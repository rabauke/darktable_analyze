
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, henrik andersson.</a>
<a name="ln4">    copyright (c) 2012 Jose Carlos Garcia Sogo</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;libs/collect.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/film.h&quot;</a>
<a name="ln24">#include &quot;common/metadata.h&quot;</a>
<a name="ln25">#include &quot;common/utility.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;control/jobs.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;libs/lib.h&quot;</a>
<a name="ln32">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln33">#include &quot;views/view.h&quot;</a>
<a name="ln34">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln35">#include &quot;osx/osx.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">DT_MODULE(1)</a>
<a name="ln39"> </a>
<a name="ln40">#define MAX_RULES 10</a>
<a name="ln41"> </a>
<a name="ln42">#define PARAM_STRING_SIZE 256 // FIXME: is this enough !?</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_lib_collect_rule_t</a>
<a name="ln45">{</a>
<a name="ln46">  int num;</a>
<a name="ln47">  GtkWidget *hbox;</a>
<a name="ln48">  GtkComboBox *combo;</a>
<a name="ln49">  GtkWidget *text;</a>
<a name="ln50">  GtkWidget *button;</a>
<a name="ln51">  gboolean typing;</a>
<a name="ln52">} dt_lib_collect_rule_t;</a>
<a name="ln53"> </a>
<a name="ln54">typedef struct dt_lib_collect_t</a>
<a name="ln55">{</a>
<a name="ln56">  dt_lib_collect_rule_t rule[MAX_RULES];</a>
<a name="ln57">  int active_rule;</a>
<a name="ln58">  int nb_rules;</a>
<a name="ln59"> </a>
<a name="ln60">  GtkTreeView *view;</a>
<a name="ln61">  int view_rule;</a>
<a name="ln62"> </a>
<a name="ln63">  GtkTreeModel *treefilter;</a>
<a name="ln64">  GtkTreeModel *listfilter;</a>
<a name="ln65">  GtkScrolledWindow *scrolledwindow;</a>
<a name="ln66"> </a>
<a name="ln67">  GtkScrolledWindow *sw2;</a>
<a name="ln68"> </a>
<a name="ln69">  gboolean singleclick;</a>
<a name="ln70">  struct dt_lib_collect_params_t *params;</a>
<a name="ln71">} dt_lib_collect_t;</a>
<a name="ln72"> </a>
<a name="ln73">typedef struct dt_lib_collect_params_rule_t</a>
<a name="ln74">{</a>
<a name="ln75">  uint32_t item : 16;</a>
<a name="ln76">  uint32_t mode : 16;</a>
<a name="ln77">  char string[PARAM_STRING_SIZE];</a>
<a name="ln78">} dt_lib_collect_params_rule_t;</a>
<a name="ln79"> </a>
<a name="ln80">typedef struct dt_lib_collect_params_t</a>
<a name="ln81">{</a>
<a name="ln82">  uint32_t rules;</a>
<a name="ln83">  dt_lib_collect_params_rule_t rule[MAX_RULES];</a>
<a name="ln84">} dt_lib_collect_params_t;</a>
<a name="ln85"> </a>
<a name="ln86">typedef enum dt_lib_collect_cols_t</a>
<a name="ln87">{</a>
<a name="ln88">  DT_LIB_COLLECT_COL_TEXT = 0,</a>
<a name="ln89">  DT_LIB_COLLECT_COL_ID,</a>
<a name="ln90">  DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln91">  DT_LIB_COLLECT_COL_PATH,</a>
<a name="ln92">  DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln93">  DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln94">  DT_LIB_COLLECT_COL_COUNT,</a>
<a name="ln95">  DT_LIB_COLLECT_NUM_COLS</a>
<a name="ln96">} dt_lib_collect_cols_t;</a>
<a name="ln97"> </a>
<a name="ln98">typedef struct _range_t</a>
<a name="ln99">{</a>
<a name="ln100">  gchar *start;</a>
<a name="ln101">  gchar *stop;</a>
<a name="ln102">  GtkTreePath *path1;</a>
<a name="ln103">  GtkTreePath *path2;</a>
<a name="ln104">} _range_t;</a>
<a name="ln105"> </a>
<a name="ln106">static void _lib_collect_gui_update(dt_lib_module_t *self);</a>
<a name="ln107">static void _lib_folders_update_collection(const gchar *filmroll);</a>
<a name="ln108">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln109">                          dt_lib_collect_rule_t *d);</a>
<a name="ln110">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr);</a>
<a name="ln111">static void collection_updated(gpointer instance, gpointer self);</a>
<a name="ln112">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d);</a>
<a name="ln113"> </a>
<a name="ln114">const char *name(dt_lib_module_t *self)</a>
<a name="ln115">{</a>
<a name="ln116">  return _(&quot;collect images&quot;);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void init_presets(dt_lib_module_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Update the params struct with active ruleset */</a>
<a name="ln124">static void _lib_collect_update_params(dt_lib_collect_t *d)</a>
<a name="ln125">{</a>
<a name="ln126">  /* reset params */</a>
<a name="ln127">  dt_lib_collect_params_t *p = d-&gt;params;</a>
<a name="ln128">  memset(p, 0, sizeof(dt_lib_collect_params_t));</a>
<a name="ln129"> </a>
<a name="ln130">  /* for each active rule set update params */</a>
<a name="ln131">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln132">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln133">  char confname[200] = { 0 };</a>
<a name="ln134">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln135">  {</a>
<a name="ln136">    /* get item */</a>
<a name="ln137">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln138">    p-&gt;rule[i].item = dt_conf_get_int(confname);</a>
<a name="ln139"> </a>
<a name="ln140">    /* get mode */</a>
<a name="ln141">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln142">    p-&gt;rule[i].mode = dt_conf_get_int(confname);</a>
<a name="ln143"> </a>
<a name="ln144">    /* get string */</a>
<a name="ln145">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln146">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln147">    if(string != NULL)</a>
<a name="ln148">    {</a>
<a name="ln149">      snprintf(p-&gt;rule[i].string, PARAM_STRING_SIZE, &quot;%s&quot;, string);</a>
<a name="ln150">      g_free(string);</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    // fprintf(stderr,&quot;[%i] %d,%d,%s\n&quot;,i, p-&gt;rule[i].item, p-&gt;rule[i].mode,  p-&gt;rule[i].string);</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  p-&gt;rules = active + 1;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln160">{</a>
<a name="ln161">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln162"> </a>
<a name="ln163">  /* allocate a copy of params to return, freed by caller */</a>
<a name="ln164">  *size = sizeof(dt_lib_collect_params_t);</a>
<a name="ln165">  void *p = malloc(*size);</a>
<a name="ln166">  memcpy(p, ((dt_lib_collect_t *)self-&gt;data)-&gt;params, *size);</a>
<a name="ln167">  return p;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln171">{</a>
<a name="ln172">  /* update conf settings from params */</a>
<a name="ln173">  dt_lib_collect_params_t *p = (dt_lib_collect_params_t *)params;</a>
<a name="ln174">  char confname[200] = { 0 };</a>
<a name="ln175"> </a>
<a name="ln176">  for(uint32_t i = 0; i &lt; p-&gt;rules; i++)</a>
<a name="ln177">  {</a>
<a name="ln178">    /* set item */</a>
<a name="ln179">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln180">    dt_conf_set_int(confname, p-&gt;rule[i].item);</a>
<a name="ln181"> </a>
<a name="ln182">    /* set mode */</a>
<a name="ln183">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln184">    dt_conf_set_int(confname, p-&gt;rule[i].mode);</a>
<a name="ln185"> </a>
<a name="ln186">    /* set string */</a>
<a name="ln187">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln188">    dt_conf_set_string(confname, p-&gt;rule[i].string);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  /* set number of rules */</a>
<a name="ln192">  g_strlcpy(confname, &quot;plugins/lighttable/collect/num_rules&quot;, sizeof(confname));</a>
<a name="ln193">  dt_conf_set_int(confname, p-&gt;rules);</a>
<a name="ln194"> </a>
<a name="ln195">  /* update internal params */</a>
<a name="ln196">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln197"> </a>
<a name="ln198">  /* update ui */</a>
<a name="ln199">  _lib_collect_gui_update(self);</a>
<a name="ln200"> </a>
<a name="ln201">  /* update view */</a>
<a name="ln202">  dt_collection_update_query(darktable.collection);</a>
<a name="ln203"> </a>
<a name="ln204">  return 0;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">const char **views(dt_lib_module_t *self)</a>
<a name="ln209">{</a>
<a name="ln210">  static const char *v[] = {&quot;lighttable&quot;, &quot;map&quot;, &quot;print&quot;, NULL};</a>
<a name="ln211">  return v;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln215">{</a>
<a name="ln216">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">static void view_popup_menu_onSearchFilmroll(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln220">{</a>
<a name="ln221">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln222">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln223">  GtkWidget *filechooser;</a>
<a name="ln224"> </a>
<a name="ln225">  GtkTreeSelection *selection;</a>
<a name="ln226">  GtkTreeIter iter, child;</a>
<a name="ln227">  GtkTreeModel *model;</a>
<a name="ln228"> </a>
<a name="ln229">  gchar *tree_path = NULL;</a>
<a name="ln230">  gchar *new_path = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln233">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln234">  if (!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln235">    return;</a>
<a name="ln236"> </a>
<a name="ln237">  child = iter;</a>
<a name="ln238">  gtk_tree_model_iter_parent(model, &amp;iter, &amp;child);</a>
<a name="ln239">  gtk_tree_model_get(model, &amp;child, DT_LIB_COLLECT_COL_PATH, &amp;tree_path, -1);</a>
<a name="ln240"> </a>
<a name="ln241">  filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln242">    _(&quot;search filmroll&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln243">    GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln244">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln245">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln246">#endif</a>
<a name="ln247"> </a>
<a name="ln248">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln249">  if(tree_path != NULL)</a>
<a name="ln250">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), tree_path);</a>
<a name="ln251">  else</a>
<a name="ln252">    goto error;</a>
<a name="ln253"> </a>
<a name="ln254">  // run the dialog</a>
<a name="ln255">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln256">  {</a>
<a name="ln257">    gint id = -1;</a>
<a name="ln258">    sqlite3_stmt *stmt;</a>
<a name="ln259">    gchar *query = NULL;</a>
<a name="ln260"> </a>
<a name="ln261">    gchar *uri = NULL;</a>
<a name="ln262">    uri = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln263">    new_path = g_filename_from_uri(uri, NULL, NULL);</a>
<a name="ln264">    g_free(uri);</a>
<a name="ln265">    if(new_path)</a>
<a name="ln266">    {</a>
<a name="ln267">      gchar *old = NULL;</a>
<a name="ln268">      query = dt_util_dstrcat(query, &quot;SELECT id, folder FROM main.film_rolls WHERE folder LIKE '%s%%'&quot;, tree_path);</a>
<a name="ln269">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln270">      g_free(query);</a>
<a name="ln271">      query = NULL;</a>
<a name="ln272"> </a>
<a name="ln273">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln274">      {</a>
<a name="ln275">        id = sqlite3_column_int(stmt, 0);</a>
<a name="ln276">        old = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln277"> </a>
<a name="ln278">        query = NULL;</a>
<a name="ln279">        query = dt_util_dstrcat(query, &quot;UPDATE main.film_rolls SET folder=?1 WHERE id=?2&quot;);</a>
<a name="ln280"> </a>
<a name="ln281">        gchar trailing[1024] = { 0 };</a>
<a name="ln282">        gchar final[1024] = { 0 };</a>
<a name="ln283"> </a>
<a name="ln284">        if(g_strcmp0(old, tree_path))</a>
<a name="ln285">        {</a>
<a name="ln286">          g_snprintf(trailing, sizeof(trailing), &quot;%s&quot;, old + strlen(tree_path) + 1);</a>
<a name="ln287">          g_snprintf(final, sizeof(final), &quot;%s/%s&quot;, new_path, trailing);</a>
<a name="ln288">        }</a>
<a name="ln289">        else</a>
<a name="ln290">        {</a>
<a name="ln291">          g_snprintf(final, sizeof(final), &quot;%s&quot;, new_path);</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">        sqlite3_stmt *stmt2;</a>
<a name="ln295">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt2, NULL);</a>
<a name="ln296">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 1, final, -1, SQLITE_STATIC);</a>
<a name="ln297">        DT_DEBUG_SQLITE3_BIND_INT(stmt2, 2, id);</a>
<a name="ln298">        sqlite3_step(stmt2);</a>
<a name="ln299">        sqlite3_finalize(stmt2);</a>
<a name="ln300">      }</a>
<a name="ln301">      sqlite3_finalize(stmt);</a>
<a name="ln302">      g_free(query);</a>
<a name="ln303"> </a>
<a name="ln304">      /* reset filter so that view isn't empty */</a>
<a name="ln305">      dt_view_filter_reset(darktable.view_manager, FALSE);</a>
<a name="ln306"> </a>
<a name="ln307">      /* update collection to view missing filmroll */</a>
<a name="ln308">      _lib_folders_update_collection(new_path);</a>
<a name="ln309"> </a>
<a name="ln310">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln311">    }</a>
<a name="ln312">    else</a>
<a name="ln313">      goto error;</a>
<a name="ln314">  }</a>
<a name="ln315">  g_free(tree_path);</a>
<a name="ln316">  g_free(new_path);</a>
<a name="ln317">  gtk_widget_destroy(filechooser);</a>
<a name="ln318">  return;</a>
<a name="ln319"> </a>
<a name="ln320">error:</a>
<a name="ln321">  /* Something wrong happened */</a>
<a name="ln322">  gtk_widget_destroy(filechooser);</a>
<a name="ln323">  dt_control_log(_(&quot;problem selecting new path for the filmroll in %s&quot;), tree_path);</a>
<a name="ln324"> </a>
<a name="ln325">  g_free(tree_path);</a>
<a name="ln326">  g_free(new_path);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">static void view_popup_menu_onRemove(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln330">{</a>
<a name="ln331">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln332"> </a>
<a name="ln333">  GtkTreeSelection *selection;</a>
<a name="ln334">  GtkTreeIter iter, model_iter;</a>
<a name="ln335">  GtkTreeModel *model;</a>
<a name="ln336"> </a>
<a name="ln337">  gchar *filmroll_path = NULL;</a>
<a name="ln338">  gchar *fullq = NULL;</a>
<a name="ln339"> </a>
<a name="ln340">  /* Get info about the filmroll (or parent) selected */</a>
<a name="ln341">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln342">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln343">  if (gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln344">  {</a>
<a name="ln345">    gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;filmroll_path, -1);</a>
<a name="ln346"> </a>
<a name="ln347">    /* Clean selected images, and add to the table those which are going to be deleted */</a>
<a name="ln348">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln349"> </a>
<a name="ln350">    fullq = dt_util_dstrcat(fullq, &quot;INSERT INTO main.selected_images SELECT id FROM main.images WHERE film_id IN &quot;</a>
<a name="ln351">                                   &quot;(SELECT id FROM main.film_rolls WHERE folder LIKE '%s%%')&quot;,</a>
<a name="ln352">                            filmroll_path);</a>
<a name="ln353">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), fullq, NULL, NULL, NULL);</a>
<a name="ln354"> </a>
<a name="ln355">    if (dt_control_remove_images())</a>
<a name="ln356">    {</a>
<a name="ln357">      gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model), &amp;model_iter, &amp;iter);</a>
<a name="ln358">      gtk_tree_store_remove(GTK_TREE_STORE(gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model))),</a>
<a name="ln359">                            &amp;model_iter);</a>
<a name="ln360">    }</a>
<a name="ln361">  }</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">static void view_popup_menu(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln365">{</a>
<a name="ln366">  GtkWidget *menu, *menuitem;</a>
<a name="ln367"> </a>
<a name="ln368">  menu = gtk_menu_new();</a>
<a name="ln369"> </a>
<a name="ln370">  menuitem = gtk_menu_item_new_with_label(_(&quot;search filmroll...&quot;));</a>
<a name="ln371">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onSearchFilmroll, treeview);</a>
<a name="ln372">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln373"> </a>
<a name="ln374">  menuitem = gtk_menu_item_new_with_label(_(&quot;remove...&quot;));</a>
<a name="ln375">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln376">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onRemove, treeview);</a>
<a name="ln377"> </a>
<a name="ln378">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln379"> </a>
<a name="ln380">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln381">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln382">#else</a>
<a name="ln383">  /* Note: event can be NULL here when called from view_onPopupMenu;</a>
<a name="ln384">   *  gdk_event_get_time() accepts a NULL argument */</a>
<a name="ln385">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, (event != NULL) ? event-&gt;button : 0,</a>
<a name="ln386">                 gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln387">#endif</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">static gboolean view_onButtonPressed(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln391">{</a>
<a name="ln392">  if((d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln393">     || (!d-&gt;singleclick &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1)</a>
<a name="ln394">     || (d-&gt;singleclick &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 1))</a>
<a name="ln395">  {</a>
<a name="ln396">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln397">    GtkTreePath *path = NULL;</a>
<a name="ln398"> </a>
<a name="ln399">    /* Get tree path for row that was clicked */</a>
<a name="ln400">    if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), (gint)event-&gt;x, (gint)event-&gt;y, &amp;path, NULL, NULL,</a>
<a name="ln401">                                     NULL))</a>
<a name="ln402">    {</a>
<a name="ln403">      if(d-&gt;singleclick &amp;&amp; (event-&gt;state &amp; GDK_SHIFT_MASK) &amp;&amp; gtk_tree_selection_count_selected_rows(selection) &gt; 0</a>
<a name="ln404">         &amp;&amp; (d-&gt;view_rule == DT_COLLECTION_PROP_DAY || d-&gt;view_rule == DT_COLLECTION_PROP_TIME</a>
<a name="ln405">             || d-&gt;view_rule == DT_COLLECTION_PROP_APERTURE || d-&gt;view_rule == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln406">             || d-&gt;view_rule == DT_COLLECTION_PROP_ISO || d-&gt;view_rule == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln407">             || d-&gt;view_rule == DT_COLLECTION_PROP_ASPECT_RATIO))</a>
<a name="ln408">      {</a>
<a name="ln409">        // range selection</a>
<a name="ln410">        GList *sels = gtk_tree_selection_get_selected_rows(selection, NULL);</a>
<a name="ln411">        GtkTreePath *path2 = (GtkTreePath *)g_list_nth_data(sels, 0);</a>
<a name="ln412">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln413">        if(gtk_tree_path_compare(path, path2) &gt; 0)</a>
<a name="ln414">          gtk_tree_selection_select_range(selection, path, path2);</a>
<a name="ln415">        else</a>
<a name="ln416">          gtk_tree_selection_select_range(selection, path2, path);</a>
<a name="ln417">      }</a>
<a name="ln418">      else</a>
<a name="ln419">      {</a>
<a name="ln420">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln421">        gtk_tree_selection_select_path(selection, path);</a>
<a name="ln422">      }</a>
<a name="ln423">    }</a>
<a name="ln424"> </a>
<a name="ln425">    /* single click on folder with the right mouse button? */</a>
<a name="ln426">    if(d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; (event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3))</a>
<a name="ln427">      view_popup_menu(treeview, event, d);</a>
<a name="ln428">    else</a>
<a name="ln429">      row_activated_with_event(GTK_TREE_VIEW(treeview), path, NULL, event, d);</a>
<a name="ln430"> </a>
<a name="ln431">    gtk_tree_path_free(path);</a>
<a name="ln432"> </a>
<a name="ln433">    if((d-&gt;view_rule == DT_COLLECTION_PROP_DAY || d-&gt;view_rule == DT_COLLECTION_PROP_TIME</a>
<a name="ln434">        || d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS || d-&gt;view_rule == DT_COLLECTION_PROP_TAG)</a>
<a name="ln435">       &amp;&amp; !(event-&gt;state &amp; GDK_SHIFT_MASK))</a>
<a name="ln436">      return FALSE; /* we allow propagation (expand/collapse row) */</a>
<a name="ln437">    else</a>
<a name="ln438">      return TRUE; /* we stop propagation */</a>
<a name="ln439">  }</a>
<a name="ln440">  return FALSE; /* we did not handle this */</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">static gboolean view_onPopupMenu(GtkWidget *treeview, dt_lib_collect_t *d)</a>
<a name="ln444">{</a>
<a name="ln445">  if(d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS) return FALSE;</a>
<a name="ln446"> </a>
<a name="ln447">  view_popup_menu(treeview, NULL, d);</a>
<a name="ln448"> </a>
<a name="ln449">  return TRUE; /* we handled this */</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">static dt_lib_collect_t *get_collect(dt_lib_collect_rule_t *r)</a>
<a name="ln453">{</a>
<a name="ln454">  dt_lib_collect_t *d = (dt_lib_collect_t *)(((char *)r) - r-&gt;num * sizeof(dt_lib_collect_rule_t));</a>
<a name="ln455">  return d;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">static gboolean list_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln459">{</a>
<a name="ln460">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln461">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln462">  gchar *str = NULL;</a>
<a name="ln463"> </a>
<a name="ln464">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln465"> </a>
<a name="ln466">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln467">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln468"> </a>
<a name="ln469">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln470">  {</a>
<a name="ln471">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln472">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln473">  }</a>
<a name="ln474"> </a>
<a name="ln475">  g_free(haystack);</a>
<a name="ln476">  g_free(needle);</a>
<a name="ln477">  g_free(str);</a>
<a name="ln478"> </a>
<a name="ln479">  return FALSE;</a>
<a name="ln480">}</a>
<a name="ln481">static gboolean range_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln482">{</a>
<a name="ln483">  _range_t *range = (_range_t *)data;</a>
<a name="ln484">  gchar *str = NULL;</a>
<a name="ln485"> </a>
<a name="ln486">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln487"> </a>
<a name="ln488">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln489">  gchar *needle;</a>
<a name="ln490">  if(range-&gt;path1)</a>
<a name="ln491">    needle = g_utf8_strdown(range-&gt;stop, -1);</a>
<a name="ln492">  else</a>
<a name="ln493">    needle = g_utf8_strdown(range-&gt;start, -1);</a>
<a name="ln494"> </a>
<a name="ln495">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln496">  {</a>
<a name="ln497">    if(range-&gt;path1)</a>
<a name="ln498">    {</a>
<a name="ln499">      range-&gt;path2 = gtk_tree_path_copy(path);</a>
<a name="ln500">      return TRUE;</a>
<a name="ln501">    }</a>
<a name="ln502">    else</a>
<a name="ln503">      range-&gt;path1 = gtk_tree_path_copy(path);</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  g_free(haystack);</a>
<a name="ln507">  g_free(needle);</a>
<a name="ln508">  g_free(str);</a>
<a name="ln509"> </a>
<a name="ln510">  return FALSE;</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">static gboolean tree_expand(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln514">{</a>
<a name="ln515">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln516">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln517">  gchar *str = NULL;</a>
<a name="ln518">  gchar *txt = NULL;</a>
<a name="ln519">  gboolean startwildcard = FALSE;</a>
<a name="ln520"> </a>
<a name="ln521">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_TEXT, &amp;txt, -1);</a>
<a name="ln522"> </a>
<a name="ln523">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln524">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln525">  gchar *txt2 = g_utf8_strdown(txt, -1);</a>
<a name="ln526"> </a>
<a name="ln527">  if(g_str_has_prefix(needle, &quot;%&quot;)) startwildcard = TRUE;</a>
<a name="ln528">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln529">  if(g_str_has_suffix(haystack, &quot;%&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln530">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln531">  {</a>
<a name="ln532">    if(g_str_has_suffix(needle, &quot;|&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln533">    if(g_str_has_suffix(haystack, &quot;|&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln534">  }</a>
<a name="ln535">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln536">  {</a>
<a name="ln537">    if(g_str_has_suffix(needle, &quot;/&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln538">    if(g_str_has_suffix(haystack, &quot;/&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln539">  }</a>
<a name="ln540">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_DAY</a>
<a name="ln541">          || gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TIME)</a>
<a name="ln542">  {</a>
<a name="ln543">    if(g_str_has_suffix(needle, &quot;:&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln544">    if(g_str_has_suffix(haystack, &quot;:&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln545">  }</a>
<a name="ln546"> </a>
<a name="ln547">  if(dr-&gt;typing &amp;&amp; g_strrstr(txt2, needle) != NULL)</a>
<a name="ln548">  {</a>
<a name="ln549">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln550">  }</a>
<a name="ln551"> </a>
<a name="ln552">  if(strlen(needle)==0)</a>
<a name="ln553">  {</a>
<a name="ln554">    //nothing to do, we keep the tree collapsed</a>
<a name="ln555">  }</a>
<a name="ln556">  else if(strcmp(haystack, needle) == 0)</a>
<a name="ln557">  {</a>
<a name="ln558">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln559">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln560">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln561">  }</a>
<a name="ln562">  else if(startwildcard &amp;&amp; g_strrstr(haystack, needle+1) != NULL)</a>
<a name="ln563">  {</a>
<a name="ln564">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln565">  }</a>
<a name="ln566">  else if(g_str_has_prefix(haystack, needle))</a>
<a name="ln567">  {</a>
<a name="ln568">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  g_free(haystack);</a>
<a name="ln572">  g_free(needle);</a>
<a name="ln573">  g_free(txt2);</a>
<a name="ln574">  g_free(str);</a>
<a name="ln575">  g_free(txt);</a>
<a name="ln576"> </a>
<a name="ln577">  return FALSE;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">static gboolean list_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln581">{</a>
<a name="ln582">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln583">  gchar *str = NULL;</a>
<a name="ln584">  gboolean visible;</a>
<a name="ln585"> </a>
<a name="ln586">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln587"> </a>
<a name="ln588">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln589">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln590">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln591"> </a>
<a name="ln592">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln593">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln594">     || property == DT_COLLECTION_PROP_ISO)</a>
<a name="ln595">  {</a>
<a name="ln596">    // handle of numeric value, which can have some operator before the text</a>
<a name="ln597">    visible = TRUE;</a>
<a name="ln598">    gchar *operator, *number, *number2;</a>
<a name="ln599">    dt_collection_split_operator_number(needle, &amp;number, &amp;number2, &amp;operator);</a>
<a name="ln600">    if(number)</a>
<a name="ln601">    {</a>
<a name="ln602">      float nb1 = g_strtod(number, NULL);</a>
<a name="ln603">      float nb2 = g_strtod(haystack, NULL);</a>
<a name="ln604">      if(operator&amp;&amp; strcmp(operator, &quot;&gt;&quot;) == 0)</a>
<a name="ln605">      {</a>
<a name="ln606">        visible = (nb2 &gt; nb1);</a>
<a name="ln607">      }</a>
<a name="ln608">      else if(operator&amp;&amp; strcmp(operator, &quot;&gt;=&quot;) == 0)</a>
<a name="ln609">      {</a>
<a name="ln610">        visible = (nb2 &gt;= nb1);</a>
<a name="ln611">      }</a>
<a name="ln612">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&quot;) == 0)</a>
<a name="ln613">      {</a>
<a name="ln614">        visible = (nb2 &lt; nb1);</a>
<a name="ln615">      }</a>
<a name="ln616">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;=&quot;) == 0)</a>
<a name="ln617">      {</a>
<a name="ln618">        visible = (nb2 &lt;= nb1);</a>
<a name="ln619">      }</a>
<a name="ln620">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&gt;&quot;) == 0)</a>
<a name="ln621">      {</a>
<a name="ln622">        visible = (nb1 != nb2);</a>
<a name="ln623">      }</a>
<a name="ln624">      else if(operator&amp;&amp; number2 &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln625">      {</a>
<a name="ln626">        float nb3 = g_strtod(number2, NULL);</a>
<a name="ln627">        visible = (nb2 &gt;= nb1 &amp;&amp; nb2 &lt;= nb3);</a>
<a name="ln628">      }</a>
<a name="ln629">      else</a>
<a name="ln630">      {</a>
<a name="ln631">        visible = (nb1 == nb2);</a>
<a name="ln632">      }</a>
<a name="ln633">    }</a>
<a name="ln634">    g_free(operator);</a>
<a name="ln635">    g_free(number);</a>
<a name="ln636">    g_free(number2);</a>
<a name="ln637">  }</a>
<a name="ln638">  else</a>
<a name="ln639">  {</a>
<a name="ln640">    if(g_str_has_prefix(needle, &quot;%&quot;))</a>
<a name="ln641">      visible = (g_strrstr(haystack, needle + 1) != NULL);</a>
<a name="ln642">    else</a>
<a name="ln643">      visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  g_free(haystack);</a>
<a name="ln647">  g_free(needle);</a>
<a name="ln648"> </a>
<a name="ln649">  g_free(str);</a>
<a name="ln650"> </a>
<a name="ln651">  gtk_list_store_set(GTK_LIST_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln652">  return FALSE;</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">static gboolean tree_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln656">{</a>
<a name="ln657">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln658">  gchar *str = NULL;</a>
<a name="ln659">  gboolean cur_state, visible;</a>
<a name="ln660"> </a>
<a name="ln661">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_VISIBLE, &amp;cur_state, -1);</a>
<a name="ln662"> </a>
<a name="ln663">  if(dr-&gt;typing == FALSE &amp;&amp; !cur_state)</a>
<a name="ln664">  {</a>
<a name="ln665">    visible = TRUE;</a>
<a name="ln666">  }</a>
<a name="ln667">  else</a>
<a name="ln668">  {</a>
<a name="ln669">    gchar *haystack = g_utf8_strdown(str, -1),</a>
<a name="ln670">          *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln671">    visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln672">    g_free(haystack);</a>
<a name="ln673">    g_free(needle);</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  g_free(str);</a>
<a name="ln677"> </a>
<a name="ln678">  gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln679">  return FALSE;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">static gboolean tree_reveal_func(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln683">{</a>
<a name="ln684">  gboolean state;</a>
<a name="ln685">  GtkTreeIter parent, child = *iter;</a>
<a name="ln686"> </a>
<a name="ln687">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln688">  if(!state) return FALSE;</a>
<a name="ln689"> </a>
<a name="ln690">  while(gtk_tree_model_iter_parent(model, &amp;parent, &amp;child))</a>
<a name="ln691">  {</a>
<a name="ln692">    gtk_tree_model_get(model, &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln693">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, TRUE, -1);</a>
<a name="ln694">    child = parent;</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  return FALSE;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">static void tree_set_visibility(GtkTreeModel *model, gpointer data)</a>
<a name="ln701">{</a>
<a name="ln702">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_match_string, data);</a>
<a name="ln703"> </a>
<a name="ln704">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_reveal_func, NULL);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">static void _lib_folders_update_collection(const gchar *filmroll)</a>
<a name="ln708">{</a>
<a name="ln709"> </a>
<a name="ln710">  gchar *complete_query = NULL;</a>
<a name="ln711"> </a>
<a name="ln712">  // remove from selected images where not in this query.</a>
<a name="ln713">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln714">  const gchar *cquery = dt_collection_get_query(darktable.collection);</a>
<a name="ln715">  // complete_query = NULL;</a>
<a name="ln716">  if(cquery &amp;&amp; cquery[0] != '\0')</a>
<a name="ln717">  {</a>
<a name="ln718">    complete_query</a>
<a name="ln719">        = dt_util_dstrcat(complete_query, &quot;DELETE FROM main.selected_images WHERE imgid NOT IN (%s)&quot;, cquery);</a>
<a name="ln720">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), complete_query, -1, &amp;stmt, NULL);</a>
<a name="ln721">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln722">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln723">    sqlite3_step(stmt);</a>
<a name="ln724">    sqlite3_finalize(stmt);</a>
<a name="ln725"> </a>
<a name="ln726">    /* free allocated strings */</a>
<a name="ln727">    g_free(complete_query);</a>
<a name="ln728">  }</a>
<a name="ln729"> </a>
<a name="ln730">  /* raise signal of collection change, only if this is an original */</a>
<a name="ln731">  if(!darktable.collection-&gt;clone) dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">static void set_properties(dt_lib_collect_rule_t *dr)</a>
<a name="ln735">{</a>
<a name="ln736">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln737">  const gchar *text = gtk_entry_get_text(GTK_ENTRY(dr-&gt;text));</a>
<a name="ln738"> </a>
<a name="ln739">  char confname[200] = { 0 };</a>
<a name="ln740">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, dr-&gt;num);</a>
<a name="ln741">  dt_conf_set_string(confname, text);</a>
<a name="ln742">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, dr-&gt;num);</a>
<a name="ln743">  dt_conf_set_int(confname, property);</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">static GtkTreeModel *_create_filtered_model(GtkTreeModel *model, dt_lib_collect_rule_t *dr)</a>
<a name="ln747">{</a>
<a name="ln748">  GtkTreeModel *filter = NULL;</a>
<a name="ln749">  GtkTreePath *path = NULL;</a>
<a name="ln750"> </a>
<a name="ln751">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln752">  {</a>
<a name="ln753">    // we search a common path to all the folders</a>
<a name="ln754">    // we'll use it as root</a>
<a name="ln755">    GtkTreeIter child, iter;</a>
<a name="ln756">    int level = 0;</a>
<a name="ln757"> </a>
<a name="ln758">    while(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) &gt; 0)</a>
<a name="ln759">    {</a>
<a name="ln760">      if(level &gt; 0)</a>
<a name="ln761">      {</a>
<a name="ln762">        sqlite3_stmt *stmt = NULL;</a>
<a name="ln763">        gchar *pth = NULL;</a>
<a name="ln764">        int id = -1;</a>
<a name="ln765">        // Check if this path also matches a filmroll</a>
<a name="ln766">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;pth, -1);</a>
<a name="ln767">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln768">                                    &quot;SELECT id FROM main.film_rolls WHERE folder LIKE ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln769">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, pth, -1, SQLITE_TRANSIENT);</a>
<a name="ln770">        if(sqlite3_step(stmt) == SQLITE_ROW) id = sqlite3_column_int(stmt, 0);</a>
<a name="ln771">        sqlite3_finalize(stmt);</a>
<a name="ln772"> </a>
<a name="ln773">        g_free(pth);</a>
<a name="ln774"> </a>
<a name="ln775">        if(id != -1)</a>
<a name="ln776">        {</a>
<a name="ln777">          // we go back to the parent, in order to show this folder</a>
<a name="ln778">          if(!gtk_tree_model_iter_parent(model, &amp;child, &amp;iter)) level = 0;</a>
<a name="ln779">          iter = child;</a>
<a name="ln780">          break;</a>
<a name="ln781">        }</a>
<a name="ln782">      }</a>
<a name="ln783">      if(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) != 1) break;</a>
<a name="ln784"> </a>
<a name="ln785">      gtk_tree_model_iter_children(model, &amp;child, level &gt; 0 ? &amp;iter : NULL);</a>
<a name="ln786">      iter = child;</a>
<a name="ln787">      level++;</a>
<a name="ln788">    }</a>
<a name="ln789"> </a>
<a name="ln790">    if(level &gt; 0)</a>
<a name="ln791">    {</a>
<a name="ln792">      if(level &gt; 0 &amp;&amp;</a>
<a name="ln793">         gtk_tree_model_iter_n_children(model, &amp;iter) == 0 &amp;&amp;</a>
<a name="ln794">         gtk_tree_model_iter_parent(model, &amp;child, &amp;iter))</a>
<a name="ln795">      {</a>
<a name="ln796">        path = gtk_tree_model_get_path(model, &amp;child);</a>
<a name="ln797">      }</a>
<a name="ln798">      else</a>
<a name="ln799">      {</a>
<a name="ln800">        path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln801">      }</a>
<a name="ln802">    }</a>
<a name="ln803">  }</a>
<a name="ln804"> </a>
<a name="ln805">  // Create filter and set virtual root</a>
<a name="ln806">  filter = gtk_tree_model_filter_new(model, path);</a>
<a name="ln807">  gtk_tree_path_free(path);</a>
<a name="ln808"> </a>
<a name="ln809">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(filter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln810"> </a>
<a name="ln811">  return filter;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">static int string_array_length(char **list)</a>
<a name="ln815">{</a>
<a name="ln816">  int length = 0;</a>
<a name="ln817">  for(; *list; list++) length++;</a>
<a name="ln818">  return length;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">// returns a NULL terminated array of path components</a>
<a name="ln822">static char **split_path(const char *path)</a>
<a name="ln823">{</a>
<a name="ln824">  if(!path || !*path) return NULL;</a>
<a name="ln825"> </a>
<a name="ln826">  char **result;</a>
<a name="ln827">  char **tokens = g_strsplit(path, G_DIR_SEPARATOR_S, -1);</a>
<a name="ln828"> </a>
<a name="ln829">#ifdef _WIN32</a>
<a name="ln830"> </a>
<a name="ln831">  if(! (g_ascii_isalpha(tokens[0][0]) &amp;&amp; tokens[0][strlen(tokens[0]) - 1] == ':') )</a>
<a name="ln832">  {</a>
<a name="ln833">    g_strfreev(tokens);</a>
<a name="ln834">    tokens = NULL;</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  result = tokens;</a>
<a name="ln838"> </a>
<a name="ln839">#else</a>
<a name="ln840"> </a>
<a name="ln841">  // there are size + 1 elements in tokens -- the final NULL! we want to ignore it.</a>
<a name="ln842">  unsigned int size = g_strv_length(tokens);</a>
<a name="ln843"> </a>
<a name="ln844">  result = malloc(size * sizeof(char *));</a>
<a name="ln845">  for(unsigned int i = 0; i &lt; size; i++)</a>
<a name="ln846">    result[i] = tokens[i + 1];</a>
<a name="ln847"> </a>
<a name="ln848">  g_free(tokens[0]);</a>
<a name="ln849">  g_free(tokens);</a>
<a name="ln850"> </a>
<a name="ln851">#endif</a>
<a name="ln852"> </a>
<a name="ln853">  return result;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">typedef struct name_key_tuple_t</a>
<a name="ln857">{</a>
<a name="ln858">  char *name, *collate_key;</a>
<a name="ln859">  int count;</a>
<a name="ln860">} name_key_tuple_t;</a>
<a name="ln861"> </a>
<a name="ln862">static void free_tuple(gpointer data)</a>
<a name="ln863">{</a>
<a name="ln864">  name_key_tuple_t *tuple = (name_key_tuple_t *)data;</a>
<a name="ln865">  g_free(tuple-&gt;name);</a>
<a name="ln866">  g_free(tuple-&gt;collate_key);</a>
<a name="ln867">  free(tuple);</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static gint sort_folder_tag(gconstpointer a, gconstpointer b)</a>
<a name="ln871">{</a>
<a name="ln872">  const name_key_tuple_t *tuple_a = (const name_key_tuple_t *)a;</a>
<a name="ln873">  const name_key_tuple_t *tuple_b = (const name_key_tuple_t *)b;</a>
<a name="ln874"> </a>
<a name="ln875">  return g_strcmp0(tuple_a-&gt;collate_key, tuple_b-&gt;collate_key);</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">// create a key such that &quot;darktable|&quot; is coming first, and the rest is ordered such that sub tags are coming directly</a>
<a name="ln879">// behind their parent</a>
<a name="ln880">static char *tag_collate_key(char *tag)</a>
<a name="ln881">{</a>
<a name="ln882">  size_t len = strlen(tag);</a>
<a name="ln883">  char *result = g_malloc(len + 2);</a>
<a name="ln884">  if(g_str_has_prefix(tag, &quot;darktable|&quot;))</a>
<a name="ln885">    *result = '\1';</a>
<a name="ln886">  else</a>
<a name="ln887">    *result = '\2';</a>
<a name="ln888">  memcpy(result + 1, tag, len + 1);</a>
<a name="ln889">  for(char *iter = result + 1; *iter; iter++)</a>
<a name="ln890">    if(*iter == '|') *iter = '\1';</a>
<a name="ln891">  return result;</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894"> </a>
<a name="ln895">void tree_count_show(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln896">                     gpointer data)</a>
<a name="ln897">{</a>
<a name="ln898">  gchar *name;</a>
<a name="ln899">  guint count;</a>
<a name="ln900"> </a>
<a name="ln901">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_TEXT, &amp;name, DT_LIB_COLLECT_COL_COUNT, &amp;count, -1);</a>
<a name="ln902">  if (!count)</a>
<a name="ln903">  {</a>
<a name="ln904">    g_object_set(renderer, &quot;text&quot;, name, NULL);</a>
<a name="ln905">  }</a>
<a name="ln906">  else</a>
<a name="ln907">  {</a>
<a name="ln908">    gchar *coltext = g_strdup_printf(&quot;%s (%d)&quot;, name, count);</a>
<a name="ln909">    g_object_set(renderer, &quot;text&quot;, coltext, NULL);</a>
<a name="ln910">    g_free(coltext);</a>
<a name="ln911">  }</a>
<a name="ln912"> </a>
<a name="ln913">  g_free(name);</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">static const char *UNCATEGORIZED_TAG = N_(&quot;uncategorized&quot;);</a>
<a name="ln917">static void tree_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln918">{</a>
<a name="ln919">  // update related list</a>
<a name="ln920">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln921">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln922">  const gboolean folders = (property == DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln923">  const gboolean tags = (property == DT_COLLECTION_PROP_TAG);</a>
<a name="ln924">  const gboolean days = (property == DT_COLLECTION_PROP_DAY);</a>
<a name="ln925">  const gboolean times = (property == DT_COLLECTION_PROP_TIME);</a>
<a name="ln926">  const char *format_separator = folders ? &quot;%s&quot; G_DIR_SEPARATOR_S :</a>
<a name="ln927">  days || times ? &quot;%s:&quot; : &quot;%s|&quot;;</a>
<a name="ln928">  int insert_position = tags ? 0 : -1;</a>
<a name="ln929"> </a>
<a name="ln930">  set_properties(dr);</a>
<a name="ln931"> </a>
<a name="ln932">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;treefilter));</a>
<a name="ln933"> </a>
<a name="ln934">  if(d-&gt;view_rule != property)</a>
<a name="ln935">  {</a>
<a name="ln936">    // tree creation/recreation</a>
<a name="ln937">    sqlite3_stmt *stmt;</a>
<a name="ln938">    GtkTreeIter uncategorized = { 0 };</a>
<a name="ln939">    GtkTreeIter temp;</a>
<a name="ln940"> </a>
<a name="ln941">    g_object_ref(model);</a>
<a name="ln942">    g_object_unref(d-&gt;treefilter);</a>
<a name="ln943">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln944">    gtk_tree_store_clear(GTK_TREE_STORE(model));</a>
<a name="ln945">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln946">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln947"> </a>
<a name="ln948">    /* query construction */</a>
<a name="ln949">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln950">    const char *query = g_strdup_printf(</a>
<a name="ln951">            folders ? &quot;SELECT folder, film_rolls_id, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln952">                    &quot;JOIN (SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln953">                    &quot;WHERE %s GROUP BY folder, film_rolls_id&quot;:</a>
<a name="ln954">            tags ? &quot;SELECT name, tag_id, COUNT(*) AS count FROM main.images JOIN main.tagged_images ON id = imgid &quot;</a>
<a name="ln955">                    &quot;JOIN (SELECT name, id AS tag_id FROM data.tags) ON tagid = tag_id &quot;</a>
<a name="ln956">                    &quot;WHERE %s GROUP BY name,tag_id&quot; :</a>
<a name="ln957">            days ? &quot;SELECT SUBSTR(datetime_taken, 1, 10) AS date, 1, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln958">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln959">            times ? &quot;SELECT datetime_taken AS date, 1, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln960">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln961">            NULL,</a>
<a name="ln962">            where_ext);</a>
<a name="ln963"> </a>
<a name="ln964">    g_free(where_ext);</a>
<a name="ln965">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln966"> </a>
<a name="ln967">    char **last_tokens = NULL;</a>
<a name="ln968">    int last_tokens_length = 0;</a>
<a name="ln969">    GtkTreeIter last_parent = { 0 };</a>
<a name="ln970"> </a>
<a name="ln971">    // we need to sort the names ourselves and not let sqlite handle this</a>
<a name="ln972">    // because it knows nothing about path separators.</a>
<a name="ln973">    GList *sorted_names = NULL;</a>
<a name="ln974">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln975">    {</a>
<a name="ln976">      char *name = g_strdup((const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln977">      gchar *collate_key = NULL;</a>
<a name="ln978"> </a>
<a name="ln979">      const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln980"> </a>
<a name="ln981">      if(folders)</a>
<a name="ln982">      {</a>
<a name="ln983">        char *name_folded = g_utf8_casefold(name, -1);</a>
<a name="ln984">        char *name_folded_slash = g_strconcat(name_folded, G_DIR_SEPARATOR_S, NULL);</a>
<a name="ln985">        collate_key = g_utf8_collate_key_for_filename(name_folded_slash, -1);</a>
<a name="ln986">        g_free(name_folded_slash);</a>
<a name="ln987">        g_free(name_folded);</a>
<a name="ln988">      }</a>
<a name="ln989">      else if(tags)</a>
<a name="ln990">        collate_key = tag_collate_key(name);</a>
<a name="ln991"> </a>
<a name="ln992">      name_key_tuple_t *tuple = (name_key_tuple_t *)malloc(sizeof(name_key_tuple_t));</a>
<a name="ln993">      tuple-&gt;name = name;</a>
<a name="ln994">      tuple-&gt;collate_key = collate_key;</a>
<a name="ln995">      tuple-&gt;count = count;</a>
<a name="ln996">      sorted_names = g_list_prepend(sorted_names, tuple);</a>
<a name="ln997">    }</a>
<a name="ln998">    sqlite3_finalize(stmt);</a>
<a name="ln999"> </a>
<a name="ln1000">    if(folders || tags)</a>
<a name="ln1001">      sorted_names = g_list_sort(sorted_names, sort_folder_tag);</a>
<a name="ln1002">    // we have to know about children in the hierarchy to not add single tags twice when they are</a>
<a name="ln1003">    // also a top level hierarchy</a>
<a name="ln1004">    if(tags)</a>
<a name="ln1005">      sorted_names = g_list_reverse(sorted_names);</a>
<a name="ln1006"> </a>
<a name="ln1007">    for(GList *names = sorted_names; names; names = g_list_next(names))</a>
<a name="ln1008">    {</a>
<a name="ln1009">      name_key_tuple_t *tuple = (name_key_tuple_t *)names-&gt;data;</a>
<a name="ln1010">      char *name = tuple-&gt;name;</a>
<a name="ln1011">      const int count = tuple-&gt;count;</a>
<a name="ln1012">      if(name == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1013"> </a>
<a name="ln1014">      if(tags &amp;&amp; strchr(name, '|') == 0 &amp;&amp; (last_tokens_length == 0 || strcmp(name, *last_tokens)))</a>
<a name="ln1015">      {</a>
<a name="ln1016">        /* add uncategorized root iter if not exists */</a>
<a name="ln1017">        if(!uncategorized.stamp)</a>
<a name="ln1018">        {</a>
<a name="ln1019">          gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;uncategorized, NULL, 0);</a>
<a name="ln1020">          gtk_tree_store_set(GTK_TREE_STORE(model), &amp;uncategorized, DT_LIB_COLLECT_COL_TEXT,</a>
<a name="ln1021">                             _(UNCATEGORIZED_TAG), DT_LIB_COLLECT_COL_PATH, &quot;&quot;, DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln1022">                             TRUE, -1);</a>
<a name="ln1023">          insert_position++; // we want to have this at the very top!</a>
<a name="ln1024">        }</a>
<a name="ln1025"> </a>
<a name="ln1026">        /* adding an uncategorized tag */</a>
<a name="ln1027">        gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;temp, &amp;uncategorized, 0);</a>
<a name="ln1028">        gtk_tree_store_set(GTK_TREE_STORE(model), &amp;temp, DT_LIB_COLLECT_COL_TEXT, name,</a>
<a name="ln1029">                           DT_LIB_COLLECT_COL_PATH, name, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1030">                           DT_LIB_COLLECT_COL_COUNT, count, -1);</a>
<a name="ln1031">      }</a>
<a name="ln1032">      else</a>
<a name="ln1033">      {</a>
<a name="ln1034">        char **tokens;</a>
<a name="ln1035">        if(folders)</a>
<a name="ln1036">          tokens = split_path(name);</a>
<a name="ln1037">        else if(days)</a>
<a name="ln1038">          tokens = g_strsplit(name, &quot;:&quot;, -1);</a>
<a name="ln1039">        else if(times)</a>
<a name="ln1040">          tokens = g_strsplit_set(name, &quot;: &quot;, 4);</a>
<a name="ln1041">        else</a>
<a name="ln1042">          tokens = g_strsplit(name, &quot;|&quot;, -1);</a>
<a name="ln1043"> </a>
<a name="ln1044">        if(tokens != NULL)</a>
<a name="ln1045">        {</a>
<a name="ln1046">          // find the number of common parts at the beginning of tokens and last_tokens</a>
<a name="ln1047">          GtkTreeIter parent = last_parent;</a>
<a name="ln1048">          int tokens_length = string_array_length(tokens);</a>
<a name="ln1049">          int common_length = 0;</a>
<a name="ln1050">          if(last_tokens)</a>
<a name="ln1051">          {</a>
<a name="ln1052">            while(tokens[common_length] &amp;&amp; last_tokens[common_length] &amp;&amp;</a>
<a name="ln1053">                  !g_strcmp0(tokens[common_length], last_tokens[common_length]))</a>
<a name="ln1054">            {</a>
<a name="ln1055">              common_length++;</a>
<a name="ln1056">            }</a>
<a name="ln1057"> </a>
<a name="ln1058">            // point parent iter to where the entries should be added</a>
<a name="ln1059">            for(int i = common_length; i &lt; last_tokens_length; i++)</a>
<a name="ln1060">            {</a>
<a name="ln1061">              gtk_tree_model_iter_parent(model, &amp;parent, &amp;last_parent);</a>
<a name="ln1062">              last_parent = parent;</a>
<a name="ln1063">            }</a>
<a name="ln1064">          }</a>
<a name="ln1065"> </a>
<a name="ln1066">          // insert everything from tokens past the common part</a>
<a name="ln1067"> </a>
<a name="ln1068">          char *pth = NULL;</a>
<a name="ln1069">#ifndef _WIN32</a>
<a name="ln1070">          if(folders) pth = g_strdup(&quot;/&quot;);</a>
<a name="ln1071">#endif</a>
<a name="ln1072">          for(int i = 0; i &lt; common_length; i++)</a>
<a name="ln1073">            pth = dt_util_dstrcat(pth, format_separator, tokens[i]);</a>
<a name="ln1074"> </a>
<a name="ln1075">          for(char **token = &amp;tokens[common_length]; *token; token++)</a>
<a name="ln1076">          {</a>
<a name="ln1077">            GtkTreeIter iter;</a>
<a name="ln1078"> </a>
<a name="ln1079">            pth = dt_util_dstrcat(pth, format_separator, *token);</a>
<a name="ln1080">            if(times &amp;&amp; !*(token + 1)) pth[10] = ' ';</a>
<a name="ln1081"> </a>
<a name="ln1082">            gchar *pth2 = g_strdup(pth);</a>
<a name="ln1083">            pth2[strlen(pth2) - 1] = '\0';</a>
<a name="ln1084">            gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;iter, common_length &gt; 0 ? &amp;parent : NULL, insert_position);</a>
<a name="ln1085">            gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, *token,</a>
<a name="ln1086">                               DT_LIB_COLLECT_COL_PATH, pth2, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1087">                               DT_LIB_COLLECT_COL_COUNT, (*(token + 1)?0:count), -1);</a>
<a name="ln1088"> </a>
<a name="ln1089">            // also add the item count to parents</a>
<a name="ln1090">            if((folders || days || times) &amp;&amp; !*(token + 1))</a>
<a name="ln1091">            {</a>
<a name="ln1092">              guint parentcount;</a>
<a name="ln1093">              GtkTreeIter parent2, child = iter;</a>
<a name="ln1094"> </a>
<a name="ln1095">              while(gtk_tree_model_iter_parent(model, &amp;parent2, &amp;child))</a>
<a name="ln1096">              {</a>
<a name="ln1097">                gtk_tree_model_get(model, &amp;parent2, DT_LIB_COLLECT_COL_COUNT, &amp;parentcount, -1);</a>
<a name="ln1098">                gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent2, DT_LIB_COLLECT_COL_COUNT, count + parentcount, -1);</a>
<a name="ln1099">                child = parent2;</a>
<a name="ln1100">              }</a>
<a name="ln1101">            }</a>
<a name="ln1102"> </a>
<a name="ln1103">            if(folders)</a>
<a name="ln1104">              gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln1105">                                 !(g_file_test(pth, G_FILE_TEST_IS_DIR)), -1);</a>
<a name="ln1106">            common_length++;</a>
<a name="ln1107">            parent = iter;</a>
<a name="ln1108">            g_free(pth2);</a>
<a name="ln1109">          }</a>
<a name="ln1110"> </a>
<a name="ln1111">          g_free(pth);</a>
<a name="ln1112"> </a>
<a name="ln1113">          // remember things for the next round</a>
<a name="ln1114">          if(last_tokens) g_strfreev(last_tokens);</a>
<a name="ln1115">          last_tokens = tokens;</a>
<a name="ln1116">          last_parent = parent;</a>
<a name="ln1117">          last_tokens_length = tokens_length;</a>
<a name="ln1118">        }</a>
<a name="ln1119">      }</a>
<a name="ln1120">    }</a>
<a name="ln1121">    g_list_free_full(sorted_names, free_tuple);</a>
<a name="ln1122"> </a>
<a name="ln1123"> </a>
<a name="ln1124">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1125"> </a>
<a name="ln1126">    d-&gt;treefilter = _create_filtered_model(model, dr);</a>
<a name="ln1127"> </a>
<a name="ln1128">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;view));</a>
<a name="ln1129">    if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1130">    {</a>
<a name="ln1131">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1132">    }</a>
<a name="ln1133">    else</a>
<a name="ln1134">    {</a>
<a name="ln1135">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);</a>
<a name="ln1136">    }</a>
<a name="ln1137"> </a>
<a name="ln1138">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;treefilter);</a>
<a name="ln1139">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1140">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1141"> </a>
<a name="ln1142">    g_object_unref(model);</a>
<a name="ln1143">    g_strfreev(last_tokens);</a>
<a name="ln1144"> </a>
<a name="ln1145">    d-&gt;view_rule = property;</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1149">  if(dr-&gt;typing) tree_set_visibility(model, dr);</a>
<a name="ln1150">  // we update tree expansion and selection</a>
<a name="ln1151">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1152">  gtk_tree_view_collapse_all(d-&gt;view);</a>
<a name="ln1153"> </a>
<a name="ln1154">  if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1155">  {</a>
<a name="ln1156">    // test selection range [xxx;xxx]</a>
<a name="ln1157">    GRegex *regex;</a>
<a name="ln1158">    GMatchInfo *match_info;</a>
<a name="ln1159">    int match_count;</a>
<a name="ln1160"> </a>
<a name="ln1161">    regex = g_regex_new(&quot;^\\s*\\[\\s*(.*)\\s*;\\s*(.*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln1162">    g_regex_match_full(regex, gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln1163">    match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln1164"> </a>
<a name="ln1165">    if(match_count == 3)</a>
<a name="ln1166">    {</a>
<a name="ln1167">      _range_t *range = (_range_t *)calloc(1, sizeof(_range_t));</a>
<a name="ln1168">      /* inversed as dates are in reverse order */</a>
<a name="ln1169">      range-&gt;start = g_match_info_fetch(match_info, 2);</a>
<a name="ln1170">      range-&gt;stop = g_match_info_fetch(match_info, 1);</a>
<a name="ln1171"> </a>
<a name="ln1172">      gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)range_select, range);</a>
<a name="ln1173">      if(range-&gt;path1 &amp;&amp; range-&gt;path2)</a>
<a name="ln1174">      {</a>
<a name="ln1175">        gtk_tree_selection_select_range(gtk_tree_view_get_selection(d-&gt;view), range-&gt;path1, range-&gt;path2);</a>
<a name="ln1176">      }</a>
<a name="ln1177">      g_free(range-&gt;start);</a>
<a name="ln1178">      g_free(range-&gt;stop);</a>
<a name="ln1179">      gtk_tree_path_free(range-&gt;path1);</a>
<a name="ln1180">      gtk_tree_path_free(range-&gt;path2);</a>
<a name="ln1181">      free(range);</a>
<a name="ln1182">    }</a>
<a name="ln1183">    else</a>
<a name="ln1184">      gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1185"> </a>
<a name="ln1186">    g_match_info_free(match_info);</a>
<a name="ln1187">    g_regex_unref(regex);</a>
<a name="ln1188">  }</a>
<a name="ln1189">  else</a>
<a name="ln1190">    gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">static void list_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1194">{</a>
<a name="ln1195">  // update related list</a>
<a name="ln1196">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln1197">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1198"> </a>
<a name="ln1199">  set_properties(dr);</a>
<a name="ln1200"> </a>
<a name="ln1201">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;listfilter));</a>
<a name="ln1202">  if(d-&gt;view_rule != property)</a>
<a name="ln1203">  {</a>
<a name="ln1204">    sqlite3_stmt *stmt;</a>
<a name="ln1205">    GtkTreeIter iter;</a>
<a name="ln1206">    g_object_unref(d-&gt;listfilter);</a>
<a name="ln1207">    g_object_ref(model);</a>
<a name="ln1208">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln1209">    gtk_list_store_clear(GTK_LIST_STORE(model));</a>
<a name="ln1210">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1211">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln1212">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln1213"> </a>
<a name="ln1214">    char query[1024] = { 0 };</a>
<a name="ln1215"> </a>
<a name="ln1216">    switch(property)</a>
<a name="ln1217">    {</a>
<a name="ln1218">      case DT_COLLECTION_PROP_CAMERA:; // camera</a>
<a name="ln1219">        int index = 0;</a>
<a name="ln1220">        gchar *makermodel_query = NULL;</a>
<a name="ln1221">        makermodel_query = dt_util_dstrcat(makermodel_query, &quot;SELECT maker, model, COUNT(*) AS count &quot;</a>
<a name="ln1222">                &quot;FROM main.images WHERE %s GROUP BY maker, model&quot;, where_ext);</a>
<a name="ln1223"> </a>
<a name="ln1224">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1225">                                makermodel_query,</a>
<a name="ln1226">                                -1, &amp;stmt, NULL);</a>
<a name="ln1227"> </a>
<a name="ln1228">        while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1229">        {</a>
<a name="ln1230">          char *exif_maker = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1231">          char *exif_model = (char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1232">          const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1233"> </a>
<a name="ln1234">          gchar *value =  dt_collection_get_makermodel(exif_maker, exif_model);</a>
<a name="ln1235"> </a>
<a name="ln1236">          gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1237">          gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, value,</a>
<a name="ln1238">                             DT_LIB_COLLECT_COL_ID, index, DT_LIB_COLLECT_COL_TOOLTIP, value,</a>
<a name="ln1239">                             DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1240">                             DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1241">                             -1);</a>
<a name="ln1242"> </a>
<a name="ln1243">          g_free(value);</a>
<a name="ln1244">          index++;</a>
<a name="ln1245">        }</a>
<a name="ln1246">        g_free(makermodel_query);</a>
<a name="ln1247">        break;</a>
<a name="ln1248"> </a>
<a name="ln1249">      case DT_COLLECTION_PROP_HISTORY: // History, 2 hardcoded alternatives</a>
<a name="ln1250">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1251">                           &quot;altered WHEN 1 THEN '%s' ELSE '%s' END as altered, 1, COUNT(*) AS count &quot;</a>
<a name="ln1252">                           &quot;FROM main.images LEFT JOIN &quot;</a>
<a name="ln1253">                           &quot;(SELECT DISTINCT imgid AS history_id, 1 AS altered FROM main.history) ON id = history_id &quot;</a>
<a name="ln1254">                           &quot;WHERE %s GROUP BY altered ORDER BY altered ASC&quot;,</a>
<a name="ln1255">                   _(&quot;altered&quot;),  _(&quot;not altered&quot;), where_ext);</a>
<a name="ln1256">        break;</a>
<a name="ln1257"> </a>
<a name="ln1258">      case DT_COLLECTION_PROP_GEOTAGGING: // Geotagging, 2 hardcoded alternatives</a>
<a name="ln1259">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1260">                           &quot;WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN '%s' ELSE '%s' END as tagged, 1, &quot;</a>
<a name="ln1261">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1262">                           &quot;FROM main.images &quot;</a>
<a name="ln1263">                           &quot;WHERE %s GROUP BY tagged ORDER BY tagged ASC&quot;,</a>
<a name="ln1264">                       _(&quot;tagged&quot;),  _(&quot;not tagged&quot;), where_ext);</a>
<a name="ln1265">        break;</a>
<a name="ln1266"> </a>
<a name="ln1267">      case DT_COLLECTION_PROP_LOCAL_COPY: // local copy, 2 hardcoded alternatives</a>
<a name="ln1268">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1269">                           &quot;WHEN (flags &amp; %d) THEN '%s' ELSE '%s' END as lcp, 1, &quot;</a>
<a name="ln1270">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1271">                           &quot;FROM main.images &quot;</a>
<a name="ln1272">                           &quot;WHERE %s GROUP BY lcp ORDER BY lcp ASC&quot;,</a>
<a name="ln1273">                   DT_IMAGE_LOCAL_COPY, _(&quot;copied locally&quot;),  _(&quot;not copied locally&quot;), where_ext);</a>
<a name="ln1274">        break;</a>
<a name="ln1275"> </a>
<a name="ln1276">      case DT_COLLECTION_PROP_ASPECT_RATIO: // aspect ratio, 3 hardcoded alternatives</a>
<a name="ln1277">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aspect_ratio,1), 1, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln1278">                   &quot;WHERE %s GROUP BY ROUND(aspect_ratio,1)&quot;, where_ext);</a>
<a name="ln1279">        break;</a>
<a name="ln1280"> </a>
<a name="ln1281">      case DT_COLLECTION_PROP_COLORLABEL: // colorlabels</a>
<a name="ln1282">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1283">                           &quot;color WHEN 0 THEN '%s' WHEN 1 THEN '%s' WHEN 2 THEN '%s' WHEN 3 THEN '%s' WHEN 4 THEN '%s' &quot;</a>
<a name="ln1284">                           &quot;ELSE '' END, color, COUNT(*) AS count &quot;</a>
<a name="ln1285">                           &quot;FROM main.images JOIN &quot;</a>
<a name="ln1286">                           &quot;(SELECT imgid AS color_labels_id, color FROM main.color_labels) ON id = color_labels_id &quot;</a>
<a name="ln1287">                           &quot;WHERE %s GROUP BY color ORDER BY color DESC&quot;,</a>
<a name="ln1288">                   _(&quot;red&quot;), _(&quot;yellow&quot;), _(&quot;green&quot;), _(&quot;blue&quot;), _(&quot;purple&quot;), where_ext);</a>
<a name="ln1289">        break;</a>
<a name="ln1290"> </a>
<a name="ln1291">      // TODO: Add empty string for metadata?</a>
<a name="ln1292">      // TODO: Autogenerate this code?</a>
<a name="ln1293">      case DT_COLLECTION_PROP_TITLE: // title</a>
<a name="ln1294">        snprintf(query, sizeof(query),</a>
<a name="ln1295">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1296">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1297">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1298">                 DT_METADATA_XMP_DC_TITLE, where_ext);</a>
<a name="ln1299">        break;</a>
<a name="ln1300">      case DT_COLLECTION_PROP_DESCRIPTION: // description</a>
<a name="ln1301">        snprintf(query, sizeof(query),</a>
<a name="ln1302">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1303">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1304">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1305">                 DT_METADATA_XMP_DC_DESCRIPTION, where_ext);</a>
<a name="ln1306">        break;</a>
<a name="ln1307">      case DT_COLLECTION_PROP_CREATOR: // creator</a>
<a name="ln1308">        snprintf(query, sizeof(query),</a>
<a name="ln1309">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1310">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1311">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1312">                 DT_METADATA_XMP_DC_CREATOR, where_ext);</a>
<a name="ln1313">        break;</a>
<a name="ln1314">      case DT_COLLECTION_PROP_PUBLISHER: // publisher</a>
<a name="ln1315">        snprintf(query, sizeof(query),</a>
<a name="ln1316">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1317">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1318">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1319">                 DT_METADATA_XMP_DC_PUBLISHER, where_ext);</a>
<a name="ln1320">        break;</a>
<a name="ln1321">      case DT_COLLECTION_PROP_RIGHTS: // rights</a>
<a name="ln1322">        snprintf(query, sizeof(query),</a>
<a name="ln1323">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1324">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1325">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1326">                 DT_METADATA_XMP_DC_RIGHTS, where_ext);</a>
<a name="ln1327">        break;</a>
<a name="ln1328">      case DT_COLLECTION_PROP_LENS: // lens</a>
<a name="ln1329">        g_snprintf(query, sizeof(query), &quot;SELECT lens, 1, COUNT(*) AS count &quot;</a>
<a name="ln1330">                &quot;FROM main.images WHERE %s GROUP BY lens ORDER BY lens&quot;, where_ext);</a>
<a name="ln1331">        break;</a>
<a name="ln1332"> </a>
<a name="ln1333">      case DT_COLLECTION_PROP_FOCAL_LENGTH: // focal length</a>
<a name="ln1334">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(focal_length AS INTEGER) AS focal_length, 1, COUNT(*) AS count &quot;</a>
<a name="ln1335">                         &quot;FROM main.images WHERE %s GROUP BY focal_length ORDER BY focal_length&quot;,</a>
<a name="ln1336">                   where_ext);</a>
<a name="ln1337">        break;</a>
<a name="ln1338"> </a>
<a name="ln1339">      case DT_COLLECTION_PROP_ISO: // iso</a>
<a name="ln1340">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(iso AS INTEGER) AS iso, 1, COUNT(*) AS count &quot;</a>
<a name="ln1341">                           &quot;FROM main.images WHERE %s GROUP BY iso ORDER BY iso&quot;,</a>
<a name="ln1342">                   where_ext);</a>
<a name="ln1343">        break;</a>
<a name="ln1344"> </a>
<a name="ln1345">      case DT_COLLECTION_PROP_APERTURE: // aperture</a>
<a name="ln1346">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aperture,1) AS aperture, 1, COUNT(*) AS count &quot;</a>
<a name="ln1347">                           &quot;FROM main.images WHERE %s GROUP BY aperture ORDER BY aperture&quot;,</a>
<a name="ln1348">                   where_ext);</a>
<a name="ln1349">        break;</a>
<a name="ln1350"> </a>
<a name="ln1351">      case DT_COLLECTION_PROP_EXPOSURE: // exposure</a>
<a name="ln1352">        g_snprintf(query, sizeof(query), &quot;SELECT CASE WHEN (exposure &lt; 0.4) &quot;</a>
<a name="ln1353">                              &quot;THEN '1/' || CAST(1/exposure + 0.9 AS INTEGER) &quot;</a>
<a name="ln1354">                           &quot;ELSE ROUND(exposure,2) || '\&quot;' END as _exposure, 1, COUNT(*) AS count &quot;</a>
<a name="ln1355">                &quot;FROM main.images WHERE %s GROUP BY _exposure ORDER BY exposure&quot;,</a>
<a name="ln1356">                  where_ext);</a>
<a name="ln1357">        break;</a>
<a name="ln1358"> </a>
<a name="ln1359">      case DT_COLLECTION_PROP_FILENAME: // filename</a>
<a name="ln1360">        g_snprintf(query, sizeof(query), &quot;SELECT filename, 1, COUNT(*) AS count &quot;</a>
<a name="ln1361">                &quot;FROM main.images WHERE %s GROUP BY filename ORDER BY filename&quot;, where_ext);</a>
<a name="ln1362">        break;</a>
<a name="ln1363"> </a>
<a name="ln1364">      default: // filmroll</a>
<a name="ln1365">        g_snprintf(query, sizeof(query), &quot;SELECT folder, film_rolls_id, COUNT(*) AS count &quot;</a>
<a name="ln1366">                &quot;FROM main.images JOIN &quot;</a>
<a name="ln1367">                &quot;(SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln1368">                &quot;WHERE %s GROUP BY folder ORDER BY folder DESC&quot;, where_ext);</a>
<a name="ln1369">        break;</a>
<a name="ln1370"> </a>
<a name="ln1371">      case DT_COLLECTION_PROP_GROUPING: // Grouping, 2 hardcoded alternatives</a>
<a name="ln1372">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1373">                           &quot;WHEN id = group_id THEN '%s' ELSE '%s' END as group_leader, 1, &quot;</a>
<a name="ln1374">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1375">                           &quot;FROM main.images &quot;</a>
<a name="ln1376">                           &quot;WHERE %s GROUP BY group_leader ORDER BY group_leader ASC&quot;,</a>
<a name="ln1377">                   _(&quot;group leaders&quot;),  _(&quot;group followers&quot;), where_ext);</a>
<a name="ln1378">        break;</a>
<a name="ln1379">    }</a>
<a name="ln1380"> </a>
<a name="ln1381">    g_free(where_ext);</a>
<a name="ln1382"> </a>
<a name="ln1383">    if(strlen(query) &gt; 0)</a>
<a name="ln1384">    {</a>
<a name="ln1385">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln1386">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1387">      {</a>
<a name="ln1388">        const char *folder = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1389">        if(folder == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1390"> </a>
<a name="ln1391">        gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1392">        if(property == DT_COLLECTION_PROP_FILMROLL)</a>
<a name="ln1393">        {</a>
<a name="ln1394">          folder = dt_image_film_roll_name(folder);</a>
<a name="ln1395">        }</a>
<a name="ln1396">        gchar *value = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1397">        const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1398"> </a>
<a name="ln1399">        // replace invalid utf8 characters if any</a>
<a name="ln1400">        gchar *text = g_strdup(value);</a>
<a name="ln1401">        gchar *ptr = text;</a>
<a name="ln1402">        while(!g_utf8_validate(ptr, -1, (const gchar **)&amp;ptr)) ptr[0] = '?';</a>
<a name="ln1403"> </a>
<a name="ln1404">        gchar *escaped_text = g_markup_escape_text(text, -1);</a>
<a name="ln1405"> </a>
<a name="ln1406">        gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, folder,</a>
<a name="ln1407">                           DT_LIB_COLLECT_COL_ID, sqlite3_column_int(stmt, 1), DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln1408">                           escaped_text, DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1409">                           DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1410">                           -1);</a>
<a name="ln1411">        g_free(text);</a>
<a name="ln1412">        g_free(escaped_text);</a>
<a name="ln1413">      }</a>
<a name="ln1414">      sqlite3_finalize(stmt);</a>
<a name="ln1415">    }</a>
<a name="ln1416"> </a>
<a name="ln1417">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1418"> </a>
<a name="ln1419">    d-&gt;listfilter = _create_filtered_model(model, dr);</a>
<a name="ln1420"> </a>
<a name="ln1421">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;view));</a>
<a name="ln1422">    if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1423">       || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln1424">       || property == DT_COLLECTION_PROP_ASPECT_RATIO)</a>
<a name="ln1425">    {</a>
<a name="ln1426">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1427">    }</a>
<a name="ln1428">    else</a>
<a name="ln1429">    {</a>
<a name="ln1430">      gtk_tree_selection_set_mode(selection, GTK_SELECTION_SINGLE);</a>
<a name="ln1431">    }</a>
<a name="ln1432"> </a>
<a name="ln1433">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;listfilter);</a>
<a name="ln1434">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1435">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1436"> </a>
<a name="ln1437">    g_object_unref(model);</a>
<a name="ln1438"> </a>
<a name="ln1439">    d-&gt;view_rule = property;</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1443">  if(dr-&gt;typing &amp;&amp; (property == DT_COLLECTION_PROP_CAMERA || property == DT_COLLECTION_PROP_CREATOR</a>
<a name="ln1444">                    || property == DT_COLLECTION_PROP_DESCRIPTION || property == DT_COLLECTION_PROP_FILENAME</a>
<a name="ln1445">                    || property == DT_COLLECTION_PROP_FILMROLL || property == DT_COLLECTION_PROP_LENS</a>
<a name="ln1446">                    || property == DT_COLLECTION_PROP_PUBLISHER || property == DT_COLLECTION_PROP_RIGHTS</a>
<a name="ln1447">                    || property == DT_COLLECTION_PROP_TITLE || property == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1448">                    || property == DT_COLLECTION_PROP_FOCAL_LENGTH || property == DT_COLLECTION_PROP_ISO))</a>
<a name="ln1449">    gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)list_match_string, dr);</a>
<a name="ln1450">  // we update list selection</a>
<a name="ln1451">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1452"> </a>
<a name="ln1453">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1454">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_EXPOSURE</a>
<a name="ln1455">     || property == DT_COLLECTION_PROP_ASPECT_RATIO)</a>
<a name="ln1456">  {</a>
<a name="ln1457">    // test selection range [xxx;xxx]</a>
<a name="ln1458">    GRegex *regex;</a>
<a name="ln1459">    GMatchInfo *match_info;</a>
<a name="ln1460">    int match_count;</a>
<a name="ln1461"> </a>
<a name="ln1462">    regex = g_regex_new(&quot;^\\s*\\[\\s*(.*)\\s*;\\s*(.*)\\s*\\]\\s*$&quot;, 0, 0, NULL);</a>
<a name="ln1463">    g_regex_match_full(regex, gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1, 0, 0, &amp;match_info, NULL);</a>
<a name="ln1464">    match_count = g_match_info_get_match_count(match_info);</a>
<a name="ln1465"> </a>
<a name="ln1466">    if(match_count == 3)</a>
<a name="ln1467">    {</a>
<a name="ln1468">      _range_t *range = (_range_t *)calloc(1, sizeof(_range_t));</a>
<a name="ln1469">      range-&gt;start = g_match_info_fetch(match_info, 1);</a>
<a name="ln1470">      range-&gt;stop = g_match_info_fetch(match_info, 2);</a>
<a name="ln1471"> </a>
<a name="ln1472">      gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)range_select, range);</a>
<a name="ln1473">      if(range-&gt;path1 &amp;&amp; range-&gt;path2)</a>
<a name="ln1474">      {</a>
<a name="ln1475">        gtk_tree_selection_select_range(gtk_tree_view_get_selection(d-&gt;view), range-&gt;path1, range-&gt;path2);</a>
<a name="ln1476">      }</a>
<a name="ln1477">      g_free(range-&gt;start);</a>
<a name="ln1478">      g_free(range-&gt;stop);</a>
<a name="ln1479">      gtk_tree_path_free(range-&gt;path1);</a>
<a name="ln1480">      gtk_tree_path_free(range-&gt;path2);</a>
<a name="ln1481">      free(range);</a>
<a name="ln1482">    }</a>
<a name="ln1483">    else</a>
<a name="ln1484">      gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1485"> </a>
<a name="ln1486">    g_match_info_free(match_info);</a>
<a name="ln1487">    g_regex_unref(regex);</a>
<a name="ln1488">  }</a>
<a name="ln1489">  else</a>
<a name="ln1490">    gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1491">}</a>
<a name="ln1492"> </a>
<a name="ln1493">static void update_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1494">{</a>
<a name="ln1495">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1496"> </a>
<a name="ln1497">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1498">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1499">    tree_view(dr);</a>
<a name="ln1500">  else</a>
<a name="ln1501">    list_view(dr);</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504"> </a>
<a name="ln1505">static void _lib_collect_gui_update(dt_lib_module_t *self)</a>
<a name="ln1506">{</a>
<a name="ln1507">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1508"> </a>
<a name="ln1509">  // we check if something as change since last call</a>
<a name="ln1510">  if(d-&gt;view_rule != -1) return;</a>
<a name="ln1511"> </a>
<a name="ln1512">  const int old = darktable.gui-&gt;reset;</a>
<a name="ln1513">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1514">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln1515">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln1516">  d-&gt;nb_rules = active + 1;</a>
<a name="ln1517">  char confname[200] = { 0 };</a>
<a name="ln1518"> </a>
<a name="ln1519">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), TRUE);</a>
<a name="ln1520">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;sw2), TRUE);</a>
<a name="ln1521"> </a>
<a name="ln1522">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln1523">  {</a>
<a name="ln1524">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1525">    gtk_widget_set_visible(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1526">  }</a>
<a name="ln1527">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln1528">  {</a>
<a name="ln1529">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1530">    gtk_widget_set_visible(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1531">    gtk_widget_show_all(d-&gt;rule[i].hbox);</a>
<a name="ln1532">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1533">    gtk_combo_box_set_active(GTK_COMBO_BOX(d-&gt;rule[i].combo), dt_conf_get_int(confname));</a>
<a name="ln1534">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1535">    gchar *text = dt_conf_get_string(confname);</a>
<a name="ln1536">    if(text)</a>
<a name="ln1537">    {</a>
<a name="ln1538">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1539">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1540">      gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[i].text), text);</a>
<a name="ln1541">      gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[i].text), -1);</a>
<a name="ln1542">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1543">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1544">      g_free(text);</a>
<a name="ln1545">      d-&gt;rule[i].typing = FALSE;</a>
<a name="ln1546">    }</a>
<a name="ln1547"> </a>
<a name="ln1548">    GtkDarktableButton *button = DTGTK_BUTTON(d-&gt;rule[i].button);</a>
<a name="ln1549">    if(i == MAX_RULES - 1)</a>
<a name="ln1550">    {</a>
<a name="ln1551">      // only clear</a>
<a name="ln1552">      button-&gt;icon = dtgtk_cairo_paint_cancel;</a>
<a name="ln1553">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1554">    }</a>
<a name="ln1555">    else if(i == active)</a>
<a name="ln1556">    {</a>
<a name="ln1557">      button-&gt;icon = dtgtk_cairo_paint_dropdown;</a>
<a name="ln1558">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule or add new rules&quot;));</a>
<a name="ln1559">    }</a>
<a name="ln1560">    else</a>
<a name="ln1561">    {</a>
<a name="ln1562">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1563">      const int mode = dt_conf_get_int(confname);</a>
<a name="ln1564">      if(mode == DT_LIB_COLLECT_MODE_AND) button-&gt;icon = dtgtk_cairo_paint_and;</a>
<a name="ln1565">      if(mode == DT_LIB_COLLECT_MODE_OR) button-&gt;icon = dtgtk_cairo_paint_or;</a>
<a name="ln1566">      if(mode == DT_LIB_COLLECT_MODE_AND_NOT) button-&gt;icon = dtgtk_cairo_paint_andnot;</a>
<a name="ln1567">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1568">    }</a>
<a name="ln1569">  }</a>
<a name="ln1570"> </a>
<a name="ln1571">  // update list of proposals</a>
<a name="ln1572">  update_view(d-&gt;rule + d-&gt;active_rule);</a>
<a name="ln1573">  darktable.gui-&gt;reset = old;</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln1577">{</a>
<a name="ln1578">  dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, 1);</a>
<a name="ln1579">  dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln1580">  dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, 0);</a>
<a name="ln1581">  dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1582">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1583">  d-&gt;active_rule = 0;</a>
<a name="ln1584">  d-&gt;view_rule = -1;</a>
<a name="ln1585">  dt_collection_set_query_flags(darktable.collection, COLLECTION_QUERY_FULL);</a>
<a name="ln1586">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">static void combo_changed(GtkComboBox *combo, dt_lib_collect_rule_t *d)</a>
<a name="ln1590">{</a>
<a name="ln1591">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1592">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1593">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1594">  gtk_entry_set_text(GTK_ENTRY(d-&gt;text), &quot;&quot;);</a>
<a name="ln1595">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1596">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1597">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1598">  c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1599"> </a>
<a name="ln1600">  int property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1601"> </a>
<a name="ln1602">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1603">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1604">  {</a>
<a name="ln1605">    d-&gt;typing = FALSE;</a>
<a name="ln1606">  }</a>
<a name="ln1607"> </a>
<a name="ln1608">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1609">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_ASPECT_RATIO</a>
<a name="ln1610">     || property == DT_COLLECTION_PROP_EXPOSURE)</a>
<a name="ln1611">  {</a>
<a name="ln1612">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators&quot;));</a>
<a name="ln1613">  }</a>
<a name="ln1614">  else if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1615">  {</a>
<a name="ln1616">    gtk_widget_set_tooltip_text(d-&gt;text,</a>
<a name="ln1617">                                _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators, type dates in &quot;</a>
<a name="ln1618">                                  &quot;the form : YYYY:MM:DD HH:MM:SS (only the year is mandatory)&quot;));</a>
<a name="ln1619">  }</a>
<a name="ln1620">  else</a>
<a name="ln1621">  {</a>
<a name="ln1622">    /* xgettext:no-c-format */</a>
<a name="ln1623">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln1624">  }</a>
<a name="ln1625"> </a>
<a name="ln1626">  set_properties(d);</a>
<a name="ln1627">  c-&gt;view_rule = -1;</a>
<a name="ln1628">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1629">}</a>
<a name="ln1630"> </a>
<a name="ln1631">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln1632">{</a>
<a name="ln1633">  GtkTreeIter iter;</a>
<a name="ln1634">  GtkTreeModel *model = NULL;</a>
<a name="ln1635"> </a>
<a name="ln1636">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1637">  if(gtk_tree_selection_count_selected_rows(selection) &lt; 1) return;</a>
<a name="ln1638">  GList *sels = gtk_tree_selection_get_selected_rows(selection, &amp;model);</a>
<a name="ln1639">  GtkTreePath *path1 = (GtkTreePath *)g_list_nth_data(sels, 0);</a>
<a name="ln1640">  if(!gtk_tree_model_get_iter(model, &amp;iter, path1)) return;</a>
<a name="ln1641"> </a>
<a name="ln1642">  gchar *text;</a>
<a name="ln1643"> </a>
<a name="ln1644">  const int active = d-&gt;active_rule;</a>
<a name="ln1645">  d-&gt;rule[active].typing = FALSE;</a>
<a name="ln1646"> </a>
<a name="ln1647">  const int item = gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[active].combo));</a>
<a name="ln1648">  gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1649"> </a>
<a name="ln1650">  if(text &amp;&amp; strlen(text) &gt; 0)</a>
<a name="ln1651">  {</a>
<a name="ln1652">    if(gtk_tree_selection_count_selected_rows(selection) &gt; 1</a>
<a name="ln1653">       &amp;&amp; (item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME || item == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1654">           || item == DT_COLLECTION_PROP_FOCAL_LENGTH || item == DT_COLLECTION_PROP_ISO</a>
<a name="ln1655">           || item == DT_COLLECTION_PROP_EXPOSURE || item == DT_COLLECTION_PROP_ASPECT_RATIO))</a>
<a name="ln1656">    {</a>
<a name="ln1657">      /* this is a range selection */</a>
<a name="ln1658">      GtkTreeIter iter2;</a>
<a name="ln1659">      GtkTreePath *path2 = (GtkTreePath *)g_list_last(sels)-&gt;data;</a>
<a name="ln1660">      if(!gtk_tree_model_get_iter(model, &amp;iter2, path2)) return;</a>
<a name="ln1661"> </a>
<a name="ln1662">      gchar *text2;</a>
<a name="ln1663">      gtk_tree_model_get(model, &amp;iter2, DT_LIB_COLLECT_COL_PATH, &amp;text2, -1);</a>
<a name="ln1664"> </a>
<a name="ln1665">      gchar *n_text;</a>
<a name="ln1666">      if(item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1667">        n_text = g_strdup_printf(&quot;[%s;%s]&quot;, text2, text); /* dates are in reverse order */</a>
<a name="ln1668">      else</a>
<a name="ln1669">        n_text = g_strdup_printf(&quot;[%s;%s]&quot;, text, text2);</a>
<a name="ln1670"> </a>
<a name="ln1671">      g_free(text);</a>
<a name="ln1672">      g_free(text2);</a>
<a name="ln1673">      text = n_text;</a>
<a name="ln1674">    }</a>
<a name="ln1675">    else if(item == DT_COLLECTION_PROP_TAG &amp;&amp; gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1676">    {</a>
<a name="ln1677">      /* if a tag has children, ctrl-clicking on a parent node should display all images under this hierarchy. */</a>
<a name="ln1678">      if(event-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln1679">      {</a>
<a name="ln1680">        gchar *n_text = g_strconcat(text, &quot;|%&quot;, NULL);</a>
<a name="ln1681">        g_free(text);</a>
<a name="ln1682">        text = n_text;</a>
<a name="ln1683">      }</a>
<a name="ln1684">      /* if a tag has children, shift-clicking on a parent node should display all images in and under this</a>
<a name="ln1685">       * hierarchy. */</a>
<a name="ln1686">      else if(event-&gt;state &amp; GDK_SHIFT_MASK)</a>
<a name="ln1687">      {</a>
<a name="ln1688">        gchar *n_text = g_strconcat(text, &quot;%&quot;, NULL);</a>
<a name="ln1689">        g_free(text);</a>
<a name="ln1690">        text = n_text;</a>
<a name="ln1691">      }</a>
<a name="ln1692">    }</a>
<a name="ln1693">  }</a>
<a name="ln1694"> </a>
<a name="ln1695">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1696">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1697">  gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[active].text), text);</a>
<a name="ln1698">  gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[active].text), -1);</a>
<a name="ln1699">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text,</a>
<a name="ln1700">                                    NULL);</a>
<a name="ln1701">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed,</a>
<a name="ln1702">                                    NULL);</a>
<a name="ln1703">  g_free(text);</a>
<a name="ln1704"> </a>
<a name="ln1705">  if(item == DT_COLLECTION_PROP_TAG || item == DT_COLLECTION_PROP_FOLDERS</a>
<a name="ln1706">     || item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME</a>
<a name="ln1707">     || item == DT_COLLECTION_PROP_COLORLABEL || item == DT_COLLECTION_PROP_GEOTAGGING</a>
<a name="ln1708">     || item == DT_COLLECTION_PROP_HISTORY ||  item == DT_COLLECTION_PROP_LOCAL_COPY</a>
<a name="ln1709">     || item == DT_COLLECTION_PROP_GROUPING)</a>
<a name="ln1710">    set_properties(d-&gt;rule + active); // we just have to set the selection</a>
<a name="ln1711">  else</a>
<a name="ln1712">    update_view(d-&gt;rule + active); // we have to update visible items too</a>
<a name="ln1713"> </a>
<a name="ln1714">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1715">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1716">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1717">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1718">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1719">  dt_control_queue_redraw_center();</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">static void entry_activated(GtkWidget *entry, dt_lib_collect_rule_t *d)</a>
<a name="ln1723">{</a>
<a name="ln1724">  GtkTreeView *view;</a>
<a name="ln1725">  GtkTreeModel *model;</a>
<a name="ln1726">  int property, rows;</a>
<a name="ln1727"> </a>
<a name="ln1728">  update_view(d);</a>
<a name="ln1729">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1730"> </a>
<a name="ln1731">  property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1732"> </a>
<a name="ln1733">  if(property != DT_COLLECTION_PROP_FOLDERS &amp;&amp; property != DT_COLLECTION_PROP_TAG</a>
<a name="ln1734">     &amp;&amp; property != DT_COLLECTION_PROP_DAY &amp;&amp; property != DT_COLLECTION_PROP_TIME)</a>
<a name="ln1735">  {</a>
<a name="ln1736">    view = c-&gt;view;</a>
<a name="ln1737">    model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln1738"> </a>
<a name="ln1739">    rows = gtk_tree_model_iter_n_children(model, NULL);</a>
<a name="ln1740"> </a>
<a name="ln1741">    if(rows == 1)</a>
<a name="ln1742">    {</a>
<a name="ln1743">      GtkTreeIter iter;</a>
<a name="ln1744">      if(gtk_tree_model_get_iter_first(model, &amp;iter))</a>
<a name="ln1745">      {</a>
<a name="ln1746">        gchar *text;</a>
<a name="ln1747">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1748"> </a>
<a name="ln1749">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1750">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1751">        gtk_entry_set_text(GTK_ENTRY(d-&gt;text), text);</a>
<a name="ln1752">        gtk_editable_set_position(GTK_EDITABLE(d-&gt;text), -1);</a>
<a name="ln1753">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1754">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1755">        g_free(text);</a>
<a name="ln1756">        d-&gt;typing = FALSE;</a>
<a name="ln1757">        update_view(d);</a>
<a name="ln1758">      }</a>
<a name="ln1759">    }</a>
<a name="ln1760">  }</a>
<a name="ln1761">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1762">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1763">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1764">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1765">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln1769">                          dt_lib_collect_rule_t *d)</a>
<a name="ln1770">{</a>
<a name="ln1771">  d-&gt;typing = TRUE;</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr)</a>
<a name="ln1775">{</a>
<a name="ln1776">  update_view(dr);</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">int position()</a>
<a name="ln1780">{</a>
<a name="ln1781">  return 400;</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784">static gboolean entry_focus_in_callback(GtkWidget *w, GdkEventFocus *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1785">{</a>
<a name="ln1786">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1787">  if(c-&gt;active_rule != d-&gt;num)</a>
<a name="ln1788">  {</a>
<a name="ln1789">    c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1790">    update_view(c-&gt;rule + c-&gt;active_rule);</a>
<a name="ln1791">  }</a>
<a name="ln1792"> </a>
<a name="ln1793">  return FALSE;</a>
<a name="ln1794">}</a>
<a name="ln1795"> </a>
<a name="ln1796">static void menuitem_mode(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1797">{</a>
<a name="ln1798">  // add next row with and operator</a>
<a name="ln1799">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1800">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1801">  if(active &lt; MAX_RULES)</a>
<a name="ln1802">  {</a>
<a name="ln1803">    char confname[200] = { 0 };</a>
<a name="ln1804">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, active);</a>
<a name="ln1805">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1806">    dt_conf_set_int(confname, mode);</a>
<a name="ln1807">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, active);</a>
<a name="ln1808">    dt_conf_set_string(confname, &quot;&quot;);</a>
<a name="ln1809">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active + 1);</a>
<a name="ln1810">    dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1811">    c-&gt;active_rule = active;</a>
<a name="ln1812">    c-&gt;view_rule = -1;</a>
<a name="ln1813">  }</a>
<a name="ln1814">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1815">}</a>
<a name="ln1816"> </a>
<a name="ln1817">static void menuitem_mode_change(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1818">{</a>
<a name="ln1819">  // add next row with and operator</a>
<a name="ln1820">  const int num = d-&gt;num + 1;</a>
<a name="ln1821">  if(num &lt; MAX_RULES &amp;&amp; num &gt; 0)</a>
<a name="ln1822">  {</a>
<a name="ln1823">    char confname[200] = { 0 };</a>
<a name="ln1824">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, num);</a>
<a name="ln1825">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1826">    dt_conf_set_int(confname, mode);</a>
<a name="ln1827">  }</a>
<a name="ln1828">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1829">  c-&gt;view_rule = -1;</a>
<a name="ln1830">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1831">}</a>
<a name="ln1832"> </a>
<a name="ln1833">static void collection_updated(gpointer instance, gpointer self)</a>
<a name="ln1834">{</a>
<a name="ln1835">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1836">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1837"> </a>
<a name="ln1838">  // update tree</a>
<a name="ln1839">  d-&gt;view_rule = -1;</a>
<a name="ln1840">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1841">  _lib_collect_gui_update(self);</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844"> </a>
<a name="ln1845">static void filmrolls_updated(gpointer instance, gpointer self)</a>
<a name="ln1846">{</a>
<a name="ln1847">  // TODO: We should update the count of images here</a>
<a name="ln1848">  _lib_collect_gui_update(self);</a>
<a name="ln1849">}</a>
<a name="ln1850"> </a>
<a name="ln1851">static void filmrolls_imported(gpointer instance, int film_id, gpointer self)</a>
<a name="ln1852">{</a>
<a name="ln1853">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1854">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1855"> </a>
<a name="ln1856">  // update tree</a>
<a name="ln1857">  d-&gt;view_rule = -1;</a>
<a name="ln1858">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1859">  _lib_collect_gui_update(self);</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">static void filmrolls_removed(gpointer instance, gpointer self)</a>
<a name="ln1863">{</a>
<a name="ln1864">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1865">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1866"> </a>
<a name="ln1867">  // update tree</a>
<a name="ln1868">  if (d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln1869">  {</a>
<a name="ln1870">    d-&gt;view_rule = -1;</a>
<a name="ln1871">  }</a>
<a name="ln1872">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1873">  _lib_collect_gui_update(self);</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876">static void tag_changed(gpointer instance, gpointer self)</a>
<a name="ln1877">{</a>
<a name="ln1878">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1879">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1880"> </a>
<a name="ln1881">  // update tree</a>
<a name="ln1882">  if(gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[d-&gt;active_rule].combo)) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln1883">  {</a>
<a name="ln1884">    d-&gt;view_rule = -1;</a>
<a name="ln1885">    d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1886">    _lib_collect_gui_update(self);</a>
<a name="ln1887">  }</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">static void menuitem_clear(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1891">{</a>
<a name="ln1892">  // remove this row, or if 1st, clear text entry box</a>
<a name="ln1893">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1894">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1895">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1896">  if(active &gt; 1)</a>
<a name="ln1897">  {</a>
<a name="ln1898">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active - 1);</a>
<a name="ln1899">    if(c-&gt;active_rule &gt;= active - 1) c-&gt;active_rule = active - 2;</a>
<a name="ln1900">  }</a>
<a name="ln1901">  else</a>
<a name="ln1902">  {</a>
<a name="ln1903">    dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln1904">    dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, 0);</a>
<a name="ln1905">    dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1906">    d-&gt;typing = FALSE;</a>
<a name="ln1907">  }</a>
<a name="ln1908">  // move up all still active rules by one.</a>
<a name="ln1909">  for(int i = d-&gt;num; i &lt; MAX_RULES - 1; i++)</a>
<a name="ln1910">  {</a>
<a name="ln1911">    char confname[200] = { 0 };</a>
<a name="ln1912">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1913">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln1914">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i + 1);</a>
<a name="ln1915">    const int item = dt_conf_get_int(confname);</a>
<a name="ln1916">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i + 1);</a>
<a name="ln1917">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln1918">    if(string)</a>
<a name="ln1919">    {</a>
<a name="ln1920">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln1921">      dt_conf_set_int(confname, mode);</a>
<a name="ln1922">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1923">      dt_conf_set_int(confname, item);</a>
<a name="ln1924">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1925">      dt_conf_set_string(confname, string);</a>
<a name="ln1926">      g_free(string);</a>
<a name="ln1927">    }</a>
<a name="ln1928">  }</a>
<a name="ln1929"> </a>
<a name="ln1930">  c-&gt;view_rule = -1;</a>
<a name="ln1931">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1932">}</a>
<a name="ln1933"> </a>
<a name="ln1934">static gboolean popup_button_callback(GtkWidget *widget, GdkEventButton *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1935">{</a>
<a name="ln1936">  if(event-&gt;button != 1) return FALSE;</a>
<a name="ln1937"> </a>
<a name="ln1938">  GtkWidget *menu = gtk_menu_new();</a>
<a name="ln1939">  GtkWidget *mi;</a>
<a name="ln1940">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1941">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1942"> </a>
<a name="ln1943">  mi = gtk_menu_item_new_with_label(_(&quot;clear this rule&quot;));</a>
<a name="ln1944">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1945">  g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_clear), d);</a>
<a name="ln1946"> </a>
<a name="ln1947">  if(d-&gt;num == active - 1)</a>
<a name="ln1948">  {</a>
<a name="ln1949">    mi = gtk_menu_item_new_with_label(_(&quot;narrow down search&quot;));</a>
<a name="ln1950">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1951">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1952">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1953"> </a>
<a name="ln1954">    mi = gtk_menu_item_new_with_label(_(&quot;add more images&quot;));</a>
<a name="ln1955">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1956">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1957">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1958"> </a>
<a name="ln1959">    mi = gtk_menu_item_new_with_label(_(&quot;exclude images&quot;));</a>
<a name="ln1960">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1961">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1962">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1963">  }</a>
<a name="ln1964">  else if(d-&gt;num &lt; active - 1)</a>
<a name="ln1965">  {</a>
<a name="ln1966">    mi = gtk_menu_item_new_with_label(_(&quot;change to: and&quot;));</a>
<a name="ln1967">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1968">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1969">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1970"> </a>
<a name="ln1971">    mi = gtk_menu_item_new_with_label(_(&quot;change to: or&quot;));</a>
<a name="ln1972">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1973">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1974">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1975"> </a>
<a name="ln1976">    mi = gtk_menu_item_new_with_label(_(&quot;change to: except&quot;));</a>
<a name="ln1977">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1978">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1979">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1980">  }</a>
<a name="ln1981"> </a>
<a name="ln1982">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1983"> </a>
<a name="ln1984">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1985">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1986">#else</a>
<a name="ln1987">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event-&gt;button, event-&gt;time);</a>
<a name="ln1988">#endif</a>
<a name="ln1989"> </a>
<a name="ln1990">  return TRUE;</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993">static void view_set_click(gpointer instance, gpointer user_data)</a>
<a name="ln1994">{</a>
<a name="ln1995">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1996">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1997">  d-&gt;singleclick = dt_conf_get_bool(&quot;plugins/lighttable/collect/single-click&quot;);</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000">void gui_init(dt_lib_module_t *self)</a>
<a name="ln2001">{</a>
<a name="ln2002">  dt_lib_collect_t *d = (dt_lib_collect_t *)calloc(1, sizeof(dt_lib_collect_t));</a>
<a name="ln2003"> </a>
<a name="ln2004">  self-&gt;data = (void *)d;</a>
<a name="ln2005">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln2006">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln2007"> </a>
<a name="ln2008">  d-&gt;active_rule = 0;</a>
<a name="ln2009">  d-&gt;nb_rules = 0;</a>
<a name="ln2010">  d-&gt;params = (dt_lib_collect_params_t *)malloc(sizeof(dt_lib_collect_params_t));</a>
<a name="ln2011">  view_set_click(NULL, self);</a>
<a name="ln2012"> </a>
<a name="ln2013">  GtkBox *box;</a>
<a name="ln2014">  GtkWidget *w;</a>
<a name="ln2015"> </a>
<a name="ln2016">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln2017">  {</a>
<a name="ln2018">    d-&gt;rule[i].num = i;</a>
<a name="ln2019">    d-&gt;rule[i].typing = FALSE;</a>
<a name="ln2020">    box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln2021">    d-&gt;rule[i].hbox = GTK_WIDGET(box);</a>
<a name="ln2022">    gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln2023">    w = gtk_combo_box_text_new();</a>
<a name="ln2024">    d-&gt;rule[i].combo = GTK_COMBO_BOX(w);</a>
<a name="ln2025">    for(int k = 0; k &lt; dt_lib_collect_string_cnt; k++)</a>
<a name="ln2026">      gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(w), _(dt_lib_collect_string[k]));</a>
<a name="ln2027">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(combo_changed), d-&gt;rule + i);</a>
<a name="ln2028">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln2029"> </a>
<a name="ln2030">    w = gtk_entry_new();</a>
<a name="ln2031">    d-&gt;rule[i].text = w;</a>
<a name="ln2032">    dt_gui_key_accel_block_on_focus_connect(d-&gt;rule[i].text);</a>
<a name="ln2033">    gtk_widget_add_events(w, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln2034">    g_signal_connect(G_OBJECT(w), &quot;focus-in-event&quot;, G_CALLBACK(entry_focus_in_callback), d-&gt;rule + i);</a>
<a name="ln2035"> </a>
<a name="ln2036">    /* xgettext:no-c-format */</a>
<a name="ln2037">    gtk_widget_set_tooltip_text(w, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln2038">    gtk_widget_add_events(w, GDK_KEY_PRESS_MASK);</a>
<a name="ln2039">    g_signal_connect(G_OBJECT(w), &quot;insert-text&quot;, G_CALLBACK(entry_insert_text), d-&gt;rule + i);</a>
<a name="ln2040">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(entry_changed), d-&gt;rule + i);</a>
<a name="ln2041">    g_signal_connect(G_OBJECT(w), &quot;activate&quot;, G_CALLBACK(entry_activated), d-&gt;rule + i);</a>
<a name="ln2042">    gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln2043">    gtk_entry_set_width_chars(GTK_ENTRY(w), 0);</a>
<a name="ln2044"> </a>
<a name="ln2045">    w = dtgtk_button_new(dtgtk_cairo_paint_presets, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln2046">    d-&gt;rule[i].button = w;</a>
<a name="ln2047">    gtk_widget_set_events(w, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln2048">    g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(popup_button_callback), d-&gt;rule + i);</a>
<a name="ln2049">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln2050">    gtk_widget_set_size_request(w, DT_PIXEL_APPLY_DPI(13), DT_PIXEL_APPLY_DPI(13));</a>
<a name="ln2051">  }</a>
<a name="ln2052"> </a>
<a name="ln2053">  GtkWidget *sw = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2054">  d-&gt;scrolledwindow = GTK_SCROLLED_WINDOW(sw);</a>
<a name="ln2055">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2056">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(d-&gt;scrolledwindow), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln2057">  GtkTreeView *view = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln2058">  d-&gt;view_rule = -1;</a>
<a name="ln2059">  d-&gt;view = view;</a>
<a name="ln2060">  gtk_tree_view_set_headers_visible(view, FALSE);</a>
<a name="ln2061">  gtk_container_add(GTK_CONTAINER(sw), GTK_WIDGET(view));</a>
<a name="ln2062">  g_signal_connect(G_OBJECT(view), &quot;button-press-event&quot;, G_CALLBACK(view_onButtonPressed), d);</a>
<a name="ln2063">  g_signal_connect(G_OBJECT(view), &quot;popup-menu&quot;, G_CALLBACK(view_onPopupMenu), d);</a>
<a name="ln2064"> </a>
<a name="ln2065">  GtkTreeViewColumn *col = gtk_tree_view_column_new();</a>
<a name="ln2066">  gtk_tree_view_append_column(view, col);</a>
<a name="ln2067">  GtkCellRenderer *renderer = gtk_cell_renderer_text_new();</a>
<a name="ln2068">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln2069">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_count_show, NULL, NULL);</a>
<a name="ln2070">  g_object_set(renderer, &quot;strikethrough&quot;, TRUE, (gchar *)0);</a>
<a name="ln2071">  gtk_tree_view_column_add_attribute(col, renderer, &quot;strikethrough-set&quot;, DT_LIB_COLLECT_COL_UNREACHABLE);</a>
<a name="ln2072"> </a>
<a name="ln2073">  GtkTreeModel *listmodel</a>
<a name="ln2074">      = GTK_TREE_MODEL(gtk_list_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2075">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln2076">  d-&gt;listfilter = gtk_tree_model_filter_new(listmodel, NULL);</a>
<a name="ln2077">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;listfilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln2078"> </a>
<a name="ln2079">  GtkTreeModel *treemodel</a>
<a name="ln2080">      = GTK_TREE_MODEL(gtk_tree_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln2081">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln2082">  d-&gt;treefilter = gtk_tree_model_filter_new(treemodel, NULL);</a>
<a name="ln2083">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;treefilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln2084">  g_object_unref(treemodel);</a>
<a name="ln2085"> </a>
<a name="ln2086">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw), TRUE, TRUE, 0);</a>
<a name="ln2087"> </a>
<a name="ln2088">  GtkWidget *sw2 = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln2089">  d-&gt;sw2 = GTK_SCROLLED_WINDOW(sw2);</a>
<a name="ln2090">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln2091">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(sw2), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln2092"> </a>
<a name="ln2093">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw2), TRUE, TRUE, 0);</a>
<a name="ln2094"> </a>
<a name="ln2095">  /* setup proxy */</a>
<a name="ln2096">  darktable.view_manager-&gt;proxy.module_collect.module = self;</a>
<a name="ln2097">  darktable.view_manager-&gt;proxy.module_collect.update = _lib_collect_gui_update;</a>
<a name="ln2098"> </a>
<a name="ln2099">  _lib_collect_gui_update(self);</a>
<a name="ln2100"> </a>
<a name="ln2101">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED, G_CALLBACK(collection_updated),</a>
<a name="ln2102">                            self);</a>
<a name="ln2103"> </a>
<a name="ln2104">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED, G_CALLBACK(filmrolls_updated),</a>
<a name="ln2105">                            self);</a>
<a name="ln2106"> </a>
<a name="ln2107">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_IMPORTED, G_CALLBACK(filmrolls_imported),</a>
<a name="ln2108">                            self);</a>
<a name="ln2109"> </a>
<a name="ln2110">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_REMOVED, G_CALLBACK(filmrolls_removed),</a>
<a name="ln2111">                            self);</a>
<a name="ln2112"> </a>
<a name="ln2113">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED, G_CALLBACK(tag_changed),</a>
<a name="ln2114">                            self);</a>
<a name="ln2115"> </a>
<a name="ln2116">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE, G_CALLBACK(view_set_click), self);</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln2120">{</a>
<a name="ln2121">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln2122"> </a>
<a name="ln2123">  for(int i = 0; i &lt; MAX_RULES; i++) dt_gui_key_accel_block_on_focus_disconnect(d-&gt;rule[i].text);</a>
<a name="ln2124"> </a>
<a name="ln2125">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(collection_updated), self);</a>
<a name="ln2126">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_updated), self);</a>
<a name="ln2127">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_imported), self);</a>
<a name="ln2128">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_removed), self);</a>
<a name="ln2129">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(tag_changed), self);</a>
<a name="ln2130">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(view_set_click), self);</a>
<a name="ln2131">  darktable.view_manager-&gt;proxy.module_collect.module = NULL;</a>
<a name="ln2132">  free(d-&gt;params);</a>
<a name="ln2133"> </a>
<a name="ln2134">  /* cleanup mem */</a>
<a name="ln2135"> </a>
<a name="ln2136">  g_object_unref(d-&gt;treefilter);</a>
<a name="ln2137">  g_object_unref(d-&gt;listfilter);</a>
<a name="ln2138"> </a>
<a name="ln2139">  /* TODO: Make sure we are cleaning up all allocations */</a>
<a name="ln2140"> </a>
<a name="ln2141">  free(self-&gt;data);</a>
<a name="ln2142">  self-&gt;data = NULL;</a>
<a name="ln2143">}</a>
<a name="ln2144"> </a>
<a name="ln2145"> </a>
<a name="ln2146">#ifdef USE_LUA</a>
<a name="ln2147">static int new_rule_cb(lua_State*L)</a>
<a name="ln2148">{</a>
<a name="ln2149">  dt_lib_collect_params_rule_t rule;</a>
<a name="ln2150">  memset(&amp;rule,0, sizeof(dt_lib_collect_params_rule_t));</a>
<a name="ln2151">  luaA_push(L,dt_lib_collect_params_rule_t,&amp;rule);</a>
<a name="ln2152">  return 1;</a>
<a name="ln2153">}</a>
<a name="ln2154">static int filter_cb(lua_State *L)</a>
<a name="ln2155">{</a>
<a name="ln2156">  dt_lib_module_t *self = lua_touserdata(L, lua_upvalueindex(1));</a>
<a name="ln2157"> </a>
<a name="ln2158">  int size;</a>
<a name="ln2159">  dt_lib_collect_params_t *p = get_params(self,&amp;size);</a>
<a name="ln2160">  // put it in stack so memory is not lost if a lua exception is raised</a>
<a name="ln2161"> </a>
<a name="ln2162"> </a>
<a name="ln2163"> </a>
<a name="ln2164">  if(lua_gettop(L) &gt; 0) {</a>
<a name="ln2165">    luaL_checktype(L,1,LUA_TTABLE);</a>
<a name="ln2166">    dt_lib_collect_params_t *new_p = get_params(self,&amp;size);</a>
<a name="ln2167">    new_p-&gt;rules = 0;</a>
<a name="ln2168">    do {</a>
<a name="ln2169">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln2170">      lua_gettable(L,1);</a>
<a name="ln2171">      if(lua_isnil(L,-1)) break;</a>
<a name="ln2172">      luaA_to(L,dt_lib_collect_params_rule_t,&amp;new_p-&gt;rule[new_p-&gt;rules],-1);</a>
<a name="ln2173">      new_p-&gt;rules++;</a>
<a name="ln2174">    }while(new_p-&gt;rules &lt; MAX_RULES);</a>
<a name="ln2175">    if(new_p-&gt;rules == MAX_RULES) {</a>
<a name="ln2176">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln2177">      lua_gettable(L,1);</a>
<a name="ln2178">      if(!lua_isnil(L,-1)) {</a>
<a name="ln2179">        luaL_error(L,&quot;Number of rules given excedes max allowed (%d)&quot;,MAX_RULES);</a>
<a name="ln2180">      }</a>
<a name="ln2181">    }</a>
<a name="ln2182">    set_params(self,new_p,size);</a>
<a name="ln2183">    free(new_p);</a>
<a name="ln2184"> </a>
<a name="ln2185">  }</a>
<a name="ln2186">  lua_newtable(L);</a>
<a name="ln2187">  for(int i = 0; i &lt; p-&gt;rules; i++) {</a>
<a name="ln2188">    luaA_push(L,dt_lib_collect_params_rule_t,&amp;p-&gt;rule[i]);</a>
<a name="ln2189">    luaL_ref(L,-2);</a>
<a name="ln2190">  }</a>
<a name="ln2191">  free(p);</a>
<a name="ln2192">  return 1;</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">static int mode_member(lua_State *L)</a>
<a name="ln2196">{</a>
<a name="ln2197">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2198">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2199">    dt_lib_collect_mode_t value;</a>
<a name="ln2200">    luaA_to(L,dt_lib_collect_mode_t,&amp;value,3);</a>
<a name="ln2201">    rule-&gt;mode = value;</a>
<a name="ln2202">    return 0;</a>
<a name="ln2203">  }</a>
<a name="ln2204">  const dt_lib_collect_mode_t tmp = rule-&gt;mode; // temp buffer because of bitfield in the original struct</a>
<a name="ln2205">  luaA_push(L,dt_lib_collect_mode_t,&amp;tmp);</a>
<a name="ln2206">  return 1;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209">static int item_member(lua_State *L)</a>
<a name="ln2210">{</a>
<a name="ln2211">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2212"> </a>
<a name="ln2213">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2214">    dt_collection_properties_t value;</a>
<a name="ln2215">    luaA_to(L,dt_collection_properties_t,&amp;value,3);</a>
<a name="ln2216">    rule-&gt;item = value;</a>
<a name="ln2217">    return 0;</a>
<a name="ln2218">  }</a>
<a name="ln2219">  const dt_collection_properties_t tmp = rule-&gt;item; // temp buffer because of bitfield in the original struct</a>
<a name="ln2220">  luaA_push(L,dt_collection_properties_t,&amp;tmp);</a>
<a name="ln2221">  return 1;</a>
<a name="ln2222">}</a>
<a name="ln2223"> </a>
<a name="ln2224">static int data_member(lua_State *L)</a>
<a name="ln2225">{</a>
<a name="ln2226">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2227"> </a>
<a name="ln2228">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2229">    size_t tgt_size;</a>
<a name="ln2230">    const char*data = luaL_checklstring(L,3,&amp;tgt_size);</a>
<a name="ln2231">    if(tgt_size &gt; PARAM_STRING_SIZE)</a>
<a name="ln2232">    {</a>
<a name="ln2233">      return luaL_error(L, &quot;string '%s' too long (max is %d)&quot;, data, PARAM_STRING_SIZE);</a>
<a name="ln2234">    }</a>
<a name="ln2235">    g_strlcpy(rule-&gt;string, data, sizeof(rule-&gt;string));</a>
<a name="ln2236">    return 0;</a>
<a name="ln2237">  }</a>
<a name="ln2238">  lua_pushstring(L,rule-&gt;string);</a>
<a name="ln2239">  return 1;</a>
<a name="ln2240">}</a>
<a name="ln2241"> </a>
<a name="ln2242"> </a>
<a name="ln2243"> </a>
<a name="ln2244">void init(struct dt_lib_module_t *self)</a>
<a name="ln2245">{</a>
<a name="ln2246"> </a>
<a name="ln2247">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln2248">  int my_type = dt_lua_module_entry_get_type(L, &quot;lib&quot;, self-&gt;plugin_name);</a>
<a name="ln2249">  lua_pushlightuserdata(L, self);</a>
<a name="ln2250">  lua_pushcclosure(L, filter_cb,1);</a>
<a name="ln2251">  dt_lua_gtk_wrap(L);</a>
<a name="ln2252">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2253">  dt_lua_type_register_const_type(L, my_type, &quot;filter&quot;);</a>
<a name="ln2254">  lua_pushcfunction(L, new_rule_cb);</a>
<a name="ln2255">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2256">  dt_lua_type_register_const_type(L, my_type, &quot;new_rule&quot;);</a>
<a name="ln2257"> </a>
<a name="ln2258">  dt_lua_init_type(L,dt_lib_collect_params_rule_t);</a>
<a name="ln2259">  lua_pushcfunction(L,mode_member);</a>
<a name="ln2260">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;mode&quot;);</a>
<a name="ln2261">  lua_pushcfunction(L,item_member);</a>
<a name="ln2262">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;item&quot;);</a>
<a name="ln2263">  lua_pushcfunction(L,data_member);</a>
<a name="ln2264">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;data&quot;);</a>
<a name="ln2265"> </a>
<a name="ln2266"> </a>
<a name="ln2267">  luaA_enum(L,dt_lib_collect_mode_t);</a>
<a name="ln2268">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln2269">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_OR);</a>
<a name="ln2270">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND_NOT);</a>
<a name="ln2271"> </a>
<a name="ln2272">  luaA_enum(L,dt_collection_properties_t);</a>
<a name="ln2273">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln2274">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln2275">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CAMERA);</a>
<a name="ln2276">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TAG);</a>
<a name="ln2277">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DAY);</a>
<a name="ln2278">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TIME);</a>
<a name="ln2279">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_HISTORY);</a>
<a name="ln2280">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_COLORLABEL);</a>
<a name="ln2281">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TITLE);</a>
<a name="ln2282">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DESCRIPTION);</a>
<a name="ln2283">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CREATOR);</a>
<a name="ln2284">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_PUBLISHER);</a>
<a name="ln2285">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_RIGHTS);</a>
<a name="ln2286">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LENS);</a>
<a name="ln2287">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOCAL_LENGTH);</a>
<a name="ln2288">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ISO);</a>
<a name="ln2289">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_APERTURE);</a>
<a name="ln2290">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ASPECT_RATIO);</a>
<a name="ln2291">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_EXPOSURE);</a>
<a name="ln2292">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILENAME);</a>
<a name="ln2293">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GEOTAGGING);</a>
<a name="ln2294">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LOCAL_COPY);</a>
<a name="ln2295">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GROUPING);</a>
<a name="ln2296"> </a>
<a name="ln2297">}</a>
<a name="ln2298">#endif</a>
<a name="ln2299">#undef MAX_RULES</a>
<a name="ln2300">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2301">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2302">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 166, 165.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="778"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: level > 0.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'level > 0' condition was already verified in line 790.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'result'. Check lines: 846, 844.</p></div>
<div class="balloon" rel="993"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tuple'. Check lines: 993, 992.</p></div>
<div class="balloon" rel="1169"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'range'. Check lines: 1169, 1167.</p></div>
<div class="balloon" rel="1469"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'range'. Check lines: 1469, 1468.</p></div>
<div class="balloon" rel="2008"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 2008, 2002.</p></div>
<div class="balloon" rel="2167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_p'.</p></div>
<div class="balloon" rel="2187"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
