
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, henrik andersson.</a>
<a name="ln4">    copyright (c) 2012 Jose Carlos Garcia Sogo</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;libs/collect.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/film.h&quot;</a>
<a name="ln24">#include &quot;common/metadata.h&quot;</a>
<a name="ln25">#include &quot;common/utility.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;control/jobs.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;libs/lib.h&quot;</a>
<a name="ln32">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln33">#include &quot;views/view.h&quot;</a>
<a name="ln34">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln35">#include &quot;osx/osx.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">DT_MODULE(1)</a>
<a name="ln39"> </a>
<a name="ln40">#define MAX_RULES 10</a>
<a name="ln41"> </a>
<a name="ln42">#define PARAM_STRING_SIZE 256 // FIXME: is this enough !?</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_lib_collect_rule_t</a>
<a name="ln45">{</a>
<a name="ln46">  int num;</a>
<a name="ln47">  GtkWidget *hbox;</a>
<a name="ln48">  GtkComboBox *combo;</a>
<a name="ln49">  GtkWidget *text;</a>
<a name="ln50">  GtkWidget *button;</a>
<a name="ln51">  gboolean typing;</a>
<a name="ln52">} dt_lib_collect_rule_t;</a>
<a name="ln53"> </a>
<a name="ln54">typedef struct dt_lib_collect_t</a>
<a name="ln55">{</a>
<a name="ln56">  dt_lib_collect_rule_t rule[MAX_RULES];</a>
<a name="ln57">  int active_rule;</a>
<a name="ln58">  int nb_rules;</a>
<a name="ln59"> </a>
<a name="ln60">  GtkTreeView *view;</a>
<a name="ln61">  int view_rule;</a>
<a name="ln62"> </a>
<a name="ln63">  GtkTreeModel *treefilter;</a>
<a name="ln64">  GtkTreeModel *listfilter;</a>
<a name="ln65">  GtkScrolledWindow *scrolledwindow;</a>
<a name="ln66"> </a>
<a name="ln67">  GtkScrolledWindow *sw2;</a>
<a name="ln68"> </a>
<a name="ln69">  struct dt_lib_collect_params_t *params;</a>
<a name="ln70">} dt_lib_collect_t;</a>
<a name="ln71"> </a>
<a name="ln72">typedef struct dt_lib_collect_params_rule_t</a>
<a name="ln73">{</a>
<a name="ln74">    uint32_t item : 16;</a>
<a name="ln75">    uint32_t mode : 16;</a>
<a name="ln76">    char string[PARAM_STRING_SIZE];</a>
<a name="ln77">} dt_lib_collect_params_rule_t;</a>
<a name="ln78"> </a>
<a name="ln79">typedef struct dt_lib_collect_params_t</a>
<a name="ln80">{</a>
<a name="ln81">  uint32_t rules;</a>
<a name="ln82">  dt_lib_collect_params_rule_t rule[MAX_RULES];</a>
<a name="ln83">} dt_lib_collect_params_t;</a>
<a name="ln84"> </a>
<a name="ln85">typedef enum dt_lib_collect_cols_t</a>
<a name="ln86">{</a>
<a name="ln87">  DT_LIB_COLLECT_COL_TEXT = 0,</a>
<a name="ln88">  DT_LIB_COLLECT_COL_ID,</a>
<a name="ln89">  DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln90">  DT_LIB_COLLECT_COL_PATH,</a>
<a name="ln91">  DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln92">  DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln93">  DT_LIB_COLLECT_COL_COUNT,</a>
<a name="ln94">  DT_LIB_COLLECT_NUM_COLS</a>
<a name="ln95">} dt_lib_collect_cols_t;</a>
<a name="ln96"> </a>
<a name="ln97">typedef struct _image_t</a>
<a name="ln98">{</a>
<a name="ln99">  int id;</a>
<a name="ln100">  int filmid;</a>
<a name="ln101">  gchar *path;</a>
<a name="ln102">  gchar *filename;</a>
<a name="ln103">  int exists;</a>
<a name="ln104">} _image_t;</a>
<a name="ln105"> </a>
<a name="ln106">static void _lib_collect_gui_update(dt_lib_module_t *self);</a>
<a name="ln107">static void _lib_folders_update_collection(const gchar *filmroll);</a>
<a name="ln108">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln109">                          dt_lib_collect_rule_t *d);</a>
<a name="ln110">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr);</a>
<a name="ln111">static void collection_updated(gpointer instance, gpointer self);</a>
<a name="ln112">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d);</a>
<a name="ln113"> </a>
<a name="ln114">const char *name(dt_lib_module_t *self)</a>
<a name="ln115">{</a>
<a name="ln116">  return _(&quot;collect images&quot;);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void init_presets(dt_lib_module_t *self)</a>
<a name="ln120">{</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Update the params struct with active ruleset */</a>
<a name="ln124">static void _lib_collect_update_params(dt_lib_collect_t *d)</a>
<a name="ln125">{</a>
<a name="ln126">  /* reset params */</a>
<a name="ln127">  dt_lib_collect_params_t *p = d-&gt;params;</a>
<a name="ln128">  memset(p, 0, sizeof(dt_lib_collect_params_t));</a>
<a name="ln129"> </a>
<a name="ln130">  /* for each active rule set update params */</a>
<a name="ln131">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln132">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln133">  char confname[200] = { 0 };</a>
<a name="ln134">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln135">  {</a>
<a name="ln136">    /* get item */</a>
<a name="ln137">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln138">    p-&gt;rule[i].item = dt_conf_get_int(confname);</a>
<a name="ln139"> </a>
<a name="ln140">    /* get mode */</a>
<a name="ln141">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln142">    p-&gt;rule[i].mode = dt_conf_get_int(confname);</a>
<a name="ln143"> </a>
<a name="ln144">    /* get string */</a>
<a name="ln145">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln146">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln147">    if(string != NULL)</a>
<a name="ln148">    {</a>
<a name="ln149">      snprintf(p-&gt;rule[i].string, PARAM_STRING_SIZE, &quot;%s&quot;, string);</a>
<a name="ln150">      g_free(string);</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    // fprintf(stderr,&quot;[%i] %d,%d,%s\n&quot;,i, p-&gt;rule[i].item, p-&gt;rule[i].mode,  p-&gt;rule[i].string);</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  p-&gt;rules = active + 1;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">void *get_params(dt_lib_module_t *self, int *size)</a>
<a name="ln160">{</a>
<a name="ln161">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln162"> </a>
<a name="ln163">  /* allocate a copy of params to return, freed by caller */</a>
<a name="ln164">  *size = sizeof(dt_lib_collect_params_t);</a>
<a name="ln165">  void *p = malloc(*size);</a>
<a name="ln166">  memcpy(p, ((dt_lib_collect_t *)self-&gt;data)-&gt;params, *size);</a>
<a name="ln167">  return p;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int set_params(dt_lib_module_t *self, const void *params, int size)</a>
<a name="ln171">{</a>
<a name="ln172">  /* update conf settings from params */</a>
<a name="ln173">  dt_lib_collect_params_t *p = (dt_lib_collect_params_t *)params;</a>
<a name="ln174">  char confname[200] = { 0 };</a>
<a name="ln175"> </a>
<a name="ln176">  for(uint32_t i = 0; i &lt; p-&gt;rules; i++)</a>
<a name="ln177">  {</a>
<a name="ln178">    /* set item */</a>
<a name="ln179">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln180">    dt_conf_set_int(confname, p-&gt;rule[i].item);</a>
<a name="ln181"> </a>
<a name="ln182">    /* set mode */</a>
<a name="ln183">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln184">    dt_conf_set_int(confname, p-&gt;rule[i].mode);</a>
<a name="ln185"> </a>
<a name="ln186">    /* set string */</a>
<a name="ln187">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln188">    dt_conf_set_string(confname, p-&gt;rule[i].string);</a>
<a name="ln189">  }</a>
<a name="ln190"> </a>
<a name="ln191">  /* set number of rules */</a>
<a name="ln192">  g_strlcpy(confname, &quot;plugins/lighttable/collect/num_rules&quot;, sizeof(confname));</a>
<a name="ln193">  dt_conf_set_int(confname, p-&gt;rules);</a>
<a name="ln194"> </a>
<a name="ln195">  /* update internal params */</a>
<a name="ln196">  _lib_collect_update_params(self-&gt;data);</a>
<a name="ln197"> </a>
<a name="ln198">  /* update ui */</a>
<a name="ln199">  _lib_collect_gui_update(self);</a>
<a name="ln200"> </a>
<a name="ln201">  /* update view */</a>
<a name="ln202">  dt_collection_update_query(darktable.collection);</a>
<a name="ln203"> </a>
<a name="ln204">  return 0;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">const char **views(dt_lib_module_t *self)</a>
<a name="ln209">{</a>
<a name="ln210">  static const char *v[] = {&quot;lighttable&quot;, &quot;map&quot;, &quot;print&quot;, NULL};</a>
<a name="ln211">  return v;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln215">{</a>
<a name="ln216">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">static void view_popup_menu_onSearchFilmroll(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln220">{</a>
<a name="ln221">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln222">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln223">  GtkWidget *filechooser;</a>
<a name="ln224"> </a>
<a name="ln225">  GtkTreeSelection *selection;</a>
<a name="ln226">  GtkTreeIter iter, child;</a>
<a name="ln227">  GtkTreeModel *model;</a>
<a name="ln228"> </a>
<a name="ln229">  gchar *tree_path = NULL;</a>
<a name="ln230">  gchar *new_path = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln233">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln234">  if (!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln235">    return;</a>
<a name="ln236"> </a>
<a name="ln237">  child = iter;</a>
<a name="ln238">  gtk_tree_model_iter_parent(model, &amp;iter, &amp;child);</a>
<a name="ln239">  gtk_tree_model_get(model, &amp;child, DT_LIB_COLLECT_COL_PATH, &amp;tree_path, -1);</a>
<a name="ln240"> </a>
<a name="ln241">  filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln242">    _(&quot;search filmroll&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln243">    GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln244">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln245">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln246">#endif</a>
<a name="ln247"> </a>
<a name="ln248">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln249">  if(tree_path != NULL)</a>
<a name="ln250">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), tree_path);</a>
<a name="ln251">  else</a>
<a name="ln252">    goto error;</a>
<a name="ln253"> </a>
<a name="ln254">  // run the dialog</a>
<a name="ln255">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln256">  {</a>
<a name="ln257">    gint id = -1;</a>
<a name="ln258">    sqlite3_stmt *stmt;</a>
<a name="ln259">    gchar *query = NULL;</a>
<a name="ln260"> </a>
<a name="ln261">    gchar *uri = NULL;</a>
<a name="ln262">    uri = gtk_file_chooser_get_uri(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln263">    new_path = g_filename_from_uri(uri, NULL, NULL);</a>
<a name="ln264">    g_free(uri);</a>
<a name="ln265">    if(new_path)</a>
<a name="ln266">    {</a>
<a name="ln267">      gchar *old = NULL;</a>
<a name="ln268">      query = dt_util_dstrcat(query, &quot;SELECT id, folder FROM main.film_rolls WHERE folder LIKE '%s%%'&quot;, tree_path);</a>
<a name="ln269">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln270">      g_free(query);</a>
<a name="ln271">      query = NULL;</a>
<a name="ln272"> </a>
<a name="ln273">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln274">      {</a>
<a name="ln275">        id = sqlite3_column_int(stmt, 0);</a>
<a name="ln276">        old = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln277"> </a>
<a name="ln278">        query = NULL;</a>
<a name="ln279">        query = dt_util_dstrcat(query, &quot;UPDATE main.film_rolls SET folder=?1 WHERE id=?2&quot;);</a>
<a name="ln280"> </a>
<a name="ln281">        gchar trailing[1024] = { 0 };</a>
<a name="ln282">        gchar final[1024] = { 0 };</a>
<a name="ln283"> </a>
<a name="ln284">        if(g_strcmp0(old, tree_path))</a>
<a name="ln285">        {</a>
<a name="ln286">          g_snprintf(trailing, sizeof(trailing), &quot;%s&quot;, old + strlen(tree_path) + 1);</a>
<a name="ln287">          g_snprintf(final, sizeof(final), &quot;%s/%s&quot;, new_path, trailing);</a>
<a name="ln288">        }</a>
<a name="ln289">        else</a>
<a name="ln290">        {</a>
<a name="ln291">          g_snprintf(final, sizeof(final), &quot;%s&quot;, new_path);</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">        sqlite3_stmt *stmt2;</a>
<a name="ln295">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt2, NULL);</a>
<a name="ln296">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt2, 1, final, -1, SQLITE_STATIC);</a>
<a name="ln297">        DT_DEBUG_SQLITE3_BIND_INT(stmt2, 2, id);</a>
<a name="ln298">        sqlite3_step(stmt2);</a>
<a name="ln299">        sqlite3_finalize(stmt2);</a>
<a name="ln300">      }</a>
<a name="ln301">      sqlite3_finalize(stmt);</a>
<a name="ln302">      g_free(query);</a>
<a name="ln303"> </a>
<a name="ln304">      /* reset filter so that view isn't empty */</a>
<a name="ln305">      dt_view_filter_reset(darktable.view_manager, FALSE);</a>
<a name="ln306"> </a>
<a name="ln307">      /* update collection to view missing filmroll */</a>
<a name="ln308">      _lib_folders_update_collection(new_path);</a>
<a name="ln309"> </a>
<a name="ln310">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln311">    }</a>
<a name="ln312">    else</a>
<a name="ln313">      goto error;</a>
<a name="ln314">  }</a>
<a name="ln315">  g_free(tree_path);</a>
<a name="ln316">  g_free(new_path);</a>
<a name="ln317">  gtk_widget_destroy(filechooser);</a>
<a name="ln318">  return;</a>
<a name="ln319"> </a>
<a name="ln320">error:</a>
<a name="ln321">  /* Something wrong happened */</a>
<a name="ln322">  gtk_widget_destroy(filechooser);</a>
<a name="ln323">  dt_control_log(_(&quot;problem selecting new path for the filmroll in %s&quot;), tree_path);</a>
<a name="ln324"> </a>
<a name="ln325">  g_free(tree_path);</a>
<a name="ln326">  g_free(new_path);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">static void view_popup_menu_onRemove(GtkWidget *menuitem, gpointer userdata)</a>
<a name="ln330">{</a>
<a name="ln331">  GtkTreeView *treeview = GTK_TREE_VIEW(userdata);</a>
<a name="ln332"> </a>
<a name="ln333">  GtkTreeSelection *selection;</a>
<a name="ln334">  GtkTreeIter iter, model_iter;</a>
<a name="ln335">  GtkTreeModel *model;</a>
<a name="ln336"> </a>
<a name="ln337">  gchar *filmroll_path = NULL;</a>
<a name="ln338">  gchar *fullq = NULL;</a>
<a name="ln339"> </a>
<a name="ln340">  /* Get info about the filmroll (or parent) selected */</a>
<a name="ln341">  model = gtk_tree_view_get_model(treeview);</a>
<a name="ln342">  selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln343">  if (gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))</a>
<a name="ln344">  {</a>
<a name="ln345">    gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;filmroll_path, -1);</a>
<a name="ln346"> </a>
<a name="ln347">    /* Clean selected images, and add to the table those which are going to be deleted */</a>
<a name="ln348">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln349"> </a>
<a name="ln350">    fullq = dt_util_dstrcat(fullq, &quot;INSERT INTO main.selected_images SELECT id FROM main.images WHERE film_id IN &quot;</a>
<a name="ln351">                                   &quot;(SELECT id FROM main.film_rolls WHERE folder LIKE '%s%%')&quot;,</a>
<a name="ln352">                            filmroll_path);</a>
<a name="ln353">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), fullq, NULL, NULL, NULL);</a>
<a name="ln354"> </a>
<a name="ln355">    if (dt_control_remove_images())</a>
<a name="ln356">    {</a>
<a name="ln357">      gtk_tree_model_filter_convert_iter_to_child_iter(GTK_TREE_MODEL_FILTER(model), &amp;model_iter, &amp;iter);</a>
<a name="ln358">      gtk_tree_store_remove(GTK_TREE_STORE(gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(model))),</a>
<a name="ln359">                            &amp;model_iter);</a>
<a name="ln360">    }</a>
<a name="ln361">  }</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">static void view_popup_menu(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln365">{</a>
<a name="ln366">  GtkWidget *menu, *menuitem;</a>
<a name="ln367"> </a>
<a name="ln368">  menu = gtk_menu_new();</a>
<a name="ln369"> </a>
<a name="ln370">  menuitem = gtk_menu_item_new_with_label(_(&quot;search filmroll...&quot;));</a>
<a name="ln371">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onSearchFilmroll, treeview);</a>
<a name="ln372">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln373"> </a>
<a name="ln374">  menuitem = gtk_menu_item_new_with_label(_(&quot;remove...&quot;));</a>
<a name="ln375">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);</a>
<a name="ln376">  g_signal_connect(menuitem, &quot;activate&quot;, (GCallback)view_popup_menu_onRemove, treeview);</a>
<a name="ln377"> </a>
<a name="ln378">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln379"> </a>
<a name="ln380">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln381">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln382">#else</a>
<a name="ln383">  /* Note: event can be NULL here when called from view_onPopupMenu;</a>
<a name="ln384">   *  gdk_event_get_time() accepts a NULL argument */</a>
<a name="ln385">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, (event != NULL) ? event-&gt;button : 0,</a>
<a name="ln386">                 gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln387">#endif</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">static gboolean view_onButtonPressed(GtkWidget *treeview, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln391">{</a>
<a name="ln392">  if((d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln393">     || (event-&gt;type == GDK_2BUTTON_PRESS &amp;&amp; event-&gt;button == 1))</a>
<a name="ln394">  {</a>
<a name="ln395">    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln396"> </a>
<a name="ln397">    if(gtk_tree_selection_count_selected_rows(selection) &lt;= 1)</a>
<a name="ln398">    {</a>
<a name="ln399">      GtkTreePath *path = NULL;</a>
<a name="ln400"> </a>
<a name="ln401">      /* Get tree path for row that was clicked */</a>
<a name="ln402">      if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), (gint)event-&gt;x, (gint)event-&gt;y, &amp;path, NULL,</a>
<a name="ln403">                                       NULL, NULL))</a>
<a name="ln404">      {</a>
<a name="ln405">        gtk_tree_selection_unselect_all(selection);</a>
<a name="ln406">        gtk_tree_selection_select_path(selection, path);</a>
<a name="ln407">      }</a>
<a name="ln408"> </a>
<a name="ln409">      /* single click on folder with the right mouse button? */</a>
<a name="ln410">      if (d-&gt;view_rule == DT_COLLECTION_PROP_FOLDERS &amp;&amp; (event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3))</a>
<a name="ln411">        view_popup_menu(treeview, event, d);</a>
<a name="ln412">      else</a>
<a name="ln413">        row_activated_with_event(GTK_TREE_VIEW(treeview), path, NULL, event, d);</a>
<a name="ln414"> </a>
<a name="ln415">      gtk_tree_path_free(path);</a>
<a name="ln416">    }</a>
<a name="ln417">    return TRUE; /* we handled this */</a>
<a name="ln418">  }</a>
<a name="ln419">  return FALSE; /* we did not handle this */</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">static gboolean view_onPopupMenu(GtkWidget *treeview, dt_lib_collect_t *d)</a>
<a name="ln423">{</a>
<a name="ln424">  if(d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS) return FALSE;</a>
<a name="ln425"> </a>
<a name="ln426">  view_popup_menu(treeview, NULL, d);</a>
<a name="ln427"> </a>
<a name="ln428">  return TRUE; /* we handled this */</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">static dt_lib_collect_t *get_collect(dt_lib_collect_rule_t *r)</a>
<a name="ln432">{</a>
<a name="ln433">  dt_lib_collect_t *d = (dt_lib_collect_t *)(((char *)r) - r-&gt;num * sizeof(dt_lib_collect_rule_t));</a>
<a name="ln434">  return d;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">static gboolean list_select(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln438">{</a>
<a name="ln439">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln440">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln441">  gchar *str = NULL;</a>
<a name="ln442"> </a>
<a name="ln443">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln444"> </a>
<a name="ln445">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln446">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln447"> </a>
<a name="ln448">  if(strcmp(haystack, needle) == 0)</a>
<a name="ln449">  {</a>
<a name="ln450">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln451">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  g_free(haystack);</a>
<a name="ln455">  g_free(needle);</a>
<a name="ln456">  g_free(str);</a>
<a name="ln457"> </a>
<a name="ln458">  return FALSE;</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">static gboolean tree_expand(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln462">{</a>
<a name="ln463">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln464">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln465">  gchar *str = NULL;</a>
<a name="ln466">  gchar *txt = NULL;</a>
<a name="ln467">  gboolean startwildcard = FALSE;</a>
<a name="ln468"> </a>
<a name="ln469">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_TEXT, &amp;txt, -1);</a>
<a name="ln470"> </a>
<a name="ln471">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln472">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln473">  gchar *txt2 = g_utf8_strdown(txt, -1);</a>
<a name="ln474"> </a>
<a name="ln475">  if(g_str_has_prefix(needle, &quot;%&quot;)) startwildcard = TRUE;</a>
<a name="ln476">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln477">  if(g_str_has_suffix(haystack, &quot;%&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln478">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln479">  {</a>
<a name="ln480">    if(g_str_has_suffix(needle, &quot;|&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln481">    if(g_str_has_suffix(haystack, &quot;|&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln482">  }</a>
<a name="ln483">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln484">  {</a>
<a name="ln485">    if(g_str_has_suffix(needle, &quot;/&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln486">    if(g_str_has_suffix(haystack, &quot;/&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln487">  }</a>
<a name="ln488">  else if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_DAY</a>
<a name="ln489">          || gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_TIME)</a>
<a name="ln490">  {</a>
<a name="ln491">    if(g_str_has_suffix(needle, &quot;:&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln492">    if(g_str_has_suffix(haystack, &quot;:&quot;)) haystack[strlen(haystack) - 1] = '\0';</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  if(dr-&gt;typing &amp;&amp; g_strrstr(txt2, needle) != NULL)</a>
<a name="ln496">  {</a>
<a name="ln497">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  if(strlen(needle)==0)</a>
<a name="ln501">  {</a>
<a name="ln502">    //nothing to do, we keep the tree collapsed</a>
<a name="ln503">  }</a>
<a name="ln504">  else if(strcmp(haystack, needle) == 0)</a>
<a name="ln505">  {</a>
<a name="ln506">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln507">    gtk_tree_selection_select_path(gtk_tree_view_get_selection(d-&gt;view), path);</a>
<a name="ln508">    gtk_tree_view_scroll_to_cell(d-&gt;view, path, NULL, FALSE, 0.2, 0);</a>
<a name="ln509">  }</a>
<a name="ln510">  else if(startwildcard &amp;&amp; g_strrstr(haystack, needle+1) != NULL)</a>
<a name="ln511">  {</a>
<a name="ln512">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln513">  }</a>
<a name="ln514">  else if(g_str_has_prefix(haystack, needle))</a>
<a name="ln515">  {</a>
<a name="ln516">    gtk_tree_view_expand_to_path(d-&gt;view, path);</a>
<a name="ln517">  }</a>
<a name="ln518"> </a>
<a name="ln519">  g_free(haystack);</a>
<a name="ln520">  g_free(needle);</a>
<a name="ln521">  g_free(txt2);</a>
<a name="ln522">  g_free(str);</a>
<a name="ln523">  g_free(txt);</a>
<a name="ln524"> </a>
<a name="ln525">  return FALSE;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">static gboolean list_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln529">{</a>
<a name="ln530">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln531">  gchar *str = NULL;</a>
<a name="ln532">  gboolean visible;</a>
<a name="ln533"> </a>
<a name="ln534">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, -1);</a>
<a name="ln535"> </a>
<a name="ln536">  gchar *haystack = g_utf8_strdown(str, -1);</a>
<a name="ln537">  gchar *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln538">  if(g_str_has_suffix(needle, &quot;%&quot;)) needle[strlen(needle) - 1] = '\0';</a>
<a name="ln539"> </a>
<a name="ln540">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln541">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln542">     || property == DT_COLLECTION_PROP_ISO)</a>
<a name="ln543">  {</a>
<a name="ln544">    // handle of numeric value, which can have some operator before the text</a>
<a name="ln545">    visible = TRUE;</a>
<a name="ln546">    gchar *operator, *number, *number2;</a>
<a name="ln547">    dt_collection_split_operator_number(needle, &amp;number, &amp;number2, &amp;operator);</a>
<a name="ln548">    if(number)</a>
<a name="ln549">    {</a>
<a name="ln550">      float nb1 = g_strtod(number, NULL);</a>
<a name="ln551">      float nb2 = g_strtod(haystack, NULL);</a>
<a name="ln552">      if(operator&amp;&amp; strcmp(operator, &quot;&gt;&quot;) == 0)</a>
<a name="ln553">      {</a>
<a name="ln554">        visible = (nb2 &gt; nb1);</a>
<a name="ln555">      }</a>
<a name="ln556">      else if(operator&amp;&amp; strcmp(operator, &quot;&gt;=&quot;) == 0)</a>
<a name="ln557">      {</a>
<a name="ln558">        visible = (nb2 &gt;= nb1);</a>
<a name="ln559">      }</a>
<a name="ln560">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&quot;) == 0)</a>
<a name="ln561">      {</a>
<a name="ln562">        visible = (nb2 &lt; nb1);</a>
<a name="ln563">      }</a>
<a name="ln564">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;=&quot;) == 0)</a>
<a name="ln565">      {</a>
<a name="ln566">        visible = (nb2 &lt;= nb1);</a>
<a name="ln567">      }</a>
<a name="ln568">      else if(operator&amp;&amp; strcmp(operator, &quot;&lt;&gt;&quot;) == 0)</a>
<a name="ln569">      {</a>
<a name="ln570">        visible = (nb1 != nb2);</a>
<a name="ln571">      }</a>
<a name="ln572">      else if(operator&amp;&amp; number2 &amp;&amp; strcmp(operator, &quot;[]&quot;) == 0)</a>
<a name="ln573">      {</a>
<a name="ln574">        float nb3 = g_strtod(number2, NULL);</a>
<a name="ln575">        visible = (nb2 &gt;= nb1 &amp;&amp; nb2 &lt;= nb3);</a>
<a name="ln576">      }</a>
<a name="ln577">      else</a>
<a name="ln578">      {</a>
<a name="ln579">        visible = (nb1 == nb2);</a>
<a name="ln580">      }</a>
<a name="ln581">    }</a>
<a name="ln582">    g_free(operator);</a>
<a name="ln583">    g_free(number);</a>
<a name="ln584">    g_free(number2);</a>
<a name="ln585">  }</a>
<a name="ln586">  else</a>
<a name="ln587">  {</a>
<a name="ln588">    if(g_str_has_prefix(needle, &quot;%&quot;))</a>
<a name="ln589">      visible = (g_strrstr(haystack, needle + 1) != NULL);</a>
<a name="ln590">    else</a>
<a name="ln591">      visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  g_free(haystack);</a>
<a name="ln595">  g_free(needle);</a>
<a name="ln596"> </a>
<a name="ln597">  g_free(str);</a>
<a name="ln598"> </a>
<a name="ln599">  gtk_list_store_set(GTK_LIST_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln600">  return FALSE;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">static gboolean tree_match_string(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln604">{</a>
<a name="ln605">  dt_lib_collect_rule_t *dr = (dt_lib_collect_rule_t *)data;</a>
<a name="ln606">  gchar *str = NULL;</a>
<a name="ln607">  gboolean cur_state, visible;</a>
<a name="ln608"> </a>
<a name="ln609">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_PATH, &amp;str, DT_LIB_COLLECT_COL_VISIBLE, &amp;cur_state, -1);</a>
<a name="ln610"> </a>
<a name="ln611">  if(dr-&gt;typing == FALSE &amp;&amp; !cur_state)</a>
<a name="ln612">  {</a>
<a name="ln613">    visible = TRUE;</a>
<a name="ln614">  }</a>
<a name="ln615">  else</a>
<a name="ln616">  {</a>
<a name="ln617">    gchar *haystack = g_utf8_strdown(str, -1),</a>
<a name="ln618">          *needle = g_utf8_strdown(gtk_entry_get_text(GTK_ENTRY(dr-&gt;text)), -1);</a>
<a name="ln619">    visible = (g_strrstr(haystack, needle) != NULL);</a>
<a name="ln620">    g_free(haystack);</a>
<a name="ln621">    g_free(needle);</a>
<a name="ln622">  }</a>
<a name="ln623"> </a>
<a name="ln624">  g_free(str);</a>
<a name="ln625"> </a>
<a name="ln626">  gtk_tree_store_set(GTK_TREE_STORE(model), iter, DT_LIB_COLLECT_COL_VISIBLE, visible, -1);</a>
<a name="ln627">  return FALSE;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">static gboolean tree_reveal_func(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln631">{</a>
<a name="ln632">  gboolean state;</a>
<a name="ln633">  GtkTreeIter parent, child = *iter;</a>
<a name="ln634"> </a>
<a name="ln635">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln636">  if(!state) return FALSE;</a>
<a name="ln637"> </a>
<a name="ln638">  while(gtk_tree_model_iter_parent(model, &amp;parent, &amp;child))</a>
<a name="ln639">  {</a>
<a name="ln640">    gtk_tree_model_get(model, &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, &amp;state, -1);</a>
<a name="ln641">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent, DT_LIB_COLLECT_COL_VISIBLE, TRUE, -1);</a>
<a name="ln642">    child = parent;</a>
<a name="ln643">  }</a>
<a name="ln644"> </a>
<a name="ln645">  return FALSE;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">static void tree_set_visibility(GtkTreeModel *model, gpointer data)</a>
<a name="ln649">{</a>
<a name="ln650">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_match_string, data);</a>
<a name="ln651"> </a>
<a name="ln652">  gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)tree_reveal_func, NULL);</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">static void _lib_folders_update_collection(const gchar *filmroll)</a>
<a name="ln656">{</a>
<a name="ln657"> </a>
<a name="ln658">  gchar *complete_query = NULL;</a>
<a name="ln659"> </a>
<a name="ln660">  // remove from selected images where not in this query.</a>
<a name="ln661">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln662">  const gchar *cquery = dt_collection_get_query(darktable.collection);</a>
<a name="ln663">  // complete_query = NULL;</a>
<a name="ln664">  if(cquery &amp;&amp; cquery[0] != '\0')</a>
<a name="ln665">  {</a>
<a name="ln666">    complete_query</a>
<a name="ln667">        = dt_util_dstrcat(complete_query, &quot;DELETE FROM main.selected_images WHERE imgid NOT IN (%s)&quot;, cquery);</a>
<a name="ln668">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), complete_query, -1, &amp;stmt, NULL);</a>
<a name="ln669">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, 0);</a>
<a name="ln670">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, -1);</a>
<a name="ln671">    sqlite3_step(stmt);</a>
<a name="ln672">    sqlite3_finalize(stmt);</a>
<a name="ln673"> </a>
<a name="ln674">    /* free allocated strings */</a>
<a name="ln675">    g_free(complete_query);</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  /* raise signal of collection change, only if this is an original */</a>
<a name="ln679">  if(!darktable.collection-&gt;clone) dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">static void set_properties(dt_lib_collect_rule_t *dr)</a>
<a name="ln683">{</a>
<a name="ln684">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln685">  const gchar *text = gtk_entry_get_text(GTK_ENTRY(dr-&gt;text));</a>
<a name="ln686"> </a>
<a name="ln687">  char confname[200] = { 0 };</a>
<a name="ln688">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, dr-&gt;num);</a>
<a name="ln689">  dt_conf_set_string(confname, text);</a>
<a name="ln690">  snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, dr-&gt;num);</a>
<a name="ln691">  dt_conf_set_int(confname, property);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">static GtkTreeModel *_create_filtered_model(GtkTreeModel *model, dt_lib_collect_rule_t *dr)</a>
<a name="ln695">{</a>
<a name="ln696">  GtkTreeModel *filter = NULL;</a>
<a name="ln697">  GtkTreePath *path = NULL;</a>
<a name="ln698"> </a>
<a name="ln699">  if(gtk_combo_box_get_active(dr-&gt;combo) == DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln700">  {</a>
<a name="ln701">    // we search a common path to all the folders</a>
<a name="ln702">    // we'll use it as root</a>
<a name="ln703">    GtkTreeIter child, iter;</a>
<a name="ln704">    int level = 0;</a>
<a name="ln705"> </a>
<a name="ln706">    while(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) &gt; 0)</a>
<a name="ln707">    {</a>
<a name="ln708">      if(level &gt; 0)</a>
<a name="ln709">      {</a>
<a name="ln710">        sqlite3_stmt *stmt = NULL;</a>
<a name="ln711">        gchar *pth = NULL;</a>
<a name="ln712">        int id = -1;</a>
<a name="ln713">        // Check if this path also matches a filmroll</a>
<a name="ln714">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;pth, -1);</a>
<a name="ln715">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln716">                                    &quot;SELECT id FROM main.film_rolls WHERE folder LIKE ?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln717">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, pth, -1, SQLITE_TRANSIENT);</a>
<a name="ln718">        if(sqlite3_step(stmt) == SQLITE_ROW) id = sqlite3_column_int(stmt, 0);</a>
<a name="ln719">        sqlite3_finalize(stmt);</a>
<a name="ln720"> </a>
<a name="ln721">        g_free(pth);</a>
<a name="ln722"> </a>
<a name="ln723">        if(id != -1)</a>
<a name="ln724">        {</a>
<a name="ln725">          // we go back to the parent, in order to show this folder</a>
<a name="ln726">          if(!gtk_tree_model_iter_parent(model, &amp;child, &amp;iter)) level = 0;</a>
<a name="ln727">          iter = child;</a>
<a name="ln728">          break;</a>
<a name="ln729">        }</a>
<a name="ln730">      }</a>
<a name="ln731">      if(gtk_tree_model_iter_n_children(model, level &gt; 0 ? &amp;iter : NULL) != 1) break;</a>
<a name="ln732"> </a>
<a name="ln733">      gtk_tree_model_iter_children(model, &amp;child, level &gt; 0 ? &amp;iter : NULL);</a>
<a name="ln734">      iter = child;</a>
<a name="ln735">      level++;</a>
<a name="ln736">    }</a>
<a name="ln737"> </a>
<a name="ln738">    if(level &gt; 0)</a>
<a name="ln739">    {</a>
<a name="ln740">      if(level &gt; 0 &amp;&amp;</a>
<a name="ln741">         gtk_tree_model_iter_n_children(model, &amp;iter) == 0 &amp;&amp;</a>
<a name="ln742">         gtk_tree_model_iter_parent(model, &amp;child, &amp;iter))</a>
<a name="ln743">      {</a>
<a name="ln744">        path = gtk_tree_model_get_path(model, &amp;child);</a>
<a name="ln745">      }</a>
<a name="ln746">      else</a>
<a name="ln747">      {</a>
<a name="ln748">        path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln749">      }</a>
<a name="ln750">    }</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  // Create filter and set virtual root</a>
<a name="ln754">  filter = gtk_tree_model_filter_new(model, path);</a>
<a name="ln755">  gtk_tree_path_free(path);</a>
<a name="ln756"> </a>
<a name="ln757">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(filter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln758"> </a>
<a name="ln759">  return filter;</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">static int string_array_length(char **list)</a>
<a name="ln763">{</a>
<a name="ln764">  int length = 0;</a>
<a name="ln765">  for(; *list; list++) length++;</a>
<a name="ln766">  return length;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">// returns a NULL terminated array of path components</a>
<a name="ln770">static char **split_path(const char *path)</a>
<a name="ln771">{</a>
<a name="ln772">  if(!path || !*path) return NULL;</a>
<a name="ln773"> </a>
<a name="ln774">  char **result;</a>
<a name="ln775">  char **tokens = g_strsplit(path, G_DIR_SEPARATOR_S, -1);</a>
<a name="ln776"> </a>
<a name="ln777">#ifdef _WIN32</a>
<a name="ln778"> </a>
<a name="ln779">  if(! (g_ascii_isalpha(tokens[0][0]) &amp;&amp; tokens[0][strlen(tokens[0]) - 1] == ':') )</a>
<a name="ln780">  {</a>
<a name="ln781">    g_strfreev(tokens);</a>
<a name="ln782">    tokens = NULL;</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  result = tokens;</a>
<a name="ln786"> </a>
<a name="ln787">#else</a>
<a name="ln788"> </a>
<a name="ln789">  // there are size + 1 elements in tokens -- the final NULL! we want to ignore it.</a>
<a name="ln790">  unsigned int size = g_strv_length(tokens);</a>
<a name="ln791"> </a>
<a name="ln792">  result = malloc(size * sizeof(char *));</a>
<a name="ln793">  for(unsigned int i = 0; i &lt; size; i++)</a>
<a name="ln794">    result[i] = tokens[i + 1];</a>
<a name="ln795"> </a>
<a name="ln796">  g_free(tokens[0]);</a>
<a name="ln797">  g_free(tokens);</a>
<a name="ln798"> </a>
<a name="ln799">#endif</a>
<a name="ln800"> </a>
<a name="ln801">  return result;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">typedef struct name_key_tuple_t</a>
<a name="ln805">{</a>
<a name="ln806">  char *name, *collate_key;</a>
<a name="ln807">  int count;</a>
<a name="ln808">} name_key_tuple_t;</a>
<a name="ln809"> </a>
<a name="ln810">static void free_tuple(gpointer data)</a>
<a name="ln811">{</a>
<a name="ln812">  name_key_tuple_t *tuple = (name_key_tuple_t *)data;</a>
<a name="ln813">  g_free(tuple-&gt;name);</a>
<a name="ln814">  g_free(tuple-&gt;collate_key);</a>
<a name="ln815">  free(tuple);</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">static gint sort_folder_tag(gconstpointer a, gconstpointer b)</a>
<a name="ln819">{</a>
<a name="ln820">  const name_key_tuple_t *tuple_a = (const name_key_tuple_t *)a;</a>
<a name="ln821">  const name_key_tuple_t *tuple_b = (const name_key_tuple_t *)b;</a>
<a name="ln822"> </a>
<a name="ln823">  return g_strcmp0(tuple_a-&gt;collate_key, tuple_b-&gt;collate_key);</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">// create a key such that &quot;darktable|&quot; is coming first, and the rest is ordered such that sub tags are coming directly</a>
<a name="ln827">// behind their parent</a>
<a name="ln828">static char *tag_collate_key(char *tag)</a>
<a name="ln829">{</a>
<a name="ln830">  size_t len = strlen(tag);</a>
<a name="ln831">  char *result = g_malloc(len + 2);</a>
<a name="ln832">  if(g_str_has_prefix(tag, &quot;darktable|&quot;))</a>
<a name="ln833">    *result = '\1';</a>
<a name="ln834">  else</a>
<a name="ln835">    *result = '\2';</a>
<a name="ln836">  memcpy(result + 1, tag, len + 1);</a>
<a name="ln837">  for(char *iter = result + 1; *iter; iter++)</a>
<a name="ln838">    if(*iter == '|') *iter = '\1';</a>
<a name="ln839">  return result;</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842"> </a>
<a name="ln843">void tree_count_show(GtkTreeViewColumn *col, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter,</a>
<a name="ln844">                     gpointer data)</a>
<a name="ln845">{</a>
<a name="ln846">  gchar *name;</a>
<a name="ln847">  guint count;</a>
<a name="ln848"> </a>
<a name="ln849">  gtk_tree_model_get(model, iter, DT_LIB_COLLECT_COL_TEXT, &amp;name, DT_LIB_COLLECT_COL_COUNT, &amp;count, -1);</a>
<a name="ln850">  if (!count)</a>
<a name="ln851">  {</a>
<a name="ln852">    g_object_set(renderer, &quot;text&quot;, name, NULL);</a>
<a name="ln853">  }</a>
<a name="ln854">  else</a>
<a name="ln855">  {</a>
<a name="ln856">    gchar *coltext = g_strdup_printf(&quot;%s (%d)&quot;, name, count);</a>
<a name="ln857">    g_object_set(renderer, &quot;text&quot;, coltext, NULL);</a>
<a name="ln858">    g_free(coltext);</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  g_free(name);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">static const char *UNCATEGORIZED_TAG = N_(&quot;uncategorized&quot;);</a>
<a name="ln865">static void tree_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln866">{</a>
<a name="ln867">  // update related list</a>
<a name="ln868">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln869">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln870">  const gboolean folders = (property == DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln871">  const gboolean tags = (property == DT_COLLECTION_PROP_TAG);</a>
<a name="ln872">  const gboolean days = (property == DT_COLLECTION_PROP_DAY);</a>
<a name="ln873">  const gboolean times = (property == DT_COLLECTION_PROP_TIME);</a>
<a name="ln874">  const char *format_separator = folders ? &quot;%s&quot; G_DIR_SEPARATOR_S :</a>
<a name="ln875">  days || times ? &quot;%s:&quot; : &quot;%s|&quot;;</a>
<a name="ln876">  int insert_position = tags ? 0 : -1;</a>
<a name="ln877"> </a>
<a name="ln878">  set_properties(dr);</a>
<a name="ln879"> </a>
<a name="ln880">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;treefilter));</a>
<a name="ln881"> </a>
<a name="ln882">  if(d-&gt;view_rule != property)</a>
<a name="ln883">  {</a>
<a name="ln884">    // tree creation/recreation</a>
<a name="ln885">    sqlite3_stmt *stmt;</a>
<a name="ln886">    GtkTreeIter uncategorized = { 0 };</a>
<a name="ln887">    GtkTreeIter temp;</a>
<a name="ln888"> </a>
<a name="ln889">    g_object_ref(model);</a>
<a name="ln890">    g_object_unref(d-&gt;treefilter);</a>
<a name="ln891">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln892">    gtk_tree_store_clear(GTK_TREE_STORE(model));</a>
<a name="ln893">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln894">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln895"> </a>
<a name="ln896">    /* query construction */</a>
<a name="ln897">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln898">    const char *query = g_strdup_printf(</a>
<a name="ln899">            folders ? &quot;SELECT folder, film_rolls_id, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln900">                    &quot;JOIN (SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln901">                    &quot;WHERE %s GROUP BY folder, film_rolls_id&quot;:</a>
<a name="ln902">            tags ? &quot;SELECT name, tag_id, COUNT(*) AS count FROM main.images JOIN main.tagged_images ON id = imgid &quot;</a>
<a name="ln903">                    &quot;JOIN (SELECT name, id AS tag_id FROM data.tags) ON tagid = tag_id &quot;</a>
<a name="ln904">                    &quot;WHERE %s GROUP BY name,tag_id&quot; :</a>
<a name="ln905">            days ? &quot;SELECT SUBSTR(datetime_taken, 1, 10) AS date, 1, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln906">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln907">            times ? &quot;SELECT datetime_taken AS date, 1, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln908">                    &quot;WHERE %s GROUP BY date ORDER BY datetime_taken ASC&quot; :</a>
<a name="ln909">            NULL,</a>
<a name="ln910">            where_ext);</a>
<a name="ln911"> </a>
<a name="ln912">    g_free(where_ext);</a>
<a name="ln913">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln914"> </a>
<a name="ln915">    char **last_tokens = NULL;</a>
<a name="ln916">    int last_tokens_length = 0;</a>
<a name="ln917">    GtkTreeIter last_parent = { 0 };</a>
<a name="ln918"> </a>
<a name="ln919">    // we need to sort the names ourselves and not let sqlite handle this</a>
<a name="ln920">    // because it knows nothing about path separators.</a>
<a name="ln921">    GList *sorted_names = NULL;</a>
<a name="ln922">    while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln923">    {</a>
<a name="ln924">      char *name = g_strdup((const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln925">      gchar *collate_key = NULL;</a>
<a name="ln926"> </a>
<a name="ln927">      const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln928"> </a>
<a name="ln929">      if(folders)</a>
<a name="ln930">      {</a>
<a name="ln931">        char *name_folded = g_utf8_casefold(name, -1);</a>
<a name="ln932">        char *name_folded_slash = g_strconcat(name_folded, G_DIR_SEPARATOR_S, NULL);</a>
<a name="ln933">        collate_key = g_utf8_collate_key_for_filename(name_folded_slash, -1);</a>
<a name="ln934">        g_free(name_folded_slash);</a>
<a name="ln935">        g_free(name_folded);</a>
<a name="ln936">      }</a>
<a name="ln937">      else if(tags)</a>
<a name="ln938">        collate_key = tag_collate_key(name);</a>
<a name="ln939"> </a>
<a name="ln940">      name_key_tuple_t *tuple = (name_key_tuple_t *)malloc(sizeof(name_key_tuple_t));</a>
<a name="ln941">      tuple-&gt;name = name;</a>
<a name="ln942">      tuple-&gt;collate_key = collate_key;</a>
<a name="ln943">      tuple-&gt;count = count;</a>
<a name="ln944">      sorted_names = g_list_prepend(sorted_names, tuple);</a>
<a name="ln945">    }</a>
<a name="ln946">    sqlite3_finalize(stmt);</a>
<a name="ln947"> </a>
<a name="ln948">    if(folders || tags)</a>
<a name="ln949">      sorted_names = g_list_sort(sorted_names, sort_folder_tag);</a>
<a name="ln950">    // we have to know about children in the hierarchy to not add single tags twice when they are</a>
<a name="ln951">    // also a top level hierarchy</a>
<a name="ln952">    if(tags)</a>
<a name="ln953">      sorted_names = g_list_reverse(sorted_names);</a>
<a name="ln954"> </a>
<a name="ln955">    for(GList *names = sorted_names; names; names = g_list_next(names))</a>
<a name="ln956">    {</a>
<a name="ln957">      name_key_tuple_t *tuple = (name_key_tuple_t *)names-&gt;data;</a>
<a name="ln958">      char *name = tuple-&gt;name;</a>
<a name="ln959">      const int count = tuple-&gt;count;</a>
<a name="ln960">      if(name == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln961"> </a>
<a name="ln962">      if(tags &amp;&amp; strchr(name, '|') == 0 &amp;&amp; (last_tokens_length == 0 || strcmp(name, *last_tokens)))</a>
<a name="ln963">      {</a>
<a name="ln964">        /* add uncategorized root iter if not exists */</a>
<a name="ln965">        if(!uncategorized.stamp)</a>
<a name="ln966">        {</a>
<a name="ln967">          gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;uncategorized, NULL, 0);</a>
<a name="ln968">          gtk_tree_store_set(GTK_TREE_STORE(model), &amp;uncategorized, DT_LIB_COLLECT_COL_TEXT,</a>
<a name="ln969">                             _(UNCATEGORIZED_TAG), DT_LIB_COLLECT_COL_PATH, &quot;&quot;, DT_LIB_COLLECT_COL_VISIBLE,</a>
<a name="ln970">                             TRUE, -1);</a>
<a name="ln971">          insert_position++; // we want to have this at the very top!</a>
<a name="ln972">        }</a>
<a name="ln973"> </a>
<a name="ln974">        /* adding an uncategorized tag */</a>
<a name="ln975">        gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;temp, &amp;uncategorized, 0);</a>
<a name="ln976">        gtk_tree_store_set(GTK_TREE_STORE(model), &amp;temp, DT_LIB_COLLECT_COL_TEXT, name,</a>
<a name="ln977">                           DT_LIB_COLLECT_COL_PATH, name, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln978">                           DT_LIB_COLLECT_COL_COUNT, count, -1);</a>
<a name="ln979">      }</a>
<a name="ln980">      else</a>
<a name="ln981">      {</a>
<a name="ln982">        char **tokens;</a>
<a name="ln983">        if(folders)</a>
<a name="ln984">          tokens = split_path(name);</a>
<a name="ln985">        else if(days)</a>
<a name="ln986">          tokens = g_strsplit(name, &quot;:&quot;, -1);</a>
<a name="ln987">        else if(times)</a>
<a name="ln988">          tokens = g_strsplit_set(name, &quot;: &quot;, 4);</a>
<a name="ln989">        else</a>
<a name="ln990">          tokens = g_strsplit(name, &quot;|&quot;, -1);</a>
<a name="ln991"> </a>
<a name="ln992">        if(tokens != NULL)</a>
<a name="ln993">        {</a>
<a name="ln994">          // find the number of common parts at the beginning of tokens and last_tokens</a>
<a name="ln995">          GtkTreeIter parent = last_parent;</a>
<a name="ln996">          int tokens_length = string_array_length(tokens);</a>
<a name="ln997">          int common_length = 0;</a>
<a name="ln998">          if(last_tokens)</a>
<a name="ln999">          {</a>
<a name="ln1000">            while(tokens[common_length] &amp;&amp; last_tokens[common_length] &amp;&amp;</a>
<a name="ln1001">                  !g_strcmp0(tokens[common_length], last_tokens[common_length]))</a>
<a name="ln1002">            {</a>
<a name="ln1003">              common_length++;</a>
<a name="ln1004">            }</a>
<a name="ln1005"> </a>
<a name="ln1006">            // point parent iter to where the entries should be added</a>
<a name="ln1007">            for(int i = common_length; i &lt; last_tokens_length; i++)</a>
<a name="ln1008">            {</a>
<a name="ln1009">              gtk_tree_model_iter_parent(model, &amp;parent, &amp;last_parent);</a>
<a name="ln1010">              last_parent = parent;</a>
<a name="ln1011">            }</a>
<a name="ln1012">          }</a>
<a name="ln1013"> </a>
<a name="ln1014">          // insert everything from tokens past the common part</a>
<a name="ln1015"> </a>
<a name="ln1016">          char *pth = NULL;</a>
<a name="ln1017">#ifndef _WIN32</a>
<a name="ln1018">          if(folders) pth = g_strdup(&quot;/&quot;);</a>
<a name="ln1019">#endif</a>
<a name="ln1020">          for(int i = 0; i &lt; common_length; i++)</a>
<a name="ln1021">            pth = dt_util_dstrcat(pth, format_separator, tokens[i]);</a>
<a name="ln1022"> </a>
<a name="ln1023">          for(char **token = &amp;tokens[common_length]; *token; token++)</a>
<a name="ln1024">          {</a>
<a name="ln1025">            GtkTreeIter iter;</a>
<a name="ln1026"> </a>
<a name="ln1027">            pth = dt_util_dstrcat(pth, format_separator, *token);</a>
<a name="ln1028">            if(times &amp;&amp; !*(token + 1)) pth[10] = ' ';</a>
<a name="ln1029"> </a>
<a name="ln1030">            gchar *pth2 = g_strdup(pth);</a>
<a name="ln1031">            pth2[strlen(pth2) - 1] = '\0';</a>
<a name="ln1032">            gtk_tree_store_insert(GTK_TREE_STORE(model), &amp;iter, common_length &gt; 0 ? &amp;parent : NULL, insert_position);</a>
<a name="ln1033">            gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, *token,</a>
<a name="ln1034">                               DT_LIB_COLLECT_COL_PATH, pth2, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1035">                               DT_LIB_COLLECT_COL_COUNT, (*(token + 1)?0:count), -1);</a>
<a name="ln1036"> </a>
<a name="ln1037">            // also add the item count to parents</a>
<a name="ln1038">            if((folders || days || times) &amp;&amp; !*(token + 1))</a>
<a name="ln1039">            {</a>
<a name="ln1040">              guint parentcount;</a>
<a name="ln1041">              GtkTreeIter parent2, child = iter;</a>
<a name="ln1042"> </a>
<a name="ln1043">              while(gtk_tree_model_iter_parent(model, &amp;parent2, &amp;child))</a>
<a name="ln1044">              {</a>
<a name="ln1045">                gtk_tree_model_get(model, &amp;parent2, DT_LIB_COLLECT_COL_COUNT, &amp;parentcount, -1);</a>
<a name="ln1046">                gtk_tree_store_set(GTK_TREE_STORE(model), &amp;parent2, DT_LIB_COLLECT_COL_COUNT, count + parentcount, -1);</a>
<a name="ln1047">                child = parent2;</a>
<a name="ln1048">              }</a>
<a name="ln1049">            }</a>
<a name="ln1050"> </a>
<a name="ln1051">            if(folders)</a>
<a name="ln1052">              gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_UNREACHABLE,</a>
<a name="ln1053">                                 !(g_file_test(pth, G_FILE_TEST_IS_DIR)), -1);</a>
<a name="ln1054">            common_length++;</a>
<a name="ln1055">            parent = iter;</a>
<a name="ln1056">            g_free(pth2);</a>
<a name="ln1057">          }</a>
<a name="ln1058"> </a>
<a name="ln1059">          g_free(pth);</a>
<a name="ln1060"> </a>
<a name="ln1061">          // remember things for the next round</a>
<a name="ln1062">          if(last_tokens) g_strfreev(last_tokens);</a>
<a name="ln1063">          last_tokens = tokens;</a>
<a name="ln1064">          last_parent = parent;</a>
<a name="ln1065">          last_tokens_length = tokens_length;</a>
<a name="ln1066">        }</a>
<a name="ln1067">      }</a>
<a name="ln1068">    }</a>
<a name="ln1069">    g_list_free_full(sorted_names, free_tuple);</a>
<a name="ln1070"> </a>
<a name="ln1071"> </a>
<a name="ln1072">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1073"> </a>
<a name="ln1074">    d-&gt;treefilter = _create_filtered_model(model, dr);</a>
<a name="ln1075"> </a>
<a name="ln1076">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;treefilter);</a>
<a name="ln1077">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1078">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1079"> </a>
<a name="ln1080">    g_object_unref(model);</a>
<a name="ln1081">    g_strfreev(last_tokens);</a>
<a name="ln1082"> </a>
<a name="ln1083">    d-&gt;view_rule = property;</a>
<a name="ln1084">  }</a>
<a name="ln1085"> </a>
<a name="ln1086">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1087">  if(dr-&gt;typing) tree_set_visibility(model, dr);</a>
<a name="ln1088">  // we update tree expansion and selection</a>
<a name="ln1089">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1090">  gtk_tree_view_collapse_all(d-&gt;view);</a>
<a name="ln1091">  gtk_tree_model_foreach(d-&gt;treefilter, (GtkTreeModelForeachFunc)tree_expand, dr);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">static void list_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1095">{</a>
<a name="ln1096">  // update related list</a>
<a name="ln1097">  dt_lib_collect_t *d = get_collect(dr);</a>
<a name="ln1098">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1099"> </a>
<a name="ln1100">  set_properties(dr);</a>
<a name="ln1101"> </a>
<a name="ln1102">  GtkTreeModel *model = gtk_tree_model_filter_get_model(GTK_TREE_MODEL_FILTER(d-&gt;listfilter));</a>
<a name="ln1103">  if(d-&gt;view_rule != property)</a>
<a name="ln1104">  {</a>
<a name="ln1105">    sqlite3_stmt *stmt;</a>
<a name="ln1106">    GtkTreeIter iter;</a>
<a name="ln1107">    g_object_unref(d-&gt;listfilter);</a>
<a name="ln1108">    g_object_ref(model);</a>
<a name="ln1109">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), NULL);</a>
<a name="ln1110">    gtk_list_store_clear(GTK_LIST_STORE(model));</a>
<a name="ln1111">    gtk_widget_hide(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1112">    gtk_widget_hide(GTK_WIDGET(d-&gt;sw2));</a>
<a name="ln1113">    gchar *where_ext = dt_collection_get_extended_where(darktable.collection, dr-&gt;num);</a>
<a name="ln1114"> </a>
<a name="ln1115">    char query[1024] = { 0 };</a>
<a name="ln1116"> </a>
<a name="ln1117">    switch(property)</a>
<a name="ln1118">    {</a>
<a name="ln1119">      case DT_COLLECTION_PROP_CAMERA:; // camera</a>
<a name="ln1120">        int index = 0;</a>
<a name="ln1121">        gchar *makermodel_query = NULL;</a>
<a name="ln1122">        makermodel_query = dt_util_dstrcat(makermodel_query, &quot;SELECT maker, model, COUNT(*) AS count &quot;</a>
<a name="ln1123">                &quot;FROM main.images WHERE %s GROUP BY maker, model&quot;, where_ext);</a>
<a name="ln1124"> </a>
<a name="ln1125">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1126">                                makermodel_query,</a>
<a name="ln1127">                                -1, &amp;stmt, NULL);</a>
<a name="ln1128"> </a>
<a name="ln1129">        while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1130">        {</a>
<a name="ln1131">          char *exif_maker = (char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1132">          char *exif_model = (char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1133">          const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1134"> </a>
<a name="ln1135">          gchar *value =  dt_collection_get_makermodel(exif_maker, exif_model);</a>
<a name="ln1136"> </a>
<a name="ln1137">          gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1138">          gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, value,</a>
<a name="ln1139">                             DT_LIB_COLLECT_COL_ID, index, DT_LIB_COLLECT_COL_TOOLTIP, value,</a>
<a name="ln1140">                             DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1141">                             DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1142">                             -1);</a>
<a name="ln1143"> </a>
<a name="ln1144">          g_free(value);</a>
<a name="ln1145">          index++;</a>
<a name="ln1146">        }</a>
<a name="ln1147">        g_free(makermodel_query);</a>
<a name="ln1148">        break;</a>
<a name="ln1149"> </a>
<a name="ln1150">      case DT_COLLECTION_PROP_HISTORY: // History, 2 hardcoded alternatives</a>
<a name="ln1151">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1152">                           &quot;altered WHEN 1 THEN '%s' ELSE '%s' END as altered, 1, COUNT(*) AS count &quot;</a>
<a name="ln1153">                           &quot;FROM main.images LEFT JOIN &quot;</a>
<a name="ln1154">                           &quot;(SELECT DISTINCT imgid AS history_id, 1 AS altered FROM main.history) ON id = history_id &quot;</a>
<a name="ln1155">                           &quot;WHERE %s GROUP BY altered ORDER BY altered ASC&quot;,</a>
<a name="ln1156">                   _(&quot;altered&quot;),  _(&quot;not altered&quot;), where_ext);</a>
<a name="ln1157">        break;</a>
<a name="ln1158"> </a>
<a name="ln1159">      case DT_COLLECTION_PROP_GEOTAGGING: // Geotagging, 2 hardcoded alternatives</a>
<a name="ln1160">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1161">                           &quot;WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN '%s' ELSE '%s' END as tagged, 1, &quot;</a>
<a name="ln1162">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1163">                           &quot;FROM main.images &quot;</a>
<a name="ln1164">                           &quot;WHERE %s GROUP BY tagged ORDER BY tagged ASC&quot;,</a>
<a name="ln1165">                       _(&quot;tagged&quot;),  _(&quot;not tagged&quot;), where_ext);</a>
<a name="ln1166">        break;</a>
<a name="ln1167"> </a>
<a name="ln1168">      case DT_COLLECTION_PROP_LOCAL_COPY: // local copy, 2 hardcoded alternatives</a>
<a name="ln1169">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1170">                           &quot;WHEN (flags &amp; %d) THEN '%s' ELSE '%s' END as lcp, 1, &quot;</a>
<a name="ln1171">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1172">                           &quot;FROM main.images &quot;</a>
<a name="ln1173">                           &quot;WHERE %s GROUP BY lcp ORDER BY lcp ASC&quot;,</a>
<a name="ln1174">                   DT_IMAGE_LOCAL_COPY, _(&quot;copied locally&quot;),  _(&quot;not copied locally&quot;), where_ext);</a>
<a name="ln1175">        break;</a>
<a name="ln1176"> </a>
<a name="ln1177">      case DT_COLLECTION_PROP_ASPECT_RATIO: // aspect ratio, 3 hardcoded alternatives</a>
<a name="ln1178">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aspect_ratio,1), 1, COUNT(*) AS count FROM main.images &quot;</a>
<a name="ln1179">                   &quot;WHERE %s GROUP BY ROUND(aspect_ratio,1)&quot;, where_ext);</a>
<a name="ln1180">        break;</a>
<a name="ln1181"> </a>
<a name="ln1182">      case DT_COLLECTION_PROP_COLORLABEL: // colorlabels</a>
<a name="ln1183">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1184">                           &quot;color WHEN 0 THEN '%s' WHEN 1 THEN '%s' WHEN 2 THEN '%s' WHEN 3 THEN '%s' WHEN 4 THEN '%s' &quot;</a>
<a name="ln1185">                           &quot;ELSE '' END, color, COUNT(*) AS count &quot;</a>
<a name="ln1186">                           &quot;FROM main.images JOIN &quot;</a>
<a name="ln1187">                           &quot;(SELECT imgid AS color_labels_id, color FROM main.color_labels) ON id = color_labels_id &quot;</a>
<a name="ln1188">                           &quot;WHERE %s GROUP BY color ORDER BY color DESC&quot;,</a>
<a name="ln1189">                   _(&quot;red&quot;), _(&quot;yellow&quot;), _(&quot;green&quot;), _(&quot;blue&quot;), _(&quot;purple&quot;), where_ext);</a>
<a name="ln1190">        break;</a>
<a name="ln1191"> </a>
<a name="ln1192">      // TODO: Add empty string for metadata?</a>
<a name="ln1193">      // TODO: Autogenerate this code?</a>
<a name="ln1194">      case DT_COLLECTION_PROP_TITLE: // title</a>
<a name="ln1195">        snprintf(query, sizeof(query),</a>
<a name="ln1196">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1197">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1198">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1199">                 DT_METADATA_XMP_DC_TITLE, where_ext);</a>
<a name="ln1200">        break;</a>
<a name="ln1201">      case DT_COLLECTION_PROP_DESCRIPTION: // description</a>
<a name="ln1202">        snprintf(query, sizeof(query),</a>
<a name="ln1203">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1204">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1205">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1206">                 DT_METADATA_XMP_DC_DESCRIPTION, where_ext);</a>
<a name="ln1207">        break;</a>
<a name="ln1208">      case DT_COLLECTION_PROP_CREATOR: // creator</a>
<a name="ln1209">        snprintf(query, sizeof(query),</a>
<a name="ln1210">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1211">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1212">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1213">                 DT_METADATA_XMP_DC_CREATOR, where_ext);</a>
<a name="ln1214">        break;</a>
<a name="ln1215">      case DT_COLLECTION_PROP_PUBLISHER: // publisher</a>
<a name="ln1216">        snprintf(query, sizeof(query),</a>
<a name="ln1217">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1218">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1219">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1220">                 DT_METADATA_XMP_DC_PUBLISHER, where_ext);</a>
<a name="ln1221">        break;</a>
<a name="ln1222">      case DT_COLLECTION_PROP_RIGHTS: // rights</a>
<a name="ln1223">        snprintf(query, sizeof(query),</a>
<a name="ln1224">                 &quot;SELECT value, 1, COUNT(*) AS count FROM main.images JOIN &quot;</a>
<a name="ln1225">                         &quot;(SELECT id AS meta_data_id, value FROM main.meta_data WHERE key = %d) ON id = meta_data_id &quot;</a>
<a name="ln1226">                         &quot;WHERE %s GROUP BY value ORDER BY value&quot;,</a>
<a name="ln1227">                 DT_METADATA_XMP_DC_RIGHTS, where_ext);</a>
<a name="ln1228">        break;</a>
<a name="ln1229">      case DT_COLLECTION_PROP_LENS: // lens</a>
<a name="ln1230">        g_snprintf(query, sizeof(query), &quot;SELECT lens, 1, COUNT(*) AS count &quot;</a>
<a name="ln1231">                &quot;FROM main.images WHERE %s GROUP BY lens ORDER BY lens&quot;, where_ext);</a>
<a name="ln1232">        break;</a>
<a name="ln1233"> </a>
<a name="ln1234">      case DT_COLLECTION_PROP_FOCAL_LENGTH: // focal length</a>
<a name="ln1235">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(focal_length AS INTEGER) AS focal_length, 1, COUNT(*) AS count &quot;</a>
<a name="ln1236">                         &quot;FROM main.images WHERE %s GROUP BY focal_length ORDER BY focal_length&quot;,</a>
<a name="ln1237">                   where_ext);</a>
<a name="ln1238">        break;</a>
<a name="ln1239"> </a>
<a name="ln1240">      case DT_COLLECTION_PROP_ISO: // iso</a>
<a name="ln1241">        g_snprintf(query, sizeof(query), &quot;SELECT CAST(iso AS INTEGER) AS iso, 1, COUNT(*) AS count &quot;</a>
<a name="ln1242">                           &quot;FROM main.images WHERE %s GROUP BY iso ORDER BY iso&quot;,</a>
<a name="ln1243">                   where_ext);</a>
<a name="ln1244">        break;</a>
<a name="ln1245"> </a>
<a name="ln1246">      case DT_COLLECTION_PROP_APERTURE: // aperture</a>
<a name="ln1247">        g_snprintf(query, sizeof(query), &quot;SELECT ROUND(aperture,1) AS aperture, 1, COUNT(*) AS count &quot;</a>
<a name="ln1248">                           &quot;FROM main.images WHERE %s GROUP BY aperture ORDER BY aperture&quot;,</a>
<a name="ln1249">                   where_ext);</a>
<a name="ln1250">        break;</a>
<a name="ln1251"> </a>
<a name="ln1252">      case DT_COLLECTION_PROP_EXPOSURE: // exposure</a>
<a name="ln1253">        g_snprintf(query, sizeof(query), &quot;SELECT CASE WHEN (exposure &lt; 0.4) &quot;</a>
<a name="ln1254">                              &quot;THEN '1/' || CAST(1/exposure + 0.9 AS INTEGER) &quot;</a>
<a name="ln1255">                           &quot;ELSE ROUND(exposure,2) || '\&quot;' END as _exposure, 1, COUNT(*) AS count &quot;</a>
<a name="ln1256">                &quot;FROM main.images WHERE %s GROUP BY _exposure ORDER BY exposure&quot;,</a>
<a name="ln1257">                  where_ext);</a>
<a name="ln1258">        break;</a>
<a name="ln1259"> </a>
<a name="ln1260">      case DT_COLLECTION_PROP_FILENAME: // filename</a>
<a name="ln1261">        g_snprintf(query, sizeof(query), &quot;SELECT filename, 1, COUNT(*) AS count &quot;</a>
<a name="ln1262">                &quot;FROM main.images WHERE %s GROUP BY filename ORDER BY filename&quot;, where_ext);</a>
<a name="ln1263">        break;</a>
<a name="ln1264"> </a>
<a name="ln1265">      default: // filmroll</a>
<a name="ln1266">        g_snprintf(query, sizeof(query), &quot;SELECT folder, film_rolls_id, COUNT(*) AS count &quot;</a>
<a name="ln1267">                &quot;FROM main.images JOIN &quot;</a>
<a name="ln1268">                &quot;(SELECT id AS film_rolls_id, folder FROM main.film_rolls) ON film_id = film_rolls_id &quot;</a>
<a name="ln1269">                &quot;WHERE %s GROUP BY folder ORDER BY folder DESC&quot;, where_ext);</a>
<a name="ln1270">        break;</a>
<a name="ln1271"> </a>
<a name="ln1272">      case DT_COLLECTION_PROP_GROUPING: // Grouping, 2 hardcoded alternatives</a>
<a name="ln1273">        g_snprintf(query, sizeof(query), &quot;SELECT CASE &quot;</a>
<a name="ln1274">                           &quot;WHEN id = group_id THEN '%s' ELSE '%s' END as group_leader, 1, &quot;</a>
<a name="ln1275">                           &quot;COUNT(*) AS count &quot;</a>
<a name="ln1276">                           &quot;FROM main.images &quot;</a>
<a name="ln1277">                           &quot;WHERE %s GROUP BY group_leader ORDER BY group_leader ASC&quot;,</a>
<a name="ln1278">                   _(&quot;group leaders&quot;),  _(&quot;group followers&quot;), where_ext);</a>
<a name="ln1279">        break;</a>
<a name="ln1280">    }</a>
<a name="ln1281"> </a>
<a name="ln1282">    g_free(where_ext);</a>
<a name="ln1283"> </a>
<a name="ln1284">    if(strlen(query) &gt; 0)</a>
<a name="ln1285">    {</a>
<a name="ln1286">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), query, -1, &amp;stmt, NULL);</a>
<a name="ln1287">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1288">      {</a>
<a name="ln1289">        const char *folder = (const char *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1290">        if(folder == NULL) continue; // safeguard against degenerated db entries</a>
<a name="ln1291"> </a>
<a name="ln1292">        gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln1293">        if(property == DT_COLLECTION_PROP_FILMROLL)</a>
<a name="ln1294">        {</a>
<a name="ln1295">          folder = dt_image_film_roll_name(folder);</a>
<a name="ln1296">        }</a>
<a name="ln1297">        gchar *value = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln1298">        const int count = sqlite3_column_int(stmt, 2);</a>
<a name="ln1299"> </a>
<a name="ln1300">        // replace invalid utf8 characters if any</a>
<a name="ln1301">        gchar *text = g_strdup(value);</a>
<a name="ln1302">        gchar *ptr = text;</a>
<a name="ln1303">        while(!g_utf8_validate(ptr, -1, (const gchar **)&amp;ptr)) ptr[0] = '?';</a>
<a name="ln1304"> </a>
<a name="ln1305">        gchar *escaped_text = g_markup_escape_text(text, -1);</a>
<a name="ln1306"> </a>
<a name="ln1307">        gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_COLLECT_COL_TEXT, folder,</a>
<a name="ln1308">                           DT_LIB_COLLECT_COL_ID, sqlite3_column_int(stmt, 1), DT_LIB_COLLECT_COL_TOOLTIP,</a>
<a name="ln1309">                           escaped_text, DT_LIB_COLLECT_COL_PATH, value, DT_LIB_COLLECT_COL_VISIBLE, TRUE,</a>
<a name="ln1310">                           DT_LIB_COLLECT_COL_COUNT, count,</a>
<a name="ln1311">                           -1);</a>
<a name="ln1312">        g_free(text);</a>
<a name="ln1313">        g_free(escaped_text);</a>
<a name="ln1314">      }</a>
<a name="ln1315">      sqlite3_finalize(stmt);</a>
<a name="ln1316">    }</a>
<a name="ln1317"> </a>
<a name="ln1318">    gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;view), DT_LIB_COLLECT_COL_TOOLTIP);</a>
<a name="ln1319"> </a>
<a name="ln1320">    d-&gt;listfilter = _create_filtered_model(model, dr);</a>
<a name="ln1321"> </a>
<a name="ln1322">    gtk_tree_view_set_model(GTK_TREE_VIEW(d-&gt;view), d-&gt;listfilter);</a>
<a name="ln1323">    gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), FALSE);</a>
<a name="ln1324">    gtk_widget_show_all(GTK_WIDGET(d-&gt;scrolledwindow));</a>
<a name="ln1325"> </a>
<a name="ln1326">    g_object_unref(model);</a>
<a name="ln1327"> </a>
<a name="ln1328">    d-&gt;view_rule = property;</a>
<a name="ln1329">  }</a>
<a name="ln1330"> </a>
<a name="ln1331">  // if needed, we restrict the tree to matching entries</a>
<a name="ln1332">  if (dr-&gt;typing</a>
<a name="ln1333">     &amp;&amp;(property == DT_COLLECTION_PROP_CAMERA || property == DT_COLLECTION_PROP_CREATOR</a>
<a name="ln1334">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_DESCRIPTION</a>
<a name="ln1335">     || property == DT_COLLECTION_PROP_FILENAME || property == DT_COLLECTION_PROP_FILMROLL</a>
<a name="ln1336">     || property == DT_COLLECTION_PROP_LENS || property == DT_COLLECTION_PROP_PUBLISHER</a>
<a name="ln1337">     || property == DT_COLLECTION_PROP_RIGHTS || property == DT_COLLECTION_PROP_TIME</a>
<a name="ln1338">     || property == DT_COLLECTION_PROP_TITLE || property == DT_COLLECTION_PROP_APERTURE</a>
<a name="ln1339">     || property == DT_COLLECTION_PROP_FOCAL_LENGTH || property == DT_COLLECTION_PROP_ISO))</a>
<a name="ln1340">    gtk_tree_model_foreach(model, (GtkTreeModelForeachFunc)list_match_string, dr);</a>
<a name="ln1341">  // we update list selection</a>
<a name="ln1342">  gtk_tree_selection_unselect_all(gtk_tree_view_get_selection(d-&gt;view));</a>
<a name="ln1343">  gtk_tree_model_foreach(d-&gt;listfilter, (GtkTreeModelForeachFunc)list_select, dr);</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">static void update_view(dt_lib_collect_rule_t *dr)</a>
<a name="ln1347">{</a>
<a name="ln1348">  int property = gtk_combo_box_get_active(dr-&gt;combo);</a>
<a name="ln1349"> </a>
<a name="ln1350">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1351">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1352">    tree_view(dr);</a>
<a name="ln1353">  else</a>
<a name="ln1354">    list_view(dr);</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357"> </a>
<a name="ln1358">static void _lib_collect_gui_update(dt_lib_module_t *self)</a>
<a name="ln1359">{</a>
<a name="ln1360">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1361"> </a>
<a name="ln1362">  // we check if something as change since last call</a>
<a name="ln1363">  if(d-&gt;view_rule != -1) return;</a>
<a name="ln1364"> </a>
<a name="ln1365">  const int old = darktable.gui-&gt;reset;</a>
<a name="ln1366">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1367">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;) - 1;</a>
<a name="ln1368">  const int active = CLAMP(_a, 0, (MAX_RULES - 1));</a>
<a name="ln1369">  d-&gt;nb_rules = active + 1;</a>
<a name="ln1370">  char confname[200] = { 0 };</a>
<a name="ln1371"> </a>
<a name="ln1372">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;scrolledwindow), TRUE);</a>
<a name="ln1373">  gtk_widget_set_no_show_all(GTK_WIDGET(d-&gt;sw2), TRUE);</a>
<a name="ln1374"> </a>
<a name="ln1375">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln1376">  {</a>
<a name="ln1377">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1378">    gtk_widget_set_visible(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1379">  }</a>
<a name="ln1380">  for(int i = 0; i &lt;= active; i++)</a>
<a name="ln1381">  {</a>
<a name="ln1382">    gtk_widget_set_no_show_all(d-&gt;rule[i].hbox, FALSE);</a>
<a name="ln1383">    gtk_widget_set_visible(d-&gt;rule[i].hbox, TRUE);</a>
<a name="ln1384">    gtk_widget_show_all(d-&gt;rule[i].hbox);</a>
<a name="ln1385">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1386">    gtk_combo_box_set_active(GTK_COMBO_BOX(d-&gt;rule[i].combo), dt_conf_get_int(confname));</a>
<a name="ln1387">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1388">    gchar *text = dt_conf_get_string(confname);</a>
<a name="ln1389">    if(text)</a>
<a name="ln1390">    {</a>
<a name="ln1391">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1392">      g_signal_handlers_block_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1393">      gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[i].text), text);</a>
<a name="ln1394">      gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[i].text), -1);</a>
<a name="ln1395">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1396">      g_signal_handlers_unblock_matched(d-&gt;rule[i].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1397">      g_free(text);</a>
<a name="ln1398">      d-&gt;rule[i].typing = FALSE;</a>
<a name="ln1399">    }</a>
<a name="ln1400"> </a>
<a name="ln1401">    GtkDarktableButton *button = DTGTK_BUTTON(d-&gt;rule[i].button);</a>
<a name="ln1402">    if(i == MAX_RULES - 1)</a>
<a name="ln1403">    {</a>
<a name="ln1404">      // only clear</a>
<a name="ln1405">      button-&gt;icon = dtgtk_cairo_paint_cancel;</a>
<a name="ln1406">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1407">    }</a>
<a name="ln1408">    else if(i == active)</a>
<a name="ln1409">    {</a>
<a name="ln1410">      button-&gt;icon = dtgtk_cairo_paint_dropdown;</a>
<a name="ln1411">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule or add new rules&quot;));</a>
<a name="ln1412">    }</a>
<a name="ln1413">    else</a>
<a name="ln1414">    {</a>
<a name="ln1415">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1416">      const int mode = dt_conf_get_int(confname);</a>
<a name="ln1417">      if(mode == DT_LIB_COLLECT_MODE_AND) button-&gt;icon = dtgtk_cairo_paint_and;</a>
<a name="ln1418">      if(mode == DT_LIB_COLLECT_MODE_OR) button-&gt;icon = dtgtk_cairo_paint_or;</a>
<a name="ln1419">      if(mode == DT_LIB_COLLECT_MODE_AND_NOT) button-&gt;icon = dtgtk_cairo_paint_andnot;</a>
<a name="ln1420">      gtk_widget_set_tooltip_text(GTK_WIDGET(button), _(&quot;clear this rule&quot;));</a>
<a name="ln1421">    }</a>
<a name="ln1422">  }</a>
<a name="ln1423"> </a>
<a name="ln1424">  // update list of proposals</a>
<a name="ln1425">  update_view(d-&gt;rule + d-&gt;active_rule);</a>
<a name="ln1426">  darktable.gui-&gt;reset = old;</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln1430">{</a>
<a name="ln1431">  dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, 1);</a>
<a name="ln1432">  dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln1433">  dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, 0);</a>
<a name="ln1434">  dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1435">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1436">  d-&gt;active_rule = 0;</a>
<a name="ln1437">  d-&gt;view_rule = -1;</a>
<a name="ln1438">  dt_collection_set_query_flags(darktable.collection, COLLECTION_QUERY_FULL);</a>
<a name="ln1439">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">static void combo_changed(GtkComboBox *combo, dt_lib_collect_rule_t *d)</a>
<a name="ln1443">{</a>
<a name="ln1444">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln1445">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1446">  g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1447">  gtk_entry_set_text(GTK_ENTRY(d-&gt;text), &quot;&quot;);</a>
<a name="ln1448">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1449">  g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1450">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1451">  c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1452"> </a>
<a name="ln1453">  int property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1454"> </a>
<a name="ln1455">  if(property == DT_COLLECTION_PROP_FOLDERS || property == DT_COLLECTION_PROP_TAG</a>
<a name="ln1456">     || property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1457">  {</a>
<a name="ln1458">    d-&gt;typing = FALSE;</a>
<a name="ln1459">  }</a>
<a name="ln1460"> </a>
<a name="ln1461">  if(property == DT_COLLECTION_PROP_APERTURE || property == DT_COLLECTION_PROP_FOCAL_LENGTH</a>
<a name="ln1462">     || property == DT_COLLECTION_PROP_ISO || property == DT_COLLECTION_PROP_ASPECT_RATIO</a>
<a name="ln1463">     || property == DT_COLLECTION_PROP_EXPOSURE)</a>
<a name="ln1464">  {</a>
<a name="ln1465">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators&quot;));</a>
<a name="ln1466">  }</a>
<a name="ln1467">  else if(property == DT_COLLECTION_PROP_DAY || property == DT_COLLECTION_PROP_TIME)</a>
<a name="ln1468">  {</a>
<a name="ln1469">    gtk_widget_set_tooltip_text(d-&gt;text,</a>
<a name="ln1470">                                _(&quot;type your query, use &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;, =, [;] as operators, type dates in &quot;</a>
<a name="ln1471">                                  &quot;the form : YYYY:MM:DD HH:MM:SS (only the year is mandatory)&quot;));</a>
<a name="ln1472">  }</a>
<a name="ln1473">  else</a>
<a name="ln1474">  {</a>
<a name="ln1475">    /* xgettext:no-c-format */</a>
<a name="ln1476">    gtk_widget_set_tooltip_text(d-&gt;text, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln1477">  }</a>
<a name="ln1478"> </a>
<a name="ln1479">  set_properties(d);</a>
<a name="ln1480">  c-&gt;view_rule = -1;</a>
<a name="ln1481">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">static void row_activated_with_event(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, GdkEventButton *event, dt_lib_collect_t *d)</a>
<a name="ln1485">{</a>
<a name="ln1486">  GtkTreeIter iter;</a>
<a name="ln1487">  GtkTreeModel *model = NULL;</a>
<a name="ln1488"> </a>
<a name="ln1489">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln1490">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln1491">  gchar *text;</a>
<a name="ln1492"> </a>
<a name="ln1493">  const int active = d-&gt;active_rule;</a>
<a name="ln1494">  d-&gt;rule[active].typing = FALSE;</a>
<a name="ln1495"> </a>
<a name="ln1496">  const int item = gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[active].combo));</a>
<a name="ln1497">  gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1498"> </a>
<a name="ln1499">  if(text &amp;&amp; strlen(text)&gt;0 &amp;&amp; item == DT_COLLECTION_PROP_TAG &amp;&amp; gtk_tree_model_iter_has_child (model, &amp;iter))</a>
<a name="ln1500">  {</a>
<a name="ln1501">    /* if a tag has children, ctrl-clicking on a parent node should display all images under this hierarchy. */</a>
<a name="ln1502">    if(event-&gt;state &amp; GDK_CONTROL_MASK)</a>
<a name="ln1503">    {</a>
<a name="ln1504">      gchar *n_text = g_strconcat(text, &quot;|%&quot;, NULL);</a>
<a name="ln1505">      g_free(text);</a>
<a name="ln1506">      text = n_text;</a>
<a name="ln1507">    }</a>
<a name="ln1508">    /* if a tag has children, shift-clicking on a parent node should display all images in and under this hierarchy. */</a>
<a name="ln1509">    else if(event-&gt;state &amp; GDK_SHIFT_MASK)</a>
<a name="ln1510">    {</a>
<a name="ln1511">      gchar *n_text = g_strconcat(text, &quot;%&quot;, NULL);</a>
<a name="ln1512">      g_free(text);</a>
<a name="ln1513">      text = n_text;</a>
<a name="ln1514">    }</a>
<a name="ln1515">  }</a>
<a name="ln1516"> </a>
<a name="ln1517">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1518">  g_signal_handlers_block_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1519">  gtk_entry_set_text(GTK_ENTRY(d-&gt;rule[active].text), text);</a>
<a name="ln1520">  gtk_editable_set_position(GTK_EDITABLE(d-&gt;rule[active].text), -1);</a>
<a name="ln1521">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text,</a>
<a name="ln1522">                                    NULL);</a>
<a name="ln1523">  g_signal_handlers_unblock_matched(d-&gt;rule[active].text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed,</a>
<a name="ln1524">                                    NULL);</a>
<a name="ln1525">  g_free(text);</a>
<a name="ln1526"> </a>
<a name="ln1527">  if(item == DT_COLLECTION_PROP_TAG || item == DT_COLLECTION_PROP_FOLDERS</a>
<a name="ln1528">     || item == DT_COLLECTION_PROP_DAY || item == DT_COLLECTION_PROP_TIME</a>
<a name="ln1529">     || item == DT_COLLECTION_PROP_COLORLABEL || item == DT_COLLECTION_PROP_GEOTAGGING</a>
<a name="ln1530">     || item == DT_COLLECTION_PROP_HISTORY ||  item == DT_COLLECTION_PROP_LOCAL_COPY</a>
<a name="ln1531">     || item == DT_COLLECTION_PROP_GROUPING)</a>
<a name="ln1532">    set_properties(d-&gt;rule + active); // we just have to set the selection</a>
<a name="ln1533">  else</a>
<a name="ln1534">    update_view(d-&gt;rule + active); // we have to update visible items too</a>
<a name="ln1535"> </a>
<a name="ln1536">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1537">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1538">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1539">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1540">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1541">  dt_control_queue_redraw_center();</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">static void entry_activated(GtkWidget *entry, dt_lib_collect_rule_t *d)</a>
<a name="ln1545">{</a>
<a name="ln1546">  GtkTreeView *view;</a>
<a name="ln1547">  GtkTreeModel *model;</a>
<a name="ln1548">  int property, rows;</a>
<a name="ln1549"> </a>
<a name="ln1550">  update_view(d);</a>
<a name="ln1551">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1552"> </a>
<a name="ln1553">  property = gtk_combo_box_get_active(d-&gt;combo);</a>
<a name="ln1554"> </a>
<a name="ln1555">  if(property != DT_COLLECTION_PROP_FOLDERS &amp;&amp; property != DT_COLLECTION_PROP_TAG</a>
<a name="ln1556">     &amp;&amp; property != DT_COLLECTION_PROP_DAY &amp;&amp; property != DT_COLLECTION_PROP_TIME)</a>
<a name="ln1557">  {</a>
<a name="ln1558">    view = c-&gt;view;</a>
<a name="ln1559">    model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln1560"> </a>
<a name="ln1561">    rows = gtk_tree_model_iter_n_children(model, NULL);</a>
<a name="ln1562"> </a>
<a name="ln1563">    if(rows == 1)</a>
<a name="ln1564">    {</a>
<a name="ln1565">      GtkTreeIter iter;</a>
<a name="ln1566">      if(gtk_tree_model_get_iter_first(model, &amp;iter))</a>
<a name="ln1567">      {</a>
<a name="ln1568">        gchar *text;</a>
<a name="ln1569">        gtk_tree_model_get(model, &amp;iter, DT_LIB_COLLECT_COL_PATH, &amp;text, -1);</a>
<a name="ln1570"> </a>
<a name="ln1571">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1572">        g_signal_handlers_block_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1573">        gtk_entry_set_text(GTK_ENTRY(d-&gt;text), text);</a>
<a name="ln1574">        gtk_editable_set_position(GTK_EDITABLE(d-&gt;text), -1);</a>
<a name="ln1575">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_insert_text, NULL);</a>
<a name="ln1576">        g_signal_handlers_unblock_matched(d-&gt;text, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, entry_changed, NULL);</a>
<a name="ln1577">        g_free(text);</a>
<a name="ln1578">        d-&gt;typing = FALSE;</a>
<a name="ln1579">        update_view(d);</a>
<a name="ln1580">      }</a>
<a name="ln1581">    }</a>
<a name="ln1582">  }</a>
<a name="ln1583">  dt_control_signal_block_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1584">                                  darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1585">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1586">  dt_control_signal_unblock_by_func(darktable.signals, G_CALLBACK(collection_updated),</a>
<a name="ln1587">                                    darktable.view_manager-&gt;proxy.module_collect.module);</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">static void entry_insert_text(GtkWidget *entry, gchar *new_text, gint new_length, gpointer *position,</a>
<a name="ln1591">                          dt_lib_collect_rule_t *d)</a>
<a name="ln1592">{</a>
<a name="ln1593">  d-&gt;typing = TRUE;</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">static void entry_changed(GtkEntry *entry, dt_lib_collect_rule_t *dr)</a>
<a name="ln1597">{</a>
<a name="ln1598">  update_view(dr);</a>
<a name="ln1599">}</a>
<a name="ln1600"> </a>
<a name="ln1601">int position()</a>
<a name="ln1602">{</a>
<a name="ln1603">  return 400;</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">static gboolean entry_focus_in_callback(GtkWidget *w, GdkEventFocus *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1607">{</a>
<a name="ln1608">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1609">  if(c-&gt;active_rule != d-&gt;num)</a>
<a name="ln1610">  {</a>
<a name="ln1611">    c-&gt;active_rule = d-&gt;num;</a>
<a name="ln1612">    update_view(c-&gt;rule + c-&gt;active_rule);</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  return FALSE;</a>
<a name="ln1616">}</a>
<a name="ln1617"> </a>
<a name="ln1618">static void menuitem_mode(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1619">{</a>
<a name="ln1620">  // add next row with and operator</a>
<a name="ln1621">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1622">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1623">  if(active &lt; MAX_RULES)</a>
<a name="ln1624">  {</a>
<a name="ln1625">    char confname[200] = { 0 };</a>
<a name="ln1626">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, active);</a>
<a name="ln1627">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1628">    dt_conf_set_int(confname, mode);</a>
<a name="ln1629">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, active);</a>
<a name="ln1630">    dt_conf_set_string(confname, &quot;&quot;);</a>
<a name="ln1631">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active + 1);</a>
<a name="ln1632">    dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1633">    c-&gt;active_rule = active;</a>
<a name="ln1634">    c-&gt;view_rule = -1;</a>
<a name="ln1635">  }</a>
<a name="ln1636">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639">static void menuitem_mode_change(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1640">{</a>
<a name="ln1641">  // add next row with and operator</a>
<a name="ln1642">  const int num = d-&gt;num + 1;</a>
<a name="ln1643">  if(num &lt; MAX_RULES &amp;&amp; num &gt; 0)</a>
<a name="ln1644">  {</a>
<a name="ln1645">    char confname[200] = { 0 };</a>
<a name="ln1646">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, num);</a>
<a name="ln1647">    const dt_lib_collect_mode_t mode = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(menuitem), &quot;menuitem_mode&quot;));</a>
<a name="ln1648">    dt_conf_set_int(confname, mode);</a>
<a name="ln1649">  }</a>
<a name="ln1650">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1651">  c-&gt;view_rule = -1;</a>
<a name="ln1652">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1653">}</a>
<a name="ln1654"> </a>
<a name="ln1655">static void collection_updated(gpointer instance, gpointer self)</a>
<a name="ln1656">{</a>
<a name="ln1657">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1658">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1659"> </a>
<a name="ln1660">  // update tree</a>
<a name="ln1661">  d-&gt;view_rule = -1;</a>
<a name="ln1662">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1663">  _lib_collect_gui_update(self);</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666"> </a>
<a name="ln1667">static void filmrolls_updated(gpointer instance, gpointer self)</a>
<a name="ln1668">{</a>
<a name="ln1669">  // TODO: We should update the count of images here</a>
<a name="ln1670">  _lib_collect_gui_update(self);</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673">static void filmrolls_imported(gpointer instance, int film_id, gpointer self)</a>
<a name="ln1674">{</a>
<a name="ln1675">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1676">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1677"> </a>
<a name="ln1678">  // update tree</a>
<a name="ln1679">  d-&gt;view_rule = -1;</a>
<a name="ln1680">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1681">  _lib_collect_gui_update(self);</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">static void filmrolls_removed(gpointer instance, gpointer self)</a>
<a name="ln1685">{</a>
<a name="ln1686">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1687">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1688"> </a>
<a name="ln1689">  // update tree</a>
<a name="ln1690">  if (d-&gt;view_rule != DT_COLLECTION_PROP_FOLDERS)</a>
<a name="ln1691">  {</a>
<a name="ln1692">    d-&gt;view_rule = -1;</a>
<a name="ln1693">  }</a>
<a name="ln1694">  d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1695">  _lib_collect_gui_update(self);</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">static void tag_changed(gpointer instance, gpointer self)</a>
<a name="ln1699">{</a>
<a name="ln1700">  dt_lib_module_t *dm = (dt_lib_module_t *)self;</a>
<a name="ln1701">  dt_lib_collect_t *d = (dt_lib_collect_t *)dm-&gt;data;</a>
<a name="ln1702"> </a>
<a name="ln1703">  // update tree</a>
<a name="ln1704">  if(gtk_combo_box_get_active(GTK_COMBO_BOX(d-&gt;rule[d-&gt;active_rule].combo)) == DT_COLLECTION_PROP_TAG)</a>
<a name="ln1705">  {</a>
<a name="ln1706">    d-&gt;view_rule = -1;</a>
<a name="ln1707">    d-&gt;rule[d-&gt;active_rule].typing = FALSE;</a>
<a name="ln1708">    _lib_collect_gui_update(self);</a>
<a name="ln1709">  }</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">static void menuitem_clear(GtkMenuItem *menuitem, dt_lib_collect_rule_t *d)</a>
<a name="ln1713">{</a>
<a name="ln1714">  // remove this row, or if 1st, clear text entry box</a>
<a name="ln1715">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1716">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1717">  dt_lib_collect_t *c = get_collect(d);</a>
<a name="ln1718">  if(active &gt; 1)</a>
<a name="ln1719">  {</a>
<a name="ln1720">    dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, active - 1);</a>
<a name="ln1721">    if(c-&gt;active_rule &gt;= active - 1) c-&gt;active_rule = active - 2;</a>
<a name="ln1722">  }</a>
<a name="ln1723">  else</a>
<a name="ln1724">  {</a>
<a name="ln1725">    dt_conf_set_int(&quot;plugins/lighttable/collect/mode0&quot;, DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln1726">    dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, 0);</a>
<a name="ln1727">    dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, &quot;&quot;);</a>
<a name="ln1728">    d-&gt;typing = FALSE;</a>
<a name="ln1729">  }</a>
<a name="ln1730">  // move up all still active rules by one.</a>
<a name="ln1731">  for(int i = d-&gt;num; i &lt; MAX_RULES - 1; i++)</a>
<a name="ln1732">  {</a>
<a name="ln1733">    char confname[200] = { 0 };</a>
<a name="ln1734">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i + 1);</a>
<a name="ln1735">    const int mode = dt_conf_get_int(confname);</a>
<a name="ln1736">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i + 1);</a>
<a name="ln1737">    const int item = dt_conf_get_int(confname);</a>
<a name="ln1738">    snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i + 1);</a>
<a name="ln1739">    gchar *string = dt_conf_get_string(confname);</a>
<a name="ln1740">    if(string)</a>
<a name="ln1741">    {</a>
<a name="ln1742">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/mode%1d&quot;, i);</a>
<a name="ln1743">      dt_conf_set_int(confname, mode);</a>
<a name="ln1744">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/item%1d&quot;, i);</a>
<a name="ln1745">      dt_conf_set_int(confname, item);</a>
<a name="ln1746">      snprintf(confname, sizeof(confname), &quot;plugins/lighttable/collect/string%1d&quot;, i);</a>
<a name="ln1747">      dt_conf_set_string(confname, string);</a>
<a name="ln1748">      g_free(string);</a>
<a name="ln1749">    }</a>
<a name="ln1750">  }</a>
<a name="ln1751"> </a>
<a name="ln1752">  c-&gt;view_rule = -1;</a>
<a name="ln1753">  dt_collection_update_query(darktable.collection);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">static gboolean popup_button_callback(GtkWidget *widget, GdkEventButton *event, dt_lib_collect_rule_t *d)</a>
<a name="ln1757">{</a>
<a name="ln1758">  if(event-&gt;button != 1) return FALSE;</a>
<a name="ln1759"> </a>
<a name="ln1760">  GtkWidget *menu = gtk_menu_new();</a>
<a name="ln1761">  GtkWidget *mi;</a>
<a name="ln1762">  const int _a = dt_conf_get_int(&quot;plugins/lighttable/collect/num_rules&quot;);</a>
<a name="ln1763">  const int active = CLAMP(_a, 1, MAX_RULES);</a>
<a name="ln1764"> </a>
<a name="ln1765">  mi = gtk_menu_item_new_with_label(_(&quot;clear this rule&quot;));</a>
<a name="ln1766">  gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1767">  g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_clear), d);</a>
<a name="ln1768"> </a>
<a name="ln1769">  if(d-&gt;num == active - 1)</a>
<a name="ln1770">  {</a>
<a name="ln1771">    mi = gtk_menu_item_new_with_label(_(&quot;narrow down search&quot;));</a>
<a name="ln1772">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1773">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1774">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1775"> </a>
<a name="ln1776">    mi = gtk_menu_item_new_with_label(_(&quot;add more images&quot;));</a>
<a name="ln1777">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1778">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1779">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1780"> </a>
<a name="ln1781">    mi = gtk_menu_item_new_with_label(_(&quot;exclude images&quot;));</a>
<a name="ln1782">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1783">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1784">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode), d);</a>
<a name="ln1785">  }</a>
<a name="ln1786">  else if(d-&gt;num &lt; active - 1)</a>
<a name="ln1787">  {</a>
<a name="ln1788">    mi = gtk_menu_item_new_with_label(_(&quot;change to: and&quot;));</a>
<a name="ln1789">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND));</a>
<a name="ln1790">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1791">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1792"> </a>
<a name="ln1793">    mi = gtk_menu_item_new_with_label(_(&quot;change to: or&quot;));</a>
<a name="ln1794">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_OR));</a>
<a name="ln1795">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1796">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1797"> </a>
<a name="ln1798">    mi = gtk_menu_item_new_with_label(_(&quot;change to: except&quot;));</a>
<a name="ln1799">    g_object_set_data(G_OBJECT(mi), &quot;menuitem_mode&quot;, GINT_TO_POINTER(DT_LIB_COLLECT_MODE_AND_NOT));</a>
<a name="ln1800">    gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1801">    g_signal_connect(G_OBJECT(mi), &quot;activate&quot;, G_CALLBACK(menuitem_mode_change), d);</a>
<a name="ln1802">  }</a>
<a name="ln1803"> </a>
<a name="ln1804">  gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1805"> </a>
<a name="ln1806">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1807">  gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1808">#else</a>
<a name="ln1809">  gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event-&gt;button, event-&gt;time);</a>
<a name="ln1810">#endif</a>
<a name="ln1811"> </a>
<a name="ln1812">  return TRUE;</a>
<a name="ln1813">}</a>
<a name="ln1814"> </a>
<a name="ln1815">void gui_init(dt_lib_module_t *self)</a>
<a name="ln1816">{</a>
<a name="ln1817">  dt_lib_collect_t *d = (dt_lib_collect_t *)calloc(1, sizeof(dt_lib_collect_t));</a>
<a name="ln1818"> </a>
<a name="ln1819">  self-&gt;data = (void *)d;</a>
<a name="ln1820">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1821">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln1822"> </a>
<a name="ln1823">  d-&gt;active_rule = 0;</a>
<a name="ln1824">  d-&gt;nb_rules = 0;</a>
<a name="ln1825">  d-&gt;params = (dt_lib_collect_params_t *)malloc(sizeof(dt_lib_collect_params_t));</a>
<a name="ln1826"> </a>
<a name="ln1827">  GtkBox *box;</a>
<a name="ln1828">  GtkWidget *w;</a>
<a name="ln1829"> </a>
<a name="ln1830">  for(int i = 0; i &lt; MAX_RULES; i++)</a>
<a name="ln1831">  {</a>
<a name="ln1832">    d-&gt;rule[i].num = i;</a>
<a name="ln1833">    d-&gt;rule[i].typing = FALSE;</a>
<a name="ln1834">    box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln1835">    d-&gt;rule[i].hbox = GTK_WIDGET(box);</a>
<a name="ln1836">    gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln1837">    w = gtk_combo_box_text_new();</a>
<a name="ln1838">    d-&gt;rule[i].combo = GTK_COMBO_BOX(w);</a>
<a name="ln1839">    for(int k = 0; k &lt; dt_lib_collect_string_cnt; k++)</a>
<a name="ln1840">      gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(w), _(dt_lib_collect_string[k]));</a>
<a name="ln1841">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(combo_changed), d-&gt;rule + i);</a>
<a name="ln1842">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln1843"> </a>
<a name="ln1844">    w = gtk_entry_new();</a>
<a name="ln1845">    d-&gt;rule[i].text = w;</a>
<a name="ln1846">    dt_gui_key_accel_block_on_focus_connect(d-&gt;rule[i].text);</a>
<a name="ln1847">    gtk_widget_add_events(w, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln1848">    g_signal_connect(G_OBJECT(w), &quot;focus-in-event&quot;, G_CALLBACK(entry_focus_in_callback), d-&gt;rule + i);</a>
<a name="ln1849"> </a>
<a name="ln1850">    /* xgettext:no-c-format */</a>
<a name="ln1851">    gtk_widget_set_tooltip_text(w, _(&quot;type your query, use `%' as wildcard&quot;));</a>
<a name="ln1852">    gtk_widget_add_events(w, GDK_KEY_PRESS_MASK);</a>
<a name="ln1853">    g_signal_connect(G_OBJECT(w), &quot;insert-text&quot;, G_CALLBACK(entry_insert_text), d-&gt;rule + i);</a>
<a name="ln1854">    g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(entry_changed), d-&gt;rule + i);</a>
<a name="ln1855">    g_signal_connect(G_OBJECT(w), &quot;activate&quot;, G_CALLBACK(entry_activated), d-&gt;rule + i);</a>
<a name="ln1856">    gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln1857">    gtk_entry_set_width_chars(GTK_ENTRY(w), 0);</a>
<a name="ln1858"> </a>
<a name="ln1859">    w = dtgtk_button_new(dtgtk_cairo_paint_presets, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1860">    d-&gt;rule[i].button = w;</a>
<a name="ln1861">    gtk_widget_set_events(w, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln1862">    g_signal_connect(G_OBJECT(w), &quot;button-press-event&quot;, G_CALLBACK(popup_button_callback), d-&gt;rule + i);</a>
<a name="ln1863">    gtk_box_pack_start(box, w, FALSE, FALSE, 0);</a>
<a name="ln1864">    gtk_widget_set_size_request(w, DT_PIXEL_APPLY_DPI(13), DT_PIXEL_APPLY_DPI(13));</a>
<a name="ln1865">  }</a>
<a name="ln1866"> </a>
<a name="ln1867">  GtkWidget *sw = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln1868">  d-&gt;scrolledwindow = GTK_SCROLLED_WINDOW(sw);</a>
<a name="ln1869">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln1870">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(d-&gt;scrolledwindow), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln1871">  GtkTreeView *view = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln1872">  d-&gt;view_rule = -1;</a>
<a name="ln1873">  d-&gt;view = view;</a>
<a name="ln1874">  gtk_tree_view_set_headers_visible(view, FALSE);</a>
<a name="ln1875">  gtk_container_add(GTK_CONTAINER(sw), GTK_WIDGET(view));</a>
<a name="ln1876">  g_signal_connect(G_OBJECT(view), &quot;button-press-event&quot;, G_CALLBACK(view_onButtonPressed), d);</a>
<a name="ln1877">  g_signal_connect(G_OBJECT(view), &quot;popup-menu&quot;, G_CALLBACK(view_onPopupMenu), d);</a>
<a name="ln1878"> </a>
<a name="ln1879">  GtkTreeViewColumn *col = gtk_tree_view_column_new();</a>
<a name="ln1880">  gtk_tree_view_append_column(view, col);</a>
<a name="ln1881">  GtkCellRenderer *renderer = gtk_cell_renderer_text_new();</a>
<a name="ln1882">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln1883">  gtk_tree_view_column_set_cell_data_func(col, renderer, tree_count_show, NULL, NULL);</a>
<a name="ln1884">  g_object_set(renderer, &quot;strikethrough&quot;, TRUE, (gchar *)0);</a>
<a name="ln1885">  gtk_tree_view_column_add_attribute(col, renderer, &quot;strikethrough-set&quot;, DT_LIB_COLLECT_COL_UNREACHABLE);</a>
<a name="ln1886"> </a>
<a name="ln1887">  GtkTreeModel *listmodel</a>
<a name="ln1888">      = GTK_TREE_MODEL(gtk_list_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln1889">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln1890">  d-&gt;listfilter = gtk_tree_model_filter_new(listmodel, NULL);</a>
<a name="ln1891">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;listfilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln1892"> </a>
<a name="ln1893">  GtkTreeModel *treemodel</a>
<a name="ln1894">      = GTK_TREE_MODEL(gtk_tree_store_new(DT_LIB_COLLECT_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING,</a>
<a name="ln1895">                                          G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT));</a>
<a name="ln1896">  d-&gt;treefilter = gtk_tree_model_filter_new(treemodel, NULL);</a>
<a name="ln1897">  gtk_tree_model_filter_set_visible_column(GTK_TREE_MODEL_FILTER(d-&gt;treefilter), DT_LIB_COLLECT_COL_VISIBLE);</a>
<a name="ln1898">  g_object_unref(treemodel);</a>
<a name="ln1899"> </a>
<a name="ln1900">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw), TRUE, TRUE, 0);</a>
<a name="ln1901"> </a>
<a name="ln1902">  GtkWidget *sw2 = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln1903">  d-&gt;sw2 = GTK_SCROLLED_WINDOW(sw2);</a>
<a name="ln1904">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln1905">  gtk_scrolled_window_set_min_content_height(GTK_SCROLLED_WINDOW(sw2), DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln1906"> </a>
<a name="ln1907">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(sw2), TRUE, TRUE, 0);</a>
<a name="ln1908"> </a>
<a name="ln1909">  /* setup proxy */</a>
<a name="ln1910">  darktable.view_manager-&gt;proxy.module_collect.module = self;</a>
<a name="ln1911">  darktable.view_manager-&gt;proxy.module_collect.update = _lib_collect_gui_update;</a>
<a name="ln1912"> </a>
<a name="ln1913">  _lib_collect_gui_update(self);</a>
<a name="ln1914"> </a>
<a name="ln1915">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED, G_CALLBACK(collection_updated),</a>
<a name="ln1916">                            self);</a>
<a name="ln1917"> </a>
<a name="ln1918">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED, G_CALLBACK(filmrolls_updated),</a>
<a name="ln1919">                            self);</a>
<a name="ln1920"> </a>
<a name="ln1921">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_IMPORTED, G_CALLBACK(filmrolls_imported),</a>
<a name="ln1922">                            self);</a>
<a name="ln1923"> </a>
<a name="ln1924">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_FILMROLLS_REMOVED, G_CALLBACK(filmrolls_removed),</a>
<a name="ln1925">                            self);</a>
<a name="ln1926"> </a>
<a name="ln1927">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED, G_CALLBACK(tag_changed),</a>
<a name="ln1928">                            self);</a>
<a name="ln1929">}</a>
<a name="ln1930"> </a>
<a name="ln1931">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln1932">{</a>
<a name="ln1933">  dt_lib_collect_t *d = (dt_lib_collect_t *)self-&gt;data;</a>
<a name="ln1934"> </a>
<a name="ln1935">  for(int i = 0; i &lt; MAX_RULES; i++) dt_gui_key_accel_block_on_focus_disconnect(d-&gt;rule[i].text);</a>
<a name="ln1936"> </a>
<a name="ln1937">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(collection_updated), self);</a>
<a name="ln1938">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_updated), self);</a>
<a name="ln1939">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_imported), self);</a>
<a name="ln1940">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(filmrolls_removed), self);</a>
<a name="ln1941">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(tag_changed), self);</a>
<a name="ln1942">  darktable.view_manager-&gt;proxy.module_collect.module = NULL;</a>
<a name="ln1943">  free(d-&gt;params);</a>
<a name="ln1944"> </a>
<a name="ln1945">  /* cleanup mem */</a>
<a name="ln1946"> </a>
<a name="ln1947">  g_object_unref(d-&gt;treefilter);</a>
<a name="ln1948">  g_object_unref(d-&gt;listfilter);</a>
<a name="ln1949"> </a>
<a name="ln1950">  /* TODO: Make sure we are cleaning up all allocations */</a>
<a name="ln1951"> </a>
<a name="ln1952">  free(self-&gt;data);</a>
<a name="ln1953">  self-&gt;data = NULL;</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956"> </a>
<a name="ln1957">#ifdef USE_LUA</a>
<a name="ln1958">static int new_rule_cb(lua_State*L)</a>
<a name="ln1959">{</a>
<a name="ln1960">  dt_lib_collect_params_rule_t rule;</a>
<a name="ln1961">  memset(&amp;rule,0, sizeof(dt_lib_collect_params_rule_t));</a>
<a name="ln1962">  luaA_push(L,dt_lib_collect_params_rule_t,&amp;rule);</a>
<a name="ln1963">  return 1;</a>
<a name="ln1964">}</a>
<a name="ln1965">static int filter_cb(lua_State *L)</a>
<a name="ln1966">{</a>
<a name="ln1967">  dt_lib_module_t *self = lua_touserdata(L, lua_upvalueindex(1));</a>
<a name="ln1968"> </a>
<a name="ln1969">  int size;</a>
<a name="ln1970">  dt_lib_collect_params_t *p = get_params(self,&amp;size);</a>
<a name="ln1971">  // put it in stack so memory is not lost if a lua exception is raised</a>
<a name="ln1972"> </a>
<a name="ln1973"> </a>
<a name="ln1974"> </a>
<a name="ln1975">  if(lua_gettop(L) &gt; 0) {</a>
<a name="ln1976">    luaL_checktype(L,1,LUA_TTABLE);</a>
<a name="ln1977">    dt_lib_collect_params_t *new_p = get_params(self,&amp;size);</a>
<a name="ln1978">    new_p-&gt;rules = 0;</a>
<a name="ln1979">    do {</a>
<a name="ln1980">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln1981">      lua_gettable(L,1);</a>
<a name="ln1982">      if(lua_isnil(L,-1)) break;</a>
<a name="ln1983">      luaA_to(L,dt_lib_collect_params_rule_t,&amp;new_p-&gt;rule[new_p-&gt;rules],-1);</a>
<a name="ln1984">      new_p-&gt;rules++;</a>
<a name="ln1985">    }while(new_p-&gt;rules &lt; MAX_RULES);</a>
<a name="ln1986">    if(new_p-&gt;rules == MAX_RULES) {</a>
<a name="ln1987">      lua_pushinteger(L,new_p-&gt;rules + 1);</a>
<a name="ln1988">      lua_gettable(L,1);</a>
<a name="ln1989">      if(!lua_isnil(L,-1)) {</a>
<a name="ln1990">        luaL_error(L,&quot;Number of rules given excedes max allowed (%d)&quot;,MAX_RULES);</a>
<a name="ln1991">      }</a>
<a name="ln1992">    }</a>
<a name="ln1993">    set_params(self,new_p,size);</a>
<a name="ln1994">    free(new_p);</a>
<a name="ln1995"> </a>
<a name="ln1996">  }</a>
<a name="ln1997">  lua_newtable(L);</a>
<a name="ln1998">  for(int i = 0; i &lt; p-&gt;rules; i++) {</a>
<a name="ln1999">    luaA_push(L,dt_lib_collect_params_rule_t,&amp;p-&gt;rule[i]);</a>
<a name="ln2000">    luaL_ref(L,-2);</a>
<a name="ln2001">  }</a>
<a name="ln2002">  free(p);</a>
<a name="ln2003">  return 1;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">static int mode_member(lua_State *L)</a>
<a name="ln2007">{</a>
<a name="ln2008">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2009">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2010">    dt_lib_collect_mode_t value;</a>
<a name="ln2011">    luaA_to(L,dt_lib_collect_mode_t,&amp;value,3);</a>
<a name="ln2012">    rule-&gt;mode = value;</a>
<a name="ln2013">    return 0;</a>
<a name="ln2014">  }</a>
<a name="ln2015">  const dt_lib_collect_mode_t tmp = rule-&gt;mode; // temp buffer because of bitfield in the original struct</a>
<a name="ln2016">  luaA_push(L,dt_lib_collect_mode_t,&amp;tmp);</a>
<a name="ln2017">  return 1;</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">static int item_member(lua_State *L)</a>
<a name="ln2021">{</a>
<a name="ln2022">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2023"> </a>
<a name="ln2024">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2025">    dt_collection_properties_t value;</a>
<a name="ln2026">    luaA_to(L,dt_collection_properties_t,&amp;value,3);</a>
<a name="ln2027">    rule-&gt;item = value;</a>
<a name="ln2028">    return 0;</a>
<a name="ln2029">  }</a>
<a name="ln2030">  const dt_collection_properties_t tmp = rule-&gt;item; // temp buffer because of bitfield in the original struct</a>
<a name="ln2031">  luaA_push(L,dt_collection_properties_t,&amp;tmp);</a>
<a name="ln2032">  return 1;</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035">static int data_member(lua_State *L)</a>
<a name="ln2036">{</a>
<a name="ln2037">  dt_lib_collect_params_rule_t *rule = luaL_checkudata(L,1,&quot;dt_lib_collect_params_rule_t&quot;);</a>
<a name="ln2038"> </a>
<a name="ln2039">  if(lua_gettop(L) &gt; 2) {</a>
<a name="ln2040">    size_t tgt_size;</a>
<a name="ln2041">    const char*data = luaL_checklstring(L,3,&amp;tgt_size);</a>
<a name="ln2042">    if(tgt_size &gt; PARAM_STRING_SIZE)</a>
<a name="ln2043">    {</a>
<a name="ln2044">      return luaL_error(L, &quot;string '%s' too long (max is %d)&quot;, data, PARAM_STRING_SIZE);</a>
<a name="ln2045">    }</a>
<a name="ln2046">    g_strlcpy(rule-&gt;string, data, sizeof(rule-&gt;string));</a>
<a name="ln2047">    return 0;</a>
<a name="ln2048">  }</a>
<a name="ln2049">  lua_pushstring(L,rule-&gt;string);</a>
<a name="ln2050">  return 1;</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053"> </a>
<a name="ln2054"> </a>
<a name="ln2055">void init(struct dt_lib_module_t *self)</a>
<a name="ln2056">{</a>
<a name="ln2057"> </a>
<a name="ln2058">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln2059">  int my_type = dt_lua_module_entry_get_type(L, &quot;lib&quot;, self-&gt;plugin_name);</a>
<a name="ln2060">  lua_pushlightuserdata(L, self);</a>
<a name="ln2061">  lua_pushcclosure(L, filter_cb,1);</a>
<a name="ln2062">  dt_lua_gtk_wrap(L);</a>
<a name="ln2063">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2064">  dt_lua_type_register_const_type(L, my_type, &quot;filter&quot;);</a>
<a name="ln2065">  lua_pushcfunction(L, new_rule_cb);</a>
<a name="ln2066">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln2067">  dt_lua_type_register_const_type(L, my_type, &quot;new_rule&quot;);</a>
<a name="ln2068"> </a>
<a name="ln2069">  dt_lua_init_type(L,dt_lib_collect_params_rule_t);</a>
<a name="ln2070">  lua_pushcfunction(L,mode_member);</a>
<a name="ln2071">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;mode&quot;);</a>
<a name="ln2072">  lua_pushcfunction(L,item_member);</a>
<a name="ln2073">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;item&quot;);</a>
<a name="ln2074">  lua_pushcfunction(L,data_member);</a>
<a name="ln2075">  dt_lua_type_register(L, dt_lib_collect_params_rule_t, &quot;data&quot;);</a>
<a name="ln2076"> </a>
<a name="ln2077"> </a>
<a name="ln2078">  luaA_enum(L,dt_lib_collect_mode_t);</a>
<a name="ln2079">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND);</a>
<a name="ln2080">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_OR);</a>
<a name="ln2081">  luaA_enum_value(L,dt_lib_collect_mode_t,DT_LIB_COLLECT_MODE_AND_NOT);</a>
<a name="ln2082"> </a>
<a name="ln2083">  luaA_enum(L,dt_collection_properties_t);</a>
<a name="ln2084">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILMROLL);</a>
<a name="ln2085">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOLDERS);</a>
<a name="ln2086">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CAMERA);</a>
<a name="ln2087">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TAG);</a>
<a name="ln2088">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DAY);</a>
<a name="ln2089">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TIME);</a>
<a name="ln2090">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_HISTORY);</a>
<a name="ln2091">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_COLORLABEL);</a>
<a name="ln2092">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_TITLE);</a>
<a name="ln2093">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_DESCRIPTION);</a>
<a name="ln2094">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_CREATOR);</a>
<a name="ln2095">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_PUBLISHER);</a>
<a name="ln2096">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_RIGHTS);</a>
<a name="ln2097">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LENS);</a>
<a name="ln2098">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FOCAL_LENGTH);</a>
<a name="ln2099">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ISO);</a>
<a name="ln2100">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_APERTURE);</a>
<a name="ln2101">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_ASPECT_RATIO);</a>
<a name="ln2102">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_EXPOSURE);</a>
<a name="ln2103">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_FILENAME);</a>
<a name="ln2104">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GEOTAGGING);</a>
<a name="ln2105">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_LOCAL_COPY);</a>
<a name="ln2106">  luaA_enum_value(L,dt_collection_properties_t,DT_COLLECTION_PROP_GROUPING);</a>
<a name="ln2107"> </a>
<a name="ln2108">}</a>
<a name="ln2109">#endif</a>
<a name="ln2110">#undef MAX_RULES</a>
<a name="ln2111">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2112">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2113">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 166, 165.</p></div>
<div class="balloon" rel="326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="726"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: level > 0.</p></div>
<div class="balloon" rel="742"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'gtk_tree_model_iter_parent' function: 'child' and 'iter'.</p></div>
<div class="balloon" rel="740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'level > 0' condition was already verified in line 738.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'result'. Check lines: 794, 792.</p></div>
<div class="balloon" rel="941"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'tuple'. Check lines: 941, 940.</p></div>
<div class="balloon" rel="1823"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 1823, 1817.</p></div>
<div class="balloon" rel="1978"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_p'.</p></div>
<div class="balloon" rel="1998"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
