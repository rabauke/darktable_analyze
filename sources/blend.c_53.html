
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2011--2014 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;blend.h&quot;</a>
<a name="ln20">#include &quot;common/gaussian.h&quot;</a>
<a name="ln21">#include &quot;common/guided_filter.h&quot;</a>
<a name="ln22">#include &quot;common/math.h&quot;</a>
<a name="ln23">#include &quot;control/control.h&quot;</a>
<a name="ln24">#include &quot;develop/imageop.h&quot;</a>
<a name="ln25">#include &quot;develop/masks.h&quot;</a>
<a name="ln26">#include &quot;develop/tiling.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#define CLAMP_RANGE(x, y, z) (CLAMP(x, y, z))</a>
<a name="ln29"> </a>
<a name="ln30">typedef struct _blend_buffer_desc_t</a>
<a name="ln31">{</a>
<a name="ln32">  dt_iop_colorspace_type_t cst;</a>
<a name="ln33">  size_t stride;</a>
<a name="ln34">  size_t ch;</a>
<a name="ln35">  size_t bch;</a>
<a name="ln36">} _blend_buffer_desc_t;</a>
<a name="ln37"> </a>
<a name="ln38">typedef void(_blend_row_func)(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln39">                              int flag);</a>
<a name="ln40"> </a>
<a name="ln41">static inline void _RGB_2_HSL(const float *RGB, float *HSL)</a>
<a name="ln42">{</a>
<a name="ln43">  float H, S, L;</a>
<a name="ln44"> </a>
<a name="ln45">  float R = RGB[0];</a>
<a name="ln46">  float G = RGB[1];</a>
<a name="ln47">  float B = RGB[2];</a>
<a name="ln48"> </a>
<a name="ln49">  float var_Min = fminf(R, fminf(G, B));</a>
<a name="ln50">  float var_Max = fmaxf(R, fmaxf(G, B));</a>
<a name="ln51">  float del_Max = var_Max - var_Min;</a>
<a name="ln52"> </a>
<a name="ln53">  L = (var_Max + var_Min) / 2.0f;</a>
<a name="ln54"> </a>
<a name="ln55">  if(del_Max &lt; 1e-6f)</a>
<a name="ln56">  {</a>
<a name="ln57">    H = 0.0f;</a>
<a name="ln58">    S = 0.0f;</a>
<a name="ln59">  }</a>
<a name="ln60">  else</a>
<a name="ln61">  {</a>
<a name="ln62">    if(L &lt; 0.5f)</a>
<a name="ln63">      S = del_Max / (var_Max + var_Min);</a>
<a name="ln64">    else</a>
<a name="ln65">      S = del_Max / (2.0f - var_Max - var_Min);</a>
<a name="ln66"> </a>
<a name="ln67">    float del_R = (((var_Max - R) / 6.0f) + (del_Max / 2.0f)) / del_Max;</a>
<a name="ln68">    float del_G = (((var_Max - G) / 6.0f) + (del_Max / 2.0f)) / del_Max;</a>
<a name="ln69">    float del_B = (((var_Max - B) / 6.0f) + (del_Max / 2.0f)) / del_Max;</a>
<a name="ln70"> </a>
<a name="ln71">    if(R == var_Max)</a>
<a name="ln72">      H = del_B - del_G;</a>
<a name="ln73">    else if(G == var_Max)</a>
<a name="ln74">      H = (1.0f / 3.0f) + del_R - del_B;</a>
<a name="ln75">    else if(B == var_Max)</a>
<a name="ln76">      H = (2.0f / 3.0f) + del_G - del_R;</a>
<a name="ln77">    else</a>
<a name="ln78">      H = 0.0f; // make GCC happy</a>
<a name="ln79"> </a>
<a name="ln80">    if(H &lt; 0.0f) H += 1.0f;</a>
<a name="ln81">    if(H &gt; 1.0f) H -= 1.0f;</a>
<a name="ln82">  }</a>
<a name="ln83"> </a>
<a name="ln84">  HSL[0] = H;</a>
<a name="ln85">  HSL[1] = S;</a>
<a name="ln86">  HSL[2] = L;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">static inline float _Hue_2_RGB(float v1, float v2, float vH)</a>
<a name="ln90">{</a>
<a name="ln91">  if(vH &lt; 0.0f) vH += 1.0f;</a>
<a name="ln92">  if(vH &gt; 1.0f) vH -= 1.0f;</a>
<a name="ln93">  if((6.0f * vH) &lt; 1.0f) return (v1 + (v2 - v1) * 6.0f * vH);</a>
<a name="ln94">  if((2.0f * vH) &lt; 1.0f) return (v2);</a>
<a name="ln95">  if((3.0f * vH) &lt; 2.0f) return (v1 + (v2 - v1) * ((2.0f / 3.0f) - vH) * 6.0f);</a>
<a name="ln96">  return (v1);</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">static inline void _HSL_2_RGB(const float *HSL, float *RGB)</a>
<a name="ln100">{</a>
<a name="ln101">  float H = HSL[0];</a>
<a name="ln102">  float S = HSL[1];</a>
<a name="ln103">  float L = HSL[2];</a>
<a name="ln104"> </a>
<a name="ln105">  float var_1, var_2;</a>
<a name="ln106"> </a>
<a name="ln107">  if(S &lt; 1e-6f)</a>
<a name="ln108">  {</a>
<a name="ln109">    RGB[0] = RGB[1] = RGB[2] = L;</a>
<a name="ln110">  }</a>
<a name="ln111">  else</a>
<a name="ln112">  {</a>
<a name="ln113">    if(L &lt; 0.5f)</a>
<a name="ln114">      var_2 = L * (1.0f + S);</a>
<a name="ln115">    else</a>
<a name="ln116">      var_2 = (L + S) - (S * L);</a>
<a name="ln117"> </a>
<a name="ln118">    var_1 = 2.0f * L - var_2;</a>
<a name="ln119"> </a>
<a name="ln120">    RGB[0] = _Hue_2_RGB(var_1, var_2, H + (1.0f / 3.0f));</a>
<a name="ln121">    RGB[1] = _Hue_2_RGB(var_1, var_2, H);</a>
<a name="ln122">    RGB[2] = _Hue_2_RGB(var_1, var_2, H - (1.0f / 3.0f));</a>
<a name="ln123">  }</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">static inline void _RGB_2_HSV(const float *RGB, float *HSV)</a>
<a name="ln127">{</a>
<a name="ln128">  float r = RGB[0], g = RGB[1], b = RGB[2];</a>
<a name="ln129">  float *h = HSV, *s = HSV + 1, *v = HSV + 2;</a>
<a name="ln130"> </a>
<a name="ln131">  float min = fminf(r, fminf(g, b));</a>
<a name="ln132">  float max = fmaxf(r, fmaxf(g, b));</a>
<a name="ln133">  float delta = max - min;</a>
<a name="ln134"> </a>
<a name="ln135">  *v = max;</a>
<a name="ln136"> </a>
<a name="ln137">  if(fabsf(max) &gt; 1e-6f &amp;&amp; fabsf(delta) &gt; 1e-6f)</a>
<a name="ln138">  {</a>
<a name="ln139">    *s = delta / max;</a>
<a name="ln140">  }</a>
<a name="ln141">  else</a>
<a name="ln142">  {</a>
<a name="ln143">    *s = 0.0f;</a>
<a name="ln144">    *h = 0.0f;</a>
<a name="ln145">    return;</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  if(r == max)</a>
<a name="ln149">    *h = (g - b) / delta;</a>
<a name="ln150">  else if(g == max)</a>
<a name="ln151">    *h = 2.0f + (b - r) / delta;</a>
<a name="ln152">  else</a>
<a name="ln153">    *h = 4.0f + (r - g) / delta;</a>
<a name="ln154"> </a>
<a name="ln155">  *h /= 6.0f;</a>
<a name="ln156"> </a>
<a name="ln157">  if(*h &lt; 0) *h += 1.0f;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">static inline void _HSV_2_RGB(const float *HSV, float *RGB)</a>
<a name="ln161">{</a>
<a name="ln162">  float h = 6.0f * HSV[0], s = HSV[1], v = HSV[2];</a>
<a name="ln163">  float *r = RGB, *g = RGB + 1, *b = RGB + 2;</a>
<a name="ln164"> </a>
<a name="ln165">  if(fabsf(s) &lt; 1e-6f)</a>
<a name="ln166">  {</a>
<a name="ln167">    *r = *g = *b = v;</a>
<a name="ln168">    return;</a>
<a name="ln169">  }</a>
<a name="ln170"> </a>
<a name="ln171">  float i = floorf(h);</a>
<a name="ln172">  float f = h - i;</a>
<a name="ln173">  float p = v * (1.0f - s);</a>
<a name="ln174">  float q = v * (1.0f - s * f);</a>
<a name="ln175">  float t = v * (1.0f - s * (1.0f - f));</a>
<a name="ln176"> </a>
<a name="ln177">  switch((int)i)</a>
<a name="ln178">  {</a>
<a name="ln179">    case 0:</a>
<a name="ln180">      *r = v;</a>
<a name="ln181">      *g = t;</a>
<a name="ln182">      *b = p;</a>
<a name="ln183">      break;</a>
<a name="ln184">    case 1:</a>
<a name="ln185">      *r = q;</a>
<a name="ln186">      *g = v;</a>
<a name="ln187">      *b = p;</a>
<a name="ln188">      break;</a>
<a name="ln189">    case 2:</a>
<a name="ln190">      *r = p;</a>
<a name="ln191">      *g = v;</a>
<a name="ln192">      *b = t;</a>
<a name="ln193">      break;</a>
<a name="ln194">    case 3:</a>
<a name="ln195">      *r = p;</a>
<a name="ln196">      *g = q;</a>
<a name="ln197">      *b = v;</a>
<a name="ln198">      break;</a>
<a name="ln199">    case 4:</a>
<a name="ln200">      *r = t;</a>
<a name="ln201">      *g = p;</a>
<a name="ln202">      *b = v;</a>
<a name="ln203">      break;</a>
<a name="ln204">    case 5:</a>
<a name="ln205">    default:</a>
<a name="ln206">      *r = v;</a>
<a name="ln207">      *g = p;</a>
<a name="ln208">      *b = q;</a>
<a name="ln209">      break;</a>
<a name="ln210">  }</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static inline void _Lab_2_LCH(const float *Lab, float *LCH)</a>
<a name="ln214">{</a>
<a name="ln215">  float var_H = atan2f(Lab[2], Lab[1]);</a>
<a name="ln216"> </a>
<a name="ln217">  if(var_H &gt; 0.0f)</a>
<a name="ln218">    var_H = var_H / (2.0f * DT_M_PI_F);</a>
<a name="ln219">  else</a>
<a name="ln220">    var_H = 1.0f + var_H / (2.0f * DT_M_PI_F);</a>
<a name="ln221"> </a>
<a name="ln222">  LCH[0] = Lab[0];</a>
<a name="ln223">  LCH[1] = sqrtf(Lab[1] * Lab[1] + Lab[2] * Lab[2]);</a>
<a name="ln224">  LCH[2] = var_H;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">static inline void _LCH_2_Lab(const float *LCH, float *Lab)</a>
<a name="ln228">{</a>
<a name="ln229">  Lab[0] = LCH[0];</a>
<a name="ln230">  Lab[1] = cosf(2.0f * DT_M_PI_F * LCH[2]) * LCH[1];</a>
<a name="ln231">  Lab[2] = sinf(2.0f * DT_M_PI_F * LCH[2]) * LCH[1];</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">static inline void _CLAMP_XYZ(float *XYZ, const float *min, const float *max)</a>
<a name="ln235">{</a>
<a name="ln236">  XYZ[0] = CLAMP_RANGE(XYZ[0], min[0], max[0]);</a>
<a name="ln237">  XYZ[1] = CLAMP_RANGE(XYZ[1], min[1], max[1]);</a>
<a name="ln238">  XYZ[2] = CLAMP_RANGE(XYZ[2], min[2], max[2]);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">static inline void _PX_COPY(const float *src, float *dst)</a>
<a name="ln242">{</a>
<a name="ln243">  dst[0] = src[0];</a>
<a name="ln244">  dst[1] = src[1];</a>
<a name="ln245">  dst[2] = src[2];</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">static inline float _blendif_factor(dt_iop_colorspace_type_t cst, const float *input, const float *output,</a>
<a name="ln249">                                    const unsigned int blendif, const float *parameters,</a>
<a name="ln250">                                    const unsigned int mask_mode, const unsigned int mask_combine)</a>
<a name="ln251">{</a>
<a name="ln252">  float result = 1.0f;</a>
<a name="ln253">  float scaled[DEVELOP_BLENDIF_SIZE] = { 0.5f };</a>
<a name="ln254">  unsigned int channel_mask = 0;</a>
<a name="ln255"> </a>
<a name="ln256">  if(!(mask_mode &amp; DEVELOP_MASK_CONDITIONAL)) return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln257"> </a>
<a name="ln258">  switch(cst)</a>
<a name="ln259">  {</a>
<a name="ln260">    case iop_cs_Lab:</a>
<a name="ln261">      scaled[DEVELOP_BLENDIF_L_in] = CLAMP_RANGE(input[0] / 100.0f, 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln262">      scaled[DEVELOP_BLENDIF_A_in]</a>
<a name="ln263">          = CLAMP_RANGE((input[1] + 128.0f) / 256.0f, 0.0f, 1.0f); // a scaled to 0..1</a>
<a name="ln264">      scaled[DEVELOP_BLENDIF_B_in]</a>
<a name="ln265">          = CLAMP_RANGE((input[2] + 128.0f) / 256.0f, 0.0f, 1.0f);                 // b scaled to 0..1</a>
<a name="ln266">      scaled[DEVELOP_BLENDIF_L_out] = CLAMP_RANGE(output[0] / 100.0f, 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln267">      scaled[DEVELOP_BLENDIF_A_out]</a>
<a name="ln268">          = CLAMP_RANGE((output[1] + 128.0f) / 256.0f, 0.0f, 1.0f); // a scaled to 0..1</a>
<a name="ln269">      scaled[DEVELOP_BLENDIF_B_out]</a>
<a name="ln270">          = CLAMP_RANGE((output[2] + 128.0f) / 256.0f, 0.0f, 1.0f); // b scaled to 0..1</a>
<a name="ln271"> </a>
<a name="ln272">      if(blendif &amp; 0x7f00) // do we need to consider LCh ?</a>
<a name="ln273">      {</a>
<a name="ln274">        float LCH_input[3];</a>
<a name="ln275">        float LCH_output[3];</a>
<a name="ln276">        _Lab_2_LCH(input, LCH_input);</a>
<a name="ln277">        _Lab_2_LCH(output, LCH_output);</a>
<a name="ln278"> </a>
<a name="ln279">        scaled[DEVELOP_BLENDIF_C_in] = CLAMP_RANGE(LCH_input[1] / (128.0f * sqrtf(2.0f)), 0.0f,</a>
<a name="ln280">                                                   1.0f);                     // C scaled to 0..1</a>
<a name="ln281">        scaled[DEVELOP_BLENDIF_h_in] = CLAMP_RANGE(LCH_input[2], 0.0f, 1.0f); // h scaled to 0..1</a>
<a name="ln282"> </a>
<a name="ln283">        scaled[DEVELOP_BLENDIF_C_out] = CLAMP_RANGE(LCH_output[1] / (128.0f * sqrtf(2.0f)), 0.0f,</a>
<a name="ln284">                                                    1.0f);                      // C scaled to 0..1</a>
<a name="ln285">        scaled[DEVELOP_BLENDIF_h_out] = CLAMP_RANGE(LCH_output[2], 0.0f, 1.0f); // h scaled to 0..1</a>
<a name="ln286">      }</a>
<a name="ln287"> </a>
<a name="ln288">      channel_mask = DEVELOP_BLENDIF_Lab_MASK;</a>
<a name="ln289"> </a>
<a name="ln290">      break;</a>
<a name="ln291">    case iop_cs_rgb:</a>
<a name="ln292">      scaled[DEVELOP_BLENDIF_GRAY_in]</a>
<a name="ln293">          = CLAMP_RANGE(0.3f * input[0] + 0.59f * input[1] + 0.11f * input[2], 0.0f,</a>
<a name="ln294">                        1.0f);                                              // Gray scaled to 0..1</a>
<a name="ln295">      scaled[DEVELOP_BLENDIF_RED_in] = CLAMP_RANGE(input[0], 0.0f, 1.0f);   // Red</a>
<a name="ln296">      scaled[DEVELOP_BLENDIF_GREEN_in] = CLAMP_RANGE(input[1], 0.0f, 1.0f); // Green</a>
<a name="ln297">      scaled[DEVELOP_BLENDIF_BLUE_in] = CLAMP_RANGE(input[2], 0.0f, 1.0f);  // Blue</a>
<a name="ln298">      scaled[DEVELOP_BLENDIF_GRAY_out] = CLAMP_RANGE(0.3f * output[0] + 0.59f * output[1] + 0.11f * output[2],</a>
<a name="ln299">                                                     0.0f, 1.0f);             // Gray scaled to 0..1</a>
<a name="ln300">      scaled[DEVELOP_BLENDIF_RED_out] = CLAMP_RANGE(output[0], 0.0f, 1.0f);   // Red</a>
<a name="ln301">      scaled[DEVELOP_BLENDIF_GREEN_out] = CLAMP_RANGE(output[1], 0.0f, 1.0f); // Green</a>
<a name="ln302">      scaled[DEVELOP_BLENDIF_BLUE_out] = CLAMP_RANGE(output[2], 0.0f, 1.0f);  // Blue</a>
<a name="ln303"> </a>
<a name="ln304">      if(blendif &amp; 0x7f00) // do we need to consider HSL ?</a>
<a name="ln305">      {</a>
<a name="ln306">        float HSL_input[3];</a>
<a name="ln307">        float HSL_output[3];</a>
<a name="ln308">        _RGB_2_HSL(input, HSL_input);</a>
<a name="ln309">        _RGB_2_HSL(output, HSL_output);</a>
<a name="ln310"> </a>
<a name="ln311">        scaled[DEVELOP_BLENDIF_H_in] = CLAMP_RANGE(HSL_input[0], 0.0f, 1.0f); // H scaled to 0..1</a>
<a name="ln312">        scaled[DEVELOP_BLENDIF_S_in] = CLAMP_RANGE(HSL_input[1], 0.0f, 1.0f); // S scaled to 0..1</a>
<a name="ln313">        scaled[DEVELOP_BLENDIF_l_in] = CLAMP_RANGE(HSL_input[2], 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln314"> </a>
<a name="ln315">        scaled[DEVELOP_BLENDIF_H_out] = CLAMP_RANGE(HSL_output[0], 0.0f, 1.0f); // H scaled to 0..1</a>
<a name="ln316">        scaled[DEVELOP_BLENDIF_S_out] = CLAMP_RANGE(HSL_output[1], 0.0f, 1.0f); // S scaled to 0..1</a>
<a name="ln317">        scaled[DEVELOP_BLENDIF_l_out] = CLAMP_RANGE(HSL_output[2], 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln318">      }</a>
<a name="ln319"> </a>
<a name="ln320">      channel_mask = DEVELOP_BLENDIF_RGB_MASK;</a>
<a name="ln321"> </a>
<a name="ln322">      break;</a>
<a name="ln323">    default:</a>
<a name="ln324">      return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f; // not implemented for other color spaces</a>
<a name="ln325">  }</a>
<a name="ln326"> </a>
<a name="ln327">  for(int ch = 0; ch &lt;= DEVELOP_BLENDIF_MAX; ch++)</a>
<a name="ln328">  {</a>
<a name="ln329">    if((channel_mask &amp; (1 &lt;&lt; ch)) == 0) continue; // skip blendif channels not used in this color space</a>
<a name="ln330"> </a>
<a name="ln331">    if((blendif &amp; (1 &lt;&lt; ch)) == 0) // deal with channels where sliders span the whole range</a>
<a name="ln332">    {</a>
<a name="ln333">      result *= !(blendif &amp; (1 &lt;&lt; (ch + 16))) == !(mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f : 0.0f;</a>
<a name="ln334">      continue;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    if(result &lt;= 0.000001f) break; // no need to continue if we are already at or close to zero</a>
<a name="ln338"> </a>
<a name="ln339">    float factor;</a>
<a name="ln340">    if(scaled[ch] &gt;= parameters[4 * ch + 1] &amp;&amp; scaled[ch] &lt;= parameters[4 * ch + 2])</a>
<a name="ln341">    {</a>
<a name="ln342">      factor = 1.0f;</a>
<a name="ln343">    }</a>
<a name="ln344">    else if(scaled[ch] &gt; parameters[4 * ch + 0] &amp;&amp; scaled[ch] &lt; parameters[4 * ch + 1])</a>
<a name="ln345">    {</a>
<a name="ln346">      factor</a>
<a name="ln347">          = (scaled[ch] - parameters[4 * ch + 0]) / fmaxf(0.01f, parameters[4 * ch + 1] - parameters[4 * ch + 0]);</a>
<a name="ln348">    }</a>
<a name="ln349">    else if(scaled[ch] &gt; parameters[4 * ch + 2] &amp;&amp; scaled[ch] &lt; parameters[4 * ch + 3])</a>
<a name="ln350">    {</a>
<a name="ln351">      factor = 1.0f</a>
<a name="ln352">               - (scaled[ch] - parameters[4 * ch + 2])</a>
<a name="ln353">                     / fmaxf(0.01f, parameters[4 * ch + 3] - parameters[4 * ch + 2]);</a>
<a name="ln354">    }</a>
<a name="ln355">    else</a>
<a name="ln356">      factor = 0.0f;</a>
<a name="ln357"> </a>
<a name="ln358">    if((blendif &amp; (1 &lt;&lt; (ch + 16))) != 0) factor = 1.0f - factor; // inverted channel?</a>
<a name="ln359"> </a>
<a name="ln360">    result *= ((mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - factor : factor);</a>
<a name="ln361">  }</a>
<a name="ln362"> </a>
<a name="ln363">  return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - result : result;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static inline void _blend_colorspace_channel_range(dt_iop_colorspace_type_t cst, float *min, float *max)</a>
<a name="ln367">{</a>
<a name="ln368">  switch(cst)</a>
<a name="ln369">  {</a>
<a name="ln370">    case iop_cs_Lab: // after scaling !!!</a>
<a name="ln371">      min[0] = 0.0f;</a>
<a name="ln372">      max[0] = 1.0f;</a>
<a name="ln373">      min[1] = -1.0f;</a>
<a name="ln374">      max[1] = 1.0f;</a>
<a name="ln375">      min[2] = -1.0f;</a>
<a name="ln376">      max[2] = 1.0f;</a>
<a name="ln377">      min[3] = 0.0f;</a>
<a name="ln378">      max[3] = 1.0f;</a>
<a name="ln379">      break;</a>
<a name="ln380">    default:</a>
<a name="ln381">      min[0] = 0.0f;</a>
<a name="ln382">      max[0] = 1.0f;</a>
<a name="ln383">      min[1] = 0.0f;</a>
<a name="ln384">      max[1] = 1.0f;</a>
<a name="ln385">      min[2] = 0.0f;</a>
<a name="ln386">      max[2] = 1.0f;</a>
<a name="ln387">      min[3] = 0.0f;</a>
<a name="ln388">      max[3] = 1.0f;</a>
<a name="ln389">      break;</a>
<a name="ln390">  }</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static inline void _blend_Lab_scale(const float *i, float *o)</a>
<a name="ln394">{</a>
<a name="ln395">  o[0] = i[0] / 100.0f;</a>
<a name="ln396">  o[1] = i[1] / 128.0f;</a>
<a name="ln397">  o[2] = i[2] / 128.0f;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">static inline void _blend_Lab_rescale(const float *i, float *o)</a>
<a name="ln401">{</a>
<a name="ln402">  o[0] = i[0] * 100.0f;</a>
<a name="ln403">  o[1] = i[1] * 128.0f;</a>
<a name="ln404">  o[2] = i[2] * 128.0f;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">static inline void _blend_noop(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln409">                               const float *min, const float *max)</a>
<a name="ln410">{</a>
<a name="ln411">  for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln412">  {</a>
<a name="ln413">    for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = CLAMP_RANGE(a[j + k], min ? min[k] : -INFINITY, max ? max[k] : INFINITY);</a>
<a name="ln414">    if(bd-&gt;cst != iop_cs_RAW) b[j + 3] = mask[i];</a>
<a name="ln415">  }</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">/* generate blend mask */</a>
<a name="ln420">static void _blend_make_mask(const _blend_buffer_desc_t *bd, const unsigned int blendif,</a>
<a name="ln421">                             const float *blendif_parameters, const unsigned int mask_mode,</a>
<a name="ln422">                             const unsigned int mask_combine, const float gopacity, const float *a,</a>
<a name="ln423">                             const float *b, float *mask)</a>
<a name="ln424">{</a>
<a name="ln425">  for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln426">  {</a>
<a name="ln427">    float form = mask[i];</a>
<a name="ln428">    float conditional</a>
<a name="ln429">        = _blendif_factor(bd-&gt;cst, &amp;a[j], &amp;b[j], blendif, blendif_parameters, mask_mode, mask_combine);</a>
<a name="ln430">    float opacity = (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - (1.0f - form) * (1.0f - conditional)</a>
<a name="ln431">                                                          : form * conditional;</a>
<a name="ln432">    opacity = (mask_combine &amp; DEVELOP_COMBINE_INV) ? 1.0f - opacity : opacity;</a>
<a name="ln433">    mask[i] = opacity * gopacity;</a>
<a name="ln434">  }</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">/* normal blend with clamping */</a>
<a name="ln438">static void _blend_normal_bounded(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln439">                                  int flag)</a>
<a name="ln440">{</a>
<a name="ln441">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln442">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln443"> </a>
<a name="ln444">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln445">  {</a>
<a name="ln446">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln447">    {</a>
<a name="ln448">      float local_opacity = mask[i];</a>
<a name="ln449">      float ta[3], tb[3];</a>
<a name="ln450">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln451">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln452"> </a>
<a name="ln453">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln454"> </a>
<a name="ln455">      if(flag == 0)</a>
<a name="ln456">      {</a>
<a name="ln457">        tb[1] = CLAMP_RANGE((ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity, min[1], max[1]);</a>
<a name="ln458">        tb[2] = CLAMP_RANGE((ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity, min[2], max[2]);</a>
<a name="ln459">      }</a>
<a name="ln460">      else</a>
<a name="ln461">      {</a>
<a name="ln462">        tb[1] = ta[1];</a>
<a name="ln463">        tb[2] = ta[2];</a>
<a name="ln464">      }</a>
<a name="ln465"> </a>
<a name="ln466">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln467">      b[j + 3] = local_opacity;</a>
<a name="ln468">    }</a>
<a name="ln469">  }</a>
<a name="ln470">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln471">  {</a>
<a name="ln472">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln473">    {</a>
<a name="ln474">      float local_opacity = mask[i];</a>
<a name="ln475">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln476">        b[j + k]</a>
<a name="ln477">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln478">      b[j + 3] = local_opacity;</a>
<a name="ln479">    }</a>
<a name="ln480">  }</a>
<a name="ln481">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln482">  {</a>
<a name="ln483">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln484">    {</a>
<a name="ln485">      float local_opacity = mask[i];</a>
<a name="ln486">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln487">        b[j + k]</a>
<a name="ln488">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln489">    }</a>
<a name="ln490">  }</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">/* normal blend without any clamping */</a>
<a name="ln494">static void _blend_normal_unbounded(const _blend_buffer_desc_t *bd, const float *a, float *b,</a>
<a name="ln495">                                    const float *mask, int flag)</a>
<a name="ln496">{</a>
<a name="ln497">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln498">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln499"> </a>
<a name="ln500">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln501">  {</a>
<a name="ln502">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln503">    {</a>
<a name="ln504">      float local_opacity = mask[i];</a>
<a name="ln505">      float ta[3], tb[3];</a>
<a name="ln506">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln507">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln508"> </a>
<a name="ln509">      tb[0] = (ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity;</a>
<a name="ln510"> </a>
<a name="ln511">      if(flag == 0)</a>
<a name="ln512">      {</a>
<a name="ln513">        tb[1] = (ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity;</a>
<a name="ln514">        tb[2] = (ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity;</a>
<a name="ln515">      }</a>
<a name="ln516">      else</a>
<a name="ln517">      {</a>
<a name="ln518">        tb[1] = ta[1];</a>
<a name="ln519">        tb[2] = ta[2];</a>
<a name="ln520">      }</a>
<a name="ln521"> </a>
<a name="ln522">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln523">      b[j + 3] = local_opacity;</a>
<a name="ln524">    }</a>
<a name="ln525">  }</a>
<a name="ln526">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln527">  {</a>
<a name="ln528">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln529">    {</a>
<a name="ln530">      float local_opacity = mask[i];</a>
<a name="ln531">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln532">        b[j + k] = (a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity;</a>
<a name="ln533">      b[j + 3] = local_opacity;</a>
<a name="ln534">    }</a>
<a name="ln535">  }</a>
<a name="ln536">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln537">  {</a>
<a name="ln538">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln539">    {</a>
<a name="ln540">      float local_opacity = mask[i];</a>
<a name="ln541">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln542">        b[j + k] = (a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity;</a>
<a name="ln543">    }</a>
<a name="ln544">  }</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">/* lighten */</a>
<a name="ln548">static void _blend_lighten(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln549">                           int flag)</a>
<a name="ln550">{</a>
<a name="ln551">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln552">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln553"> </a>
<a name="ln554">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln555">  {</a>
<a name="ln556">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln557">    {</a>
<a name="ln558">      float local_opacity = mask[i];</a>
<a name="ln559">      float ta[3], tb[3], tbo;</a>
<a name="ln560">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln561">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln562"> </a>
<a name="ln563">      tbo = tb[0];</a>
<a name="ln564">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + (ta[0] &gt; tb[0] ? ta[0] : tb[0]) * local_opacity,</a>
<a name="ln565">                          min[0], max[0]);</a>
<a name="ln566"> </a>
<a name="ln567">      if(flag == 0)</a>
<a name="ln568">      {</a>
<a name="ln569">        tb[1] = CLAMP_RANGE(ta[1] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[1] + tb[1]) * fabsf(tbo - tb[0]),</a>
<a name="ln570">                            min[1], max[1]);</a>
<a name="ln571">        tb[2] = CLAMP_RANGE(ta[2] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[2] + tb[2]) * fabsf(tbo - tb[0]),</a>
<a name="ln572">                            min[2], max[2]);</a>
<a name="ln573">      }</a>
<a name="ln574">      else</a>
<a name="ln575">      {</a>
<a name="ln576">        tb[1] = ta[1];</a>
<a name="ln577">        tb[2] = ta[2];</a>
<a name="ln578">      }</a>
<a name="ln579"> </a>
<a name="ln580">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln581">      b[j + 3] = local_opacity;</a>
<a name="ln582">    }</a>
<a name="ln583">  }</a>
<a name="ln584">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln585">  {</a>
<a name="ln586">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln587">    {</a>
<a name="ln588">      float local_opacity = mask[i];</a>
<a name="ln589">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln590">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fmaxf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln591">                               min[k], max[k]);</a>
<a name="ln592">      b[j + 3] = local_opacity;</a>
<a name="ln593">    }</a>
<a name="ln594">  }</a>
<a name="ln595">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln596">  {</a>
<a name="ln597">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln598">    {</a>
<a name="ln599">      float local_opacity = mask[i];</a>
<a name="ln600">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln601">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fmaxf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln602">                               min[k], max[k]);</a>
<a name="ln603">    }</a>
<a name="ln604">  }</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">/* darken */</a>
<a name="ln608">static void _blend_darken(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln609">                          int flag)</a>
<a name="ln610">{</a>
<a name="ln611">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln612">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln613"> </a>
<a name="ln614">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln615">  {</a>
<a name="ln616">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln617">    {</a>
<a name="ln618">      float local_opacity = mask[i];</a>
<a name="ln619">      float ta[3], tb[3], tbo;</a>
<a name="ln620">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln621">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln622"> </a>
<a name="ln623">      tbo = tb[0];</a>
<a name="ln624">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + (ta[0] &lt; tb[0] ? ta[0] : tb[0]) * local_opacity,</a>
<a name="ln625">                          min[0], max[0]);</a>
<a name="ln626"> </a>
<a name="ln627">      if(flag == 0)</a>
<a name="ln628">      {</a>
<a name="ln629">        tb[1] = CLAMP_RANGE(ta[1] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[1] + tb[1]) * fabsf(tbo - tb[0]),</a>
<a name="ln630">                            min[1], max[1]);</a>
<a name="ln631">        tb[2] = CLAMP_RANGE(ta[2] * (1.0f - fabsf(tbo - tb[0])) + 0.5f * (ta[2] + tb[2]) * fabsf(tbo - tb[0]),</a>
<a name="ln632">                            min[2], max[2]);</a>
<a name="ln633">      }</a>
<a name="ln634">      else</a>
<a name="ln635">      {</a>
<a name="ln636">        tb[1] = ta[1];</a>
<a name="ln637">        tb[2] = ta[2];</a>
<a name="ln638">      }</a>
<a name="ln639"> </a>
<a name="ln640">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln641">      b[j + 3] = local_opacity;</a>
<a name="ln642">    }</a>
<a name="ln643">  }</a>
<a name="ln644">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln645">  {</a>
<a name="ln646">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln647">    {</a>
<a name="ln648">      float local_opacity = mask[i];</a>
<a name="ln649">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln650">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fminf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln651">                               min[k], max[k]);</a>
<a name="ln652">      b[j + 3] = local_opacity;</a>
<a name="ln653">    }</a>
<a name="ln654">  }</a>
<a name="ln655">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln656">  {</a>
<a name="ln657">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln658">    {</a>
<a name="ln659">      float local_opacity = mask[i];</a>
<a name="ln660">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln661">        b[j + k] = CLAMP_RANGE(a[j + k] * (1.0f - local_opacity) + fminf(a[j + k], b[j + k]) * local_opacity,</a>
<a name="ln662">                               min[k], max[k]);</a>
<a name="ln663">    }</a>
<a name="ln664">  }</a>
<a name="ln665">  // return fminf(a,b);</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">/* multiply */</a>
<a name="ln669">static void _blend_multiply(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln670">                            int flag)</a>
<a name="ln671">{</a>
<a name="ln672">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln673">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln674"> </a>
<a name="ln675">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln676">  {</a>
<a name="ln677">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln678">    {</a>
<a name="ln679">      float local_opacity = mask[i];</a>
<a name="ln680">      float ta[3], tb[3];</a>
<a name="ln681">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln682"> </a>
<a name="ln683">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln684">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln685">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln686">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln687">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln688"> </a>
<a name="ln689">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity)) + ((la * lb) * local_opacity)), min[0], max[0])</a>
<a name="ln690">              - fabsf(min[0]);</a>
<a name="ln691"> </a>
<a name="ln692">      if(flag == 0)</a>
<a name="ln693">      {</a>
<a name="ln694">        if(ta[0] &gt; 0.01f)</a>
<a name="ln695">        {</a>
<a name="ln696">          tb[1]</a>
<a name="ln697">              = CLAMP_RANGE(ta[1] * (1.0f - local_opacity) + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln698">                            min[1], max[1]);</a>
<a name="ln699">          tb[2]</a>
<a name="ln700">              = CLAMP_RANGE(ta[2] * (1.0f - local_opacity) + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln701">                            min[2], max[2]);</a>
<a name="ln702">        }</a>
<a name="ln703">        else</a>
<a name="ln704">        {</a>
<a name="ln705">          tb[1]</a>
<a name="ln706">              = CLAMP_RANGE(ta[1] * (1.0f - local_opacity) + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln707">                            min[1], max[1]);</a>
<a name="ln708">          tb[2]</a>
<a name="ln709">              = CLAMP_RANGE(ta[2] * (1.0f - local_opacity) + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln710">                            min[2], max[2]);</a>
<a name="ln711">        }</a>
<a name="ln712">      }</a>
<a name="ln713">      else</a>
<a name="ln714">      {</a>
<a name="ln715">        tb[1] = ta[1];</a>
<a name="ln716">        tb[2] = ta[2];</a>
<a name="ln717">      }</a>
<a name="ln718"> </a>
<a name="ln719">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln720">      b[j + 3] = local_opacity;</a>
<a name="ln721">    }</a>
<a name="ln722">  }</a>
<a name="ln723">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln724">  {</a>
<a name="ln725">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln726">    {</a>
<a name="ln727">      float local_opacity = mask[i];</a>
<a name="ln728">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln729">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln730">            ((a[j + k] * (1.0f - local_opacity)) + ((a[j + k] * b[j + k]) * local_opacity)), min[k], max[k]);</a>
<a name="ln731">      b[j + 3] = local_opacity;</a>
<a name="ln732">    }</a>
<a name="ln733">  }</a>
<a name="ln734">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln735">  {</a>
<a name="ln736">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln737">    {</a>
<a name="ln738">      float local_opacity = mask[i];</a>
<a name="ln739">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln740"> </a>
<a name="ln741">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln742">            ((a[j + k] * (1.0f - local_opacity)) + ((a[j + k] * b[j + k]) * local_opacity)), min[k], max[k]);</a>
<a name="ln743">    }</a>
<a name="ln744">  }</a>
<a name="ln745">  // return (a*b);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">/* average */</a>
<a name="ln749">static void _blend_average(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln750">                           int flag)</a>
<a name="ln751">{</a>
<a name="ln752">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln753">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln754"> </a>
<a name="ln755">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln756">  {</a>
<a name="ln757">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln758">    {</a>
<a name="ln759">      float local_opacity = mask[i];</a>
<a name="ln760">      float ta[3], tb[3];</a>
<a name="ln761">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln762">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln763"> </a>
<a name="ln764">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + (ta[0] + tb[0]) / 2.0f * local_opacity, min[0],</a>
<a name="ln765">                          max[0]);</a>
<a name="ln766"> </a>
<a name="ln767">      if(flag == 0)</a>
<a name="ln768">      {</a>
<a name="ln769">        tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity) + (ta[1] + tb[1]) / 2.0f * local_opacity, min[1],</a>
<a name="ln770">                            max[1]);</a>
<a name="ln771">        tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity) + (ta[2] + tb[2]) / 2.0f * local_opacity, min[2],</a>
<a name="ln772">                            max[2]);</a>
<a name="ln773">      }</a>
<a name="ln774">      else</a>
<a name="ln775">      {</a>
<a name="ln776">        tb[1] = ta[1];</a>
<a name="ln777">        tb[2] = ta[2];</a>
<a name="ln778">      }</a>
<a name="ln779"> </a>
<a name="ln780">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln781">      b[j + 3] = local_opacity;</a>
<a name="ln782">    }</a>
<a name="ln783">  }</a>
<a name="ln784">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln785">  {</a>
<a name="ln786">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln787">    {</a>
<a name="ln788">      float local_opacity = mask[i];</a>
<a name="ln789">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln790">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln791">            a[j + k] * (1.0f - local_opacity) + (a[j + k] + b[j + k]) / 2.0f * local_opacity, min[k], max[k]);</a>
<a name="ln792"> </a>
<a name="ln793">      b[j + 3] = local_opacity;</a>
<a name="ln794">    }</a>
<a name="ln795">  }</a>
<a name="ln796">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln797">  {</a>
<a name="ln798">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln799">    {</a>
<a name="ln800">      float local_opacity = mask[i];</a>
<a name="ln801">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln802">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln803">            a[j + k] * (1.0f - local_opacity) + (a[j + k] + b[j + k]) / 2.0f * local_opacity, min[k], max[k]);</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806">  // return (a+b)/2.0;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">/* add */</a>
<a name="ln810">static void _blend_add(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln811">{</a>
<a name="ln812">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln813">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln814"> </a>
<a name="ln815">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln816">  {</a>
<a name="ln817">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln818">    {</a>
<a name="ln819">      float local_opacity = mask[i];</a>
<a name="ln820">      float ta[3], tb[3];</a>
<a name="ln821">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln822">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln823"> </a>
<a name="ln824">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + (((ta[0] + tb[0])) * local_opacity), min[0],</a>
<a name="ln825">                          max[0]);</a>
<a name="ln826"> </a>
<a name="ln827">      if(flag == 0)</a>
<a name="ln828">      {</a>
<a name="ln829">        tb[1] = CLAMP_RANGE((ta[1] * (1.0f - local_opacity)) + (((ta[1] + tb[1])) * local_opacity), min[1],</a>
<a name="ln830">                            max[1]);</a>
<a name="ln831">        tb[2] = CLAMP_RANGE((ta[2] * (1.0f - local_opacity)) + (((ta[2] + tb[2])) * local_opacity), min[2],</a>
<a name="ln832">                            max[2]);</a>
<a name="ln833">      }</a>
<a name="ln834">      else</a>
<a name="ln835">      {</a>
<a name="ln836">        tb[1] = ta[1];</a>
<a name="ln837">        tb[2] = ta[2];</a>
<a name="ln838">      }</a>
<a name="ln839"> </a>
<a name="ln840">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln841">      b[j + 3] = local_opacity;</a>
<a name="ln842">    }</a>
<a name="ln843">  }</a>
<a name="ln844">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln845">  {</a>
<a name="ln846">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln847">    {</a>
<a name="ln848">      float local_opacity = mask[i];</a>
<a name="ln849">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln850">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln851">            (a[j + k] * (1.0f - local_opacity)) + (((a[j + k] + b[j + k])) * local_opacity), min[k], max[k]);</a>
<a name="ln852">      b[j + 3] = local_opacity;</a>
<a name="ln853">    }</a>
<a name="ln854">  }</a>
<a name="ln855">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln856">  {</a>
<a name="ln857">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln858">    {</a>
<a name="ln859">      float local_opacity = mask[i];</a>
<a name="ln860">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln861">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln862">            (a[j + k] * (1.0f - local_opacity)) + (((a[j + k] + b[j + k])) * local_opacity), min[k], max[k]);</a>
<a name="ln863">    }</a>
<a name="ln864">  }</a>
<a name="ln865">  /*</a>
<a name="ln866">  float max,min;</a>
<a name="ln867">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln868">  return CLAMP_RANGE(a+b,min,max);</a>
<a name="ln869">  */</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">/* substract */</a>
<a name="ln873">static void _blend_substract(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln874">                             int flag)</a>
<a name="ln875">{</a>
<a name="ln876">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln877">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln878"> </a>
<a name="ln879">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln880">  {</a>
<a name="ln881">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln882">    {</a>
<a name="ln883">      float local_opacity = mask[i];</a>
<a name="ln884">      float ta[3], tb[3];</a>
<a name="ln885">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln886">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln887"> </a>
<a name="ln888">      tb[0] = CLAMP_RANGE(</a>
<a name="ln889">          ((ta[0] * (1.0f - local_opacity)) + (((tb[0] + ta[0]) - (fabsf(min[0] + max[0]))) * local_opacity)),</a>
<a name="ln890">          min[0], max[0]);</a>
<a name="ln891"> </a>
<a name="ln892">      if(flag == 0)</a>
<a name="ln893">      {</a>
<a name="ln894">        tb[1] = CLAMP_RANGE(</a>
<a name="ln895">            ((ta[1] * (1.0f - local_opacity)) + (((tb[1] + ta[1]) - (fabsf(min[1] + max[1]))) * local_opacity)),</a>
<a name="ln896">            min[1], max[1]);</a>
<a name="ln897">        tb[2] = CLAMP_RANGE(</a>
<a name="ln898">            ((ta[2] * (1.0f - local_opacity)) + (((tb[2] + ta[2]) - (fabsf(min[2] + max[2]))) * local_opacity)),</a>
<a name="ln899">            min[2], max[2]);</a>
<a name="ln900">      }</a>
<a name="ln901">      else</a>
<a name="ln902">      {</a>
<a name="ln903">        tb[1] = ta[1];</a>
<a name="ln904">        tb[2] = ta[2];</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln908">      b[j + 3] = local_opacity;</a>
<a name="ln909">    }</a>
<a name="ln910">  }</a>
<a name="ln911">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln912">  {</a>
<a name="ln913">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln914">    {</a>
<a name="ln915">      float local_opacity = mask[i];</a>
<a name="ln916">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln917">        b[j + k] = CLAMP_RANGE(((a[j + k] * (1.0f - local_opacity))</a>
<a name="ln918">                                + (((b[j + k] + a[j + k]) - (fabsf(min[k] + max[k]))) * local_opacity)),</a>
<a name="ln919">                               min[k], max[k]);</a>
<a name="ln920">      b[j + 3] = local_opacity;</a>
<a name="ln921">    }</a>
<a name="ln922">  }</a>
<a name="ln923">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln924">  {</a>
<a name="ln925">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln926">    {</a>
<a name="ln927">      float local_opacity = mask[i];</a>
<a name="ln928">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln929">        b[j + k] = CLAMP_RANGE(((a[j + k] * (1.0f - local_opacity))</a>
<a name="ln930">                                + (((b[j + k] + a[j + k]) - (fabsf(min[k] + max[k]))) * local_opacity)),</a>
<a name="ln931">                               min[k], max[k]);</a>
<a name="ln932">    }</a>
<a name="ln933">  }</a>
<a name="ln934">  /*</a>
<a name="ln935">  float max,min;</a>
<a name="ln936">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln937">  return ((a+b&lt;max) ? 0:(b+a-max));</a>
<a name="ln938">  */</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">/* difference (deprecated) */</a>
<a name="ln942">static void _blend_difference(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln943">                              int flag)</a>
<a name="ln944">{</a>
<a name="ln945">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln946">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln947"> </a>
<a name="ln948">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln949">  {</a>
<a name="ln950">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln951">    {</a>
<a name="ln952">      float local_opacity = mask[i];</a>
<a name="ln953">      float ta[3], tb[3];</a>
<a name="ln954">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln955">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln956">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln957">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln958">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln959">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln960"> </a>
<a name="ln961">      tb[0] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln962">              - fabsf(min[0]);</a>
<a name="ln963"> </a>
<a name="ln964">      if(flag == 0)</a>
<a name="ln965">      {</a>
<a name="ln966">        lmax = max[1] + fabsf(min[1]);</a>
<a name="ln967">        la = CLAMP_RANGE(ta[1] + fabsf(min[1]), lmin, lmax);</a>
<a name="ln968">        lb = CLAMP_RANGE(tb[1] + fabsf(min[1]), lmin, lmax);</a>
<a name="ln969">        tb[1] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln970">                - fabsf(min[1]);</a>
<a name="ln971">        lmax = max[2] + fabsf(min[2]);</a>
<a name="ln972">        la = CLAMP_RANGE(ta[2] + fabsf(min[2]), lmin, lmax);</a>
<a name="ln973">        lb = CLAMP_RANGE(tb[2] + fabsf(min[2]), lmin, lmax);</a>
<a name="ln974">        tb[2] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln975">                - fabsf(min[2]);</a>
<a name="ln976">      }</a>
<a name="ln977">      else</a>
<a name="ln978">      {</a>
<a name="ln979">        tb[1] = ta[1];</a>
<a name="ln980">        tb[2] = ta[2];</a>
<a name="ln981">      }</a>
<a name="ln982"> </a>
<a name="ln983">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln984">      b[j + 3] = local_opacity;</a>
<a name="ln985">    }</a>
<a name="ln986">  }</a>
<a name="ln987">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln988">  {</a>
<a name="ln989">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln990">    {</a>
<a name="ln991">      float local_opacity = mask[i];</a>
<a name="ln992">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln993">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln994">      {</a>
<a name="ln995">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln996">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln997">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln998"> </a>
<a name="ln999">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1000">                   - fabsf(min[k]);</a>
<a name="ln1001">      }</a>
<a name="ln1002">      b[j + 3] = local_opacity;</a>
<a name="ln1003">    }</a>
<a name="ln1004">  }</a>
<a name="ln1005">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1006">  {</a>
<a name="ln1007">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1008">    {</a>
<a name="ln1009">      float local_opacity = mask[i];</a>
<a name="ln1010">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1011">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1012">      {</a>
<a name="ln1013">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1014">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1015">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1016"> </a>
<a name="ln1017">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1018">                   - fabsf(min[k]);</a>
<a name="ln1019">      }</a>
<a name="ln1020">    }</a>
<a name="ln1021">  }</a>
<a name="ln1022">  // return fabsf(a-b);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">/* difference 2 (new) */</a>
<a name="ln1026">static void _blend_difference2(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1027">                               int flag)</a>
<a name="ln1028">{</a>
<a name="ln1029">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1030">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1031"> </a>
<a name="ln1032">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1033">  {</a>
<a name="ln1034">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1035">    {</a>
<a name="ln1036">      float local_opacity = mask[i];</a>
<a name="ln1037">      float ta[3], tb[3];</a>
<a name="ln1038">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1039">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1040"> </a>
<a name="ln1041">      tb[0] = fabsf(ta[0] - tb[0]) / fabsf(max[0] - min[0]);</a>
<a name="ln1042">      tb[1] = fabsf(ta[1] - tb[1]) / fabsf(max[1] - min[1]);</a>
<a name="ln1043">      tb[2] = fabsf(ta[2] - tb[2]) / fabsf(max[2] - min[2]);</a>
<a name="ln1044">      tb[0] = fmaxf(tb[0], fmaxf(tb[1], tb[2]));</a>
<a name="ln1045"> </a>
<a name="ln1046">      tb[0] = CLAMP_RANGE(ta[0] * (1.0f - local_opacity) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln1047"> </a>
<a name="ln1048">      if(flag == 0)</a>
<a name="ln1049">      {</a>
<a name="ln1050">        tb[1] = 0.0f;</a>
<a name="ln1051">        tb[2] = 0.0f;</a>
<a name="ln1052">      }</a>
<a name="ln1053">      else</a>
<a name="ln1054">      {</a>
<a name="ln1055">        tb[1] = ta[1];</a>
<a name="ln1056">        tb[2] = ta[2];</a>
<a name="ln1057">      }</a>
<a name="ln1058"> </a>
<a name="ln1059">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1060">      b[j + 3] = local_opacity;</a>
<a name="ln1061">    }</a>
<a name="ln1062">  }</a>
<a name="ln1063">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1064">  {</a>
<a name="ln1065">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1066">    {</a>
<a name="ln1067">      float local_opacity = mask[i];</a>
<a name="ln1068">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1069">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1070">      {</a>
<a name="ln1071">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1072">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1073">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1074"> </a>
<a name="ln1075">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1076">                   - fabsf(min[k]);</a>
<a name="ln1077">      }</a>
<a name="ln1078"> </a>
<a name="ln1079">      b[j + 3] = local_opacity;</a>
<a name="ln1080">    }</a>
<a name="ln1081">  }</a>
<a name="ln1082">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1083">  {</a>
<a name="ln1084">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1085">    {</a>
<a name="ln1086">      float local_opacity = mask[i];</a>
<a name="ln1087">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1088">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1089">      {</a>
<a name="ln1090">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1091">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1092">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1093"> </a>
<a name="ln1094">        b[j + k] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (fabsf(la - lb) * local_opacity), lmin, lmax)</a>
<a name="ln1095">                   - fabsf(min[k]);</a>
<a name="ln1096">      }</a>
<a name="ln1097">    }</a>
<a name="ln1098">  }</a>
<a name="ln1099">  // return fabsf(a-b);</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">/* screen */</a>
<a name="ln1103">static void _blend_screen(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1104">                          int flag)</a>
<a name="ln1105">{</a>
<a name="ln1106">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1107">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1108"> </a>
<a name="ln1109">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1110">  {</a>
<a name="ln1111">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1112">    {</a>
<a name="ln1113">      float local_opacity = mask[i];</a>
<a name="ln1114">      float ta[3], tb[3];</a>
<a name="ln1115">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1116">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1117">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1118">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1119">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1120">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1121"> </a>
<a name="ln1122">      tb[0] = CLAMP_RANGE((la * (1.0f - local_opacity)) + (((lmax - (lmax - la) * (lmax - lb))) * local_opacity),</a>
<a name="ln1123">                          lmin, lmax)</a>
<a name="ln1124">              - fabsf(min[0]);</a>
<a name="ln1125"> </a>
<a name="ln1126">      if(flag == 0)</a>
<a name="ln1127">      {</a>
<a name="ln1128">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1129">        {</a>
<a name="ln1130">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity)</a>
<a name="ln1131">                              + 0.5f * (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln1132">                              min[1], max[1]);</a>
<a name="ln1133">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity)</a>
<a name="ln1134">                              + 0.5f * (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity,</a>
<a name="ln1135">                              min[2], max[2]);</a>
<a name="ln1136">        }</a>
<a name="ln1137">        else</a>
<a name="ln1138">        {</a>
<a name="ln1139">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity)</a>
<a name="ln1140">                              + 0.5f * (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln1141">                              min[1], max[1]);</a>
<a name="ln1142">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity)</a>
<a name="ln1143">                              + 0.5f * (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity,</a>
<a name="ln1144">                              min[2], max[2]);</a>
<a name="ln1145">        }</a>
<a name="ln1146">      }</a>
<a name="ln1147">      else</a>
<a name="ln1148">      {</a>
<a name="ln1149">        tb[1] = ta[1];</a>
<a name="ln1150">        tb[2] = ta[2];</a>
<a name="ln1151">      }</a>
<a name="ln1152"> </a>
<a name="ln1153">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1154">      b[j + 3] = local_opacity;</a>
<a name="ln1155">    }</a>
<a name="ln1156">  }</a>
<a name="ln1157">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1158">  {</a>
<a name="ln1159">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1160">    {</a>
<a name="ln1161">      float local_opacity = mask[i];</a>
<a name="ln1162">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1163">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1164">      {</a>
<a name="ln1165">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1166">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1167">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1168"> </a>
<a name="ln1169">        b[j + k]</a>
<a name="ln1170">            = CLAMP_RANGE((la * (1.0f - local_opacity)) + (((lmax - (lmax - la) * (lmax - lb))) * local_opacity),</a>
<a name="ln1171">                          lmin, lmax)</a>
<a name="ln1172">              - fabsf(min[k]);</a>
<a name="ln1173">      }</a>
<a name="ln1174">      b[j + 3] = local_opacity;</a>
<a name="ln1175">    }</a>
<a name="ln1176">  }</a>
<a name="ln1177">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1178">  {</a>
<a name="ln1179">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1180">    {</a>
<a name="ln1181">      float local_opacity = mask[i];</a>
<a name="ln1182">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1183">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1184">      {</a>
<a name="ln1185">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1186">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1187">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1188"> </a>
<a name="ln1189">        b[j + k]</a>
<a name="ln1190">            = CLAMP_RANGE((la * (1.0f - local_opacity)) + (((lmax - (lmax - la) * (lmax - lb))) * local_opacity),</a>
<a name="ln1191">                          lmin, lmax)</a>
<a name="ln1192">              - fabsf(min[k]);</a>
<a name="ln1193">      }</a>
<a name="ln1194">    }</a>
<a name="ln1195">  }</a>
<a name="ln1196">  /*</a>
<a name="ln1197">  float max,min;</a>
<a name="ln1198">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1199">  return max - (max-a) * (max-b);</a>
<a name="ln1200">  */</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">/* overlay */</a>
<a name="ln1204">static void _blend_overlay(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1205">                           int flag)</a>
<a name="ln1206">{</a>
<a name="ln1207">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1208">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1209"> </a>
<a name="ln1210">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1211">  {</a>
<a name="ln1212">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1213">    {</a>
<a name="ln1214">      float local_opacity = mask[i];</a>
<a name="ln1215">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1216">      float ta[3], tb[3];</a>
<a name="ln1217">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1218">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1219">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1220">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1221">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1222">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1223">      halfmax = lmax / 2.0f;</a>
<a name="ln1224">      doublemax = lmax * 2.0f;</a>
<a name="ln1225"> </a>
<a name="ln1226">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1227">                           + ((la &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1228">                                             : ((doublemax * la) * lb))</a>
<a name="ln1229">                                 * local_opacity2),</a>
<a name="ln1230">                          lmin, lmax)</a>
<a name="ln1231">              - fabsf(min[0]);</a>
<a name="ln1232"> </a>
<a name="ln1233">      if(flag == 0)</a>
<a name="ln1234">      {</a>
<a name="ln1235">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1236">        {</a>
<a name="ln1237">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1238">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1239">                              min[1], max[1]);</a>
<a name="ln1240">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1241">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1242">                              min[2], max[2]);</a>
<a name="ln1243">        }</a>
<a name="ln1244">        else</a>
<a name="ln1245">        {</a>
<a name="ln1246">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1247">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1248">                              min[1], max[1]);</a>
<a name="ln1249">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1250">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1251">                              min[2], max[2]);</a>
<a name="ln1252">        }</a>
<a name="ln1253">      }</a>
<a name="ln1254">      else</a>
<a name="ln1255">      {</a>
<a name="ln1256">        tb[1] = ta[1];</a>
<a name="ln1257">        tb[2] = ta[2];</a>
<a name="ln1258">      }</a>
<a name="ln1259"> </a>
<a name="ln1260">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1261">      b[j + 3] = local_opacity;</a>
<a name="ln1262">    }</a>
<a name="ln1263">  }</a>
<a name="ln1264">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1265">  {</a>
<a name="ln1266">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1267">    {</a>
<a name="ln1268">      float local_opacity = mask[i];</a>
<a name="ln1269">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1270">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1271">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1272">      {</a>
<a name="ln1273">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1274">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1275">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1276">        halfmax = lmax / 2.0f;</a>
<a name="ln1277">        doublemax = lmax * 2.0f;</a>
<a name="ln1278"> </a>
<a name="ln1279">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1280">                                + ((la &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1281">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1282">                                      * local_opacity2),</a>
<a name="ln1283">                               lmin, lmax)</a>
<a name="ln1284">                   - fabsf(min[k]);</a>
<a name="ln1285">      }</a>
<a name="ln1286">      b[j + 3] = local_opacity;</a>
<a name="ln1287">    }</a>
<a name="ln1288">  }</a>
<a name="ln1289">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1290">  {</a>
<a name="ln1291">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1292">    {</a>
<a name="ln1293">      float local_opacity = mask[i];</a>
<a name="ln1294">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1295">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1296">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1297">      {</a>
<a name="ln1298">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1299">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1300">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1301">        halfmax = lmax / 2.0f;</a>
<a name="ln1302">        doublemax = lmax * 2.0f;</a>
<a name="ln1303"> </a>
<a name="ln1304">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1305">                                + ((la &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1306">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1307">                                      * local_opacity2),</a>
<a name="ln1308">                               lmin, lmax)</a>
<a name="ln1309">                   - fabsf(min[k]);</a>
<a name="ln1310">      }</a>
<a name="ln1311">    }</a>
<a name="ln1312">  }</a>
<a name="ln1313">  /*</a>
<a name="ln1314">    float max,min;</a>
<a name="ln1315">    _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1316">    const float halfmax=max/2.0;</a>
<a name="ln1317">    const float doublemax=max*2.0;</a>
<a name="ln1318">    return (a&gt;halfmax) ? max - (max - doublemax*(a-halfmax)) * (max-b) :</a>
<a name="ln1319">    (doublemax*a) * b;</a>
<a name="ln1320">    */</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323">/* softlight */</a>
<a name="ln1324">static void _blend_softlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1325">                             int flag)</a>
<a name="ln1326">{</a>
<a name="ln1327"> </a>
<a name="ln1328">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1329">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1330"> </a>
<a name="ln1331">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1332">  {</a>
<a name="ln1333">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1334">    {</a>
<a name="ln1335">      float local_opacity = mask[i];</a>
<a name="ln1336">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1337">      float ta[3], tb[3];</a>
<a name="ln1338">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1339">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1340">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1341">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1342">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1343">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1344">      halfmax = lmax / 2.0f;</a>
<a name="ln1345"> </a>
<a name="ln1346">      tb[0] = CLAMP_RANGE(</a>
<a name="ln1347">                  ((la * (1.0f - local_opacity2))</a>
<a name="ln1348">                   + ((lb &gt; halfmax) ? (lmax - (lmax - la) * (lmax - (lb - halfmax))) : (la * (lb + halfmax)))</a>
<a name="ln1349">                         * local_opacity2),</a>
<a name="ln1350">                  lmin, lmax)</a>
<a name="ln1351">              - fabsf(min[0]);</a>
<a name="ln1352"> </a>
<a name="ln1353">      if(flag == 0)</a>
<a name="ln1354">      {</a>
<a name="ln1355">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1356">        {</a>
<a name="ln1357">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1358">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1359">                              min[1], max[1]);</a>
<a name="ln1360">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1361">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1362">                              min[2], max[2]);</a>
<a name="ln1363">        }</a>
<a name="ln1364">        else</a>
<a name="ln1365">        {</a>
<a name="ln1366">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1367">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1368">                              min[1], max[1]);</a>
<a name="ln1369">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1370">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1371">                              min[2], max[2]);</a>
<a name="ln1372">        }</a>
<a name="ln1373">      }</a>
<a name="ln1374">      else</a>
<a name="ln1375">      {</a>
<a name="ln1376">        tb[1] = ta[1];</a>
<a name="ln1377">        tb[2] = ta[2];</a>
<a name="ln1378">      }</a>
<a name="ln1379"> </a>
<a name="ln1380">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1381">      b[j + 3] = local_opacity;</a>
<a name="ln1382">    }</a>
<a name="ln1383">  }</a>
<a name="ln1384">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1385">  {</a>
<a name="ln1386">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1387">    {</a>
<a name="ln1388">      float local_opacity = mask[i];</a>
<a name="ln1389">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1390">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1391">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1392">      {</a>
<a name="ln1393">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1394">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1395">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1396">        halfmax = lmax / 2.0f;</a>
<a name="ln1397"> </a>
<a name="ln1398">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1399">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1400">                        + ((lb &gt; halfmax) ? (lmax - (lmax - la) * (lmax - (lb - halfmax))) : (la * (lb + halfmax)))</a>
<a name="ln1401">                              * local_opacity2),</a>
<a name="ln1402">                       lmin, lmax)</a>
<a name="ln1403">                   - fabsf(min[k]);</a>
<a name="ln1404"> </a>
<a name="ln1405">        b[j + 3] = local_opacity;</a>
<a name="ln1406">      }</a>
<a name="ln1407">    }</a>
<a name="ln1408">  }</a>
<a name="ln1409">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1410">  {</a>
<a name="ln1411">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1412">    {</a>
<a name="ln1413">      float local_opacity = mask[i];</a>
<a name="ln1414">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1415">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1416">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1417">      {</a>
<a name="ln1418">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1419">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1420">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1421">        halfmax = lmax / 2.0f;</a>
<a name="ln1422"> </a>
<a name="ln1423">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1424">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1425">                        + ((lb &gt; halfmax) ? (lmax - (lmax - la) * (lmax - (lb - halfmax))) : (la * (lb + halfmax)))</a>
<a name="ln1426">                              * local_opacity2),</a>
<a name="ln1427">                       lmin, lmax)</a>
<a name="ln1428">                   - fabsf(min[k]);</a>
<a name="ln1429">      }</a>
<a name="ln1430">    }</a>
<a name="ln1431">  }</a>
<a name="ln1432">  /*</a>
<a name="ln1433">  float max,min;</a>
<a name="ln1434">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1435">  const float halfmax=max/2.0;</a>
<a name="ln1436">  return (b&gt;halfmax) ? max - (max-a) * (max - (b-halfmax)) : a * (b+halfmax);</a>
<a name="ln1437">  */</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440">/* hardlight */</a>
<a name="ln1441">static void _blend_hardlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1442">                             int flag)</a>
<a name="ln1443">{</a>
<a name="ln1444">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1445">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1446"> </a>
<a name="ln1447">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1448">  {</a>
<a name="ln1449">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1450">    {</a>
<a name="ln1451">      float local_opacity = mask[i];</a>
<a name="ln1452">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1453">      float ta[3], tb[3];</a>
<a name="ln1454">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1455">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1456">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1457">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1458">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1459">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1460">      halfmax = lmax / 2.0f;</a>
<a name="ln1461">      doublemax = lmax * 2.0f;</a>
<a name="ln1462"> </a>
<a name="ln1463">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1464">                           + ((lb &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1465">                                             : ((doublemax * la) * lb))</a>
<a name="ln1466">                                 * local_opacity2),</a>
<a name="ln1467">                          lmin, lmax)</a>
<a name="ln1468">              - fabsf(min[0]);</a>
<a name="ln1469"> </a>
<a name="ln1470">      if(flag == 0)</a>
<a name="ln1471">      {</a>
<a name="ln1472">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1473">        {</a>
<a name="ln1474">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1475">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1476">                              min[1], max[1]);</a>
<a name="ln1477">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1478">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1479">                              min[2], max[2]);</a>
<a name="ln1480">        }</a>
<a name="ln1481">        else</a>
<a name="ln1482">        {</a>
<a name="ln1483">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1484">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1485">                              min[1], max[1]);</a>
<a name="ln1486">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1487">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1488">                              min[2], max[2]);</a>
<a name="ln1489">        }</a>
<a name="ln1490">      }</a>
<a name="ln1491">      else</a>
<a name="ln1492">      {</a>
<a name="ln1493">        tb[1] = ta[1];</a>
<a name="ln1494">        tb[2] = ta[2];</a>
<a name="ln1495">      }</a>
<a name="ln1496"> </a>
<a name="ln1497">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1498">      b[j + 3] = local_opacity;</a>
<a name="ln1499">    }</a>
<a name="ln1500">  }</a>
<a name="ln1501">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1502">  {</a>
<a name="ln1503">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1504">    {</a>
<a name="ln1505">      float local_opacity = mask[i];</a>
<a name="ln1506">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1507">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1508">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1509">      {</a>
<a name="ln1510">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1511">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1512">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1513">        halfmax = lmax / 2.0f;</a>
<a name="ln1514">        doublemax = lmax * 2.0f;</a>
<a name="ln1515"> </a>
<a name="ln1516">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1517">                                + ((lb &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1518">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1519">                                      * local_opacity2),</a>
<a name="ln1520">                               lmin, lmax)</a>
<a name="ln1521">                   - fabsf(min[k]);</a>
<a name="ln1522">      }</a>
<a name="ln1523">      b[j + 3] = local_opacity;</a>
<a name="ln1524">    }</a>
<a name="ln1525">  }</a>
<a name="ln1526">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1527">  {</a>
<a name="ln1528">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1529">    {</a>
<a name="ln1530">      float local_opacity = mask[i];</a>
<a name="ln1531">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1532">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1533">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1534">      {</a>
<a name="ln1535">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1536">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1537">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1538">        halfmax = lmax / 2.0f;</a>
<a name="ln1539">        doublemax = lmax * 2.0f;</a>
<a name="ln1540"> </a>
<a name="ln1541">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1542">                                + ((lb &gt; halfmax) ? (lmax - (lmax - doublemax * (la - halfmax)) * (lmax - lb))</a>
<a name="ln1543">                                                  : ((doublemax * la) * lb))</a>
<a name="ln1544">                                      * local_opacity2),</a>
<a name="ln1545">                               lmin, lmax)</a>
<a name="ln1546">                   - fabsf(min[k]);</a>
<a name="ln1547">      }</a>
<a name="ln1548">    }</a>
<a name="ln1549">  }</a>
<a name="ln1550">  /*</a>
<a name="ln1551">  float max,min;</a>
<a name="ln1552">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1553">  const float halfmax=max/2.0;</a>
<a name="ln1554">  const float doublemax=max*2.0;</a>
<a name="ln1555">  return (b&gt;halfmax) ? max - (max - doublemax*(a-halfmax)) * (max-b) :</a>
<a name="ln1556">  (doublemax*a) * b;</a>
<a name="ln1557">  */</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560">/* vividlight */</a>
<a name="ln1561">static void _blend_vividlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1562">                              int flag)</a>
<a name="ln1563">{</a>
<a name="ln1564">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1565">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1566"> </a>
<a name="ln1567">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1568">  {</a>
<a name="ln1569">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1570">    {</a>
<a name="ln1571">      float local_opacity = mask[i];</a>
<a name="ln1572">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1573">      float ta[3], tb[3];</a>
<a name="ln1574">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1575">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1576">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1577">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1578">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1579">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1580">      halfmax = lmax / 2.0f;</a>
<a name="ln1581">      doublemax = lmax * 2.0f;</a>
<a name="ln1582"> </a>
<a name="ln1583">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1584">                           + ((lb &gt; halfmax) ? (lb &gt;= lmax ? lmax : la / (doublemax * (lmax - lb)))</a>
<a name="ln1585">                                             : (lb &lt;= lmin ? lmin : lmax - (lmax - la) / (doublemax * lb)))</a>
<a name="ln1586">                                 * local_opacity2),</a>
<a name="ln1587">                          lmin, lmax)</a>
<a name="ln1588">              - fabsf(min[0]);</a>
<a name="ln1589"> </a>
<a name="ln1590">      if(flag == 0)</a>
<a name="ln1591">      {</a>
<a name="ln1592">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1593">        {</a>
<a name="ln1594">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1595">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1596">                              min[1], max[1]);</a>
<a name="ln1597">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1598">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1599">                              min[2], max[2]);</a>
<a name="ln1600">        }</a>
<a name="ln1601">        else</a>
<a name="ln1602">        {</a>
<a name="ln1603">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1604">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1605">                              min[1], max[1]);</a>
<a name="ln1606">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1607">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1608">                              min[2], max[2]);</a>
<a name="ln1609">        }</a>
<a name="ln1610">      }</a>
<a name="ln1611">      else</a>
<a name="ln1612">      {</a>
<a name="ln1613">        tb[1] = ta[1];</a>
<a name="ln1614">        tb[2] = ta[2];</a>
<a name="ln1615">      }</a>
<a name="ln1616"> </a>
<a name="ln1617">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1618">      b[j + 3] = local_opacity;</a>
<a name="ln1619">    }</a>
<a name="ln1620">  }</a>
<a name="ln1621">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1622">  {</a>
<a name="ln1623">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1624">    {</a>
<a name="ln1625">      float local_opacity = mask[i];</a>
<a name="ln1626">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1627">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1628">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1629">      {</a>
<a name="ln1630">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1631">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1632">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1633">        halfmax = lmax / 2.0f;</a>
<a name="ln1634">        doublemax = lmax * 2.0f;</a>
<a name="ln1635"> </a>
<a name="ln1636">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1637">                                + ((lb &gt; halfmax) ? (lb &gt;= lmax ? lmax : la / (doublemax * (lmax - lb)))</a>
<a name="ln1638">                                                  : (lb &lt;= lmin ? lmin : lmax - (lmax - la) / (doublemax * lb)))</a>
<a name="ln1639">                                      * local_opacity2),</a>
<a name="ln1640">                               lmin, lmax)</a>
<a name="ln1641">                   - fabsf(min[k]);</a>
<a name="ln1642">      }</a>
<a name="ln1643">      b[j + 3] = local_opacity;</a>
<a name="ln1644">    }</a>
<a name="ln1645">  }</a>
<a name="ln1646">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1647">  {</a>
<a name="ln1648">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1649">    {</a>
<a name="ln1650">      float local_opacity = mask[i];</a>
<a name="ln1651">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1652">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1653">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1654">      {</a>
<a name="ln1655">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1656">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1657">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1658">        halfmax = lmax / 2.0f;</a>
<a name="ln1659">        doublemax = lmax * 2.0f;</a>
<a name="ln1660"> </a>
<a name="ln1661">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1662">                                + ((lb &gt; halfmax) ? (lb &gt;= lmax ? lmax : la / (doublemax * (lmax - lb)))</a>
<a name="ln1663">                                                  : (lb &lt;= lmin ? lmin : lmax - (lmax - la) / (doublemax * lb)))</a>
<a name="ln1664">                                      * local_opacity2),</a>
<a name="ln1665">                               lmin, lmax)</a>
<a name="ln1666">                   - fabsf(min[k]);</a>
<a name="ln1667">      }</a>
<a name="ln1668">    }</a>
<a name="ln1669">  }</a>
<a name="ln1670">  /*</a>
<a name="ln1671">  float max,min;</a>
<a name="ln1672">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1673">  const float halfmax=max/2.0;</a>
<a name="ln1674">  const float doublemax=max*2.0;</a>
<a name="ln1675">  return (b&gt;halfmax) ? a / (doublemax*(max-b)) : max - (max-a) / (doublemax*b);</a>
<a name="ln1676">  */</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679">/* linearlight */</a>
<a name="ln1680">static void _blend_linearlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1681">                               int flag)</a>
<a name="ln1682">{</a>
<a name="ln1683">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1684">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1685"> </a>
<a name="ln1686">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1687">  {</a>
<a name="ln1688">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1689">    {</a>
<a name="ln1690">      float local_opacity = mask[i];</a>
<a name="ln1691">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1692">      float ta[3], tb[3];</a>
<a name="ln1693">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1694">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1695">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1696">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1697">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1698">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1699">      doublemax = lmax * 2.0f;</a>
<a name="ln1700"> </a>
<a name="ln1701">      tb[0] = CLAMP_RANGE(((la * (1.0f - local_opacity2)) + (la + doublemax * lb - lmax) * local_opacity2), lmin,</a>
<a name="ln1702">                          lmax)</a>
<a name="ln1703">              - fabsf(min[0]);</a>
<a name="ln1704"> </a>
<a name="ln1705">      if(flag == 0)</a>
<a name="ln1706">      {</a>
<a name="ln1707">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1708">        {</a>
<a name="ln1709">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1710">                              + (ta[1] + tb[1]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1711">                              min[1], max[1]);</a>
<a name="ln1712">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1713">                              + (ta[2] + tb[2]) * tb[0] / ta[0] * local_opacity2,</a>
<a name="ln1714">                              min[2], max[2]);</a>
<a name="ln1715">        }</a>
<a name="ln1716">        else</a>
<a name="ln1717">        {</a>
<a name="ln1718">          tb[1] = CLAMP_RANGE(ta[1] * (1.0f - local_opacity2)</a>
<a name="ln1719">                              + (ta[1] + tb[1]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1720">                              min[1], max[1]);</a>
<a name="ln1721">          tb[2] = CLAMP_RANGE(ta[2] * (1.0f - local_opacity2)</a>
<a name="ln1722">                              + (ta[2] + tb[2]) * tb[0] / 0.01f * local_opacity2,</a>
<a name="ln1723">                              min[2], max[2]);</a>
<a name="ln1724">        }</a>
<a name="ln1725">      }</a>
<a name="ln1726">      else</a>
<a name="ln1727">      {</a>
<a name="ln1728">        tb[1] = ta[1];</a>
<a name="ln1729">        tb[2] = ta[2];</a>
<a name="ln1730">      }</a>
<a name="ln1731"> </a>
<a name="ln1732">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1733">      b[j + 3] = local_opacity;</a>
<a name="ln1734">    }</a>
<a name="ln1735">  }</a>
<a name="ln1736">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1737">  {</a>
<a name="ln1738">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1739">    {</a>
<a name="ln1740">      float local_opacity = mask[i];</a>
<a name="ln1741">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1742">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1743">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1744">      {</a>
<a name="ln1745">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1746">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1747">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1748">        doublemax = lmax * 2.0f;</a>
<a name="ln1749"> </a>
<a name="ln1750">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2)) + (la + doublemax * lb - lmax) * local_opacity2),</a>
<a name="ln1751">                               lmin, lmax)</a>
<a name="ln1752">                   - fabsf(min[k]);</a>
<a name="ln1753">      }</a>
<a name="ln1754">      b[j + 3] = local_opacity;</a>
<a name="ln1755">    }</a>
<a name="ln1756">  }</a>
<a name="ln1757">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1758">  {</a>
<a name="ln1759">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1760">    {</a>
<a name="ln1761">      float local_opacity = mask[i];</a>
<a name="ln1762">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1763">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1764">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1765">      {</a>
<a name="ln1766">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1767">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1768">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1769">        doublemax = lmax * 2.0f;</a>
<a name="ln1770"> </a>
<a name="ln1771">        b[j + k] = CLAMP_RANGE(((la * (1.0f - local_opacity2)) + (la + doublemax * lb - lmax) * local_opacity2),</a>
<a name="ln1772">                               lmin, lmax)</a>
<a name="ln1773">                   - fabsf(min[k]);</a>
<a name="ln1774">      }</a>
<a name="ln1775">    }</a>
<a name="ln1776">  }</a>
<a name="ln1777">  /*</a>
<a name="ln1778">  float max,min;</a>
<a name="ln1779">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1780">  const float halfmax=max/2.0;</a>
<a name="ln1781">  const float doublemax=max*2.0;</a>
<a name="ln1782">  return a +doublemax*b-max;</a>
<a name="ln1783">  */</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">/* pinlight */</a>
<a name="ln1787">static void _blend_pinlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1788">                            int flag)</a>
<a name="ln1789">{</a>
<a name="ln1790">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1791">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1792"> </a>
<a name="ln1793">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1794">  {</a>
<a name="ln1795">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1796">    {</a>
<a name="ln1797">      float local_opacity = mask[i];</a>
<a name="ln1798">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1799">      float ta[3], tb[3];</a>
<a name="ln1800">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1801">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1802">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1803">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1804">      la = CLAMP_RANGE(ta[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1805">      lb = CLAMP_RANGE(tb[0] + fabsf(min[0]), lmin, lmax);</a>
<a name="ln1806">      halfmax = lmax / 2.0f;</a>
<a name="ln1807">      doublemax = lmax * 2.0f;</a>
<a name="ln1808"> </a>
<a name="ln1809">      tb[0]</a>
<a name="ln1810">          = CLAMP_RANGE(((la * (1.0f - local_opacity2))</a>
<a name="ln1811">                         + ((lb &gt; halfmax) ? (fmaxf(la, doublemax * (lb - halfmax))) : (fminf(la, doublemax * lb)))</a>
<a name="ln1812">                               * local_opacity2),</a>
<a name="ln1813">                        lmin, lmax)</a>
<a name="ln1814">            - fabsf(min[0]);</a>
<a name="ln1815"> </a>
<a name="ln1816">      tb[1] = CLAMP_RANGE(ta[1], min[1], max[1]);</a>
<a name="ln1817">      tb[2] = CLAMP_RANGE(ta[2], min[2], max[2]);</a>
<a name="ln1818"> </a>
<a name="ln1819">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1820">      b[j + 3] = local_opacity;</a>
<a name="ln1821">    }</a>
<a name="ln1822">  }</a>
<a name="ln1823">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1824">  {</a>
<a name="ln1825">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1826">    {</a>
<a name="ln1827">      float local_opacity = mask[i];</a>
<a name="ln1828">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1829">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1830">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1831">      {</a>
<a name="ln1832">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1833">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1834">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1835">        halfmax = lmax / 2.0f;</a>
<a name="ln1836">        doublemax = lmax * 2.0f;</a>
<a name="ln1837"> </a>
<a name="ln1838">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1839">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1840">                        + ((lb &gt; halfmax) ? (fmaxf(la, doublemax * (lb - halfmax))) : (fminf(la, doublemax * lb)))</a>
<a name="ln1841">                              * local_opacity2),</a>
<a name="ln1842">                       lmin, lmax)</a>
<a name="ln1843">                   - fabsf(min[k]);</a>
<a name="ln1844">      }</a>
<a name="ln1845">      b[j + 3] = local_opacity;</a>
<a name="ln1846">    }</a>
<a name="ln1847">  }</a>
<a name="ln1848">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1849">  {</a>
<a name="ln1850">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1851">    {</a>
<a name="ln1852">      float local_opacity = mask[i];</a>
<a name="ln1853">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1854">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1855">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1856">      {</a>
<a name="ln1857">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1858">        la = CLAMP_RANGE(a[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1859">        lb = CLAMP_RANGE(b[j + k] + fabsf(min[k]), lmin, lmax);</a>
<a name="ln1860">        halfmax = lmax / 2.0f;</a>
<a name="ln1861">        doublemax = lmax * 2.0f;</a>
<a name="ln1862"> </a>
<a name="ln1863">        b[j + k] = CLAMP_RANGE(</a>
<a name="ln1864">                       ((la * (1.0f - local_opacity2))</a>
<a name="ln1865">                        + ((lb &gt; halfmax) ? (fmaxf(la, doublemax * (lb - halfmax))) : (fminf(la, doublemax * lb)))</a>
<a name="ln1866">                              * local_opacity2),</a>
<a name="ln1867">                       lmin, lmax)</a>
<a name="ln1868">                   - fabsf(min[k]);</a>
<a name="ln1869">      }</a>
<a name="ln1870">    }</a>
<a name="ln1871">  }</a>
<a name="ln1872">  /*</a>
<a name="ln1873">  float max,min;</a>
<a name="ln1874">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1875">  const float halfmax=max/2.0;</a>
<a name="ln1876">  const float doublemax=max*2.0;</a>
<a name="ln1877">  return (b&gt;halfmax) ? fmaxf(a,doublemax*(b-halfmax)) : fminf(a,doublemax*b);</a>
<a name="ln1878">  */</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">/* lightness blend */</a>
<a name="ln1882">static void _blend_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1883">                             int flag)</a>
<a name="ln1884">{</a>
<a name="ln1885">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1886">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1887"> </a>
<a name="ln1888">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1889">  {</a>
<a name="ln1890">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1891">    {</a>
<a name="ln1892">      float local_opacity = mask[i];</a>
<a name="ln1893">      float ta[3], tb[3];</a>
<a name="ln1894">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1895">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1896"> </a>
<a name="ln1897">      // no need to transfer to LCH as L is the same as in Lab, and C and H</a>
<a name="ln1898">      // remain unchanged</a>
<a name="ln1899">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln1900">      tb[1] = CLAMP_RANGE(ta[1], min[1], max[1]);</a>
<a name="ln1901">      tb[2] = CLAMP_RANGE(ta[2], min[2], max[2]);</a>
<a name="ln1902"> </a>
<a name="ln1903">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1904">      b[j + 3] = local_opacity;</a>
<a name="ln1905">    }</a>
<a name="ln1906">  }</a>
<a name="ln1907">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1908">  {</a>
<a name="ln1909">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1910">    {</a>
<a name="ln1911">      float local_opacity = mask[i];</a>
<a name="ln1912">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1913">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1914"> </a>
<a name="ln1915">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1916">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1917"> </a>
<a name="ln1918">      _RGB_2_HSL(ta, tta);</a>
<a name="ln1919">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1920"> </a>
<a name="ln1921">      ttb[0] = tta[0];</a>
<a name="ln1922">      ttb[1] = tta[1];</a>
<a name="ln1923">      ttb[2] = (tta[2] * (1.0f - local_opacity)) + ttb[2] * local_opacity;</a>
<a name="ln1924"> </a>
<a name="ln1925">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1926">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1927"> </a>
<a name="ln1928">      b[j + 3] = local_opacity;</a>
<a name="ln1929">    }</a>
<a name="ln1930">  }</a>
<a name="ln1931">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1932">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln1933">}</a>
<a name="ln1934"> </a>
<a name="ln1935">/* chroma blend */</a>
<a name="ln1936">static void _blend_chroma(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1937">                          int flag)</a>
<a name="ln1938">{</a>
<a name="ln1939">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1940">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1941"> </a>
<a name="ln1942">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1943">  {</a>
<a name="ln1944">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1945">    {</a>
<a name="ln1946">      float local_opacity = mask[i];</a>
<a name="ln1947">      float ta[3], tb[3];</a>
<a name="ln1948">      float tta[3], ttb[3];</a>
<a name="ln1949">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1950">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1951">      _Lab_2_LCH(ta, tta);</a>
<a name="ln1952"> </a>
<a name="ln1953">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1954">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1955">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln1956"> </a>
<a name="ln1957">      ttb[0] = tta[0];</a>
<a name="ln1958">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln1959">      ttb[2] = tta[2];</a>
<a name="ln1960"> </a>
<a name="ln1961">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln1962">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1963">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1964"> </a>
<a name="ln1965">      b[j + 3] = local_opacity;</a>
<a name="ln1966">    }</a>
<a name="ln1967">  }</a>
<a name="ln1968">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1969">  {</a>
<a name="ln1970">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1971">    {</a>
<a name="ln1972">      float local_opacity = mask[i];</a>
<a name="ln1973">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1974">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1975"> </a>
<a name="ln1976">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1977">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1978"> </a>
<a name="ln1979">      _RGB_2_HSL(ta, tta);</a>
<a name="ln1980">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1981"> </a>
<a name="ln1982">      ttb[0] = tta[0];</a>
<a name="ln1983">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln1984">      ttb[2] = tta[2];</a>
<a name="ln1985"> </a>
<a name="ln1986">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1987">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1988"> </a>
<a name="ln1989">      b[j + 3] = local_opacity;</a>
<a name="ln1990">    }</a>
<a name="ln1991">  }</a>
<a name="ln1992">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1993">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln1994">}</a>
<a name="ln1995"> </a>
<a name="ln1996">/* hue blend */</a>
<a name="ln1997">static void _blend_hue(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln1998">{</a>
<a name="ln1999">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2000">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2001"> </a>
<a name="ln2002">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2003">  {</a>
<a name="ln2004">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2005">    {</a>
<a name="ln2006">      float local_opacity = mask[i];</a>
<a name="ln2007">      float ta[3], tb[3];</a>
<a name="ln2008">      float tta[3], ttb[3];</a>
<a name="ln2009">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2010">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2011">      _Lab_2_LCH(ta, tta);</a>
<a name="ln2012"> </a>
<a name="ln2013">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2014">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2015">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln2016"> </a>
<a name="ln2017">      ttb[0] = tta[0];</a>
<a name="ln2018">      ttb[1] = tta[1];</a>
<a name="ln2019">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2020">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2021">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2022">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2023"> </a>
<a name="ln2024">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln2025">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2026">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2027"> </a>
<a name="ln2028">      b[j + 3] = local_opacity;</a>
<a name="ln2029">    }</a>
<a name="ln2030">  }</a>
<a name="ln2031">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2032">  {</a>
<a name="ln2033">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2034">    {</a>
<a name="ln2035">      float local_opacity = mask[i];</a>
<a name="ln2036">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2037">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2038"> </a>
<a name="ln2039">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2040">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2041"> </a>
<a name="ln2042">      _RGB_2_HSL(ta, tta);</a>
<a name="ln2043">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2044"> </a>
<a name="ln2045">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2046">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2047">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2048">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2049">      ttb[1] = tta[1];</a>
<a name="ln2050">      ttb[2] = tta[2];</a>
<a name="ln2051"> </a>
<a name="ln2052">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2053">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2054"> </a>
<a name="ln2055">      b[j + 3] = local_opacity;</a>
<a name="ln2056">    }</a>
<a name="ln2057">  }</a>
<a name="ln2058">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2059">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">/* color blend; blend hue and chroma, but not lightness */</a>
<a name="ln2063">static void _blend_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln2064">{</a>
<a name="ln2065">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2066">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2067"> </a>
<a name="ln2068">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2069">  {</a>
<a name="ln2070">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2071">    {</a>
<a name="ln2072">      float local_opacity = mask[i];</a>
<a name="ln2073">      float ta[3], tb[3];</a>
<a name="ln2074">      float tta[3], ttb[3];</a>
<a name="ln2075">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2076">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2077">      _Lab_2_LCH(ta, tta);</a>
<a name="ln2078"> </a>
<a name="ln2079">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2080">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2081">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln2082"> </a>
<a name="ln2083">      ttb[0] = tta[0];</a>
<a name="ln2084">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2085"> </a>
<a name="ln2086">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2087">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2088">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2089">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2090"> </a>
<a name="ln2091">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln2092">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2093">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2094"> </a>
<a name="ln2095"> </a>
<a name="ln2096">      b[j + 3] = local_opacity;</a>
<a name="ln2097">    }</a>
<a name="ln2098">  }</a>
<a name="ln2099">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2100">  {</a>
<a name="ln2101">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2102">    {</a>
<a name="ln2103">      float local_opacity = mask[i];</a>
<a name="ln2104">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2105">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2106"> </a>
<a name="ln2107">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2108">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2109"> </a>
<a name="ln2110">      _RGB_2_HSL(ta, tta);</a>
<a name="ln2111">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2112"> </a>
<a name="ln2113">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2114">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2115">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2116">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2117"> </a>
<a name="ln2118">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2119">      ttb[2] = tta[2];</a>
<a name="ln2120"> </a>
<a name="ln2121">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2122">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2123"> </a>
<a name="ln2124">      b[j + 3] = local_opacity;</a>
<a name="ln2125">    }</a>
<a name="ln2126">  }</a>
<a name="ln2127">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2128">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2129">}</a>
<a name="ln2130"> </a>
<a name="ln2131">/* color adjustment; blend hue and chroma; take lightness from module output */</a>
<a name="ln2132">static void _blend_coloradjust(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2133">                               int flag)</a>
<a name="ln2134">{</a>
<a name="ln2135">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2136">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2137"> </a>
<a name="ln2138">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2139">  {</a>
<a name="ln2140">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2141">    {</a>
<a name="ln2142">      float local_opacity = mask[i];</a>
<a name="ln2143">      float ta[3], tb[3];</a>
<a name="ln2144">      float tta[3], ttb[3];</a>
<a name="ln2145">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2146">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2147">      _Lab_2_LCH(ta, tta);</a>
<a name="ln2148"> </a>
<a name="ln2149">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2150">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2151">      _Lab_2_LCH(tb, ttb);</a>
<a name="ln2152"> </a>
<a name="ln2153">      // ttb[0] (output lightness) unchanged</a>
<a name="ln2154">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2155"> </a>
<a name="ln2156">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2157">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2158">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2159">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2160"> </a>
<a name="ln2161">      _LCH_2_Lab(ttb, tb);</a>
<a name="ln2162">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2163">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2164"> </a>
<a name="ln2165">      b[j + 3] = local_opacity;</a>
<a name="ln2166">    }</a>
<a name="ln2167">  }</a>
<a name="ln2168">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2169">  {</a>
<a name="ln2170">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2171">    {</a>
<a name="ln2172">      float local_opacity = mask[i];</a>
<a name="ln2173">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2174">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2175"> </a>
<a name="ln2176">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2177">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2178"> </a>
<a name="ln2179">      _RGB_2_HSL(ta, tta);</a>
<a name="ln2180">      _RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2181"> </a>
<a name="ln2182">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2183">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2184">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2185">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2186"> </a>
<a name="ln2187">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2188">      // ttb[2] (output lightness) unchanged</a>
<a name="ln2189"> </a>
<a name="ln2190">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2191">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2192"> </a>
<a name="ln2193">      b[j + 3] = local_opacity;</a>
<a name="ln2194">    }</a>
<a name="ln2195">  }</a>
<a name="ln2196">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2197">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2198">}</a>
<a name="ln2199"> </a>
<a name="ln2200">/* inverse blend */</a>
<a name="ln2201">static void _blend_inverse(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2202">                           int flag)</a>
<a name="ln2203">{</a>
<a name="ln2204">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2205">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2206"> </a>
<a name="ln2207">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2208">  {</a>
<a name="ln2209">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2210">    {</a>
<a name="ln2211">      float local_opacity = mask[i];</a>
<a name="ln2212">      float ta[3], tb[3];</a>
<a name="ln2213">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2214">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2215"> </a>
<a name="ln2216">      tb[0] = CLAMP_RANGE((ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity, min[0], max[0]);</a>
<a name="ln2217"> </a>
<a name="ln2218">      if(flag == 0)</a>
<a name="ln2219">      {</a>
<a name="ln2220">        tb[1] = CLAMP_RANGE((ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity, min[1], max[1]);</a>
<a name="ln2221">        tb[2] = CLAMP_RANGE((ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity, min[2], max[2]);</a>
<a name="ln2222">      }</a>
<a name="ln2223">      else</a>
<a name="ln2224">      {</a>
<a name="ln2225">        tb[1] = ta[1];</a>
<a name="ln2226">        tb[2] = ta[2];</a>
<a name="ln2227">      }</a>
<a name="ln2228"> </a>
<a name="ln2229">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2230">      b[j + 3] = local_opacity;</a>
<a name="ln2231">    }</a>
<a name="ln2232">  }</a>
<a name="ln2233">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2234">  {</a>
<a name="ln2235">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2236">    {</a>
<a name="ln2237">      float local_opacity = mask[i];</a>
<a name="ln2238">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln2239">        b[j + k]</a>
<a name="ln2240">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln2241">      b[j + 3] = local_opacity;</a>
<a name="ln2242">    }</a>
<a name="ln2243">  }</a>
<a name="ln2244">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2245">  {</a>
<a name="ln2246">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2247">    {</a>
<a name="ln2248">      float local_opacity = mask[i];</a>
<a name="ln2249">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln2250">        b[j + k]</a>
<a name="ln2251">            = CLAMP_RANGE((a[j + k] * (1.0f - local_opacity)) + b[j + k] * local_opacity, min[k], max[k]);</a>
<a name="ln2252">    }</a>
<a name="ln2253">  }</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256">/* blend only lightness in Lab color space without any clamping (a noop for</a>
<a name="ln2257"> * other color spaces) */</a>
<a name="ln2258">static void _blend_Lab_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2259">                                 int flag)</a>
<a name="ln2260">{</a>
<a name="ln2261">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2262">  {</a>
<a name="ln2263">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2264">    {</a>
<a name="ln2265">      float local_opacity = mask[i];</a>
<a name="ln2266">      float ta[3], tb[3];</a>
<a name="ln2267">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2268">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2269"> </a>
<a name="ln2270">      tb[0] = (ta[0] * (1.0f - local_opacity)) + tb[0] * local_opacity;</a>
<a name="ln2271">      tb[1] = ta[1];</a>
<a name="ln2272">      tb[2] = ta[2];</a>
<a name="ln2273"> </a>
<a name="ln2274">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2275">      b[j + 3] = local_opacity;</a>
<a name="ln2276">    }</a>
<a name="ln2277">  }</a>
<a name="ln2278">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2279">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282">/* blend only a-channel in Lab color space without any clamping (a noop for</a>
<a name="ln2283"> * other color spaces) */</a>
<a name="ln2284">static void _blend_Lab_a(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2285">                         int flag)</a>
<a name="ln2286">{</a>
<a name="ln2287">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2288">  {</a>
<a name="ln2289">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2290">    {</a>
<a name="ln2291">      float local_opacity = mask[i];</a>
<a name="ln2292">      float ta[3], tb[3];</a>
<a name="ln2293">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2294">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2295"> </a>
<a name="ln2296">      tb[0] = ta[0];</a>
<a name="ln2297">      tb[1] = (ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity;</a>
<a name="ln2298">      tb[2] = ta[2];</a>
<a name="ln2299"> </a>
<a name="ln2300">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2301">      b[j + 3] = local_opacity;</a>
<a name="ln2302">    }</a>
<a name="ln2303">  }</a>
<a name="ln2304">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2305">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">/* blend only b-channel in Lab color space without any clamping (a noop for</a>
<a name="ln2309"> * other color spaces) */</a>
<a name="ln2310">static void _blend_Lab_b(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2311">                         int flag)</a>
<a name="ln2312">{</a>
<a name="ln2313">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2314">  {</a>
<a name="ln2315">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2316">    {</a>
<a name="ln2317">      float local_opacity = mask[i];</a>
<a name="ln2318">      float ta[3], tb[3];</a>
<a name="ln2319">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2320">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2321"> </a>
<a name="ln2322">      tb[0] = ta[0];</a>
<a name="ln2323">      tb[1] = ta[1];</a>
<a name="ln2324">      tb[2] = (ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity;</a>
<a name="ln2325"> </a>
<a name="ln2326">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2327">      b[j + 3] = local_opacity;</a>
<a name="ln2328">    }</a>
<a name="ln2329">  }</a>
<a name="ln2330">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2331">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334"> </a>
<a name="ln2335">/* blend only color in Lab color space without any clamping (a noop for other</a>
<a name="ln2336"> * color spaces) */</a>
<a name="ln2337">static void _blend_Lab_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2338">                             int flag)</a>
<a name="ln2339">{</a>
<a name="ln2340">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2341">  {</a>
<a name="ln2342">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2343">    {</a>
<a name="ln2344">      float local_opacity = mask[i];</a>
<a name="ln2345">      float ta[3], tb[3];</a>
<a name="ln2346">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2347">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2348"> </a>
<a name="ln2349">      tb[0] = ta[0];</a>
<a name="ln2350">      tb[1] = (ta[1] * (1.0f - local_opacity)) + tb[1] * local_opacity;</a>
<a name="ln2351">      tb[2] = (ta[2] * (1.0f - local_opacity)) + tb[2] * local_opacity;</a>
<a name="ln2352"> </a>
<a name="ln2353">      if(flag != 0)</a>
<a name="ln2354">      {</a>
<a name="ln2355">        tb[1] = ta[1];</a>
<a name="ln2356">        tb[2] = ta[2];</a>
<a name="ln2357">      }</a>
<a name="ln2358"> </a>
<a name="ln2359">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2360">      b[j + 3] = local_opacity;</a>
<a name="ln2361">    }</a>
<a name="ln2362">  }</a>
<a name="ln2363">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2364">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367">/* blend only lightness in HSV color space without any clamping (a noop for</a>
<a name="ln2368"> * other color spaces) */</a>
<a name="ln2369">static void _blend_HSV_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2370">                                 int flag)</a>
<a name="ln2371">{</a>
<a name="ln2372">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2373">  {</a>
<a name="ln2374">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2375">    {</a>
<a name="ln2376">      float local_opacity = mask[i];</a>
<a name="ln2377">      float ta[3], tb[3];</a>
<a name="ln2378">      _RGB_2_HSV(&amp;a[j], ta);</a>
<a name="ln2379">      _RGB_2_HSV(&amp;b[j], tb);</a>
<a name="ln2380"> </a>
<a name="ln2381">      // hue and saturation from input image</a>
<a name="ln2382">      tb[0] = ta[0];</a>
<a name="ln2383">      tb[1] = ta[1];</a>
<a name="ln2384"> </a>
<a name="ln2385">      // blend lightness between input and output</a>
<a name="ln2386">      tb[2] = ta[2] * (1.0f - local_opacity) + tb[2] * local_opacity;</a>
<a name="ln2387"> </a>
<a name="ln2388">      _HSV_2_RGB(tb, &amp;b[j]);</a>
<a name="ln2389">      b[j + 3] = local_opacity;</a>
<a name="ln2390">    }</a>
<a name="ln2391">  }</a>
<a name="ln2392">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2393">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2394">}</a>
<a name="ln2395"> </a>
<a name="ln2396">/* blend only color in HSV color space without any clamping (a noop for other</a>
<a name="ln2397"> * color spaces) */</a>
<a name="ln2398">static void _blend_HSV_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2399">                             int flag)</a>
<a name="ln2400">{</a>
<a name="ln2401">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2402">  {</a>
<a name="ln2403">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2404">    {</a>
<a name="ln2405">      float local_opacity = mask[i];</a>
<a name="ln2406">      float ta[3], tb[3];</a>
<a name="ln2407">      _RGB_2_HSV(&amp;a[j], ta);</a>
<a name="ln2408">      _RGB_2_HSV(&amp;b[j], tb);</a>
<a name="ln2409"> </a>
<a name="ln2410">      // convert from polar to cartesian coordinates</a>
<a name="ln2411">      float xa = ta[1] * cosf(2.0f * DT_M_PI_F * ta[0]);</a>
<a name="ln2412">      float ya = ta[1] * sinf(2.0f * DT_M_PI_F * ta[0]);</a>
<a name="ln2413">      float xb = tb[1] * cosf(2.0f * DT_M_PI_F * tb[0]);</a>
<a name="ln2414">      float yb = tb[1] * sinf(2.0f * DT_M_PI_F * tb[0]);</a>
<a name="ln2415"> </a>
<a name="ln2416">      // blend color vectors of input and output</a>
<a name="ln2417">      float xc = xa * (1.0f - local_opacity) + xb * local_opacity;</a>
<a name="ln2418">      float yc = ya * (1.0f - local_opacity) + yb * local_opacity;</a>
<a name="ln2419"> </a>
<a name="ln2420">      tb[0] = atan2f(yc, xc) / (2.0f * DT_M_PI_F);</a>
<a name="ln2421">      if(tb[0] &lt; 0.0f) tb[0] += 1.0f;</a>
<a name="ln2422">      tb[1] = sqrtf(xc * xc + yc * yc);</a>
<a name="ln2423"> </a>
<a name="ln2424">      // lightness from input image</a>
<a name="ln2425">      tb[2] = ta[2];</a>
<a name="ln2426"> </a>
<a name="ln2427">      _HSV_2_RGB(tb, &amp;b[j]);</a>
<a name="ln2428">      b[j + 3] = local_opacity;</a>
<a name="ln2429">    }</a>
<a name="ln2430">  }</a>
<a name="ln2431">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2432">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2433">}</a>
<a name="ln2434"> </a>
<a name="ln2435">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2436"> * other color spaces) */</a>
<a name="ln2437">static void _blend_RGB_R(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2438">                         int flag)</a>
<a name="ln2439">{</a>
<a name="ln2440">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2441">  {</a>
<a name="ln2442">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2443">    {</a>
<a name="ln2444">      float local_opacity = mask[i];</a>
<a name="ln2445"> </a>
<a name="ln2446">      b[j + 0] = (a[j + 0] * (1.0f - local_opacity)) + b[j + 0] * local_opacity;</a>
<a name="ln2447">      b[j + 1] = a[j + 1];</a>
<a name="ln2448">      b[j + 2] = a[j + 2];</a>
<a name="ln2449">      b[j + 3] = local_opacity;</a>
<a name="ln2450">    }</a>
<a name="ln2451">  }</a>
<a name="ln2452">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2453">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2454"> </a>
<a name="ln2455">}</a>
<a name="ln2456"> </a>
<a name="ln2457">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2458"> * other color spaces) */</a>
<a name="ln2459">static void _blend_RGB_G(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2460">                         int flag)</a>
<a name="ln2461">{</a>
<a name="ln2462">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2463">  {</a>
<a name="ln2464">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2465">    {</a>
<a name="ln2466">      float local_opacity = mask[i];</a>
<a name="ln2467"> </a>
<a name="ln2468">      b[j + 0] = a[j + 0];</a>
<a name="ln2469">      b[j + 1] = (a[j + 1] * (1.0f - local_opacity)) + b[j + 1] * local_opacity;</a>
<a name="ln2470">      b[j + 2] = a[j + 2];</a>
<a name="ln2471">      b[j + 3] = local_opacity;</a>
<a name="ln2472">    }</a>
<a name="ln2473">  }</a>
<a name="ln2474">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2475">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2476">}</a>
<a name="ln2477"> </a>
<a name="ln2478">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2479"> * other color spaces) */</a>
<a name="ln2480">static void _blend_RGB_B(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2481">                         int flag)</a>
<a name="ln2482">{</a>
<a name="ln2483">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2484">  {</a>
<a name="ln2485">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2486">    {</a>
<a name="ln2487">      float local_opacity = mask[i];</a>
<a name="ln2488"> </a>
<a name="ln2489">      b[j + 0] = a[j + 0];</a>
<a name="ln2490">      b[j + 1] = a[j + 1];</a>
<a name="ln2491">      b[j + 2] = (a[j + 2] * (1.0f - local_opacity)) + b[j + 2] * local_opacity;</a>
<a name="ln2492">      b[j + 3] = local_opacity;</a>
<a name="ln2493">    }</a>
<a name="ln2494">  }</a>
<a name="ln2495">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2496">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499"> </a>
<a name="ln2500">static void display_channel(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2501">                            dt_dev_pixelpipe_display_mask_t channel)</a>
<a name="ln2502">{</a>
<a name="ln2503"> </a>
<a name="ln2504">  switch(channel &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln2505">  {</a>
<a name="ln2506">    case DT_DEV_PIXELPIPE_DISPLAY_L:</a>
<a name="ln2507">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2508">      {</a>
<a name="ln2509">        const float c = CLAMP_RANGE(a[j] / 100.0f, 0.0f, 1.0f);</a>
<a name="ln2510">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2511">      }</a>
<a name="ln2512">      break;</a>
<a name="ln2513">    case (DT_DEV_PIXELPIPE_DISPLAY_L | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2514">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2515">      {</a>
<a name="ln2516">        const float c = CLAMP_RANGE(b[j] / 100.0f, 0.0f, 1.0f);</a>
<a name="ln2517">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2518">      }</a>
<a name="ln2519">      break;</a>
<a name="ln2520">    case DT_DEV_PIXELPIPE_DISPLAY_a:</a>
<a name="ln2521">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2522">      {</a>
<a name="ln2523">        const float c = CLAMP_RANGE((a[j + 1] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2524">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2525">      }</a>
<a name="ln2526">      break;</a>
<a name="ln2527">    case (DT_DEV_PIXELPIPE_DISPLAY_a | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2528">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2529">      {</a>
<a name="ln2530">        const float c = CLAMP_RANGE((b[j + 1] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2531">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2532">      }</a>
<a name="ln2533">      break;</a>
<a name="ln2534">    case DT_DEV_PIXELPIPE_DISPLAY_b:</a>
<a name="ln2535">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2536">      {</a>
<a name="ln2537">        const float c = CLAMP_RANGE((a[j + 2] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2538">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2539">      }</a>
<a name="ln2540">      break;</a>
<a name="ln2541">    case (DT_DEV_PIXELPIPE_DISPLAY_b | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2542">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2543">      {</a>
<a name="ln2544">        const float c = CLAMP_RANGE((b[j + 2] + 128.0f) / 256.0f, 0.0f, 1.0f);</a>
<a name="ln2545">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2546">      }</a>
<a name="ln2547">      break;</a>
<a name="ln2548">    case DT_DEV_PIXELPIPE_DISPLAY_R:</a>
<a name="ln2549">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2550">      {</a>
<a name="ln2551">        const float c = CLAMP_RANGE(a[j], 0.0f, 1.0f);</a>
<a name="ln2552">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2553">      }</a>
<a name="ln2554">      break;</a>
<a name="ln2555">    case (DT_DEV_PIXELPIPE_DISPLAY_R | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2556">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2557">      {</a>
<a name="ln2558">        const float c = CLAMP_RANGE(b[j], 0.0f, 1.0f);</a>
<a name="ln2559">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2560">      }</a>
<a name="ln2561">      break;</a>
<a name="ln2562">    case DT_DEV_PIXELPIPE_DISPLAY_G:</a>
<a name="ln2563">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2564">      {</a>
<a name="ln2565">        const float c = CLAMP_RANGE(a[j + 1], 0.0f, 1.0f);</a>
<a name="ln2566">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2567">      }</a>
<a name="ln2568">      break;</a>
<a name="ln2569">    case (DT_DEV_PIXELPIPE_DISPLAY_G | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2570">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2571">      {</a>
<a name="ln2572">        const float c = CLAMP_RANGE(b[j + 1], 0.0f, 1.0f);</a>
<a name="ln2573">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2574">      }</a>
<a name="ln2575">      break;</a>
<a name="ln2576">    case DT_DEV_PIXELPIPE_DISPLAY_B:</a>
<a name="ln2577">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2578">      {</a>
<a name="ln2579">        const float c = CLAMP_RANGE(a[j + 2], 0.0f, 1.0f);</a>
<a name="ln2580">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2581">      }</a>
<a name="ln2582">      break;</a>
<a name="ln2583">    case (DT_DEV_PIXELPIPE_DISPLAY_B | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2584">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2585">      {</a>
<a name="ln2586">        const float c = CLAMP_RANGE(b[j + 2], 0.0f, 1.0f);</a>
<a name="ln2587">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2588">      }</a>
<a name="ln2589">      break;</a>
<a name="ln2590">    case DT_DEV_PIXELPIPE_DISPLAY_GRAY:</a>
<a name="ln2591">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2592">      {</a>
<a name="ln2593">        const float c = CLAMP_RANGE(0.3f * a[j] + 0.59f * a[j + 1] + 0.11f * a[j + 2], 0.0f, 1.0f);</a>
<a name="ln2594">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2595">      }</a>
<a name="ln2596">      break;</a>
<a name="ln2597">    case (DT_DEV_PIXELPIPE_DISPLAY_GRAY | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2598">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2599">      {</a>
<a name="ln2600">        const float c = CLAMP_RANGE(0.3f * b[j] + 0.59f * b[j + 1] + 0.11f * b[j + 2], 0.0f, 1.0f);</a>
<a name="ln2601">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2602">      }</a>
<a name="ln2603">      break;</a>
<a name="ln2604">    case DT_DEV_PIXELPIPE_DISPLAY_LCH_C:</a>
<a name="ln2605">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2606">      {</a>
<a name="ln2607">        float LCH[3];</a>
<a name="ln2608">        _Lab_2_LCH(a + j, LCH);</a>
<a name="ln2609">        const float c = CLAMP_RANGE(LCH[1] / (128.0f * sqrtf(2.0f)), 0.0f, 1.0f);</a>
<a name="ln2610">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2611">      }</a>
<a name="ln2612">      break;</a>
<a name="ln2613">    case (DT_DEV_PIXELPIPE_DISPLAY_LCH_C | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2614">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2615">      {</a>
<a name="ln2616">        float LCH[3];</a>
<a name="ln2617">        _Lab_2_LCH(b + j, LCH);</a>
<a name="ln2618">        const float c = CLAMP_RANGE(LCH[1] / (128.0f * sqrtf(2.0f)), 0.0f, 1.0f);</a>
<a name="ln2619">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2620">      }</a>
<a name="ln2621">      break;</a>
<a name="ln2622">    case DT_DEV_PIXELPIPE_DISPLAY_LCH_h:</a>
<a name="ln2623">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2624">      {</a>
<a name="ln2625">        float LCH[3];</a>
<a name="ln2626">        _Lab_2_LCH(a + j, LCH);</a>
<a name="ln2627">        const float c = CLAMP_RANGE(LCH[2], 0.0f, 1.0f);</a>
<a name="ln2628">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2629">      }</a>
<a name="ln2630">      break;</a>
<a name="ln2631">    case (DT_DEV_PIXELPIPE_DISPLAY_LCH_h | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2632">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2633">      {</a>
<a name="ln2634">        float LCH[3];</a>
<a name="ln2635">        _Lab_2_LCH(b + j, LCH);</a>
<a name="ln2636">        const float c = CLAMP_RANGE(LCH[2], 0.0f, 1.0f);</a>
<a name="ln2637">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2638">      }</a>
<a name="ln2639">      break;</a>
<a name="ln2640">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_H:</a>
<a name="ln2641">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2642">      {</a>
<a name="ln2643">        float HSL[3];</a>
<a name="ln2644">        _RGB_2_HSL(a + j, HSL);</a>
<a name="ln2645">        const float c = CLAMP_RANGE(HSL[0], 0.0f, 1.0f);</a>
<a name="ln2646">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2647">      }</a>
<a name="ln2648">      break;</a>
<a name="ln2649">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_H | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2650">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2651">      {</a>
<a name="ln2652">        float HSL[3];</a>
<a name="ln2653">        _RGB_2_HSL(b + j, HSL);</a>
<a name="ln2654">        const float c = CLAMP_RANGE(HSL[0], 0.0f, 1.0f);</a>
<a name="ln2655">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2656">      }</a>
<a name="ln2657">      break;</a>
<a name="ln2658">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_S:</a>
<a name="ln2659">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2660">      {</a>
<a name="ln2661">        float HSL[3];</a>
<a name="ln2662">        _RGB_2_HSL(a + j, HSL);</a>
<a name="ln2663">        const float c = CLAMP_RANGE(HSL[1], 0.0f, 1.0f);</a>
<a name="ln2664">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2665">      }</a>
<a name="ln2666">      break;</a>
<a name="ln2667">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_S | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2668">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2669">      {</a>
<a name="ln2670">        float HSL[3];</a>
<a name="ln2671">        _RGB_2_HSL(b + j, HSL);</a>
<a name="ln2672">        const float c = CLAMP_RANGE(HSL[1], 0.0f, 1.0f);</a>
<a name="ln2673">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2674">      }</a>
<a name="ln2675">      break;</a>
<a name="ln2676">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_l:</a>
<a name="ln2677">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2678">      {</a>
<a name="ln2679">        float HSL[3];</a>
<a name="ln2680">        _RGB_2_HSL(a + j, HSL);</a>
<a name="ln2681">        const float c = CLAMP_RANGE(HSL[2], 0.0f, 1.0f);</a>
<a name="ln2682">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2683">      }</a>
<a name="ln2684">      break;</a>
<a name="ln2685">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_l | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2686">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2687">      {</a>
<a name="ln2688">        float HSL[3];</a>
<a name="ln2689">        _RGB_2_HSL(b + j, HSL);</a>
<a name="ln2690">        const float c = CLAMP_RANGE(HSL[2], 0.0f, 1.0f);</a>
<a name="ln2691">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2692">      }</a>
<a name="ln2693">      break;</a>
<a name="ln2694">    default:</a>
<a name="ln2695">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2696">      {</a>
<a name="ln2697">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = 0.0f;</a>
<a name="ln2698">      }</a>
<a name="ln2699">      break;</a>
<a name="ln2700">  }</a>
<a name="ln2701"> </a>
<a name="ln2702">  if(bd-&gt;cst != iop_cs_rgb)</a>
<a name="ln2703">  {</a>
<a name="ln2704">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2705">      b[j + 3] = mask[i];</a>
<a name="ln2706">  }</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709"> </a>
<a name="ln2710">_blend_row_func *dt_develop_choose_blend_func(const unsigned int blend_mode)</a>
<a name="ln2711">{</a>
<a name="ln2712">  _blend_row_func *blend = NULL;</a>
<a name="ln2713"> </a>
<a name="ln2714">  /* select the blend operator */</a>
<a name="ln2715">  switch(blend_mode)</a>
<a name="ln2716">  {</a>
<a name="ln2717">    case DEVELOP_BLEND_LIGHTEN:</a>
<a name="ln2718">      blend = _blend_lighten;</a>
<a name="ln2719">      break;</a>
<a name="ln2720">    case DEVELOP_BLEND_DARKEN:</a>
<a name="ln2721">      blend = _blend_darken;</a>
<a name="ln2722">      break;</a>
<a name="ln2723">    case DEVELOP_BLEND_MULTIPLY:</a>
<a name="ln2724">      blend = _blend_multiply;</a>
<a name="ln2725">      break;</a>
<a name="ln2726">    case DEVELOP_BLEND_AVERAGE:</a>
<a name="ln2727">      blend = _blend_average;</a>
<a name="ln2728">      break;</a>
<a name="ln2729">    case DEVELOP_BLEND_ADD:</a>
<a name="ln2730">      blend = _blend_add;</a>
<a name="ln2731">      break;</a>
<a name="ln2732">    case DEVELOP_BLEND_SUBSTRACT:</a>
<a name="ln2733">      blend = _blend_substract;</a>
<a name="ln2734">      break;</a>
<a name="ln2735">    case DEVELOP_BLEND_DIFFERENCE:</a>
<a name="ln2736">      blend = _blend_difference;</a>
<a name="ln2737">      break;</a>
<a name="ln2738">    case DEVELOP_BLEND_DIFFERENCE2:</a>
<a name="ln2739">      blend = _blend_difference2;</a>
<a name="ln2740">      break;</a>
<a name="ln2741">    case DEVELOP_BLEND_SCREEN:</a>
<a name="ln2742">      blend = _blend_screen;</a>
<a name="ln2743">      break;</a>
<a name="ln2744">    case DEVELOP_BLEND_OVERLAY:</a>
<a name="ln2745">      blend = _blend_overlay;</a>
<a name="ln2746">      break;</a>
<a name="ln2747">    case DEVELOP_BLEND_SOFTLIGHT:</a>
<a name="ln2748">      blend = _blend_softlight;</a>
<a name="ln2749">      break;</a>
<a name="ln2750">    case DEVELOP_BLEND_HARDLIGHT:</a>
<a name="ln2751">      blend = _blend_hardlight;</a>
<a name="ln2752">      break;</a>
<a name="ln2753">    case DEVELOP_BLEND_VIVIDLIGHT:</a>
<a name="ln2754">      blend = _blend_vividlight;</a>
<a name="ln2755">      break;</a>
<a name="ln2756">    case DEVELOP_BLEND_LINEARLIGHT:</a>
<a name="ln2757">      blend = _blend_linearlight;</a>
<a name="ln2758">      break;</a>
<a name="ln2759">    case DEVELOP_BLEND_PINLIGHT:</a>
<a name="ln2760">      blend = _blend_pinlight;</a>
<a name="ln2761">      break;</a>
<a name="ln2762">    case DEVELOP_BLEND_LIGHTNESS:</a>
<a name="ln2763">      blend = _blend_lightness;</a>
<a name="ln2764">      break;</a>
<a name="ln2765">    case DEVELOP_BLEND_CHROMA:</a>
<a name="ln2766">      blend = _blend_chroma;</a>
<a name="ln2767">      break;</a>
<a name="ln2768">    case DEVELOP_BLEND_HUE:</a>
<a name="ln2769">      blend = _blend_hue;</a>
<a name="ln2770">      break;</a>
<a name="ln2771">    case DEVELOP_BLEND_COLOR:</a>
<a name="ln2772">      blend = _blend_color;</a>
<a name="ln2773">      break;</a>
<a name="ln2774">    case DEVELOP_BLEND_INVERSE:</a>
<a name="ln2775">      blend = _blend_inverse;</a>
<a name="ln2776">      break;</a>
<a name="ln2777">    case DEVELOP_BLEND_NORMAL:</a>
<a name="ln2778">    case DEVELOP_BLEND_BOUNDED:</a>
<a name="ln2779">      blend = _blend_normal_bounded;</a>
<a name="ln2780">      break;</a>
<a name="ln2781">    case DEVELOP_BLEND_COLORADJUST:</a>
<a name="ln2782">      blend = _blend_coloradjust;</a>
<a name="ln2783">      break;</a>
<a name="ln2784">    case DEVELOP_BLEND_LAB_LIGHTNESS:</a>
<a name="ln2785">    case DEVELOP_BLEND_LAB_L:</a>
<a name="ln2786">      blend = _blend_Lab_lightness;</a>
<a name="ln2787">      break;</a>
<a name="ln2788">    case DEVELOP_BLEND_LAB_A:</a>
<a name="ln2789">      blend = _blend_Lab_a;</a>
<a name="ln2790">      break;</a>
<a name="ln2791">    case DEVELOP_BLEND_LAB_B:</a>
<a name="ln2792">      blend = _blend_Lab_b;</a>
<a name="ln2793">      break;</a>
<a name="ln2794">    case DEVELOP_BLEND_LAB_COLOR:</a>
<a name="ln2795">      blend = _blend_Lab_color;</a>
<a name="ln2796">      break;</a>
<a name="ln2797">    case DEVELOP_BLEND_HSV_LIGHTNESS:</a>
<a name="ln2798">      blend = _blend_HSV_lightness;</a>
<a name="ln2799">      break;</a>
<a name="ln2800">    case DEVELOP_BLEND_HSV_COLOR:</a>
<a name="ln2801">      blend = _blend_HSV_color;</a>
<a name="ln2802">      break;</a>
<a name="ln2803">    case DEVELOP_BLEND_RGB_R:</a>
<a name="ln2804">      blend = _blend_RGB_R;</a>
<a name="ln2805">      break;</a>
<a name="ln2806">    case DEVELOP_BLEND_RGB_G:</a>
<a name="ln2807">      blend = _blend_RGB_G;</a>
<a name="ln2808">      break;</a>
<a name="ln2809">    case DEVELOP_BLEND_RGB_B:</a>
<a name="ln2810">      blend = _blend_RGB_B;</a>
<a name="ln2811">      break;</a>
<a name="ln2812"> </a>
<a name="ln2813">    /* fallback to normal blend */</a>
<a name="ln2814">    case DEVELOP_BLEND_NORMAL2:</a>
<a name="ln2815">    case DEVELOP_BLEND_UNBOUNDED:</a>
<a name="ln2816">    default:</a>
<a name="ln2817">      blend = _blend_normal_unbounded;</a>
<a name="ln2818">      break;</a>
<a name="ln2819">  }</a>
<a name="ln2820"> </a>
<a name="ln2821">  return blend;</a>
<a name="ln2822">}</a>
<a name="ln2823"> </a>
<a name="ln2824">void dt_develop_blend_process(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2825">                              const void *const ivoid, void *const ovoid, const struct dt_iop_roi_t *const roi_in,</a>
<a name="ln2826">                              const struct dt_iop_roi_t *const roi_out)</a>
<a name="ln2827">{</a>
<a name="ln2828">  if(self-&gt;bypass_blendif &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)) return;</a>
<a name="ln2829"> </a>
<a name="ln2830">  const dt_develop_blend_params_t *const d = (const dt_develop_blend_params_t *const)piece-&gt;blendop_data;</a>
<a name="ln2831">  if(!d) return;</a>
<a name="ln2832"> </a>
<a name="ln2833">  const unsigned int mask_mode = d-&gt;mask_mode;</a>
<a name="ln2834">  // check if blend is disabled</a>
<a name="ln2835">  if(!(mask_mode &amp; DEVELOP_MASK_ENABLED)) return;</a>
<a name="ln2836"> </a>
<a name="ln2837">  const int ch = piece-&gt;colors;           // the number of channels in the buffer</a>
<a name="ln2838">  const int bch = (ch == 1) ? 1 : ch - 1; // the number of channels to blend (all but alpha)</a>
<a name="ln2839">  const int xoffs = roi_out-&gt;x - roi_in-&gt;x;</a>
<a name="ln2840">  const int yoffs = roi_out-&gt;y - roi_in-&gt;y;</a>
<a name="ln2841">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln2842">  const int iheight = roi_in-&gt;height;</a>
<a name="ln2843">  const int owidth = roi_out-&gt;width;</a>
<a name="ln2844">  const int oheight = roi_out-&gt;height;</a>
<a name="ln2845">  const size_t buffsize = (size_t)owidth * oheight;</a>
<a name="ln2846">  const float iscale = roi_in-&gt;scale;</a>
<a name="ln2847">  const float oscale = roi_out-&gt;scale;</a>
<a name="ln2848">  const _Bool rois_equal = iwidth == owidth || iheight == oheight || xoffs == 0 || yoffs == 0;</a>
<a name="ln2849"> </a>
<a name="ln2850">  // In most cases of blending-enabled modules input and output of the module have</a>
<a name="ln2851">  // the exact same dimensions. Only in very special cases we allow a module's input</a>
<a name="ln2852">  // to exceed its output. This is namely the case for the spot removal module where</a>
<a name="ln2853">  // the source of a patch might lie outside the roi of the output image. Therefore:</a>
<a name="ln2854">  // We can only handle blending if roi_out and roi_in have the same scale and</a>
<a name="ln2855">  // if roi_out fits into the area given by roi_in. xoffs and yoffs describe the relative</a>
<a name="ln2856">  // offset of the input image to the output image.</a>
<a name="ln2857">  if(oscale != iscale || xoffs &lt; 0 || yoffs &lt; 0</a>
<a name="ln2858">     || ((xoffs &gt; 0 || yoffs &gt; 0) &amp;&amp; (owidth + xoffs &gt; iwidth || oheight + yoffs &gt; iheight)))</a>
<a name="ln2859">  {</a>
<a name="ln2860">    dt_control_log(_(&quot;skipped blending in module '%s': roi's do not match&quot;), self-&gt;op);</a>
<a name="ln2861">    return;</a>
<a name="ln2862">  }</a>
<a name="ln2863"> </a>
<a name="ln2864">  // only non-zero if mask_display was set by an _earlier_ module</a>
<a name="ln2865">  const dt_dev_pixelpipe_display_mask_t mask_display = piece-&gt;pipe-&gt;mask_display;</a>
<a name="ln2866"> </a>
<a name="ln2867">  // does user want us to display a specific channel?</a>
<a name="ln2868">  const dt_dev_pixelpipe_display_mask_t request_mask_display =</a>
<a name="ln2869">    (self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module) &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe)</a>
<a name="ln2870">     &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL))</a>
<a name="ln2871">        ? self-&gt;request_mask_display</a>
<a name="ln2872">        : DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln2873"> </a>
<a name="ln2874">  // check if we only should blend lightness channel. will affect only Lab space</a>
<a name="ln2875">  const int blendflag = self-&gt;flags() &amp; IOP_FLAGS_BLEND_ONLY_LIGHTNESS;</a>
<a name="ln2876"> </a>
<a name="ln2877">  // get channel max values depending on colorspace</a>
<a name="ln2878">  const dt_iop_colorspace_type_t cst = dt_iop_module_colorspace(self);</a>
<a name="ln2879"> </a>
<a name="ln2880">  // check if mask should be suppressed temporarily (i.e. just set to global</a>
<a name="ln2881">  // opacity value)</a>
<a name="ln2882">  const _Bool suppress_mask = self-&gt;suppress_mask &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)</a>
<a name="ln2883">                              &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe) &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL);</a>
<a name="ln2884">  const _Bool mask_feather = d-&gt;feathering_radius &gt; 0.1f;</a>
<a name="ln2885">  const _Bool mask_blur = d-&gt;blur_radius &gt; 0.1f;</a>
<a name="ln2886">  const _Bool mask_tone_curve = fabsf(d-&gt;contrast) &gt;= 0.01f || fabsf(d-&gt;brightness) &gt;= 0.01f;</a>
<a name="ln2887"> </a>
<a name="ln2888">  // get the clipped opacity value  0 - 1</a>
<a name="ln2889">  const float opacity = fminf(fmaxf(0.0f, (d-&gt;opacity / 100.0f)), 1.0f);</a>
<a name="ln2890"> </a>
<a name="ln2891">  // allocate space for blend mask</a>
<a name="ln2892">  float *_mask = dt_alloc_align(64, buffsize * sizeof(float));</a>
<a name="ln2893">  if(!_mask)</a>
<a name="ln2894">  {</a>
<a name="ln2895">    dt_control_log(_(&quot;could not allocate buffer for blending&quot;));</a>
<a name="ln2896">    return;</a>
<a name="ln2897">  }</a>
<a name="ln2898">  float *const mask = _mask;</a>
<a name="ln2899"> </a>
<a name="ln2900">  if(mask_mode == DEVELOP_MASK_ENABLED || suppress_mask)</a>
<a name="ln2901">  {</a>
<a name="ln2902">    // blend uniformly (no drawn or parametric mask)</a>
<a name="ln2903"> </a>
<a name="ln2904">#ifdef _OPENMP</a>
<a name="ln2905">#pragma omp parallel for default(none)</a>
<a name="ln2906">#endif</a>
<a name="ln2907">    for(size_t i = 0; i &lt; buffsize; i++) mask[i] = opacity;</a>
<a name="ln2908">  }</a>
<a name="ln2909">  else if(mask_mode &amp; DEVELOP_MASK_RASTER)</a>
<a name="ln2910">  {</a>
<a name="ln2911">    /* use a raster mask from another module earlier in the pipe */</a>
<a name="ln2912">    gboolean free_mask = FALSE; // if no transformations were applied we get the cached original back</a>
<a name="ln2913">    float *raster_mask = dt_dev_get_raster_mask(piece-&gt;pipe, self-&gt;raster_mask.sink.source, self-&gt;raster_mask.sink.id,</a>
<a name="ln2914">                                                self, &amp;free_mask);</a>
<a name="ln2915"> </a>
<a name="ln2916">    if(raster_mask)</a>
<a name="ln2917">    {</a>
<a name="ln2918">      // invert if required</a>
<a name="ln2919">      if(d-&gt;raster_mask_invert)</a>
<a name="ln2920">#ifdef _OPENMP</a>
<a name="ln2921">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln2922">#endif</a>
<a name="ln2923">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = (1.0 - raster_mask[i]) * opacity;</a>
<a name="ln2924">      else</a>
<a name="ln2925">#ifdef _OPENMP</a>
<a name="ln2926">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln2927">#endif</a>
<a name="ln2928">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = raster_mask[i] * opacity;</a>
<a name="ln2929">      if(free_mask) dt_free_align(raster_mask);</a>
<a name="ln2930">    }</a>
<a name="ln2931">    else</a>
<a name="ln2932">    {</a>
<a name="ln2933">      // fallback for when the raster mask couldn't be applied</a>
<a name="ln2934">      const float value = d-&gt;raster_mask_invert ? 0.0 : 1.0;</a>
<a name="ln2935">#ifdef _OPENMP</a>
<a name="ln2936">  #pragma omp parallel for default(none)</a>
<a name="ln2937">#endif</a>
<a name="ln2938">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = value;</a>
<a name="ln2939">    }</a>
<a name="ln2940">  }</a>
<a name="ln2941">  else</a>
<a name="ln2942">  {</a>
<a name="ln2943">    // we blend with a drawn and/or parametric mask</a>
<a name="ln2944"> </a>
<a name="ln2945">    // get the drawn mask if there is one</a>
<a name="ln2946">    dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, d-&gt;mask_id);</a>
<a name="ln2947"> </a>
<a name="ln2948">    if(form &amp;&amp; (!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln2949">    {</a>
<a name="ln2950">      dt_masks_group_render_roi(self, piece, form, roi_out, mask);</a>
<a name="ln2951"> </a>
<a name="ln2952">      if(d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS)</a>
<a name="ln2953">      {</a>
<a name="ln2954">        // if we have a mask and this flag is set -&gt; invert the mask</a>
<a name="ln2955">#ifdef _OPENMP</a>
<a name="ln2956">#pragma omp parallel for default(none)</a>
<a name="ln2957">#endif</a>
<a name="ln2958">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = 1.0f - mask[i];</a>
<a name="ln2959">      }</a>
<a name="ln2960">    }</a>
<a name="ln2961">    else if((!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln2962">    {</a>
<a name="ln2963">      // no form defined but drawn mask active</a>
<a name="ln2964">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln2965">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS) ? 0.0f : 1.0f;</a>
<a name="ln2966">#ifdef _OPENMP</a>
<a name="ln2967">#pragma omp parallel for default(none)</a>
<a name="ln2968">#endif</a>
<a name="ln2969">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln2970">    }</a>
<a name="ln2971">    else</a>
<a name="ln2972">    {</a>
<a name="ln2973">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln2974">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln2975">#ifdef _OPENMP</a>
<a name="ln2976">#pragma omp parallel for default(none)</a>
<a name="ln2977">#endif</a>
<a name="ln2978">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln2979">    }</a>
<a name="ln2980"> </a>
<a name="ln2981">    // get parametric mask (if any) and apply global opacity</a>
<a name="ln2982">#ifdef _OPENMP</a>
<a name="ln2983">#pragma omp parallel for default(none)</a>
<a name="ln2984">#endif</a>
<a name="ln2985">    for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln2986">    {</a>
<a name="ln2987">      size_t iindex = ((y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln2988">      size_t oindex = y * owidth * ch;</a>
<a name="ln2989">      _blend_buffer_desc_t bd = { .cst = cst, .stride = (size_t)owidth * ch, .ch = ch, .bch = bch };</a>
<a name="ln2990">      float *in = (float *)ivoid + iindex;</a>
<a name="ln2991">      float *out = (float *)ovoid + oindex;</a>
<a name="ln2992">      float *m = mask + y * owidth;</a>
<a name="ln2993">      _blend_make_mask(&amp;bd, d-&gt;blendif, d-&gt;blendif_parameters, d-&gt;mask_mode, d-&gt;mask_combine, opacity, in, out, m);</a>
<a name="ln2994">    }</a>
<a name="ln2995"> </a>
<a name="ln2996">    if(mask_feather)</a>
<a name="ln2997">    {</a>
<a name="ln2998">      int w = (int)(2 * d-&gt;feathering_radius * roi_out-&gt;scale / piece-&gt;iscale + 0.5f);</a>
<a name="ln2999">      if(w &lt; 1) w = 1;</a>
<a name="ln3000">      float sqrt_eps = 1.f;</a>
<a name="ln3001">      float guide_weight = 1.f;</a>
<a name="ln3002">      switch(cst)</a>
<a name="ln3003">      {</a>
<a name="ln3004">        case iop_cs_rgb:</a>
<a name="ln3005">          guide_weight = 100.f;</a>
<a name="ln3006">          break;</a>
<a name="ln3007">        case iop_cs_Lab:</a>
<a name="ln3008">          guide_weight = 1.f;</a>
<a name="ln3009">          break;</a>
<a name="ln3010">        case iop_cs_RAW:</a>
<a name="ln3011">        default:</a>
<a name="ln3012">          assert(0);</a>
<a name="ln3013">      }</a>
<a name="ln3014">      float *mask_bak = dt_alloc_align(64, sizeof(*mask_bak) * buffsize);</a>
<a name="ln3015">      memcpy(mask_bak, mask, sizeof(*mask_bak) * buffsize);</a>
<a name="ln3016">      float *guide = d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN ? (float *)ivoid : (float *)ovoid;</a>
<a name="ln3017">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN)</a>
<a name="ln3018">      {</a>
<a name="ln3019">        float *const guide_tmp = dt_alloc_align(64, sizeof(*guide_tmp) * buffsize * ch);</a>
<a name="ln3020">#ifdef _OPENMP</a>
<a name="ln3021">#pragma omp parallel for default(none)</a>
<a name="ln3022">#endif</a>
<a name="ln3023">        for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln3024">        {</a>
<a name="ln3025">          size_t iindex = ((size_t)(y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln3026">          size_t oindex = (size_t)(y + yoffs) * owidth * ch;</a>
<a name="ln3027">          memcpy(guide_tmp + oindex, (float *)ivoid + iindex, sizeof(*guide_tmp) * owidth * ch);</a>
<a name="ln3028">        }</a>
<a name="ln3029">        guide = guide_tmp;</a>
<a name="ln3030">      }</a>
<a name="ln3031">      guided_filter(guide, mask_bak, mask, owidth, oheight, ch, w, sqrt_eps, guide_weight, 0.f, 1.f);</a>
<a name="ln3032">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN) dt_free_align(guide);</a>
<a name="ln3033">      dt_free_align(mask_bak);</a>
<a name="ln3034">    }</a>
<a name="ln3035">    if(mask_blur)</a>
<a name="ln3036">    {</a>
<a name="ln3037">      const float sigma = d-&gt;blur_radius * roi_out-&gt;scale / piece-&gt;iscale;</a>
<a name="ln3038">      const float mmax[] = { 1.0f };</a>
<a name="ln3039">      const float mmin[] = { 0.0f };</a>
<a name="ln3040"> </a>
<a name="ln3041">      dt_gaussian_t *g = dt_gaussian_init(owidth, oheight, 1, mmax, mmin, sigma, 0);</a>
<a name="ln3042">      if(g)</a>
<a name="ln3043">      {</a>
<a name="ln3044">        dt_gaussian_blur(g, mask, mask);</a>
<a name="ln3045">        dt_gaussian_free(g);</a>
<a name="ln3046">      }</a>
<a name="ln3047">    }</a>
<a name="ln3048"> </a>
<a name="ln3049">    if(mask_tone_curve &amp;&amp; opacity &gt; 1e-4f)</a>
<a name="ln3050">    {</a>
<a name="ln3051">      const float e = expf(3.f * d-&gt;contrast);</a>
<a name="ln3052">      const float brightness = d-&gt;brightness;</a>
<a name="ln3053">#ifdef _OPENMP</a>
<a name="ln3054">#pragma omp parallel for default(none)</a>
<a name="ln3055">#endif</a>
<a name="ln3056">      for(size_t k = 0; k &lt; buffsize; k++)</a>
<a name="ln3057">      {</a>
<a name="ln3058">        float x = mask[k] / opacity;</a>
<a name="ln3059">        x = 2.f * x - 1.f;</a>
<a name="ln3060">        if (1.f - brightness &lt;= 0.f)</a>
<a name="ln3061">          x = mask[k] &lt;= FLT_EPSILON ? -1.f : 1.f;</a>
<a name="ln3062">        else if (1.f + brightness &lt;= 0.f)</a>
<a name="ln3063">          x = mask[k] &gt;= 1.f - FLT_EPSILON ? 1.f : -1.f;</a>
<a name="ln3064">        else if (brightness &gt; 0.f)</a>
<a name="ln3065">        {</a>
<a name="ln3066">          x = (x + brightness) / (1.f - brightness);</a>
<a name="ln3067">          x = fminf(x, 1.f);</a>
<a name="ln3068">        }</a>
<a name="ln3069">        else</a>
<a name="ln3070">        {</a>
<a name="ln3071">          x = (x + brightness) / (1.f + brightness);</a>
<a name="ln3072">          x = fmaxf(x, -1.f);</a>
<a name="ln3073">        }</a>
<a name="ln3074">        mask[k] = ((x * e / (1.f + (e - 1.f) * fabsf(x))) / 2.f + 0.5f) * opacity;</a>
<a name="ln3075">      }</a>
<a name="ln3076">    }</a>
<a name="ln3077">  }</a>
<a name="ln3078"> </a>
<a name="ln3079">  // now apply blending with per-pixel opacity value as defined in mask</a>
<a name="ln3080">  // select the blend operator</a>
<a name="ln3081">  _blend_row_func *const blend = dt_develop_choose_blend_func(d-&gt;blend_mode);</a>
<a name="ln3082">#ifdef _OPENMP</a>
<a name="ln3083">#pragma omp parallel for default(none)</a>
<a name="ln3084">#endif</a>
<a name="ln3085">  for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln3086">  {</a>
<a name="ln3087">    size_t iindex = ((y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln3088">    size_t oindex = y * owidth * ch;</a>
<a name="ln3089">    _blend_buffer_desc_t bd = { .cst = cst, .stride = (size_t)owidth * ch, .ch = ch, .bch = bch };</a>
<a name="ln3090">    float *in = (float *)ivoid + iindex;</a>
<a name="ln3091">    float *out = (float *)ovoid + oindex;</a>
<a name="ln3092">    float *m = mask + y * owidth;</a>
<a name="ln3093"> </a>
<a name="ln3094">    if(request_mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln3095">      display_channel(&amp;bd, in, out, m, request_mask_display);</a>
<a name="ln3096">    else</a>
<a name="ln3097">      blend(&amp;bd, in, out, m, blendflag);</a>
<a name="ln3098"> </a>
<a name="ln3099">    if((mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) &amp;&amp; cst != iop_cs_RAW)</a>
<a name="ln3100">      for(size_t j = 0; j &lt; bd.stride; j += 4) out[j + 3] = in[j + 3];</a>
<a name="ln3101">  }</a>
<a name="ln3102"> </a>
<a name="ln3103">  // register if _this_ module should expose mask or display channel</a>
<a name="ln3104">  if(request_mask_display &amp; (DT_DEV_PIXELPIPE_DISPLAY_MASK | DT_DEV_PIXELPIPE_DISPLAY_CHANNEL))</a>
<a name="ln3105">  {</a>
<a name="ln3106">    piece-&gt;pipe-&gt;mask_display = request_mask_display;</a>
<a name="ln3107">  }</a>
<a name="ln3108"> </a>
<a name="ln3109">  // check if we should store the mask for export or use in subsequent modules</a>
<a name="ln3110">  // TODO: should we skip raster masks?</a>
<a name="ln3111">  if(piece-&gt;pipe-&gt;store_all_raster_masks || dt_iop_is_raster_mask_used(self, 0))</a>
<a name="ln3112">  {</a>
<a name="ln3113">    g_hash_table_replace(piece-&gt;raster_masks, GINT_TO_POINTER(0), _mask);</a>
<a name="ln3114">  }</a>
<a name="ln3115">  else</a>
<a name="ln3116">  {</a>
<a name="ln3117">    g_hash_table_remove(piece-&gt;raster_masks, GINT_TO_POINTER(0));</a>
<a name="ln3118">    dt_free_align(_mask);</a>
<a name="ln3119">  }</a>
<a name="ln3120">}</a>
<a name="ln3121"> </a>
<a name="ln3122">#ifdef HAVE_OPENCL</a>
<a name="ln3123">int dt_develop_blend_process_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln3124">                                cl_mem dev_in, cl_mem dev_out, const struct dt_iop_roi_t *roi_in,</a>
<a name="ln3125">                                const struct dt_iop_roi_t *roi_out)</a>
<a name="ln3126">{</a>
<a name="ln3127">  if(self-&gt;bypass_blendif &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)) return TRUE;</a>
<a name="ln3128"> </a>
<a name="ln3129">  dt_develop_blend_params_t *const d = (dt_develop_blend_params_t *const)piece-&gt;blendop_data;</a>
<a name="ln3130">  if(!d) return TRUE;</a>
<a name="ln3131"> </a>
<a name="ln3132">  const unsigned int mask_mode = d-&gt;mask_mode;</a>
<a name="ln3133">  // check if blend is disabled: just return, output is already in dev_out</a>
<a name="ln3134">  if(!(mask_mode &amp; DEVELOP_MASK_ENABLED)) return TRUE;</a>
<a name="ln3135"> </a>
<a name="ln3136">  const int ch = piece-&gt;colors; // the number of channels in the buffer</a>
<a name="ln3137">  const int xoffs = roi_out-&gt;x - roi_in-&gt;x;</a>
<a name="ln3138">  const int yoffs = roi_out-&gt;y - roi_in-&gt;y;</a>
<a name="ln3139">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln3140">  const int iheight = roi_in-&gt;height;</a>
<a name="ln3141">  const int owidth = roi_out-&gt;width;</a>
<a name="ln3142">  const int oheight = roi_out-&gt;height;</a>
<a name="ln3143">  const size_t buffsize = (size_t)owidth * oheight;</a>
<a name="ln3144">  const float iscale = roi_in-&gt;scale;</a>
<a name="ln3145">  const float oscale = roi_out-&gt;scale;</a>
<a name="ln3146">  const _Bool rois_equal = iwidth == owidth || iheight == oheight || xoffs == 0 || yoffs == 0;</a>
<a name="ln3147"> </a>
<a name="ln3148">  // In most cases of blending-enabled modules input and output of the module have</a>
<a name="ln3149">  // the exact same dimensions. Only in very special cases we allow a module's input</a>
<a name="ln3150">  // to exceed its output. This is namely the case for the spot removal module where</a>
<a name="ln3151">  // the source of a patch might lie outside the roi of the output image. Therefore:</a>
<a name="ln3152">  // We can only handle blending if roi_out and roi_in have the same scale and</a>
<a name="ln3153">  // if roi_out fits into the area given by roi_in. xoffs and yoffs describe the relative</a>
<a name="ln3154">  // offset of the input image to the output image. */</a>
<a name="ln3155">  if(oscale != iscale || xoffs &lt; 0 || yoffs &lt; 0</a>
<a name="ln3156">     || ((xoffs &gt; 0 || yoffs &gt; 0) &amp;&amp; (owidth + xoffs &gt; iwidth || oheight + yoffs &gt; iheight)))</a>
<a name="ln3157">  {</a>
<a name="ln3158">    dt_control_log(_(&quot;skipped blending in module '%s': roi's do not match&quot;), self-&gt;op);</a>
<a name="ln3159">    return TRUE;</a>
<a name="ln3160">  }</a>
<a name="ln3161"> </a>
<a name="ln3162">  // only non-zero if mask_display was set by an _earlier_ module</a>
<a name="ln3163">  const dt_dev_pixelpipe_display_mask_t mask_display = piece-&gt;pipe-&gt;mask_display;</a>
<a name="ln3164"> </a>
<a name="ln3165">  // does user want us to display a specific channel?</a>
<a name="ln3166">  const dt_dev_pixelpipe_display_mask_t request_mask_display</a>
<a name="ln3167">      = (self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module) &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe)</a>
<a name="ln3168">         &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL))</a>
<a name="ln3169">            ? self-&gt;request_mask_display</a>
<a name="ln3170">            : DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln3171"> </a>
<a name="ln3172">  // check if we only should blend lightness channel. will affect only Lab space</a>
<a name="ln3173">  const int blendflag = self-&gt;flags() &amp; IOP_FLAGS_BLEND_ONLY_LIGHTNESS;</a>
<a name="ln3174"> </a>
<a name="ln3175">  // get channel max values depending on colorspace</a>
<a name="ln3176">  const dt_iop_colorspace_type_t cst = dt_iop_module_colorspace(self);</a>
<a name="ln3177"> </a>
<a name="ln3178">  // check if mask should be suppressed temporarily (i.e. just set to global</a>
<a name="ln3179">  // opacity value)</a>
<a name="ln3180">  const _Bool suppress_mask = self-&gt;suppress_mask &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)</a>
<a name="ln3181">                              &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe) &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL);</a>
<a name="ln3182">  const _Bool mask_feather = d-&gt;feathering_radius &gt; 0.1f;</a>
<a name="ln3183">  const _Bool mask_blur = d-&gt;blur_radius &gt; 0.1f;</a>
<a name="ln3184">  const _Bool mask_tone_curve = fabsf(d-&gt;contrast) &gt;= 0.01f || fabsf(d-&gt;brightness) &gt;= 0.01f;</a>
<a name="ln3185"> </a>
<a name="ln3186">  // get the clipped opacity value  0 - 1</a>
<a name="ln3187">  const float opacity = fminf(fmaxf(0.0f, (d-&gt;opacity / 100.0f)), 1.0f);</a>
<a name="ln3188"> </a>
<a name="ln3189">  // allocate space for blend mask</a>
<a name="ln3190">  float *_mask = dt_alloc_align(64, buffsize * sizeof(float));</a>
<a name="ln3191">  if(!_mask)</a>
<a name="ln3192">  {</a>
<a name="ln3193">    dt_control_log(_(&quot;could not allocate buffer for blending&quot;));</a>
<a name="ln3194">    return FALSE;</a>
<a name="ln3195">  }</a>
<a name="ln3196">  float *const mask = _mask;</a>
<a name="ln3197"> </a>
<a name="ln3198">  // setup some kernels</a>
<a name="ln3199">  int kernel_mask;</a>
<a name="ln3200">  int kernel;</a>
<a name="ln3201">  switch(cst)</a>
<a name="ln3202">  {</a>
<a name="ln3203">    case iop_cs_RAW:</a>
<a name="ln3204">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_RAW;</a>
<a name="ln3205">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_RAW;</a>
<a name="ln3206">      break;</a>
<a name="ln3207"> </a>
<a name="ln3208">    case iop_cs_rgb:</a>
<a name="ln3209">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_rgb;</a>
<a name="ln3210">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_rgb;</a>
<a name="ln3211">      break;</a>
<a name="ln3212"> </a>
<a name="ln3213">    case iop_cs_Lab:</a>
<a name="ln3214">    default:</a>
<a name="ln3215">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_Lab;</a>
<a name="ln3216">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_Lab;</a>
<a name="ln3217">      break;</a>
<a name="ln3218">  }</a>
<a name="ln3219">  int kernel_mask_tone_curve = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_tone_curve;</a>
<a name="ln3220">  int kernel_set_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_set_mask;</a>
<a name="ln3221">  int kernel_display_channel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_display_channel;</a>
<a name="ln3222"> </a>
<a name="ln3223">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3224">  const int offs[2] = { xoffs, yoffs };</a>
<a name="ln3225">  const size_t sizes[] = { ROUNDUPWD(owidth), ROUNDUPHT(oheight), 1 };</a>
<a name="ln3226"> </a>
<a name="ln3227">  cl_int err = -999;</a>
<a name="ln3228">  cl_mem dev_m = NULL;</a>
<a name="ln3229">  cl_mem dev_mask_1 = NULL;</a>
<a name="ln3230">  cl_mem dev_mask_2 = NULL;</a>
<a name="ln3231">  cl_mem dev_tmp = NULL;</a>
<a name="ln3232">  size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3233">  size_t region[] = { owidth, oheight, 1 };</a>
<a name="ln3234"> </a>
<a name="ln3235">  // copy blend parameters to constant device memory</a>
<a name="ln3236">  dev_m = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 4 * DEVELOP_BLENDIF_SIZE,</a>
<a name="ln3237">                                                 d-&gt;blendif_parameters);</a>
<a name="ln3238">  if(dev_m == NULL) goto error;</a>
<a name="ln3239"> </a>
<a name="ln3240">  dev_mask_1 = dt_opencl_alloc_device(devid, owidth, oheight, sizeof(float));</a>
<a name="ln3241">  if(dev_mask_1 == NULL) goto error;</a>
<a name="ln3242"> </a>
<a name="ln3243">  if(mask_mode == DEVELOP_MASK_ENABLED || suppress_mask)</a>
<a name="ln3244">  {</a>
<a name="ln3245">    // blend uniformly (no drawn or parametric mask)</a>
<a name="ln3246"> </a>
<a name="ln3247">    // set dev_mask with global opacity value</a>
<a name="ln3248">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 0, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3249">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 1, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3250">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 2, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3251">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 3, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3252">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_set_mask, sizes);</a>
<a name="ln3253">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3254">  }</a>
<a name="ln3255">  else if(mask_mode &amp; DEVELOP_MASK_RASTER)</a>
<a name="ln3256">  {</a>
<a name="ln3257">    /* use a raster mask from another module earlier in the pipe */</a>
<a name="ln3258">    gboolean free_mask = FALSE; // if no transformations were applied we get the cached original back</a>
<a name="ln3259">    float *raster_mask = dt_dev_get_raster_mask(piece-&gt;pipe, self-&gt;raster_mask.sink.source, self-&gt;raster_mask.sink.id,</a>
<a name="ln3260">                                                self, &amp;free_mask);</a>
<a name="ln3261"> </a>
<a name="ln3262">    if(raster_mask)</a>
<a name="ln3263">    {</a>
<a name="ln3264">      // invert if required</a>
<a name="ln3265">      if(d-&gt;raster_mask_invert)</a>
<a name="ln3266">#ifdef _OPENMP</a>
<a name="ln3267">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln3268">#endif</a>
<a name="ln3269">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = (1.0 - raster_mask[i]) * opacity;</a>
<a name="ln3270">      else</a>
<a name="ln3271">#ifdef _OPENMP</a>
<a name="ln3272">  #pragma omp parallel for default(none) shared(raster_mask)</a>
<a name="ln3273">#endif</a>
<a name="ln3274">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = raster_mask[i] * opacity;</a>
<a name="ln3275">      if(free_mask) dt_free_align(raster_mask);</a>
<a name="ln3276">    }</a>
<a name="ln3277">    else</a>
<a name="ln3278">    {</a>
<a name="ln3279">      // fallback for when the raster mask couldn't be applied</a>
<a name="ln3280">      const float value = d-&gt;raster_mask_invert ? 0.0 : 1.0;</a>
<a name="ln3281">#ifdef _OPENMP</a>
<a name="ln3282">  #pragma omp parallel for default(none)</a>
<a name="ln3283">#endif</a>
<a name="ln3284">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = value;</a>
<a name="ln3285">    }</a>
<a name="ln3286"> </a>
<a name="ln3287">    err = dt_opencl_write_host_to_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3288">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3289">  }</a>
<a name="ln3290">  else</a>
<a name="ln3291">  {</a>
<a name="ln3292">    // we blend with a drawn and/or parametric mask</a>
<a name="ln3293"> </a>
<a name="ln3294">    // get the drawn mask if there is one</a>
<a name="ln3295">    dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, d-&gt;mask_id);</a>
<a name="ln3296"> </a>
<a name="ln3297">    if(form &amp;&amp; (!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln3298">    {</a>
<a name="ln3299">      dt_masks_group_render_roi(self, piece, form, roi_out, mask);</a>
<a name="ln3300"> </a>
<a name="ln3301">      if(d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS)</a>
<a name="ln3302">      {</a>
<a name="ln3303">        // if we have a mask and this flag is set -&gt; invert the mask</a>
<a name="ln3304">#ifdef _OPENMP</a>
<a name="ln3305">  #pragma omp parallel for default(none)</a>
<a name="ln3306">#endif</a>
<a name="ln3307">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = 1.0f - mask[i];</a>
<a name="ln3308">      }</a>
<a name="ln3309">    }</a>
<a name="ln3310">    else if((!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln3311">    {</a>
<a name="ln3312">      // no form defined but drawn mask active</a>
<a name="ln3313">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln3314">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS) ? 0.0f : 1.0f;</a>
<a name="ln3315">#ifdef _OPENMP</a>
<a name="ln3316">  #pragma omp parallel for default(none)</a>
<a name="ln3317">#endif</a>
<a name="ln3318">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln3319">    }</a>
<a name="ln3320">    else</a>
<a name="ln3321">    {</a>
<a name="ln3322">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln3323">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln3324">#ifdef _OPENMP</a>
<a name="ln3325">  #pragma omp parallel for default(none)</a>
<a name="ln3326">#endif</a>
<a name="ln3327">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln3328">    }</a>
<a name="ln3329"> </a>
<a name="ln3330">    // write mask from host to device</a>
<a name="ln3331">    dev_mask_2 = dt_opencl_alloc_device(devid, owidth, oheight, sizeof(float));</a>
<a name="ln3332">    if(dev_mask_2 == NULL) goto error;</a>
<a name="ln3333">    err = dt_opencl_write_host_to_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3334">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3335"> </a>
<a name="ln3336">    // The following call to clFinish() works around a bug in some OpenCL</a>
<a name="ln3337">    // drivers (namely AMD).</a>
<a name="ln3338">    // Without this synchronization point, reads to dev_in would often not</a>
<a name="ln3339">    // return the correct value.</a>
<a name="ln3340">    // This depends on the module after which blending is called. One of the</a>
<a name="ln3341">    // affected ones is sharpen.</a>
<a name="ln3342">    dt_opencl_finish(devid);</a>
<a name="ln3343"> </a>
<a name="ln3344">    // get parametric mask (if any) and apply global opacity</a>
<a name="ln3345">    const unsigned blendif = d-&gt;blendif;</a>
<a name="ln3346">    const unsigned int mask_combine = d-&gt;mask_combine;</a>
<a name="ln3347">    dt_opencl_set_kernel_arg(devid, kernel_mask, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3348">    dt_opencl_set_kernel_arg(devid, kernel_mask, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3349">    dt_opencl_set_kernel_arg(devid, kernel_mask, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3350">    dt_opencl_set_kernel_arg(devid, kernel_mask, 3, sizeof(cl_mem), (void *)&amp;dev_mask_2);</a>
<a name="ln3351">    dt_opencl_set_kernel_arg(devid, kernel_mask, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3352">    dt_opencl_set_kernel_arg(devid, kernel_mask, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3353">    dt_opencl_set_kernel_arg(devid, kernel_mask, 6, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3354">    dt_opencl_set_kernel_arg(devid, kernel_mask, 7, sizeof(unsigned), (void *)&amp;blendif);</a>
<a name="ln3355">    dt_opencl_set_kernel_arg(devid, kernel_mask, 8, sizeof(cl_mem), (void *)&amp;dev_m);</a>
<a name="ln3356">    dt_opencl_set_kernel_arg(devid, kernel_mask, 9, sizeof(unsigned), (void *)&amp;mask_mode);</a>
<a name="ln3357">    dt_opencl_set_kernel_arg(devid, kernel_mask, 10, sizeof(unsigned), (void *)&amp;mask_combine);</a>
<a name="ln3358">    dt_opencl_set_kernel_arg(devid, kernel_mask, 11, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3359">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_mask, sizes);</a>
<a name="ln3360">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3361"> </a>
<a name="ln3362">    if(mask_feather)</a>
<a name="ln3363">    {</a>
<a name="ln3364">      int w = (int)(2 * d-&gt;feathering_radius * roi_out-&gt;scale / piece-&gt;iscale + 0.5f);</a>
<a name="ln3365">      if (w &lt; 1)</a>
<a name="ln3366">        w = 1;</a>
<a name="ln3367">      float sqrt_eps = 1.f;</a>
<a name="ln3368">      float guide_weight = 1.f;</a>
<a name="ln3369">      switch(cst)</a>
<a name="ln3370">      {</a>
<a name="ln3371">      case iop_cs_rgb:</a>
<a name="ln3372">        guide_weight = 100.f;</a>
<a name="ln3373">        break;</a>
<a name="ln3374">      case iop_cs_Lab:</a>
<a name="ln3375">        guide_weight = 1.f;</a>
<a name="ln3376">        break;</a>
<a name="ln3377">      case iop_cs_RAW:</a>
<a name="ln3378">      default:</a>
<a name="ln3379">        assert(0);</a>
<a name="ln3380">      }</a>
<a name="ln3381">      cl_mem guide = d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN ? dev_in : dev_out;</a>
<a name="ln3382">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN)</a>
<a name="ln3383">      {</a>
<a name="ln3384">        guide = dt_opencl_alloc_device(devid, owidth, oheight, 4 * sizeof(float));</a>
<a name="ln3385">        if(guide == NULL) goto error;</a>
<a name="ln3386">        size_t origin_1[] = { xoffs, yoffs, 0 };</a>
<a name="ln3387">        size_t origin_2[] = { 0, 0, 0 };</a>
<a name="ln3388">        err = dt_opencl_enqueue_copy_image(devid, dev_in, guide, origin_2, origin_1, region);</a>
<a name="ln3389">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3390">      }</a>
<a name="ln3391">      guided_filter_cl(devid, guide, dev_mask_2, dev_mask_1, owidth, oheight, ch, w, sqrt_eps, guide_weight, 0.f,</a>
<a name="ln3392">                       1.f);</a>
<a name="ln3393">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN) dt_opencl_release_mem_object(guide);</a>
<a name="ln3394">    }</a>
<a name="ln3395">    else</a>
<a name="ln3396">    {</a>
<a name="ln3397">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3398">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3399">      dev_mask_2 = tmp;</a>
<a name="ln3400">    }</a>
<a name="ln3401"> </a>
<a name="ln3402">    if(mask_blur)</a>
<a name="ln3403">    {</a>
<a name="ln3404">      const float sigma = d-&gt;blur_radius * roi_out-&gt;scale / piece-&gt;iscale;</a>
<a name="ln3405">      const float mmax[] = { 1.0f };</a>
<a name="ln3406">      const float mmin[] = { 0.0f };</a>
<a name="ln3407"> </a>
<a name="ln3408">      dt_gaussian_cl_t *g = dt_gaussian_init_cl(devid, owidth, oheight, 1, mmax, mmin, sigma, 0);</a>
<a name="ln3409">      if(g)</a>
<a name="ln3410">      {</a>
<a name="ln3411">        dt_gaussian_blur_cl(g, dev_mask_1, dev_mask_2);</a>
<a name="ln3412">        dt_gaussian_free_cl(g);</a>
<a name="ln3413">      }</a>
<a name="ln3414">    }</a>
<a name="ln3415">    else</a>
<a name="ln3416">    {</a>
<a name="ln3417">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3418">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3419">      dev_mask_2 = tmp;</a>
<a name="ln3420">    }</a>
<a name="ln3421"> </a>
<a name="ln3422">    if(mask_tone_curve)</a>
<a name="ln3423">    {</a>
<a name="ln3424">      const float e = expf(3.f * d-&gt;contrast);</a>
<a name="ln3425">      const float brightness = d-&gt;brightness;</a>
<a name="ln3426">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 0, sizeof(cl_mem), (void *)&amp;dev_mask_2);</a>
<a name="ln3427">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 1, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3428">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 2, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3429">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 3, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3430">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 4, sizeof(float), (void *)&amp;e);</a>
<a name="ln3431">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 5, sizeof(float), (void *)&amp;brightness);</a>
<a name="ln3432">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 6, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3433">      err = dt_opencl_enqueue_kernel_2d(devid, kernel_mask_tone_curve, sizes);</a>
<a name="ln3434">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3435">    }</a>
<a name="ln3436">    else</a>
<a name="ln3437">    {</a>
<a name="ln3438">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3439">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3440">      dev_mask_2 = tmp;</a>
<a name="ln3441">    }</a>
<a name="ln3442"> </a>
<a name="ln3443">    // get rid of dev_mask_2</a>
<a name="ln3444">    dt_opencl_release_mem_object(dev_mask_2);</a>
<a name="ln3445">    dev_mask_2 = NULL;</a>
<a name="ln3446">  }</a>
<a name="ln3447"> </a>
<a name="ln3448">  // get temporary buffer for output image to overcome readonly/writeonly limitation</a>
<a name="ln3449">  dev_tmp = dt_opencl_alloc_device(devid, owidth, oheight, 4 * sizeof(float));</a>
<a name="ln3450">  if(dev_tmp == NULL) goto error;</a>
<a name="ln3451"> </a>
<a name="ln3452">  err = dt_opencl_enqueue_copy_image(devid, dev_out, dev_tmp, origin, origin, region);</a>
<a name="ln3453">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3454"> </a>
<a name="ln3455">  if(request_mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln3456">  {</a>
<a name="ln3457">    // let us display a specific channel</a>
<a name="ln3458">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3459">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3460">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3461">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 3, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3462">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3463">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3464">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 6, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3465">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 7, sizeof(int), (void *)&amp;request_mask_display);</a>
<a name="ln3466">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_display_channel, sizes);</a>
<a name="ln3467">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3468">  }</a>
<a name="ln3469">  else</a>
<a name="ln3470">  {</a>
<a name="ln3471">    // apply blending with per-pixel opacity value as defined in dev_mask_1</a>
<a name="ln3472">    const unsigned int blend_mode = d-&gt;blend_mode;</a>
<a name="ln3473">    dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3474">    dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3475">    dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3476">    dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3477">    dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3478">    dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3479">    dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(unsigned), (void *)&amp;blend_mode);</a>
<a name="ln3480">    dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(int), (void *)&amp;blendflag);</a>
<a name="ln3481">    dt_opencl_set_kernel_arg(devid, kernel, 8, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3482">    dt_opencl_set_kernel_arg(devid, kernel, 9, sizeof(int), (void *)&amp;mask_display);</a>
<a name="ln3483">    err = dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln3484">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3485">  }</a>
<a name="ln3486"> </a>
<a name="ln3487">  // register if _this_ module should expose mask or display channel</a>
<a name="ln3488">  if(request_mask_display &amp; (DT_DEV_PIXELPIPE_DISPLAY_MASK | DT_DEV_PIXELPIPE_DISPLAY_CHANNEL))</a>
<a name="ln3489">  {</a>
<a name="ln3490">    piece-&gt;pipe-&gt;mask_display = request_mask_display;</a>
<a name="ln3491">  }</a>
<a name="ln3492"> </a>
<a name="ln3493"> </a>
<a name="ln3494">  // check if we should store the mask for export or use in subsequent modules</a>
<a name="ln3495">  // TODO: should we skip raster masks?</a>
<a name="ln3496">  if(piece-&gt;pipe-&gt;store_all_raster_masks || dt_iop_is_raster_mask_used(self, 0))</a>
<a name="ln3497">  {</a>
<a name="ln3498">    //  get back final mask from the device to store it for later use</a>
<a name="ln3499">    if(!(mask_mode &amp; DEVELOP_MASK_RASTER))</a>
<a name="ln3500">    {</a>
<a name="ln3501">      err = dt_opencl_read_buffer_from_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3502">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3503">    }</a>
<a name="ln3504">    g_hash_table_replace(piece-&gt;raster_masks, GINT_TO_POINTER(0), _mask);</a>
<a name="ln3505">    }</a>
<a name="ln3506">  else</a>
<a name="ln3507">  {</a>
<a name="ln3508">    g_hash_table_remove(piece-&gt;raster_masks, GINT_TO_POINTER(0));</a>
<a name="ln3509">    dt_free_align(_mask);</a>
<a name="ln3510">  }</a>
<a name="ln3511"> </a>
<a name="ln3512">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3513">  dt_opencl_release_mem_object(dev_mask_1);</a>
<a name="ln3514">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3515">  return TRUE;</a>
<a name="ln3516"> </a>
<a name="ln3517">error:</a>
<a name="ln3518">  dt_free_align(_mask);</a>
<a name="ln3519">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3520">  dt_opencl_release_mem_object(dev_mask_1);</a>
<a name="ln3521">  dt_opencl_release_mem_object(dev_mask_2);</a>
<a name="ln3522">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3523">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_blendop] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3524">  return FALSE;</a>
<a name="ln3525">}</a>
<a name="ln3526">#endif</a>
<a name="ln3527"> </a>
<a name="ln3528">/** global init of blendops */</a>
<a name="ln3529">dt_blendop_cl_global_t *dt_develop_blend_init_cl_global(void)</a>
<a name="ln3530">{</a>
<a name="ln3531">#ifdef HAVE_OPENCL</a>
<a name="ln3532">  dt_blendop_cl_global_t *b = (dt_blendop_cl_global_t *)calloc(1, sizeof(dt_blendop_cl_global_t));</a>
<a name="ln3533"> </a>
<a name="ln3534">  const int program = 3; // blendop.cl, from programs.conf</a>
<a name="ln3535">  b-&gt;kernel_blendop_mask_Lab = dt_opencl_create_kernel(program, &quot;blendop_mask_Lab&quot;);</a>
<a name="ln3536">  b-&gt;kernel_blendop_mask_RAW = dt_opencl_create_kernel(program, &quot;blendop_mask_RAW&quot;);</a>
<a name="ln3537">  b-&gt;kernel_blendop_mask_rgb = dt_opencl_create_kernel(program, &quot;blendop_mask_rgb&quot;);</a>
<a name="ln3538">  b-&gt;kernel_blendop_Lab = dt_opencl_create_kernel(program, &quot;blendop_Lab&quot;);</a>
<a name="ln3539">  b-&gt;kernel_blendop_RAW = dt_opencl_create_kernel(program, &quot;blendop_RAW&quot;);</a>
<a name="ln3540">  b-&gt;kernel_blendop_rgb = dt_opencl_create_kernel(program, &quot;blendop_rgb&quot;);</a>
<a name="ln3541">  b-&gt;kernel_blendop_mask_tone_curve = dt_opencl_create_kernel(program, &quot;blendop_mask_tone_curve&quot;);</a>
<a name="ln3542">  b-&gt;kernel_blendop_set_mask = dt_opencl_create_kernel(program, &quot;blendop_set_mask&quot;);</a>
<a name="ln3543">  b-&gt;kernel_blendop_display_channel = dt_opencl_create_kernel(program, &quot;blendop_display_channel&quot;);</a>
<a name="ln3544">  return b;</a>
<a name="ln3545">#else</a>
<a name="ln3546">  return NULL;</a>
<a name="ln3547">#endif</a>
<a name="ln3548">}</a>
<a name="ln3549"> </a>
<a name="ln3550">/** global cleanup of blendops */</a>
<a name="ln3551">void dt_develop_blend_free_cl_global(dt_blendop_cl_global_t *b)</a>
<a name="ln3552">{</a>
<a name="ln3553">#ifdef HAVE_OPENCL</a>
<a name="ln3554">  if(!b) return;</a>
<a name="ln3555"> </a>
<a name="ln3556">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_Lab);</a>
<a name="ln3557">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_RAW);</a>
<a name="ln3558">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_rgb);</a>
<a name="ln3559">  dt_opencl_free_kernel(b-&gt;kernel_blendop_Lab);</a>
<a name="ln3560">  dt_opencl_free_kernel(b-&gt;kernel_blendop_RAW);</a>
<a name="ln3561">  dt_opencl_free_kernel(b-&gt;kernel_blendop_rgb);</a>
<a name="ln3562">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_tone_curve);</a>
<a name="ln3563">  dt_opencl_free_kernel(b-&gt;kernel_blendop_set_mask);</a>
<a name="ln3564">  dt_opencl_free_kernel(b-&gt;kernel_blendop_display_channel);</a>
<a name="ln3565"> </a>
<a name="ln3566">  free(b);</a>
<a name="ln3567">#endif</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">/** blend version */</a>
<a name="ln3571">int dt_develop_blend_version(void)</a>
<a name="ln3572">{</a>
<a name="ln3573">  return DEVELOP_BLEND_VERSION;</a>
<a name="ln3574">}</a>
<a name="ln3575"> </a>
<a name="ln3576">/** report back specific memory requirements for blend step (only relevant for OpenCL path) */</a>
<a name="ln3577">void tiling_callback_blendop(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln3578">                             const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln3579">                             struct dt_develop_tiling_t *tiling)</a>
<a name="ln3580">{</a>
<a name="ln3581">  tiling-&gt;factor = 3.25f; // in + out + tmp + one quarter buffer for the mask</a>
<a name="ln3582">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln3583">  tiling-&gt;overhead = 0;</a>
<a name="ln3584">  tiling-&gt;overlap = 0;</a>
<a name="ln3585">  tiling-&gt;xalign = 1;</a>
<a name="ln3586">  tiling-&gt;yalign = 1;</a>
<a name="ln3587">}</a>
<a name="ln3588"> </a>
<a name="ln3589">/** check if content of params is all zero, indicating a non-initialized set of</a>
<a name="ln3590">   blend parameters</a>
<a name="ln3591">    which needs special care. */</a>
<a name="ln3592">gboolean dt_develop_blend_params_is_all_zero(const void *params, size_t length)</a>
<a name="ln3593">{</a>
<a name="ln3594">  const char *data = (const char *)params;</a>
<a name="ln3595"> </a>
<a name="ln3596">  for(size_t k = 0; k &lt; length; k++)</a>
<a name="ln3597">    if(data[k]) return FALSE;</a>
<a name="ln3598"> </a>
<a name="ln3599">  return TRUE;</a>
<a name="ln3600">}</a>
<a name="ln3601"> </a>
<a name="ln3602">/** update blendop params from older versions */</a>
<a name="ln3603">int dt_develop_blend_legacy_params(dt_iop_module_t *module, const void *const old_params,</a>
<a name="ln3604">                                   const int old_version, void *new_params, const int new_version,</a>
<a name="ln3605">                                   const int length)</a>
<a name="ln3606">{</a>
<a name="ln3607">  // first deal with all-zero parmameter sets, regardless of version number.</a>
<a name="ln3608">  // these occurred in previous</a>
<a name="ln3609">  // darktable versions when modules</a>
<a name="ln3610">  // without blend support stored zero-initialized data in history stack. that's</a>
<a name="ln3611">  // no problem unless the module</a>
<a name="ln3612">  // gets blend</a>
<a name="ln3613">  // support later (e.g. module exposure). remedy: we simply initialize with the</a>
<a name="ln3614">  // current default blend params</a>
<a name="ln3615">  // in this case.</a>
<a name="ln3616">  if(dt_develop_blend_params_is_all_zero(old_params, length))</a>
<a name="ln3617">  {</a>
<a name="ln3618">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3619">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3620"> </a>
<a name="ln3621">    *n = *d;</a>
<a name="ln3622">    return 0;</a>
<a name="ln3623">  }</a>
<a name="ln3624"> </a>
<a name="ln3625">  if(old_version == 1 &amp;&amp; new_version == 9)</a>
<a name="ln3626">  {</a>
<a name="ln3627">    if(length != sizeof(dt_develop_blend_params1_t)) return 1;</a>
<a name="ln3628"> </a>
<a name="ln3629">    dt_develop_blend_params1_t *o = (dt_develop_blend_params1_t *)old_params;</a>
<a name="ln3630">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3631">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3632"> </a>
<a name="ln3633">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3634">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3635">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3636">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3637">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3638">    return 0;</a>
<a name="ln3639">  }</a>
<a name="ln3640"> </a>
<a name="ln3641">  if(old_version == 2 &amp;&amp; new_version == 9)</a>
<a name="ln3642">  {</a>
<a name="ln3643">    if(length != sizeof(dt_develop_blend_params2_t)) return 1;</a>
<a name="ln3644"> </a>
<a name="ln3645">    dt_develop_blend_params2_t *o = (dt_develop_blend_params2_t *)old_params;</a>
<a name="ln3646">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3647">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3648"> </a>
<a name="ln3649">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3650">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3651">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3652">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3653">                        : 0;</a>
<a name="ln3654">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3655">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3656">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3657">    n-&gt;blendif = o-&gt;blendif &amp; 0xff; // only just in case: knock out all bits</a>
<a name="ln3658">                                    // which were undefined in version</a>
<a name="ln3659">                                    // 2; also switch off old &quot;active&quot; bit</a>
<a name="ln3660">    for(int i = 0; i &lt; (4 * 8); i++) n-&gt;blendif_parameters[i] = o-&gt;blendif_parameters[i];</a>
<a name="ln3661"> </a>
<a name="ln3662">    return 0;</a>
<a name="ln3663">  }</a>
<a name="ln3664"> </a>
<a name="ln3665">  if(old_version == 3 &amp;&amp; new_version == 9)</a>
<a name="ln3666">  {</a>
<a name="ln3667">    if(length != sizeof(dt_develop_blend_params3_t)) return 1;</a>
<a name="ln3668"> </a>
<a name="ln3669">    dt_develop_blend_params3_t *o = (dt_develop_blend_params3_t *)old_params;</a>
<a name="ln3670">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3671">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3672"> </a>
<a name="ln3673">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3674">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3675">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3676">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3677">                        : 0;</a>
<a name="ln3678">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3679">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3680">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3681">    n-&gt;blendif = o-&gt;blendif &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active); // knock out old unused &quot;active&quot; flag</a>
<a name="ln3682">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3683"> </a>
<a name="ln3684">    return 0;</a>
<a name="ln3685">  }</a>
<a name="ln3686"> </a>
<a name="ln3687">  if(old_version == 4 &amp;&amp; new_version == 9)</a>
<a name="ln3688">  {</a>
<a name="ln3689">    if(length != sizeof(dt_develop_blend_params4_t)) return 1;</a>
<a name="ln3690"> </a>
<a name="ln3691">    dt_develop_blend_params4_t *o = (dt_develop_blend_params4_t *)old_params;</a>
<a name="ln3692">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3693">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3694"> </a>
<a name="ln3695">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3696">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3697">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3698">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3699">                        : 0;</a>
<a name="ln3700">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3701">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3702">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3703">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3704">    n-&gt;blendif = o-&gt;blendif &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active); // knock out old unused &quot;active&quot; flag</a>
<a name="ln3705">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3706"> </a>
<a name="ln3707">    return 0;</a>
<a name="ln3708">  }</a>
<a name="ln3709"> </a>
<a name="ln3710">  if(old_version == 5 &amp;&amp; new_version == 9)</a>
<a name="ln3711">  {</a>
<a name="ln3712">    if(length != sizeof(dt_develop_blend_params5_t)) return 1;</a>
<a name="ln3713"> </a>
<a name="ln3714">    dt_develop_blend_params5_t *o = (dt_develop_blend_params5_t *)old_params;</a>
<a name="ln3715">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3716">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3717"> </a>
<a name="ln3718">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3719">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3720">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3721">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3722">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3723">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3724">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3725">    // this is needed as version 5 contained a bug which screwed up history</a>
<a name="ln3726">    // stacks of even older</a>
<a name="ln3727">    // versions. potentially bad history stacks can be identified by an active</a>
<a name="ln3728">    // bit no. 32 in blendif.</a>
<a name="ln3729">    n-&gt;blendif = (o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active) ? o-&gt;blendif | 31 : o-&gt;blendif)</a>
<a name="ln3730">                 &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active);</a>
<a name="ln3731">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3732"> </a>
<a name="ln3733">    return 0;</a>
<a name="ln3734">  }</a>
<a name="ln3735"> </a>
<a name="ln3736">  if(old_version == 6 &amp;&amp; new_version == 9)</a>
<a name="ln3737">  {</a>
<a name="ln3738">    if(length != sizeof(dt_develop_blend_params6_t)) return 1;</a>
<a name="ln3739"> </a>
<a name="ln3740">    dt_develop_blend_params6_t *o = (dt_develop_blend_params6_t *)old_params;</a>
<a name="ln3741">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3742">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3743"> </a>
<a name="ln3744">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3745">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3746">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3747">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3748">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3749">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3750">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3751">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3752">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3753">    return 0;</a>
<a name="ln3754">  }</a>
<a name="ln3755"> </a>
<a name="ln3756">  if(old_version == 7 &amp;&amp; new_version == 9)</a>
<a name="ln3757">  {</a>
<a name="ln3758">    if(length != sizeof(dt_develop_blend_params7_t)) return 1;</a>
<a name="ln3759"> </a>
<a name="ln3760">    dt_develop_blend_params7_t *o = (dt_develop_blend_params7_t *)old_params;</a>
<a name="ln3761">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3762">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3763"> </a>
<a name="ln3764">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3765">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3766">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3767">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3768">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3769">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3770">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3771">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3772">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3773">    return 0;</a>
<a name="ln3774">  }</a>
<a name="ln3775"> </a>
<a name="ln3776">  if(old_version == 8 &amp;&amp; new_version == 9)</a>
<a name="ln3777">  {</a>
<a name="ln3778">    if(length != sizeof(dt_develop_blend_params8_t)) return 1;</a>
<a name="ln3779"> </a>
<a name="ln3780">    dt_develop_blend_params8_t *o = (dt_develop_blend_params8_t *)old_params;</a>
<a name="ln3781">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3782">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3783"> </a>
<a name="ln3784">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3785">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3786">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3787">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3788">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3789">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3790">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3791">    n-&gt;feathering_radius = o-&gt;feathering_radius;</a>
<a name="ln3792">    n-&gt;feathering_guide = o-&gt;feathering_guide;</a>
<a name="ln3793">    n-&gt;blur_radius = o-&gt;blur_radius;</a>
<a name="ln3794">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln3795">    n-&gt;brightness = o-&gt;brightness;</a>
<a name="ln3796">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3797">    return 0;</a>
<a name="ln3798">  }</a>
<a name="ln3799"> </a>
<a name="ln3800">  return 1;</a>
<a name="ln3801">}</a>
<a name="ln3802"> </a>
<a name="ln3803">int dt_develop_blend_legacy_params_from_so(dt_iop_module_so_t *module_so, const void *const old_params,</a>
<a name="ln3804">                                           const int old_version, void *new_params, const int new_version,</a>
<a name="ln3805">                                           const int length)</a>
<a name="ln3806">{</a>
<a name="ln3807">  // we need a dt_iop_module_t for dt_develop_blend_legacy_params()</a>
<a name="ln3808">  dt_iop_module_t *module;</a>
<a name="ln3809">  module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln3810">  if(dt_iop_load_module_by_so(module, module_so, NULL))</a>
<a name="ln3811">  {</a>
<a name="ln3812">    free(module);</a>
<a name="ln3813">    return 1;</a>
<a name="ln3814">  }</a>
<a name="ln3815"> </a>
<a name="ln3816">  if(module-&gt;params_size == 0)</a>
<a name="ln3817">  {</a>
<a name="ln3818">    dt_iop_cleanup_module(module);</a>
<a name="ln3819">    free(module);</a>
<a name="ln3820">    return 1;</a>
<a name="ln3821">  }</a>
<a name="ln3822"> </a>
<a name="ln3823">  // convert the old blend params to new</a>
<a name="ln3824">  int res = dt_develop_blend_legacy_params(module, old_params, old_version,</a>
<a name="ln3825">                                           new_params, dt_develop_blend_version(),</a>
<a name="ln3826">                                           length);</a>
<a name="ln3827">  dt_iop_cleanup_module(module);</a>
<a name="ln3828">  free(module);</a>
<a name="ln3829">  return res;</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832">// tools/update_modelines.sh</a>
<a name="ln3833">// remove-trailing-space on;</a>
<a name="ln3834">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3835">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3836">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1190"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1701"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1771"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="3113"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3117"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_remove' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3504"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3508"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_remove' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3535"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'b'. Check lines: 3535, 3532.</p></div>
<div class="balloon" rel="3816"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 3816, 3809.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
