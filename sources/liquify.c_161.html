
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014, 2015 marcello perathoner</a>
<a name="ln4">    copyright (c) 2015, 2016 pascal obry</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#ifdef HAVE_CONFIG_H</a>
<a name="ln21">#include &quot;config.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln24">#include &quot;common/interpolation.h&quot;</a>
<a name="ln25">#include &quot;common/opencl.h&quot;</a>
<a name="ln26">#include &quot;control/conf.h&quot;</a>
<a name="ln27">#include &quot;control/control.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln32">#include &lt;assert.h&gt;</a>
<a name="ln33">#include &lt;cairo.h&gt;</a>
<a name="ln34">#include &lt;complex.h&gt;</a>
<a name="ln35">#include &lt;math.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef _OPENMP</a>
<a name="ln39">#include &lt;omp.h&gt;</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42">// this is the version of the modules parameters, and includes version information about compile-time dt</a>
<a name="ln43">DT_MODULE_INTROSPECTION(1, dt_iop_liquify_params_t)</a>
<a name="ln44"> </a>
<a name="ln45">#pragma GCC diagnostic ignored &quot;-Wshadow&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#define MAX_NODES 100 // max of nodes in one instance</a>
<a name="ln48"> </a>
<a name="ln49">const int   LOOKUP_OVERSAMPLE = 10;</a>
<a name="ln50">const int   INTERPOLATION_POINTS = 100; // when interpolating bezier</a>
<a name="ln51">const float STAMP_RELOCATION = 0.1;     // how many radii to move stamp forward when following a path</a>
<a name="ln52"> </a>
<a name="ln53">#define CONF_RADIUS &quot;plugins/darkroom/liquify/radius&quot;</a>
<a name="ln54">#define CONF_ANGLE &quot;plugins/darkroom/liquify/angle&quot;</a>
<a name="ln55">#define CONF_STRENGTH &quot;plugins/darkroom/liquify/strength&quot;</a>
<a name="ln56"> </a>
<a name="ln57">// enum of layers. sorted back to front.</a>
<a name="ln58"> </a>
<a name="ln59">typedef enum</a>
<a name="ln60">{</a>
<a name="ln61">  DT_LIQUIFY_LAYER_BACKGROUND,</a>
<a name="ln62">  DT_LIQUIFY_LAYER_RADIUS,</a>
<a name="ln63">  DT_LIQUIFY_LAYER_HARDNESS1,</a>
<a name="ln64">  DT_LIQUIFY_LAYER_HARDNESS2,</a>
<a name="ln65">  DT_LIQUIFY_LAYER_WARPS,</a>
<a name="ln66">  DT_LIQUIFY_LAYER_PATH,</a>
<a name="ln67">  DT_LIQUIFY_LAYER_CTRLPOINT1_HANDLE,</a>
<a name="ln68">  DT_LIQUIFY_LAYER_CTRLPOINT2_HANDLE,</a>
<a name="ln69">  DT_LIQUIFY_LAYER_RADIUSPOINT_HANDLE,</a>
<a name="ln70">  DT_LIQUIFY_LAYER_HARDNESSPOINT1_HANDLE,</a>
<a name="ln71">  DT_LIQUIFY_LAYER_HARDNESSPOINT2_HANDLE,</a>
<a name="ln72">  DT_LIQUIFY_LAYER_STRENGTHPOINT_HANDLE,</a>
<a name="ln73">  DT_LIQUIFY_LAYER_CENTERPOINT,</a>
<a name="ln74">  DT_LIQUIFY_LAYER_CTRLPOINT1,</a>
<a name="ln75">  DT_LIQUIFY_LAYER_CTRLPOINT2,</a>
<a name="ln76">  DT_LIQUIFY_LAYER_RADIUSPOINT,</a>
<a name="ln77">  DT_LIQUIFY_LAYER_HARDNESSPOINT1,</a>
<a name="ln78">  DT_LIQUIFY_LAYER_HARDNESSPOINT2,</a>
<a name="ln79">  DT_LIQUIFY_LAYER_STRENGTHPOINT,</a>
<a name="ln80">  DT_LIQUIFY_LAYER_LAST</a>
<a name="ln81">} dt_liquify_layer_enum_t;</a>
<a name="ln82"> </a>
<a name="ln83">typedef enum</a>
<a name="ln84">{</a>
<a name="ln85">  DT_LIQUIFY_LAYER_FLAG_HIT_TEST      =  1,   ///&lt; include layer in hit testing</a>
<a name="ln86">  DT_LIQUIFY_LAYER_FLAG_PREV_SELECTED =  2,   ///&lt; show if previous node is selected</a>
<a name="ln87">  DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED =  4,   ///&lt; show if node is selected</a>
<a name="ln88">  DT_LIQUIFY_LAYER_FLAG_POINT_TOOL    =  8,   ///&lt; show if point tool active</a>
<a name="ln89">  DT_LIQUIFY_LAYER_FLAG_LINE_TOOL     = 16,   ///&lt; show if line tool active</a>
<a name="ln90">  DT_LIQUIFY_LAYER_FLAG_CURVE_TOOL    = 32,   ///&lt; show if line tool active</a>
<a name="ln91">  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL     = 64,   ///&lt; show if node tool active</a>
<a name="ln92">  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL      = 8 + 16 + 32 + 64,</a>
<a name="ln93">} dt_liquify_layer_flag_enum_t;</a>
<a name="ln94"> </a>
<a name="ln95">typedef struct</a>
<a name="ln96">{</a>
<a name="ln97">  float red, green, blue, alpha;</a>
<a name="ln98">} dt_liquify_rgba_t;</a>
<a name="ln99"> </a>
<a name="ln100">#define COLOR_NULL                 { 0.0, 0.0, 0.0, 0.8 }</a>
<a name="ln101">#define GREY                       { 0.3, 0.3, 0.3, 0.8 }</a>
<a name="ln102">#define LGREY                      { 0.8, 0.8, 0.8, 1.0 }</a>
<a name="ln103">#define COLOR_DEBUG                { 0.9, 0.9, 0.0, 1.0 }</a>
<a name="ln104">static const dt_liquify_rgba_t DT_LIQUIFY_COLOR_SELECTED = { 1.0, 1.0, 1.0, 1.0 };</a>
<a name="ln105">static const dt_liquify_rgba_t DT_LIQUIFY_COLOR_HOVER    = { 1.0, 1.0, 1.0, 0.8 };</a>
<a name="ln106"> </a>
<a name="ln107">typedef struct</a>
<a name="ln108">{</a>
<a name="ln109">  dt_liquify_layer_enum_t hover_master;    ///&lt; hover whenever master layer hovers, eg. to</a>
<a name="ln110">  dt_liquify_rgba_t fg;                    ///&lt; the foreground color for this layer</a>
<a name="ln111">  dt_liquify_rgba_t bg;                    ///&lt; the background color for this layer</a>
<a name="ln112">  double opacity;                          ///&lt; the opacity of this layer</a>
<a name="ln113">                                           ///  highlight the whole radius when only the</a>
<a name="ln114">                                           ///  radius point is hovered</a>
<a name="ln115">  dt_liquify_layer_flag_enum_t flags;      ///&lt; various flags for layer</a>
<a name="ln116">  const char *hint;                        ///&lt; hint displayed when hovering</a>
<a name="ln117">} dt_liquify_layer_t;</a>
<a name="ln118"> </a>
<a name="ln119">dt_liquify_layer_t dt_liquify_layers[] =</a>
<a name="ln120">{</a>
<a name="ln121">  { DT_LIQUIFY_LAYER_BACKGROUND,     COLOR_NULL,  COLOR_NULL, 0.0,  0,                                                                                                      },</a>
<a name="ln122">  { DT_LIQUIFY_LAYER_RADIUS,         COLOR_DEBUG, COLOR_NULL, 0.25, DT_LIQUIFY_LAYER_FLAG_ANY_TOOL,                                                                         },</a>
<a name="ln123">  { DT_LIQUIFY_LAYER_HARDNESS1,      COLOR_DEBUG, COLOR_NULL, 1.0,  0,                                                                                                      },</a>
<a name="ln124">  { DT_LIQUIFY_LAYER_HARDNESS2,      COLOR_DEBUG, COLOR_NULL, 1.0,  0,                                                                                                      },</a>
<a name="ln125">  { DT_LIQUIFY_LAYER_WARPS,          COLOR_DEBUG, LGREY,      0.5,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL,                                                                         },</a>
<a name="ln126">  { DT_LIQUIFY_LAYER_PATH,           GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL  | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln127">  { DT_LIQUIFY_LAYER_CTRLPOINT1,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL,                                                                        },</a>
<a name="ln128">  { DT_LIQUIFY_LAYER_CTRLPOINT2,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL,                                                                        },</a>
<a name="ln129">  { DT_LIQUIFY_LAYER_RADIUSPOINT,    GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL,                                                                        },</a>
<a name="ln130">  { DT_LIQUIFY_LAYER_HARDNESSPOINT1, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED,                                  },</a>
<a name="ln131">  { DT_LIQUIFY_LAYER_HARDNESSPOINT2, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED,                                  },</a>
<a name="ln132">  { DT_LIQUIFY_LAYER_STRENGTHPOINT,  GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL,                                                                         },</a>
<a name="ln133">  { DT_LIQUIFY_LAYER_CENTERPOINT,    GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL  | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln134">  { DT_LIQUIFY_LAYER_CTRLPOINT1,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln135">  { DT_LIQUIFY_LAYER_CTRLPOINT2,     GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln136">  { DT_LIQUIFY_LAYER_RADIUSPOINT,    GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       },</a>
<a name="ln137">  { DT_LIQUIFY_LAYER_HARDNESSPOINT1, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED | DT_LIQUIFY_LAYER_FLAG_HIT_TEST, },</a>
<a name="ln138">  { DT_LIQUIFY_LAYER_HARDNESSPOINT2, GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_NODE_TOOL | DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED | DT_LIQUIFY_LAYER_FLAG_HIT_TEST, },</a>
<a name="ln139">  { DT_LIQUIFY_LAYER_STRENGTHPOINT,  GREY,        LGREY,      1.0,  DT_LIQUIFY_LAYER_FLAG_ANY_TOOL  | DT_LIQUIFY_LAYER_FLAG_HIT_TEST,                                       }</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">typedef enum</a>
<a name="ln143">{</a>
<a name="ln144">  DT_LIQUIFY_UI_WIDTH_THINLINE,</a>
<a name="ln145">  DT_LIQUIFY_UI_WIDTH_THICKLINE,</a>
<a name="ln146">  DT_LIQUIFY_UI_WIDTH_DOUBLELINE,</a>
<a name="ln147">  DT_LIQUIFY_UI_WIDTH_GIZMO,</a>
<a name="ln148">  DT_LIQUIFY_UI_WIDTH_GIZMO_SMALL,</a>
<a name="ln149">  DT_LIQUIFY_UI_WIDTH_DEFAULT_RADIUS,</a>
<a name="ln150">  DT_LIQUIFY_UI_WIDTH_DEFAULT_STRENGTH,</a>
<a name="ln151">  DT_LIQUIFY_UI_WIDTH_MIN_DRAG,</a>
<a name="ln152">  DT_LIQUIFY_UI_WIDTH_LAST</a>
<a name="ln153">} dt_liquify_ui_width_enum_t;</a>
<a name="ln154"> </a>
<a name="ln155">float dt_liquify_ui_widths [] =</a>
<a name="ln156">{</a>
<a name="ln157">  // value in 1/96 inch (that is: in pixels on a standard 96 dpi screen)</a>
<a name="ln158">    2.0, // DT_LIQUIFY_UI_WIDTH_THINLINE</a>
<a name="ln159">    3.0, // DT_LIQUIFY_UI_WIDTH_THICKLINE</a>
<a name="ln160">    3.0, // DT_LIQUIFY_UI_WIDTH_DOUBLELINE</a>
<a name="ln161">    9.0, // DT_LIQUIFY_UI_WIDTH_GIZMO</a>
<a name="ln162">    7.0, // DT_LIQUIFY_UI_WIDTH_GIZMO_SMALL</a>
<a name="ln163">  100.0, // DT_LIQUIFY_UI_WIDTH_DEFAULT_RADIUS,</a>
<a name="ln164">   50.0, // DT_LIQUIFY_UI_WIDTH_DEFAULT_STRENGTH,</a>
<a name="ln165">    4.0  // DT_LIQUIFY_UI_WIDTH_MIN_DRAG</a>
<a name="ln166">};</a>
<a name="ln167"> </a>
<a name="ln168">typedef enum</a>
<a name="ln169">{</a>
<a name="ln170">  DT_LIQUIFY_WARP_TYPE_LINEAR,         ///&lt; A linear warp originating from one point.</a>
<a name="ln171">  DT_LIQUIFY_WARP_TYPE_RADIAL_GROW,    ///&lt; A radial warp originating from one point.</a>
<a name="ln172">  DT_LIQUIFY_WARP_TYPE_RADIAL_SHRINK,</a>
<a name="ln173">  DT_LIQUIFY_WARP_TYPE_LAST</a>
<a name="ln174">} dt_liquify_warp_type_enum_t;</a>
<a name="ln175"> </a>
<a name="ln176">typedef enum</a>
<a name="ln177">{</a>
<a name="ln178">  DT_LIQUIFY_NODE_TYPE_CUSP,</a>
<a name="ln179">  DT_LIQUIFY_NODE_TYPE_SMOOTH,</a>
<a name="ln180">  DT_LIQUIFY_NODE_TYPE_SYMMETRICAL,</a>
<a name="ln181">  DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH,</a>
<a name="ln182">  DT_LIQUIFY_NODE_TYPE_LAST</a>
<a name="ln183">} dt_liquify_node_type_enum_t;</a>
<a name="ln184"> </a>
<a name="ln185">typedef enum</a>
<a name="ln186">{</a>
<a name="ln187">  DT_LIQUIFY_STATUS_NONE = 0,</a>
<a name="ln188">  DT_LIQUIFY_STATUS_NEW = 1,</a>
<a name="ln189">  DT_LIQUIFY_STATUS_INTERPOLATED = 2,</a>
<a name="ln190">  DT_LIQUIFY_STATUS_PREVIEW = 4,</a>
<a name="ln191">  DT_LIQUIFY_STATUS_LAST</a>
<a name="ln192">} dt_liquify_status_enum_t;</a>
<a name="ln193"> </a>
<a name="ln194">// enumerates the shapes types we use.</a>
<a name="ln195"> </a>
<a name="ln196">typedef enum</a>
<a name="ln197">{</a>
<a name="ln198">  DT_LIQUIFY_PATH_INVALIDATED = 0,</a>
<a name="ln199">  DT_LIQUIFY_PATH_MOVE_TO_V1,</a>
<a name="ln200">  DT_LIQUIFY_PATH_LINE_TO_V1,</a>
<a name="ln201">  DT_LIQUIFY_PATH_CURVE_TO_V1,</a>
<a name="ln202">} dt_liquify_path_data_enum_t;</a>
<a name="ln203"> </a>
<a name="ln204">typedef struct</a>
<a name="ln205">{</a>
<a name="ln206">  dt_liquify_path_data_enum_t type;</a>
<a name="ln207">  dt_liquify_node_type_enum_t node_type;</a>
<a name="ln208">  dt_liquify_layer_enum_t selected;</a>
<a name="ln209">  dt_liquify_layer_enum_t hovered;</a>
<a name="ln210">  int8_t prev;</a>
<a name="ln211">  int8_t idx;</a>
<a name="ln212">  int8_t next;</a>
<a name="ln213">} dt_liquify_path_header_t;</a>
<a name="ln214"> </a>
<a name="ln215">// Scalars and vectors are represented here as points because the only</a>
<a name="ln216">// thing we can reasonably distort_transform are points.</a>
<a name="ln217"> </a>
<a name="ln218">typedef struct</a>
<a name="ln219">{</a>
<a name="ln220">  float complex point;</a>
<a name="ln221">  float complex strength;   ///&lt; a point (the effective strength vector is: strength - point)</a>
<a name="ln222">  float complex radius;     ///&lt; a point (the effective radius scalar is: cabs (radius - point))</a>
<a name="ln223">  float control1;           ///&lt; range 0.0 .. 1.0 == radius</a>
<a name="ln224">  float control2;           ///&lt; range 0.0 .. 1.0 == radius</a>
<a name="ln225">  dt_liquify_warp_type_enum_t type;</a>
<a name="ln226">  dt_liquify_status_enum_t status;</a>
<a name="ln227">} dt_liquify_warp_t;</a>
<a name="ln228"> </a>
<a name="ln229">typedef struct</a>
<a name="ln230">{</a>
<a name="ln231">  float complex ctrl1;</a>
<a name="ln232">  float complex ctrl2;</a>
<a name="ln233">} dt_liquify_node_t;</a>
<a name="ln234"> </a>
<a name="ln235">// set up lots of alternative ways to get at the popular members.</a>
<a name="ln236"> </a>
<a name="ln237">typedef struct</a>
<a name="ln238">{</a>
<a name="ln239">  dt_liquify_path_header_t header;</a>
<a name="ln240">  dt_liquify_warp_t        warp;</a>
<a name="ln241">  dt_liquify_node_t        node; // extended node data</a>
<a name="ln242">} dt_liquify_path_data_t;</a>
<a name="ln243"> </a>
<a name="ln244">typedef struct</a>
<a name="ln245">{</a>
<a name="ln246">  dt_liquify_layer_enum_t layer;</a>
<a name="ln247">  dt_liquify_path_data_t *elem;</a>
<a name="ln248">} dt_liquify_hit_t;</a>
<a name="ln249"> </a>
<a name="ln250">static const dt_liquify_hit_t NOWHERE = { DT_LIQUIFY_LAYER_BACKGROUND, NULL };</a>
<a name="ln251"> </a>
<a name="ln252">typedef struct</a>
<a name="ln253">{</a>
<a name="ln254">  dt_liquify_path_data_t nodes[MAX_NODES];</a>
<a name="ln255">} dt_iop_liquify_params_t;</a>
<a name="ln256"> </a>
<a name="ln257">typedef struct</a>
<a name="ln258">{</a>
<a name="ln259">  int warp_kernel;</a>
<a name="ln260">} dt_iop_liquify_global_data_t;</a>
<a name="ln261"> </a>
<a name="ln262">typedef struct</a>
<a name="ln263">{</a>
<a name="ln264">  dt_pthread_mutex_t lock;</a>
<a name="ln265">  dt_iop_liquify_params_t params;</a>
<a name="ln266">  int node_index; // last node index inserted</a>
<a name="ln267"> </a>
<a name="ln268">  float complex last_mouse_pos;</a>
<a name="ln269">  float complex last_button1_pressed_pos;</a>
<a name="ln270">  GdkModifierType last_mouse_mods;  ///&lt; GDK modifiers at the time mouse button was pressed.</a>
<a name="ln271"> </a>
<a name="ln272">  dt_liquify_hit_t last_hit;      ///&lt; Element last hit with mouse button.</a>
<a name="ln273">  dt_liquify_hit_t dragging;      ///&lt; Element being dragged with mouse button.</a>
<a name="ln274"> </a>
<a name="ln275">  dt_liquify_path_data_t *temp;    ///&lt; Points to the element under construction or NULL.</a>
<a name="ln276">  dt_liquify_status_enum_t status; ///&lt; Various flags.</a>
<a name="ln277"> </a>
<a name="ln278">  cairo_t *fake_cr;     ///&lt; A fake cairo context for hit testing and coordinate transform.</a>
<a name="ln279"> </a>
<a name="ln280">  GtkLabel *label;</a>
<a name="ln281">  GtkToggleButton *btn_point_tool, *btn_line_tool, *btn_curve_tool, *btn_node_tool;</a>
<a name="ln282"> </a>
<a name="ln283">} dt_iop_liquify_gui_data_t;</a>
<a name="ln284"> </a>
<a name="ln285"> </a>
<a name="ln286">// this returns a translatable name</a>
<a name="ln287">const char *name()</a>
<a name="ln288">{</a>
<a name="ln289">  return _(&quot;liquify&quot;);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">int default_group()</a>
<a name="ln293">{</a>
<a name="ln294">  return IOP_GROUP_CORRECT;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">int flags()</a>
<a name="ln298">{</a>
<a name="ln299">  return IOP_FLAGS_SUPPORTS_BLENDING;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">int operation_tags()</a>
<a name="ln303">{</a>
<a name="ln304">   return IOP_TAG_DISTORT;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">/******************************************************************************/</a>
<a name="ln308">/* Code common to op-engine and gui.                                          */</a>
<a name="ln309">/******************************************************************************/</a>
<a name="ln310"> </a>
<a name="ln311">static const float get_rot(const dt_liquify_warp_type_enum_t warp_type)</a>
<a name="ln312">{</a>
<a name="ln313">  if (warp_type == DT_LIQUIFY_WARP_TYPE_RADIAL_SHRINK)</a>
<a name="ln314">    return M_PI;</a>
<a name="ln315">  else</a>
<a name="ln316">    return 0.0;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static dt_liquify_path_data_t *node_alloc (dt_iop_liquify_params_t *p, int *node_index)</a>
<a name="ln320">{</a>
<a name="ln321">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln322">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln323">    {</a>
<a name="ln324">      *node_index = k;</a>
<a name="ln325">      p-&gt;nodes[k].header.idx = k;</a>
<a name="ln326">      p-&gt;nodes[k].header.next = p-&gt;nodes[k].header.prev = -1;</a>
<a name="ln327">      p-&gt;nodes[k].header.selected = p-&gt;nodes[k].header.hovered = 0;</a>
<a name="ln328">      return &amp;p-&gt;nodes[k];</a>
<a name="ln329">    }</a>
<a name="ln330">  return NULL;</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">static dt_liquify_path_data_t *node_prev (dt_iop_liquify_params_t *p, const dt_liquify_path_data_t *n)</a>
<a name="ln334">{</a>
<a name="ln335">  if (n-&gt;header.prev == -1)</a>
<a name="ln336">    return NULL;</a>
<a name="ln337">  else</a>
<a name="ln338">    return &amp;p-&gt;nodes[n-&gt;header.prev];</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">static dt_liquify_path_data_t *node_get (dt_iop_liquify_params_t *p, const int index)</a>
<a name="ln342">{</a>
<a name="ln343">  if (index &gt; -1 &amp;&amp; index &lt; MAX_NODES)</a>
<a name="ln344">    return &amp;p-&gt;nodes[index];</a>
<a name="ln345">  else</a>
<a name="ln346">    return NULL;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">static dt_liquify_path_data_t *node_next (dt_iop_liquify_params_t *p, const dt_liquify_path_data_t *n)</a>
<a name="ln350">{</a>
<a name="ln351">  if (n-&gt;header.next == -1)</a>
<a name="ln352">    return NULL;</a>
<a name="ln353">  else</a>
<a name="ln354">    return &amp;p-&gt;nodes[n-&gt;header.next];</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">static void node_insert_before (dt_iop_liquify_params_t *p, dt_liquify_path_data_t *this, dt_liquify_path_data_t *new)</a>
<a name="ln358">{</a>
<a name="ln359">  new-&gt;header.next  = this-&gt;header.idx;</a>
<a name="ln360">  new-&gt;header.prev  = this-&gt;header.prev;</a>
<a name="ln361">  if (this-&gt;header.prev != -1)</a>
<a name="ln362">    p-&gt;nodes[this-&gt;header.prev].header.next = new-&gt;header.idx;</a>
<a name="ln363">  this-&gt;header.prev = new-&gt;header.idx;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static void node_gc (dt_iop_liquify_params_t *p)</a>
<a name="ln367">{</a>
<a name="ln368">  int last=0;</a>
<a name="ln369">  for (last=MAX_NODES-1; last&gt;0; last--)</a>
<a name="ln370">    if (p-&gt;nodes[last].header.type != DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln371">      break;</a>
<a name="ln372">  int k = 0;</a>
<a name="ln373"> </a>
<a name="ln374">  while (k&lt;=last)</a>
<a name="ln375">  {</a>
<a name="ln376">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln377">    {</a>
<a name="ln378">      for (int e=0; e&lt;last; e++)</a>
<a name="ln379">      {</a>
<a name="ln380">        //  then move slot if above position k</a>
<a name="ln381">        if (e &gt;= k)                       p-&gt;nodes[e] = p-&gt;nodes[e+1];</a>
<a name="ln382">        //  update all pointers above position k</a>
<a name="ln383">        if (e &gt;= k)                       p-&gt;nodes[e].header.idx--;</a>
<a name="ln384">        if (p-&gt;nodes[e].header.prev &gt;= k) p-&gt;nodes[e].header.prev--;</a>
<a name="ln385">        if (p-&gt;nodes[e].header.next &gt;= k) p-&gt;nodes[e].header.next--;</a>
<a name="ln386">      }</a>
<a name="ln387">      last--;</a>
<a name="ln388">    }</a>
<a name="ln389">    else</a>
<a name="ln390">      k++;</a>
<a name="ln391">  }</a>
<a name="ln392">  //  invalidate all nodes beyond the last moved one</a>
<a name="ln393">  for (int k=last+1; k&lt;MAX_NODES; k++)</a>
<a name="ln394">    p-&gt;nodes[k].header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">static void node_delete (dt_iop_liquify_params_t *p, dt_liquify_path_data_t *this)</a>
<a name="ln398">{</a>
<a name="ln399">  dt_liquify_path_data_t *prev = node_prev (p, this);</a>
<a name="ln400">  dt_liquify_path_data_t *next = node_next (p, this);</a>
<a name="ln401"> </a>
<a name="ln402">  if (!prev &amp;&amp; next)</a>
<a name="ln403">  {</a>
<a name="ln404">    next-&gt;header.prev = -1;</a>
<a name="ln405">    next-&gt;header.type = DT_LIQUIFY_PATH_MOVE_TO_V1;</a>
<a name="ln406">  }</a>
<a name="ln407">  else if (prev)</a>
<a name="ln408">  {</a>
<a name="ln409">    prev-&gt;header.next = this-&gt;header.next;</a>
<a name="ln410"> </a>
<a name="ln411">    if (next)</a>
<a name="ln412">      next-&gt;header.prev = prev-&gt;header.idx;</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  this-&gt;header.prev = this-&gt;header.next = - 1;</a>
<a name="ln416">  this-&gt;header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln417">  node_gc (p);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">static void path_delete (dt_iop_liquify_params_t *p, dt_liquify_path_data_t *this)</a>
<a name="ln421">{</a>
<a name="ln422">  dt_liquify_path_data_t *n = this;</a>
<a name="ln423"> </a>
<a name="ln424">  // clear next</a>
<a name="ln425">  while (n)</a>
<a name="ln426">  {</a>
<a name="ln427">    n-&gt;header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln428">    n = node_next (p, n);</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  // clear prev</a>
<a name="ln432">  n = this;</a>
<a name="ln433">  while (n)</a>
<a name="ln434">  {</a>
<a name="ln435">    n-&gt;header.type = DT_LIQUIFY_PATH_INVALIDATED;</a>
<a name="ln436">    n = node_prev (p, n);</a>
<a name="ln437">  }</a>
<a name="ln438">  node_gc (p);</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/**</a>
<a name="ln442"> * The functions in this group help transform between coordinate</a>
<a name="ln443"> * systems.  (In darktable nomenclature this kind of transform is</a>
<a name="ln444"> * called 'distort').</a>
<a name="ln445"> *</a>
<a name="ln446"> * The transforms between coordinate systems are not necessarily</a>
<a name="ln447"> * perspective transforms (eg. lensfun), therefore no transformation</a>
<a name="ln448"> * matrix can be specified for them, instead all points to be</a>
<a name="ln449"> * transformed have to be passed through a darktable function.</a>
<a name="ln450"> *</a>
<a name="ln451"> * Note: only points may be sensibly 'distorted'. Vectors and scalars</a>
<a name="ln452"> * don't have a meaningful 'distort'.</a>
<a name="ln453"> *</a>
<a name="ln454"> *</a>
<a name="ln455"> * Explanation of the coordinate systems used by this module:</a>
<a name="ln456"> *</a>
<a name="ln457"> * RAW: These are sensor coordinates. They go from x=0, y=0 to x=&lt;sensor</a>
<a name="ln458"> * width&gt;, y=&lt;sensor height&gt;. In a landscape picture (rotated 0°) x=0,</a>
<a name="ln459"> * y=0 will be top left. In a portrait picture (rotated 90°</a>
<a name="ln460"> * counter-clockwise) x=0, y=0 will be bottom left.</a>
<a name="ln461"> *</a>
<a name="ln462"> * The user probably wants liquified regions to be anchored to the</a>
<a name="ln463"> * motive when more transformations are added, eg. a different</a>
<a name="ln464"> * cropping of the image.  For this to work, all coordinates we store</a>
<a name="ln465"> * or pass between gui and pipe are RAW sensor coordinates.</a>
<a name="ln466"> *</a>
<a name="ln467"> *</a>
<a name="ln468"> * PIECE: These are coordinates based on the size of our pipe piece.</a>
<a name="ln469"> * They go from x=0, y=0 to x=&lt;width of piece&gt;, y=&lt;height of piece&gt;.</a>
<a name="ln470"> * PIECE coordinates should only be used while processing an image.</a>
<a name="ln471"> *</a>
<a name="ln472"> * Note: Currently (as of darktable 1.7) there are no geometry</a>
<a name="ln473"> * transforms between RAW and PIECE (our module coming very early in</a>
<a name="ln474"> * the pipe), but this may change in a later release. By allowing for</a>
<a name="ln475"> * them now, we are prepared for pipe order re-shuffeling.</a>
<a name="ln476"> *</a>
<a name="ln477"> *</a>
<a name="ln478"> * CAIRO: These are coordinates based on the cairo view.  The extent</a>
<a name="ln479"> * of the longest side of the cooked picture is normalized to 1.0.</a>
<a name="ln480"> * x=0, y=0 is the top left of the cooked picture.  x=u, y=v is the</a>
<a name="ln481"> * bottom right of a cooked picture with u&lt;=1, v&lt;=1 and either u==1 or</a>
<a name="ln482"> * v==1 depending on orientation.  Note that depending on pan and zoom</a>
<a name="ln483"> * cairo view borders and cooked picture borders may intersect in many</a>
<a name="ln484"> * ways.</a>
<a name="ln485"> *</a>
<a name="ln486"> * The normalized scale helps in choosing default values for vectors and</a>
<a name="ln487"> * radii.</a>
<a name="ln488"> *</a>
<a name="ln489"> * VIEW: These are coordinates based on the cairo view. x=0, y=0 being</a>
<a name="ln490"> * top left and x=&lt;view width&gt;, y=&lt;view height&gt; being bottom right.</a>
<a name="ln491"> * The parameters to the mouse_moved, button_pressed, and</a>
<a name="ln492"> * button_released functions are in this system.</a>
<a name="ln493"> *</a>
<a name="ln494"> * This system is also used for sizing ui-elements. They cannot be</a>
<a name="ln495"> * expressed in CAIRO coordinates because they should not change size</a>
<a name="ln496"> * when zooming the picture.</a>
<a name="ln497"> *</a>
<a name="ln498"> * To get sensible sizes for ui elements and default warps use this</a>
<a name="ln499"> * relation between the scales: CAIRO * get_zoom_scale () == VIEW.</a>
<a name="ln500"> *</a>
<a name="ln501"> */</a>
<a name="ln502"> </a>
<a name="ln503">typedef struct</a>
<a name="ln504">{</a>
<a name="ln505">  dt_develop_t *develop;</a>
<a name="ln506">  dt_dev_pixelpipe_t *pipe;</a>
<a name="ln507">  float from_scale;</a>
<a name="ln508">  float to_scale;</a>
<a name="ln509">  int pmin;</a>
<a name="ln510">  int pmax;</a>
<a name="ln511">} distort_params_t;</a>
<a name="ln512"> </a>
<a name="ln513">static void _distort_paths (const struct dt_iop_module_t *module,</a>
<a name="ln514">                            const distort_params_t *params, const dt_iop_liquify_params_t *p)</a>
<a name="ln515">{</a>
<a name="ln516">  int len = 0;</a>
<a name="ln517"> </a>
<a name="ln518">  // count nodes</a>
<a name="ln519"> </a>
<a name="ln520">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln521">  {</a>
<a name="ln522">    dt_liquify_path_data_t *data = (dt_liquify_path_data_t *) &amp;p-&gt;nodes[k];</a>
<a name="ln523">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln524">      break;</a>
<a name="ln525"> </a>
<a name="ln526">    switch (data-&gt;header.type)</a>
<a name="ln527">    {</a>
<a name="ln528">    case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln529">      len += 2;</a>
<a name="ln530">      // fall thru</a>
<a name="ln531">    case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln532">    case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln533">      len += 3;</a>
<a name="ln534">      break;</a>
<a name="ln535">    default:</a>
<a name="ln536">      break;</a>
<a name="ln537">    }</a>
<a name="ln538">  }</a>
<a name="ln539"> </a>
<a name="ln540">  // create buffer with all points</a>
<a name="ln541"> </a>
<a name="ln542">  float *buffer = malloc (2 * sizeof (float) * len);</a>
<a name="ln543">  float *b = buffer;</a>
<a name="ln544"> </a>
<a name="ln545">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln546">  {</a>
<a name="ln547">    dt_liquify_path_data_t *data = (dt_liquify_path_data_t *) &amp;p-&gt;nodes[k];</a>
<a name="ln548">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln549">      break;</a>
<a name="ln550"> </a>
<a name="ln551">    switch (data-&gt;header.type)</a>
<a name="ln552">    {</a>
<a name="ln553">    case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln554">      *b++ = creal (data-&gt;node.ctrl1) / params-&gt;from_scale;</a>
<a name="ln555">      *b++ = cimag (data-&gt;node.ctrl1) / params-&gt;from_scale;</a>
<a name="ln556">      *b++ = creal (data-&gt;node.ctrl2) / params-&gt;from_scale;</a>
<a name="ln557">      *b++ = cimag (data-&gt;node.ctrl2) / params-&gt;from_scale;</a>
<a name="ln558">      // fall thru</a>
<a name="ln559">    case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln560">    case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln561">      *b++ = creal (data-&gt;warp.point) / params-&gt;from_scale;</a>
<a name="ln562">      *b++ = cimag (data-&gt;warp.point) / params-&gt;from_scale;</a>
<a name="ln563">      *b++ = creal (data-&gt;warp.strength) / params-&gt;from_scale;</a>
<a name="ln564">      *b++ = cimag (data-&gt;warp.strength) / params-&gt;from_scale;</a>
<a name="ln565">      *b++ = creal (data-&gt;warp.radius) / params-&gt;from_scale;</a>
<a name="ln566">      *b++ = cimag (data-&gt;warp.radius) / params-&gt;from_scale;</a>
<a name="ln567">      break;</a>
<a name="ln568">    default:</a>
<a name="ln569">      break;</a>
<a name="ln570">    }</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  if (params-&gt;pmin &lt; module-&gt;priority &amp;&amp; params-&gt;pmax &gt; module-&gt;priority)</a>
<a name="ln574">  {</a>
<a name="ln575">    dt_dev_distort_transform_plus (params-&gt;develop, params-&gt;pipe, params-&gt;pmin, module-&gt;priority - 1, buffer, len);</a>
<a name="ln576">    dt_dev_distort_transform_plus (params-&gt;develop, params-&gt;pipe, module-&gt;priority + 1, params-&gt;pmax, buffer, len);</a>
<a name="ln577">  }</a>
<a name="ln578">  else</a>
<a name="ln579">    dt_dev_distort_transform_plus (params-&gt;develop, params-&gt;pipe, params-&gt;pmin, params-&gt;pmax, buffer, len);</a>
<a name="ln580"> </a>
<a name="ln581">  // record back the transformed points</a>
<a name="ln582"> </a>
<a name="ln583">  b = buffer;</a>
<a name="ln584"> </a>
<a name="ln585">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln586">  {</a>
<a name="ln587">    dt_liquify_path_data_t *data = (dt_liquify_path_data_t *) &amp;p-&gt;nodes[k];</a>
<a name="ln588">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln589">      break;</a>
<a name="ln590"> </a>
<a name="ln591">    switch (data-&gt;header.type)</a>
<a name="ln592">    {</a>
<a name="ln593">       case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln594">         data-&gt;node.ctrl1 = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln595">         b += 2;</a>
<a name="ln596">         data-&gt;node.ctrl2 = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln597">         b += 2;</a>
<a name="ln598">         // fall thru</a>
<a name="ln599">       case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln600">       case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln601">         data-&gt;warp.point = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln602">         b += 2;</a>
<a name="ln603">         data-&gt;warp.strength = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln604">         b += 2;</a>
<a name="ln605">         data-&gt;warp.radius = (b[0] + b[1] * I) * params-&gt;to_scale;</a>
<a name="ln606">         b += 2;</a>
<a name="ln607">         break;</a>
<a name="ln608">       default:</a>
<a name="ln609">         break;</a>
<a name="ln610">    }</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  free (buffer);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">static void distort_paths_raw_to_piece (const struct dt_iop_module_t *module,</a>
<a name="ln617">                                        dt_dev_pixelpipe_t *pipe,</a>
<a name="ln618">                                        const float roi_in_scale,</a>
<a name="ln619">                                        dt_iop_liquify_params_t *p)</a>
<a name="ln620">{</a>
<a name="ln621">  const distort_params_t params = { module-&gt;dev, pipe, pipe-&gt;iscale, roi_in_scale, 0, module-&gt;priority - 1 };</a>
<a name="ln622">  _distort_paths (module, &amp;params, p);</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">// op-engine code</a>
<a name="ln626"> </a>
<a name="ln627">static inline float complex normalize (const float complex v)</a>
<a name="ln628">{</a>
<a name="ln629">  if (cabs (v) &lt; 0.000001)</a>
<a name="ln630">    return 1.0;</a>
<a name="ln631">  return v / cabs (v);</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">// calculate the linear blend of scalars a and b</a>
<a name="ln635"> </a>
<a name="ln636">static inline float mix (const float a, const float b, const float t)</a>
<a name="ln637">{</a>
<a name="ln638">  return a + (b - a) * t;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">// calculate the linear blend of points p0 and p1</a>
<a name="ln643"> </a>
<a name="ln644">static inline float complex cmix (const float complex p0, const float complex p1, const float t)</a>
<a name="ln645">{</a>
<a name="ln646">  return p0 + (p1 - p0) * t;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">static void mix_warps (dt_liquify_warp_t *result,</a>
<a name="ln650">                       const dt_liquify_warp_t *warp1,</a>
<a name="ln651">                       const dt_liquify_warp_t *warp2,</a>
<a name="ln652">                       const complex float pt,</a>
<a name="ln653">                       const float t)</a>
<a name="ln654">{</a>
<a name="ln655">  result-&gt;type     = warp1-&gt;type;</a>
<a name="ln656">  result-&gt;control1 = mix  (warp1-&gt;control1, warp2-&gt;control1, t);</a>
<a name="ln657">  result-&gt;control2 = mix  (warp1-&gt;control2, warp2-&gt;control2, t);</a>
<a name="ln658"> </a>
<a name="ln659">  const float radius = mix (cabs (warp1-&gt;radius - warp1-&gt;point), cabs (warp2-&gt;radius - warp2-&gt;point), t);</a>
<a name="ln660">  result-&gt;radius     = pt + radius;</a>
<a name="ln661"> </a>
<a name="ln662">  const float r    = mix (cabs (warp1-&gt;strength - warp1-&gt;point), cabs (warp2-&gt;strength - warp2-&gt;point), t);</a>
<a name="ln663">  const float phi  = mix (carg (warp1-&gt;strength - warp1-&gt;point), carg (warp2-&gt;strength - warp2-&gt;point), t);</a>
<a name="ln664">  result-&gt;strength = pt + r * cexp (phi * I);</a>
<a name="ln665"> </a>
<a name="ln666">  result-&gt;point    = pt;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">// Interpolate a cubic bezier spline into a series of points.</a>
<a name="ln670"> </a>
<a name="ln671">static void interpolate_cubic_bezier (const float complex p0,</a>
<a name="ln672">                                      const float complex p1,</a>
<a name="ln673">                                      const float complex p2,</a>
<a name="ln674">                                      const float complex p3,</a>
<a name="ln675">                                      float complex buffer[],</a>
<a name="ln676">                                      const int n)</a>
<a name="ln677">{</a>
<a name="ln678">  // convert from bernstein basis to polynomial basis to get faster math</a>
<a name="ln679">  // See: http://www.tinaja.com/glib/cubemath.pdf</a>
<a name="ln680">  const float complex A = p3 - 3 * p2 + 3 * p1 -     p0;</a>
<a name="ln681">  const float complex B =      3 * p2 - 6 * p1 + 3 * p0;</a>
<a name="ln682">  const float complex C =               3 * p1 - 3 * p0;</a>
<a name="ln683">  const float complex D =                            p0;</a>
<a name="ln684"> </a>
<a name="ln685">  float complex *buf = buffer;</a>
<a name="ln686">  const float step = 1.0 / n;</a>
<a name="ln687">  float t = step;</a>
<a name="ln688">  *buf++ = p0;</a>
<a name="ln689"> </a>
<a name="ln690">  for (int i = 1; i &lt; n - 1; ++i)</a>
<a name="ln691">  {</a>
<a name="ln692">    *buf++ = ((((A) * t) + B) * t + C) * t + D;</a>
<a name="ln693">    t += step;</a>
<a name="ln694">  }</a>
<a name="ln695">  *buf = p3;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">static GList *interpolate_paths (dt_iop_liquify_params_t *p);</a>
<a name="ln699"> </a>
<a name="ln700">/*</a>
<a name="ln701">  Get approx. arc length of a curve.</a>
<a name="ln702"> </a>
<a name="ln703">  Used to approximate the arc length of a bezier curve.</a>
<a name="ln704">*/</a>
<a name="ln705"> </a>
<a name="ln706">static const float get_arc_length (const float complex points[], const int n_points)</a>
<a name="ln707">{</a>
<a name="ln708">  float length = 0.0;</a>
<a name="ln709">  for (int i = 1; i &lt; n_points; i++)</a>
<a name="ln710">    length += cabs (points[i-1] - points[i]);</a>
<a name="ln711">  return length;</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">typedef struct</a>
<a name="ln715">{</a>
<a name="ln716">  int i;</a>
<a name="ln717">  double length;</a>
<a name="ln718">} restart_cookie_t;</a>
<a name="ln719"> </a>
<a name="ln720">/*</a>
<a name="ln721">  Interpolate a point on a curve at a specified arc length.</a>
<a name="ln722"> </a>
<a name="ln723">  In a bezier curve the parameter t usually does not correspond to</a>
<a name="ln724">  the arc length.</a>
<a name="ln725">*/</a>
<a name="ln726"> </a>
<a name="ln727">static const float complex point_at_arc_length (const float complex points[],</a>
<a name="ln728">                                                const int n_points,</a>
<a name="ln729">                                                const float arc_length,</a>
<a name="ln730">                                                restart_cookie_t *restart)</a>
<a name="ln731">{</a>
<a name="ln732">  float length = restart ? restart-&gt;length : 0.0;</a>
<a name="ln733">  int i        = restart ? restart-&gt;i      : 1;</a>
<a name="ln734"> </a>
<a name="ln735">  for ( ; i &lt; n_points; i++)</a>
<a name="ln736">  {</a>
<a name="ln737">    const float prev_length = length;</a>
<a name="ln738">    length += cabsf (points[i-1] - points[i]);</a>
<a name="ln739"> </a>
<a name="ln740">    if (length &gt;= arc_length)</a>
<a name="ln741">    {</a>
<a name="ln742">      const float t = (arc_length - prev_length) / (length - prev_length);</a>
<a name="ln743">      if (restart)</a>
<a name="ln744">      {</a>
<a name="ln745">        restart-&gt;i = i;</a>
<a name="ln746">        restart-&gt;length = prev_length;</a>
<a name="ln747">      }</a>
<a name="ln748">      return cmix (points[i-1], points[i], t);</a>
<a name="ln749">    }</a>
<a name="ln750">  }</a>
<a name="ln751"> </a>
<a name="ln752">  return points[n_points - 1];</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">/*</a>
<a name="ln756">  Build a lookup table for the warp intensity.</a>
<a name="ln757"> </a>
<a name="ln758">  Lookup table for the warp intensity function: f(x). The warp</a>
<a name="ln759">  intensity function determines how much a pixel is influenced by the</a>
<a name="ln760">  warp depending from its distance from a central point.</a>
<a name="ln761"> </a>
<a name="ln762">  Boundary conditions: f(0) must be 1 and f(@a distance) must be 0.</a>
<a name="ln763">  f'(0) and f'(@a distance) must both be 0 or we'll get artifacts on</a>
<a name="ln764">  the picture.</a>
<a name="ln765"> </a>
<a name="ln766">  Implementation: a bezier curve with p0 = 0, 1 and p3 = 1, 0. p1 is</a>
<a name="ln767">  defined by @a control1, 1 and p2 by @a control1, 0.  Because a</a>
<a name="ln768">  bezier is parameterized on t, we have to reparameterize on x, which</a>
<a name="ln769">  we do by linear interpolation.</a>
<a name="ln770"> </a>
<a name="ln771">  Octave code:</a>
<a name="ln772"> </a>
<a name="ln773">  t = linspace (0,1,100);</a>
<a name="ln774">  grid;</a>
<a name="ln775">  hold on;</a>
<a name="ln776">  for steps = 0:0.1:1</a>
<a name="ln777">    cpoints = [0,1; steps,1; steps,0; 1,0];</a>
<a name="ln778">    bezier = cbezier2poly (cpoints);</a>
<a name="ln779">    x = polyval (bezier(1,:), t);</a>
<a name="ln780">    y = polyval (bezier(2,:), t);</a>
<a name="ln781">    plot (t, interp1 (x, y, t));</a>
<a name="ln782">  end</a>
<a name="ln783">  hold off;</a>
<a name="ln784">*/</a>
<a name="ln785"> </a>
<a name="ln786">static float *</a>
<a name="ln787">build_lookup_table (const int distance, const float control1, const float control2)</a>
<a name="ln788">{</a>
<a name="ln789">  float complex *clookup = dt_alloc_align (16, (distance + 2) * sizeof (float complex));</a>
<a name="ln790"> </a>
<a name="ln791">  interpolate_cubic_bezier (I, control1 + I, control2, 1.0, clookup, distance + 2);</a>
<a name="ln792"> </a>
<a name="ln793">  // reparameterize bezier by x and keep only y values</a>
<a name="ln794"> </a>
<a name="ln795">  float *lookup = dt_alloc_align(16, (distance + 2) * sizeof(float));</a>
<a name="ln796">  float *ptr = lookup;</a>
<a name="ln797">  float complex *cptr = clookup + 1;</a>
<a name="ln798">  const float complex *cptr_end = cptr + distance;</a>
<a name="ln799">  const float step = 1.0 / (float) distance;</a>
<a name="ln800">  float x = 0.0;</a>
<a name="ln801"> </a>
<a name="ln802">  *ptr++ = 1.0;</a>
<a name="ln803">  for (int i = 1; i &lt; distance &amp;&amp; cptr &lt; cptr_end; i++)</a>
<a name="ln804">  {</a>
<a name="ln805">    x += step;</a>
<a name="ln806">    while (creal (*cptr) &lt; x &amp;&amp; cptr &lt; cptr_end)</a>
<a name="ln807">      cptr++;</a>
<a name="ln808">    const float dx1 = creal (cptr[0] - cptr[-1]);</a>
<a name="ln809">    const float dx2 = x - creal (cptr[-1]);</a>
<a name="ln810">    *ptr++ = cimag (cptr[0]) + (dx2 / dx1) * (cimag (cptr[0]) - cimag (cptr[-1]));</a>
<a name="ln811">  }</a>
<a name="ln812">  *ptr++ = 0.0;</a>
<a name="ln813"> </a>
<a name="ln814">  dt_free_align (clookup);</a>
<a name="ln815">  return lookup;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">static void compute_round_stamp_extent (cairo_rectangle_int_t *stamp_extent,</a>
<a name="ln819">                                        const dt_liquify_warp_t *warp)</a>
<a name="ln820">{</a>
<a name="ln821"> </a>
<a name="ln822">  const int iradius = round (cabs (warp-&gt;radius - warp-&gt;point));</a>
<a name="ln823">  assert (iradius &gt; 0);</a>
<a name="ln824"> </a>
<a name="ln825">  stamp_extent-&gt;x = stamp_extent-&gt;y = -iradius;</a>
<a name="ln826">  stamp_extent-&gt;x += creal (warp-&gt;point);</a>
<a name="ln827">  stamp_extent-&gt;y += cimag (warp-&gt;point);</a>
<a name="ln828">  stamp_extent-&gt;width = stamp_extent-&gt;height = 2 * iradius + 1;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">/*</a>
<a name="ln832">  Compute a round (circular) stamp.</a>
<a name="ln833"> </a>
<a name="ln834">  The stamp is a vector field of warp vectors around a center point.</a>
<a name="ln835"> </a>
<a name="ln836">  In a linear warp the center point gets a warp of @a strength, while</a>
<a name="ln837">  points on the circumference of the circle get no warp at all.</a>
<a name="ln838">  Between center and circumference the warp magnitude tapers off</a>
<a name="ln839">  following a curve (see: build_lookup_table()).</a>
<a name="ln840"> </a>
<a name="ln841">  Note that when applying a linear stamp to a path, we will first rotate its</a>
<a name="ln842">  vectors into the direction of the path.</a>
<a name="ln843"> </a>
<a name="ln844">  In a radial warp the center point and the points on the</a>
<a name="ln845">  circumference get no warp. Between center and circumference the</a>
<a name="ln846">  warp magnitude follows a curve with maximum at radius / 0.5</a>
<a name="ln847"> </a>
<a name="ln848">  Our stamp is stored in a rectangular region.</a>
<a name="ln849">*/</a>
<a name="ln850"> </a>
<a name="ln851">static void build_round_stamp (float complex **pstamp,</a>
<a name="ln852">                               cairo_rectangle_int_t *stamp_extent,</a>
<a name="ln853">                               const dt_liquify_warp_t *warp)</a>
<a name="ln854">{</a>
<a name="ln855">  const int iradius = round (cabs (warp-&gt;radius - warp-&gt;point));</a>
<a name="ln856">  assert (iradius &gt; 0);</a>
<a name="ln857"> </a>
<a name="ln858">  stamp_extent-&gt;x = stamp_extent-&gt;y = -iradius;</a>
<a name="ln859">  stamp_extent-&gt;width = stamp_extent-&gt;height = 2 * iradius + 1;</a>
<a name="ln860"> </a>
<a name="ln861">  // 0.5 is factored in so the warp starts to degenerate when the</a>
<a name="ln862">  // strength arrow crosses the warp radius.</a>
<a name="ln863">  float complex strength = 0.5 * (warp-&gt;strength - warp-&gt;point);</a>
<a name="ln864">  strength = (warp-&gt;status &amp; DT_LIQUIFY_STATUS_INTERPOLATED) ?</a>
<a name="ln865">    (strength * STAMP_RELOCATION) : strength;</a>
<a name="ln866">  const float abs_strength = cabs (strength);</a>
<a name="ln867"> </a>
<a name="ln868">  float complex *stamp = malloc (sizeof (float complex)</a>
<a name="ln869">                                 * stamp_extent-&gt;width * stamp_extent-&gt;height);</a>
<a name="ln870"> </a>
<a name="ln871">  // clear memory</a>
<a name="ln872">  #ifdef _OPENMP</a>
<a name="ln873">  #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln874">  #endif</a>
<a name="ln875"> </a>
<a name="ln876">  for (int i = 0; i &lt; stamp_extent-&gt;height; i++)</a>
<a name="ln877">  {</a>
<a name="ln878">    float complex *row = stamp + i * stamp_extent-&gt;width;</a>
<a name="ln879">    memset (row, 0, sizeof (float complex) * stamp_extent-&gt;width);</a>
<a name="ln880">  }</a>
<a name="ln881"> </a>
<a name="ln882">  // lookup table: map of distance from center point =&gt; warp</a>
<a name="ln883">  const int table_size = iradius * LOOKUP_OVERSAMPLE;</a>
<a name="ln884">  const float *lookup_table = build_lookup_table (table_size, warp-&gt;control1, warp-&gt;control2);</a>
<a name="ln885"> </a>
<a name="ln886">  // points into buffer at the center of the circle</a>
<a name="ln887">  float complex *center = stamp + 2 * iradius * iradius + 2 * iradius;</a>
<a name="ln888"> </a>
<a name="ln889">  // The expensive operation here is hypotf ().  By dividing the</a>
<a name="ln890">  // circle in octants and doing only the inside we have to calculate</a>
<a name="ln891">  // hypotf only for PI / 32 = 0.098 of the stamp area.</a>
<a name="ln892">  #ifdef _OPENMP</a>
<a name="ln893">  #pragma omp parallel for schedule (dynamic, 1) default (shared)</a>
<a name="ln894">  #endif</a>
<a name="ln895"> </a>
<a name="ln896">  for (int y = 0; y &lt;= iradius; y++)</a>
<a name="ln897">  {</a>
<a name="ln898">    for (int x = y; x &lt;= iradius; x++)</a>
<a name="ln899">    {</a>
<a name="ln900">      const float dist = hypotf (x, y);</a>
<a name="ln901">      const int idist = round (dist * LOOKUP_OVERSAMPLE);</a>
<a name="ln902">      if (idist &gt;= table_size)</a>
<a name="ln903">        // idist will only grow bigger in this row</a>
<a name="ln904">        goto next_row;</a>
<a name="ln905"> </a>
<a name="ln906">      // pointers into the 8 octants of the circle</a>
<a name="ln907">      // octant count is ccw from positive x-axis</a>
<a name="ln908">      float complex *o1 = center - y * stamp_extent-&gt;width + x;</a>
<a name="ln909">      float complex *o2 = center - x * stamp_extent-&gt;width + y;</a>
<a name="ln910">      float complex *o3 = center - x * stamp_extent-&gt;width - y;</a>
<a name="ln911">      float complex *o4 = center - y * stamp_extent-&gt;width - x;</a>
<a name="ln912">      float complex *o5 = center + y * stamp_extent-&gt;width - x;</a>
<a name="ln913">      float complex *o6 = center + x * stamp_extent-&gt;width - y;</a>
<a name="ln914">      float complex *o7 = center + x * stamp_extent-&gt;width + y;</a>
<a name="ln915">      float complex *o8 = center + y * stamp_extent-&gt;width + x;</a>
<a name="ln916"> </a>
<a name="ln917">      float abs_lookup = abs_strength * lookup_table[idist] / iradius;</a>
<a name="ln918"> </a>
<a name="ln919">      switch (warp-&gt;type)</a>
<a name="ln920">      {</a>
<a name="ln921">         case DT_LIQUIFY_WARP_TYPE_RADIAL_GROW:</a>
<a name="ln922">           *o1 = abs_lookup * ( x - y * I);</a>
<a name="ln923">           *o2 = abs_lookup * ( y - x * I);</a>
<a name="ln924">           *o3 = abs_lookup * (-y - x * I);</a>
<a name="ln925">           *o4 = abs_lookup * (-x - y * I);</a>
<a name="ln926">           *o5 = abs_lookup * (-x + y * I);</a>
<a name="ln927">           *o6 = abs_lookup * (-y + x * I);</a>
<a name="ln928">           *o7 = abs_lookup * ( y + x * I);</a>
<a name="ln929">           *o8 = abs_lookup * ( x + y * I);</a>
<a name="ln930">           break;</a>
<a name="ln931"> </a>
<a name="ln932">         case DT_LIQUIFY_WARP_TYPE_RADIAL_SHRINK:</a>
<a name="ln933">           *o1 = -abs_lookup * ( x - y * I);</a>
<a name="ln934">           *o2 = -abs_lookup * ( y - x * I);</a>
<a name="ln935">           *o3 = -abs_lookup * (-y - x * I);</a>
<a name="ln936">           *o4 = -abs_lookup * (-x - y * I);</a>
<a name="ln937">           *o5 = -abs_lookup * (-x + y * I);</a>
<a name="ln938">           *o6 = -abs_lookup * (-y + x * I);</a>
<a name="ln939">           *o7 = -abs_lookup * ( y + x * I);</a>
<a name="ln940">           *o8 = -abs_lookup * ( x + y * I);</a>
<a name="ln941">           break;</a>
<a name="ln942"> </a>
<a name="ln943">         default:</a>
<a name="ln944">           *o1 = *o2 = *o3 = *o4 = *o5 = *o6 = *o7 = *o8 =</a>
<a name="ln945">             strength * lookup_table[idist];</a>
<a name="ln946">           break;</a>
<a name="ln947">      }</a>
<a name="ln948">    }</a>
<a name="ln949">  next_row: ; // &quot;;&quot; makes compiler happy</a>
<a name="ln950">  }</a>
<a name="ln951"> </a>
<a name="ln952">  dt_free_align ((void *) lookup_table);</a>
<a name="ln953">  *pstamp = stamp;</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">/*</a>
<a name="ln957">  Applies a stamp at a specified position.</a>
<a name="ln958"> </a>
<a name="ln959">  Applies a stamp at the position specified by @a point and adds the</a>
<a name="ln960">  resulting vector field to the global distortion map @a global_map.</a>
<a name="ln961"> </a>
<a name="ln962">  The global distortion map is a map of relative pixel displacements</a>
<a name="ln963">  encompassing all our paths.</a>
<a name="ln964">*/</a>
<a name="ln965"> </a>
<a name="ln966">static void add_to_global_distortion_map (float complex *global_map,</a>
<a name="ln967">                                          const cairo_rectangle_int_t *global_map_extent,</a>
<a name="ln968">                                          const dt_liquify_warp_t *warp,</a>
<a name="ln969">                                          const float complex *stamp,</a>
<a name="ln970">                                          const cairo_rectangle_int_t *stamp_extent)</a>
<a name="ln971">{</a>
<a name="ln972">  cairo_rectangle_int_t mmext = *stamp_extent;</a>
<a name="ln973">  mmext.x += (int) round (creal (warp-&gt;point));</a>
<a name="ln974">  mmext.y += (int) round (cimag (warp-&gt;point));</a>
<a name="ln975">  cairo_rectangle_int_t cmmext = mmext;</a>
<a name="ln976">  cairo_region_t *mmreg = cairo_region_create_rectangle (&amp;mmext);</a>
<a name="ln977">  cairo_region_intersect_rectangle (mmreg, global_map_extent);</a>
<a name="ln978">  cairo_region_get_extents (mmreg, &amp;cmmext);</a>
<a name="ln979">  free (mmreg);</a>
<a name="ln980"> </a>
<a name="ln981">  #ifdef _OPENMP</a>
<a name="ln982">  #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln983">  #endif</a>
<a name="ln984"> </a>
<a name="ln985">  for (int y = cmmext.y; y &lt; cmmext.y + cmmext.height; y++)</a>
<a name="ln986">  {</a>
<a name="ln987">    const float complex *srcrow = stamp + ((y - mmext.y) * mmext.width);</a>
<a name="ln988"> </a>
<a name="ln989">    float complex *destrow = global_map +</a>
<a name="ln990">      ((y - global_map_extent-&gt;y) * global_map_extent-&gt;width);</a>
<a name="ln991"> </a>
<a name="ln992">    for (int x = cmmext.x; x &lt; cmmext.x + cmmext.width; x++)</a>
<a name="ln993">    {</a>
<a name="ln994">      destrow[x - global_map_extent-&gt;x] -= srcrow[x - mmext.x];</a>
<a name="ln995">    }</a>
<a name="ln996">  }</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">/*</a>
<a name="ln1000">  Applies the global distortion map to the picture.  The distortion</a>
<a name="ln1001">  map maps points to the position from where the new color of the</a>
<a name="ln1002">  point should be sampled from.  The distortion map is in relative</a>
<a name="ln1003">  device coords.</a>
<a name="ln1004">*/</a>
<a name="ln1005"> </a>
<a name="ln1006">static void apply_global_distortion_map (struct dt_iop_module_t *module,</a>
<a name="ln1007">                                         dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1008">                                         const float *in,</a>
<a name="ln1009">                                         float *out,</a>
<a name="ln1010">                                         const dt_iop_roi_t *roi_in,</a>
<a name="ln1011">                                         const dt_iop_roi_t *roi_out,</a>
<a name="ln1012">                                         const float complex *map,</a>
<a name="ln1013">                                         const cairo_rectangle_int_t *extent)</a>
<a name="ln1014">{</a>
<a name="ln1015">  const int ch = piece-&gt;colors;</a>
<a name="ln1016">  const int ch_width = ch * roi_in-&gt;width;</a>
<a name="ln1017">  const struct dt_interpolation * const interpolation =</a>
<a name="ln1018">    dt_interpolation_new (DT_INTERPOLATION_USERPREF);</a>
<a name="ln1019"> </a>
<a name="ln1020">  #ifdef _OPENMP</a>
<a name="ln1021">  #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln1022">  #endif</a>
<a name="ln1023"> </a>
<a name="ln1024">  for (int y = extent-&gt;y; y &lt; extent-&gt;y + extent-&gt;height; y++)</a>
<a name="ln1025">  {</a>
<a name="ln1026">    // point inside roi_out ?</a>
<a name="ln1027">    if (y &gt;= roi_out-&gt;y &amp;&amp; y &lt; roi_out-&gt;y + roi_out-&gt;height)</a>
<a name="ln1028">    {</a>
<a name="ln1029">      const float complex *row = map + (y - extent-&gt;y) * extent-&gt;width;</a>
<a name="ln1030">      float* out_sample = out + ((y - roi_out-&gt;y) * roi_out-&gt;width +</a>
<a name="ln1031">                               extent-&gt;x - roi_out-&gt;x) * ch;</a>
<a name="ln1032">      for (int x = extent-&gt;x; x &lt; extent-&gt;x + extent-&gt;width; x++)</a>
<a name="ln1033">      {</a>
<a name="ln1034">        if (</a>
<a name="ln1035">          // point inside roi_out ?</a>
<a name="ln1036">          (x &gt;= roi_out-&gt;x &amp;&amp; x &lt; roi_out-&gt;x + roi_out-&gt;width) &amp;&amp;</a>
<a name="ln1037">          // point actually warped ?</a>
<a name="ln1038">          (*row != 0))</a>
<a name="ln1039">        {</a>
<a name="ln1040">          if(ch == 1)</a>
<a name="ln1041">            *out_sample = dt_interpolation_compute_sample(interpolation,</a>
<a name="ln1042">                                                          in,</a>
<a name="ln1043">                                                          x + creal (*row) - roi_in-&gt;x,</a>
<a name="ln1044">                                                          y + cimag (*row) - roi_in-&gt;y,</a>
<a name="ln1045">                                                          roi_in-&gt;width,</a>
<a name="ln1046">                                                          roi_in-&gt;height,</a>
<a name="ln1047">                                                          ch,</a>
<a name="ln1048">                                                          ch_width);</a>
<a name="ln1049">          else</a>
<a name="ln1050">            dt_interpolation_compute_pixel4c (</a>
<a name="ln1051">              interpolation,</a>
<a name="ln1052">              in,</a>
<a name="ln1053">              out_sample,</a>
<a name="ln1054">              x + creal (*row) - roi_in-&gt;x,</a>
<a name="ln1055">              y + cimag (*row) - roi_in-&gt;y,</a>
<a name="ln1056">              roi_in-&gt;width,</a>
<a name="ln1057">              roi_in-&gt;height,</a>
<a name="ln1058">              ch_width);</a>
<a name="ln1059"> </a>
<a name="ln1060">        }</a>
<a name="ln1061">        ++row;</a>
<a name="ln1062">        out_sample += ch;</a>
<a name="ln1063">      }</a>
<a name="ln1064">    }</a>
<a name="ln1065">  }</a>
<a name="ln1066">}</a>
<a name="ln1067"> </a>
<a name="ln1068">// calculate the map extent.</a>
<a name="ln1069"> </a>
<a name="ln1070">static void _get_map_extent (const dt_iop_roi_t *roi_out,</a>
<a name="ln1071">                             GList *interpolated,</a>
<a name="ln1072">                             cairo_rectangle_int_t *map_extent)</a>
<a name="ln1073">{</a>
<a name="ln1074">  const cairo_rectangle_int_t roi_out_rect = { roi_out-&gt;x, roi_out-&gt;y, roi_out-&gt;width, roi_out-&gt;height };</a>
<a name="ln1075">  cairo_region_t *roi_out_region = cairo_region_create_rectangle (&amp;roi_out_rect);</a>
<a name="ln1076">  cairo_region_t *map_region = cairo_region_create ();</a>
<a name="ln1077"> </a>
<a name="ln1078">  for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1079">  {</a>
<a name="ln1080">    const dt_liquify_warp_t *warp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1081">    cairo_rectangle_int_t r;</a>
<a name="ln1082">    compute_round_stamp_extent (&amp;r, warp);</a>
<a name="ln1083">    // add extent if not entirely outside the roi</a>
<a name="ln1084">    if (cairo_region_contains_rectangle (roi_out_region, &amp;r) != CAIRO_REGION_OVERLAP_OUT)</a>
<a name="ln1085">    {</a>
<a name="ln1086">      cairo_region_union_rectangle (map_region, &amp;r);</a>
<a name="ln1087">    }</a>
<a name="ln1088">  }</a>
<a name="ln1089"> </a>
<a name="ln1090">  // return the paths and the extent of all paths</a>
<a name="ln1091">  cairo_region_get_extents (map_region, map_extent);</a>
<a name="ln1092">  cairo_region_destroy (map_region);</a>
<a name="ln1093">  cairo_region_destroy (roi_out_region);</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">static float complex *create_global_distortion_map (const cairo_rectangle_int_t *map_extent,</a>
<a name="ln1097">                                                    GList *interpolated,</a>
<a name="ln1098">                                                    gboolean inverted)</a>
<a name="ln1099">{</a>
<a name="ln1100">  // allocate distortion map big enough to contain all paths</a>
<a name="ln1101">  const int mapsize = map_extent-&gt;width * map_extent-&gt;height;</a>
<a name="ln1102">  float complex * map = dt_alloc_align (16, mapsize * sizeof (float complex));</a>
<a name="ln1103">  memset (map, 0, mapsize * sizeof (float complex));</a>
<a name="ln1104"> </a>
<a name="ln1105">  // build map</a>
<a name="ln1106">  for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1107">  {</a>
<a name="ln1108">    const dt_liquify_warp_t *warp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1109">    float complex *stamp = NULL;</a>
<a name="ln1110">    cairo_rectangle_int_t r;</a>
<a name="ln1111">    build_round_stamp (&amp;stamp, &amp;r, warp);</a>
<a name="ln1112">    add_to_global_distortion_map (map, map_extent, warp, stamp, &amp;r);</a>
<a name="ln1113">    free ((void *) stamp);</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  if (inverted)</a>
<a name="ln1117">  {</a>
<a name="ln1118">    float complex * const imap = dt_alloc_align (16, mapsize * sizeof (float complex));</a>
<a name="ln1119">    memset (imap, 0, mapsize * sizeof (float complex));</a>
<a name="ln1120"> </a>
<a name="ln1121">    // copy map into imap (inverted map).</a>
<a name="ln1122">    // imap [ n + dx(map[n]) , n + dy(map[n]) ] = -map[n]</a>
<a name="ln1123"> </a>
<a name="ln1124">    #ifdef _OPENMP</a>
<a name="ln1125">    #pragma omp parallel for schedule (static) default (shared)</a>
<a name="ln1126">    #endif</a>
<a name="ln1127"> </a>
<a name="ln1128">    for (int y = 0; y &lt;  map_extent-&gt;height; y++)</a>
<a name="ln1129">    {</a>
<a name="ln1130">      const float complex *row = map + y * map_extent-&gt;width;</a>
<a name="ln1131">      for (int x = 0; x &lt; map_extent-&gt;width; x++)</a>
<a name="ln1132">      {</a>
<a name="ln1133">        const float complex d = *(row + x);</a>
<a name="ln1134">        // compute new position (nx,ny) given the displacement d</a>
<a name="ln1135">        const int nx = x + (int)creal(d);</a>
<a name="ln1136">        const int ny = y + (int)cimag(d);</a>
<a name="ln1137"> </a>
<a name="ln1138">        // if the point falls into the extent, set it</a>
<a name="ln1139">        if (nx&gt;0 &amp;&amp; nx&lt;map_extent-&gt;width &amp;&amp; ny&gt;0 &amp;&amp; ny&lt;map_extent-&gt;height)</a>
<a name="ln1140">          imap[nx + ny * map_extent-&gt;width] = -d;</a>
<a name="ln1141">      }</a>
<a name="ln1142">    }</a>
<a name="ln1143"> </a>
<a name="ln1144">    dt_free_align ((void *) map);</a>
<a name="ln1145"> </a>
<a name="ln1146">    // now just do a pass to avoid gap with a displacement of zero, note that we do not need high</a>
<a name="ln1147">    // precision here as the inverted distortion mask is only used to compute a final displacement</a>
<a name="ln1148">    // of points.</a>
<a name="ln1149"> </a>
<a name="ln1150">    #ifdef _OPENMP</a>
<a name="ln1151">    #pragma omp parallel for schedule (dynamic) default (shared)</a>
<a name="ln1152">    #endif</a>
<a name="ln1153"> </a>
<a name="ln1154">    for (int y = 0; y &lt;  map_extent-&gt;height; y++)</a>
<a name="ln1155">    {</a>
<a name="ln1156">      float complex *row = imap + y * map_extent-&gt;width;</a>
<a name="ln1157">      float complex last[2] = { 0, 0 };</a>
<a name="ln1158">      for (int x = 0; x &lt; map_extent-&gt;width / 2 + 1; x++)</a>
<a name="ln1159">      {</a>
<a name="ln1160">        float complex *cl = row + x;</a>
<a name="ln1161">        float complex *cr = row + map_extent-&gt;width - x;</a>
<a name="ln1162">        if (x!=0)</a>
<a name="ln1163">        {</a>
<a name="ln1164">          if (*cl == 0) *cl = last[0];</a>
<a name="ln1165">          if (*cr == 0) *cr = last[1];</a>
<a name="ln1166">        }</a>
<a name="ln1167">        last[0] = *cl; last[1] = *cr;</a>
<a name="ln1168">      }</a>
<a name="ln1169">    }</a>
<a name="ln1170"> </a>
<a name="ln1171">    map = imap;</a>
<a name="ln1172">  }</a>
<a name="ln1173"> </a>
<a name="ln1174">  return map;</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">static float complex *build_global_distortion_map (struct dt_iop_module_t *module,</a>
<a name="ln1178">                                                   const dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1179">                                                   const dt_iop_roi_t *roi_in,</a>
<a name="ln1180">                                                   const dt_iop_roi_t *roi_out,</a>
<a name="ln1181">                                                   cairo_rectangle_int_t *map_extent)</a>
<a name="ln1182">{</a>
<a name="ln1183">  // copy params</a>
<a name="ln1184">  dt_iop_liquify_params_t copy_params;</a>
<a name="ln1185">  memcpy(&amp;copy_params, (dt_iop_liquify_params_t *)piece-&gt;data, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln1186"> </a>
<a name="ln1187">  distort_paths_raw_to_piece (module, piece-&gt;pipe, roi_in-&gt;scale, &amp;copy_params);</a>
<a name="ln1188"> </a>
<a name="ln1189">  GList *interpolated = interpolate_paths (&amp;copy_params);</a>
<a name="ln1190"> </a>
<a name="ln1191">  _get_map_extent (roi_out, interpolated, map_extent);</a>
<a name="ln1192"> </a>
<a name="ln1193">  float complex *map = create_global_distortion_map(map_extent, interpolated, FALSE);</a>
<a name="ln1194"> </a>
<a name="ln1195">  g_list_free_full (interpolated, free);</a>
<a name="ln1196">  return map;</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">// 1st pass: how large would the output be, given this input roi?</a>
<a name="ln1200">// this is always called with the full buffer before processing.</a>
<a name="ln1201">void modify_roi_out (struct dt_iop_module_t *module,</a>
<a name="ln1202">                     struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1203">                     dt_iop_roi_t *roi_out,</a>
<a name="ln1204">                     const dt_iop_roi_t *roi_in)</a>
<a name="ln1205">{</a>
<a name="ln1206">  // output is same size as input</a>
<a name="ln1207">  *roi_out = *roi_in;</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">// 2nd pass: which roi would this operation need as input to fill the given output region?</a>
<a name="ln1211">void modify_roi_in (struct dt_iop_module_t *module,</a>
<a name="ln1212">                    struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1213">                    const dt_iop_roi_t *roi_out,</a>
<a name="ln1214">                    dt_iop_roi_t *roi_in)</a>
<a name="ln1215">{</a>
<a name="ln1216">  // Because we move pixels, and we may have to sample a pixel from</a>
<a name="ln1217">  // outside roi_in, we need to expand roi_in to contain all our</a>
<a name="ln1218">  // paths.  But we may ignore paths completely outside of roi_out.</a>
<a name="ln1219"> </a>
<a name="ln1220">  *roi_in = *roi_out;</a>
<a name="ln1221"> </a>
<a name="ln1222">  // copy params</a>
<a name="ln1223">  dt_iop_liquify_params_t copy_params;</a>
<a name="ln1224">  memcpy(&amp;copy_params, (dt_iop_liquify_params_t*)piece-&gt;data, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln1225"> </a>
<a name="ln1226">  distort_paths_raw_to_piece (module, piece-&gt;pipe, roi_in-&gt;scale, &amp;copy_params);</a>
<a name="ln1227"> </a>
<a name="ln1228">  cairo_rectangle_int_t pipe_rect =</a>
<a name="ln1229">    {</a>
<a name="ln1230">      0,</a>
<a name="ln1231">      0,</a>
<a name="ln1232">      lroundf((double)piece-&gt;buf_in.width * roi_in-&gt;scale),</a>
<a name="ln1233">      lroundf((double)piece-&gt;buf_in.height * roi_in-&gt;scale)</a>
<a name="ln1234">    };</a>
<a name="ln1235"> </a>
<a name="ln1236">  cairo_rectangle_int_t roi_in_rect =</a>
<a name="ln1237">    {</a>
<a name="ln1238">      roi_in-&gt;x,</a>
<a name="ln1239">      roi_in-&gt;y,</a>
<a name="ln1240">      roi_in-&gt;width,</a>
<a name="ln1241">      roi_in-&gt;height</a>
<a name="ln1242">    };</a>
<a name="ln1243">  cairo_region_t *roi_in_region = cairo_region_create_rectangle (&amp;roi_in_rect);</a>
<a name="ln1244"> </a>
<a name="ln1245">  // get extent of all paths</a>
<a name="ln1246">  GList *interpolated = interpolate_paths (&amp;copy_params);</a>
<a name="ln1247">  cairo_rectangle_int_t extent;</a>
<a name="ln1248">  _get_map_extent (roi_out, interpolated, &amp;extent);</a>
<a name="ln1249"> </a>
<a name="ln1250">  // (eventually) extend roi_in</a>
<a name="ln1251">  cairo_region_union_rectangle (roi_in_region, &amp;extent);</a>
<a name="ln1252">  // and clamp to pipe extent</a>
<a name="ln1253">  cairo_region_intersect_rectangle (roi_in_region, &amp;pipe_rect);</a>
<a name="ln1254"> </a>
<a name="ln1255">  // write new extent to roi_in</a>
<a name="ln1256">  cairo_region_get_extents (roi_in_region, &amp;roi_in_rect);</a>
<a name="ln1257">  roi_in-&gt;x = roi_in_rect.x;</a>
<a name="ln1258">  roi_in-&gt;y = roi_in_rect.y;</a>
<a name="ln1259">  roi_in-&gt;width  = roi_in_rect.width;</a>
<a name="ln1260">  roi_in-&gt;height = roi_in_rect.height;</a>
<a name="ln1261"> </a>
<a name="ln1262">  // cleanup</a>
<a name="ln1263">  cairo_region_destroy (roi_in_region);</a>
<a name="ln1264">  g_list_free_full (interpolated, free);</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">static int _distort_xtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count, gboolean inverted)</a>
<a name="ln1268">{</a>
<a name="ln1269">  const float scale = piece-&gt;iscale;</a>
<a name="ln1270"> </a>
<a name="ln1271">  // compute the extent of all points (all computations are done in RAW coordinate)</a>
<a name="ln1272">  float xmin=FLT_MAX, xmax=FLT_MIN, ymin=FLT_MAX, ymax=FLT_MIN;</a>
<a name="ln1273"> </a>
<a name="ln1274">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln1275">  {</a>
<a name="ln1276">    const float x = points[i] * scale;</a>
<a name="ln1277">    const float y = points[i + 1] * scale;</a>
<a name="ln1278">    xmin = fmin (xmin, x);</a>
<a name="ln1279">    xmax = fmax (xmax, x);</a>
<a name="ln1280">    ymin = fmin (ymin, y);</a>
<a name="ln1281">    ymax = fmax (ymax, y);</a>
<a name="ln1282">  }</a>
<a name="ln1283"> </a>
<a name="ln1284">  cairo_rectangle_int_t extent = { .x = (int)(xmin - .5), .y = (int)(ymin - .5),</a>
<a name="ln1285">                                   .width = (int)(xmax - xmin + 2.5), .height = (int)(ymax - ymin + 2.5) };</a>
<a name="ln1286"> </a>
<a name="ln1287">  if (extent.width != 0 &amp;&amp; extent.height != 0)</a>
<a name="ln1288">  {</a>
<a name="ln1289">    // create the distortion map for this extent</a>
<a name="ln1290"> </a>
<a name="ln1291">    GList *interpolated = interpolate_paths ((dt_iop_liquify_params_t *)piece-&gt;data);</a>
<a name="ln1292"> </a>
<a name="ln1293">    // we need to adjust the extent to be the union enclosing all the points (currently in extent) and</a>
<a name="ln1294">    // the warps that are in (possibly partly) in this same region.</a>
<a name="ln1295"> </a>
<a name="ln1296">    dt_iop_roi_t roi_in = { .x = extent.x, .y = extent.y, .width = extent.width, .height = extent.height };</a>
<a name="ln1297">    _get_map_extent (&amp;roi_in, interpolated, &amp;extent);</a>
<a name="ln1298"> </a>
<a name="ln1299">    float complex *map = create_global_distortion_map (&amp;extent, interpolated, inverted);</a>
<a name="ln1300">    g_list_free_full (interpolated, free);</a>
<a name="ln1301"> </a>
<a name="ln1302">    if (map == NULL) return 0;</a>
<a name="ln1303"> </a>
<a name="ln1304">    const int map_size =  extent.width * extent.height;</a>
<a name="ln1305">    const int x_last = extent.x + extent.width;</a>
<a name="ln1306">    const int y_last = extent.y + extent.height;</a>
<a name="ln1307"> </a>
<a name="ln1308">    // apply distortion to all points (this is a simple displacement given by a vector at this same point in the map)</a>
<a name="ln1309">    for(size_t i = 0; i &lt; points_count; i++)</a>
<a name="ln1310">    {</a>
<a name="ln1311">      float *px = &amp;points[i*2];</a>
<a name="ln1312">      float *py = &amp;points[i*2+1];</a>
<a name="ln1313">      const float x = *px * scale;</a>
<a name="ln1314">      const float y = *py * scale;</a>
<a name="ln1315">      const int map_offset = ((int)(x - 0.5) - extent.x) + ((int)(y - 0.5) - extent.y) * extent.width;</a>
<a name="ln1316"> </a>
<a name="ln1317">      if (x &gt;= extent.x &amp;&amp; x &lt; x_last &amp;&amp; y &gt;= extent.y &amp;&amp; y &lt; y_last &amp;&amp; map_offset &gt;= 0 &amp;&amp; map_offset &lt; map_size)</a>
<a name="ln1318">      {</a>
<a name="ln1319">        const float complex dist = map[map_offset] / scale;</a>
<a name="ln1320">        *px += creal(dist);</a>
<a name="ln1321">        *py += cimag(dist);</a>
<a name="ln1322">      }</a>
<a name="ln1323">    }</a>
<a name="ln1324"> </a>
<a name="ln1325">    dt_free_align ((void *) map);</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  return 1;</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331">int distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln1332">{</a>
<a name="ln1333">  return _distort_xtransform(self, piece, points, points_count, TRUE);</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">int distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln1337">{</a>
<a name="ln1338">  return _distort_xtransform(self, piece, points, points_count, FALSE);</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln1342">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln1343">{</a>
<a name="ln1344">  // 1. copy the whole image (we'll change only a small part of it)</a>
<a name="ln1345"> </a>
<a name="ln1346">#ifdef _OPENMP</a>
<a name="ln1347">#pragma omp parallel for schedule(static) default(none)</a>
<a name="ln1348">#endif</a>
<a name="ln1349">  for (int i = 0; i &lt; roi_out-&gt;height; i++)</a>
<a name="ln1350">  {</a>
<a name="ln1351">    float *destrow = out + (size_t) i * roi_out-&gt;width;</a>
<a name="ln1352">    const float *srcrow = in + (size_t) (roi_in-&gt;width * (i + roi_out-&gt;y - roi_in-&gt;y) + roi_out-&gt;x - roi_in-&gt;x);</a>
<a name="ln1353"> </a>
<a name="ln1354">    memcpy (destrow, srcrow, sizeof (float) * roi_out-&gt;width);</a>
<a name="ln1355">  }</a>
<a name="ln1356"> </a>
<a name="ln1357">  // 2. build the distortion map</a>
<a name="ln1358"> </a>
<a name="ln1359">  cairo_rectangle_int_t map_extent;</a>
<a name="ln1360">  float complex *map = build_global_distortion_map (self, piece, roi_in, roi_out, &amp;map_extent);</a>
<a name="ln1361">  if (map == NULL)</a>
<a name="ln1362">    return;</a>
<a name="ln1363"> </a>
<a name="ln1364">  // 3. apply the map</a>
<a name="ln1365"> </a>
<a name="ln1366">  if (map_extent.width != 0 &amp;&amp; map_extent.height != 0)</a>
<a name="ln1367">  {</a>
<a name="ln1368">    int ch = piece-&gt;colors;</a>
<a name="ln1369">    piece-&gt;colors = 1;</a>
<a name="ln1370">    apply_global_distortion_map (self, piece, in, out, roi_in, roi_out, map, &amp;map_extent);</a>
<a name="ln1371">    piece-&gt;colors = ch;</a>
<a name="ln1372">  }</a>
<a name="ln1373"> </a>
<a name="ln1374">  dt_free_align ((void *) map);</a>
<a name="ln1375"> </a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">void process(struct dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, const void *const in,</a>
<a name="ln1379">             void *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln1380">{</a>
<a name="ln1381">  // 1. copy the whole image (we'll change only a small part of it)</a>
<a name="ln1382"> </a>
<a name="ln1383">  const int ch = piece-&gt;colors;</a>
<a name="ln1384">  assert (ch == 4);</a>
<a name="ln1385"> </a>
<a name="ln1386">#ifdef _OPENMP</a>
<a name="ln1387">#pragma omp parallel for schedule(static) default(none)</a>
<a name="ln1388">#endif</a>
<a name="ln1389">  for (int i = 0; i &lt; roi_out-&gt;height; i++)</a>
<a name="ln1390">  {</a>
<a name="ln1391">    float *destrow = (float *)out + (size_t) ch * i * roi_out-&gt;width;</a>
<a name="ln1392">    const float *srcrow = (float *)in + (size_t) ch * (roi_in-&gt;width * (i + roi_out-&gt;y - roi_in-&gt;y) +</a>
<a name="ln1393">                                                       roi_out-&gt;x - roi_in-&gt;x);</a>
<a name="ln1394"> </a>
<a name="ln1395">    memcpy (destrow, srcrow, sizeof (float) * ch * roi_out-&gt;width);</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  // 2. build the distortion map</a>
<a name="ln1399"> </a>
<a name="ln1400">  cairo_rectangle_int_t map_extent;</a>
<a name="ln1401">  float complex *map = build_global_distortion_map (module, piece, roi_in, roi_out, &amp;map_extent);</a>
<a name="ln1402">  if (map == NULL)</a>
<a name="ln1403">    return;</a>
<a name="ln1404"> </a>
<a name="ln1405">  // 3. apply the map</a>
<a name="ln1406"> </a>
<a name="ln1407">  if (map_extent.width != 0 &amp;&amp; map_extent.height != 0)</a>
<a name="ln1408">    apply_global_distortion_map (module, piece, in, out, roi_in, roi_out, map, &amp;map_extent);</a>
<a name="ln1409"> </a>
<a name="ln1410">  dt_free_align ((void *) map);</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">#ifdef HAVE_OPENCL</a>
<a name="ln1414"> </a>
<a name="ln1415">// compute lanczos kernel. See: https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel</a>
<a name="ln1416"> </a>
<a name="ln1417">static float lanczos(const float a, const float x)</a>
<a name="ln1418">{</a>
<a name="ln1419">  if (fabs (x) &gt;= a) return 0.0f;</a>
<a name="ln1420">  if (fabs (x) &lt; CL_FLT_EPSILON) return 1.0f;</a>
<a name="ln1421"> </a>
<a name="ln1422">  return</a>
<a name="ln1423">    (a * sinf (M_PI * x) * sinf (M_PI * x / a))</a>
<a name="ln1424">    /</a>
<a name="ln1425">    (M_PI * M_PI * x * x);</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428">// compute bicubic kernel. See: https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm</a>
<a name="ln1429"> </a>
<a name="ln1430">static float bicubic(const float a, const float x)</a>
<a name="ln1431">{</a>
<a name="ln1432">  const float absx = fabs (x);</a>
<a name="ln1433"> </a>
<a name="ln1434">  if (absx &lt;= 1)</a>
<a name="ln1435">    return ((a + 2) * absx - (a + 3)) * absx * absx + 1;</a>
<a name="ln1436"> </a>
<a name="ln1437">  if (absx &lt; 2)</a>
<a name="ln1438">    return ((a * absx - 5 * a) * absx + 8 * a) * absx - 4 * a;</a>
<a name="ln1439"> </a>
<a name="ln1440">  return 0.0f;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">typedef struct</a>
<a name="ln1444">{</a>
<a name="ln1445">  int size;</a>
<a name="ln1446">  int resolution;</a>
<a name="ln1447">} dt_liquify_kernel_descriptor_t;</a>
<a name="ln1448"> </a>
<a name="ln1449">typedef cl_mem cl_mem_t;</a>
<a name="ln1450">typedef cl_int cl_int_t;</a>
<a name="ln1451"> </a>
<a name="ln1452">static cl_int_t apply_global_distortion_map_cl (struct dt_iop_module_t *module,</a>
<a name="ln1453">                                                dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1454">                                                const cl_mem_t dev_in,</a>
<a name="ln1455">                                                const cl_mem_t dev_out,</a>
<a name="ln1456">                                                const dt_iop_roi_t *roi_in,</a>
<a name="ln1457">                                                const dt_iop_roi_t *roi_out,</a>
<a name="ln1458">                                                const float complex *map,</a>
<a name="ln1459">                                                const cairo_rectangle_int_t *map_extent)</a>
<a name="ln1460">{</a>
<a name="ln1461">  cl_int_t err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln1462"> </a>
<a name="ln1463">  dt_iop_liquify_global_data_t *gd = (dt_iop_liquify_global_data_t *) module-&gt;data;</a>
<a name="ln1464">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1465"> </a>
<a name="ln1466">  const struct dt_interpolation* interpolation = dt_interpolation_new (DT_INTERPOLATION_USERPREF);</a>
<a name="ln1467">  dt_liquify_kernel_descriptor_t kdesc = { .size = 0, .resolution = 100 };</a>
<a name="ln1468">  float *k = NULL;</a>
<a name="ln1469"> </a>
<a name="ln1470">  switch (interpolation-&gt;id)</a>
<a name="ln1471">  {</a>
<a name="ln1472">     case DT_INTERPOLATION_BILINEAR:</a>
<a name="ln1473">       kdesc.size = 1;</a>
<a name="ln1474">       kdesc.resolution = 1;</a>
<a name="ln1475">       k = malloc (2 * sizeof (float));</a>
<a name="ln1476">       k[0] = 1.0f;</a>
<a name="ln1477">       k[1] = 0.0f;</a>
<a name="ln1478">       break;</a>
<a name="ln1479">     case DT_INTERPOLATION_BICUBIC:</a>
<a name="ln1480">       kdesc.size = 2;</a>
<a name="ln1481">       k = malloc ((kdesc.size * kdesc.resolution + 1) * sizeof (float));</a>
<a name="ln1482">       for (int i = 0; i &lt;= kdesc.size * kdesc.resolution; ++i)</a>
<a name="ln1483">         k[i] = bicubic (0.5f, (float) i / kdesc.resolution);</a>
<a name="ln1484">       break;</a>
<a name="ln1485">     case DT_INTERPOLATION_LANCZOS2:</a>
<a name="ln1486">       kdesc.size = 2;</a>
<a name="ln1487">       k = malloc ((kdesc.size * kdesc.resolution + 1) * sizeof (float));</a>
<a name="ln1488">       for (int i = 0; i &lt;= kdesc.size * kdesc.resolution; ++i)</a>
<a name="ln1489">         k[i] = lanczos (2, (float) i / kdesc.resolution);</a>
<a name="ln1490">       break;</a>
<a name="ln1491">     case DT_INTERPOLATION_LANCZOS3:</a>
<a name="ln1492">       kdesc.size = 3;</a>
<a name="ln1493">       k = malloc ((kdesc.size * kdesc.resolution + 1) * sizeof (float));</a>
<a name="ln1494">       for (int i = 0; i &lt;= kdesc.size * kdesc.resolution; ++i)</a>
<a name="ln1495">         k[i] = lanczos (3, (float) i / kdesc.resolution);</a>
<a name="ln1496">       break;</a>
<a name="ln1497">     default:</a>
<a name="ln1498">       return FALSE;</a>
<a name="ln1499">  }</a>
<a name="ln1500"> </a>
<a name="ln1501">  cl_mem_t dev_roi_in = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1502">    (devid, sizeof (dt_iop_roi_t), (void *) roi_in);</a>
<a name="ln1503"> </a>
<a name="ln1504">  cl_mem_t dev_roi_out = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1505">    (devid, sizeof (dt_iop_roi_t), (void *) roi_out);</a>
<a name="ln1506"> </a>
<a name="ln1507">  cl_mem_t dev_map = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1508">    (devid, map_extent-&gt;width * map_extent-&gt;height * sizeof (float complex), (void *) map);</a>
<a name="ln1509"> </a>
<a name="ln1510">  cl_mem_t dev_map_extent = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1511">    (devid, sizeof (cairo_rectangle_int_t), (void *) map_extent);</a>
<a name="ln1512"> </a>
<a name="ln1513">  cl_mem_t dev_kdesc = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1514">    (devid, sizeof (dt_liquify_kernel_descriptor_t), (void *) &amp;kdesc);</a>
<a name="ln1515"> </a>
<a name="ln1516">  cl_mem_t dev_kernel = dt_opencl_copy_host_to_device_constant</a>
<a name="ln1517">    (devid, (kdesc.size * kdesc.resolution  + 1) * sizeof (float), (void *) k);</a>
<a name="ln1518"> </a>
<a name="ln1519">  if (dev_roi_in == NULL || dev_roi_out == NULL || dev_map == NULL || dev_map_extent == NULL</a>
<a name="ln1520">      || dev_kdesc == NULL || dev_kernel == NULL)</a>
<a name="ln1521">    goto error;</a>
<a name="ln1522"> </a>
<a name="ln1523">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 0, sizeof (cl_mem), &amp;dev_in);</a>
<a name="ln1524">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 1, sizeof (cl_mem), &amp;dev_out);</a>
<a name="ln1525">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 2, sizeof (cl_mem), &amp;dev_roi_in);</a>
<a name="ln1526">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 3, sizeof (cl_mem), &amp;dev_roi_out);</a>
<a name="ln1527">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 4, sizeof (cl_mem), &amp;dev_map);</a>
<a name="ln1528">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 5, sizeof (cl_mem), &amp;dev_map_extent);</a>
<a name="ln1529"> </a>
<a name="ln1530">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 6, sizeof (cl_mem), &amp;dev_kdesc);</a>
<a name="ln1531">  dt_opencl_set_kernel_arg (devid, gd-&gt;warp_kernel, 7, sizeof (cl_mem), &amp;dev_kernel);</a>
<a name="ln1532"> </a>
<a name="ln1533">  const size_t sizes[] = { ROUNDUPWD (map_extent-&gt;width), ROUNDUPHT (map_extent-&gt;height) };</a>
<a name="ln1534">  err = dt_opencl_enqueue_kernel_2d (devid, gd-&gt;warp_kernel, sizes);</a>
<a name="ln1535"> </a>
<a name="ln1536">error:</a>
<a name="ln1537"> </a>
<a name="ln1538">  dt_opencl_release_mem_object (dev_kernel);</a>
<a name="ln1539">  dt_opencl_release_mem_object (dev_kdesc);</a>
<a name="ln1540">  dt_opencl_release_mem_object (dev_map_extent);</a>
<a name="ln1541">  dt_opencl_release_mem_object (dev_map);</a>
<a name="ln1542">  dt_opencl_release_mem_object (dev_roi_out);</a>
<a name="ln1543">  dt_opencl_release_mem_object (dev_roi_in);</a>
<a name="ln1544">  if (k) free (k);</a>
<a name="ln1545"> </a>
<a name="ln1546">  return err;</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549">int process_cl (struct dt_iop_module_t *module,</a>
<a name="ln1550">                dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1551">                const cl_mem_t dev_in,</a>
<a name="ln1552">                const cl_mem_t dev_out,</a>
<a name="ln1553">                const dt_iop_roi_t *roi_in,</a>
<a name="ln1554">                const dt_iop_roi_t *roi_out)</a>
<a name="ln1555">{</a>
<a name="ln1556">  cl_int_t err = -999;</a>
<a name="ln1557">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln1558"> </a>
<a name="ln1559">  // 1. copy the whole image (we'll change only a small part of it)</a>
<a name="ln1560"> </a>
<a name="ln1561">  {</a>
<a name="ln1562">    size_t src[]    = { roi_out-&gt;x - roi_in-&gt;x, roi_out-&gt;y - roi_in-&gt;y, 0 };</a>
<a name="ln1563">    size_t dest[]   = { 0, 0, 0 };</a>
<a name="ln1564">    size_t extent[] = { roi_out-&gt;width, roi_out-&gt;height, 1 };</a>
<a name="ln1565">    err = dt_opencl_enqueue_copy_image (devid, dev_in, dev_out, src, dest, extent);</a>
<a name="ln1566">    if (err != CL_SUCCESS) goto error;</a>
<a name="ln1567">  }</a>
<a name="ln1568"> </a>
<a name="ln1569">  // 2. build the distortion map</a>
<a name="ln1570"> </a>
<a name="ln1571">  cairo_rectangle_int_t map_extent;</a>
<a name="ln1572">  const float complex *map = build_global_distortion_map (module, piece, roi_in, roi_out, &amp;map_extent);</a>
<a name="ln1573">  if (map == NULL)</a>
<a name="ln1574">    return TRUE;</a>
<a name="ln1575"> </a>
<a name="ln1576">  // 3. apply the map</a>
<a name="ln1577"> </a>
<a name="ln1578">  if (map_extent.width != 0 &amp;&amp; map_extent.height != 0)</a>
<a name="ln1579">    err = apply_global_distortion_map_cl (module, piece, dev_in, dev_out, roi_in, roi_out, map, &amp;map_extent);</a>
<a name="ln1580"> </a>
<a name="ln1581">  dt_free_align ((void *) map);</a>
<a name="ln1582">  if (err != CL_SUCCESS) goto error;</a>
<a name="ln1583"> </a>
<a name="ln1584">  return TRUE;</a>
<a name="ln1585"> </a>
<a name="ln1586">error:</a>
<a name="ln1587">  dt_print (DT_DEBUG_OPENCL, &quot;[opencl_liquify] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln1588">  return FALSE;</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591">#endif</a>
<a name="ln1592"> </a>
<a name="ln1593">void init_global (dt_iop_module_so_t *module)</a>
<a name="ln1594">{</a>
<a name="ln1595">  // called once at startup</a>
<a name="ln1596">  const int program = 17; // from programs.conf</a>
<a name="ln1597">  dt_iop_liquify_global_data_t *gd = (dt_iop_liquify_global_data_t *) malloc (sizeof (dt_iop_liquify_global_data_t));</a>
<a name="ln1598">  module-&gt;data = gd;</a>
<a name="ln1599">  gd-&gt;warp_kernel = dt_opencl_create_kernel (program, &quot;warp_kernel&quot;);</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">void cleanup_global (dt_iop_module_so_t *module)</a>
<a name="ln1603">{</a>
<a name="ln1604">  // called once at shutdown</a>
<a name="ln1605">  dt_iop_liquify_global_data_t *gd = (dt_iop_liquify_global_data_t *) module-&gt;data;</a>
<a name="ln1606">  dt_opencl_free_kernel (gd-&gt;warp_kernel);</a>
<a name="ln1607">  free (module-&gt;data);</a>
<a name="ln1608">  module-&gt;data = NULL;</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">void init (dt_iop_module_t *module)</a>
<a name="ln1612">{</a>
<a name="ln1613">  // module is disabled by default</a>
<a name="ln1614">  module-&gt;default_enabled = 0;</a>
<a name="ln1615">  module-&gt;priority = 228; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln1616">  module-&gt;params_size = sizeof(dt_iop_liquify_params_t);</a>
<a name="ln1617">  module-&gt;gui_data = NULL;</a>
<a name="ln1618"> </a>
<a name="ln1619">  // all allocated to 0, which is the default</a>
<a name="ln1620">  module-&gt;params = calloc (1, module-&gt;params_size);</a>
<a name="ln1621">  module-&gt;default_params = calloc (1, module-&gt;params_size);</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">void cleanup (dt_iop_module_t *module)</a>
<a name="ln1625">{</a>
<a name="ln1626">  free (module-&gt;params);</a>
<a name="ln1627">  module-&gt;params = NULL;</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">void init_pipe (struct dt_iop_module_t *module, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1631">{</a>
<a name="ln1632">  piece-&gt;data = malloc (module-&gt;params_size);</a>
<a name="ln1633">  module-&gt;commit_params (module, module-&gt;default_params, pipe, piece);</a>
<a name="ln1634">}</a>
<a name="ln1635"> </a>
<a name="ln1636">void cleanup_pipe (struct dt_iop_module_t *module, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1637">{</a>
<a name="ln1638">  free (piece-&gt;data);</a>
<a name="ln1639">  piece-&gt;data = NULL;</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">/* commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln1643"> </a>
<a name="ln1644">void commit_params (struct dt_iop_module_t *module,</a>
<a name="ln1645">                    dt_iop_params_t *params,</a>
<a name="ln1646">                    dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1647">                    dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1648">{</a>
<a name="ln1649">  memcpy (piece-&gt;data, params, module-&gt;params_size);</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">// calculate the dot product of 2 vectors.</a>
<a name="ln1653"> </a>
<a name="ln1654">static float cdot (const float complex p0, const float complex p1)</a>
<a name="ln1655">{</a>
<a name="ln1656">#ifdef FP_FAST_FMA</a>
<a name="ln1657">  return fma (creal (p0), creal (p1), cimag (p0) * cimag (p1));</a>
<a name="ln1658">#else</a>
<a name="ln1659">  return creal (p0) * creal (p1) + cimag (p0) * cimag (p1);</a>
<a name="ln1660">#endif</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">static void draw_rectangle (cairo_t *cr, const float complex pt, const double theta, const double size)</a>
<a name="ln1664">{</a>
<a name="ln1665">  const double x = creal (pt), y = cimag (pt);</a>
<a name="ln1666">  cairo_save (cr);</a>
<a name="ln1667">  cairo_translate (cr, x, y);</a>
<a name="ln1668">  cairo_rotate (cr, theta);</a>
<a name="ln1669">  cairo_rectangle (cr, -size / 2.0, -size / 2.0, size, size);</a>
<a name="ln1670">  cairo_restore (cr);</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673">static void draw_triangle (cairo_t *cr, const float complex pt, const double theta, const double size)</a>
<a name="ln1674">{</a>
<a name="ln1675">  const double x = creal (pt), y = cimag (pt);</a>
<a name="ln1676">  cairo_save (cr);</a>
<a name="ln1677">  cairo_translate (cr, x, y);</a>
<a name="ln1678">  cairo_rotate (cr, theta);</a>
<a name="ln1679">  cairo_move_to (cr, -size, -size / 2.0);</a>
<a name="ln1680">  cairo_line_to (cr, 0,     0          );</a>
<a name="ln1681">  cairo_line_to (cr, -size, +size / 2.0);</a>
<a name="ln1682">  cairo_close_path (cr);</a>
<a name="ln1683">  cairo_restore (cr);</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686">static void draw_circle (cairo_t *cr, const float complex pt, const double diameter)</a>
<a name="ln1687">{</a>
<a name="ln1688">  const double x = creal (pt), y = cimag (pt);</a>
<a name="ln1689">  cairo_save (cr);</a>
<a name="ln1690">  cairo_new_sub_path (cr);</a>
<a name="ln1691">  cairo_arc (cr, x, y, diameter / 2.0, 0, 2 * M_PI);</a>
<a name="ln1692">  cairo_restore (cr);</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">static void set_source_rgba (cairo_t *cr, dt_liquify_rgba_t rgba)</a>
<a name="ln1696">{</a>
<a name="ln1697">  cairo_set_source_rgba (cr, rgba.red, rgba.green, rgba.blue, rgba.alpha);</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700">static float get_ui_width (const float scale, const dt_liquify_ui_width_enum_t w)</a>
<a name="ln1701">{</a>
<a name="ln1702">  assert (w &gt;= 0 &amp;&amp; w &lt; DT_LIQUIFY_UI_WIDTH_LAST);</a>
<a name="ln1703">  return scale * DT_PIXEL_APPLY_DPI (dt_liquify_ui_widths[w]);</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">#define GET_UI_WIDTH(a) (get_ui_width (scale, DT_LIQUIFY_UI_WIDTH_##a))</a>
<a name="ln1707"> </a>
<a name="ln1708">static void set_line_width (cairo_t *cr, double scale, dt_liquify_ui_width_enum_t w)</a>
<a name="ln1709">{</a>
<a name="ln1710">  const double width = get_ui_width (scale, w);</a>
<a name="ln1711">  cairo_set_line_width (cr, width);</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714">static gboolean detect_drag (const dt_iop_liquify_gui_data_t *g, const double scale, const float complex pt)</a>
<a name="ln1715">{</a>
<a name="ln1716">  // g-&gt;last_button1_pressed_pos is valid only while BUTTON1 is down</a>
<a name="ln1717">  return g-&gt;last_button1_pressed_pos != -1.0 &amp;&amp;</a>
<a name="ln1718">    cabs (pt - g-&gt;last_button1_pressed_pos) &gt;= GET_UI_WIDTH (MIN_DRAG);</a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721">static void update_warp_count (const dt_iop_liquify_gui_data_t *g)</a>
<a name="ln1722">{</a>
<a name="ln1723">  guint warp = 0, node = 0;</a>
<a name="ln1724">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln1725">    if (g-&gt;params.nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln1726">      break;</a>
<a name="ln1727">    else</a>
<a name="ln1728">    {</a>
<a name="ln1729">      node++;</a>
<a name="ln1730">      if (g-&gt;params.nodes[k].header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln1731">        warp++;</a>
<a name="ln1732">    }</a>
<a name="ln1733">  char str[10];</a>
<a name="ln1734">  snprintf (str, sizeof (str), &quot;%d|%d&quot;, warp, node);</a>
<a name="ln1735">  gtk_label_set_text (g-&gt;label, str);</a>
<a name="ln1736">}</a>
<a name="ln1737"> </a>
<a name="ln1738">static GList *interpolate_paths (dt_iop_liquify_params_t *p)</a>
<a name="ln1739">{</a>
<a name="ln1740">  GList *l = NULL;</a>
<a name="ln1741"> </a>
<a name="ln1742">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln1743">  {</a>
<a name="ln1744">    const dt_liquify_path_data_t *data = &amp;p-&gt;nodes[k];</a>
<a name="ln1745"> </a>
<a name="ln1746">    if (data-&gt;header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln1747">      break;</a>
<a name="ln1748"> </a>
<a name="ln1749">    const float complex *p2 = &amp;data-&gt;warp.point;</a>
<a name="ln1750">    const dt_liquify_warp_t *warp2 = &amp;data-&gt;warp;</a>
<a name="ln1751"> </a>
<a name="ln1752">    if (data-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln1753">    {</a>
<a name="ln1754">      if (data-&gt;header.next == -1)</a>
<a name="ln1755">      {</a>
<a name="ln1756">        dt_liquify_warp_t *w = malloc (sizeof (dt_liquify_warp_t));</a>
<a name="ln1757">        *w = *warp2;</a>
<a name="ln1758">        l = g_list_append (l, w);</a>
<a name="ln1759">      }</a>
<a name="ln1760">      continue;</a>
<a name="ln1761">    }</a>
<a name="ln1762"> </a>
<a name="ln1763">    const dt_liquify_path_data_t *prev = node_prev (p, data);</a>
<a name="ln1764">    const dt_liquify_warp_t *warp1 = &amp;prev-&gt;warp;</a>
<a name="ln1765">    const float complex *p1 = &amp;prev-&gt;warp.point;</a>
<a name="ln1766"> </a>
<a name="ln1767">    if (data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln1768">    {</a>
<a name="ln1769">      const float total_length = cabs (*p1 - *p2);</a>
<a name="ln1770">      float arc_length = 0.0;</a>
<a name="ln1771">      while (arc_length &lt; total_length)</a>
<a name="ln1772">      {</a>
<a name="ln1773">        dt_liquify_warp_t *w = malloc (sizeof (dt_liquify_warp_t));</a>
<a name="ln1774">        const float t = arc_length / total_length;</a>
<a name="ln1775">        const float complex pt = cmix (*p1, *p2, t);</a>
<a name="ln1776">        mix_warps (w, warp1, warp2, pt, t);</a>
<a name="ln1777">        w-&gt;status = DT_LIQUIFY_STATUS_INTERPOLATED;</a>
<a name="ln1778">        arc_length += cabs (w-&gt;radius - w-&gt;point) * STAMP_RELOCATION;</a>
<a name="ln1779">        l = g_list_append (l, w);</a>
<a name="ln1780">      }</a>
<a name="ln1781">      continue;</a>
<a name="ln1782">    }</a>
<a name="ln1783"> </a>
<a name="ln1784">    if (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln1785">    {</a>
<a name="ln1786">      float complex *buffer = malloc (INTERPOLATION_POINTS * sizeof (float complex));</a>
<a name="ln1787">      interpolate_cubic_bezier (*p1,</a>
<a name="ln1788">                                data-&gt;node.ctrl1,</a>
<a name="ln1789">                                data-&gt;node.ctrl2,</a>
<a name="ln1790">                                *p2,</a>
<a name="ln1791">                                buffer,</a>
<a name="ln1792">                                INTERPOLATION_POINTS);</a>
<a name="ln1793">      const float total_length = get_arc_length (buffer, INTERPOLATION_POINTS);</a>
<a name="ln1794">      float arc_length = 0.0;</a>
<a name="ln1795">      restart_cookie_t restart = { 1, 0.0 };</a>
<a name="ln1796"> </a>
<a name="ln1797">      while (arc_length &lt; total_length)</a>
<a name="ln1798">      {</a>
<a name="ln1799">        dt_liquify_warp_t *w = malloc (sizeof (dt_liquify_warp_t));</a>
<a name="ln1800">        const float complex pt = point_at_arc_length (buffer, INTERPOLATION_POINTS, arc_length, &amp;restart);</a>
<a name="ln1801">        mix_warps (w, warp1, warp2, pt, arc_length / total_length);</a>
<a name="ln1802">        w-&gt;status = DT_LIQUIFY_STATUS_INTERPOLATED;</a>
<a name="ln1803">        arc_length += cabs (w-&gt;radius - w-&gt;point) * STAMP_RELOCATION;</a>
<a name="ln1804">        l = g_list_append (l, w);</a>
<a name="ln1805">      }</a>
<a name="ln1806">      free ((void *) buffer);</a>
<a name="ln1807">      continue;</a>
<a name="ln1808">    }</a>
<a name="ln1809">  }</a>
<a name="ln1810">  return l;</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">#define STROKE_TEST \</a>
<a name="ln1814">  if (do_hit_test) { if (cairo_in_stroke (cr, creal (*pt), cimag (*pt))) goto hit; continue; }</a>
<a name="ln1815"> </a>
<a name="ln1816">#define FILL_TEST \</a>
<a name="ln1817">  if (do_hit_test) { if (cairo_in_fill (cr, creal (*pt), cimag (*pt)) || cairo_in_stroke (cr, creal (*pt), cimag (*pt))) goto hit; continue; }</a>
<a name="ln1818"> </a>
<a name="ln1819">#define FG_COLOR  set_source_rgba (cr, fg_color);</a>
<a name="ln1820">#define BG_COLOR  set_source_rgba (cr, bg_color);</a>
<a name="ln1821">#define VERYTHINLINE  set_line_width  (cr, scale, DT_LIQUIFY_UI_WIDTH_THINLINE / 2.0);</a>
<a name="ln1822">#define THINLINE  set_line_width  (cr, scale, DT_LIQUIFY_UI_WIDTH_THINLINE);</a>
<a name="ln1823">#define THICKLINE set_line_width  (cr, scale, DT_LIQUIFY_UI_WIDTH_THICKLINE);</a>
<a name="ln1824"> </a>
<a name="ln1825">static dt_liquify_hit_t _draw_paths (dt_iop_module_t *module,</a>
<a name="ln1826">                                     cairo_t *cr,</a>
<a name="ln1827">                                     const float scale,</a>
<a name="ln1828">                                     dt_iop_liquify_params_t *p,</a>
<a name="ln1829">                                     GList *layers,</a>
<a name="ln1830">                                     const float complex *pt)</a>
<a name="ln1831">{</a>
<a name="ln1832">  dt_liquify_hit_t hit = NOWHERE;</a>
<a name="ln1833">  const gboolean do_hit_test = pt != NULL;</a>
<a name="ln1834"> </a>
<a name="ln1835">  cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1836"> </a>
<a name="ln1837">  GList *interpolated = do_hit_test ? NULL : interpolate_paths (p);</a>
<a name="ln1838"> </a>
<a name="ln1839">  for (GList *l = layers; l != NULL; l = l-&gt;next)</a>
<a name="ln1840">  {</a>
<a name="ln1841">    const dt_liquify_layer_enum_t layer = (dt_liquify_layer_enum_t) GPOINTER_TO_INT (l-&gt;data);</a>
<a name="ln1842">    dt_liquify_rgba_t fg_color = dt_liquify_layers[layer].fg;</a>
<a name="ln1843">    dt_liquify_rgba_t bg_color = dt_liquify_layers[layer].bg;</a>
<a name="ln1844"> </a>
<a name="ln1845">    if (do_hit_test &amp;&amp; ((dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_HIT_TEST) == 0))</a>
<a name="ln1846">      continue;</a>
<a name="ln1847"> </a>
<a name="ln1848">    hit.layer = layer;</a>
<a name="ln1849"> </a>
<a name="ln1850">    if (dt_liquify_layers[layer].opacity &lt; 1.0)</a>
<a name="ln1851">        cairo_push_group (cr);</a>
<a name="ln1852"> </a>
<a name="ln1853">    for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln1854">    {</a>
<a name="ln1855">      dt_liquify_path_data_t *data = &amp;p-&gt;nodes[k];</a>
<a name="ln1856">      const dt_liquify_path_data_t *prev = node_prev (p, data);</a>
<a name="ln1857"> </a>
<a name="ln1858">      if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln1859">        break;</a>
<a name="ln1860"> </a>
<a name="ln1861">      hit.elem = data;</a>
<a name="ln1862"> </a>
<a name="ln1863">      if ((dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_NODE_SELECTED)</a>
<a name="ln1864">          &amp;&amp; !data-&gt;header.selected)</a>
<a name="ln1865">        continue;</a>
<a name="ln1866"> </a>
<a name="ln1867">      if ((dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_PREV_SELECTED)</a>
<a name="ln1868">          &amp;&amp; (!prev || !prev-&gt;header.selected))</a>
<a name="ln1869">        continue;</a>
<a name="ln1870"> </a>
<a name="ln1871">      fg_color = dt_liquify_layers[layer].fg;</a>
<a name="ln1872">      bg_color = dt_liquify_layers[layer].bg;</a>
<a name="ln1873"> </a>
<a name="ln1874">      if (data-&gt;header.selected == layer)</a>
<a name="ln1875">        fg_color = DT_LIQUIFY_COLOR_SELECTED;</a>
<a name="ln1876"> </a>
<a name="ln1877">      if (data-&gt;header.hovered == dt_liquify_layers[layer].hover_master)</a>
<a name="ln1878">        fg_color = DT_LIQUIFY_COLOR_HOVER;</a>
<a name="ln1879"> </a>
<a name="ln1880">      cairo_new_path (cr);</a>
<a name="ln1881"> </a>
<a name="ln1882">      const float complex point = data-&gt;warp.point;</a>
<a name="ln1883"> </a>
<a name="ln1884">      if (data-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln1885">        cairo_move_to (cr, creal (point), cimag (point));</a>
<a name="ln1886"> </a>
<a name="ln1887">      if (layer == DT_LIQUIFY_LAYER_RADIUS)</a>
<a name="ln1888">      {</a>
<a name="ln1889">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1890">        {</a>
<a name="ln1891">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1892">          draw_circle (cr, pwarp-&gt;point, 2.0f * cabs (pwarp-&gt;radius - pwarp-&gt;point));</a>
<a name="ln1893">        }</a>
<a name="ln1894">        draw_circle (cr, point, 2.0f * cabs (data-&gt;warp.radius - data-&gt;warp.point));</a>
<a name="ln1895">        FG_COLOR;</a>
<a name="ln1896">        cairo_fill (cr);</a>
<a name="ln1897">      }</a>
<a name="ln1898"> </a>
<a name="ln1899">      if (layer == DT_LIQUIFY_LAYER_HARDNESS1)</a>
<a name="ln1900">      {</a>
<a name="ln1901">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1902">        {</a>
<a name="ln1903">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1904">          draw_circle (cr, pwarp-&gt;point, 2.0f * cabs (pwarp-&gt;radius - pwarp-&gt;point) * pwarp-&gt;control1);</a>
<a name="ln1905">        }</a>
<a name="ln1906">        FG_COLOR;</a>
<a name="ln1907">        cairo_fill (cr);</a>
<a name="ln1908">      }</a>
<a name="ln1909"> </a>
<a name="ln1910">      if (layer == DT_LIQUIFY_LAYER_HARDNESS2)</a>
<a name="ln1911">      {</a>
<a name="ln1912">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1913">        {</a>
<a name="ln1914">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1915">          draw_circle (cr, pwarp-&gt;point, 2.0f * cabs (pwarp-&gt;radius - pwarp-&gt;point) * pwarp-&gt;control2);</a>
<a name="ln1916">        }</a>
<a name="ln1917">        FG_COLOR;</a>
<a name="ln1918">        cairo_fill (cr);</a>
<a name="ln1919">      }</a>
<a name="ln1920"> </a>
<a name="ln1921">      if (layer == DT_LIQUIFY_LAYER_WARPS)</a>
<a name="ln1922">      {</a>
<a name="ln1923">        VERYTHINLINE; FG_COLOR;</a>
<a name="ln1924">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1925">        {</a>
<a name="ln1926">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1927">          cairo_move_to (cr, creal (pwarp-&gt;point), cimag (pwarp-&gt;point));</a>
<a name="ln1928">          cairo_line_to (cr, creal (pwarp-&gt;strength), cimag (pwarp-&gt;strength));</a>
<a name="ln1929">        }</a>
<a name="ln1930">        cairo_stroke (cr);</a>
<a name="ln1931"> </a>
<a name="ln1932">        for (GList *i = interpolated; i != NULL; i = i-&gt;next)</a>
<a name="ln1933">        {</a>
<a name="ln1934">          const dt_liquify_warp_t *pwarp = ((dt_liquify_warp_t *) i-&gt;data);</a>
<a name="ln1935">          const float rot = get_rot (pwarp-&gt;type);</a>
<a name="ln1936">          draw_circle   (cr, pwarp-&gt;point, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln1937">          draw_triangle (cr, pwarp-&gt;strength,</a>
<a name="ln1938">                         carg (pwarp-&gt;strength - pwarp-&gt;point) + rot,</a>
<a name="ln1939">                         GET_UI_WIDTH (GIZMO_SMALL) / 3.0);</a>
<a name="ln1940">        }</a>
<a name="ln1941">        BG_COLOR;</a>
<a name="ln1942">        cairo_fill_preserve (cr);</a>
<a name="ln1943">        FG_COLOR;</a>
<a name="ln1944">        cairo_stroke (cr);</a>
<a name="ln1945">      }</a>
<a name="ln1946"> </a>
<a name="ln1947">      if (layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln1948">      {</a>
<a name="ln1949">        if ((data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln1950">            || (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1))</a>
<a name="ln1951">        {</a>
<a name="ln1952">          assert (prev);</a>
<a name="ln1953">          cairo_move_to (cr, creal (prev-&gt;warp.point), cimag (prev-&gt;warp.point));</a>
<a name="ln1954">          if (data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln1955">            cairo_line_to (cr, creal (point), cimag (point));</a>
<a name="ln1956">          if (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln1957">          {</a>
<a name="ln1958">            cairo_curve_to (cr, creal (data-&gt;node.ctrl1), cimag (data-&gt;node.ctrl1),</a>
<a name="ln1959">                            creal (data-&gt;node.ctrl2), cimag (data-&gt;node.ctrl2),</a>
<a name="ln1960">                            creal (point), cimag (point));</a>
<a name="ln1961">          }</a>
<a name="ln1962">          THICKLINE; FG_COLOR;</a>
<a name="ln1963">          STROKE_TEST;</a>
<a name="ln1964">          cairo_stroke_preserve (cr);</a>
<a name="ln1965">          THINLINE; BG_COLOR;</a>
<a name="ln1966">          cairo_stroke (cr);</a>
<a name="ln1967">        }</a>
<a name="ln1968">      }</a>
<a name="ln1969"> </a>
<a name="ln1970">      if (layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln1971">      {</a>
<a name="ln1972">        if (data-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1</a>
<a name="ln1973">            || data-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1</a>
<a name="ln1974">            || data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln1975">        {</a>
<a name="ln1976">          const float w = GET_UI_WIDTH (GIZMO);</a>
<a name="ln1977">          switch (data-&gt;header.node_type)</a>
<a name="ln1978">          {</a>
<a name="ln1979">             case DT_LIQUIFY_NODE_TYPE_CUSP:</a>
<a name="ln1980">               draw_triangle (cr, point - w / 2.0 * I, -M_PI / 2.0, w);</a>
<a name="ln1981">               break;</a>
<a name="ln1982">             case DT_LIQUIFY_NODE_TYPE_SMOOTH:</a>
<a name="ln1983">               draw_rectangle (cr, point, M_PI / 4.0, w);</a>
<a name="ln1984">               break;</a>
<a name="ln1985">             case DT_LIQUIFY_NODE_TYPE_SYMMETRICAL:</a>
<a name="ln1986">               draw_rectangle (cr, point, 0, w);</a>
<a name="ln1987">               break;</a>
<a name="ln1988">             case DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH:</a>
<a name="ln1989">               draw_circle (cr, point, w);</a>
<a name="ln1990">               break;</a>
<a name="ln1991">             default:</a>
<a name="ln1992">               break;</a>
<a name="ln1993">          }</a>
<a name="ln1994">          THINLINE; BG_COLOR;</a>
<a name="ln1995">          FILL_TEST;</a>
<a name="ln1996">          cairo_fill_preserve (cr);</a>
<a name="ln1997">          FG_COLOR;</a>
<a name="ln1998">          cairo_stroke (cr);</a>
<a name="ln1999">        }</a>
<a name="ln2000">      }</a>
<a name="ln2001"> </a>
<a name="ln2002">      if (data-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2003">      {</a>
<a name="ln2004">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT1_HANDLE &amp;&amp;</a>
<a name="ln2005">            !(prev &amp;&amp; prev-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH))</a>
<a name="ln2006">        {</a>
<a name="ln2007">          THINLINE; FG_COLOR;</a>
<a name="ln2008">          cairo_move_to (cr, creal (prev-&gt;warp.point), cimag (prev-&gt;warp.point));</a>
<a name="ln2009">          cairo_line_to (cr, creal (data-&gt;node.ctrl1), cimag (data-&gt;node.ctrl1));</a>
<a name="ln2010">          cairo_stroke (cr);</a>
<a name="ln2011">        }</a>
<a name="ln2012">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT2_HANDLE &amp;&amp;</a>
<a name="ln2013">            data-&gt;header.node_type != DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH)</a>
<a name="ln2014">        {</a>
<a name="ln2015">          THINLINE; FG_COLOR;</a>
<a name="ln2016">          cairo_move_to (cr, creal (data-&gt;warp.point), cimag (data-&gt;warp.point));</a>
<a name="ln2017">          cairo_line_to (cr, creal (data-&gt;node.ctrl2), cimag (data-&gt;node.ctrl2));</a>
<a name="ln2018">          cairo_stroke (cr);</a>
<a name="ln2019">        }</a>
<a name="ln2020">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT1 &amp;&amp;</a>
<a name="ln2021">            !(prev &amp;&amp; prev-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH))</a>
<a name="ln2022">        {</a>
<a name="ln2023">          THINLINE; BG_COLOR;</a>
<a name="ln2024">          draw_circle (cr, data-&gt;node.ctrl1, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2025">          FILL_TEST;</a>
<a name="ln2026">          cairo_fill_preserve (cr);</a>
<a name="ln2027">          FG_COLOR;</a>
<a name="ln2028">          cairo_stroke (cr);</a>
<a name="ln2029">        }</a>
<a name="ln2030">        if (layer == DT_LIQUIFY_LAYER_CTRLPOINT2 &amp;&amp;</a>
<a name="ln2031">            data-&gt;header.node_type != DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH)</a>
<a name="ln2032">        {</a>
<a name="ln2033">          THINLINE; BG_COLOR;</a>
<a name="ln2034">          draw_circle (cr, data-&gt;node.ctrl2, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2035">          FILL_TEST;</a>
<a name="ln2036">          cairo_fill_preserve (cr);</a>
<a name="ln2037">          FG_COLOR;</a>
<a name="ln2038">          cairo_stroke (cr);</a>
<a name="ln2039">        }</a>
<a name="ln2040">      }</a>
<a name="ln2041"> </a>
<a name="ln2042">      const dt_liquify_warp_t *warp  = &amp;data-&gt;warp;</a>
<a name="ln2043"> </a>
<a name="ln2044">      if (layer == DT_LIQUIFY_LAYER_RADIUSPOINT_HANDLE)</a>
<a name="ln2045">      {</a>
<a name="ln2046">        draw_circle (cr, point, 2.0 * cabs (warp-&gt;radius - point));</a>
<a name="ln2047">        THICKLINE; FG_COLOR;</a>
<a name="ln2048">        cairo_stroke_preserve (cr);</a>
<a name="ln2049">        THINLINE; BG_COLOR;</a>
<a name="ln2050">        cairo_stroke (cr);</a>
<a name="ln2051">      }</a>
<a name="ln2052"> </a>
<a name="ln2053">      if (layer == DT_LIQUIFY_LAYER_RADIUSPOINT)</a>
<a name="ln2054">      {</a>
<a name="ln2055">        THINLINE; BG_COLOR;</a>
<a name="ln2056">        draw_circle (cr, warp-&gt;radius, GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2057">        FILL_TEST;</a>
<a name="ln2058">        cairo_fill_preserve (cr);</a>
<a name="ln2059">        FG_COLOR;</a>
<a name="ln2060">        cairo_stroke (cr);</a>
<a name="ln2061">      }</a>
<a name="ln2062"> </a>
<a name="ln2063">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT1_HANDLE)</a>
<a name="ln2064">      {</a>
<a name="ln2065">        draw_circle (cr, point, 2.0 * cabs (warp-&gt;radius - point) * warp-&gt;control1);</a>
<a name="ln2066">        THICKLINE; FG_COLOR;</a>
<a name="ln2067">        cairo_stroke_preserve (cr);</a>
<a name="ln2068">        THINLINE; BG_COLOR;</a>
<a name="ln2069">        cairo_stroke (cr);</a>
<a name="ln2070">      }</a>
<a name="ln2071"> </a>
<a name="ln2072">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT2_HANDLE)</a>
<a name="ln2073">      {</a>
<a name="ln2074">        draw_circle (cr, point, 2.0 * cabs (warp-&gt;radius - point) * warp-&gt;control2);</a>
<a name="ln2075">        THICKLINE; FG_COLOR;</a>
<a name="ln2076">        cairo_stroke_preserve (cr);</a>
<a name="ln2077">        THINLINE; BG_COLOR;</a>
<a name="ln2078">        cairo_stroke (cr);</a>
<a name="ln2079">      }</a>
<a name="ln2080"> </a>
<a name="ln2081">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT1)</a>
<a name="ln2082">      {</a>
<a name="ln2083">        draw_triangle (cr, cmix (point, warp-&gt;radius, warp-&gt;control1),</a>
<a name="ln2084">                       carg (warp-&gt;radius - point),</a>
<a name="ln2085">                       GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2086">        THINLINE; BG_COLOR;</a>
<a name="ln2087">        FILL_TEST;</a>
<a name="ln2088">        cairo_fill_preserve (cr);</a>
<a name="ln2089">        FG_COLOR;</a>
<a name="ln2090">        cairo_stroke (cr);</a>
<a name="ln2091">      }</a>
<a name="ln2092"> </a>
<a name="ln2093">      if (layer == DT_LIQUIFY_LAYER_HARDNESSPOINT2)</a>
<a name="ln2094">      {</a>
<a name="ln2095">        draw_triangle (cr, cmix (point, warp-&gt;radius, warp-&gt;control2),</a>
<a name="ln2096">                       carg (- (warp-&gt;radius - point)),</a>
<a name="ln2097">                       GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2098">        THINLINE; BG_COLOR;</a>
<a name="ln2099">        FILL_TEST;</a>
<a name="ln2100">        cairo_fill_preserve (cr);</a>
<a name="ln2101">        FG_COLOR;</a>
<a name="ln2102">        cairo_stroke (cr);</a>
<a name="ln2103">      }</a>
<a name="ln2104"> </a>
<a name="ln2105">      if (layer == DT_LIQUIFY_LAYER_STRENGTHPOINT_HANDLE)</a>
<a name="ln2106">      {</a>
<a name="ln2107">        cairo_move_to (cr, creal (point), cimag (point));</a>
<a name="ln2108">        if (warp-&gt;type == DT_LIQUIFY_WARP_TYPE_LINEAR)</a>
<a name="ln2109">        {</a>
<a name="ln2110">          float complex pt = cmix (point, warp-&gt;strength, 1.0 - 0.5 *</a>
<a name="ln2111">                                   (GET_UI_WIDTH (GIZMO_SMALL) /</a>
<a name="ln2112">                                    cabs (warp-&gt;strength - point)));</a>
<a name="ln2113">          cairo_line_to (cr, creal (pt), cimag (pt));</a>
<a name="ln2114">        }</a>
<a name="ln2115">        else</a>
<a name="ln2116">          draw_circle (cr, point, 2.0 * cabs (warp-&gt;strength - warp-&gt;point));</a>
<a name="ln2117">        THICKLINE; FG_COLOR;</a>
<a name="ln2118">        cairo_stroke_preserve (cr);</a>
<a name="ln2119">        THINLINE; BG_COLOR;</a>
<a name="ln2120">        cairo_stroke (cr);</a>
<a name="ln2121">      }</a>
<a name="ln2122"> </a>
<a name="ln2123">      if (layer == DT_LIQUIFY_LAYER_STRENGTHPOINT)</a>
<a name="ln2124">      {</a>
<a name="ln2125">        const float rot = get_rot (warp-&gt;type);</a>
<a name="ln2126">        draw_triangle (cr, warp-&gt;strength,</a>
<a name="ln2127">                       carg (warp-&gt;strength - warp-&gt;point) + rot,</a>
<a name="ln2128">                       GET_UI_WIDTH (GIZMO_SMALL));</a>
<a name="ln2129">        THINLINE; BG_COLOR;</a>
<a name="ln2130">        FILL_TEST;</a>
<a name="ln2131">        cairo_fill_preserve (cr);</a>
<a name="ln2132">        FG_COLOR;</a>
<a name="ln2133">        cairo_stroke (cr);</a>
<a name="ln2134">      }</a>
<a name="ln2135">    }</a>
<a name="ln2136"> </a>
<a name="ln2137">    if (dt_liquify_layers[layer].opacity &lt; 1.0)</a>
<a name="ln2138">    {</a>
<a name="ln2139">      cairo_pop_group_to_source (cr);</a>
<a name="ln2140">      cairo_paint_with_alpha (cr, dt_liquify_layers[layer].opacity);</a>
<a name="ln2141">    }</a>
<a name="ln2142">  }</a>
<a name="ln2143"> </a>
<a name="ln2144">  g_list_free_full (interpolated, free);</a>
<a name="ln2145">  return NOWHERE;</a>
<a name="ln2146"> </a>
<a name="ln2147">hit:</a>
<a name="ln2148">  g_list_free_full (interpolated, free);</a>
<a name="ln2149">  cairo_new_path (cr); // otherwise a successful hit test would leave the path behind</a>
<a name="ln2150">  return hit;</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153">static void draw_paths (struct dt_iop_module_t *module, cairo_t *cr, float scale, dt_iop_liquify_params_t *params)</a>
<a name="ln2154">{</a>
<a name="ln2155">  const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2156">  GList *layers = NULL;</a>
<a name="ln2157"> </a>
<a name="ln2158">  for (dt_liquify_layer_enum_t layer = 0; layer &lt; DT_LIQUIFY_LAYER_LAST; ++layer)</a>
<a name="ln2159">  {</a>
<a name="ln2160">    if (gtk_toggle_button_get_active (g-&gt;btn_point_tool)</a>
<a name="ln2161">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_POINT_TOOL))</a>
<a name="ln2162">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2163">    if (gtk_toggle_button_get_active (g-&gt;btn_line_tool)</a>
<a name="ln2164">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_LINE_TOOL))</a>
<a name="ln2165">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2166">    if (gtk_toggle_button_get_active (g-&gt;btn_curve_tool)</a>
<a name="ln2167">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_CURVE_TOOL))</a>
<a name="ln2168">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2169">    if (gtk_toggle_button_get_active (g-&gt;btn_node_tool)</a>
<a name="ln2170">        &amp;&amp; (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_NODE_TOOL))</a>
<a name="ln2171">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2172">  }</a>
<a name="ln2173"> </a>
<a name="ln2174">  _draw_paths (module, cr, scale, params, layers, NULL);</a>
<a name="ln2175"> </a>
<a name="ln2176">  g_list_free (layers);</a>
<a name="ln2177">}</a>
<a name="ln2178"> </a>
<a name="ln2179">static dt_liquify_hit_t hit_test_paths (struct dt_iop_module_t *module,</a>
<a name="ln2180">                                        float scale,</a>
<a name="ln2181">                                        cairo_t *cr,</a>
<a name="ln2182">                                        dt_iop_liquify_params_t *params,</a>
<a name="ln2183">                                        float complex pt)</a>
<a name="ln2184">{</a>
<a name="ln2185">  dt_liquify_hit_t hit = NOWHERE;</a>
<a name="ln2186">  GList *layers = NULL;</a>
<a name="ln2187"> </a>
<a name="ln2188">  for (dt_liquify_layer_enum_t layer = 0; layer &lt; DT_LIQUIFY_LAYER_LAST; ++layer)</a>
<a name="ln2189">  {</a>
<a name="ln2190">    if (dt_liquify_layers[layer].flags &amp; DT_LIQUIFY_LAYER_FLAG_HIT_TEST)</a>
<a name="ln2191">      layers = g_list_append (layers, GINT_TO_POINTER (layer));</a>
<a name="ln2192">  }</a>
<a name="ln2193"> </a>
<a name="ln2194">  layers = g_list_reverse (layers);</a>
<a name="ln2195">  hit = _draw_paths (module, cr, scale, params, layers, &amp;pt);</a>
<a name="ln2196">  g_list_free (layers);</a>
<a name="ln2197">  return hit;</a>
<a name="ln2198">}</a>
<a name="ln2199"> </a>
<a name="ln2200">// split a cubic bezier at t into two cubic beziers.</a>
<a name="ln2201"> </a>
<a name="ln2202">static void casteljau (const float complex *p0, float complex *p1, float complex *p2, float complex *p3, const float t)</a>
<a name="ln2203">{</a>
<a name="ln2204">  const float complex p01 = *p0 + (*p1 - *p0) * t;</a>
<a name="ln2205">  const float complex p12 = *p1 + (*p2 - *p1) * t;</a>
<a name="ln2206">  const float complex p23 = *p2 + (*p3 - *p2) * t;</a>
<a name="ln2207"> </a>
<a name="ln2208">  const float complex p012 = p01 + (p12 - p01) * t;</a>
<a name="ln2209">  const float complex p123 = p12 + (p23 - p12) * t;</a>
<a name="ln2210"> </a>
<a name="ln2211">  const float complex p0123 = p012 + (p123 - p012) * t;</a>
<a name="ln2212"> </a>
<a name="ln2213">  *p1 = p01;</a>
<a name="ln2214">  *p2 = p012;</a>
<a name="ln2215">  *p3 = p0123;</a>
<a name="ln2216">}</a>
<a name="ln2217"> </a>
<a name="ln2218">/*</a>
<a name="ln2219">  Find the nearest point on a cubic bezier curve.</a>
<a name="ln2220"> </a>
<a name="ln2221">  Return the curve parameter t of the point on a cubic bezier curve</a>
<a name="ln2222">  that is nearest to another arbitrary point.  Uses interpolation.</a>
<a name="ln2223"> </a>
<a name="ln2224">  FIXME: Implement a faster method, see:</a>
<a name="ln2225">  http://tog.acm.org/resources/GraphicsGems/gems/NearestPoint.c</a>
<a name="ln2226">*/</a>
<a name="ln2227"> </a>
<a name="ln2228">static float find_nearest_on_curve_t (const float complex p0,</a>
<a name="ln2229">                                      const float complex p1,</a>
<a name="ln2230">                                      const float complex p2,</a>
<a name="ln2231">                                      const float complex p3,</a>
<a name="ln2232">                                      const float complex x,</a>
<a name="ln2233">                                      const int n)</a>
<a name="ln2234">{</a>
<a name="ln2235">  float min_t = 0, min_dist = cabs (x - p0);</a>
<a name="ln2236"> </a>
<a name="ln2237">  for (int i = 0; i &lt; n; i++)</a>
<a name="ln2238">  {</a>
<a name="ln2239">    const float t = (1.0 * i) / n;</a>
<a name="ln2240">    const float t1 = 1.0 - t;</a>
<a name="ln2241">    const float complex ip =</a>
<a name="ln2242">          t1 * t1 * t1 * p0 +</a>
<a name="ln2243">      3 * t1 * t1 * t  * p1 +</a>
<a name="ln2244">      3 * t1 * t  * t  * p2 +</a>
<a name="ln2245">          t  * t  * t  * p3;</a>
<a name="ln2246"> </a>
<a name="ln2247">    const float dist = cabs (x - ip);</a>
<a name="ln2248">    if (dist &lt; min_dist)</a>
<a name="ln2249">    {</a>
<a name="ln2250">      min_dist = dist;</a>
<a name="ln2251">      min_t = t;</a>
<a name="ln2252">    }</a>
<a name="ln2253">  }</a>
<a name="ln2254">  return min_t;</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257">/*</a>
<a name="ln2258">  Find the nearest point on a line.</a>
<a name="ln2259"> </a>
<a name="ln2260">  Return the line parameter t of the point on a line that is nearest</a>
<a name="ln2261">  to another arbitrary point.</a>
<a name="ln2262">*/</a>
<a name="ln2263"> </a>
<a name="ln2264">static float find_nearest_on_line_t (const float complex p0, const float complex p1, const float complex x)</a>
<a name="ln2265">{</a>
<a name="ln2266">  // scalar projection</a>
<a name="ln2267">  const float b     = cabs (p1 - p0);           // |b|</a>
<a name="ln2268">  const float dotab = cdot (x - p0, p1 - p0);   // |a| * |b| * cos(phi)</a>
<a name="ln2269">  return dotab / (b * b);                       // |a| / |b| * cos(phi)</a>
<a name="ln2270">}</a>
<a name="ln2271"> </a>
<a name="ln2272">/**</a>
<a name="ln2273"> * Smooth a bezier spline through prescribed points.</a>
<a name="ln2274"> *</a>
<a name="ln2275"> * Smooth a bezier spline through prescribed points by solving a</a>
<a name="ln2276"> * linear system.  First we build a tridiagonal matrix and then we</a>
<a name="ln2277"> * solve it using the Thomas algorithm.  (FIXME: A tridiagonal matrix</a>
<a name="ln2278"> * is easy to solve in O(n) but you cannot write a closed path as a</a>
<a name="ln2279"> * tridiagonal.  To solve closed paths we will have to use a different</a>
<a name="ln2280"> * solver. Use the GSL?)</a>
<a name="ln2281"> *</a>
<a name="ln2282"> * Here is an article that explains the math:</a>
<a name="ln2283"> * http://www.particleincell.com/blog/2012/bezier-splines/</a>
<a name="ln2284"> *</a>
<a name="ln2285"> * Basically we find all the ctrl1 points when we solve the linear</a>
<a name="ln2286"> * system, then we calculate each ctrl2 from the ctrl1.</a>
<a name="ln2287"> *</a>
<a name="ln2288"> * We build the linear system choosing for each segment of the path an</a>
<a name="ln2289"> * equation among following 9 equations.  &quot;Straight&quot; is a path that</a>
<a name="ln2290"> * goes straight in to the knot (2nd derivative == 0 at the knot).</a>
<a name="ln2291"> * &quot;Smooth&quot; means a path that goes smoothly through the knot, makes no</a>
<a name="ln2292"> * corner and curves the same amount just before and just after the</a>
<a name="ln2293"> * knot (1st and 2nd derivatives are constant around the knot.)</a>
<a name="ln2294"> * &quot;Keep&quot; means to keep the control point as the user set it.</a>
<a name="ln2295"> *</a>
<a name="ln2296"> * |    | start       |   end of path</a>
<a name="ln2297"> * | -- | ----------- | ---------------</a>
<a name="ln2298"> * | 1  | straight    | smooth</a>
<a name="ln2299"> * | 2  | smooth      | smooth</a>
<a name="ln2300"> * | 3  | smooth      | straight</a>
<a name="ln2301"> * | 4  | keep        | smooth</a>
<a name="ln2302"> * | 5  | keep        | keep</a>
<a name="ln2303"> * | 6  | smooth      | keep</a>
<a name="ln2304"> * | 7  | keep        | straight</a>
<a name="ln2305"> * | 8  | straight    | straight  (yields a line)</a>
<a name="ln2306"> * | 9  | straight    | keep</a>
<a name="ln2307"> *</a>
<a name="ln2308"> * The equations are (close your eyes):</a>
<a name="ln2309"> *</a>
<a name="ln2310"> * \f{eqnarray}{</a>
<a name="ln2311"> *                2P_{1,i} + P_{1,i+1} &amp;=&amp;  K_i + 2K_{i+1}  \label{1} \\</a>
<a name="ln2312"> *    P_{1,i-1} + 4P_{1,i} + P_{1,i+1} &amp;=&amp; 4K_i + 2K_{i+1}  \label{2} \\</a>
<a name="ln2313"> *   2P_{1,i-1} + 7P_{1,i}             &amp;=&amp; 8K_i +  K_{i+1}  \label{3} \\</a>
<a name="ln2314"> *                 P_{1,i}             &amp;=&amp; C1_i             \label{4} \\</a>
<a name="ln2315"> *                 P_{1,i}             &amp;=&amp; C1_i             \label{5} \\</a>
<a name="ln2316"> *    P_{1,i-1} + 4P_{1,i}             &amp;=&amp; C2_i + 4K_i      \label{6} \\</a>
<a name="ln2317"> *                 P_{1,i}             &amp;=&amp; C1_i             \label{7} \\</a>
<a name="ln2318"> *                3P_{1,i}             &amp;=&amp; 2K_i +  K_{i+1}  \label{8} \\</a>
<a name="ln2319"> *                2P_{1,i}             &amp;=&amp;  K_i +  C2_i     \label{9}</a>
<a name="ln2320"> * \f}</a>
<a name="ln2321"> *</a>
<a name="ln2322"> * Some of these are the same and differ only in the way we calculate</a>
<a name="ln2323"> * c2. (You may open your eyes again.)</a>
<a name="ln2324"> */</a>
<a name="ln2325"> </a>
<a name="ln2326">static void smooth_path_linsys (size_t n,</a>
<a name="ln2327">                                const float complex *k,</a>
<a name="ln2328">                                float complex *c1,</a>
<a name="ln2329">                                float complex *c2,</a>
<a name="ln2330">                                const int *equation)</a>
<a name="ln2331">{</a>
<a name="ln2332">  --n;</a>
<a name="ln2333">  float *a = malloc (n * sizeof (float)); // subdiagonal</a>
<a name="ln2334">  float *b = malloc (n * sizeof (float)); // main diagonal</a>
<a name="ln2335">  float *c = malloc (n * sizeof (float)); // superdiagonal</a>
<a name="ln2336">  float complex *d = malloc (n * sizeof (float complex)); // right hand side</a>
<a name="ln2337"> </a>
<a name="ln2338">  // Build the tridiagonal matrix.</a>
<a name="ln2339"> </a>
<a name="ln2340">  for (int i = 0; i &lt; n; i++)</a>
<a name="ln2341">  {</a>
<a name="ln2342">    switch (equation[i])</a>
<a name="ln2343">    {</a>
<a name="ln2344">    #define ABCD(A,B,C,D) { { a[i] = A; b[i] = B; c[i] = C; d[i] = D; continue; } }</a>
<a name="ln2345">       case 1:  ABCD (0, 2, 1,       k[i] + 2 * k[i+1]   ); break;</a>
<a name="ln2346">       case 2:  ABCD (1, 4, 1,   4 * k[i] + 2 * k[i+1]   ); break;</a>
<a name="ln2347">       case 3:  ABCD (2, 7, 0,   8 * k[i] +     k[i+1]   ); break;</a>
<a name="ln2348">       case 4:  ABCD (0, 1, 0,                  c1[i]    ); break;</a>
<a name="ln2349">       case 5:  ABCD (0, 1, 0,                  c1[i]    ); break;</a>
<a name="ln2350">       case 6:  ABCD (1, 4, 0,   4 * k[i] +     c2[i]    ); break;</a>
<a name="ln2351">       case 7:  ABCD (0, 1, 0,                  c1[i]    ); break;</a>
<a name="ln2352">       case 8:  ABCD (0, 3, 0,   2 * k[i] +     k[i+1]   ); break;</a>
<a name="ln2353">       case 9:  ABCD (0, 2, 0,       k[i] +     c2[i]    ); break;</a>
<a name="ln2354">    #undef ABCD</a>
<a name="ln2355">    }</a>
<a name="ln2356">  }</a>
<a name="ln2357"> </a>
<a name="ln2358">  // Solve with the Thomas algorithm to compute c1's.  See:</a>
<a name="ln2359">  // http://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm</a>
<a name="ln2360"> </a>
<a name="ln2361">  for (int i = 1; i &lt; n; i++)</a>
<a name="ln2362">  {</a>
<a name="ln2363">    const float m = a[i] / b[i-1];</a>
<a name="ln2364">    b[i] = b[i] - m * c[i-1];</a>
<a name="ln2365">    d[i] = d[i] - m * d[i-1];</a>
<a name="ln2366">  }</a>
<a name="ln2367"> </a>
<a name="ln2368">  c1[n-1] = d[n-1] / b[n-1];</a>
<a name="ln2369">  for (int i = n - 2; i &gt;= 0; i--)</a>
<a name="ln2370">    c1[i] = (d[i] - c[i] * c1[i+1]) / b[i];</a>
<a name="ln2371"> </a>
<a name="ln2372">  // Now compute the c2's.</a>
<a name="ln2373"> </a>
<a name="ln2374">  for (int i = 0; i &lt; n; i++)</a>
<a name="ln2375">  {</a>
<a name="ln2376">    switch (equation[i])</a>
<a name="ln2377">    {</a>
<a name="ln2378">       // keep end: c2 does not change</a>
<a name="ln2379">       case 5:</a>
<a name="ln2380">       case 6:</a>
<a name="ln2381">       case 9:  break;</a>
<a name="ln2382"> </a>
<a name="ln2383">       // straight end: put c2[i] halfway between c1[i] and k[i+1]</a>
<a name="ln2384">       case 3:</a>
<a name="ln2385">       case 7:</a>
<a name="ln2386">       case 8:  c2[i] = (c1[i] + k[i+1]) / 2;  break;</a>
<a name="ln2387"> </a>
<a name="ln2388">       // smooth end: c2 and c1 are symmetrical around the knot</a>
<a name="ln2389">       default: c2[i] = 2 * k[i+1] - c1[i+1];</a>
<a name="ln2390">    }</a>
<a name="ln2391">  }</a>
<a name="ln2392"> </a>
<a name="ln2393">  free (a);</a>
<a name="ln2394">  free (b);</a>
<a name="ln2395">  free (c);</a>
<a name="ln2396">  free (d);</a>
<a name="ln2397">}</a>
<a name="ln2398"> </a>
<a name="ln2399">static const int path_length(dt_iop_liquify_params_t *p, dt_liquify_path_data_t *n)</a>
<a name="ln2400">{</a>
<a name="ln2401">  int count = 1;</a>
<a name="ln2402">  while (n-&gt;header.next != -1)</a>
<a name="ln2403">  {</a>
<a name="ln2404">    count++;</a>
<a name="ln2405">    n = &amp;p-&gt;nodes[n-&gt;header.next];</a>
<a name="ln2406">  }</a>
<a name="ln2407">  return count;</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410">static void smooth_paths_linsys (dt_iop_liquify_params_t *params)</a>
<a name="ln2411">{</a>
<a name="ln2412">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln2413">  {</a>
<a name="ln2414">    if (params-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln2415">      break;</a>
<a name="ln2416"> </a>
<a name="ln2417">    if (params-&gt;nodes[k].header.prev != -1)</a>
<a name="ln2418">      continue;</a>
<a name="ln2419"> </a>
<a name="ln2420">    dt_liquify_path_data_t *node = &amp;params-&gt;nodes[k];</a>
<a name="ln2421"> </a>
<a name="ln2422">    const size_t n = path_length (params, node);</a>
<a name="ln2423"> </a>
<a name="ln2424">    if (n &lt; 2)</a>
<a name="ln2425">      continue;</a>
<a name="ln2426"> </a>
<a name="ln2427">    float complex *pt   = calloc (n, sizeof (float complex));</a>
<a name="ln2428">    float complex *c1   = calloc (n, sizeof (float complex));</a>
<a name="ln2429">    float complex *c2   = calloc (n, sizeof (float complex));</a>
<a name="ln2430">    int *eqn            = calloc (n, sizeof (int));</a>
<a name="ln2431">    size_t idx = 0;</a>
<a name="ln2432"> </a>
<a name="ln2433">    while (node)</a>
<a name="ln2434">    {</a>
<a name="ln2435">      const dt_liquify_path_data_t *d = (dt_liquify_path_data_t *) node;</a>
<a name="ln2436">      const dt_liquify_path_data_t *p = node_prev (params, node);</a>
<a name="ln2437">      const dt_liquify_path_data_t *n = node_next (params, node);</a>
<a name="ln2438">      const dt_liquify_path_data_t *nn = n ? node_next (params, n) : NULL;</a>
<a name="ln2439"> </a>
<a name="ln2440">      pt[idx] = node-&gt;warp.point;</a>
<a name="ln2441">      if (d-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2442">      {</a>
<a name="ln2443">        c1[idx-1] = d-&gt;node.ctrl1;</a>
<a name="ln2444">        c2[idx-1] = d-&gt;node.ctrl2;</a>
<a name="ln2445">      }</a>
<a name="ln2446"> </a>
<a name="ln2447">      const int autosmooth      = d-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2448">      const int next_autosmooth = n   &amp;&amp;  n-&gt;header.node_type == DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2449">      const int firstseg        = !p  ||  d-&gt;header.type != DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln2450">      const int lastseg         = !nn ||  nn-&gt;header.type != DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln2451">      const int lineseg         = n   &amp;&amp;  n-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1;</a>
<a name="ln2452"> </a>
<a name="ln2453">      // Program the linear system with equations:</a>
<a name="ln2454">      //</a>
<a name="ln2455">      //    START           END</a>
<a name="ln2456">      //    --------------------------</a>
<a name="ln2457">      // 1: straight        smooth</a>
<a name="ln2458">      // 2: smooth          smooth</a>
<a name="ln2459">      // 3: smooth          straight</a>
<a name="ln2460">      // 4: keep            smooth</a>
<a name="ln2461">      // 5: keep            keep</a>
<a name="ln2462">      // 6: smooth          keep</a>
<a name="ln2463">      // 7: keep            straight</a>
<a name="ln2464">      // 8: straight        straight   (== line)</a>
<a name="ln2465">      // 9: straight        keep</a>
<a name="ln2466"> </a>
<a name="ln2467">      if (lineseg)                                                    eqn[idx] = 5;</a>
<a name="ln2468">      else if (!autosmooth &amp;&amp; !next_autosmooth)                       eqn[idx] = 5;</a>
<a name="ln2469">      else if (firstseg &amp;&amp; lastseg &amp;&amp; !autosmooth &amp;&amp; next_autosmooth) eqn[idx] = 7;</a>
<a name="ln2470">      else if (firstseg &amp;&amp; lastseg &amp;&amp; autosmooth &amp;&amp; next_autosmooth)  eqn[idx] = 8;</a>
<a name="ln2471">      else if (firstseg &amp;&amp; lastseg &amp;&amp; autosmooth &amp;&amp; !next_autosmooth) eqn[idx] = 9;</a>
<a name="ln2472">      else if (firstseg &amp;&amp; autosmooth &amp;&amp; !next_autosmooth)            eqn[idx] = 5;</a>
<a name="ln2473">      else if (firstseg &amp;&amp; autosmooth)                                eqn[idx] = 1;</a>
<a name="ln2474">      else if (lastseg &amp;&amp; autosmooth &amp;&amp; next_autosmooth)              eqn[idx] = 3;</a>
<a name="ln2475">      else if (lastseg &amp;&amp; !autosmooth &amp;&amp; next_autosmooth)             eqn[idx] = 7;</a>
<a name="ln2476">      else if (autosmooth &amp;&amp; !next_autosmooth)                        eqn[idx] = 6;</a>
<a name="ln2477">      else if (!autosmooth &amp;&amp; next_autosmooth)                        eqn[idx] = 4;</a>
<a name="ln2478">      else                                                            eqn[idx] = 2;</a>
<a name="ln2479"> </a>
<a name="ln2480">      ++idx;</a>
<a name="ln2481">      node = node_next (params, node);</a>
<a name="ln2482">    }</a>
<a name="ln2483"> </a>
<a name="ln2484">    smooth_path_linsys (n, pt, c1, c2, eqn);</a>
<a name="ln2485"> </a>
<a name="ln2486">    // write calculated control points back to list structure</a>
<a name="ln2487">    node = &amp;params-&gt;nodes[k];</a>
<a name="ln2488">    node = node_next(params, node);</a>
<a name="ln2489">    idx = 0;</a>
<a name="ln2490">    while (node)</a>
<a name="ln2491">    {</a>
<a name="ln2492">      dt_liquify_path_data_t *d  = (dt_liquify_path_data_t *) node;</a>
<a name="ln2493">      if (d-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2494">      {</a>
<a name="ln2495">        d-&gt;node.ctrl1 = c1[idx];</a>
<a name="ln2496">        d-&gt;node.ctrl2 = c2[idx];</a>
<a name="ln2497">      }</a>
<a name="ln2498">      ++idx;</a>
<a name="ln2499">      node = node_next(params, node);</a>
<a name="ln2500">    }</a>
<a name="ln2501"> </a>
<a name="ln2502">    free (pt);</a>
<a name="ln2503">    free (c1);</a>
<a name="ln2504">    free (c2);</a>
<a name="ln2505">    free (eqn);</a>
<a name="ln2506">  }</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">static dt_liquify_path_data_t *find_hovered (dt_iop_liquify_params_t *p)</a>
<a name="ln2510">{</a>
<a name="ln2511">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln2512">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln2513">      break;</a>
<a name="ln2514">    else if (p-&gt;nodes[k].header.hovered)</a>
<a name="ln2515">      return &amp;p-&gt;nodes[k];</a>
<a name="ln2516">  return NULL;</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519">static void init_warp (dt_liquify_warp_t *warp, float complex point)</a>
<a name="ln2520">{</a>
<a name="ln2521">  warp-&gt;type     = DT_LIQUIFY_WARP_TYPE_LINEAR;</a>
<a name="ln2522">  warp-&gt;point    = point;</a>
<a name="ln2523">  warp-&gt;radius   = point;</a>
<a name="ln2524">  warp-&gt;strength = point;</a>
<a name="ln2525">  warp-&gt;control1 = 0.5;</a>
<a name="ln2526">  warp-&gt;control2 = 0.75;</a>
<a name="ln2527">  warp-&gt;status   = DT_LIQUIFY_STATUS_NONE;</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">static dt_liquify_path_data_t *alloc_move_to (dt_iop_module_t *module, float complex start_point)</a>
<a name="ln2531">{</a>
<a name="ln2532">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2533">  dt_liquify_path_data_t* m = (dt_liquify_path_data_t*)node_alloc (&amp;g-&gt;params, &amp;g-&gt;node_index);</a>
<a name="ln2534">  if (m)</a>
<a name="ln2535">  {</a>
<a name="ln2536">    m-&gt;header.type = DT_LIQUIFY_PATH_MOVE_TO_V1;</a>
<a name="ln2537">    m-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2538">    init_warp (&amp;m-&gt;warp, start_point);</a>
<a name="ln2539">  }</a>
<a name="ln2540">  return (dt_liquify_path_data_t *)m;</a>
<a name="ln2541">}</a>
<a name="ln2542"> </a>
<a name="ln2543">static dt_liquify_path_data_t *alloc_line_to (dt_iop_module_t *module, float complex end_point)</a>
<a name="ln2544">{</a>
<a name="ln2545">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2546">  dt_liquify_path_data_t* l = (dt_liquify_path_data_t*)node_alloc (&amp;g-&gt;params, &amp;g-&gt;node_index);</a>
<a name="ln2547">  if (l)</a>
<a name="ln2548">  {</a>
<a name="ln2549">    l-&gt;header.type = DT_LIQUIFY_PATH_LINE_TO_V1;</a>
<a name="ln2550">    l-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2551">    init_warp (&amp;l-&gt;warp, end_point);</a>
<a name="ln2552">  }</a>
<a name="ln2553">  return (dt_liquify_path_data_t *)l;</a>
<a name="ln2554">}</a>
<a name="ln2555"> </a>
<a name="ln2556">static dt_liquify_path_data_t *alloc_curve_to (dt_iop_module_t *module, float complex end_point)</a>
<a name="ln2557">{</a>
<a name="ln2558">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2559">  dt_liquify_path_data_t* c = (dt_liquify_path_data_t*)node_alloc (&amp;g-&gt;params, &amp;g-&gt;node_index);</a>
<a name="ln2560">  if (c)</a>
<a name="ln2561">  {</a>
<a name="ln2562">    c-&gt;header.type = DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln2563">    c-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln2564">    c-&gt;node.ctrl1 = c-&gt;node.ctrl2 = 0.0;</a>
<a name="ln2565">    init_warp (&amp;c-&gt;warp, end_point);</a>
<a name="ln2566">  }</a>
<a name="ln2567">  return (dt_liquify_path_data_t *)c;</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570">static void start_drag (dt_iop_liquify_gui_data_t *g, dt_liquify_layer_enum_t layer, dt_liquify_path_data_t *elem)</a>
<a name="ln2571">{</a>
<a name="ln2572">  g-&gt;dragging.layer = layer;</a>
<a name="ln2573">  g-&gt;dragging.elem = elem;</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">static void end_drag (dt_iop_liquify_gui_data_t *g)</a>
<a name="ln2577">{</a>
<a name="ln2578">  g-&gt;dragging = NOWHERE;</a>
<a name="ln2579">}</a>
<a name="ln2580"> </a>
<a name="ln2581">static gboolean is_dragging(dt_iop_liquify_gui_data_t *g)</a>
<a name="ln2582">{</a>
<a name="ln2583">  return g-&gt;dragging.elem != NULL;</a>
<a name="ln2584">}</a>
<a name="ln2585"> </a>
<a name="ln2586">static void unselect_all (dt_iop_liquify_params_t *p)</a>
<a name="ln2587">{</a>
<a name="ln2588">  for (int k=0; k&lt;MAX_NODES; k++)</a>
<a name="ln2589">    if (p-&gt;nodes[k].header.type == DT_LIQUIFY_PATH_INVALIDATED)</a>
<a name="ln2590">      break;</a>
<a name="ln2591">    else</a>
<a name="ln2592">      p-&gt;nodes[k].header.selected = 0;</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">static float get_zoom_scale (dt_develop_t *develop)</a>
<a name="ln2596">{</a>
<a name="ln2597">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom ();</a>
<a name="ln2598">  const int closeup = dt_control_get_dev_closeup ();</a>
<a name="ln2599">  return dt_dev_get_zoom_scale (develop, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln2600">}</a>
<a name="ln2601"> </a>
<a name="ln2602">void gui_post_expose (struct dt_iop_module_t *module,</a>
<a name="ln2603">                      cairo_t *cr,</a>
<a name="ln2604">                      int32_t width,</a>
<a name="ln2605">                      int32_t height,</a>
<a name="ln2606">                      int32_t pointerx,</a>
<a name="ln2607">                      int32_t pointery)</a>
<a name="ln2608">{</a>
<a name="ln2609">  dt_develop_t *develop = module-&gt;dev;</a>
<a name="ln2610">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2611">  if (!g)</a>
<a name="ln2612">    return;</a>
<a name="ln2613"> </a>
<a name="ln2614">  const float bb_width = develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2615">  const float bb_height = develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2616">  const float iscale = develop-&gt;preview_pipe-&gt;iscale;</a>
<a name="ln2617">  const float scale = MAX (bb_width, bb_height);</a>
<a name="ln2618">  if (bb_width &lt; 1.0 || bb_height &lt; 1.0)</a>
<a name="ln2619">    return;</a>
<a name="ln2620"> </a>
<a name="ln2621">  // get a copy of all iop params</a>
<a name="ln2622">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln2623">  update_warp_count (g);</a>
<a name="ln2624">  smooth_paths_linsys (&amp;g-&gt;params);</a>
<a name="ln2625">  dt_iop_liquify_params_t copy_params;</a>
<a name="ln2626">  memcpy(&amp;copy_params, &amp;g-&gt;params, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln2627">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln2628"> </a>
<a name="ln2629">  // distort all points</a>
<a name="ln2630">  dt_pthread_mutex_lock(&amp;develop-&gt;preview_pipe_mutex);</a>
<a name="ln2631">  const distort_params_t d_params = { develop, develop-&gt;preview_pipe, iscale, 1.0 / scale, 0, 9999999 };</a>
<a name="ln2632">  _distort_paths (module, &amp;d_params, &amp;copy_params);</a>
<a name="ln2633">  dt_pthread_mutex_unlock(&amp;develop-&gt;preview_pipe_mutex);</a>
<a name="ln2634"> </a>
<a name="ln2635">  // You're not supposed to understand this</a>
<a name="ln2636">  const float zoom_x = dt_control_get_dev_zoom_x ();</a>
<a name="ln2637">  const float zoom_y = dt_control_get_dev_zoom_y ();</a>
<a name="ln2638">  const float zoom_scale = get_zoom_scale (develop);</a>
<a name="ln2639"> </a>
<a name="ln2640">  // setup CAIRO coordinate system</a>
<a name="ln2641">  cairo_translate (cr, 0.5 * width, 0.5 * height); // origin @ center of view</a>
<a name="ln2642">  cairo_scale     (cr, zoom_scale, zoom_scale);    // the zoom</a>
<a name="ln2643">  cairo_translate (cr, -bb_width * (0.5 + zoom_x), -bb_height * (0.5 + zoom_y));</a>
<a name="ln2644">  cairo_scale (cr, scale, scale);</a>
<a name="ln2645"> </a>
<a name="ln2646">  draw_paths (module, cr, 1.0 / (scale * zoom_scale), &amp;copy_params);</a>
<a name="ln2647">}</a>
<a name="ln2648"> </a>
<a name="ln2649">void gui_focus (struct dt_iop_module_t *module, gboolean in)</a>
<a name="ln2650">{</a>
<a name="ln2651">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2652"> </a>
<a name="ln2653">  if (!in)</a>
<a name="ln2654">  {</a>
<a name="ln2655">    dt_control_hinter_message (darktable.control, &quot;&quot;);</a>
<a name="ln2656">    gtk_toggle_button_set_active (g-&gt;btn_point_tool, FALSE);</a>
<a name="ln2657">    gtk_toggle_button_set_active (g-&gt;btn_line_tool,  FALSE);</a>
<a name="ln2658">    gtk_toggle_button_set_active (g-&gt;btn_curve_tool, FALSE);</a>
<a name="ln2659">    gtk_toggle_button_set_active (g-&gt;btn_node_tool,  FALSE);</a>
<a name="ln2660">  }</a>
<a name="ln2661">}</a>
<a name="ln2662"> </a>
<a name="ln2663">static void sync_pipe (struct dt_iop_module_t *module, gboolean history)</a>
<a name="ln2664">{</a>
<a name="ln2665">  if (history)</a>
<a name="ln2666">  {</a>
<a name="ln2667">    const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2668">    // something definitive has happened like button release ... so</a>
<a name="ln2669">    // redraw pipe</a>
<a name="ln2670">    memcpy(module-&gt;params, &amp;g-&gt;params, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln2671">    dt_dev_add_history_item (darktable.develop, module, TRUE);</a>
<a name="ln2672">  }</a>
<a name="ln2673">  else</a>
<a name="ln2674">  {</a>
<a name="ln2675">    // only moving mouse around, pointing at things or dragging ... so</a>
<a name="ln2676">    // give some cairo feedback, but don't redraw pipe</a>
<a name="ln2677">    dt_control_queue_redraw_center ();</a>
<a name="ln2678">  }</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681">/*</a>
<a name="ln2682">  right-click on node:       Delete node.</a>
<a name="ln2683">  right-click on path:       Delete whole path.</a>
<a name="ln2684"> </a>
<a name="ln2685">  ctrl+click on node:        Cycle symmetrical, smooth, cusp, autosmooth</a>
<a name="ln2686">  ctrl+click on path:        Add node</a>
<a name="ln2687">  ctrl+alt+click on path:    Change line / bezier</a>
<a name="ln2688"> </a>
<a name="ln2689">  ctrl+click on strength:    Cycle linear, grow, shrink</a>
<a name="ln2690">*/</a>
<a name="ln2691"> </a>
<a name="ln2692">static void get_point_scale(struct dt_iop_module_t *module, float x, float y, float complex *pt, float *scale)</a>
<a name="ln2693">{</a>
<a name="ln2694">  float pzx, pzy;</a>
<a name="ln2695">  dt_dev_get_pointer_zoom_pos(darktable.develop, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln2696">  pzx += 0.5f;</a>
<a name="ln2697">  pzy += 0.5f;</a>
<a name="ln2698">  const float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2699">  const float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2700">  float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln2701">  dt_dev_distort_backtransform_plus(darktable.develop, darktable.develop-&gt;preview_pipe,</a>
<a name="ln2702">                                    module-&gt;priority + 1, 9999999, pts, 1);</a>
<a name="ln2703">  dt_dev_distort_backtransform_plus(darktable.develop, darktable.develop-&gt;preview_pipe,</a>
<a name="ln2704">                                    0, module-&gt;priority - 1, pts, 1);</a>
<a name="ln2705">  const float nx = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln2706">  const float ny = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln2707"> </a>
<a name="ln2708">  *scale = darktable.develop-&gt;preview_pipe-&gt;iscale / get_zoom_scale(module-&gt;dev);</a>
<a name="ln2709">  *pt = (nx * darktable.develop-&gt;pipe-&gt;iwidth) +  (ny * darktable.develop-&gt;pipe-&gt;iheight) * I;</a>
<a name="ln2710">}</a>
<a name="ln2711"> </a>
<a name="ln2712">int mouse_moved (struct dt_iop_module_t *module,</a>
<a name="ln2713">                 double x,</a>
<a name="ln2714">                 double y,</a>
<a name="ln2715">                 double pressure,</a>
<a name="ln2716">                 int which)</a>
<a name="ln2717">{</a>
<a name="ln2718">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2719">  int handled = g-&gt;last_hit.elem ? 1 : 0;</a>
<a name="ln2720">  float complex pt;</a>
<a name="ln2721">  float scale;</a>
<a name="ln2722"> </a>
<a name="ln2723">  get_point_scale(module, x, y, &amp;pt, &amp;scale);</a>
<a name="ln2724"> </a>
<a name="ln2725">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln2726"> </a>
<a name="ln2727">  g-&gt;last_mouse_pos = pt;</a>
<a name="ln2728">  const int dragged = detect_drag (g, scale, pt);</a>
<a name="ln2729"> </a>
<a name="ln2730">  // Don't hit test while dragging, you'd only hit the dragged thing</a>
<a name="ln2731">  // anyway.</a>
<a name="ln2732"> </a>
<a name="ln2733">  if (!is_dragging(g))</a>
<a name="ln2734">  {</a>
<a name="ln2735">    dt_liquify_hit_t hit = hit_test_paths (module, scale, g-&gt;fake_cr, &amp;g-&gt;params, pt);</a>
<a name="ln2736">    dt_liquify_path_data_t *last_hovered = find_hovered (&amp;g-&gt;params);</a>
<a name="ln2737">    if (hit.elem != last_hovered ||</a>
<a name="ln2738">        (last_hovered &amp;&amp; hit.elem &amp;&amp; hit.elem-&gt;header.hovered != last_hovered-&gt;header.hovered))</a>
<a name="ln2739">    {</a>
<a name="ln2740">      if (hit.elem)</a>
<a name="ln2741">        hit.elem-&gt;header.hovered = hit.layer;</a>
<a name="ln2742">      if (last_hovered)</a>
<a name="ln2743">        last_hovered-&gt;header.hovered = 0;</a>
<a name="ln2744">      // change in hover display</a>
<a name="ln2745">      dt_control_hinter_message (darktable.control, dt_liquify_layers[hit.layer].hint);</a>
<a name="ln2746">      handled = 1;</a>
<a name="ln2747">      goto done;</a>
<a name="ln2748">    }</a>
<a name="ln2749">  }</a>
<a name="ln2750"> </a>
<a name="ln2751">  if (dragged &amp;&amp; !is_dragging(g) &amp;&amp; g-&gt;last_hit.elem)</a>
<a name="ln2752">  {</a>
<a name="ln2753">    // start dragging</a>
<a name="ln2754">    start_drag (g, g-&gt;last_hit.layer, g-&gt;last_hit.elem);</a>
<a name="ln2755">  }</a>
<a name="ln2756"> </a>
<a name="ln2757">  if (is_dragging(g))</a>
<a name="ln2758">  {</a>
<a name="ln2759">    dt_liquify_path_data_t *d = g-&gt;dragging.elem;</a>
<a name="ln2760">    dt_liquify_path_data_t *n = node_next(&amp;g-&gt;params, d);</a>
<a name="ln2761">    dt_liquify_path_data_t *p = node_prev(&amp;g-&gt;params, d);</a>
<a name="ln2762"> </a>
<a name="ln2763">    const float complex *start_pt = &amp;d-&gt;warp.point;</a>
<a name="ln2764"> </a>
<a name="ln2765">    switch (g-&gt;dragging.layer)</a>
<a name="ln2766">    {</a>
<a name="ln2767">       case DT_LIQUIFY_LAYER_CENTERPOINT:</a>
<a name="ln2768">         switch (d-&gt;header.type)</a>
<a name="ln2769">         {</a>
<a name="ln2770">            case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln2771">              d-&gt;node.ctrl2 += pt - d-&gt;warp.point;</a>
<a name="ln2772">              // fall thru</a>
<a name="ln2773">            case DT_LIQUIFY_PATH_MOVE_TO_V1:</a>
<a name="ln2774">            case DT_LIQUIFY_PATH_LINE_TO_V1:</a>
<a name="ln2775">              if (n &amp;&amp; n-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2776">                n-&gt;node.ctrl1 += pt - d-&gt;warp.point;</a>
<a name="ln2777">              if (p &amp;&amp; p-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2778">                p-&gt;node.ctrl2 += pt - d-&gt;warp.point;</a>
<a name="ln2779">              d-&gt;warp.radius   += pt - d-&gt;warp.point;</a>
<a name="ln2780">              d-&gt;warp.strength += pt - d-&gt;warp.point;</a>
<a name="ln2781">              d-&gt;warp.point = pt;</a>
<a name="ln2782">              break;</a>
<a name="ln2783">            default:</a>
<a name="ln2784">              break;</a>
<a name="ln2785">         }</a>
<a name="ln2786">         break;</a>
<a name="ln2787"> </a>
<a name="ln2788">       case DT_LIQUIFY_LAYER_CTRLPOINT1:</a>
<a name="ln2789">         switch (d-&gt;header.type)</a>
<a name="ln2790">         {</a>
<a name="ln2791">            case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln2792">              d-&gt;node.ctrl1 = pt;</a>
<a name="ln2793">              if (p &amp;&amp; p-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2794">              {</a>
<a name="ln2795">                switch (p-&gt;header.node_type)</a>
<a name="ln2796">                {</a>
<a name="ln2797">                   case DT_LIQUIFY_NODE_TYPE_SMOOTH:</a>
<a name="ln2798">                     p-&gt;node.ctrl2 = p-&gt;warp.point +</a>
<a name="ln2799">                       cabs (p-&gt;warp.point - p-&gt;node.ctrl2) *</a>
<a name="ln2800">                       cexp (carg (p-&gt;warp.point - pt) * I);</a>
<a name="ln2801">                     break;</a>
<a name="ln2802">                case DT_LIQUIFY_NODE_TYPE_SYMMETRICAL:</a>
<a name="ln2803">                  p-&gt;node.ctrl2 = 2 * p-&gt;warp.point - pt;</a>
<a name="ln2804">                  break;</a>
<a name="ln2805">                default:</a>
<a name="ln2806">                  break;</a>
<a name="ln2807">                }</a>
<a name="ln2808">              }</a>
<a name="ln2809">              break;</a>
<a name="ln2810">            default:</a>
<a name="ln2811">              break;</a>
<a name="ln2812">         }</a>
<a name="ln2813">         break;</a>
<a name="ln2814"> </a>
<a name="ln2815">       case DT_LIQUIFY_LAYER_CTRLPOINT2:</a>
<a name="ln2816">         switch (d-&gt;header.type)</a>
<a name="ln2817">         {</a>
<a name="ln2818">            case DT_LIQUIFY_PATH_CURVE_TO_V1:</a>
<a name="ln2819">              d-&gt;node.ctrl2 = pt;</a>
<a name="ln2820">              if (n &amp;&amp; n-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln2821">              {</a>
<a name="ln2822">                switch (d-&gt;header.node_type)</a>
<a name="ln2823">                {</a>
<a name="ln2824">                   case DT_LIQUIFY_NODE_TYPE_SMOOTH:</a>
<a name="ln2825">                     n-&gt;node.ctrl1 = d-&gt;warp.point +</a>
<a name="ln2826">                       cabs (d-&gt;warp.point - n-&gt;node.ctrl1) *</a>
<a name="ln2827">                       cexp (carg (d-&gt;warp.point - pt) * I);</a>
<a name="ln2828">                     break;</a>
<a name="ln2829">                   case DT_LIQUIFY_NODE_TYPE_SYMMETRICAL:</a>
<a name="ln2830">                     n-&gt;node.ctrl1 = 2 * d-&gt;warp.point - pt;</a>
<a name="ln2831">                     break;</a>
<a name="ln2832">                   default:</a>
<a name="ln2833">                     break;</a>
<a name="ln2834">                }</a>
<a name="ln2835">              }</a>
<a name="ln2836">              break;</a>
<a name="ln2837">            default:</a>
<a name="ln2838">              break;</a>
<a name="ln2839">         }</a>
<a name="ln2840">         break;</a>
<a name="ln2841"> </a>
<a name="ln2842">       case DT_LIQUIFY_LAYER_RADIUSPOINT:</a>
<a name="ln2843">         d-&gt;warp.radius = pt;</a>
<a name="ln2844">         dt_conf_set_float(CONF_RADIUS, cabs(d-&gt;warp.radius - d-&gt;warp.point));</a>
<a name="ln2845">         break;</a>
<a name="ln2846"> </a>
<a name="ln2847">       case DT_LIQUIFY_LAYER_STRENGTHPOINT:</a>
<a name="ln2848">         d-&gt;warp.strength = pt;</a>
<a name="ln2849">         dt_conf_set_float(CONF_STRENGTH, cabs(d-&gt;warp.strength - d-&gt;warp.point));</a>
<a name="ln2850">         dt_conf_set_float(CONF_ANGLE, carg(d-&gt;warp.strength - d-&gt;warp.point));</a>
<a name="ln2851">         break;</a>
<a name="ln2852"> </a>
<a name="ln2853">       case DT_LIQUIFY_LAYER_HARDNESSPOINT1:</a>
<a name="ln2854">         d-&gt;warp.control1 = MIN (1.0, cabs (pt - *start_pt) / cabs (d-&gt;warp.radius - *start_pt));</a>
<a name="ln2855">         break;</a>
<a name="ln2856"> </a>
<a name="ln2857">       case DT_LIQUIFY_LAYER_HARDNESSPOINT2:</a>
<a name="ln2858">         d-&gt;warp.control2 = MIN (1.0, cabs (pt - *start_pt) / cabs (d-&gt;warp.radius - *start_pt));</a>
<a name="ln2859">         break;</a>
<a name="ln2860"> </a>
<a name="ln2861">       default:</a>
<a name="ln2862">         break;</a>
<a name="ln2863">    }</a>
<a name="ln2864">    handled = 1;</a>
<a name="ln2865">  }</a>
<a name="ln2866"> </a>
<a name="ln2867">done:</a>
<a name="ln2868">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln2869">  if (handled)</a>
<a name="ln2870">  {</a>
<a name="ln2871">    sync_pipe (module, handled == 2);</a>
<a name="ln2872">  }</a>
<a name="ln2873">  return handled;</a>
<a name="ln2874">}</a>
<a name="ln2875"> </a>
<a name="ln2876">/*</a>
<a name="ln2877">  add support for changing the radius and the strength vector for the temp node</a>
<a name="ln2878"> */</a>
<a name="ln2879">int scrolled(struct dt_iop_module_t *module, double x, double y, int up, uint32_t state)</a>
<a name="ln2880">{</a>
<a name="ln2881">  const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2882"> </a>
<a name="ln2883">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln2884">  if(darktable.develop-&gt;darkroom_skip_mouse_events) return 0;</a>
<a name="ln2885"> </a>
<a name="ln2886">  if (g-&gt;temp)</a>
<a name="ln2887">  {</a>
<a name="ln2888">    dt_liquify_warp_t *warp = &amp;g-&gt;temp-&gt;warp;</a>
<a name="ln2889">    const float complex strength_v = warp-&gt;strength - warp-&gt;point;</a>
<a name="ln2890"> </a>
<a name="ln2891">    if (state == 0)</a>
<a name="ln2892">    {</a>
<a name="ln2893">      //  change size</a>
<a name="ln2894">      float radius = dt_conf_get_float(CONF_RADIUS);</a>
<a name="ln2895">      const float phi = carg(strength_v);</a>
<a name="ln2896">      float r = cabs(strength_v);</a>
<a name="ln2897">      float factor = 1.0f;</a>
<a name="ln2898"> </a>
<a name="ln2899">      if(up &amp;&amp; cabs(warp-&gt;radius - warp-&gt;point) &gt; 10.0f)</a>
<a name="ln2900">        factor *= 0.97f;</a>
<a name="ln2901">      else if(!up)</a>
<a name="ln2902">        factor *= 1.0f / 0.97f;</a>
<a name="ln2903"> </a>
<a name="ln2904">      r *= factor;</a>
<a name="ln2905">      radius *= factor;</a>
<a name="ln2906"> </a>
<a name="ln2907">      warp-&gt;radius = warp-&gt;point + (radius * factor);</a>
<a name="ln2908">      warp-&gt;strength = warp-&gt;point + r * cexp (phi * I);</a>
<a name="ln2909"> </a>
<a name="ln2910">      dt_conf_set_float(CONF_RADIUS, radius);</a>
<a name="ln2911">      dt_conf_set_float(CONF_STRENGTH, r);</a>
<a name="ln2912">      return 1;</a>
<a name="ln2913">    }</a>
<a name="ln2914">    else if (state &amp; GDK_CONTROL_MASK)</a>
<a name="ln2915">    {</a>
<a name="ln2916">      //  change the strength direction</a>
<a name="ln2917">      float phi = carg(strength_v);</a>
<a name="ln2918">      const float r = cabs(strength_v);</a>
<a name="ln2919"> </a>
<a name="ln2920">      if(up)</a>
<a name="ln2921">        phi += M_PI / 16.0f;</a>
<a name="ln2922">      else</a>
<a name="ln2923">        phi -= M_PI / 16.0f;</a>
<a name="ln2924"> </a>
<a name="ln2925">      warp-&gt;strength = warp-&gt;point + r * cexp (phi * I);</a>
<a name="ln2926">      dt_conf_set_float(CONF_STRENGTH, r);</a>
<a name="ln2927">      dt_conf_set_float(CONF_ANGLE, phi);</a>
<a name="ln2928">      return 1;</a>
<a name="ln2929">    }</a>
<a name="ln2930">    else if (state &amp; GDK_SHIFT_MASK)</a>
<a name="ln2931">    {</a>
<a name="ln2932">      //  change the strength</a>
<a name="ln2933">      const float phi = carg(strength_v);</a>
<a name="ln2934">      float r = cabs(strength_v);</a>
<a name="ln2935"> </a>
<a name="ln2936">      if(up)</a>
<a name="ln2937">        r *= 0.97f;</a>
<a name="ln2938">      else</a>
<a name="ln2939">        r *= 1.0f / 0.97f;</a>
<a name="ln2940"> </a>
<a name="ln2941">      warp-&gt;strength = warp-&gt;point + r * cexp (phi * I);</a>
<a name="ln2942">      dt_conf_set_float(CONF_STRENGTH, r);</a>
<a name="ln2943">      dt_conf_set_float(CONF_ANGLE, phi);</a>
<a name="ln2944">      return 1;</a>
<a name="ln2945">    }</a>
<a name="ln2946">  }</a>
<a name="ln2947"> </a>
<a name="ln2948">  return 0;</a>
<a name="ln2949">}</a>
<a name="ln2950"> </a>
<a name="ln2951">int button_pressed (struct dt_iop_module_t *module,</a>
<a name="ln2952">                    double x,</a>
<a name="ln2953">                    double y,</a>
<a name="ln2954">                    double pressure,</a>
<a name="ln2955">                    int which,</a>
<a name="ln2956">                    int type,</a>
<a name="ln2957">                    uint32_t state)</a>
<a name="ln2958">{</a>
<a name="ln2959">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln2960">  int handled = 0;</a>
<a name="ln2961">  float complex pt;</a>
<a name="ln2962">  float scale;</a>
<a name="ln2963"> </a>
<a name="ln2964">  get_point_scale(module, x, y, &amp;pt, &amp;scale);</a>
<a name="ln2965"> </a>
<a name="ln2966">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln2967"> </a>
<a name="ln2968">  g-&gt;last_mouse_pos = pt;</a>
<a name="ln2969">  g-&gt;last_mouse_mods = state &amp; gtk_accelerator_get_default_mod_mask ();</a>
<a name="ln2970">  if (which == 1)</a>
<a name="ln2971">    g-&gt;last_button1_pressed_pos = pt;</a>
<a name="ln2972"> </a>
<a name="ln2973">  if (!is_dragging(g))</a>
<a name="ln2974">    // while dragging you would always hit the dragged thing</a>
<a name="ln2975">    g-&gt;last_hit = hit_test_paths (module, scale, g-&gt;fake_cr, &amp;g-&gt;params, pt);</a>
<a name="ln2976"> </a>
<a name="ln2977">  if (which == 2) goto done;</a>
<a name="ln2978"> </a>
<a name="ln2979">  // Point tool</a>
<a name="ln2980"> </a>
<a name="ln2981">  if (which == 1 &amp;&amp; gtk_toggle_button_get_active (g-&gt;btn_point_tool))</a>
<a name="ln2982">  {</a>
<a name="ln2983">    // always end dragging before manipulating the path list to avoid</a>
<a name="ln2984">    // dangling pointers</a>
<a name="ln2985">    end_drag (g);</a>
<a name="ln2986"> </a>
<a name="ln2987">    if (!g-&gt;temp) goto done;</a>
<a name="ln2988">    g-&gt;status |= DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln2989">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln2990"> </a>
<a name="ln2991">    start_drag (g, DT_LIQUIFY_LAYER_STRENGTHPOINT, g-&gt;temp);</a>
<a name="ln2992">    g-&gt;last_hit = NOWHERE;</a>
<a name="ln2993">    handled = 1;</a>
<a name="ln2994">    goto done;</a>
<a name="ln2995">  }</a>
<a name="ln2996"> </a>
<a name="ln2997">  // Line tool or curve tool</a>
<a name="ln2998"> </a>
<a name="ln2999">  if (which == 1 &amp;&amp; (gtk_toggle_button_get_active (g-&gt;btn_line_tool)</a>
<a name="ln3000">                     || gtk_toggle_button_get_active (g-&gt;btn_curve_tool)))</a>
<a name="ln3001">  {</a>
<a name="ln3002">    // always end dragging before manipulating the path list to avoid</a>
<a name="ln3003">    // dangling pointers</a>
<a name="ln3004">    end_drag (g);</a>
<a name="ln3005">    if (!g-&gt;temp)</a>
<a name="ln3006">    {</a>
<a name="ln3007">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3008">      {</a>
<a name="ln3009">        // continue path</a>
<a name="ln3010">        g-&gt;temp = g-&gt;last_hit.elem;</a>
<a name="ln3011">      }</a>
<a name="ln3012">      else</a>
<a name="ln3013">      {</a>
<a name="ln3014">        if (!g-&gt;temp) goto done;</a>
<a name="ln3015">      }</a>
<a name="ln3016">    }</a>
<a name="ln3017">    g-&gt;last_hit = NOWHERE;</a>
<a name="ln3018">    if (gtk_toggle_button_get_active (g-&gt;btn_curve_tool))</a>
<a name="ln3019">    {</a>
<a name="ln3020">      start_drag (g, DT_LIQUIFY_LAYER_CTRLPOINT1, g-&gt;temp);</a>
<a name="ln3021">    }</a>
<a name="ln3022">    g-&gt;status |= DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3023">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3024">    handled = 1;</a>
<a name="ln3025">    goto done;</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028">  // Node tool</a>
<a name="ln3029"> </a>
<a name="ln3030">  if (gtk_toggle_button_get_active (g-&gt;btn_node_tool))</a>
<a name="ln3031">  {</a>
<a name="ln3032">    if (which == 1 &amp;&amp; (g-&gt;last_mouse_mods == GDK_CONTROL_MASK) &amp;&amp;</a>
<a name="ln3033">        (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT))</a>
<a name="ln3034">    {</a>
<a name="ln3035">      // cycle node type: smooth -&gt; cusp etc.</a>
<a name="ln3036">      dt_liquify_path_data_t *node = g-&gt;last_hit.elem;</a>
<a name="ln3037">      node-&gt;header.node_type = (node-&gt;header.node_type + 1) % DT_LIQUIFY_NODE_TYPE_LAST;</a>
<a name="ln3038">      handled = 1;</a>
<a name="ln3039">      goto done;</a>
<a name="ln3040">    }</a>
<a name="ln3041">    if (which == 1 &amp;&amp; (g-&gt;last_mouse_mods == GDK_CONTROL_MASK) &amp;&amp;</a>
<a name="ln3042">        (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_STRENGTHPOINT))</a>
<a name="ln3043">    {</a>
<a name="ln3044">      // cycle warp type: linear -&gt; radial etc.</a>
<a name="ln3045">      if (g-&gt;last_hit.elem-&gt;header.type == DT_LIQUIFY_PATH_MOVE_TO_V1)</a>
<a name="ln3046">      {</a>
<a name="ln3047">        dt_liquify_warp_t *warp = &amp;g-&gt;last_hit.elem-&gt;warp;</a>
<a name="ln3048">        warp-&gt;type = (warp-&gt;type + 1) % DT_LIQUIFY_WARP_TYPE_LAST;</a>
<a name="ln3049">      }</a>
<a name="ln3050">      handled = 1;</a>
<a name="ln3051">      goto done;</a>
<a name="ln3052">    }</a>
<a name="ln3053">  }</a>
<a name="ln3054"> </a>
<a name="ln3055">done:</a>
<a name="ln3056">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln3057">  if (handled)</a>
<a name="ln3058">    sync_pipe (module, TRUE);</a>
<a name="ln3059">  return handled;</a>
<a name="ln3060">}</a>
<a name="ln3061"> </a>
<a name="ln3062">int button_released (struct dt_iop_module_t *module,</a>
<a name="ln3063">                     double x,</a>
<a name="ln3064">                     double y,</a>
<a name="ln3065">                     int which,</a>
<a name="ln3066">                     uint32_t state)</a>
<a name="ln3067">{</a>
<a name="ln3068">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3069">  int handled = 0;</a>
<a name="ln3070">  float complex pt;</a>
<a name="ln3071">  float scale;</a>
<a name="ln3072"> </a>
<a name="ln3073">  get_point_scale(module, x, y, &amp;pt, &amp;scale);</a>
<a name="ln3074"> </a>
<a name="ln3075">  dt_pthread_mutex_lock (&amp;g-&gt;lock);</a>
<a name="ln3076"> </a>
<a name="ln3077">  g-&gt;last_mouse_pos = pt;</a>
<a name="ln3078"> </a>
<a name="ln3079">  const gboolean dragged = detect_drag (g, scale, pt);</a>
<a name="ln3080"> </a>
<a name="ln3081">  if (which == 1 &amp;&amp; g-&gt;temp &amp;&amp; (g-&gt;status &amp; DT_LIQUIFY_STATUS_NEW))</a>
<a name="ln3082">  {</a>
<a name="ln3083">    end_drag (g);</a>
<a name="ln3084">    if (gtk_toggle_button_get_active (g-&gt;btn_point_tool))</a>
<a name="ln3085">    {</a>
<a name="ln3086">      g-&gt;temp = NULL; // a point is done</a>
<a name="ln3087">      gtk_toggle_button_set_active (g-&gt;btn_node_tool, 1);</a>
<a name="ln3088">      handled = dragged ? 2 : 1;</a>
<a name="ln3089">    }</a>
<a name="ln3090">    else if (gtk_toggle_button_get_active (g-&gt;btn_line_tool))</a>
<a name="ln3091">    {</a>
<a name="ln3092">      const int prev_index = g-&gt;node_index;</a>
<a name="ln3093">      const float complex strength = (g-&gt;temp-&gt;warp.strength - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3094">      const float radius = cabs(g-&gt;temp-&gt;warp.radius - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3095">      g-&gt;temp = alloc_line_to (module, pt);</a>
<a name="ln3096">      if (!g-&gt;temp) goto done;</a>
<a name="ln3097">      g-&gt;temp-&gt;warp.radius   = pt + radius;</a>
<a name="ln3098">      g-&gt;temp-&gt;warp.strength = pt + strength;</a>
<a name="ln3099">      // links</a>
<a name="ln3100">      g-&gt;temp-&gt;header.prev = prev_index;</a>
<a name="ln3101">      node_get(&amp;g-&gt;params, prev_index)-&gt;header.next = g-&gt;node_index;</a>
<a name="ln3102">      start_drag (g, DT_LIQUIFY_LAYER_CENTERPOINT, g-&gt;temp);</a>
<a name="ln3103">      handled = 1;</a>
<a name="ln3104">    }</a>
<a name="ln3105">    else if (gtk_toggle_button_get_active (g-&gt;btn_curve_tool))</a>
<a name="ln3106">    {</a>
<a name="ln3107">      const int prev_index = g-&gt;node_index;</a>
<a name="ln3108">      const float complex strength = (g-&gt;temp-&gt;warp.strength - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3109">      const float radius = cabs(g-&gt;temp-&gt;warp.radius - g-&gt;temp-&gt;warp.point);</a>
<a name="ln3110">      g-&gt;temp = alloc_curve_to (module, pt);</a>
<a name="ln3111">      if (!g-&gt;temp) goto done;</a>
<a name="ln3112">      // user dragged, make it a symmetrical node</a>
<a name="ln3113">      if (dragged)</a>
<a name="ln3114">      {</a>
<a name="ln3115">        g-&gt;temp-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_SYMMETRICAL;</a>
<a name="ln3116">      }</a>
<a name="ln3117">      g-&gt;temp-&gt;warp.radius = pt + radius;</a>
<a name="ln3118">      g-&gt;temp-&gt;warp.strength = pt + strength;</a>
<a name="ln3119">      // links</a>
<a name="ln3120">      g-&gt;temp-&gt;header.prev = prev_index;</a>
<a name="ln3121">      node_get(&amp;g-&gt;params, prev_index)-&gt;header.next = g-&gt;node_index;</a>
<a name="ln3122">      start_drag (g, DT_LIQUIFY_LAYER_CENTERPOINT, g-&gt;temp);</a>
<a name="ln3123">      handled = 1;</a>
<a name="ln3124">    }</a>
<a name="ln3125">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3126">    goto done;</a>
<a name="ln3127">  }</a>
<a name="ln3128"> </a>
<a name="ln3129">  if (which == 1 &amp;&amp; is_dragging(g))</a>
<a name="ln3130">  {</a>
<a name="ln3131">    end_drag (g);</a>
<a name="ln3132">    handled = 2;</a>
<a name="ln3133">    goto done;</a>
<a name="ln3134">  }</a>
<a name="ln3135"> </a>
<a name="ln3136">  // right click == cancel or delete</a>
<a name="ln3137">  if (which == 3)</a>
<a name="ln3138">  {</a>
<a name="ln3139">    dt_control_hinter_message (darktable.control, &quot;&quot;);</a>
<a name="ln3140">    end_drag (g);</a>
<a name="ln3141"> </a>
<a name="ln3142">    // cancel line or curve creation</a>
<a name="ln3143">    if (g-&gt;temp)</a>
<a name="ln3144">    {</a>
<a name="ln3145">      node_delete (&amp;g-&gt;params, g-&gt;temp);</a>
<a name="ln3146">      g-&gt;temp = NULL;</a>
<a name="ln3147">      g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3148">      gtk_toggle_button_set_active (g-&gt;btn_node_tool, 1);</a>
<a name="ln3149">      handled = 2;</a>
<a name="ln3150">      goto done;</a>
<a name="ln3151">    }</a>
<a name="ln3152"> </a>
<a name="ln3153">    // right click on background toggles node tool</a>
<a name="ln3154">    if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_BACKGROUND)</a>
<a name="ln3155">    {</a>
<a name="ln3156">      gtk_toggle_button_set_active (g-&gt;btn_node_tool,</a>
<a name="ln3157">                                    !gtk_toggle_button_get_active (g-&gt;btn_node_tool));</a>
<a name="ln3158">      handled = 1;</a>
<a name="ln3159">      goto done;</a>
<a name="ln3160">    }</a>
<a name="ln3161"> </a>
<a name="ln3162">    // delete node</a>
<a name="ln3163">    if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3164">    {</a>
<a name="ln3165">      node_delete (&amp;g-&gt;params, g-&gt;last_hit.elem);</a>
<a name="ln3166">      g-&gt;last_hit = NOWHERE;</a>
<a name="ln3167">      handled = 2;</a>
<a name="ln3168">      goto done;</a>
<a name="ln3169">    }</a>
<a name="ln3170">    // delete shape</a>
<a name="ln3171">    if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln3172">    {</a>
<a name="ln3173">      path_delete (&amp;g-&gt;params, g-&gt;last_hit.elem);</a>
<a name="ln3174">      g-&gt;last_hit = NOWHERE;</a>
<a name="ln3175">      handled = 2;</a>
<a name="ln3176">      goto done;</a>
<a name="ln3177">    }</a>
<a name="ln3178">    goto done;</a>
<a name="ln3179">  }</a>
<a name="ln3180"> </a>
<a name="ln3181">  // Node tool</a>
<a name="ln3182"> </a>
<a name="ln3183">  if (gtk_toggle_button_get_active (g-&gt;btn_node_tool))</a>
<a name="ln3184">  {</a>
<a name="ln3185">    if (which == 1 &amp;&amp; g-&gt;last_mouse_mods == 0 &amp;&amp; !dragged)</a>
<a name="ln3186">    {</a>
<a name="ln3187">      // select/unselect start/endpoint and clear previous selections</a>
<a name="ln3188">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3189">      {</a>
<a name="ln3190">        const int oldsel = !!g-&gt;last_hit.elem-&gt;header.selected;</a>
<a name="ln3191">	unselect_all (&amp;g-&gt;params);</a>
<a name="ln3192">        g-&gt;last_hit.elem-&gt;header.selected = oldsel ? 0 : g-&gt;last_hit.layer;</a>
<a name="ln3193">        handled = 1;</a>
<a name="ln3194">        goto done;</a>
<a name="ln3195">      }</a>
<a name="ln3196">      // unselect all</a>
<a name="ln3197">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_BACKGROUND)</a>
<a name="ln3198">      {</a>
<a name="ln3199">        unselect_all (&amp;g-&gt;params);</a>
<a name="ln3200">        handled = 1;</a>
<a name="ln3201">        goto done;</a>
<a name="ln3202">      }</a>
<a name="ln3203">    }</a>
<a name="ln3204">    if (which == 1 &amp;&amp; g-&gt;last_mouse_mods == GDK_SHIFT_MASK &amp;&amp; !dragged)</a>
<a name="ln3205">    {</a>
<a name="ln3206">      // select/unselect start/endpoint and keep previous selections</a>
<a name="ln3207">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_CENTERPOINT)</a>
<a name="ln3208">      {</a>
<a name="ln3209">        const int oldsel = !!g-&gt;last_hit.elem-&gt;header.selected;</a>
<a name="ln3210">        g-&gt;last_hit.elem-&gt;header.selected = oldsel ? 0 : g-&gt;last_hit.layer;</a>
<a name="ln3211">        handled = 1;</a>
<a name="ln3212">        goto done;</a>
<a name="ln3213">      }</a>
<a name="ln3214">    }</a>
<a name="ln3215">    if (which == 1 &amp;&amp; (g-&gt;last_mouse_mods == GDK_CONTROL_MASK) &amp;&amp; !dragged)</a>
<a name="ln3216">    {</a>
<a name="ln3217">      // add node</a>
<a name="ln3218">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln3219">      {</a>
<a name="ln3220">        dt_liquify_path_data_t *e = g-&gt;last_hit.elem;</a>
<a name="ln3221">        dt_liquify_path_data_t *prev = node_prev (&amp;g-&gt;params, e);</a>
<a name="ln3222">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln3223">        {</a>
<a name="ln3224">	  // add node to curve</a>
<a name="ln3225">          dt_liquify_path_data_t *curve1 = (dt_liquify_path_data_t *) e;</a>
<a name="ln3226"> </a>
<a name="ln3227">          dt_liquify_path_data_t *curve2 = (dt_liquify_path_data_t *)alloc_curve_to (module, 0);</a>
<a name="ln3228">          if (!curve2) goto done;</a>
<a name="ln3229"> </a>
<a name="ln3230">          curve2-&gt;node.ctrl1 = curve1-&gt;node.ctrl1;</a>
<a name="ln3231">          curve2-&gt;node.ctrl2 = curve1-&gt;node.ctrl2;</a>
<a name="ln3232"> </a>
<a name="ln3233">          dt_liquify_warp_t *warp1 = &amp;prev-&gt;warp;</a>
<a name="ln3234">          dt_liquify_warp_t *warp2 = &amp;curve2-&gt;warp;</a>
<a name="ln3235">          dt_liquify_warp_t *warp3 = &amp;e-&gt;warp;</a>
<a name="ln3236"> </a>
<a name="ln3237">          const float t = find_nearest_on_curve_t (warp1-&gt;point, curve1-&gt;node.ctrl1, curve1-&gt;node.ctrl2,</a>
<a name="ln3238">                                                   warp3-&gt;point, pt, INTERPOLATION_POINTS);</a>
<a name="ln3239"> </a>
<a name="ln3240">          float complex midpoint = warp3-&gt;point;</a>
<a name="ln3241">          casteljau (&amp;warp1-&gt;point, &amp;curve1-&gt;node.ctrl1, &amp;curve1-&gt;node.ctrl2, &amp;midpoint, t);</a>
<a name="ln3242">          midpoint = warp1-&gt;point;</a>
<a name="ln3243">          casteljau (&amp;warp3-&gt;point, &amp;curve2-&gt;node.ctrl2, &amp;curve2-&gt;node.ctrl1, &amp;midpoint, 1.0 - t);</a>
<a name="ln3244"> </a>
<a name="ln3245">          mix_warps (warp2, warp1, warp3, midpoint, t);</a>
<a name="ln3246"> </a>
<a name="ln3247">          node_insert_before (&amp;g-&gt;params, e, (dt_liquify_path_data_t *)curve2);</a>
<a name="ln3248"> </a>
<a name="ln3249">          handled = 2;</a>
<a name="ln3250">          goto done;</a>
<a name="ln3251">        }</a>
<a name="ln3252">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln3253">        {</a>
<a name="ln3254">	  // add node to line</a>
<a name="ln3255">          dt_liquify_warp_t *warp1 = &amp;prev-&gt;warp;</a>
<a name="ln3256">          dt_liquify_warp_t *warp3 = &amp;e-&gt;warp;</a>
<a name="ln3257">          const float t = find_nearest_on_line_t (warp1-&gt;point, warp3-&gt;point, pt);</a>
<a name="ln3258"> </a>
<a name="ln3259">          dt_liquify_path_data_t *tmp = alloc_line_to (module, e-&gt;warp.point);</a>
<a name="ln3260">          if (!tmp) goto done;</a>
<a name="ln3261"> </a>
<a name="ln3262">          dt_liquify_warp_t *warp2 = &amp;tmp-&gt;warp;</a>
<a name="ln3263">          double complex midpoint = cmix (warp1-&gt;point, warp3-&gt;point, t);</a>
<a name="ln3264"> </a>
<a name="ln3265">          mix_warps (warp2, warp1, warp3, midpoint, t);</a>
<a name="ln3266">          node_insert_before (&amp;g-&gt;params, e, tmp);</a>
<a name="ln3267"> </a>
<a name="ln3268">          handled = 2;</a>
<a name="ln3269">          goto done;</a>
<a name="ln3270">        }</a>
<a name="ln3271">      }</a>
<a name="ln3272">    }</a>
<a name="ln3273">    if (which == 1</a>
<a name="ln3274">        &amp;&amp; (g-&gt;last_mouse_mods == (GDK_MOD1_MASK | GDK_CONTROL_MASK))</a>
<a name="ln3275">        &amp;&amp; !dragged)</a>
<a name="ln3276">    {</a>
<a name="ln3277">      if (g-&gt;last_hit.layer == DT_LIQUIFY_LAYER_PATH)</a>
<a name="ln3278">      {</a>
<a name="ln3279">        // change segment</a>
<a name="ln3280">        dt_liquify_path_data_t *e = g-&gt;last_hit.elem;</a>
<a name="ln3281">        dt_liquify_path_data_t *prev = node_prev (&amp;g-&gt;params, e);</a>
<a name="ln3282">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_CURVE_TO_V1)</a>
<a name="ln3283">        {</a>
<a name="ln3284">          // curve -&gt; line</a>
<a name="ln3285">          e-&gt;header.type = DT_LIQUIFY_PATH_LINE_TO_V1;</a>
<a name="ln3286">          e-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln3287">          e-&gt;header.selected = e-&gt;header.hovered = 0;</a>
<a name="ln3288">          handled = 2;</a>
<a name="ln3289">          goto done;</a>
<a name="ln3290">        }</a>
<a name="ln3291">        if (prev &amp;&amp; e-&gt;header.type == DT_LIQUIFY_PATH_LINE_TO_V1)</a>
<a name="ln3292">        {</a>
<a name="ln3293">          // line -&gt; curve</a>
<a name="ln3294">          const float complex p0 = prev-&gt;warp.point;</a>
<a name="ln3295">          const float complex p1 = e-&gt;warp.point;</a>
<a name="ln3296">          dt_liquify_path_data_t *c = (dt_liquify_path_data_t *)e;</a>
<a name="ln3297">          e-&gt;header.type = DT_LIQUIFY_PATH_CURVE_TO_V1;</a>
<a name="ln3298">          e-&gt;header.node_type = DT_LIQUIFY_NODE_TYPE_AUTOSMOOTH;</a>
<a name="ln3299">          c-&gt;node.ctrl1 = (2 * p0 +     p1) / 3.0;</a>
<a name="ln3300">          c-&gt;node.ctrl2 = (    p0 + 2 * p1) / 3.0;</a>
<a name="ln3301"> </a>
<a name="ln3302">          handled = 2;</a>
<a name="ln3303">          goto done;</a>
<a name="ln3304">        }</a>
<a name="ln3305">      }</a>
<a name="ln3306">    }</a>
<a name="ln3307">  }</a>
<a name="ln3308"> </a>
<a name="ln3309">done:</a>
<a name="ln3310">  if (which == 1)</a>
<a name="ln3311">    g-&gt;last_button1_pressed_pos = -1;</a>
<a name="ln3312">  g-&gt;last_hit = NOWHERE;</a>
<a name="ln3313">  dt_pthread_mutex_unlock (&amp;g-&gt;lock);</a>
<a name="ln3314">  if (handled)</a>
<a name="ln3315">  {</a>
<a name="ln3316">    update_warp_count (g);</a>
<a name="ln3317">    sync_pipe (module, handled == 2);</a>
<a name="ln3318">  }</a>
<a name="ln3319">  return handled;</a>
<a name="ln3320">}</a>
<a name="ln3321"> </a>
<a name="ln3322">static void _liquify_cairo_paint_point_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3323">                                            const gint flags, void *data);</a>
<a name="ln3324"> </a>
<a name="ln3325">static void _liquify_cairo_paint_line_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3326">                                           const gint flags, void *data);</a>
<a name="ln3327"> </a>
<a name="ln3328">static void _liquify_cairo_paint_curve_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3329">                                            const gint flags, void *data);</a>
<a name="ln3330"> </a>
<a name="ln3331">static void _liquify_cairo_paint_node_tool(cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3332">                                           const gint flags, void *data);</a>
<a name="ln3333"> </a>
<a name="ln3334"> </a>
<a name="ln3335">static float conf_set_get_default(const char *name, float def)</a>
<a name="ln3336">{</a>
<a name="ln3337">  float value;</a>
<a name="ln3338">  if(dt_conf_key_exists(name))</a>
<a name="ln3339">  {</a>
<a name="ln3340">    value = dt_conf_get_float(name);</a>
<a name="ln3341">    // do some sanity check, the value must &gt; 1.0 (these are value in pixels), reset to default if not</a>
<a name="ln3342">    if((value &lt;= 1.0f || value &gt; 3000.0f) &amp;&amp; strcmp(name, CONF_ANGLE))</a>
<a name="ln3343">    {</a>
<a name="ln3344">      value = def;</a>
<a name="ln3345">      dt_conf_set_float(name, value);</a>
<a name="ln3346">    }</a>
<a name="ln3347">  }</a>
<a name="ln3348">  else</a>
<a name="ln3349">  {</a>
<a name="ln3350">    value = def;</a>
<a name="ln3351">    dt_conf_set_float(name, value);</a>
<a name="ln3352">  }</a>
<a name="ln3353">  return value;</a>
<a name="ln3354">}</a>
<a name="ln3355"> </a>
<a name="ln3356">// we need this only because darktable has no radiobutton support</a>
<a name="ln3357">static void btn_make_radio_callback (GtkToggleButton *btn, dt_iop_module_t *module)</a>
<a name="ln3358">{</a>
<a name="ln3359">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3360"> </a>
<a name="ln3361">  // if currently dragging and a form (line or node) has been started, does nothing (expect reseting the toggle button status).</a>
<a name="ln3362"> </a>
<a name="ln3363">  if (is_dragging(g) &amp;&amp; g-&gt;temp &amp;&amp; node_prev(&amp;g-&gt;params, g-&gt;temp))</a>
<a name="ln3364">  {</a>
<a name="ln3365">    g_signal_handlers_block_matched(g-&gt;btn_point_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3366">    g_signal_handlers_block_matched(g-&gt;btn_line_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3367">    g_signal_handlers_block_matched(g-&gt;btn_curve_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3368">    g_signal_handlers_block_matched(g-&gt;btn_node_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3369"> </a>
<a name="ln3370">    gtk_toggle_button_set_active (btn, !gtk_toggle_button_get_active(btn));</a>
<a name="ln3371"> </a>
<a name="ln3372">    g_signal_handlers_unblock_matched(g-&gt;btn_point_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3373">    g_signal_handlers_unblock_matched(g-&gt;btn_line_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3374">    g_signal_handlers_unblock_matched(g-&gt;btn_curve_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3375">    g_signal_handlers_unblock_matched(g-&gt;btn_node_tool, G_SIGNAL_MATCH_FUNC, 0, 0, NULL, btn_make_radio_callback, NULL);</a>
<a name="ln3376">    return;</a>
<a name="ln3377">  }</a>
<a name="ln3378"> </a>
<a name="ln3379">  dt_control_hinter_message (darktable.control, &quot;&quot;);</a>
<a name="ln3380"> </a>
<a name="ln3381">  // if we are on a preview, it means that a form (point, line, curve) has been started, but no node has yet been placed.</a>
<a name="ln3382">  // in this case we abort the current preview and let the new tool activated.</a>
<a name="ln3383"> </a>
<a name="ln3384">  if (g-&gt;status &amp; DT_LIQUIFY_STATUS_PREVIEW)</a>
<a name="ln3385">  {</a>
<a name="ln3386">    node_delete (&amp;g-&gt;params, g-&gt;temp);</a>
<a name="ln3387">    g-&gt;temp = NULL;</a>
<a name="ln3388">    g-&gt;status &amp;= ~DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3389">  }</a>
<a name="ln3390"> </a>
<a name="ln3391">  // now, let's enable and start a new form safely</a>
<a name="ln3392"> </a>
<a name="ln3393">  if (gtk_toggle_button_get_active (btn))</a>
<a name="ln3394">  {</a>
<a name="ln3395">    gtk_toggle_button_set_active (g-&gt;btn_point_tool, btn == g-&gt;btn_point_tool);</a>
<a name="ln3396">    gtk_toggle_button_set_active (g-&gt;btn_line_tool,  btn == g-&gt;btn_line_tool);</a>
<a name="ln3397">    gtk_toggle_button_set_active (g-&gt;btn_curve_tool, btn == g-&gt;btn_curve_tool);</a>
<a name="ln3398">    gtk_toggle_button_set_active (g-&gt;btn_node_tool,  btn == g-&gt;btn_node_tool);</a>
<a name="ln3399"> </a>
<a name="ln3400">    if (btn == g-&gt;btn_point_tool)</a>
<a name="ln3401">      dt_control_hinter_message</a>
<a name="ln3402">        (darktable.control, _(&quot;click and drag to add point\nscroll to change size\n&quot;</a>
<a name="ln3403">                              &quot;shift-scroll to change strength - ctrl-scroll to change direction&quot;));</a>
<a name="ln3404">    else if (btn == g-&gt;btn_line_tool)</a>
<a name="ln3405">      dt_control_hinter_message</a>
<a name="ln3406">        (darktable.control, _(&quot;click to add line\nscroll to change size\n&quot;</a>
<a name="ln3407">                              &quot;shift-scroll to change strength - ctrl-scroll to change direction&quot;));</a>
<a name="ln3408">    else if (btn == g-&gt;btn_curve_tool)</a>
<a name="ln3409">      dt_control_hinter_message</a>
<a name="ln3410">        (darktable.control, _(&quot;click to add curve\nscroll to change size\n&quot;</a>
<a name="ln3411">                              &quot;shift-scroll to change strength - ctrl-scroll to change direction&quot;));</a>
<a name="ln3412">    else if (btn == g-&gt;btn_node_tool)</a>
<a name="ln3413">      dt_control_hinter_message (darktable.control, _(&quot;click to edit nodes&quot;));</a>
<a name="ln3414"> </a>
<a name="ln3415">    //  start the preview mode to show the shape that will be created</a>
<a name="ln3416"> </a>
<a name="ln3417">    if (btn == g-&gt;btn_point_tool || btn == g-&gt;btn_line_tool || btn == g-&gt;btn_curve_tool)</a>
<a name="ln3418">    {</a>
<a name="ln3419">      float complex pt;</a>
<a name="ln3420">      float scale;</a>
<a name="ln3421"> </a>
<a name="ln3422">      //  create initial shape at the center</a>
<a name="ln3423">      get_point_scale(module, .5f * darktable.develop-&gt;width, .5f * darktable.develop-&gt;height, &amp;pt, &amp;scale);</a>
<a name="ln3424"> </a>
<a name="ln3425">      //  start a new path</a>
<a name="ln3426">      g-&gt;temp = alloc_move_to (module, pt);</a>
<a name="ln3427"> </a>
<a name="ln3428">      //  start with current saved size/strength</a>
<a name="ln3429"> </a>
<a name="ln3430">      const float radius = conf_set_get_default(CONF_RADIUS, GET_UI_WIDTH(DEFAULT_RADIUS));</a>
<a name="ln3431">      const float r = conf_set_get_default(CONF_STRENGTH, GET_UI_WIDTH(DEFAULT_STRENGTH));</a>
<a name="ln3432">      const float phi = conf_set_get_default(CONF_ANGLE, 0);</a>
<a name="ln3433"> </a>
<a name="ln3434">      g-&gt;temp-&gt;warp.radius   = pt + radius;</a>
<a name="ln3435">      g-&gt;temp-&gt;warp.strength = pt + r * cexp (phi * I);</a>
<a name="ln3436"> </a>
<a name="ln3437">      g-&gt;status |= DT_LIQUIFY_STATUS_PREVIEW;</a>
<a name="ln3438">      g-&gt;status |= DT_LIQUIFY_STATUS_NEW;</a>
<a name="ln3439"> </a>
<a name="ln3440">      start_drag (g, DT_LIQUIFY_LAYER_CENTERPOINT, g-&gt;temp);</a>
<a name="ln3441">      g-&gt;last_hit = NOWHERE;</a>
<a name="ln3442">    }</a>
<a name="ln3443">  }</a>
<a name="ln3444"> </a>
<a name="ln3445">  sync_pipe (module, FALSE);</a>
<a name="ln3446">  dt_iop_request_focus(module);</a>
<a name="ln3447">}</a>
<a name="ln3448"> </a>
<a name="ln3449">void gui_update (dt_iop_module_t *module)</a>
<a name="ln3450">{</a>
<a name="ln3451">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3452">  memcpy(&amp;g-&gt;params, module-&gt;params, sizeof(dt_iop_liquify_params_t));</a>
<a name="ln3453">  update_warp_count(g);</a>
<a name="ln3454">}</a>
<a name="ln3455"> </a>
<a name="ln3456">void gui_init (dt_iop_module_t *module)</a>
<a name="ln3457">{</a>
<a name="ln3458">  const int bs = DT_PIXEL_APPLY_DPI(14);</a>
<a name="ln3459"> </a>
<a name="ln3460">  module-&gt;gui_data = malloc (sizeof (dt_iop_liquify_gui_data_t));</a>
<a name="ln3461">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3462"> </a>
<a name="ln3463">  // A dummy surface for calculations only, no drawing.</a>
<a name="ln3464">  cairo_surface_t *cs = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 1, 1);</a>
<a name="ln3465">  g-&gt;fake_cr = cairo_create (cs);</a>
<a name="ln3466">  cairo_surface_destroy (cs);</a>
<a name="ln3467"> </a>
<a name="ln3468">  g-&gt;dragging = NOWHERE;</a>
<a name="ln3469">  g-&gt;temp = NULL;</a>
<a name="ln3470">  g-&gt;status = 0;</a>
<a name="ln3471">  g-&gt;last_mouse_pos =</a>
<a name="ln3472">  g-&gt;last_button1_pressed_pos = -1;</a>
<a name="ln3473">  g-&gt;last_hit = NOWHERE;</a>
<a name="ln3474">  dt_pthread_mutex_init (&amp;g-&gt;lock, NULL);</a>
<a name="ln3475">  g-&gt;node_index = 0;</a>
<a name="ln3476"> </a>
<a name="ln3477">  module-&gt;widget = gtk_box_new (GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln3478">  dt_gui_add_help_link(module-&gt;widget, dt_get_help_url(module-&gt;op));</a>
<a name="ln3479"> </a>
<a name="ln3480">  GtkWidget *hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln3481">  gtk_widget_set_tooltip_text(hbox, _(&quot;use a tool to add warps.\nright-click to remove a warp.&quot;));</a>
<a name="ln3482"> </a>
<a name="ln3483">  gtk_box_pack_start(GTK_BOX(hbox), gtk_label_new (_(&quot;warps|nodes count:&quot;)), FALSE, TRUE, 0);</a>
<a name="ln3484">  g-&gt;label = GTK_LABEL(gtk_label_new (&quot;-&quot;));</a>
<a name="ln3485">  gtk_box_pack_start (GTK_BOX(hbox), GTK_WIDGET(g-&gt;label), FALSE, TRUE, 0);</a>
<a name="ln3486"> </a>
<a name="ln3487">  g-&gt;btn_node_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_node_tool,</a>
<a name="ln3488">                                                              CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3489">  g_signal_connect(G_OBJECT(g-&gt;btn_node_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3490">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_node_tool), _(&quot;node tool: edit, add and delete nodes&quot;));</a>
<a name="ln3491">  gtk_toggle_button_set_active (g-&gt;btn_node_tool, 0);</a>
<a name="ln3492">  gtk_widget_set_size_request(GTK_WIDGET(g-&gt;btn_node_tool), bs, bs);</a>
<a name="ln3493">  gtk_box_pack_end(GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_node_tool), FALSE, FALSE, 0);</a>
<a name="ln3494"> </a>
<a name="ln3495">  g-&gt;btn_curve_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_curve_tool,</a>
<a name="ln3496">                                                               CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3497">  g_signal_connect (G_OBJECT (g-&gt;btn_curve_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3498">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_curve_tool), _(&quot;curve tool: draw curves&quot;));</a>
<a name="ln3499">  gtk_toggle_button_set_active (g-&gt;btn_curve_tool, 0);</a>
<a name="ln3500">  gtk_widget_set_size_request (GTK_WIDGET(g-&gt;btn_curve_tool), bs, bs);</a>
<a name="ln3501">  gtk_box_pack_end (GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_curve_tool), FALSE, FALSE, 0);</a>
<a name="ln3502"> </a>
<a name="ln3503">  g-&gt;btn_line_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_line_tool,</a>
<a name="ln3504">                                                              CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3505">  g_signal_connect (G_OBJECT (g-&gt;btn_line_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3506">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_line_tool), _(&quot;line tool: draw lines&quot;));</a>
<a name="ln3507">  gtk_toggle_button_set_active (g-&gt;btn_line_tool, 0);</a>
<a name="ln3508">  gtk_widget_set_size_request (GTK_WIDGET(g-&gt;btn_line_tool), bs, bs);</a>
<a name="ln3509">  gtk_box_pack_end (GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_line_tool), FALSE, FALSE, 0);</a>
<a name="ln3510"> </a>
<a name="ln3511">  g-&gt;btn_point_tool = GTK_TOGGLE_BUTTON(dtgtk_togglebutton_new(_liquify_cairo_paint_point_tool,</a>
<a name="ln3512">                                                               CPF_STYLE_FLAT|CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln3513">  g_signal_connect (G_OBJECT (g-&gt;btn_point_tool), &quot;toggled&quot;, G_CALLBACK (btn_make_radio_callback), module);</a>
<a name="ln3514">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;btn_point_tool), _(&quot;point tool: draw points&quot;));</a>
<a name="ln3515">  gtk_toggle_button_set_active (g-&gt;btn_point_tool, 0);</a>
<a name="ln3516">  gtk_widget_set_size_request (GTK_WIDGET(g-&gt;btn_point_tool), bs, bs);</a>
<a name="ln3517">  gtk_box_pack_end (GTK_BOX(hbox), GTK_WIDGET(g-&gt;btn_point_tool), FALSE, FALSE, 0);</a>
<a name="ln3518"> </a>
<a name="ln3519">  gtk_box_pack_start(GTK_BOX(module-&gt;widget), hbox, TRUE, TRUE, 0);</a>
<a name="ln3520"> </a>
<a name="ln3521">  dt_liquify_layers[DT_LIQUIFY_LAYER_PATH].hint           = _(&quot;ctrl-click: add node - right click: remove path\n&quot;</a>
<a name="ln3522">                                                              &quot;ctrl-alt-click: toggle line/curve&quot;);</a>
<a name="ln3523">  dt_liquify_layers[DT_LIQUIFY_LAYER_CENTERPOINT].hint    = _(&quot;click and drag to move - click: show/hide feathering controls\n&quot;</a>
<a name="ln3524">                                                              &quot;ctrl-click: autosmooth, cusp, smooth, symmetrical&quot;</a>
<a name="ln3525">                                                              &quot; - right click to remove&quot;);</a>
<a name="ln3526">  dt_liquify_layers[DT_LIQUIFY_LAYER_CTRLPOINT1].hint     = _(&quot;drag to change shape of path&quot;);</a>
<a name="ln3527">  dt_liquify_layers[DT_LIQUIFY_LAYER_CTRLPOINT2].hint     = _(&quot;drag to change shape of path&quot;);</a>
<a name="ln3528">  dt_liquify_layers[DT_LIQUIFY_LAYER_RADIUSPOINT].hint    = _(&quot;drag to adjust warp radius&quot;);</a>
<a name="ln3529">  dt_liquify_layers[DT_LIQUIFY_LAYER_HARDNESSPOINT1].hint = _(&quot;drag to adjust hardness (center)&quot;);</a>
<a name="ln3530">  dt_liquify_layers[DT_LIQUIFY_LAYER_HARDNESSPOINT2].hint = _(&quot;drag to adjust hardness (feather)&quot;);</a>
<a name="ln3531">  dt_liquify_layers[DT_LIQUIFY_LAYER_STRENGTHPOINT].hint  = _(&quot;drag to adjust warp strength\n&quot;</a>
<a name="ln3532">                                                              &quot;ctrl-click: linear, grow, and shrink&quot;);</a>
<a name="ln3533">}</a>
<a name="ln3534"> </a>
<a name="ln3535">void gui_cleanup (dt_iop_module_t *module)</a>
<a name="ln3536">{</a>
<a name="ln3537">  dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3538">  if (g)</a>
<a name="ln3539">  {</a>
<a name="ln3540">    cairo_destroy (g-&gt;fake_cr);</a>
<a name="ln3541">    dt_pthread_mutex_destroy (&amp;g-&gt;lock);</a>
<a name="ln3542">    free (g);</a>
<a name="ln3543">  }</a>
<a name="ln3544">  module-&gt;gui_data = NULL;</a>
<a name="ln3545">}</a>
<a name="ln3546"> </a>
<a name="ln3547">void init_key_accels (dt_iop_module_so_t *module)</a>
<a name="ln3548">{</a>
<a name="ln3549">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;point tool&quot;),     0, 0);</a>
<a name="ln3550">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;line tool&quot;),      0, 0);</a>
<a name="ln3551">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;curve tool&quot;),     0, 0);</a>
<a name="ln3552">  dt_accel_register_iop (module, FALSE, NC_(&quot;accel&quot;, &quot;node tool&quot;),      0, 0);</a>
<a name="ln3553">}</a>
<a name="ln3554"> </a>
<a name="ln3555">void connect_key_accels (dt_iop_module_t *module)</a>
<a name="ln3556">{</a>
<a name="ln3557">  const dt_iop_liquify_gui_data_t *g = (dt_iop_liquify_gui_data_t *) module-&gt;gui_data;</a>
<a name="ln3558"> </a>
<a name="ln3559">  dt_accel_connect_button_iop (module, &quot;point tool&quot;,    GTK_WIDGET (g-&gt;btn_point_tool));</a>
<a name="ln3560">  dt_accel_connect_button_iop (module, &quot;line tool&quot;,     GTK_WIDGET (g-&gt;btn_line_tool));</a>
<a name="ln3561">  dt_accel_connect_button_iop (module, &quot;curve tool&quot;,    GTK_WIDGET (g-&gt;btn_curve_tool));</a>
<a name="ln3562">  dt_accel_connect_button_iop (module, &quot;node tool&quot;,     GTK_WIDGET (g-&gt;btn_node_tool));</a>
<a name="ln3563">}</a>
<a name="ln3564"> </a>
<a name="ln3565">// defgroup Button paint functions</a>
<a name="ln3566"> </a>
<a name="ln3567">#define PREAMBLE                                        \</a>
<a name="ln3568">  cairo_save (cr);                                      \</a>
<a name="ln3569">  const gint s = MIN (w, h);                            \</a>
<a name="ln3570">  cairo_translate (cr, x + (w / 2.0) - (s / 2.0),       \</a>
<a name="ln3571">                   y + (h / 2.0) - (s / 2.0));          \</a>
<a name="ln3572">  cairo_scale (cr, s, s);                               \</a>
<a name="ln3573">  cairo_push_group (cr);                                \</a>
<a name="ln3574">  cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, 1.0);       \</a>
<a name="ln3575">  cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);        \</a>
<a name="ln3576">  cairo_set_line_width (cr, 0.2);</a>
<a name="ln3577"> </a>
<a name="ln3578">#define POSTAMBLE                                               \</a>
<a name="ln3579">  cairo_pop_group_to_source (cr);                               \</a>
<a name="ln3580">  cairo_paint_with_alpha (cr, flags &amp; CPF_ACTIVE ? 1.0 : 0.5);  \</a>
<a name="ln3581">  cairo_restore (cr);</a>
<a name="ln3582"> </a>
<a name="ln3583">static void _liquify_cairo_paint_point_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3584">                                             const gint flags, void *data)</a>
<a name="ln3585">{</a>
<a name="ln3586">  PREAMBLE;</a>
<a name="ln3587">  cairo_new_sub_path (cr);</a>
<a name="ln3588">  cairo_arc (cr, 0.5, 0.5, 0.2, 0.0, 2 * M_PI);</a>
<a name="ln3589">  cairo_fill (cr);</a>
<a name="ln3590">  POSTAMBLE;</a>
<a name="ln3591">}</a>
<a name="ln3592"> </a>
<a name="ln3593">static void _liquify_cairo_paint_line_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3594">                                            const gint flags, void *data)</a>
<a name="ln3595">{</a>
<a name="ln3596">  PREAMBLE;</a>
<a name="ln3597">  cairo_move_to (cr, 0.1, 0.9);</a>
<a name="ln3598">  cairo_line_to (cr, 0.9, 0.1);</a>
<a name="ln3599">  cairo_stroke (cr);</a>
<a name="ln3600">  POSTAMBLE;</a>
<a name="ln3601">}</a>
<a name="ln3602"> </a>
<a name="ln3603">static void _liquify_cairo_paint_curve_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3604">                                             const gint flags, void *data)</a>
<a name="ln3605">{</a>
<a name="ln3606">  PREAMBLE;</a>
<a name="ln3607">  cairo_move_to (cr, 0.1, 0.9);</a>
<a name="ln3608">  cairo_curve_to (cr, 0.1, 0.5, 0.5, 0.1, 0.9, 0.1);</a>
<a name="ln3609">  cairo_stroke (cr);</a>
<a name="ln3610">  POSTAMBLE;</a>
<a name="ln3611">}</a>
<a name="ln3612"> </a>
<a name="ln3613">static void _liquify_cairo_paint_node_tool (cairo_t *cr, const gint x, const gint y, const gint w, const gint h,</a>
<a name="ln3614">                                            const gint flags, void *data)</a>
<a name="ln3615">{</a>
<a name="ln3616">  PREAMBLE;</a>
<a name="ln3617">  const double dashed[] = {0.2, 0.2};</a>
<a name="ln3618">  cairo_set_dash (cr, dashed, 2, 0);</a>
<a name="ln3619">  cairo_set_line_width (cr, 0.1);</a>
<a name="ln3620"> </a>
<a name="ln3621">  cairo_arc (cr, 0.75, 0.75, 0.75, 2.8, 4.7124);</a>
<a name="ln3622">  cairo_stroke (cr);</a>
<a name="ln3623"> </a>
<a name="ln3624">  cairo_rectangle (cr, 0.2, 0.0, 0.4, 0.4);</a>
<a name="ln3625">  cairo_fill (cr);</a>
<a name="ln3626"> </a>
<a name="ln3627">  cairo_move_to (cr, 0.4,  0.2);</a>
<a name="ln3628">  cairo_line_to (cr, 0.5,  1.0);</a>
<a name="ln3629">  cairo_line_to (cr, 0.9,  0.7);</a>
<a name="ln3630">  cairo_close_path (cr);</a>
<a name="ln3631">  cairo_fill (cr);</a>
<a name="ln3632">  POSTAMBLE;</a>
<a name="ln3633">}</a>
<a name="ln3634"> </a>
<a name="ln3635">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3636">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3637">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="383"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 381, 383.</p></div>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'b' pointer in the 'b ++' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 554, 542.</p></div>
<div class="balloon" rel="878"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'stamp' pointer in the 'stamp + i * stamp_extent->width' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 878, 868.</p></div>
<div class="balloon" rel="1476"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'k'. Check lines: 1476, 1475.</p></div>
<div class="balloon" rel="1599"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 1599, 1597.</p></div>
<div class="balloon" rel="1757"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'w'. Check lines: 1757, 1756.</p></div>
<div class="balloon" rel="2345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'a'. Check lines: 2345, 2333.</p></div>
<div class="balloon" rel="2345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'b'. Check lines: 2345, 2334.</p></div>
<div class="balloon" rel="2345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c'. Check lines: 2345, 2335.</p></div>
<div class="balloon" rel="2345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 2345, 2336.</p></div>
<div class="balloon" rel="2440"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'pt'. Check lines: 2440, 2427.</p></div>
<div class="balloon" rel="2443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c1'. Check lines: 2443, 2428.</p></div>
<div class="balloon" rel="2444"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c2'. Check lines: 2444, 2429.</p></div>
<div class="balloon" rel="2467"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'eqn'. Check lines: 2467, 2430.</p></div>
<div class="balloon" rel="2871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'handled == 2' is always false.</p></div>
<div class="balloon" rel="3014"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!g->temp' is always true.</p></div>
<div class="balloon" rel="3185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: g->last_mouse_mods == 0.</p></div>
<div class="balloon" rel="3465"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 3465, 3460.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
