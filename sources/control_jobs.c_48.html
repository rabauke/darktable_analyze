
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 johannes hanika</a>
<a name="ln4">    copyright (c) 2010-2012 henrik andersson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/film.h&quot;</a>
<a name="ln25">#include &quot;common/gpx.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image.h&quot;</a>
<a name="ln28">#include &quot;common/image_cache.h&quot;</a>
<a name="ln29">#include &quot;common/imageio.h&quot;</a>
<a name="ln30">#include &quot;common/imageio_dng.h&quot;</a>
<a name="ln31">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln32">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln33">#include &quot;common/tags.h&quot;</a>
<a name="ln34">#include &quot;control/conf.h&quot;</a>
<a name="ln35">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;gui/gtk.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gio/gio.h&gt;</a>
<a name="ln40">#include &lt;glib.h&gt;</a>
<a name="ln41">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln42">#ifndef _WIN32</a>
<a name="ln43">#include &lt;glob.h&gt;</a>
<a name="ln44">#endif</a>
<a name="ln45">#ifdef __APPLE__</a>
<a name="ln46">#include &quot;osx/osx.h&quot;</a>
<a name="ln47">#endif</a>
<a name="ln48">#ifdef _WIN32</a>
<a name="ln49">#include &quot;win/dtwin.h&quot;</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">typedef struct dt_control_time_offset_t</a>
<a name="ln53">{</a>
<a name="ln54">  long int offset;</a>
<a name="ln55">} dt_control_time_offset_t;</a>
<a name="ln56"> </a>
<a name="ln57">typedef struct dt_control_gpx_apply_t</a>
<a name="ln58">{</a>
<a name="ln59">  gchar *filename;</a>
<a name="ln60">  gchar *tz;</a>
<a name="ln61">} dt_control_gpx_apply_t;</a>
<a name="ln62"> </a>
<a name="ln63">typedef struct dt_control_export_t</a>
<a name="ln64">{</a>
<a name="ln65">  int max_width, max_height, format_index, storage_index;</a>
<a name="ln66">  dt_imageio_module_data_t *sdata; // needed since the gui thread resets things like overwrite once the export</a>
<a name="ln67">  // is dispatched, but we have to keep that information</a>
<a name="ln68">  gboolean high_quality, upscale;</a>
<a name="ln69">  char style[128];</a>
<a name="ln70">  gboolean style_append;</a>
<a name="ln71">  dt_colorspaces_color_profile_type_t icc_type;</a>
<a name="ln72">  gchar *icc_filename;</a>
<a name="ln73">  dt_iop_color_intent_t icc_intent;</a>
<a name="ln74">} dt_control_export_t;</a>
<a name="ln75"> </a>
<a name="ln76">typedef struct dt_control_image_enumerator_t</a>
<a name="ln77">{</a>
<a name="ln78">  GList *index;</a>
<a name="ln79">  int flag;</a>
<a name="ln80">  gpointer data;</a>
<a name="ln81">} dt_control_image_enumerator_t;</a>
<a name="ln82"> </a>
<a name="ln83">/* enumerator of images from filmroll */</a>
<a name="ln84">static void dt_control_image_enumerator_job_film_init(dt_control_image_enumerator_t *t, int32_t filmid)</a>
<a name="ln85">{</a>
<a name="ln86">  g_list_free(t-&gt;index);</a>
<a name="ln87">  t-&gt;index = NULL;</a>
<a name="ln88"> </a>
<a name="ln89">  sqlite3_stmt *stmt;</a>
<a name="ln90">  /* get a list of images in filmroll */</a>
<a name="ln91">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM main.images WHERE film_id = ?1&quot;, -1,</a>
<a name="ln92">                              &amp;stmt, NULL);</a>
<a name="ln93">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln94"> </a>
<a name="ln95">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln96">  {</a>
<a name="ln97">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln98">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln99">  }</a>
<a name="ln100">  sqlite3_finalize(stmt);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">/* enumerator of selected images */</a>
<a name="ln104">static void dt_control_image_enumerator_job_selected_init(dt_control_image_enumerator_t *t)</a>
<a name="ln105">{</a>
<a name="ln106">  g_list_free(t-&gt;index);</a>
<a name="ln107">  t-&gt;index = NULL;</a>
<a name="ln108"> </a>
<a name="ln109">  int imgid = dt_view_get_image_to_act_on();</a>
<a name="ln110"> </a>
<a name="ln111">  if(imgid &lt; 0) /* get sorted list of selected images */</a>
<a name="ln112">    t-&gt;index = dt_collection_get_selected(darktable.collection, -1);</a>
<a name="ln113">  else</a>
<a name="ln114">    /* Create a list with only one image */</a>
<a name="ln115">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">static int32_t _generic_dt_control_fileop_images_job_run(dt_job_t *job,</a>
<a name="ln119">                                                         int32_t (*fileop_callback)(const int32_t,</a>
<a name="ln120">                                                                                    const int32_t),</a>
<a name="ln121">                                                         const char *desc, const char *desc_pl)</a>
<a name="ln122">{</a>
<a name="ln123">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln124">  GList *t = params-&gt;index;</a>
<a name="ln125">  guint total = g_list_length(t);</a>
<a name="ln126">  char message[512] = { 0 };</a>
<a name="ln127">  double fraction = 0;</a>
<a name="ln128">  gchar *newdir = (gchar *)params-&gt;data;</a>
<a name="ln129"> </a>
<a name="ln130">  g_snprintf(message, sizeof(message), ngettext(desc, desc_pl, total), total);</a>
<a name="ln131">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln132"> </a>
<a name="ln133">  // create new film roll for the destination directory</a>
<a name="ln134">  dt_film_t new_film;</a>
<a name="ln135">  const int32_t film_id = dt_film_new(&amp;new_film, newdir);</a>
<a name="ln136">  g_free(newdir);</a>
<a name="ln137"> </a>
<a name="ln138">  if(film_id &lt;= 0)</a>
<a name="ln139">  {</a>
<a name="ln140">    dt_control_log(_(&quot;failed to create film roll for destination directory, aborting move..&quot;));</a>
<a name="ln141">    return -1;</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln145">  {</a>
<a name="ln146">    fileop_callback(GPOINTER_TO_INT(t-&gt;data), film_id);</a>
<a name="ln147">    t = g_list_delete_link(t, t);</a>
<a name="ln148">    fraction += 1.0 / total;</a>
<a name="ln149">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln150">  }</a>
<a name="ln151">  params-&gt;index = NULL;</a>
<a name="ln152"> </a>
<a name="ln153">  char collect[1024];</a>
<a name="ln154">  snprintf(collect, sizeof(collect), &quot;1:0:0:%s$&quot;, new_film.dirname);</a>
<a name="ln155">  dt_collection_deserialize(collect);</a>
<a name="ln156">  dt_film_remove_empty();</a>
<a name="ln157">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln158">  dt_control_queue_redraw_center();</a>
<a name="ln159">  return 0;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">static void *dt_control_image_enumerator_alloc()</a>
<a name="ln163">{</a>
<a name="ln164">  dt_control_image_enumerator_t *params = calloc(1, sizeof(dt_control_image_enumerator_t));</a>
<a name="ln165">  if(!params) return NULL;</a>
<a name="ln166"> </a>
<a name="ln167">  return params;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">static void dt_control_image_enumerator_cleanup(void *p)</a>
<a name="ln171">{</a>
<a name="ln172">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln173"> </a>
<a name="ln174">  g_list_free(params-&gt;index);</a>
<a name="ln175"> </a>
<a name="ln176">  free(params);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">typedef enum {PROGRESS_NONE, PROGRESS_SIMPLE, PROGRESS_CANCELLABLE} progress_type_t;</a>
<a name="ln180"> </a>
<a name="ln181">static dt_job_t *dt_control_generic_images_job_create(dt_job_execute_callback execute, const char *message,</a>
<a name="ln182">                                                      int flag, gpointer data, progress_type_t progress_type)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_job_t *job = dt_control_job_create(execute, &quot;%s&quot;, message);</a>
<a name="ln185">  if(!job) return NULL;</a>
<a name="ln186">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln187">  if(!params)</a>
<a name="ln188">  {</a>
<a name="ln189">    dt_control_job_dispose(job);</a>
<a name="ln190">    return NULL;</a>
<a name="ln191">  }</a>
<a name="ln192">  if(progress_type != PROGRESS_NONE)</a>
<a name="ln193">    dt_control_job_add_progress(job, _(message), progress_type == PROGRESS_CANCELLABLE);</a>
<a name="ln194">  dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln195">  dt_control_job_set_params(job, params, dt_control_image_enumerator_cleanup);</a>
<a name="ln196"> </a>
<a name="ln197">  params-&gt;flag = flag;</a>
<a name="ln198">  params-&gt;data = data;</a>
<a name="ln199">  return job;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static int32_t dt_control_write_sidecar_files_job_run(dt_job_t *job)</a>
<a name="ln203">{</a>
<a name="ln204">  int imgid = -1;</a>
<a name="ln205">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln206">  GList *t = params-&gt;index;</a>
<a name="ln207">  sqlite3_stmt *stmt;</a>
<a name="ln208">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln209">                              &quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE id = ?1&quot;, -1,</a>
<a name="ln210">                              &amp;stmt, NULL);</a>
<a name="ln211">  while(t)</a>
<a name="ln212">  {</a>
<a name="ln213">    gboolean from_cache = FALSE;</a>
<a name="ln214">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln215">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln216">    char dtfilename[PATH_MAX] = { 0 };</a>
<a name="ln217">    dt_image_full_path(img-&gt;id, dtfilename, sizeof(dtfilename), &amp;from_cache);</a>
<a name="ln218">    dt_image_path_append_version(img-&gt;id, dtfilename, sizeof(dtfilename));</a>
<a name="ln219">    g_strlcat(dtfilename, &quot;.xmp&quot;, sizeof(dtfilename));</a>
<a name="ln220">    if(!dt_exif_xmp_write(imgid, dtfilename))</a>
<a name="ln221">    {</a>
<a name="ln222">      // put the timestamp into db. this can't be done in exif.cc since that code gets called</a>
<a name="ln223">      // for the copy exporter, too</a>
<a name="ln224">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln225">      sqlite3_step(stmt);</a>
<a name="ln226">      sqlite3_reset(stmt);</a>
<a name="ln227">      sqlite3_clear_bindings(stmt);</a>
<a name="ln228">    }</a>
<a name="ln229">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln230">    t = g_list_delete_link(t, t);</a>
<a name="ln231">  }</a>
<a name="ln232">  params-&gt;index = NULL;</a>
<a name="ln233">  sqlite3_finalize(stmt);</a>
<a name="ln234">  return 0;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">typedef struct dt_control_merge_hdr_t</a>
<a name="ln238">{</a>
<a name="ln239">  uint32_t first_imgid;</a>
<a name="ln240">  uint32_t first_filter;</a>
<a name="ln241">  uint8_t first_xtrans[6][6];</a>
<a name="ln242"> </a>
<a name="ln243">  float *pixels, *weight;</a>
<a name="ln244"> </a>
<a name="ln245">  int wd;</a>
<a name="ln246">  int ht;</a>
<a name="ln247">  dt_image_orientation_t orientation;</a>
<a name="ln248"> </a>
<a name="ln249">  float whitelevel;</a>
<a name="ln250">  float epsw;</a>
<a name="ln251"> </a>
<a name="ln252">  // 0 - ok; 1 - errors, abort</a>
<a name="ln253">  gboolean abort;</a>
<a name="ln254">} dt_control_merge_hdr_t;</a>
<a name="ln255"> </a>
<a name="ln256">typedef struct dt_control_merge_hdr_format_t</a>
<a name="ln257">{</a>
<a name="ln258">  dt_imageio_module_data_t parent;</a>
<a name="ln259">  dt_control_merge_hdr_t *d;</a>
<a name="ln260">} dt_control_merge_hdr_format_t;</a>
<a name="ln261"> </a>
<a name="ln262">static int dt_control_merge_hdr_bpp(dt_imageio_module_data_t *data)</a>
<a name="ln263">{</a>
<a name="ln264">  return 32;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">static int dt_control_merge_hdr_levels(dt_imageio_module_data_t *data)</a>
<a name="ln268">{</a>
<a name="ln269">  return IMAGEIO_RGB | IMAGEIO_FLOAT;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">static const char *dt_control_merge_hdr_mime(dt_imageio_module_data_t *data)</a>
<a name="ln273">{</a>
<a name="ln274">  return &quot;memory&quot;;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static float envelope(const float xx)</a>
<a name="ln278">{</a>
<a name="ln279">  const float x = CLAMPS(xx, 0.0f, 1.0f);</a>
<a name="ln280">  // const float alpha = 2.0f;</a>
<a name="ln281">  const float beta = 0.5f;</a>
<a name="ln282">  if(x &lt; beta)</a>
<a name="ln283">  {</a>
<a name="ln284">    // return 1.0f-fabsf(x/beta-1.0f)^2</a>
<a name="ln285">    const float tmp = fabsf(x / beta - 1.0f);</a>
<a name="ln286">    return 1.0f - tmp * tmp;</a>
<a name="ln287">  }</a>
<a name="ln288">  else</a>
<a name="ln289">  {</a>
<a name="ln290">    const float tmp1 = (1.0f - x) / (1.0f - beta);</a>
<a name="ln291">    const float tmp2 = tmp1 * tmp1;</a>
<a name="ln292">    const float tmp3 = tmp2 * tmp1;</a>
<a name="ln293">    return 3.0f * tmp2 - 2.0f * tmp3;</a>
<a name="ln294">  }</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">static int dt_control_merge_hdr_process(dt_imageio_module_data_t *datai, const char *filename,</a>
<a name="ln298">                                        const void *const ivoid,</a>
<a name="ln299">                                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln300">                                        void *exif, int exif_len, int imgid, int num, int total,</a>
<a name="ln301">                                        dt_dev_pixelpipe_t *pipe)</a>
<a name="ln302">{</a>
<a name="ln303">  dt_control_merge_hdr_format_t *data = (dt_control_merge_hdr_format_t *)datai;</a>
<a name="ln304">  dt_control_merge_hdr_t *d = data-&gt;d;</a>
<a name="ln305"> </a>
<a name="ln306">  // just take a copy. also do it after blocking read, so filters will make sense.</a>
<a name="ln307">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln308">  const dt_image_t image = *img;</a>
<a name="ln309">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln310"> </a>
<a name="ln311">  if(!d-&gt;pixels)</a>
<a name="ln312">  {</a>
<a name="ln313">    d-&gt;first_imgid = imgid;</a>
<a name="ln314">    d-&gt;first_filter = image.buf_dsc.filters;</a>
<a name="ln315">    // sensor layout is just passed on to be written to dng.</a>
<a name="ln316">    // we offset it to the crop of the image here, so we don't</a>
<a name="ln317">    // need to load in the FCxtrans dependency into the dng writer.</a>
<a name="ln318">    // for some stupid reason the dng needs this layout wrt cropped</a>
<a name="ln319">    // offsets, not globally.</a>
<a name="ln320">    dt_iop_roi_t roi = {0};</a>
<a name="ln321">    roi.x = image.crop_x;</a>
<a name="ln322">    roi.y = image.crop_y;</a>
<a name="ln323">    for(int j=0;j&lt;6;j++)</a>
<a name="ln324">      for(int i = 0; i &lt; 6; i++) d-&gt;first_xtrans[j][i] = FCxtrans(j, i, &amp;roi, image.buf_dsc.xtrans);</a>
<a name="ln325">    d-&gt;pixels = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln326">    d-&gt;weight = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln327">    d-&gt;wd = datai-&gt;width;</a>
<a name="ln328">    d-&gt;ht = datai-&gt;height;</a>
<a name="ln329">    d-&gt;orientation = image.orientation;</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  if(image.buf_dsc.filters == 0u || image.buf_dsc.channels != 1 || image.buf_dsc.datatype != TYPE_UINT16)</a>
<a name="ln333">  {</a>
<a name="ln334">    dt_control_log(_(&quot;exposure bracketing only works on raw images.&quot;));</a>
<a name="ln335">    d-&gt;abort = TRUE;</a>
<a name="ln336">    return 1;</a>
<a name="ln337">  }</a>
<a name="ln338">  else if(datai-&gt;width != d-&gt;wd || datai-&gt;height != d-&gt;ht || d-&gt;first_filter != image.buf_dsc.filters</a>
<a name="ln339">          || d-&gt;orientation != image.orientation)</a>
<a name="ln340">  {</a>
<a name="ln341">    dt_control_log(_(&quot;images have to be of same size and orientation!&quot;));</a>
<a name="ln342">    d-&gt;abort = TRUE;</a>
<a name="ln343">    return 1;</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  // if no valid exif data can be found, assume peleng fisheye at f/16, 8mm, with half of the light lost in</a>
<a name="ln347">  // the system =&gt; f/22</a>
<a name="ln348">  const float eap = image.exif_aperture &gt; 0.0f ? image.exif_aperture : 22.0f;</a>
<a name="ln349">  const float efl = image.exif_focal_length &gt; 0.0f ? image.exif_focal_length : 8.0f;</a>
<a name="ln350">  const float rad = .5f * efl / eap;</a>
<a name="ln351">  const float aperture = M_PI * rad * rad;</a>
<a name="ln352">  const float iso = image.exif_iso &gt; 0.0f ? image.exif_iso : 100.0f;</a>
<a name="ln353">  const float exp = image.exif_exposure &gt; 0.0f ? image.exif_exposure : 1.0f;</a>
<a name="ln354">  const float cal = 100.0f / (aperture * exp * iso);</a>
<a name="ln355">  // about proportional to how many photons we can expect from this shot:</a>
<a name="ln356">  const float photoncnt = 100.0f * aperture * exp / iso;</a>
<a name="ln357">  float saturation = 1.0f;</a>
<a name="ln358">  d-&gt;whitelevel = fmaxf(d-&gt;whitelevel, saturation * cal);</a>
<a name="ln359">#ifdef _OPENMP</a>
<a name="ln360">#pragma omp parallel for schedule(static) default(none) shared(d, saturation)</a>
<a name="ln361">#endif</a>
<a name="ln362">  for(int y = 0; y &lt; d-&gt;ht; y++)</a>
<a name="ln363">    for(int x = 0; x &lt; d-&gt;wd; x++)</a>
<a name="ln364">    {</a>
<a name="ln365">      // read unclamped raw value with subtracted black and rescaled to 1.0 saturation.</a>
<a name="ln366">      // this is the output of the rawprepare iop.</a>
<a name="ln367">      const float in = ((float *)ivoid)[x + d-&gt;wd * y];</a>
<a name="ln368">      // weights based on siggraph 12 poster</a>
<a name="ln369">      // zijian zhu, zhengguo li, susanto rahardja, pasi fraenti</a>
<a name="ln370">      // 2d denoising factor for high dynamic range imaging</a>
<a name="ln371">      float w = photoncnt;</a>
<a name="ln372"> </a>
<a name="ln373">      // need some safety margin due to upsampling and 16-bit quantization + dithering?</a>
<a name="ln374">      float offset = 3000.0f / (float)UINT16_MAX;</a>
<a name="ln375"> </a>
<a name="ln376">      // cannot do an envelope based on single pixel values here, need to get</a>
<a name="ln377">      // maximum value of all color channels. to find that, go through the</a>
<a name="ln378">      // pattern block (we conservatively do a 3x3 for bayer or xtrans):</a>
<a name="ln379">      int xx = x &amp; ~1, yy = y &amp; ~1;</a>
<a name="ln380">      float M = 0.0f, m = FLT_MAX;</a>
<a name="ln381">      if(xx &lt; d-&gt;wd - 2 &amp;&amp; yy &lt; d-&gt;ht - 2)</a>
<a name="ln382">      {</a>
<a name="ln383">        for(int i = 0; i &lt; 3; i++)</a>
<a name="ln384">          for(int j = 0; j &lt; 3; j++)</a>
<a name="ln385">          {</a>
<a name="ln386">            M = MAX(M, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln387">            m = MIN(m, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln388">          }</a>
<a name="ln389">        // move envelope a little to allow non-zero weight even for clipped regions.</a>
<a name="ln390">        // this is because even if the 2x2 block is clipped somewhere, the other channels</a>
<a name="ln391">        // might still prove useful. we'll check for individual channel saturation below.</a>
<a name="ln392">        w *= d-&gt;epsw + envelope((M + offset) / saturation);</a>
<a name="ln393">      }</a>
<a name="ln394"> </a>
<a name="ln395">      if(M + offset &gt;= saturation)</a>
<a name="ln396">      {</a>
<a name="ln397">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0f)</a>
<a name="ln398">        { // only consider saturated pixels in case we have nothing better:</a>
<a name="ln399">          if(d-&gt;weight[x + d-&gt;wd * y] == 0 || m &lt; -d-&gt;weight[x + d-&gt;wd * y])</a>
<a name="ln400">          {</a>
<a name="ln401">            if(m + offset &gt;= saturation)</a>
<a name="ln402">              d-&gt;pixels[x + d-&gt;wd * y] = 1.0f; // let's admit we were completely clipped, too</a>
<a name="ln403">            else</a>
<a name="ln404">              d-&gt;pixels[x + d-&gt;wd * y] = in * cal / d-&gt;whitelevel;</a>
<a name="ln405">            d-&gt;weight[x + d-&gt;wd * y]</a>
<a name="ln406">                = -m; // could use -cal here, but m is per pixel and safer for varying illumination conditions</a>
<a name="ln407">          }</a>
<a name="ln408">        }</a>
<a name="ln409">        // else silently ignore, others have filled in a better color here already</a>
<a name="ln410">      }</a>
<a name="ln411">      else</a>
<a name="ln412">      {</a>
<a name="ln413">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0)</a>
<a name="ln414">        { // cleanup potentially blown highlights from earlier images</a>
<a name="ln415">          d-&gt;pixels[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln416">          d-&gt;weight[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln417">        }</a>
<a name="ln418">        d-&gt;pixels[x + d-&gt;wd * y] += w * in * cal;</a>
<a name="ln419">        d-&gt;weight[x + d-&gt;wd * y] += w;</a>
<a name="ln420">      }</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">  return 0;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">static int32_t dt_control_merge_hdr_job_run(dt_job_t *job)</a>
<a name="ln427">{</a>
<a name="ln428">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln429">  GList *t = params-&gt;index;</a>
<a name="ln430">  const guint total = g_list_length(t);</a>
<a name="ln431">  char message[512] = { 0 };</a>
<a name="ln432">  double fraction = 0;</a>
<a name="ln433">  snprintf(message, sizeof(message), ngettext(&quot;merging %d image&quot;, &quot;merging %d images&quot;, total), total);</a>
<a name="ln434"> </a>
<a name="ln435">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln436"> </a>
<a name="ln437">  dt_control_merge_hdr_t d = (dt_control_merge_hdr_t){.epsw = 1e-8f, .abort = FALSE };</a>
<a name="ln438"> </a>
<a name="ln439">  dt_imageio_module_format_t buf = (dt_imageio_module_format_t){.mime = dt_control_merge_hdr_mime,</a>
<a name="ln440">                                                                .levels = dt_control_merge_hdr_levels,</a>
<a name="ln441">                                                                .bpp = dt_control_merge_hdr_bpp,</a>
<a name="ln442">                                                                .write_image = dt_control_merge_hdr_process };</a>
<a name="ln443"> </a>
<a name="ln444">  dt_control_merge_hdr_format_t dat = (dt_control_merge_hdr_format_t){.parent = { 0 }, .d = &amp;d };</a>
<a name="ln445"> </a>
<a name="ln446">  int num = 1;</a>
<a name="ln447">  while(t)</a>
<a name="ln448">  {</a>
<a name="ln449">    if(d.abort) goto end;</a>
<a name="ln450"> </a>
<a name="ln451">    const uint32_t imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln452"> </a>
<a name="ln453">    dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE, TRUE,</a>
<a name="ln454">                                 FALSE, &quot;pre:rawprepare&quot;, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln455">                                 num, total);</a>
<a name="ln456"> </a>
<a name="ln457">    t = g_list_delete_link(t, t);</a>
<a name="ln458"> </a>
<a name="ln459">    /* update the progress bar */</a>
<a name="ln460">    fraction += 1.0 / (total + 1);</a>
<a name="ln461">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln462">    num++;</a>
<a name="ln463">  }</a>
<a name="ln464">  params-&gt;index = NULL;</a>
<a name="ln465"> </a>
<a name="ln466">  if(d.abort) goto end;</a>
<a name="ln467"> </a>
<a name="ln468">// normalize by white level to make clipping at 1.0 work as expected</a>
<a name="ln469"> </a>
<a name="ln470">#ifdef _OPENMP</a>
<a name="ln471">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln472">#endif</a>
<a name="ln473">  for(size_t k = 0; k &lt; (size_t)d.wd * d.ht; k++)</a>
<a name="ln474">  {</a>
<a name="ln475">    if(d.weight[k] &gt; 0.0) d.pixels[k] = fmaxf(0.0f, d.pixels[k] / (d.whitelevel * d.weight[k]));</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">  // output hdr as digital negative with exif data.</a>
<a name="ln479">  uint8_t *exif = NULL;</a>
<a name="ln480">  char pathname[PATH_MAX] = { 0 };</a>
<a name="ln481">  gboolean from_cache = TRUE;</a>
<a name="ln482">  dt_image_full_path(d.first_imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln483"> </a>
<a name="ln484">  // last param is dng mode</a>
<a name="ln485">  const int exif_len = dt_exif_read_blob(&amp;exif, pathname, d.first_imgid, 0, d.wd, d.ht, 1);</a>
<a name="ln486">  char *c = pathname + strlen(pathname);</a>
<a name="ln487">  while(*c != '.' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln488">  g_strlcpy(c, &quot;-hdr.dng&quot;, sizeof(pathname) - (c - pathname));</a>
<a name="ln489">  dt_imageio_write_dng(pathname, d.pixels, d.wd, d.ht, exif, exif_len, d.first_filter, (const uint8_t (*)[6])d.first_xtrans, 1.0f);</a>
<a name="ln490">  free(exif);</a>
<a name="ln491"> </a>
<a name="ln492">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln493"> </a>
<a name="ln494">  while(*c != '/' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln495">  dt_control_log(_(&quot;wrote merged HDR `%s'&quot;), c + 1);</a>
<a name="ln496"> </a>
<a name="ln497">  // import new image</a>
<a name="ln498">  gchar *directory = g_path_get_dirname((const gchar *)pathname);</a>
<a name="ln499">  dt_film_t film;</a>
<a name="ln500">  const int filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln501">  dt_image_import(filmid, pathname, TRUE);</a>
<a name="ln502">  g_free(directory);</a>
<a name="ln503"> </a>
<a name="ln504">end:</a>
<a name="ln505">  free(d.pixels);</a>
<a name="ln506">  free(d.weight);</a>
<a name="ln507"> </a>
<a name="ln508">  dt_control_queue_redraw_center();</a>
<a name="ln509">  return 0;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">static int32_t dt_control_duplicate_images_job_run(dt_job_t *job)</a>
<a name="ln513">{</a>
<a name="ln514">  int imgid = -1;</a>
<a name="ln515">  int newimgid = -1;</a>
<a name="ln516">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln517">  GList *t = params-&gt;index;</a>
<a name="ln518">  guint total = g_list_length(t);</a>
<a name="ln519">  char message[512] = { 0 };</a>
<a name="ln520">  double fraction = 0;</a>
<a name="ln521">  snprintf(message, sizeof(message), ngettext(&quot;duplicating %d image&quot;, &quot;duplicating %d images&quot;, total), total);</a>
<a name="ln522">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln523">  while(t)</a>
<a name="ln524">  {</a>
<a name="ln525">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln526">    newimgid = dt_image_duplicate(imgid);</a>
<a name="ln527">    if(newimgid != -1) dt_history_copy_and_paste_on_image(imgid, newimgid, FALSE, NULL);</a>
<a name="ln528">    t = g_list_delete_link(t, t);</a>
<a name="ln529">    fraction = 1.0 / total;</a>
<a name="ln530">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln531">  }</a>
<a name="ln532">  params-&gt;index = NULL;</a>
<a name="ln533">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln534">  dt_control_queue_redraw_center();</a>
<a name="ln535">  return 0;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">static int32_t dt_control_flip_images_job_run(dt_job_t *job)</a>
<a name="ln539">{</a>
<a name="ln540">  int imgid = -1;</a>
<a name="ln541">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln542">  const int cw = params-&gt;flag;</a>
<a name="ln543">  GList *t = params-&gt;index;</a>
<a name="ln544">  guint total = g_list_length(t);</a>
<a name="ln545">  double fraction = 0;</a>
<a name="ln546">  char message[512] = { 0 };</a>
<a name="ln547">  snprintf(message, sizeof(message), ngettext(&quot;flipping %d image&quot;, &quot;flipping %d images&quot;, total), total);</a>
<a name="ln548">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln549">  while(t)</a>
<a name="ln550">  {</a>
<a name="ln551">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln552">    dt_image_flip(imgid, cw);</a>
<a name="ln553">    t = g_list_delete_link(t, t);</a>
<a name="ln554">    fraction = 1.0 / total;</a>
<a name="ln555">    dt_image_set_aspect_ratio(imgid);</a>
<a name="ln556">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln557">  }</a>
<a name="ln558">  params-&gt;index = NULL;</a>
<a name="ln559">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln560">  dt_control_queue_redraw_center();</a>
<a name="ln561">  return 0;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">static char *_get_image_list(GList *l)</a>
<a name="ln565">{</a>
<a name="ln566">  const guint size = g_list_length(l);</a>
<a name="ln567">  char num[8];</a>
<a name="ln568">  char *buffer = calloc(size, sizeof(num));</a>
<a name="ln569">  int imgid;</a>
<a name="ln570">  gboolean first = TRUE;</a>
<a name="ln571"> </a>
<a name="ln572">  buffer[0] = '\0';</a>
<a name="ln573"> </a>
<a name="ln574">  while(l)</a>
<a name="ln575">  {</a>
<a name="ln576">    imgid = GPOINTER_TO_INT(l-&gt;data);</a>
<a name="ln577">    snprintf(num, sizeof(num), &quot;%s%6d&quot;, first ? &quot;&quot; : &quot;,&quot;, imgid);</a>
<a name="ln578">    g_strlcat(buffer, num, size * sizeof(num));</a>
<a name="ln579">    l = g_list_next(l);</a>
<a name="ln580">    first = FALSE;</a>
<a name="ln581">  }</a>
<a name="ln582">  return buffer;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">static void _set_remove_flag(char *imgs)</a>
<a name="ln586">{</a>
<a name="ln587">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln588">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln589">                              &quot;UPDATE main.images SET flags = (flags|?1) WHERE id IN (?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln590">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_REMOVE);</a>
<a name="ln591">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln592">  sqlite3_step(stmt);</a>
<a name="ln593">  sqlite3_finalize(stmt);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static GList *_get_full_pathname(char *imgs)</a>
<a name="ln597">{</a>
<a name="ln598">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln599">  GList *list = NULL;</a>
<a name="ln600"> </a>
<a name="ln601">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM &quot;</a>
<a name="ln602">                                                             &quot;main.images i, main.film_rolls f &quot;</a>
<a name="ln603">                                                             &quot;ON i.film_id = f.id WHERE i.id IN (?1)&quot;,</a>
<a name="ln604">                              -1, &amp;stmt, NULL);</a>
<a name="ln605">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, imgs, -1, SQLITE_STATIC);</a>
<a name="ln606">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln607">  {</a>
<a name="ln608">    list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(stmt, 0)));</a>
<a name="ln609">  }</a>
<a name="ln610">  sqlite3_finalize(stmt);</a>
<a name="ln611">  return list;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">static int32_t dt_control_remove_images_job_run(dt_job_t *job)</a>
<a name="ln615">{</a>
<a name="ln616">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln617">  GList *t = params-&gt;index;</a>
<a name="ln618">  char *imgs = _get_image_list(t);</a>
<a name="ln619">  guint total = g_list_length(t);</a>
<a name="ln620">  char message[512] = { 0 };</a>
<a name="ln621">  double fraction = 0;</a>
<a name="ln622">  snprintf(message, sizeof(message), ngettext(&quot;removing %d image&quot;, &quot;removing %d images&quot;, total), total);</a>
<a name="ln623">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln624">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln625"> </a>
<a name="ln626">  // check that we can safely remove the image</a>
<a name="ln627">  gboolean remove_ok = TRUE;</a>
<a name="ln628">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln629">                              &quot;SELECT id FROM main.images WHERE id IN (?2) AND flags&amp;?1=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln630">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln631">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln632"> </a>
<a name="ln633">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln634">  {</a>
<a name="ln635">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln636">    if(!dt_image_safe_remove(imgid))</a>
<a name="ln637">    {</a>
<a name="ln638">      remove_ok = FALSE;</a>
<a name="ln639">      break;</a>
<a name="ln640">    }</a>
<a name="ln641">  }</a>
<a name="ln642">  sqlite3_finalize(stmt);</a>
<a name="ln643"> </a>
<a name="ln644">  if(!remove_ok)</a>
<a name="ln645">  {</a>
<a name="ln646">    dt_control_log(_(&quot;cannot remove local copy when the original file is not accessible.&quot;));</a>
<a name="ln647">    free(imgs);</a>
<a name="ln648">    return 0;</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  // update remove status</a>
<a name="ln652">  _set_remove_flag(imgs);</a>
<a name="ln653"> </a>
<a name="ln654">  dt_collection_update(darktable.collection);</a>
<a name="ln655"> </a>
<a name="ln656">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln657">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln658"> </a>
<a name="ln659">  free(imgs);</a>
<a name="ln660"> </a>
<a name="ln661">  while(t)</a>
<a name="ln662">  {</a>
<a name="ln663">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln664">    dt_image_remove(imgid);</a>
<a name="ln665">    t = g_list_delete_link(t, t);</a>
<a name="ln666">    fraction = 1.0 / total;</a>
<a name="ln667">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln668">  }</a>
<a name="ln669">  params-&gt;index = NULL;</a>
<a name="ln670"> </a>
<a name="ln671">  char *imgname;</a>
<a name="ln672">  while(list)</a>
<a name="ln673">  {</a>
<a name="ln674">    imgname = (char *)list-&gt;data;</a>
<a name="ln675">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln676">    list = g_list_delete_link(list, list);</a>
<a name="ln677">  }</a>
<a name="ln678">  dt_film_remove_empty();</a>
<a name="ln679">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln680">  dt_control_queue_redraw_center();</a>
<a name="ln681">  return 0;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">typedef struct _dt_delete_modal_dialog_t</a>
<a name="ln685">{</a>
<a name="ln686">  int send_to_trash;</a>
<a name="ln687">  const char *filename;</a>
<a name="ln688">  const char *error_message;</a>
<a name="ln689"> </a>
<a name="ln690">  gint dialog_result;</a>
<a name="ln691"> </a>
<a name="ln692">  dt_pthread_mutex_t mutex;</a>
<a name="ln693">  pthread_cond_t cond;</a>
<a name="ln694">} _dt_delete_modal_dialog_t;</a>
<a name="ln695"> </a>
<a name="ln696">enum _dt_delete_status</a>
<a name="ln697">{</a>
<a name="ln698">  _DT_DELETE_STATUS_UNKNOWN = 0,</a>
<a name="ln699">  _DT_DELETE_STATUS_OK_TO_REMOVE = 1,</a>
<a name="ln700">  _DT_DELETE_STATUS_SKIP_FILE = 2,</a>
<a name="ln701">  _DT_DELETE_STATUS_STOP_PROCESSING = 3</a>
<a name="ln702">};</a>
<a name="ln703"> </a>
<a name="ln704">enum _dt_delete_dialog_choice</a>
<a name="ln705">{</a>
<a name="ln706">  _DT_DELETE_DIALOG_CHOICE_DELETE = 1,</a>
<a name="ln707">  _DT_DELETE_DIALOG_CHOICE_REMOVE = 2,</a>
<a name="ln708">  _DT_DELETE_DIALOG_CHOICE_CONTINUE = 3,</a>
<a name="ln709">  _DT_DELETE_DIALOG_CHOICE_STOP = 4</a>
<a name="ln710">};</a>
<a name="ln711"> </a>
<a name="ln712">static gboolean _dt_delete_dialog_main_thread(gpointer user_data)</a>
<a name="ln713">{</a>
<a name="ln714">  _dt_delete_modal_dialog_t* modal_dialog = (_dt_delete_modal_dialog_t*)user_data;</a>
<a name="ln715">  dt_pthread_mutex_lock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln716"> </a>
<a name="ln717">  GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln718">      GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln719">      GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln720">      GTK_MESSAGE_QUESTION,</a>
<a name="ln721">      GTK_BUTTONS_NONE,</a>
<a name="ln722">      modal_dialog-&gt;send_to_trash</a>
<a name="ln723">        ? _(&quot;could not send %s to trash%s%s&quot;)</a>
<a name="ln724">        : _(&quot;could not physically delete %s%s%s&quot;),</a>
<a name="ln725">      modal_dialog-&gt;filename,</a>
<a name="ln726">      modal_dialog-&gt;error_message != NULL ? &quot;: &quot; : &quot;&quot;,</a>
<a name="ln727">      modal_dialog-&gt;error_message != NULL ? modal_dialog-&gt;error_message : &quot;&quot;);</a>
<a name="ln728">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln729">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln730">#endif</a>
<a name="ln731"> </a>
<a name="ln732">  if (modal_dialog-&gt;send_to_trash)</a>
<a name="ln733">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE);</a>
<a name="ln734">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;only remove from the collection&quot;), _DT_DELETE_DIALOG_CHOICE_REMOVE);</a>
<a name="ln735">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;skip to next file&quot;), _DT_DELETE_DIALOG_CHOICE_CONTINUE);</a>
<a name="ln736">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;stop process&quot;), _DT_DELETE_DIALOG_CHOICE_STOP);</a>
<a name="ln737"> </a>
<a name="ln738">  gtk_window_set_title(</a>
<a name="ln739">      GTK_WINDOW(dialog),</a>
<a name="ln740">      modal_dialog-&gt;send_to_trash</a>
<a name="ln741">        ? _(&quot;trashing error&quot;)</a>
<a name="ln742">        : _(&quot;deletion error&quot;));</a>
<a name="ln743">  modal_dialog-&gt;dialog_result = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln744">  gtk_widget_destroy(dialog);</a>
<a name="ln745"> </a>
<a name="ln746">  pthread_cond_signal(&amp;modal_dialog-&gt;cond);</a>
<a name="ln747"> </a>
<a name="ln748">  dt_pthread_mutex_unlock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln749"> </a>
<a name="ln750">  // Don't call again on next idle time</a>
<a name="ln751">  return FALSE;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">static gint _dt_delete_file_display_modal_dialog(int send_to_trash, const char *filename, const char *error_message)</a>
<a name="ln755">{</a>
<a name="ln756">  _dt_delete_modal_dialog_t modal_dialog;</a>
<a name="ln757">  modal_dialog.send_to_trash = send_to_trash;</a>
<a name="ln758">  modal_dialog.filename = filename;</a>
<a name="ln759">  modal_dialog.error_message = error_message;</a>
<a name="ln760"> </a>
<a name="ln761">  modal_dialog.dialog_result = GTK_RESPONSE_NONE;</a>
<a name="ln762"> </a>
<a name="ln763">  dt_pthread_mutex_init(&amp;modal_dialog.mutex, NULL);</a>
<a name="ln764">  pthread_cond_init(&amp;modal_dialog.cond, NULL);</a>
<a name="ln765"> </a>
<a name="ln766">  dt_pthread_mutex_lock(&amp;modal_dialog.mutex);</a>
<a name="ln767"> </a>
<a name="ln768">  gdk_threads_add_idle(_dt_delete_dialog_main_thread, &amp;modal_dialog);</a>
<a name="ln769">  while (modal_dialog.dialog_result == GTK_RESPONSE_NONE)</a>
<a name="ln770">    dt_pthread_cond_wait(&amp;modal_dialog.cond, &amp;modal_dialog.mutex);</a>
<a name="ln771"> </a>
<a name="ln772">  dt_pthread_mutex_unlock(&amp;modal_dialog.mutex);</a>
<a name="ln773">  dt_pthread_mutex_destroy(&amp;modal_dialog.mutex);</a>
<a name="ln774">  pthread_cond_destroy(&amp;modal_dialog.cond);</a>
<a name="ln775"> </a>
<a name="ln776">  return modal_dialog.dialog_result;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">static enum _dt_delete_status delete_file_from_disk(const char *filename)</a>
<a name="ln780">{</a>
<a name="ln781">  enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln782"> </a>
<a name="ln783">  GFile *gfile = g_file_new_for_path(filename);</a>
<a name="ln784">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln785"> </a>
<a name="ln786">  while (delete_status == _DT_DELETE_STATUS_UNKNOWN)</a>
<a name="ln787">  {</a>
<a name="ln788">    gboolean delete_success = FALSE;</a>
<a name="ln789">    GError *gerror = NULL;</a>
<a name="ln790">    if (send_to_trash)</a>
<a name="ln791">    {</a>
<a name="ln792">#ifdef __APPLE__</a>
<a name="ln793">      delete_success = dt_osx_file_trash(filename, &amp;gerror);</a>
<a name="ln794">#elif defined(_WIN32)</a>
<a name="ln795">      delete_success = dt_win_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln796">#else</a>
<a name="ln797">      delete_success = g_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln798">#endif</a>
<a name="ln799">    }</a>
<a name="ln800">    else</a>
<a name="ln801">    {</a>
<a name="ln802">      delete_success = g_file_delete(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln803">    }</a>
<a name="ln804"> </a>
<a name="ln805">    // Delete is a success or the file does not exists: OK to remove from collection</a>
<a name="ln806">    if (delete_success</a>
<a name="ln807">        || g_error_matches(gerror, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))</a>
<a name="ln808">    {</a>
<a name="ln809">      delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln810">    }</a>
<a name="ln811">    else</a>
<a name="ln812">    {</a>
<a name="ln813">      const char *filename_display = NULL;</a>
<a name="ln814">      GFileInfo *gfileinfo = g_file_query_info(</a>
<a name="ln815">          gfile,</a>
<a name="ln816">          G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,</a>
<a name="ln817">          G_FILE_QUERY_INFO_NONE,</a>
<a name="ln818">          NULL /*cancellable*/,</a>
<a name="ln819">          NULL /*error*/);</a>
<a name="ln820">      if (gfileinfo != NULL)</a>
<a name="ln821">        filename_display = g_file_info_get_attribute_string(</a>
<a name="ln822">            gfileinfo,</a>
<a name="ln823">            G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);</a>
<a name="ln824"> </a>
<a name="ln825">      gint res = _dt_delete_file_display_modal_dialog(</a>
<a name="ln826">          send_to_trash,</a>
<a name="ln827">          filename_display == NULL ? filename : filename_display,</a>
<a name="ln828">          gerror == NULL ? NULL : gerror-&gt;message);</a>
<a name="ln829"> </a>
<a name="ln830">      if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE)</a>
<a name="ln831">      {</a>
<a name="ln832">        // Loop again, this time delete instead of trashing</a>
<a name="ln833">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln834">        send_to_trash = FALSE;</a>
<a name="ln835">      }</a>
<a name="ln836">      else if (res == _DT_DELETE_DIALOG_CHOICE_REMOVE)</a>
<a name="ln837">      {</a>
<a name="ln838">        delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln839">      }</a>
<a name="ln840">      else if (res == _DT_DELETE_DIALOG_CHOICE_CONTINUE)</a>
<a name="ln841">      {</a>
<a name="ln842">        delete_status = _DT_DELETE_STATUS_SKIP_FILE;</a>
<a name="ln843">      }</a>
<a name="ln844">      else</a>
<a name="ln845">      {</a>
<a name="ln846">        delete_status = _DT_DELETE_STATUS_STOP_PROCESSING;</a>
<a name="ln847">      }</a>
<a name="ln848">    }</a>
<a name="ln849">    if (gerror != NULL)</a>
<a name="ln850">      g_error_free(gerror);</a>
<a name="ln851">  }</a>
<a name="ln852"> </a>
<a name="ln853">  if (gfile != NULL)</a>
<a name="ln854">    g_object_unref(gfile);</a>
<a name="ln855"> </a>
<a name="ln856">  return delete_status;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859"> </a>
<a name="ln860">static int32_t dt_control_delete_images_job_run(dt_job_t *job)</a>
<a name="ln861">{</a>
<a name="ln862">  int imgid = -1;</a>
<a name="ln863">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln864">  GList *t = params-&gt;index;</a>
<a name="ln865">  char *imgs = _get_image_list(t);</a>
<a name="ln866">  char imgidstr[25] = { 0 };</a>
<a name="ln867">  guint total = g_list_length(t);</a>
<a name="ln868">  char message[512] = { 0 };</a>
<a name="ln869">  double fraction = 0;</a>
<a name="ln870">  if (dt_conf_get_bool(&quot;send_to_trash&quot;))</a>
<a name="ln871">    snprintf(message, sizeof(message), ngettext(&quot;trashing %d image&quot;, &quot;trashing %d images&quot;, total), total);</a>
<a name="ln872">  else</a>
<a name="ln873">    snprintf(message, sizeof(message), ngettext(&quot;deleting %d image&quot;, &quot;deleting %d images&quot;, total), total);</a>
<a name="ln874">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln875"> </a>
<a name="ln876">  sqlite3_stmt *stmt;</a>
<a name="ln877"> </a>
<a name="ln878">  dt_collection_update(darktable.collection);</a>
<a name="ln879"> </a>
<a name="ln880">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln881">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln882"> </a>
<a name="ln883">  free(imgs);</a>
<a name="ln884"> </a>
<a name="ln885">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln886">                              &quot;SELECT COUNT(*) FROM main.images WHERE filename IN (SELECT filename FROM &quot;</a>
<a name="ln887">                              &quot;main.images WHERE id = ?1) AND film_id IN (SELECT film_id FROM main.images WHERE &quot;</a>
<a name="ln888">                              &quot;id = ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln889">  while(t)</a>
<a name="ln890">  {</a>
<a name="ln891">    enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln892">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln893">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln894">    gboolean from_cache = FALSE;</a>
<a name="ln895">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln896"> </a>
<a name="ln897">#ifdef _WIN32</a>
<a name="ln898">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln899">#endif</a>
<a name="ln900"> </a>
<a name="ln901">    int duplicates = 0;</a>
<a name="ln902">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln903">    if(sqlite3_step(stmt) == SQLITE_ROW) duplicates = sqlite3_column_int(stmt, 0);</a>
<a name="ln904">    sqlite3_reset(stmt);</a>
<a name="ln905">    sqlite3_clear_bindings(stmt);</a>
<a name="ln906"> </a>
<a name="ln907">    // remove from disk:</a>
<a name="ln908">    if(duplicates == 1)</a>
<a name="ln909">    {</a>
<a name="ln910">      // first check for local copies, never delete a file whose original file is not accessible</a>
<a name="ln911">      if (dt_image_local_copy_reset(imgid))</a>
<a name="ln912">        goto delete_next_file;</a>
<a name="ln913"> </a>
<a name="ln914">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln915">      _set_remove_flag(imgidstr);</a>
<a name="ln916">      dt_image_remove(imgid);</a>
<a name="ln917"> </a>
<a name="ln918">      // there are no further duplicates so we can remove the source data file</a>
<a name="ln919">      delete_status = delete_file_from_disk(filename);</a>
<a name="ln920">      if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln921">        goto delete_next_file;</a>
<a name="ln922"> </a>
<a name="ln923">      // all sidecar files - including left-overs - can be deleted;</a>
<a name="ln924">      // left-overs can result when previously duplicates have been REMOVED;</a>
<a name="ln925">      // no need to keep them as the source data file is gone.</a>
<a name="ln926">      gchar pattern[PATH_MAX] = { 0 };</a>
<a name="ln927"> </a>
<a name="ln928">      // NULL terminated list of glob patterns; should include &quot;&quot; and can be extended if needed</a>
<a name="ln929">      static const gchar *glob_patterns[]</a>
<a name="ln930">          = { &quot;&quot;, &quot;_[0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9][0-9]&quot;, NULL };</a>
<a name="ln931"> </a>
<a name="ln932">      const gchar **glob_pattern = glob_patterns;</a>
<a name="ln933">      GList *files = NULL;</a>
<a name="ln934">      while(*glob_pattern)</a>
<a name="ln935">      {</a>
<a name="ln936">        snprintf(pattern, sizeof(pattern), &quot;%s&quot;, filename);</a>
<a name="ln937">        gchar *c1 = pattern + strlen(pattern);</a>
<a name="ln938">        while(*c1 != '.' &amp;&amp; c1 &gt; pattern) c1--;</a>
<a name="ln939">        snprintf(c1, pattern + sizeof(pattern) - c1, &quot;%s&quot;, *glob_pattern);</a>
<a name="ln940">        const gchar *c2 = filename + strlen(filename);</a>
<a name="ln941">        while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln942">        snprintf(c1 + strlen(*glob_pattern), pattern + sizeof(pattern) - c1 - strlen(*glob_pattern), &quot;%s.xmp&quot;,</a>
<a name="ln943">                 c2);</a>
<a name="ln944"> </a>
<a name="ln945">#ifdef _WIN32</a>
<a name="ln946">        wchar_t *wpattern = g_utf8_to_utf16(pattern, -1, NULL, NULL, NULL);</a>
<a name="ln947">        WIN32_FIND_DATAW data;</a>
<a name="ln948">        HANDLE handle = FindFirstFileW(wpattern, &amp;data);</a>
<a name="ln949">        g_free(wpattern);</a>
<a name="ln950">        if(handle != INVALID_HANDLE_VALUE)</a>
<a name="ln951">        {</a>
<a name="ln952">          do</a>
<a name="ln953">          {</a>
<a name="ln954">            char *xmp_filename = g_utf16_to_utf8(data.cFileName, -1, NULL, NULL, NULL);</a>
<a name="ln955">            files = g_list_append(files, g_build_filename(dirname, xmp_filename, NULL));</a>
<a name="ln956">            g_free(xmp_filename);</a>
<a name="ln957">          }</a>
<a name="ln958">          while(FindNextFileW(handle, &amp;data));</a>
<a name="ln959">        }</a>
<a name="ln960">#else</a>
<a name="ln961">        glob_t globbuf;</a>
<a name="ln962">        if(!glob(pattern, 0, NULL, &amp;globbuf))</a>
<a name="ln963">        {</a>
<a name="ln964">          for(size_t i = 0; i &lt; globbuf.gl_pathc; i++)</a>
<a name="ln965">            files = g_list_append(files, g_strdup(globbuf.gl_pathv[i]));</a>
<a name="ln966">          globfree(&amp;globbuf);</a>
<a name="ln967">        }</a>
<a name="ln968">#endif</a>
<a name="ln969"> </a>
<a name="ln970">        glob_pattern++;</a>
<a name="ln971">      }</a>
<a name="ln972"> </a>
<a name="ln973">      GList *file_iter = g_list_first(files);</a>
<a name="ln974">      while(file_iter != NULL)</a>
<a name="ln975">      {</a>
<a name="ln976">        delete_status = delete_file_from_disk(file_iter-&gt;data);</a>
<a name="ln977">        if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln978">          break;</a>
<a name="ln979">        file_iter = g_list_next(file_iter);</a>
<a name="ln980">      }</a>
<a name="ln981"> </a>
<a name="ln982">      g_list_free_full(files, g_free);</a>
<a name="ln983">    }</a>
<a name="ln984">    else</a>
<a name="ln985">    {</a>
<a name="ln986">      // don't remove the actual source data if there are further duplicates using it;</a>
<a name="ln987">      // just delete the xmp file of the duplicate selected.</a>
<a name="ln988"> </a>
<a name="ln989">      dt_image_path_append_version(imgid, filename, sizeof(filename));</a>
<a name="ln990">      g_strlcat(filename, &quot;.xmp&quot;, sizeof(filename));</a>
<a name="ln991"> </a>
<a name="ln992">      // remove image from db first ...</a>
<a name="ln993">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln994">      _set_remove_flag(imgidstr);</a>
<a name="ln995">      dt_image_remove(imgid);</a>
<a name="ln996"> </a>
<a name="ln997">      // ... and delete afterwards because removing will re-write the XMP</a>
<a name="ln998">      delete_file_from_disk(filename);</a>
<a name="ln999">    }</a>
<a name="ln1000"> </a>
<a name="ln1001">delete_next_file:</a>
<a name="ln1002">#ifdef _WIN32</a>
<a name="ln1003">    g_free(dirname);</a>
<a name="ln1004">#endif</a>
<a name="ln1005">    t = g_list_delete_link(t, t);</a>
<a name="ln1006">    fraction = 1.0 / total;</a>
<a name="ln1007">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1008">    if (delete_status == _DT_DELETE_STATUS_STOP_PROCESSING)</a>
<a name="ln1009">      break;</a>
<a name="ln1010">  }</a>
<a name="ln1011">  while (t)</a>
<a name="ln1012">    t = g_list_delete_link(t, t);</a>
<a name="ln1013">  params-&gt;index = NULL;</a>
<a name="ln1014">  sqlite3_finalize(stmt);</a>
<a name="ln1015"> </a>
<a name="ln1016">  char *imgname;</a>
<a name="ln1017">  while(list)</a>
<a name="ln1018">  {</a>
<a name="ln1019">    imgname = (char *)list-&gt;data;</a>
<a name="ln1020">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln1021">    list = g_list_delete_link(list, list);</a>
<a name="ln1022">  }</a>
<a name="ln1023">  g_list_free(list);</a>
<a name="ln1024">  dt_film_remove_empty();</a>
<a name="ln1025">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1026">  dt_control_queue_redraw_center();</a>
<a name="ln1027">  return 0;</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">static int32_t dt_control_gpx_apply_job_run(dt_job_t *job)</a>
<a name="ln1031">{</a>
<a name="ln1032">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln1033">  GList *t = params-&gt;index;</a>
<a name="ln1034">  struct dt_gpx_t *gpx = NULL;</a>
<a name="ln1035">  uint32_t cntr = 0;</a>
<a name="ln1036">  const dt_control_gpx_apply_t *d = params-&gt;data;</a>
<a name="ln1037">  const gchar *filename = d-&gt;filename;</a>
<a name="ln1038">  const gchar *tz = d-&gt;tz;</a>
<a name="ln1039"> </a>
<a name="ln1040">  /* do we have any selected images */</a>
<a name="ln1041">  if(!t) goto bail_out;</a>
<a name="ln1042"> </a>
<a name="ln1043">  /* try parse the gpx data */</a>
<a name="ln1044">  gpx = dt_gpx_new(filename);</a>
<a name="ln1045">  if(!gpx)</a>
<a name="ln1046">  {</a>
<a name="ln1047">    dt_control_log(_(&quot;failed to parse GPX file&quot;));</a>
<a name="ln1048">    goto bail_out;</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  GTimeZone *tz_camera = (tz == NULL) ? g_time_zone_new_utc() : g_time_zone_new(tz);</a>
<a name="ln1052">  if(!tz_camera) goto bail_out;</a>
<a name="ln1053">  GTimeZone *tz_utc = g_time_zone_new_utc();</a>
<a name="ln1054"> </a>
<a name="ln1055">  /* go thru each selected image and lookup location in gpx */</a>
<a name="ln1056">  do</a>
<a name="ln1057">  {</a>
<a name="ln1058">    GTimeVal timestamp;</a>
<a name="ln1059">    GDateTime *exif_time, *utc_time;</a>
<a name="ln1060">    gdouble lon, lat, ele;</a>
<a name="ln1061">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1062"> </a>
<a name="ln1063">    /* get image */</a>
<a name="ln1064">    const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1065">    if(!cimg) continue;</a>
<a name="ln1066"> </a>
<a name="ln1067">    /* convert exif datetime</a>
<a name="ln1068">       TODO: exiv2 dates should be iso8601 and we are probably doing some ugly</a>
<a name="ln1069">       conversion before inserting into database.</a>
<a name="ln1070">     */</a>
<a name="ln1071">    gint year;</a>
<a name="ln1072">    gint month;</a>
<a name="ln1073">    gint day;</a>
<a name="ln1074">    gint hour;</a>
<a name="ln1075">    gint minute;</a>
<a name="ln1076">    gint seconds;</a>
<a name="ln1077"> </a>
<a name="ln1078">    if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month, (int *)&amp;day,</a>
<a name="ln1079">              (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;seconds) != 6)</a>
<a name="ln1080">    {</a>
<a name="ln1081">      fprintf(stderr, &quot;broken exif time in db, '%s'\n&quot;, cimg-&gt;exif_datetime_taken);</a>
<a name="ln1082">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1083">      continue;</a>
<a name="ln1084">    }</a>
<a name="ln1085"> </a>
<a name="ln1086">    /* release the lock */</a>
<a name="ln1087">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1088"> </a>
<a name="ln1089">    exif_time = g_date_time_new(tz_camera, year, month, day, hour, minute, seconds);</a>
<a name="ln1090">    if(!exif_time) continue;</a>
<a name="ln1091">    utc_time = g_date_time_to_timezone(exif_time, tz_utc);</a>
<a name="ln1092">    g_date_time_unref(exif_time);</a>
<a name="ln1093">    if(!utc_time) continue;</a>
<a name="ln1094">    gboolean res = g_date_time_to_timeval(utc_time, &amp;timestamp);</a>
<a name="ln1095">    g_date_time_unref(utc_time);</a>
<a name="ln1096">    if(!res) continue;</a>
<a name="ln1097"> </a>
<a name="ln1098">    /* only update image location if time is within gpx tack range */</a>
<a name="ln1099">    if(dt_gpx_get_location(gpx, &amp;timestamp, &amp;lon, &amp;lat, &amp;ele))</a>
<a name="ln1100">    {</a>
<a name="ln1101">      dt_image_set_location_and_elevation(imgid, lon, lat, ele);</a>
<a name="ln1102">      cntr++;</a>
<a name="ln1103">    }</a>
<a name="ln1104"> </a>
<a name="ln1105">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1106"> </a>
<a name="ln1107">  dt_control_log(ngettext(&quot;applied matched GPX location onto %d image&quot;, &quot;applied matched GPX location onto %d images&quot;, cntr), cntr);</a>
<a name="ln1108"> </a>
<a name="ln1109">  g_time_zone_unref(tz_camera);</a>
<a name="ln1110">  g_time_zone_unref(tz_utc);</a>
<a name="ln1111">  dt_gpx_destroy(gpx);</a>
<a name="ln1112">  return 0;</a>
<a name="ln1113"> </a>
<a name="ln1114">bail_out:</a>
<a name="ln1115">  if(gpx) dt_gpx_destroy(gpx);</a>
<a name="ln1116"> </a>
<a name="ln1117">  return 1;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">static int32_t dt_control_move_images_job_run(dt_job_t *job)</a>
<a name="ln1121">{</a>
<a name="ln1122">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_move, _(&quot;moving %d image&quot;),</a>
<a name="ln1123">                                                   _(&quot;moving %d images&quot;));</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static int32_t dt_control_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1127">{</a>
<a name="ln1128">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_copy, _(&quot;copying %d image&quot;),</a>
<a name="ln1129">                                                   _(&quot;copying %d images&quot;));</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">static int32_t dt_control_local_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1133">{</a>
<a name="ln1134">  int imgid = -1;</a>
<a name="ln1135">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1136">  GList *t = params-&gt;index;</a>
<a name="ln1137">  guint tagid = 0;</a>
<a name="ln1138">  const guint total = g_list_length(t);</a>
<a name="ln1139">  double fraction = 0;</a>
<a name="ln1140">  gboolean is_copy = params-&gt;flag == 1;</a>
<a name="ln1141">  char message[512] = { 0 };</a>
<a name="ln1142"> </a>
<a name="ln1143">  if(is_copy)</a>
<a name="ln1144">    snprintf(message, sizeof(message),</a>
<a name="ln1145">             ngettext(&quot;creating local copy of %d image&quot;, &quot;creating local copies of %d images&quot;, total), total);</a>
<a name="ln1146">  else</a>
<a name="ln1147">    snprintf(message, sizeof(message),</a>
<a name="ln1148">             ngettext(&quot;removing local copy of %d image&quot;, &quot;removing local copies of %d images&quot;, total), total);</a>
<a name="ln1149"> </a>
<a name="ln1150">  dt_control_log(&quot;%s&quot;, message);</a>
<a name="ln1151">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1152"> </a>
<a name="ln1153">  dt_tag_new(&quot;darktable|local-copy&quot;, &amp;tagid);</a>
<a name="ln1154"> </a>
<a name="ln1155">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1156">  {</a>
<a name="ln1157">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1158">    if(is_copy)</a>
<a name="ln1159">    {</a>
<a name="ln1160">      if (dt_image_local_copy_set(imgid) == 0)</a>
<a name="ln1161">        dt_tag_attach(tagid, imgid);</a>
<a name="ln1162">    }</a>
<a name="ln1163">    else</a>
<a name="ln1164">    {</a>
<a name="ln1165">      if (dt_image_local_copy_reset(imgid) == 0)</a>
<a name="ln1166">        dt_tag_detach(tagid, imgid);</a>
<a name="ln1167">    }</a>
<a name="ln1168">    t = g_list_delete_link(t, t);</a>
<a name="ln1169"> </a>
<a name="ln1170">    fraction += 1.0 / total;</a>
<a name="ln1171">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1172">  }</a>
<a name="ln1173">  params-&gt;index = NULL;</a>
<a name="ln1174"> </a>
<a name="ln1175">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1176">  return 0;</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">static int32_t dt_control_export_job_run(dt_job_t *job)</a>
<a name="ln1180">{</a>
<a name="ln1181">  int imgid = -1;</a>
<a name="ln1182">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1183">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1184">  GList *t = params-&gt;index;</a>
<a name="ln1185">  dt_imageio_module_format_t *mformat = dt_imageio_get_format_by_index(settings-&gt;format_index);</a>
<a name="ln1186">  g_assert(mformat);</a>
<a name="ln1187">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1188">  g_assert(mstorage);</a>
<a name="ln1189">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1190"> </a>
<a name="ln1191">  // get a thread-safe fdata struct (one jpeg struct per thread etc):</a>
<a name="ln1192">  dt_imageio_module_data_t *fdata = mformat-&gt;get_params(mformat);</a>
<a name="ln1193"> </a>
<a name="ln1194">  if(mstorage-&gt;initialize_store)</a>
<a name="ln1195">  {</a>
<a name="ln1196">    if(mstorage-&gt;initialize_store(mstorage, sdata, &amp;mformat, &amp;fdata, &amp;t, settings-&gt;high_quality, settings-&gt;upscale))</a>
<a name="ln1197">    {</a>
<a name="ln1198">      // bail out, something went wrong</a>
<a name="ln1199">      goto end;</a>
<a name="ln1200">    }</a>
<a name="ln1201">    mformat-&gt;set_params(mformat, fdata, mformat-&gt;params_size(mformat));</a>
<a name="ln1202">    mstorage-&gt;set_params(mstorage, sdata, mstorage-&gt;params_size(mstorage));</a>
<a name="ln1203">  }</a>
<a name="ln1204"> </a>
<a name="ln1205">  // Get max dimensions...</a>
<a name="ln1206">  uint32_t w, h, fw, fh, sw, sh;</a>
<a name="ln1207">  fw = fh = sw = sh = 0;</a>
<a name="ln1208">  mstorage-&gt;dimension(mstorage, sdata, &amp;sw, &amp;sh);</a>
<a name="ln1209">  mformat-&gt;dimension(mformat, fdata, &amp;fw, &amp;fh);</a>
<a name="ln1210"> </a>
<a name="ln1211">  if(sw == 0 || fw == 0)</a>
<a name="ln1212">    w = sw &gt; fw ? sw : fw;</a>
<a name="ln1213">  else</a>
<a name="ln1214">    w = sw &lt; fw ? sw : fw;</a>
<a name="ln1215"> </a>
<a name="ln1216">  if(sh == 0 || fh == 0)</a>
<a name="ln1217">    h = sh &gt; fh ? sh : fh;</a>
<a name="ln1218">  else</a>
<a name="ln1219">    h = sh &lt; fh ? sh : fh;</a>
<a name="ln1220"> </a>
<a name="ln1221">  const guint total = g_list_length(t);</a>
<a name="ln1222">  dt_control_log(ngettext(&quot;exporting %d image..&quot;, &quot;exporting %d images..&quot;, total), total);</a>
<a name="ln1223">  char message[512] = { 0 };</a>
<a name="ln1224">  snprintf(message, sizeof(message), ngettext(&quot;exporting %d image to %s&quot;, &quot;exporting %d images to %s&quot;, total),</a>
<a name="ln1225">           total, mstorage-&gt;name(mstorage));</a>
<a name="ln1226">  // update the message. initialize_store() might have changed the number of images</a>
<a name="ln1227">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1228"> </a>
<a name="ln1229">  double fraction = 0;</a>
<a name="ln1230"> </a>
<a name="ln1231">  // set up the fdata struct</a>
<a name="ln1232">  fdata-&gt;max_width = (settings-&gt;max_width != 0 &amp;&amp; w != 0) ? MIN(w, settings-&gt;max_width) : MAX(w, settings-&gt;max_width);</a>
<a name="ln1233">  fdata-&gt;max_height = (settings-&gt;max_height != 0 &amp;&amp; h != 0) ? MIN(h, settings-&gt;max_height) : MAX(h, settings-&gt;max_height);</a>
<a name="ln1234">  g_strlcpy(fdata-&gt;style, settings-&gt;style, sizeof(fdata-&gt;style));</a>
<a name="ln1235">  fdata-&gt;style_append = settings-&gt;style_append;</a>
<a name="ln1236">  guint num = 0;</a>
<a name="ln1237">  // Invariant: the tagid for 'darktable|changed' will not change while this function runs. Is this a</a>
<a name="ln1238">  // sensible assumption?</a>
<a name="ln1239">  guint tagid = 0, etagid = 0;</a>
<a name="ln1240">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln1241">  dt_tag_new(&quot;darktable|exported&quot;, &amp;etagid);</a>
<a name="ln1242"> </a>
<a name="ln1243">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1244">  {</a>
<a name="ln1245">    if(!t)</a>
<a name="ln1246">      imgid = 0;</a>
<a name="ln1247">    else</a>
<a name="ln1248">    {</a>
<a name="ln1249">      imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1250">      t = g_list_delete_link(t, t);</a>
<a name="ln1251">      num = total - g_list_length(t);</a>
<a name="ln1252">    }</a>
<a name="ln1253"> </a>
<a name="ln1254">    // remove 'changed' tag from image</a>
<a name="ln1255">    dt_tag_detach(tagid, imgid);</a>
<a name="ln1256">    // make sure the 'exported' tag is set on the image</a>
<a name="ln1257">    dt_tag_attach(etagid, imgid);</a>
<a name="ln1258">    // check if image still exists:</a>
<a name="ln1259">    char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln1260">    const dt_image_t *image = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln1261">    if(image)</a>
<a name="ln1262">    {</a>
<a name="ln1263">      gboolean from_cache = TRUE;</a>
<a name="ln1264">      dt_image_full_path(image-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln1265">      if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln1266">      {</a>
<a name="ln1267">        dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), image-&gt;filename);</a>
<a name="ln1268">        fprintf(stderr, &quot;image `%s' is currently unavailable\n&quot;, imgfilename);</a>
<a name="ln1269">        // dt_image_remove(imgid);</a>
<a name="ln1270">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1271">      }</a>
<a name="ln1272">      else</a>
<a name="ln1273">      {</a>
<a name="ln1274">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1275">        if(mstorage-&gt;store(mstorage, sdata, imgid, mformat, fdata, num, total, settings-&gt;high_quality,</a>
<a name="ln1276">                           settings-&gt;upscale, settings-&gt;icc_type, settings-&gt;icc_filename, settings-&gt;icc_intent) != 0)</a>
<a name="ln1277">          dt_control_job_cancel(job);</a>
<a name="ln1278">      }</a>
<a name="ln1279">    }</a>
<a name="ln1280"> </a>
<a name="ln1281">    fraction += 1.0 / total;</a>
<a name="ln1282">    if(fraction &gt; 1.0) fraction = 1.0;</a>
<a name="ln1283">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1284">  }</a>
<a name="ln1285">  params-&gt;index = NULL;</a>
<a name="ln1286"> </a>
<a name="ln1287">  if(mstorage-&gt;finalize_store) mstorage-&gt;finalize_store(mstorage, sdata);</a>
<a name="ln1288"> </a>
<a name="ln1289">end:</a>
<a name="ln1290">  // all threads free their fdata</a>
<a name="ln1291">  mformat-&gt;free_params(mformat, fdata);</a>
<a name="ln1292"> </a>
<a name="ln1293">  // notify the user via the window manager</a>
<a name="ln1294">  dt_ui_notify_user();</a>
<a name="ln1295"> </a>
<a name="ln1296">  return 0;</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">static dt_control_image_enumerator_t *dt_control_gpx_apply_alloc()</a>
<a name="ln1300">{</a>
<a name="ln1301">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1302">  if(!params) return NULL;</a>
<a name="ln1303"> </a>
<a name="ln1304">  params-&gt;data = calloc(1, sizeof(dt_control_gpx_apply_t));</a>
<a name="ln1305">  if(!params-&gt;data)</a>
<a name="ln1306">  {</a>
<a name="ln1307">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1308">    return NULL;</a>
<a name="ln1309">  }</a>
<a name="ln1310"> </a>
<a name="ln1311">  return params;</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314">static void dt_control_gpx_apply_job_cleanup(void *p)</a>
<a name="ln1315">{</a>
<a name="ln1316">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1317"> </a>
<a name="ln1318">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1319">  g_free(data-&gt;filename);</a>
<a name="ln1320">  g_free(data-&gt;tz);</a>
<a name="ln1321"> </a>
<a name="ln1322">  free(data);</a>
<a name="ln1323"> </a>
<a name="ln1324">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1325">}</a>
<a name="ln1326"> </a>
<a name="ln1327">static dt_job_t *dt_control_gpx_apply_job_create(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1328">{</a>
<a name="ln1329">  dt_job_t *job = dt_control_job_create(&amp;dt_control_gpx_apply_job_run, &quot;gpx apply&quot;);</a>
<a name="ln1330">  if(!job) return NULL;</a>
<a name="ln1331">  dt_control_image_enumerator_t *params = dt_control_gpx_apply_alloc();</a>
<a name="ln1332">  if(!params)</a>
<a name="ln1333">  {</a>
<a name="ln1334">    dt_control_job_dispose(job);</a>
<a name="ln1335">    return NULL;</a>
<a name="ln1336">  }</a>
<a name="ln1337">  dt_control_job_set_params(job, params, dt_control_gpx_apply_job_cleanup);</a>
<a name="ln1338"> </a>
<a name="ln1339">  if(filmid != -1)</a>
<a name="ln1340">    dt_control_image_enumerator_job_film_init(params, filmid);</a>
<a name="ln1341">  else</a>
<a name="ln1342">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1343"> </a>
<a name="ln1344">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1345">  data-&gt;filename = g_strdup(filename);</a>
<a name="ln1346">  data-&gt;tz = g_strdup(tz);</a>
<a name="ln1347"> </a>
<a name="ln1348">  return job;</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351">void dt_control_merge_hdr()</a>
<a name="ln1352">{</a>
<a name="ln1353">  dt_control_add_job(</a>
<a name="ln1354">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1355">      dt_control_generic_images_job_create(&amp;dt_control_merge_hdr_job_run, N_(&quot;merge hdr image&quot;), 0, NULL,</a>
<a name="ln1356">                                           PROGRESS_CANCELLABLE));</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">void dt_control_gpx_apply(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1360">{</a>
<a name="ln1361">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1362">                     dt_control_gpx_apply_job_create(filename, filmid, tz));</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365">void dt_control_duplicate_images()</a>
<a name="ln1366">{</a>
<a name="ln1367">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1368">                     dt_control_generic_images_job_create(&amp;dt_control_duplicate_images_job_run,</a>
<a name="ln1369">                                                          N_(&quot;duplicate images&quot;), 0, NULL, PROGRESS_SIMPLE));</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">void dt_control_flip_images(const int32_t cw)</a>
<a name="ln1373">{</a>
<a name="ln1374">  dt_control_add_job(</a>
<a name="ln1375">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1376">      dt_control_generic_images_job_create(&amp;dt_control_flip_images_job_run, N_(&quot;flip images&quot;), cw, NULL,</a>
<a name="ln1377">                                           PROGRESS_SIMPLE));</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">gboolean dt_control_remove_images()</a>
<a name="ln1381">{</a>
<a name="ln1382">  // get all selected images now, to avoid the set changing during ui interaction</a>
<a name="ln1383">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_remove_images_job_run, N_(&quot;remove images&quot;), 0, NULL,</a>
<a name="ln1384">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1385">  if(dt_conf_get_bool(&quot;ask_before_remove&quot;))</a>
<a name="ln1386">  {</a>
<a name="ln1387">    GtkWidget *dialog;</a>
<a name="ln1388">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1389"> </a>
<a name="ln1390">    int number;</a>
<a name="ln1391">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1392">      number = 1;</a>
<a name="ln1393">    else</a>
<a name="ln1394">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1395"> </a>
<a name="ln1396">    // Do not show the dialog if no image is selected:</a>
<a name="ln1397">    if(number == 0)</a>
<a name="ln1398">    {</a>
<a name="ln1399">      dt_control_job_dispose(job);</a>
<a name="ln1400">      return TRUE;</a>
<a name="ln1401">    }</a>
<a name="ln1402"> </a>
<a name="ln1403">    dialog = gtk_message_dialog_new(</a>
<a name="ln1404">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1405">        ngettext(&quot;do you really want to remove %d selected image from the collection?&quot;,</a>
<a name="ln1406">                 &quot;do you really want to remove %d selected images from the collection?&quot;, number),</a>
<a name="ln1407">        number);</a>
<a name="ln1408">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1409">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1410">#endif</a>
<a name="ln1411"> </a>
<a name="ln1412">    gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;remove images?&quot;));</a>
<a name="ln1413">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1414">    gtk_widget_destroy(dialog);</a>
<a name="ln1415">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1416">    {</a>
<a name="ln1417">      dt_control_job_dispose(job);</a>
<a name="ln1418">      return FALSE;</a>
<a name="ln1419">    }</a>
<a name="ln1420">  }</a>
<a name="ln1421">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1422">  return TRUE;</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">void dt_control_delete_images()</a>
<a name="ln1426">{</a>
<a name="ln1427">  // first get all selected images, to avoid the set changing during ui interaction</a>
<a name="ln1428">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_delete_images_job_run, N_(&quot;delete images&quot;), 0, NULL,</a>
<a name="ln1429">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1430">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln1431">  if(dt_conf_get_bool(&quot;ask_before_delete&quot;))</a>
<a name="ln1432">  {</a>
<a name="ln1433">    GtkWidget *dialog;</a>
<a name="ln1434">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1435"> </a>
<a name="ln1436">    int number;</a>
<a name="ln1437">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1438">      number = 1;</a>
<a name="ln1439">    else</a>
<a name="ln1440">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1441"> </a>
<a name="ln1442">    // Do not show the dialog if no image is selected:</a>
<a name="ln1443">    if(number == 0)</a>
<a name="ln1444">    {</a>
<a name="ln1445">      dt_control_job_dispose(job);</a>
<a name="ln1446">      return;</a>
<a name="ln1447">    }</a>
<a name="ln1448"> </a>
<a name="ln1449">    dialog = gtk_message_dialog_new(</a>
<a name="ln1450">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1451">        send_to_trash</a>
<a name="ln1452">        ? ngettext(&quot;do you really want to send %d selected image to trash?&quot;,</a>
<a name="ln1453">          &quot;do you really want to send %d selected images to trash?&quot;, number)</a>
<a name="ln1454">        : ngettext(&quot;do you really want to physically delete %d selected image from disk?&quot;,</a>
<a name="ln1455">          &quot;do you really want to physically delete %d selected images from disk?&quot;, number),</a>
<a name="ln1456">        number);</a>
<a name="ln1457">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1458">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1459">#endif</a>
<a name="ln1460"> </a>
<a name="ln1461">    gtk_window_set_title(GTK_WINDOW(dialog), send_to_trash ? _(&quot;trash images?&quot;) : _(&quot;delete images?&quot;));</a>
<a name="ln1462">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1463">    gtk_widget_destroy(dialog);</a>
<a name="ln1464">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1465">    {</a>
<a name="ln1466">      dt_control_job_dispose(job);</a>
<a name="ln1467">      return;</a>
<a name="ln1468">    }</a>
<a name="ln1469">  }</a>
<a name="ln1470">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473">void dt_control_move_images()</a>
<a name="ln1474">{</a>
<a name="ln1475">  // Open file chooser dialog</a>
<a name="ln1476">  gchar *dir = NULL;</a>
<a name="ln1477">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1478">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1479"> </a>
<a name="ln1480">  // Do not show the dialog if no image is selected:</a>
<a name="ln1481">  if(number == 0) return;</a>
<a name="ln1482">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_move_images_job_run, N_(&quot;move images&quot;), 0, dir,</a>
<a name="ln1483">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1484"> </a>
<a name="ln1485">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1486">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1487">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1488">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1489">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1490">#endif</a>
<a name="ln1491"> </a>
<a name="ln1492">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1493">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1494">  {</a>
<a name="ln1495">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1496">  }</a>
<a name="ln1497">  gtk_widget_destroy(filechooser);</a>
<a name="ln1498"> </a>
<a name="ln1499">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1500"> </a>
<a name="ln1501">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1502">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1503"> </a>
<a name="ln1504">  if(dt_conf_get_bool(&quot;ask_before_move&quot;))</a>
<a name="ln1505">  {</a>
<a name="ln1506">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1507">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1508">        ngettext(&quot;do you really want to physically move the %d selected image to %s?\n&quot;</a>
<a name="ln1509">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1510">                 &quot;do you really want to physically move %d selected images to %s?\n&quot;</a>
<a name="ln1511">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1512">                 number),</a>
<a name="ln1513">        number, dir);</a>
<a name="ln1514">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1515">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1516">#endif</a>
<a name="ln1517">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;move image?&quot;, &quot;move images?&quot;, number));</a>
<a name="ln1518"> </a>
<a name="ln1519">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1520">    gtk_widget_destroy(dialog);</a>
<a name="ln1521"> </a>
<a name="ln1522">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1523">  }</a>
<a name="ln1524"> </a>
<a name="ln1525">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1526">  return;</a>
<a name="ln1527"> </a>
<a name="ln1528">abort:</a>
<a name="ln1529">  g_free(dir);</a>
<a name="ln1530">  dt_control_job_dispose(job);</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">void dt_control_copy_images()</a>
<a name="ln1534">{</a>
<a name="ln1535">  // Open file chooser dialog</a>
<a name="ln1536">  gchar *dir = NULL;</a>
<a name="ln1537">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1538">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1539"> </a>
<a name="ln1540">  // Do not show the dialog if no image is selected:</a>
<a name="ln1541">  if(number == 0) return;</a>
<a name="ln1542">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_copy_images_job_run, N_(&quot;copy images&quot;), 0, dir,</a>
<a name="ln1543">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1544"> </a>
<a name="ln1545">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1546">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1547">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1548">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1549">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1550">#endif</a>
<a name="ln1551"> </a>
<a name="ln1552">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1553">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1554">  {</a>
<a name="ln1555">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1556">  }</a>
<a name="ln1557">  gtk_widget_destroy(filechooser);</a>
<a name="ln1558"> </a>
<a name="ln1559">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1560"> </a>
<a name="ln1561">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1562">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1563"> </a>
<a name="ln1564">  if(dt_conf_get_bool(&quot;ask_before_copy&quot;))</a>
<a name="ln1565">  {</a>
<a name="ln1566">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1567">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1568">        ngettext(&quot;do you really want to physically copy the %d selected image to %s?&quot;,</a>
<a name="ln1569">                 &quot;do you really want to physically copy %d selected images to %s?&quot;, number),</a>
<a name="ln1570">        number, dir);</a>
<a name="ln1571">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1572">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1573">#endif</a>
<a name="ln1574">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;copy image?&quot;, &quot;copy images?&quot;, number));</a>
<a name="ln1575"> </a>
<a name="ln1576">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1577">    gtk_widget_destroy(dialog);</a>
<a name="ln1578"> </a>
<a name="ln1579">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1580">  }</a>
<a name="ln1581"> </a>
<a name="ln1582">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1583">  return;</a>
<a name="ln1584"> </a>
<a name="ln1585">abort:</a>
<a name="ln1586">  g_free(dir);</a>
<a name="ln1587">  dt_control_job_dispose(job);</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">void dt_control_set_local_copy_images()</a>
<a name="ln1591">{</a>
<a name="ln1592">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1593">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1594">                                                          N_(&quot;local copy images&quot;), 1, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1595">}</a>
<a name="ln1596"> </a>
<a name="ln1597">void dt_control_reset_local_copy_images()</a>
<a name="ln1598">{</a>
<a name="ln1599">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1600">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1601">                                                          N_(&quot;local copy images&quot;), 0, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1602">}</a>
<a name="ln1603"> </a>
<a name="ln1604">static dt_control_image_enumerator_t *dt_control_export_alloc()</a>
<a name="ln1605">{</a>
<a name="ln1606">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1607">  if(!params) return NULL;</a>
<a name="ln1608"> </a>
<a name="ln1609">  params-&gt;data = calloc(1, sizeof(dt_control_export_t));</a>
<a name="ln1610">  if(!params-&gt;data)</a>
<a name="ln1611">  {</a>
<a name="ln1612">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1613">    return NULL;</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  return params;</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">static void dt_control_export_cleanup(void *p)</a>
<a name="ln1620">{</a>
<a name="ln1621">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1622"> </a>
<a name="ln1623">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1624">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1625">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1626"> </a>
<a name="ln1627">  mstorage-&gt;free_params(mstorage, sdata);</a>
<a name="ln1628"> </a>
<a name="ln1629">  g_free(settings-&gt;icc_filename);</a>
<a name="ln1630">  free(params-&gt;data);</a>
<a name="ln1631"> </a>
<a name="ln1632">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">void dt_control_export(GList *imgid_list, int max_width, int max_height, int format_index, int storage_index,</a>
<a name="ln1636">                       gboolean high_quality, gboolean upscale, char *style, gboolean style_append,</a>
<a name="ln1637">                       dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln1638">                       dt_iop_color_intent_t icc_intent)</a>
<a name="ln1639">{</a>
<a name="ln1640">  dt_job_t *job = dt_control_job_create(&amp;dt_control_export_job_run, &quot;export&quot;);</a>
<a name="ln1641">  if(!job) return;</a>
<a name="ln1642">  dt_control_image_enumerator_t *params = dt_control_export_alloc();</a>
<a name="ln1643">  if(!params)</a>
<a name="ln1644">  {</a>
<a name="ln1645">    dt_control_job_dispose(job);</a>
<a name="ln1646">    return;</a>
<a name="ln1647">  }</a>
<a name="ln1648">  dt_control_job_set_params(job, params, dt_control_export_cleanup);</a>
<a name="ln1649"> </a>
<a name="ln1650">  params-&gt;index = imgid_list;</a>
<a name="ln1651"> </a>
<a name="ln1652">  dt_control_export_t *data = params-&gt;data;</a>
<a name="ln1653">  data-&gt;max_width = max_width;</a>
<a name="ln1654">  data-&gt;max_height = max_height;</a>
<a name="ln1655">  data-&gt;format_index = format_index;</a>
<a name="ln1656">  data-&gt;storage_index = storage_index;</a>
<a name="ln1657">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(storage_index);</a>
<a name="ln1658">  g_assert(mstorage);</a>
<a name="ln1659">  // get shared storage param struct (global sequence counter, one picasa connection etc)</a>
<a name="ln1660">  dt_imageio_module_data_t *sdata = mstorage-&gt;get_params(mstorage);</a>
<a name="ln1661">  if(sdata == NULL)</a>
<a name="ln1662">  {</a>
<a name="ln1663">    dt_control_log(_(&quot;failed to get parameters from storage module `%s', aborting export..&quot;),</a>
<a name="ln1664">                   mstorage-&gt;name(mstorage));</a>
<a name="ln1665">    dt_control_job_dispose(job);</a>
<a name="ln1666">    return;</a>
<a name="ln1667">  }</a>
<a name="ln1668">  data-&gt;sdata = sdata;</a>
<a name="ln1669">  data-&gt;high_quality = high_quality;</a>
<a name="ln1670">  data-&gt;upscale = upscale;</a>
<a name="ln1671">  g_strlcpy(data-&gt;style, style, sizeof(data-&gt;style));</a>
<a name="ln1672">  data-&gt;style_append = style_append;</a>
<a name="ln1673">  data-&gt;icc_type = icc_type;</a>
<a name="ln1674">  data-&gt;icc_filename = g_strdup(icc_filename);</a>
<a name="ln1675">  data-&gt;icc_intent = icc_intent;</a>
<a name="ln1676"> </a>
<a name="ln1677">  dt_control_job_add_progress(job, _(&quot;export images&quot;), TRUE);</a>
<a name="ln1678">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln1679"> </a>
<a name="ln1680">  // tell the storage that we got its params for an export so it can reset itself to a safe state</a>
<a name="ln1681">  mstorage-&gt;export_dispatched(mstorage);</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">static int32_t dt_control_time_offset_job_run(dt_job_t *job)</a>
<a name="ln1685">{</a>
<a name="ln1686">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1687">  uint32_t cntr = 0;</a>
<a name="ln1688">  double fraction = 0.0;</a>
<a name="ln1689">  GList *t = params-&gt;index;</a>
<a name="ln1690">  const long int offset = ((dt_control_time_offset_t *)params-&gt;data)-&gt;offset;</a>
<a name="ln1691">  char message[512] = { 0 };</a>
<a name="ln1692"> </a>
<a name="ln1693">  /* do we have any selected images and is offset != 0 */</a>
<a name="ln1694">  if(!t || offset == 0)</a>
<a name="ln1695">  {</a>
<a name="ln1696">    return 1;</a>
<a name="ln1697">  }</a>
<a name="ln1698"> </a>
<a name="ln1699">  const guint total = g_list_length(t);</a>
<a name="ln1700"> </a>
<a name="ln1701">  snprintf(message, sizeof(message),</a>
<a name="ln1702">           ngettext(&quot;adding time offset to %d image&quot;, &quot;adding time offset to %d images&quot;, total), total);</a>
<a name="ln1703">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1704"> </a>
<a name="ln1705">  /* go thru each selected image and update datetime_taken */</a>
<a name="ln1706">  do</a>
<a name="ln1707">  {</a>
<a name="ln1708">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1709"> </a>
<a name="ln1710">    dt_image_add_time_offset(imgid, offset);</a>
<a name="ln1711">    cntr++;</a>
<a name="ln1712"> </a>
<a name="ln1713">    fraction = MAX(fraction, (1.0 * cntr) / total);</a>
<a name="ln1714">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1715">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1716"> </a>
<a name="ln1717">  dt_control_log(ngettext(&quot;added time offset to %d image&quot;, &quot;added time offset to %d images&quot;, cntr), cntr);</a>
<a name="ln1718"> </a>
<a name="ln1719">  return 0;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">static void *dt_control_time_offset_alloc()</a>
<a name="ln1723">{</a>
<a name="ln1724">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1725">  if(!params) return NULL;</a>
<a name="ln1726"> </a>
<a name="ln1727">  params-&gt;data = calloc(1, sizeof(dt_control_time_offset_t));</a>
<a name="ln1728">  if(!params-&gt;data)</a>
<a name="ln1729">  {</a>
<a name="ln1730">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1731">    return NULL;</a>
<a name="ln1732">  }</a>
<a name="ln1733"> </a>
<a name="ln1734">  return params;</a>
<a name="ln1735">}</a>
<a name="ln1736"> </a>
<a name="ln1737">static void dt_control_time_offset_job_cleanup(void *p)</a>
<a name="ln1738">{</a>
<a name="ln1739">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)p;</a>
<a name="ln1740"> </a>
<a name="ln1741">  free(params-&gt;data);</a>
<a name="ln1742"> </a>
<a name="ln1743">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1744">}</a>
<a name="ln1745"> </a>
<a name="ln1746">static dt_job_t *dt_control_time_offset_job_create(const long int offset, int imgid)</a>
<a name="ln1747">{</a>
<a name="ln1748">  dt_job_t *job = dt_control_job_create(&amp;dt_control_time_offset_job_run, &quot;time offset&quot;);</a>
<a name="ln1749">  if(!job) return NULL;</a>
<a name="ln1750">  dt_control_image_enumerator_t *params = dt_control_time_offset_alloc();</a>
<a name="ln1751">  if(!params)</a>
<a name="ln1752">  {</a>
<a name="ln1753">    dt_control_job_dispose(job);</a>
<a name="ln1754">    return NULL;</a>
<a name="ln1755">  }</a>
<a name="ln1756">  dt_control_job_add_progress(job, _(&quot;time offset&quot;), FALSE);</a>
<a name="ln1757">  dt_control_job_set_params(job, params, dt_control_time_offset_job_cleanup);</a>
<a name="ln1758"> </a>
<a name="ln1759">  if(imgid != -1)</a>
<a name="ln1760">    params-&gt;index = g_list_append(params-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln1761">  else</a>
<a name="ln1762">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1763"> </a>
<a name="ln1764">  dt_control_time_offset_t *data = params-&gt;data;</a>
<a name="ln1765">  data-&gt;offset = offset;</a>
<a name="ln1766">  params-&gt;data = data;</a>
<a name="ln1767">  return job;</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770">void dt_control_time_offset(const long int offset, int imgid)</a>
<a name="ln1771">{</a>
<a name="ln1772">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1773">                     dt_control_time_offset_job_create(offset, imgid));</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">void dt_control_write_sidecar_files()</a>
<a name="ln1777">{</a>
<a name="ln1778">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1779">                     dt_control_generic_images_job_create(&amp;dt_control_write_sidecar_files_job_run,</a>
<a name="ln1780">                                                          N_(&quot;write sidecar files&quot;), 0, NULL, PROGRESS_NONE));</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1784">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1785">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="572"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buffer'. Check lines: 572, 568.</p></div>
<div class="balloon" rel="1023"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1245"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!t' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
