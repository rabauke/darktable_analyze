
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#define __STDC_FORMAT_MACROS</a>
<a name="ln20"> </a>
<a name="ln21">#if defined(__SSE__)</a>
<a name="ln22">#include &lt;xmmintrin.h&gt;</a>
<a name="ln23">#endif</a>
<a name="ln24"> </a>
<a name="ln25">extern &quot;C&quot; {</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">// otherwise the name will be mangled and the linker won't be able to see the function ...</a>
<a name="ln30">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln31">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln32">                       const int filters);</a>
<a name="ln33">}</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;algorithm&gt;</a>
<a name="ln36">#include &lt;cmath&gt;</a>
<a name="ln37">#include &lt;cstdint&gt;</a>
<a name="ln38">#include &lt;cstdlib&gt;</a>
<a name="ln39">#include &lt;cstring&gt;</a>
<a name="ln40"> </a>
<a name="ln41">static __inline float clampnan(const float x, const float m, const float M)</a>
<a name="ln42">{</a>
<a name="ln43">  float r;</a>
<a name="ln44"> </a>
<a name="ln45">  // clamp to [m, M] if x is infinite; return average of m and M if x is NaN; else just return x</a>
<a name="ln46"> </a>
<a name="ln47">  if(std::isinf(x))</a>
<a name="ln48">    r = (std::isless(x, m) ? m : (std::isgreater(x, M) ? M : x));</a>
<a name="ln49">  else if(std::isnan(x))</a>
<a name="ln50">    r = (m + M) / 2.0f;</a>
<a name="ln51">  else // normal number</a>
<a name="ln52">    r = x;</a>
<a name="ln53"> </a>
<a name="ln54">  return r;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">#ifndef __SSE2__</a>
<a name="ln58">static __inline float xmul2f(float d)</a>
<a name="ln59">{</a>
<a name="ln60">  if(*(int *)&amp;d &amp; 0x7FFFFFFF) // if f==0 do nothing</a>
<a name="ln61">  {</a>
<a name="ln62">    *(int *)&amp;d += 1 &lt;&lt; 23; // add 1 to the exponent</a>
<a name="ln63">  }</a>
<a name="ln64">  return d;</a>
<a name="ln65">}</a>
<a name="ln66">#endif</a>
<a name="ln67"> </a>
<a name="ln68">static __inline float xdiv2f(float d)</a>
<a name="ln69">{</a>
<a name="ln70">  if(*(int *)&amp;d &amp; 0x7FFFFFFF) // if f==0 do nothing</a>
<a name="ln71">  {</a>
<a name="ln72">    *(int *)&amp;d -= 1 &lt;&lt; 23; // sub 1 from the exponent</a>
<a name="ln73">  }</a>
<a name="ln74">  return d;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">static __inline float xdivf(float d, int n)</a>
<a name="ln78">{</a>
<a name="ln79">  if(*(int *)&amp;d &amp; 0x7FFFFFFF) // if f==0 do nothing</a>
<a name="ln80">  {</a>
<a name="ln81">    *(int *)&amp;d -= n &lt;&lt; 23; // add n to the exponent</a>
<a name="ln82">  }</a>
<a name="ln83">  return d;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">/*==================================================================================</a>
<a name="ln88"> * begin raw therapee code, hg checkout of march 03, 2016 branch master.</a>
<a name="ln89"> *==================================================================================*/</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">#ifdef __SSE2__</a>
<a name="ln93"> </a>
<a name="ln94">#ifdef __GNUC__</a>
<a name="ln95">#define INLINE __inline</a>
<a name="ln96">#else</a>
<a name="ln97">#define INLINE inline</a>
<a name="ln98">#endif</a>
<a name="ln99"> </a>
<a name="ln100">#ifdef __GNUC__</a>
<a name="ln101">#if((__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 9) || __GNUC__ &gt; 4) &amp;&amp; (!defined(WIN32) || defined(__x86_64__))</a>
<a name="ln102">#define LVF(x) _mm_load_ps(&amp;x)</a>
<a name="ln103">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln104">#define STVF(x, y) _mm_store_ps(&amp;x, y)</a>
<a name="ln105">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln106">#else // there is a bug in gcc 4.7.x when using openmp and aligned memory and -O3, also need to map the</a>
<a name="ln107">      // aligned functions to unaligned functions for WIN32 builds</a>
<a name="ln108">#define LVF(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln109">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln110">#define STVF(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln111">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln112">#endif</a>
<a name="ln113">#else</a>
<a name="ln114">#define LVF(x) _mm_load_ps(&amp;x)</a>
<a name="ln115">#define LVFU(x) _mm_loadu_ps(&amp;x)</a>
<a name="ln116">#define STVF(x, y) _mm_store_ps(&amp;x, y)</a>
<a name="ln117">#define STVFU(x, y) _mm_storeu_ps(&amp;x, y)</a>
<a name="ln118">#endif</a>
<a name="ln119"> </a>
<a name="ln120">#define STC2VFU(a, v)                                                                                        \</a>
<a name="ln121">  {                                                                                                          \</a>
<a name="ln122">    __m128 TST1V = _mm_loadu_ps(&amp;a);                                                                         \</a>
<a name="ln123">    __m128 TST2V = _mm_unpacklo_ps(v, v);                                                                    \</a>
<a name="ln124">    vmask cmask = _mm_set_epi32(0xffffffff, 0, 0xffffffff, 0);                                               \</a>
<a name="ln125">    _mm_storeu_ps(&amp;a, vself(cmask, TST1V, TST2V));                                                           \</a>
<a name="ln126">    TST1V = _mm_loadu_ps((&amp;a) + 4);                                                                          \</a>
<a name="ln127">    TST2V = _mm_unpackhi_ps(v, v);                                                                           \</a>
<a name="ln128">    _mm_storeu_ps((&amp;a) + 4, vself(cmask, TST1V, TST2V));                                                     \</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">#define ZEROV _mm_setzero_ps()</a>
<a name="ln132">#define F2V(a) _mm_set1_ps((a))</a>
<a name="ln133"> </a>
<a name="ln134">typedef __m128i vmask;</a>
<a name="ln135">typedef __m128 vfloat;</a>
<a name="ln136">typedef __m128i vint;</a>
<a name="ln137"> </a>
<a name="ln138">static INLINE vfloat LC2VFU(float &amp;a)</a>
<a name="ln139">{</a>
<a name="ln140">  // Load 8 floats from a and combine a[0],a[2],a[4] and a[6] into a vector of 4 floats</a>
<a name="ln141">  vfloat a1 = _mm_loadu_ps(&amp;a);</a>
<a name="ln142">  vfloat a2 = _mm_loadu_ps((&amp;a) + 4);</a>
<a name="ln143">  return _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(2, 0, 2, 0));</a>
<a name="ln144">}</a>
<a name="ln145">static INLINE vfloat vmaxf(vfloat x, vfloat y)</a>
<a name="ln146">{</a>
<a name="ln147">  return _mm_max_ps(x, y);</a>
<a name="ln148">}</a>
<a name="ln149">static INLINE vfloat vminf(vfloat x, vfloat y)</a>
<a name="ln150">{</a>
<a name="ln151">  return _mm_min_ps(x, y);</a>
<a name="ln152">}</a>
<a name="ln153">static INLINE vfloat vcast_vf_f(float f)</a>
<a name="ln154">{</a>
<a name="ln155">  return _mm_set_ps(f, f, f, f);</a>
<a name="ln156">}</a>
<a name="ln157">static INLINE vmask vorm(vmask x, vmask y)</a>
<a name="ln158">{</a>
<a name="ln159">  return _mm_or_si128(x, y);</a>
<a name="ln160">}</a>
<a name="ln161">static INLINE vmask vandm(vmask x, vmask y)</a>
<a name="ln162">{</a>
<a name="ln163">  return _mm_and_si128(x, y);</a>
<a name="ln164">}</a>
<a name="ln165">static INLINE vmask vandnotm(vmask x, vmask y)</a>
<a name="ln166">{</a>
<a name="ln167">  return _mm_andnot_si128(x, y);</a>
<a name="ln168">}</a>
<a name="ln169">static INLINE vfloat vabsf(vfloat f)</a>
<a name="ln170">{</a>
<a name="ln171">  return (vfloat)vandnotm((vmask)vcast_vf_f(-0.0f), (vmask)f);</a>
<a name="ln172">}</a>
<a name="ln173">static INLINE vfloat vself(vmask mask, vfloat x, vfloat y)</a>
<a name="ln174">{</a>
<a name="ln175">  return (vfloat)vorm(vandm(mask, (vmask)x), vandnotm(mask, (vmask)y));</a>
<a name="ln176">}</a>
<a name="ln177">static INLINE vmask vmaskf_lt(vfloat x, vfloat y)</a>
<a name="ln178">{</a>
<a name="ln179">  return (__m128i)_mm_cmplt_ps(x, y);</a>
<a name="ln180">}</a>
<a name="ln181">static INLINE vmask vmaskf_gt(vfloat x, vfloat y)</a>
<a name="ln182">{</a>
<a name="ln183">  return (__m128i)_mm_cmpgt_ps(x, y);</a>
<a name="ln184">}</a>
<a name="ln185">static INLINE vfloat ULIMV(vfloat a, vfloat b, vfloat c)</a>
<a name="ln186">{</a>
<a name="ln187">  // made to clamp a in range [b,c] but in fact it's also the median of a,b,c, which means that the result is</a>
<a name="ln188">  // independent on order of arguments</a>
<a name="ln189">  // ULIMV(a,b,c) = ULIMV(a,c,b) = ULIMV(b,a,c) = ULIMV(b,c,a) = ULIMV(c,a,b) = ULIMV(c,b,a)</a>
<a name="ln190">  return vmaxf(vminf(a, b), vminf(vmaxf(a, b), c));</a>
<a name="ln191">}</a>
<a name="ln192">static INLINE vfloat SQRV(vfloat a)</a>
<a name="ln193">{</a>
<a name="ln194">  return a * a;</a>
<a name="ln195">}</a>
<a name="ln196">static INLINE vfloat vintpf(vfloat a, vfloat b, vfloat c)</a>
<a name="ln197">{</a>
<a name="ln198">  // calculate a * b + (1 - a) * c (interpolate two values)</a>
<a name="ln199">  // following is valid:</a>
<a name="ln200">  // vintpf(a, b+x, c+x) = vintpf(a, b, c) + x</a>
<a name="ln201">  // vintpf(a, b*x, c*x) = vintpf(a, b, c) * x</a>
<a name="ln202">  return a * (b - c) + c;</a>
<a name="ln203">}</a>
<a name="ln204">static INLINE vfloat vaddc2vfu(float &amp;a)</a>
<a name="ln205">{</a>
<a name="ln206">  // loads a[0]..a[7] and returns { a[0]+a[1], a[2]+a[3], a[4]+a[5], a[6]+a[7] }</a>
<a name="ln207">  vfloat a1 = _mm_loadu_ps(&amp;a);</a>
<a name="ln208">  vfloat a2 = _mm_loadu_ps((&amp;a) + 4);</a>
<a name="ln209">  return _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(2, 0, 2, 0)) + _mm_shuffle_ps(a1, a2, _MM_SHUFFLE(3, 1, 3, 1));</a>
<a name="ln210">}</a>
<a name="ln211">static INLINE vfloat vadivapb(vfloat a, vfloat b)</a>
<a name="ln212">{</a>
<a name="ln213">  return a / (a + b);</a>
<a name="ln214">}</a>
<a name="ln215">static INLINE vint vselc(vmask mask, vint x, vint y)</a>
<a name="ln216">{</a>
<a name="ln217">  return vorm(vandm(mask, (vmask)x), vandnotm(mask, (vmask)y));</a>
<a name="ln218">}</a>
<a name="ln219">static INLINE vint vselinotzero(vmask mask, vint x)</a>
<a name="ln220">{</a>
<a name="ln221">  // returns value of x if corresponding mask bits are 0, else returns 0</a>
<a name="ln222">  // faster than vselc(mask, ZEROV, x)</a>
<a name="ln223">  return _mm_andnot_si128(mask, x);</a>
<a name="ln224">}</a>
<a name="ln225">static INLINE vfloat vmul2f(vfloat a)</a>
<a name="ln226">{</a>
<a name="ln227">  // fastest way to multiply by 2</a>
<a name="ln228">  return a + a;</a>
<a name="ln229">}</a>
<a name="ln230">static INLINE vmask vmaskf_ge(vfloat x, vfloat y)</a>
<a name="ln231">{</a>
<a name="ln232">  return (__m128i)_mm_cmpge_ps(x, y);</a>
<a name="ln233">}</a>
<a name="ln234">static INLINE vmask vnotm(vmask x)</a>
<a name="ln235">{</a>
<a name="ln236">  return _mm_xor_si128(x, _mm_cmpeq_epi32(_mm_setzero_si128(), _mm_setzero_si128()));</a>
<a name="ln237">}</a>
<a name="ln238">static INLINE vfloat vdup(vfloat a)</a>
<a name="ln239">{</a>
<a name="ln240">  // returns { a[0],a[0],a[1],a[1] }</a>
<a name="ln241">  return _mm_unpacklo_ps(a, a);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">#endif // __SSE2__</a>
<a name="ln245"> </a>
<a name="ln246">template &lt;typename _Tp&gt; static inline const _Tp SQR(_Tp x)</a>
<a name="ln247">{</a>
<a name="ln248">  //      return std::pow(x,2); Slower than:</a>
<a name="ln249">  return (x * x);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">template &lt;typename _Tp&gt; static inline const _Tp intp(const _Tp a, const _Tp b, const _Tp c)</a>
<a name="ln253">{</a>
<a name="ln254">  // calculate a * b + (1 - a) * c</a>
<a name="ln255">  // following is valid:</a>
<a name="ln256">  // intp(a, b+x, c+x) = intp(a, b, c) + x</a>
<a name="ln257">  // intp(a, b*x, c*x) = intp(a, b, c) * x</a>
<a name="ln258">  return a * (b - c) + c;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">template &lt;typename _Tp&gt; static inline const _Tp LIM(const _Tp a, const _Tp b, const _Tp c)</a>
<a name="ln262">{</a>
<a name="ln263">  return std::max(b, std::min(a, c));</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">template &lt;typename _Tp&gt; static inline const _Tp ULIM(const _Tp a, const _Tp b, const _Tp c)</a>
<a name="ln267">{</a>
<a name="ln268">  return ((b &lt; c) ? LIM(a, b, c) : LIM(a, c, b));</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">////////////////////////////////////////////////////////////////</a>
<a name="ln274">//</a>
<a name="ln275">//          AMaZE demosaic algorithm</a>
<a name="ln276">// (Aliasing Minimization and Zipper Elimination)</a>
<a name="ln277">//</a>
<a name="ln278">//  copyright (c) 2008-2010  Emil Martinec &lt;ejmartin@uchicago.edu&gt;</a>
<a name="ln279">//  optimized for speed by Ingo Weyrich</a>
<a name="ln280">//</a>
<a name="ln281">// incorporating ideas of Luis Sanz Rodrigues and Paul Lee</a>
<a name="ln282">//</a>
<a name="ln283">// code dated: May 27, 2010</a>
<a name="ln284">// latest modification: Ingo Weyrich, January 25, 2016</a>
<a name="ln285">//</a>
<a name="ln286">//  amaze_interpolate_RT.cc is free software: you can redistribute it and/or modify</a>
<a name="ln287">//  it under the terms of the GNU General Public License as published by</a>
<a name="ln288">//  the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln289">//  (at your option) any later version.</a>
<a name="ln290">//</a>
<a name="ln291">//  This program is distributed in the hope that it will be useful,</a>
<a name="ln292">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln293">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln294">//  GNU General Public License for more details.</a>
<a name="ln295">//</a>
<a name="ln296">//  You should have received a copy of the GNU General Public License</a>
<a name="ln297">//  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln298">//</a>
<a name="ln299">////////////////////////////////////////////////////////////////</a>
<a name="ln300"> </a>
<a name="ln301">// namespace rtengine</a>
<a name="ln302">// {</a>
<a name="ln303"> </a>
<a name="ln304">// SSEFUNCTION void RawImageSource::amaze_demosaic_RT(int winx, int winy, int winw, int winh)</a>
<a name="ln305">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln306">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln307">                       const int filters)</a>
<a name="ln308">{</a>
<a name="ln309">  //   BENCHFUN</a>
<a name="ln310"> </a>
<a name="ln311">  //   volatile double progress = 0.0;</a>
<a name="ln312"> </a>
<a name="ln313">  //   if(plistener)</a>
<a name="ln314">  //   {</a>
<a name="ln315">  //     plistener-&gt;setProgressStr(Glib::ustring::compose(</a>
<a name="ln316">  //         M(&quot;TP_RAW_DMETHOD_PROGRESSBAR&quot;),</a>
<a name="ln317">  //         RAWParams::BayerSensor::methodstring[RAWParams::BayerSensor::amaze]));</a>
<a name="ln318">  //     plistener-&gt;setProgress(0.0);</a>
<a name="ln319">  //   }</a>
<a name="ln320"> </a>
<a name="ln321">  int winx = roi_out-&gt;x;</a>
<a name="ln322">  int winy = roi_out-&gt;y;</a>
<a name="ln323">  int winw = roi_in-&gt;width;</a>
<a name="ln324">  int winh = roi_in-&gt;height;</a>
<a name="ln325"> </a>
<a name="ln326">  const int width = winw, height = winh;</a>
<a name="ln327">  //   const float clip_pt = 1.0 / initialGain;</a>
<a name="ln328">  //   const float clip_pt8 = 0.8 / initialGain;</a>
<a name="ln329">  const float clip_pt = fminf(piece-&gt;pipe-&gt;dsc.processed_maximum[0],</a>
<a name="ln330">                              fminf(piece-&gt;pipe-&gt;dsc.processed_maximum[1], piece-&gt;pipe-&gt;dsc.processed_maximum[2]));</a>
<a name="ln331">  const float clip_pt8 = 0.8f * clip_pt;</a>
<a name="ln332"> </a>
<a name="ln333">// this allows to pass AMAZETS to the code. On some machines larger AMAZETS is faster</a>
<a name="ln334">// If AMAZETS is undefined it will be set to 160, which is the fastest on modern x86/64 machines</a>
<a name="ln335">#ifndef AMAZETS</a>
<a name="ln336">#define AMAZETS 160</a>
<a name="ln337">#endif</a>
<a name="ln338">  // Tile size; the image is processed in square tiles to lower memory requirements and facilitate</a>
<a name="ln339">  // multi-threading</a>
<a name="ln340">  // We assure that Tile size is a multiple of 32 in the range [96;992]</a>
<a name="ln341">  constexpr int ts = (AMAZETS &amp; 992) &lt; 96 ? 96 : (AMAZETS &amp; 992);</a>
<a name="ln342">  constexpr int tsh = ts / 2; // half of Tile size</a>
<a name="ln343"> </a>
<a name="ln344">  // offset of R pixel within a Bayer quartet</a>
<a name="ln345">  int ex, ey;</a>
<a name="ln346"> </a>
<a name="ln347">  // determine GRBG coset; (ey,ex) is the offset of the R subarray</a>
<a name="ln348">  if(FC(0, 0, filters) == 1)</a>
<a name="ln349">  { // first pixel is G</a>
<a name="ln350">    if(FC(0, 1, filters) == 0)</a>
<a name="ln351">    {</a>
<a name="ln352">      ey = 0;</a>
<a name="ln353">      ex = 1;</a>
<a name="ln354">    }</a>
<a name="ln355">    else</a>
<a name="ln356">    {</a>
<a name="ln357">      ey = 1;</a>
<a name="ln358">      ex = 0;</a>
<a name="ln359">    }</a>
<a name="ln360">  }</a>
<a name="ln361">  else</a>
<a name="ln362">  { // first pixel is R or B</a>
<a name="ln363">    if(FC(0, 0, filters) == 0)</a>
<a name="ln364">    {</a>
<a name="ln365">      ey = 0;</a>
<a name="ln366">      ex = 0;</a>
<a name="ln367">    }</a>
<a name="ln368">    else</a>
<a name="ln369">    {</a>
<a name="ln370">      ey = 1;</a>
<a name="ln371">      ex = 1;</a>
<a name="ln372">    }</a>
<a name="ln373">  }</a>
<a name="ln374"> </a>
<a name="ln375">  // shifts of pointer value to access pixels in vertical and diagonal directions</a>
<a name="ln376">  constexpr int v1 = ts, v2 = 2 * ts, v3 = 3 * ts, p1 = -ts + 1, p2 = -2 * ts + 2, p3 = -3 * ts + 3,</a>
<a name="ln377">                m1 = ts + 1, m2 = 2 * ts + 2, m3 = 3 * ts + 3;</a>
<a name="ln378"> </a>
<a name="ln379">  // tolerance to avoid dividing by zero</a>
<a name="ln380">  constexpr float eps = 1e-5, epssq = 1e-10; // tolerance to avoid dividing by zero</a>
<a name="ln381"> </a>
<a name="ln382">  // adaptive ratios threshold</a>
<a name="ln383">  constexpr float arthresh = 0.75;</a>
<a name="ln384"> </a>
<a name="ln385">  // gaussian on 5x5 quincunx, sigma=1.2</a>
<a name="ln386">  constexpr float gaussodd[4]</a>
<a name="ln387">      = { 0.14659727707323927f, 0.103592713382435f, 0.0732036125103057f, 0.0365543548389495f };</a>
<a name="ln388">  // nyquist texture test threshold</a>
<a name="ln389">  constexpr float nyqthresh = 0.5;</a>
<a name="ln390">  // gaussian on 5x5, sigma=1.2, multiplied with nyqthresh to save some time later in loop</a>
<a name="ln391">  // Is this really sigma=1.2????, seems more like sigma = 1.672</a>
<a name="ln392">  constexpr float gaussgrad[6] = { nyqthresh * 0.07384411893421103f, nyqthresh * 0.06207511968171489f,</a>
<a name="ln393">                                   nyqthresh * 0.0521818194747806f,  nyqthresh * 0.03687419286733595f,</a>
<a name="ln394">                                   nyqthresh * 0.03099732204057846f, nyqthresh * 0.018413194161458882f };</a>
<a name="ln395">  // gaussian on 5x5 alt quincunx, sigma=1.5</a>
<a name="ln396">  constexpr float gausseven[2] = { 0.13719494435797422f, 0.05640252782101291f };</a>
<a name="ln397">  // gaussian on quincunx grid</a>
<a name="ln398">  constexpr float gquinc[4] = { 0.169917f, 0.108947f, 0.069855f, 0.0287182f };</a>
<a name="ln399"> </a>
<a name="ln400">  typedef struct</a>
<a name="ln401">  {</a>
<a name="ln402">    float h;</a>
<a name="ln403">    float v;</a>
<a name="ln404">  } s_hv;</a>
<a name="ln405"> </a>
<a name="ln406">#ifdef _OPENMP</a>
<a name="ln407">#pragma omp parallel</a>
<a name="ln408">#endif</a>
<a name="ln409">  {</a>
<a name="ln410">    //     int progresscounter = 0;</a>
<a name="ln411"> </a>
<a name="ln412">    constexpr int cldf = 2; // factor to multiply cache line distance. 1 = 64 bytes, 2 = 128 bytes ...</a>
<a name="ln413">    // assign working space</a>
<a name="ln414">    char *buffer</a>
<a name="ln415">        = (char *)calloc(14 * sizeof(float) * ts * ts + sizeof(char) * ts * tsh + 18 * cldf * 64 + 63, 1);</a>
<a name="ln416">    // aligned to 64 byte boundary</a>
<a name="ln417">    char *data = (char *)((uintptr_t(buffer) + uintptr_t(63)) / 64 * 64);</a>
<a name="ln418"> </a>
<a name="ln419">    // green values</a>
<a name="ln420">    float *rgbgreen = (float(*))data;</a>
<a name="ln421">    // sum of square of horizontal gradient and square of vertical gradient</a>
<a name="ln422">    float *delhvsqsum = (float(*))((char *)rgbgreen + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln423">    // gradient based directional weights for interpolation</a>
<a name="ln424">    float *dirwts0 = (float(*))((char *)delhvsqsum + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln425">    float *dirwts1 = (float(*))((char *)dirwts0 + sizeof(float) * ts * ts + cldf * 64);    // 1</a>
<a name="ln426">    // vertically interpolated colour differences G-R, G-B</a>
<a name="ln427">    float *vcd = (float(*))((char *)dirwts1 + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln428">    // horizontally interpolated colour differences</a>
<a name="ln429">    float *hcd = (float(*))((char *)vcd + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln430">    // alternative vertical interpolation</a>
<a name="ln431">    float *vcdalt = (float(*))((char *)hcd + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln432">    // alternative horizontal interpolation</a>
<a name="ln433">    float *hcdalt = (float(*))((char *)vcdalt + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln434">    // square of average colour difference</a>
<a name="ln435">    float *cddiffsq = (float(*))((char *)hcdalt + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln436">    // weight to give horizontal vs vertical interpolation</a>
<a name="ln437">    float *hvwt = (float(*))((char *)cddiffsq + sizeof(float) * ts * ts + 2 * cldf * 64); // 1</a>
<a name="ln438">    // final interpolated colour difference</a>
<a name="ln439">    float(*Dgrb)[ts * tsh] = (float(*)[ts * tsh])vcdalt; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln440">    // gradient in plus (NE/SW) direction</a>
<a name="ln441">    float *delp = (float(*))cddiffsq; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln442">    // gradient in minus (NW/SE) direction</a>
<a name="ln443">    float *delm = (float(*))((char *)delp + sizeof(float) * ts * tsh + cldf * 64);</a>
<a name="ln444">    // diagonal interpolation of R+B</a>
<a name="ln445">    float *rbint = (float(*))delm; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln446">    // horizontal and vertical curvature of interpolated G (used to refine interpolation in Nyquist texture</a>
<a name="ln447">    // regions)</a>
<a name="ln448">    s_hv *Dgrb2 = (s_hv(*))((char *)hvwt + sizeof(float) * ts * tsh + cldf * 64); // 1</a>
<a name="ln449">    // difference between up/down interpolations of G</a>
<a name="ln450">    float *dgintv = (float(*))Dgrb2; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln451">    // difference between left/right interpolations of G</a>
<a name="ln452">    float *dginth = (float(*))((char *)dgintv + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln453">    // square of diagonal colour differences</a>
<a name="ln454">    float *Dgrbsq1m = (float(*))((char *)dginth + sizeof(float) * ts * ts + cldf * 64);    // 1</a>
<a name="ln455">    float *Dgrbsq1p = (float(*))((char *)Dgrbsq1m + sizeof(float) * ts * tsh + cldf * 64); // 1</a>
<a name="ln456">    // tile raw data</a>
<a name="ln457">    float *cfa = (float(*))((char *)Dgrbsq1p + sizeof(float) * ts * tsh + cldf * 64); // 1</a>
<a name="ln458">    // relative weight for combining plus and minus diagonal interpolations</a>
<a name="ln459">    float *pmwt = (float(*))delhvsqsum; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln460">    // interpolated colour difference R-B in minus and plus direction</a>
<a name="ln461">    float *rbm = (float(*))vcd; // there is no overlap in buffer usage =&gt; share</a>
<a name="ln462">    float *rbp = (float(*))((char *)rbm + sizeof(float) * ts * tsh + cldf * 64);</a>
<a name="ln463">    // nyquist texture flags 1=nyquist, 0=not nyquist</a>
<a name="ln464">    unsigned char *nyquist = (unsigned char(*))((char *)cfa + sizeof(float) * ts * ts + cldf * 64); // 1</a>
<a name="ln465">    unsigned char *nyquist2 = (unsigned char(*))cddiffsq;</a>
<a name="ln466">    float *nyqutest = (float(*))((char *)nyquist + sizeof(unsigned char) * ts * tsh + cldf * 64); // 1</a>
<a name="ln467"> </a>
<a name="ln468">// Main algorithm: Tile loop</a>
<a name="ln469">// use collapse(2) to collapse the 2 loops to one large loop, so there is better scaling</a>
<a name="ln470">#ifdef _OPENMP</a>
<a name="ln471">#pragma omp for SIMD() schedule(static) collapse(2) nowait</a>
<a name="ln472">#endif</a>
<a name="ln473"> </a>
<a name="ln474">    for(int top = winy - 16; top &lt; winy + height; top += ts - 32)</a>
<a name="ln475">    {</a>
<a name="ln476">      for(int left = winx - 16; left &lt; winx + width; left += ts - 32)</a>
<a name="ln477">      {</a>
<a name="ln478">        memset(&amp;nyquist[3 * tsh], 0, sizeof(unsigned char) * (ts - 6) * tsh);</a>
<a name="ln479">        // location of tile bottom edge</a>
<a name="ln480">        int bottom = MIN(top + ts, winy + height + 16);</a>
<a name="ln481">        // location of tile right edge</a>
<a name="ln482">        int right = MIN(left + ts, winx + width + 16);</a>
<a name="ln483">        // tile width  (=ts except for right edge of image)</a>
<a name="ln484">        int rr1 = bottom - top;</a>
<a name="ln485">        // tile height (=ts except for bottom edge of image)</a>
<a name="ln486">        int cc1 = right - left;</a>
<a name="ln487">        // bookkeeping for borders</a>
<a name="ln488">        // min and max row/column in the tile</a>
<a name="ln489">        int rrmin = top &lt; winy ? 16 : 0;</a>
<a name="ln490">        int ccmin = left &lt; winx ? 16 : 0;</a>
<a name="ln491">        int rrmax = bottom &gt; (winy + height) ? winy + height - top : rr1;</a>
<a name="ln492">        int ccmax = right &gt; (winx + width) ? winx + width - left : cc1;</a>
<a name="ln493"> </a>
<a name="ln494">// rgb from input CFA data</a>
<a name="ln495">// rgb values should be floating point number between 0 and 1</a>
<a name="ln496">// after white balance multipliers are applied</a>
<a name="ln497">// a 16 pixel border is added to each side of the image</a>
<a name="ln498"> </a>
<a name="ln499">// begin of tile initialization</a>
<a name="ln500">#ifdef __SSE2__</a>
<a name="ln501">        // fill upper border</a>
<a name="ln502">        if(rrmin &gt; 0)</a>
<a name="ln503">        {</a>
<a name="ln504">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln505">          {</a>
<a name="ln506">            int row = 32 - rr + top;</a>
<a name="ln507"> </a>
<a name="ln508">            for(int cc = ccmin; cc &lt; ccmax; cc += 4)</a>
<a name="ln509">            {</a>
<a name="ln510">              int indx1 = rr * ts + cc;</a>
<a name="ln511">              vfloat tempv = LVFU(in[row * width + (cc + left)]);</a>
<a name="ln512">              STVF(cfa[indx1], tempv);</a>
<a name="ln513">              STVF(rgbgreen[indx1], tempv);</a>
<a name="ln514">            }</a>
<a name="ln515">          }</a>
<a name="ln516">        }</a>
<a name="ln517"> </a>
<a name="ln518">        // fill inner part</a>
<a name="ln519">        for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln520">        {</a>
<a name="ln521">          int row = rr + top;</a>
<a name="ln522"> </a>
<a name="ln523">          for(int cc = ccmin; cc &lt; ccmax; cc += 4)</a>
<a name="ln524">          {</a>
<a name="ln525">            int indx1 = rr * ts + cc;</a>
<a name="ln526">            vfloat tempv = LVFU(in[row * width + (cc + left)]);</a>
<a name="ln527">            STVF(cfa[indx1], tempv);</a>
<a name="ln528">            STVF(rgbgreen[indx1], tempv);</a>
<a name="ln529">          }</a>
<a name="ln530">        }</a>
<a name="ln531"> </a>
<a name="ln532">        // fill lower border</a>
<a name="ln533">        if(rrmax &lt; rr1)</a>
<a name="ln534">        {</a>
<a name="ln535">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln536">            for(int cc = ccmin; cc &lt; ccmax; cc += 4)</a>
<a name="ln537">            {</a>
<a name="ln538">              int indx1 = (rrmax + rr) * ts + cc;</a>
<a name="ln539">              vfloat tempv = LVFU(in[(winy + height - rr - 2) * width + (left + cc)]);</a>
<a name="ln540">              STVF(cfa[indx1], tempv);</a>
<a name="ln541">              STVF(rgbgreen[indx1], tempv);</a>
<a name="ln542">            }</a>
<a name="ln543">        }</a>
<a name="ln544"> </a>
<a name="ln545">#else</a>
<a name="ln546"> </a>
<a name="ln547">        // fill upper border</a>
<a name="ln548">        if(rrmin &gt; 0)</a>
<a name="ln549">        {</a>
<a name="ln550">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln551">            for(int cc = ccmin, row = 32 - rr + top; cc &lt; ccmax; cc++)</a>
<a name="ln552">            {</a>
<a name="ln553">              cfa[rr * ts + cc] = (in[row * width + (cc + left)]);</a>
<a name="ln554">              rgbgreen[rr * ts + cc] = cfa[rr * ts + cc];</a>
<a name="ln555">            }</a>
<a name="ln556">        }</a>
<a name="ln557"> </a>
<a name="ln558">        // fill inner part</a>
<a name="ln559">        for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln560">        {</a>
<a name="ln561">          int row = rr + top;</a>
<a name="ln562"> </a>
<a name="ln563">          for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln564">          {</a>
<a name="ln565">            int indx1 = rr * ts + cc;</a>
<a name="ln566">            cfa[indx1] = (in[row * width + (cc + left)]);</a>
<a name="ln567">            rgbgreen[indx1] = cfa[indx1];</a>
<a name="ln568">          }</a>
<a name="ln569">        }</a>
<a name="ln570"> </a>
<a name="ln571">        // fill lower border</a>
<a name="ln572">        if(rrmax &lt; rr1)</a>
<a name="ln573">        {</a>
<a name="ln574">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln575">            for(int cc = ccmin; cc &lt; ccmax; cc++)</a>
<a name="ln576">            {</a>
<a name="ln577">              cfa[(rrmax + rr) * ts + cc] = (in[(winy + height - rr - 2) * width + (left + cc)]);</a>
<a name="ln578">              rgbgreen[(rrmax + rr) * ts + cc] = cfa[(rrmax + rr) * ts + cc];</a>
<a name="ln579">            }</a>
<a name="ln580">        }</a>
<a name="ln581"> </a>
<a name="ln582">#endif</a>
<a name="ln583"> </a>
<a name="ln584">        // fill left border</a>
<a name="ln585">        if(ccmin &gt; 0)</a>
<a name="ln586">        {</a>
<a name="ln587">          for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln588">            for(int cc = 0, row = rr + top; cc &lt; 16; cc++)</a>
<a name="ln589">            {</a>
<a name="ln590">              cfa[rr * ts + cc] = (in[row * width + (32 - cc + left)]);</a>
<a name="ln591">              rgbgreen[rr * ts + cc] = cfa[rr * ts + cc];</a>
<a name="ln592">            }</a>
<a name="ln593">        }</a>
<a name="ln594"> </a>
<a name="ln595">        // fill right border</a>
<a name="ln596">        if(ccmax &lt; cc1)</a>
<a name="ln597">        {</a>
<a name="ln598">          for(int rr = rrmin; rr &lt; rrmax; rr++)</a>
<a name="ln599">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln600">            {</a>
<a name="ln601">              cfa[rr * ts + ccmax + cc] = (in[(top + rr) * width + ((winx + width - cc - 2))]);</a>
<a name="ln602">              rgbgreen[rr * ts + ccmax + cc] = cfa[rr * ts + ccmax + cc];</a>
<a name="ln603">            }</a>
<a name="ln604">        }</a>
<a name="ln605"> </a>
<a name="ln606">        // also, fill the image corners</a>
<a name="ln607">        if(rrmin &gt; 0 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln608">        {</a>
<a name="ln609">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln610">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln611">            {</a>
<a name="ln612">              cfa[(rr)*ts + cc] = (in[(winy + 32 - rr) * width + (winx + 32 - cc)]);</a>
<a name="ln613">              rgbgreen[(rr)*ts + cc] = cfa[(rr)*ts + cc];</a>
<a name="ln614">            }</a>
<a name="ln615">        }</a>
<a name="ln616"> </a>
<a name="ln617">        if(rrmax &lt; rr1 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln618">        {</a>
<a name="ln619">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln620">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln621">            {</a>
<a name="ln622">              cfa[(rrmax + rr) * ts + ccmax + cc]</a>
<a name="ln623">                  = (in[(winy + height - rr - 2) * width + ((winx + width - cc - 2))]);</a>
<a name="ln624">              rgbgreen[(rrmax + rr) * ts + ccmax + cc] = cfa[(rrmax + rr) * ts + ccmax + cc];</a>
<a name="ln625">            }</a>
<a name="ln626">        }</a>
<a name="ln627"> </a>
<a name="ln628">        if(rrmin &gt; 0 &amp;&amp; ccmax &lt; cc1)</a>
<a name="ln629">        {</a>
<a name="ln630">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln631">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln632">            {</a>
<a name="ln633">              cfa[(rr)*ts + ccmax + cc] = (in[(winy + 32 - rr) * width + ((winx + width - cc - 2))]);</a>
<a name="ln634">              rgbgreen[(rr)*ts + ccmax + cc] = cfa[(rr)*ts + ccmax + cc];</a>
<a name="ln635">            }</a>
<a name="ln636">        }</a>
<a name="ln637"> </a>
<a name="ln638">        if(rrmax &lt; rr1 &amp;&amp; ccmin &gt; 0)</a>
<a name="ln639">        {</a>
<a name="ln640">          for(int rr = 0; rr &lt; 16; rr++)</a>
<a name="ln641">            for(int cc = 0; cc &lt; 16; cc++)</a>
<a name="ln642">            {</a>
<a name="ln643">              cfa[(rrmax + rr) * ts + cc] = (in[(winy + height - rr - 2) * width + ((winx + 32 - cc))]);</a>
<a name="ln644">              rgbgreen[(rrmax + rr) * ts + cc] = cfa[(rrmax + rr) * ts + cc];</a>
<a name="ln645">            }</a>
<a name="ln646">        }</a>
<a name="ln647"> </a>
<a name="ln648">// end of tile initialization</a>
<a name="ln649"> </a>
<a name="ln650">// horizontal and vertical gradients</a>
<a name="ln651">#ifdef __SSE2__</a>
<a name="ln652">        vfloat epsv = F2V(eps);</a>
<a name="ln653"> </a>
<a name="ln654">        for(int rr = 2; rr &lt; rr1 - 2; rr++)</a>
<a name="ln655">        {</a>
<a name="ln656">          for(int indx = rr * ts; indx &lt; rr * ts + cc1; indx += 4)</a>
<a name="ln657">          {</a>
<a name="ln658">            vfloat delhv = vabsf(LVFU(cfa[indx + 1]) - LVFU(cfa[indx - 1]));</a>
<a name="ln659">            vfloat delvv = vabsf(LVF(cfa[indx + v1]) - LVF(cfa[indx - v1]));</a>
<a name="ln660">            STVF(dirwts1[indx], epsv + vabsf(LVFU(cfa[indx + 2]) - LVF(cfa[indx]))</a>
<a name="ln661">                                    + vabsf(LVF(cfa[indx]) - LVFU(cfa[indx - 2])) + delhv);</a>
<a name="ln662">            STVF(dirwts0[indx], epsv + vabsf(LVF(cfa[indx + v2]) - LVF(cfa[indx]))</a>
<a name="ln663">                                    + vabsf(LVF(cfa[indx]) - LVF(cfa[indx - v2])) + delvv);</a>
<a name="ln664">            STVF(delhvsqsum[indx], SQRV(delhv) + SQRV(delvv));</a>
<a name="ln665">          }</a>
<a name="ln666">        }</a>
<a name="ln667"> </a>
<a name="ln668">#else</a>
<a name="ln669"> </a>
<a name="ln670">        for(int rr = 2; rr &lt; rr1 - 2; rr++)</a>
<a name="ln671">          for(int cc = 2, indx = (rr)*ts + cc; cc &lt; cc1 - 2; cc++, indx++)</a>
<a name="ln672">          {</a>
<a name="ln673">            float delh = fabsf(cfa[indx + 1] - cfa[indx - 1]);</a>
<a name="ln674">            float delv = fabsf(cfa[indx + v1] - cfa[indx - v1]);</a>
<a name="ln675">            dirwts0[indx]</a>
<a name="ln676">                = eps + fabsf(cfa[indx + v2] - cfa[indx]) + fabsf(cfa[indx] - cfa[indx - v2]) + delv;</a>
<a name="ln677">            dirwts1[indx] = eps + fabsf(cfa[indx + 2] - cfa[indx]) + fabsf(cfa[indx] - cfa[indx - 2]) + delh;</a>
<a name="ln678">            delhvsqsum[indx] = SQR(delh) + SQR(delv);</a>
<a name="ln679">          }</a>
<a name="ln680"> </a>
<a name="ln681">#endif</a>
<a name="ln682"> </a>
<a name="ln683">// interpolate vertical and horizontal colour differences</a>
<a name="ln684">#ifdef __SSE2__</a>
<a name="ln685">        vfloat sgnv;</a>
<a name="ln686"> </a>
<a name="ln687">        if(!(FC(4, 4, filters) &amp; 1))</a>
<a name="ln688">        {</a>
<a name="ln689">          sgnv = _mm_set_ps(1.f, -1.f, 1.f, -1.f);</a>
<a name="ln690">        }</a>
<a name="ln691">        else</a>
<a name="ln692">        {</a>
<a name="ln693">          sgnv = _mm_set_ps(-1.f, 1.f, -1.f, 1.f);</a>
<a name="ln694">        }</a>
<a name="ln695"> </a>
<a name="ln696">        vfloat zd5v = F2V(0.5f);</a>
<a name="ln697">        vfloat onev = F2V(1.f);</a>
<a name="ln698">        vfloat arthreshv = F2V(arthresh);</a>
<a name="ln699">        vfloat clip_pt8v = F2V(clip_pt8);</a>
<a name="ln700"> </a>
<a name="ln701">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln702">        {</a>
<a name="ln703">          sgnv = -sgnv;</a>
<a name="ln704"> </a>
<a name="ln705">          for(int indx = rr * ts + 4; indx &lt; rr * ts + cc1 - 7; indx += 4)</a>
<a name="ln706">          {</a>
<a name="ln707">            // colour ratios in each cardinal direction</a>
<a name="ln708">            vfloat cfav = LVF(cfa[indx]);</a>
<a name="ln709">            vfloat cruv = LVF(cfa[indx - v1]) * (LVF(dirwts0[indx - v2]) + LVF(dirwts0[indx]))</a>
<a name="ln710">                          / (LVF(dirwts0[indx - v2]) * (epsv + cfav)</a>
<a name="ln711">                             + LVF(dirwts0[indx]) * (epsv + LVF(cfa[indx - v2])));</a>
<a name="ln712">            vfloat crdv = LVF(cfa[indx + v1]) * (LVF(dirwts0[indx + v2]) + LVF(dirwts0[indx]))</a>
<a name="ln713">                          / (LVF(dirwts0[indx + v2]) * (epsv + cfav)</a>
<a name="ln714">                             + LVF(dirwts0[indx]) * (epsv + LVF(cfa[indx + v2])));</a>
<a name="ln715">            vfloat crlv = LVFU(cfa[indx - 1]) * (LVFU(dirwts1[indx - 2]) + LVF(dirwts1[indx]))</a>
<a name="ln716">                          / (LVFU(dirwts1[indx - 2]) * (epsv + cfav)</a>
<a name="ln717">                             + LVF(dirwts1[indx]) * (epsv + LVFU(cfa[indx - 2])));</a>
<a name="ln718">            vfloat crrv = LVFU(cfa[indx + 1]) * (LVFU(dirwts1[indx + 2]) + LVF(dirwts1[indx]))</a>
<a name="ln719">                          / (LVFU(dirwts1[indx + 2]) * (epsv + cfav)</a>
<a name="ln720">                             + LVF(dirwts1[indx]) * (epsv + LVFU(cfa[indx + 2])));</a>
<a name="ln721"> </a>
<a name="ln722">            // G interpolated in vert/hor directions using Hamilton-Adams method</a>
<a name="ln723">            vfloat guhav = LVF(cfa[indx - v1]) + zd5v * (cfav - LVF(cfa[indx - v2]));</a>
<a name="ln724">            vfloat gdhav = LVF(cfa[indx + v1]) + zd5v * (cfav - LVF(cfa[indx + v2]));</a>
<a name="ln725">            vfloat glhav = LVFU(cfa[indx - 1]) + zd5v * (cfav - LVFU(cfa[indx - 2]));</a>
<a name="ln726">            vfloat grhav = LVFU(cfa[indx + 1]) + zd5v * (cfav - LVFU(cfa[indx + 2]));</a>
<a name="ln727"> </a>
<a name="ln728">            // G interpolated in vert/hor directions using adaptive ratios</a>
<a name="ln729">            vfloat guarv = vself(vmaskf_lt(vabsf(onev - cruv), arthreshv), cfav * cruv, guhav);</a>
<a name="ln730">            vfloat gdarv = vself(vmaskf_lt(vabsf(onev - crdv), arthreshv), cfav * crdv, gdhav);</a>
<a name="ln731">            vfloat glarv = vself(vmaskf_lt(vabsf(onev - crlv), arthreshv), cfav * crlv, glhav);</a>
<a name="ln732">            vfloat grarv = vself(vmaskf_lt(vabsf(onev - crrv), arthreshv), cfav * crrv, grhav);</a>
<a name="ln733"> </a>
<a name="ln734">            // adaptive weights for vertical/horizontal directions</a>
<a name="ln735">            vfloat hwtv = LVFU(dirwts1[indx - 1]) / (LVFU(dirwts1[indx - 1]) + LVFU(dirwts1[indx + 1]));</a>
<a name="ln736">            vfloat vwtv = LVF(dirwts0[indx - v1]) / (LVF(dirwts0[indx + v1]) + LVF(dirwts0[indx - v1]));</a>
<a name="ln737"> </a>
<a name="ln738">            // interpolated G via adaptive weights of cardinal evaluations</a>
<a name="ln739">            vfloat Ginthhav = vintpf(hwtv, grhav, glhav);</a>
<a name="ln740">            vfloat Gintvhav = vintpf(vwtv, gdhav, guhav);</a>
<a name="ln741"> </a>
<a name="ln742">            // interpolated colour differences</a>
<a name="ln743">            vfloat hcdaltv = sgnv * (Ginthhav - cfav);</a>
<a name="ln744">            vfloat vcdaltv = sgnv * (Gintvhav - cfav);</a>
<a name="ln745">            STVF(hcdalt[indx], hcdaltv);</a>
<a name="ln746">            STVF(vcdalt[indx], vcdaltv);</a>
<a name="ln747"> </a>
<a name="ln748">            vmask clipmask = vorm(vorm(vmaskf_gt(cfav, clip_pt8v), vmaskf_gt(Gintvhav, clip_pt8v)),</a>
<a name="ln749">                                  vmaskf_gt(Ginthhav, clip_pt8v));</a>
<a name="ln750">            guarv = vself(clipmask, guhav, guarv);</a>
<a name="ln751">            gdarv = vself(clipmask, gdhav, gdarv);</a>
<a name="ln752">            glarv = vself(clipmask, glhav, glarv);</a>
<a name="ln753">            grarv = vself(clipmask, grhav, grarv);</a>
<a name="ln754"> </a>
<a name="ln755">            // use HA if highlights are (nearly) clipped</a>
<a name="ln756">            STVF(vcd[indx], vself(clipmask, vcdaltv, sgnv * (vintpf(vwtv, gdarv, guarv) - cfav)));</a>
<a name="ln757">            STVF(hcd[indx], vself(clipmask, hcdaltv, sgnv * (vintpf(hwtv, grarv, glarv) - cfav)));</a>
<a name="ln758"> </a>
<a name="ln759">            // differences of interpolations in opposite directions</a>
<a name="ln760">            STVF(dgintv[indx], vminf(SQRV(guhav - gdhav), SQRV(guarv - gdarv)));</a>
<a name="ln761">            STVF(dginth[indx], vminf(SQRV(glhav - grhav), SQRV(glarv - grarv)));</a>
<a name="ln762">          }</a>
<a name="ln763">        }</a>
<a name="ln764"> </a>
<a name="ln765">#else</a>
<a name="ln766"> </a>
<a name="ln767">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln768">        {</a>
<a name="ln769">          bool fcswitch = FC(rr, 4, filters) &amp; 1;</a>
<a name="ln770"> </a>
<a name="ln771">          for(int cc = 4, indx = rr * ts + cc; cc &lt; cc1 - 4; cc++, indx++)</a>
<a name="ln772">          {</a>
<a name="ln773"> </a>
<a name="ln774">            // colour ratios in each cardinal direction</a>
<a name="ln775">            float cru = cfa[indx - v1] * (dirwts0[indx - v2] + dirwts0[indx])</a>
<a name="ln776">                        / (dirwts0[indx - v2] * (eps + cfa[indx]) + dirwts0[indx] * (eps + cfa[indx - v2]));</a>
<a name="ln777">            float crd = cfa[indx + v1] * (dirwts0[indx + v2] + dirwts0[indx])</a>
<a name="ln778">                        / (dirwts0[indx + v2] * (eps + cfa[indx]) + dirwts0[indx] * (eps + cfa[indx + v2]));</a>
<a name="ln779">            float crl = cfa[indx - 1] * (dirwts1[indx - 2] + dirwts1[indx])</a>
<a name="ln780">                        / (dirwts1[indx - 2] * (eps + cfa[indx]) + dirwts1[indx] * (eps + cfa[indx - 2]));</a>
<a name="ln781">            float crr = cfa[indx + 1] * (dirwts1[indx + 2] + dirwts1[indx])</a>
<a name="ln782">                        / (dirwts1[indx + 2] * (eps + cfa[indx]) + dirwts1[indx] * (eps + cfa[indx + 2]));</a>
<a name="ln783"> </a>
<a name="ln784">            // G interpolated in vert/hor directions using Hamilton-Adams method</a>
<a name="ln785">            float guha = cfa[indx - v1] + xdiv2f(cfa[indx] - cfa[indx - v2]);</a>
<a name="ln786">            float gdha = cfa[indx + v1] + xdiv2f(cfa[indx] - cfa[indx + v2]);</a>
<a name="ln787">            float glha = cfa[indx - 1] + xdiv2f(cfa[indx] - cfa[indx - 2]);</a>
<a name="ln788">            float grha = cfa[indx + 1] + xdiv2f(cfa[indx] - cfa[indx + 2]);</a>
<a name="ln789"> </a>
<a name="ln790">            // G interpolated in vert/hor directions using adaptive ratios</a>
<a name="ln791">            float guar, gdar, glar, grar;</a>
<a name="ln792"> </a>
<a name="ln793">            if(fabsf(1.f - cru) &lt; arthresh)</a>
<a name="ln794">            {</a>
<a name="ln795">              guar = cfa[indx] * cru;</a>
<a name="ln796">            }</a>
<a name="ln797">            else</a>
<a name="ln798">            {</a>
<a name="ln799">              guar = guha;</a>
<a name="ln800">            }</a>
<a name="ln801"> </a>
<a name="ln802">            if(fabsf(1.f - crd) &lt; arthresh)</a>
<a name="ln803">            {</a>
<a name="ln804">              gdar = cfa[indx] * crd;</a>
<a name="ln805">            }</a>
<a name="ln806">            else</a>
<a name="ln807">            {</a>
<a name="ln808">              gdar = gdha;</a>
<a name="ln809">            }</a>
<a name="ln810"> </a>
<a name="ln811">            if(fabsf(1.f - crl) &lt; arthresh)</a>
<a name="ln812">            {</a>
<a name="ln813">              glar = cfa[indx] * crl;</a>
<a name="ln814">            }</a>
<a name="ln815">            else</a>
<a name="ln816">            {</a>
<a name="ln817">              glar = glha;</a>
<a name="ln818">            }</a>
<a name="ln819"> </a>
<a name="ln820">            if(fabsf(1.f - crr) &lt; arthresh)</a>
<a name="ln821">            {</a>
<a name="ln822">              grar = cfa[indx] * crr;</a>
<a name="ln823">            }</a>
<a name="ln824">            else</a>
<a name="ln825">            {</a>
<a name="ln826">              grar = grha;</a>
<a name="ln827">            }</a>
<a name="ln828"> </a>
<a name="ln829">            // adaptive weights for vertical/horizontal directions</a>
<a name="ln830">            float hwt = dirwts1[indx - 1] / (dirwts1[indx - 1] + dirwts1[indx + 1]);</a>
<a name="ln831">            float vwt = dirwts0[indx - v1] / (dirwts0[indx + v1] + dirwts0[indx - v1]);</a>
<a name="ln832"> </a>
<a name="ln833">            // interpolated G via adaptive weights of cardinal evaluations</a>
<a name="ln834">            float Gintvha = vwt * gdha + (1.f - vwt) * guha;</a>
<a name="ln835">            float Ginthha = hwt * grha + (1.f - hwt) * glha;</a>
<a name="ln836"> </a>
<a name="ln837">            // interpolated colour differences</a>
<a name="ln838">            if(fcswitch)</a>
<a name="ln839">            {</a>
<a name="ln840">              vcd[indx] = cfa[indx] - (vwt * gdar + (1.f - vwt) * guar);</a>
<a name="ln841">              hcd[indx] = cfa[indx] - (hwt * grar + (1.f - hwt) * glar);</a>
<a name="ln842">              vcdalt[indx] = cfa[indx] - Gintvha;</a>
<a name="ln843">              hcdalt[indx] = cfa[indx] - Ginthha;</a>
<a name="ln844">            }</a>
<a name="ln845">            else</a>
<a name="ln846">            {</a>
<a name="ln847">              // interpolated colour differences</a>
<a name="ln848">              vcd[indx] = (vwt * gdar + (1.f - vwt) * guar) - cfa[indx];</a>
<a name="ln849">              hcd[indx] = (hwt * grar + (1.f - hwt) * glar) - cfa[indx];</a>
<a name="ln850">              vcdalt[indx] = Gintvha - cfa[indx];</a>
<a name="ln851">              hcdalt[indx] = Ginthha - cfa[indx];</a>
<a name="ln852">            }</a>
<a name="ln853"> </a>
<a name="ln854">            fcswitch = !fcswitch;</a>
<a name="ln855"> </a>
<a name="ln856">            if(cfa[indx] &gt; clip_pt8 || Gintvha &gt; clip_pt8 || Ginthha &gt; clip_pt8)</a>
<a name="ln857">            {</a>
<a name="ln858">              // use HA if highlights are (nearly) clipped</a>
<a name="ln859">              guar = guha;</a>
<a name="ln860">              gdar = gdha;</a>
<a name="ln861">              glar = glha;</a>
<a name="ln862">              grar = grha;</a>
<a name="ln863">              vcd[indx] = vcdalt[indx];</a>
<a name="ln864">              hcd[indx] = hcdalt[indx];</a>
<a name="ln865">            }</a>
<a name="ln866"> </a>
<a name="ln867">            // differences of interpolations in opposite directions</a>
<a name="ln868">            dgintv[indx] = MIN(SQR(guha - gdha), SQR(guar - gdar));</a>
<a name="ln869">            dginth[indx] = MIN(SQR(glha - grha), SQR(glar - grar));</a>
<a name="ln870">          }</a>
<a name="ln871">        }</a>
<a name="ln872"> </a>
<a name="ln873">#endif</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">#ifdef __SSE2__</a>
<a name="ln878">        vfloat clip_ptv = F2V(clip_pt);</a>
<a name="ln879">        vfloat sgn3v;</a>
<a name="ln880"> </a>
<a name="ln881">        if(!(FC(4, 4, filters) &amp; 1))</a>
<a name="ln882">        {</a>
<a name="ln883">          sgnv = _mm_set_ps(1.f, -1.f, 1.f, -1.f);</a>
<a name="ln884">        }</a>
<a name="ln885">        else</a>
<a name="ln886">        {</a>
<a name="ln887">          sgnv = _mm_set_ps(-1.f, 1.f, -1.f, 1.f);</a>
<a name="ln888">        }</a>
<a name="ln889"> </a>
<a name="ln890">        sgn3v = sgnv + sgnv + sgnv;</a>
<a name="ln891"> </a>
<a name="ln892">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln893">        {</a>
<a name="ln894">          vfloat nsgnv = sgnv;</a>
<a name="ln895">          sgnv = -sgnv;</a>
<a name="ln896">          sgn3v = -sgn3v;</a>
<a name="ln897"> </a>
<a name="ln898">          for(int indx = rr * ts + 4; indx &lt; rr * ts + cc1 - 4; indx += 4)</a>
<a name="ln899">          {</a>
<a name="ln900">            vfloat hcdv = LVF(hcd[indx]);</a>
<a name="ln901">            vfloat hcdvarv = SQRV(LVFU(hcd[indx - 2]) - hcdv)</a>
<a name="ln902">                             + SQRV(LVFU(hcd[indx - 2]) - LVFU(hcd[indx + 2]))</a>
<a name="ln903">                             + SQRV(hcdv - LVFU(hcd[indx + 2]));</a>
<a name="ln904">            vfloat hcdaltv = LVF(hcdalt[indx]);</a>
<a name="ln905">            vfloat hcdaltvarv = SQRV(LVFU(hcdalt[indx - 2]) - hcdaltv)</a>
<a name="ln906">                                + SQRV(LVFU(hcdalt[indx - 2]) - LVFU(hcdalt[indx + 2]))</a>
<a name="ln907">                                + SQRV(hcdaltv - LVFU(hcdalt[indx + 2]));</a>
<a name="ln908">            vfloat vcdv = LVF(vcd[indx]);</a>
<a name="ln909">            vfloat vcdvarv = SQRV(LVF(vcd[indx - v2]) - vcdv)</a>
<a name="ln910">                             + SQRV(LVF(vcd[indx - v2]) - LVF(vcd[indx + v2]))</a>
<a name="ln911">                             + SQRV(vcdv - LVF(vcd[indx + v2]));</a>
<a name="ln912">            vfloat vcdaltv = LVF(vcdalt[indx]);</a>
<a name="ln913">            vfloat vcdaltvarv = SQRV(LVF(vcdalt[indx - v2]) - vcdaltv)</a>
<a name="ln914">                                + SQRV(LVF(vcdalt[indx - v2]) - LVF(vcdalt[indx + v2]))</a>
<a name="ln915">                                + SQRV(vcdaltv - LVF(vcdalt[indx + v2]));</a>
<a name="ln916"> </a>
<a name="ln917">            // choose the smallest variance; this yields a smoother interpolation</a>
<a name="ln918">            hcdv = vself(vmaskf_lt(hcdaltvarv, hcdvarv), hcdaltv, hcdv);</a>
<a name="ln919">            vcdv = vself(vmaskf_lt(vcdaltvarv, vcdvarv), vcdaltv, vcdv);</a>
<a name="ln920"> </a>
<a name="ln921">            // bound the interpolation in regions of high saturation</a>
<a name="ln922">            // vertical and horizontal G interpolations</a>
<a name="ln923">            vfloat Ginthv = sgnv * hcdv + LVF(cfa[indx]);</a>
<a name="ln924">            vfloat temp2v = sgn3v * hcdv;</a>
<a name="ln925">            vfloat hwtv = onev + temp2v / (epsv + Ginthv + LVF(cfa[indx]));</a>
<a name="ln926">            vmask hcdmask = vmaskf_gt(nsgnv * hcdv, ZEROV);</a>
<a name="ln927">            vfloat hcdoldv = hcdv;</a>
<a name="ln928">            vfloat tempv = nsgnv * (LVF(cfa[indx]) - ULIMV(Ginthv, LVFU(cfa[indx - 1]), LVFU(cfa[indx + 1])));</a>
<a name="ln929">            hcdv = vself(vmaskf_lt(temp2v, -(LVF(cfa[indx]) + Ginthv)), tempv, vintpf(hwtv, hcdv, tempv));</a>
<a name="ln930">            hcdv = vself(hcdmask, hcdv, hcdoldv);</a>
<a name="ln931">            hcdv = vself(vmaskf_gt(Ginthv, clip_ptv), tempv, hcdv);</a>
<a name="ln932">            STVF(hcd[indx], hcdv);</a>
<a name="ln933"> </a>
<a name="ln934">            vfloat Gintvv = sgnv * vcdv + LVF(cfa[indx]);</a>
<a name="ln935">            temp2v = sgn3v * vcdv;</a>
<a name="ln936">            vfloat vwtv = onev + temp2v / (epsv + Gintvv + LVF(cfa[indx]));</a>
<a name="ln937">            vmask vcdmask = vmaskf_gt(nsgnv * vcdv, ZEROV);</a>
<a name="ln938">            vfloat vcdoldv = vcdv;</a>
<a name="ln939">            tempv = nsgnv * (LVF(cfa[indx]) - ULIMV(Gintvv, LVF(cfa[indx - v1]), LVF(cfa[indx + v1])));</a>
<a name="ln940">            vcdv = vself(vmaskf_lt(temp2v, -(LVF(cfa[indx]) + Gintvv)), tempv, vintpf(vwtv, vcdv, tempv));</a>
<a name="ln941">            vcdv = vself(vcdmask, vcdv, vcdoldv);</a>
<a name="ln942">            vcdv = vself(vmaskf_gt(Gintvv, clip_ptv), tempv, vcdv);</a>
<a name="ln943">            STVF(vcd[indx], vcdv);</a>
<a name="ln944">            STVFU(cddiffsq[indx], SQRV(vcdv - hcdv));</a>
<a name="ln945">          }</a>
<a name="ln946">        }</a>
<a name="ln947"> </a>
<a name="ln948">#else</a>
<a name="ln949"> </a>
<a name="ln950">        for(int rr = 4; rr &lt; rr1 - 4; rr++)</a>
<a name="ln951">        {</a>
<a name="ln952">          for(int cc = 4, indx = rr * ts + cc, c = FC(rr, cc, filters) &amp; 1; cc &lt; cc1 - 4; cc++, indx++)</a>
<a name="ln953">          {</a>
<a name="ln954">            float hcdvar = 3.f * (SQR(hcd[indx - 2]) + SQR(hcd[indx]) + SQR(hcd[indx + 2]))</a>
<a name="ln955">                           - SQR(hcd[indx - 2] + hcd[indx] + hcd[indx + 2]);</a>
<a name="ln956">            float hcdaltvar = 3.f * (SQR(hcdalt[indx - 2]) + SQR(hcdalt[indx]) + SQR(hcdalt[indx + 2]))</a>
<a name="ln957">                              - SQR(hcdalt[indx - 2] + hcdalt[indx] + hcdalt[indx + 2]);</a>
<a name="ln958">            float vcdvar = 3.f * (SQR(vcd[indx - v2]) + SQR(vcd[indx]) + SQR(vcd[indx + v2]))</a>
<a name="ln959">                           - SQR(vcd[indx - v2] + vcd[indx] + vcd[indx + v2]);</a>
<a name="ln960">            float vcdaltvar = 3.f * (SQR(vcdalt[indx - v2]) + SQR(vcdalt[indx]) + SQR(vcdalt[indx + v2]))</a>
<a name="ln961">                              - SQR(vcdalt[indx - v2] + vcdalt[indx] + vcdalt[indx + v2]);</a>
<a name="ln962"> </a>
<a name="ln963">            // choose the smallest variance; this yields a smoother interpolation</a>
<a name="ln964">            if(hcdaltvar &lt; hcdvar)</a>
<a name="ln965">            {</a>
<a name="ln966">              hcd[indx] = hcdalt[indx];</a>
<a name="ln967">            }</a>
<a name="ln968"> </a>
<a name="ln969">            if(vcdaltvar &lt; vcdvar)</a>
<a name="ln970">            {</a>
<a name="ln971">              vcd[indx] = vcdalt[indx];</a>
<a name="ln972">            }</a>
<a name="ln973"> </a>
<a name="ln974">            // bound the interpolation in regions of high saturation</a>
<a name="ln975">            // vertical and horizontal G interpolations</a>
<a name="ln976">            float Gintv, Ginth;</a>
<a name="ln977"> </a>
<a name="ln978">            if(c)</a>
<a name="ln979">            {                                 // G site</a>
<a name="ln980">              Ginth = -hcd[indx] + cfa[indx]; // R or B</a>
<a name="ln981">              Gintv = -vcd[indx] + cfa[indx]; // B or R</a>
<a name="ln982"> </a>
<a name="ln983">              if(hcd[indx] &gt; 0)</a>
<a name="ln984">              {</a>
<a name="ln985">                if(3.f * hcd[indx] &gt; (Ginth + cfa[indx]))</a>
<a name="ln986">                {</a>
<a name="ln987">                  hcd[indx] = -ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) + cfa[indx];</a>
<a name="ln988">                }</a>
<a name="ln989">                else</a>
<a name="ln990">                {</a>
<a name="ln991">                  float hwt = 1.f - 3.f * hcd[indx] / (eps + Ginth + cfa[indx]);</a>
<a name="ln992">                  hcd[indx] = hwt * hcd[indx]</a>
<a name="ln993">                              + (1.f - hwt) * (-ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) + cfa[indx]);</a>
<a name="ln994">                }</a>
<a name="ln995">              }</a>
<a name="ln996"> </a>
<a name="ln997">              if(vcd[indx] &gt; 0)</a>
<a name="ln998">              {</a>
<a name="ln999">                if(3.f * vcd[indx] &gt; (Gintv + cfa[indx]))</a>
<a name="ln1000">                {</a>
<a name="ln1001">                  vcd[indx] = -ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) + cfa[indx];</a>
<a name="ln1002">                }</a>
<a name="ln1003">                else</a>
<a name="ln1004">                {</a>
<a name="ln1005">                  float vwt = 1.f - 3.f * vcd[indx] / (eps + Gintv + cfa[indx]);</a>
<a name="ln1006">                  vcd[indx] = vwt * vcd[indx]</a>
<a name="ln1007">                              + (1.f - vwt) * (-ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) + cfa[indx]);</a>
<a name="ln1008">                }</a>
<a name="ln1009">              }</a>
<a name="ln1010"> </a>
<a name="ln1011">              if(Ginth &gt; clip_pt)</a>
<a name="ln1012">              {</a>
<a name="ln1013">                hcd[indx] = -ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) + cfa[indx];</a>
<a name="ln1014">              }</a>
<a name="ln1015"> </a>
<a name="ln1016">              if(Gintv &gt; clip_pt)</a>
<a name="ln1017">              {</a>
<a name="ln1018">                vcd[indx] = -ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) + cfa[indx];</a>
<a name="ln1019">              }</a>
<a name="ln1020">            }</a>
<a name="ln1021">            else</a>
<a name="ln1022">            { // R or B site</a>
<a name="ln1023"> </a>
<a name="ln1024">              Ginth = hcd[indx] + cfa[indx]; // interpolated G</a>
<a name="ln1025">              Gintv = vcd[indx] + cfa[indx];</a>
<a name="ln1026"> </a>
<a name="ln1027">              if(hcd[indx] &lt; 0)</a>
<a name="ln1028">              {</a>
<a name="ln1029">                if(3.f * hcd[indx] &lt; -(Ginth + cfa[indx]))</a>
<a name="ln1030">                {</a>
<a name="ln1031">                  hcd[indx] = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) - cfa[indx];</a>
<a name="ln1032">                }</a>
<a name="ln1033">                else</a>
<a name="ln1034">                {</a>
<a name="ln1035">                  float hwt = 1.f + 3.f * hcd[indx] / (eps + Ginth + cfa[indx]);</a>
<a name="ln1036">                  hcd[indx] = hwt * hcd[indx]</a>
<a name="ln1037">                              + (1.f - hwt) * (ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) - cfa[indx]);</a>
<a name="ln1038">                }</a>
<a name="ln1039">              }</a>
<a name="ln1040"> </a>
<a name="ln1041">              if(vcd[indx] &lt; 0)</a>
<a name="ln1042">              {</a>
<a name="ln1043">                if(3.f * vcd[indx] &lt; -(Gintv + cfa[indx]))</a>
<a name="ln1044">                {</a>
<a name="ln1045">                  vcd[indx] = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) - cfa[indx];</a>
<a name="ln1046">                }</a>
<a name="ln1047">                else</a>
<a name="ln1048">                {</a>
<a name="ln1049">                  float vwt = 1.f + 3.f * vcd[indx] / (eps + Gintv + cfa[indx]);</a>
<a name="ln1050">                  vcd[indx] = vwt * vcd[indx]</a>
<a name="ln1051">                              + (1.f - vwt) * (ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) - cfa[indx]);</a>
<a name="ln1052">                }</a>
<a name="ln1053">              }</a>
<a name="ln1054"> </a>
<a name="ln1055">              if(Ginth &gt; clip_pt)</a>
<a name="ln1056">              {</a>
<a name="ln1057">                hcd[indx] = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]) - cfa[indx];</a>
<a name="ln1058">              }</a>
<a name="ln1059"> </a>
<a name="ln1060">              if(Gintv &gt; clip_pt)</a>
<a name="ln1061">              {</a>
<a name="ln1062">                vcd[indx] = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]) - cfa[indx];</a>
<a name="ln1063">              }</a>
<a name="ln1064"> </a>
<a name="ln1065">              cddiffsq[indx] = SQR(vcd[indx] - hcd[indx]);</a>
<a name="ln1066">            }</a>
<a name="ln1067"> </a>
<a name="ln1068">            c = !c;</a>
<a name="ln1069">          }</a>
<a name="ln1070">        }</a>
<a name="ln1071"> </a>
<a name="ln1072">#endif</a>
<a name="ln1073"> </a>
<a name="ln1074"> </a>
<a name="ln1075"> </a>
<a name="ln1076">#ifdef __SSE2__</a>
<a name="ln1077">        vfloat epssqv = F2V(epssq);</a>
<a name="ln1078"> </a>
<a name="ln1079">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1080">        {</a>
<a name="ln1081">          for(int indx = rr * ts + 6 + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + cc1 - 6; indx += 8)</a>
<a name="ln1082">          {</a>
<a name="ln1083">            // compute colour difference variances in cardinal directions</a>
<a name="ln1084">            vfloat tempv = LC2VFU(vcd[indx]);</a>
<a name="ln1085">            vfloat uavev = tempv + LC2VFU(vcd[indx - v1]) + LC2VFU(vcd[indx - v2]) + LC2VFU(vcd[indx - v3]);</a>
<a name="ln1086">            vfloat davev = tempv + LC2VFU(vcd[indx + v1]) + LC2VFU(vcd[indx + v2]) + LC2VFU(vcd[indx + v3]);</a>
<a name="ln1087">            vfloat Dgrbvvaruv = SQRV(tempv - uavev) + SQRV(LC2VFU(vcd[indx - v1]) - uavev)</a>
<a name="ln1088">                                + SQRV(LC2VFU(vcd[indx - v2]) - uavev) + SQRV(LC2VFU(vcd[indx - v3]) - uavev);</a>
<a name="ln1089">            vfloat Dgrbvvardv = SQRV(tempv - davev) + SQRV(LC2VFU(vcd[indx + v1]) - davev)</a>
<a name="ln1090">                                + SQRV(LC2VFU(vcd[indx + v2]) - davev) + SQRV(LC2VFU(vcd[indx + v3]) - davev);</a>
<a name="ln1091"> </a>
<a name="ln1092">            vfloat hwtv = vadivapb(LC2VFU(dirwts1[indx - 1]), LC2VFU(dirwts1[indx + 1]));</a>
<a name="ln1093">            vfloat vwtv = vadivapb(LC2VFU(dirwts0[indx - v1]), LC2VFU(dirwts0[indx + v1]));</a>
<a name="ln1094"> </a>
<a name="ln1095">            tempv = LC2VFU(hcd[indx]);</a>
<a name="ln1096">            vfloat lavev = tempv + vaddc2vfu(hcd[indx - 3]) + LC2VFU(hcd[indx - 1]);</a>
<a name="ln1097">            vfloat ravev = tempv + vaddc2vfu(hcd[indx + 1]) + LC2VFU(hcd[indx + 3]);</a>
<a name="ln1098"> </a>
<a name="ln1099">            vfloat Dgrbhvarlv = SQRV(tempv - lavev) + SQRV(LC2VFU(hcd[indx - 1]) - lavev)</a>
<a name="ln1100">                                + SQRV(LC2VFU(hcd[indx - 2]) - lavev) + SQRV(LC2VFU(hcd[indx - 3]) - lavev);</a>
<a name="ln1101">            vfloat Dgrbhvarrv = SQRV(tempv - ravev) + SQRV(LC2VFU(hcd[indx + 1]) - ravev)</a>
<a name="ln1102">                                + SQRV(LC2VFU(hcd[indx + 2]) - ravev) + SQRV(LC2VFU(hcd[indx + 3]) - ravev);</a>
<a name="ln1103"> </a>
<a name="ln1104"> </a>
<a name="ln1105">            vfloat vcdvarv = epssqv + vintpf(vwtv, Dgrbvvardv, Dgrbvvaruv);</a>
<a name="ln1106">            vfloat hcdvarv = epssqv + vintpf(hwtv, Dgrbhvarrv, Dgrbhvarlv);</a>
<a name="ln1107"> </a>
<a name="ln1108">            // compute fluctuations in up/down and left/right interpolations of colours</a>
<a name="ln1109">            Dgrbvvaruv = LC2VFU(dgintv[indx - v1]) + LC2VFU(dgintv[indx - v2]);</a>
<a name="ln1110">            Dgrbvvardv = LC2VFU(dgintv[indx + v1]) + LC2VFU(dgintv[indx + v2]);</a>
<a name="ln1111"> </a>
<a name="ln1112">            Dgrbhvarlv = vaddc2vfu(dginth[indx - 2]);</a>
<a name="ln1113">            Dgrbhvarrv = vaddc2vfu(dginth[indx + 1]);</a>
<a name="ln1114"> </a>
<a name="ln1115">            vfloat vcdvar1v = epssqv + LC2VFU(dgintv[indx]) + vintpf(vwtv, Dgrbvvardv, Dgrbvvaruv);</a>
<a name="ln1116">            vfloat hcdvar1v = epssqv + LC2VFU(dginth[indx]) + vintpf(hwtv, Dgrbhvarrv, Dgrbhvarlv);</a>
<a name="ln1117"> </a>
<a name="ln1118">            // determine adaptive weights for G interpolation</a>
<a name="ln1119">            vfloat varwtv = hcdvarv / (vcdvarv + hcdvarv);</a>
<a name="ln1120">            vfloat diffwtv = hcdvar1v / (vcdvar1v + hcdvar1v);</a>
<a name="ln1121"> </a>
<a name="ln1122">            // if both agree on interpolation direction, choose the one with strongest directional</a>
<a name="ln1123">            // discrimination;</a>
<a name="ln1124">            // otherwise, choose the u/d and l/r difference fluctuation weights</a>
<a name="ln1125">            vmask decmask = vandm(vmaskf_gt((zd5v - varwtv) * (zd5v - diffwtv), ZEROV),</a>
<a name="ln1126">                                  vmaskf_lt(vabsf(zd5v - diffwtv), vabsf(zd5v - varwtv)));</a>
<a name="ln1127">            STVFU(hvwt[indx &gt;&gt; 1], vself(decmask, varwtv, diffwtv));</a>
<a name="ln1128">          }</a>
<a name="ln1129">        }</a>
<a name="ln1130"> </a>
<a name="ln1131">#else</a>
<a name="ln1132"> </a>
<a name="ln1133">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1134">        {</a>
<a name="ln1135">          for(int cc = 6 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1136">          {</a>
<a name="ln1137"> </a>
<a name="ln1138">            // compute colour difference variances in cardinal directions</a>
<a name="ln1139"> </a>
<a name="ln1140">            float uave = vcd[indx] + vcd[indx - v1] + vcd[indx - v2] + vcd[indx - v3];</a>
<a name="ln1141">            float dave = vcd[indx] + vcd[indx + v1] + vcd[indx + v2] + vcd[indx + v3];</a>
<a name="ln1142">            float lave = hcd[indx] + hcd[indx - 1] + hcd[indx - 2] + hcd[indx - 3];</a>
<a name="ln1143">            float rave = hcd[indx] + hcd[indx + 1] + hcd[indx + 2] + hcd[indx + 3];</a>
<a name="ln1144"> </a>
<a name="ln1145">            // colour difference (G-R or G-B) variance in up/down/left/right directions</a>
<a name="ln1146">            float Dgrbvvaru = SQR(vcd[indx] - uave) + SQR(vcd[indx - v1] - uave) + SQR(vcd[indx - v2] - uave)</a>
<a name="ln1147">                              + SQR(vcd[indx - v3] - uave);</a>
<a name="ln1148">            float Dgrbvvard = SQR(vcd[indx] - dave) + SQR(vcd[indx + v1] - dave) + SQR(vcd[indx + v2] - dave)</a>
<a name="ln1149">                              + SQR(vcd[indx + v3] - dave);</a>
<a name="ln1150">            float Dgrbhvarl = SQR(hcd[indx] - lave) + SQR(hcd[indx - 1] - lave) + SQR(hcd[indx - 2] - lave)</a>
<a name="ln1151">                              + SQR(hcd[indx - 3] - lave);</a>
<a name="ln1152">            float Dgrbhvarr = SQR(hcd[indx] - rave) + SQR(hcd[indx + 1] - rave) + SQR(hcd[indx + 2] - rave)</a>
<a name="ln1153">                              + SQR(hcd[indx + 3] - rave);</a>
<a name="ln1154"> </a>
<a name="ln1155">            float hwt = dirwts1[indx - 1] / (dirwts1[indx - 1] + dirwts1[indx + 1]);</a>
<a name="ln1156">            float vwt = dirwts0[indx - v1] / (dirwts0[indx + v1] + dirwts0[indx - v1]);</a>
<a name="ln1157"> </a>
<a name="ln1158">            float vcdvar = epssq + vwt * Dgrbvvard + (1.f - vwt) * Dgrbvvaru;</a>
<a name="ln1159">            float hcdvar = epssq + hwt * Dgrbhvarr + (1.f - hwt) * Dgrbhvarl;</a>
<a name="ln1160"> </a>
<a name="ln1161">            // compute fluctuations in up/down and left/right interpolations of colours</a>
<a name="ln1162">            Dgrbvvaru = (dgintv[indx]) + (dgintv[indx - v1]) + (dgintv[indx - v2]);</a>
<a name="ln1163">            Dgrbvvard = (dgintv[indx]) + (dgintv[indx + v1]) + (dgintv[indx + v2]);</a>
<a name="ln1164">            Dgrbhvarl = (dginth[indx]) + (dginth[indx - 1]) + (dginth[indx - 2]);</a>
<a name="ln1165">            Dgrbhvarr = (dginth[indx]) + (dginth[indx + 1]) + (dginth[indx + 2]);</a>
<a name="ln1166"> </a>
<a name="ln1167">            float vcdvar1 = epssq + vwt * Dgrbvvard + (1.f - vwt) * Dgrbvvaru;</a>
<a name="ln1168">            float hcdvar1 = epssq + hwt * Dgrbhvarr + (1.f - hwt) * Dgrbhvarl;</a>
<a name="ln1169"> </a>
<a name="ln1170">            // determine adaptive weights for G interpolation</a>
<a name="ln1171">            float varwt = hcdvar / (vcdvar + hcdvar);</a>
<a name="ln1172">            float diffwt = hcdvar1 / (vcdvar1 + hcdvar1);</a>
<a name="ln1173"> </a>
<a name="ln1174">            // if both agree on interpolation direction, choose the one with strongest directional</a>
<a name="ln1175">            // discrimination;</a>
<a name="ln1176">            // otherwise, choose the u/d and l/r difference fluctuation weights</a>
<a name="ln1177">            if((0.5 - varwt) * (0.5 - diffwt) &gt; 0 &amp;&amp; fabsf(0.5f - diffwt) &lt; fabsf(0.5f - varwt))</a>
<a name="ln1178">            {</a>
<a name="ln1179">              hvwt[indx &gt;&gt; 1] = varwt;</a>
<a name="ln1180">            }</a>
<a name="ln1181">            else</a>
<a name="ln1182">            {</a>
<a name="ln1183">              hvwt[indx &gt;&gt; 1] = diffwt;</a>
<a name="ln1184">            }</a>
<a name="ln1185">          }</a>
<a name="ln1186">        }</a>
<a name="ln1187"> </a>
<a name="ln1188">#endif</a>
<a name="ln1189"> </a>
<a name="ln1190">#ifdef __SSE2__</a>
<a name="ln1191">        vfloat gaussg0 = F2V(gaussgrad[0]);</a>
<a name="ln1192">        vfloat gaussg1 = F2V(gaussgrad[1]);</a>
<a name="ln1193">        vfloat gaussg2 = F2V(gaussgrad[2]);</a>
<a name="ln1194">        vfloat gaussg3 = F2V(gaussgrad[3]);</a>
<a name="ln1195">        vfloat gaussg4 = F2V(gaussgrad[4]);</a>
<a name="ln1196">        vfloat gaussg5 = F2V(gaussgrad[5]);</a>
<a name="ln1197">        vfloat gausso0 = F2V(gaussodd[0]);</a>
<a name="ln1198">        vfloat gausso1 = F2V(gaussodd[1]);</a>
<a name="ln1199">        vfloat gausso2 = F2V(gaussodd[2]);</a>
<a name="ln1200">        vfloat gausso3 = F2V(gaussodd[3]);</a>
<a name="ln1201"> </a>
<a name="ln1202">#endif</a>
<a name="ln1203"> </a>
<a name="ln1204">        // precompute nyquist</a>
<a name="ln1205">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1206">        {</a>
<a name="ln1207">          int cc = 6 + (FC(rr, 2, filters) &amp; 1);</a>
<a name="ln1208">          int indx = rr * ts + cc;</a>
<a name="ln1209"> </a>
<a name="ln1210">#ifdef __SSE2__</a>
<a name="ln1211"> </a>
<a name="ln1212">          for(; cc &lt; cc1 - 7; cc += 8, indx += 8)</a>
<a name="ln1213">          {</a>
<a name="ln1214">            vfloat valv</a>
<a name="ln1215">                = (gausso0 * LC2VFU(cddiffsq[indx])</a>
<a name="ln1216">                   + gausso1 * (LC2VFU(cddiffsq[(indx - m1)]) + LC2VFU(cddiffsq[(indx + p1)])</a>
<a name="ln1217">                                + LC2VFU(cddiffsq[(indx - p1)]) + LC2VFU(cddiffsq[(indx + m1)]))</a>
<a name="ln1218">                   + gausso2 * (LC2VFU(cddiffsq[(indx - v2)]) + LC2VFU(cddiffsq[(indx - 2)])</a>
<a name="ln1219">                                + LC2VFU(cddiffsq[(indx + 2)]) + LC2VFU(cddiffsq[(indx + v2)]))</a>
<a name="ln1220">                   + gausso3 * (LC2VFU(cddiffsq[(indx - m2)]) + LC2VFU(cddiffsq[(indx + p2)])</a>
<a name="ln1221">                                + LC2VFU(cddiffsq[(indx - p2)]) + LC2VFU(cddiffsq[(indx + m2)])))</a>
<a name="ln1222">                  - (gaussg0 * LC2VFU(delhvsqsum[indx])</a>
<a name="ln1223">                     + gaussg1 * (LC2VFU(delhvsqsum[indx - v1]) + LC2VFU(delhvsqsum[indx - 1])</a>
<a name="ln1224">                                  + LC2VFU(delhvsqsum[indx + 1]) + LC2VFU(delhvsqsum[indx + v1]))</a>
<a name="ln1225">                     + gaussg2 * (LC2VFU(delhvsqsum[indx - m1]) + LC2VFU(delhvsqsum[indx + p1])</a>
<a name="ln1226">                                  + LC2VFU(delhvsqsum[indx - p1]) + LC2VFU(delhvsqsum[indx + m1]))</a>
<a name="ln1227">                     + gaussg3 * (LC2VFU(delhvsqsum[indx - v2]) + LC2VFU(delhvsqsum[indx - 2])</a>
<a name="ln1228">                                  + LC2VFU(delhvsqsum[indx + 2]) + LC2VFU(delhvsqsum[indx + v2]))</a>
<a name="ln1229">                     + gaussg4 * (LC2VFU(delhvsqsum[indx - v2 - 1]) + LC2VFU(delhvsqsum[indx - v2 + 1])</a>
<a name="ln1230">                                  + LC2VFU(delhvsqsum[indx - ts - 2]) + LC2VFU(delhvsqsum[indx - ts + 2])</a>
<a name="ln1231">                                  + LC2VFU(delhvsqsum[indx + ts - 2]) + LC2VFU(delhvsqsum[indx + ts + 2])</a>
<a name="ln1232">                                  + LC2VFU(delhvsqsum[indx + v2 - 1]) + LC2VFU(delhvsqsum[indx + v2 + 1]))</a>
<a name="ln1233">                     + gaussg5 * (LC2VFU(delhvsqsum[indx - m2]) + LC2VFU(delhvsqsum[indx + p2])</a>
<a name="ln1234">                                  + LC2VFU(delhvsqsum[indx - p2]) + LC2VFU(delhvsqsum[indx + m2])));</a>
<a name="ln1235">            STVFU(nyqutest[indx &gt;&gt; 1], valv);</a>
<a name="ln1236">          }</a>
<a name="ln1237"> </a>
<a name="ln1238">#endif</a>
<a name="ln1239"> </a>
<a name="ln1240">          for(; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1241">          {</a>
<a name="ln1242">            nyqutest[indx &gt;&gt; 1]</a>
<a name="ln1243">                = (gaussodd[0] * cddiffsq[indx]</a>
<a name="ln1244">                   + gaussodd[1] * (cddiffsq[(indx - m1)] + cddiffsq[(indx + p1)] + cddiffsq[(indx - p1)]</a>
<a name="ln1245">                                    + cddiffsq[(indx + m1)])</a>
<a name="ln1246">                   + gaussodd[2] * (cddiffsq[(indx - v2)] + cddiffsq[(indx - 2)] + cddiffsq[(indx + 2)]</a>
<a name="ln1247">                                    + cddiffsq[(indx + v2)])</a>
<a name="ln1248">                   + gaussodd[3] * (cddiffsq[(indx - m2)] + cddiffsq[(indx + p2)] + cddiffsq[(indx - p2)]</a>
<a name="ln1249">                                    + cddiffsq[(indx + m2)]))</a>
<a name="ln1250">                  - (gaussgrad[0] * delhvsqsum[indx]</a>
<a name="ln1251">                     + gaussgrad[1] * (delhvsqsum[indx - v1] + delhvsqsum[indx + 1] + delhvsqsum[indx - 1]</a>
<a name="ln1252">                                       + delhvsqsum[indx + v1])</a>
<a name="ln1253">                     + gaussgrad[2] * (delhvsqsum[indx - m1] + delhvsqsum[indx + p1] + delhvsqsum[indx - p1]</a>
<a name="ln1254">                                       + delhvsqsum[indx + m1])</a>
<a name="ln1255">                     + gaussgrad[3] * (delhvsqsum[indx - v2] + delhvsqsum[indx - 2] + delhvsqsum[indx + 2]</a>
<a name="ln1256">                                       + delhvsqsum[indx + v2])</a>
<a name="ln1257">                     + gaussgrad[4] * (delhvsqsum[indx - v2 - 1] + delhvsqsum[indx - v2 + 1]</a>
<a name="ln1258">                                       + delhvsqsum[indx - ts - 2] + delhvsqsum[indx - ts + 2]</a>
<a name="ln1259">                                       + delhvsqsum[indx + ts - 2] + delhvsqsum[indx + ts + 2]</a>
<a name="ln1260">                                       + delhvsqsum[indx + v2 - 1] + delhvsqsum[indx + v2 + 1])</a>
<a name="ln1261">                     + gaussgrad[5] * (delhvsqsum[indx - m2] + delhvsqsum[indx + p2] + delhvsqsum[indx - p2]</a>
<a name="ln1262">                                       + delhvsqsum[indx + m2]));</a>
<a name="ln1263">          }</a>
<a name="ln1264">        }</a>
<a name="ln1265"> </a>
<a name="ln1266">        // Nyquist test</a>
<a name="ln1267">        int nystartrow = 0;</a>
<a name="ln1268">        int nyendrow = 0;</a>
<a name="ln1269">        int nystartcol = ts + 1;</a>
<a name="ln1270">        int nyendcol = 0;</a>
<a name="ln1271"> </a>
<a name="ln1272">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1273">        {</a>
<a name="ln1274">          for(int cc = 6 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1275">          {</a>
<a name="ln1276"> </a>
<a name="ln1277">            // nyquist texture test: ask if difference of vcd compared to hcd is larger or smaller than RGGB</a>
<a name="ln1278">            // gradients</a>
<a name="ln1279">            if(nyqutest[indx &gt;&gt; 1] &gt; 0.f)</a>
<a name="ln1280">            {</a>
<a name="ln1281">              nyquist[indx &gt;&gt; 1] = 1; // nyquist=1 for nyquist region</a>
<a name="ln1282">              nystartrow = nystartrow ? nystartrow : rr;</a>
<a name="ln1283">              nyendrow = rr;</a>
<a name="ln1284">              nystartcol = nystartcol &gt; cc ? cc : nystartcol;</a>
<a name="ln1285">              nyendcol = nyendcol &lt; cc ? cc : nyendcol;</a>
<a name="ln1286">            }</a>
<a name="ln1287">          }</a>
<a name="ln1288">        }</a>
<a name="ln1289"> </a>
<a name="ln1290"> </a>
<a name="ln1291">        bool doNyquist = nystartrow != nyendrow &amp;&amp; nystartcol != nyendcol;</a>
<a name="ln1292"> </a>
<a name="ln1293">        if(doNyquist)</a>
<a name="ln1294">        {</a>
<a name="ln1295">          nyendrow++; // because of &lt; condition</a>
<a name="ln1296">          nyendcol++; // because of &lt; condition</a>
<a name="ln1297">          nystartcol -= (nystartcol &amp; 1);</a>
<a name="ln1298">          nystartrow = std::max(8, nystartrow);</a>
<a name="ln1299">          nyendrow = std::min(rr1 - 8, nyendrow);</a>
<a name="ln1300">          nystartcol = std::max(8, nystartcol);</a>
<a name="ln1301">          nyendcol = std::min(cc1 - 8, nyendcol);</a>
<a name="ln1302">          memset(&amp;nyquist2[4 * tsh], 0, sizeof(char) * (ts - 8) * tsh);</a>
<a name="ln1303"> </a>
<a name="ln1304">#ifdef __SSE2__</a>
<a name="ln1305">          vint fourvb = _mm_set1_epi8(4);</a>
<a name="ln1306">          vint onevb = _mm_set1_epi8(1);</a>
<a name="ln1307"> </a>
<a name="ln1308">#endif</a>
<a name="ln1309"> </a>
<a name="ln1310">          for(int rr = nystartrow; rr &lt; nyendrow; rr++)</a>
<a name="ln1311">          {</a>
<a name="ln1312">#ifdef __SSE2__</a>
<a name="ln1313"> </a>
<a name="ln1314">            for(int indx = rr * ts; indx &lt; rr * ts + cc1; indx += 32)</a>
<a name="ln1315">            {</a>
<a name="ln1316">              vint nyquisttemp1v = _mm_adds_epi8(_mm_load_si128((vint *)&amp;nyquist[(indx - v2) &gt;&gt; 1]),</a>
<a name="ln1317">                                                 _mm_loadu_si128((vint *)&amp;nyquist[(indx - m1) &gt;&gt; 1]));</a>
<a name="ln1318">              vint nyquisttemp2v = _mm_adds_epi8(_mm_loadu_si128((vint *)&amp;nyquist[(indx + p1) &gt;&gt; 1]),</a>
<a name="ln1319">                                                 _mm_loadu_si128((vint *)&amp;nyquist[(indx - 2) &gt;&gt; 1]));</a>
<a name="ln1320">              vint nyquisttemp3v = _mm_adds_epi8(_mm_loadu_si128((vint *)&amp;nyquist[(indx + 2) &gt;&gt; 1]),</a>
<a name="ln1321">                                                 _mm_loadu_si128((vint *)&amp;nyquist[(indx - p1) &gt;&gt; 1]));</a>
<a name="ln1322">              vint valv = _mm_load_si128((vint *)&amp;nyquist[indx &gt;&gt; 1]);</a>
<a name="ln1323">              vint nyquisttemp4v = _mm_adds_epi8(_mm_loadu_si128((vint *)&amp;nyquist[(indx + m1) &gt;&gt; 1]),</a>
<a name="ln1324">                                                 _mm_load_si128((vint *)&amp;nyquist[(indx + v2) &gt;&gt; 1]));</a>
<a name="ln1325">              nyquisttemp1v = _mm_adds_epi8(nyquisttemp1v, nyquisttemp3v);</a>
<a name="ln1326">              nyquisttemp2v = _mm_adds_epi8(nyquisttemp2v, nyquisttemp4v);</a>
<a name="ln1327">              nyquisttemp1v = _mm_adds_epi8(nyquisttemp1v, nyquisttemp2v);</a>
<a name="ln1328">              valv = vselc(_mm_cmpgt_epi8(nyquisttemp1v, fourvb), onevb, valv);</a>
<a name="ln1329">              valv = vselinotzero(_mm_cmplt_epi8(nyquisttemp1v, fourvb), valv);</a>
<a name="ln1330">              _mm_store_si128((vint *)&amp;nyquist2[indx &gt;&gt; 1], valv);</a>
<a name="ln1331">            }</a>
<a name="ln1332"> </a>
<a name="ln1333">#else</a>
<a name="ln1334"> </a>
<a name="ln1335">            for(int indx = rr * ts + nystartcol + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + nyendcol;</a>
<a name="ln1336">                indx += 2)</a>
<a name="ln1337">            {</a>
<a name="ln1338">              unsigned int nyquisttemp</a>
<a name="ln1339">                  = (nyquist[(indx - v2) &gt;&gt; 1] + nyquist[(indx - m1) &gt;&gt; 1] + nyquist[(indx + p1) &gt;&gt; 1]</a>
<a name="ln1340">                     + nyquist[(indx - 2) &gt;&gt; 1] + nyquist[(indx + 2) &gt;&gt; 1] + nyquist[(indx - p1) &gt;&gt; 1]</a>
<a name="ln1341">                     + nyquist[(indx + m1) &gt;&gt; 1] + nyquist[(indx + v2) &gt;&gt; 1]);</a>
<a name="ln1342">              // if most of your neighbours are named Nyquist, it's likely that you're one too, or not</a>
<a name="ln1343">              nyquist2[indx &gt;&gt; 1] = nyquisttemp &gt; 4 ? 1 : (nyquisttemp &lt; 4 ? 0 : nyquist[indx &gt;&gt; 1]);</a>
<a name="ln1344">            }</a>
<a name="ln1345"> </a>
<a name="ln1346">#endif</a>
<a name="ln1347">          }</a>
<a name="ln1348"> </a>
<a name="ln1349">          // end of Nyquist test</a>
<a name="ln1350"> </a>
<a name="ln1351">          // in areas of Nyquist texture, do area interpolation</a>
<a name="ln1352">          for(int rr = nystartrow; rr &lt; nyendrow; rr++)</a>
<a name="ln1353">            for(int indx = rr * ts + nystartcol + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + nyendcol;</a>
<a name="ln1354">                indx += 2)</a>
<a name="ln1355">            {</a>
<a name="ln1356"> </a>
<a name="ln1357">              if(nyquist2[indx &gt;&gt; 1])</a>
<a name="ln1358">              {</a>
<a name="ln1359">                // area interpolation</a>
<a name="ln1360"> </a>
<a name="ln1361">                float sumcfa = 0.f, sumh = 0.f, sumv = 0.f, sumsqh = 0.f, sumsqv = 0.f, areawt = 0.f;</a>
<a name="ln1362"> </a>
<a name="ln1363">                for(int i = -6; i &lt; 7; i += 2)</a>
<a name="ln1364">                {</a>
<a name="ln1365">                  int indx1 = indx + (i * ts) - 6;</a>
<a name="ln1366"> </a>
<a name="ln1367">                  for(int j = -6; j &lt; 7; j += 2, indx1 += 2)</a>
<a name="ln1368">                  {</a>
<a name="ln1369">                    if(nyquist2[indx1 &gt;&gt; 1])</a>
<a name="ln1370">                    {</a>
<a name="ln1371">                      float cfatemp = cfa[indx1];</a>
<a name="ln1372">                      sumcfa += cfatemp;</a>
<a name="ln1373">                      sumh += (cfa[indx1 - 1] + cfa[indx1 + 1]);</a>
<a name="ln1374">                      sumv += (cfa[indx1 - v1] + cfa[indx1 + v1]);</a>
<a name="ln1375">                      sumsqh += SQR(cfatemp - cfa[indx1 - 1]) + SQR(cfatemp - cfa[indx1 + 1]);</a>
<a name="ln1376">                      sumsqv += SQR(cfatemp - cfa[indx1 - v1]) + SQR(cfatemp - cfa[indx1 + v1]);</a>
<a name="ln1377">                      areawt += 1;</a>
<a name="ln1378">                    }</a>
<a name="ln1379">                  }</a>
<a name="ln1380">                }</a>
<a name="ln1381"> </a>
<a name="ln1382">                // horizontal and vertical colour differences, and adaptive weight</a>
<a name="ln1383">                sumh = sumcfa - xdiv2f(sumh);</a>
<a name="ln1384">                sumv = sumcfa - xdiv2f(sumv);</a>
<a name="ln1385">                areawt = xdiv2f(areawt);</a>
<a name="ln1386">                float hcdvar = epssq + fabsf(areawt * sumsqh - sumh * sumh);</a>
<a name="ln1387">                float vcdvar = epssq + fabsf(areawt * sumsqv - sumv * sumv);</a>
<a name="ln1388">                hvwt[indx &gt;&gt; 1] = hcdvar / (vcdvar + hcdvar);</a>
<a name="ln1389"> </a>
<a name="ln1390">                // end of area interpolation</a>
<a name="ln1391">              }</a>
<a name="ln1392">            }</a>
<a name="ln1393">        }</a>
<a name="ln1394"> </a>
<a name="ln1395"> </a>
<a name="ln1396">        // populate G at R/B sites</a>
<a name="ln1397">        for(int rr = 8; rr &lt; rr1 - 8; rr++)</a>
<a name="ln1398">          for(int indx = rr * ts + 8 + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + cc1 - 8; indx += 2)</a>
<a name="ln1399">          {</a>
<a name="ln1400"> </a>
<a name="ln1401">            // first ask if one gets more directional discrimination from nearby B/R sites</a>
<a name="ln1402">            float hvwtalt = xdivf(hvwt[(indx - m1) &gt;&gt; 1] + hvwt[(indx + p1) &gt;&gt; 1] + hvwt[(indx - p1) &gt;&gt; 1]</a>
<a name="ln1403">                                      + hvwt[(indx + m1) &gt;&gt; 1],</a>
<a name="ln1404">                                  2);</a>
<a name="ln1405"> </a>
<a name="ln1406">            hvwt[indx &gt;&gt; 1]</a>
<a name="ln1407">                = fabsf(0.5f - hvwt[indx &gt;&gt; 1]) &lt; fabsf(0.5f - hvwtalt) ? hvwtalt : hvwt[indx &gt;&gt; 1];</a>
<a name="ln1408">            // a better result was obtained from the neighbours</a>
<a name="ln1409"> </a>
<a name="ln1410">            Dgrb[0][indx &gt;&gt; 1] = intp(hvwt[indx &gt;&gt; 1], vcd[indx], hcd[indx]); // evaluate colour differences</a>
<a name="ln1411"> </a>
<a name="ln1412">            rgbgreen[indx] = cfa[indx] + Dgrb[0][indx &gt;&gt; 1]; // evaluate G (finally!)</a>
<a name="ln1413"> </a>
<a name="ln1414">            // local curvature in G (preparation for nyquist refinement step)</a>
<a name="ln1415">            Dgrb2[indx &gt;&gt; 1].h = nyquist2[indx &gt;&gt; 1]</a>
<a name="ln1416">                                     ? SQR(rgbgreen[indx] - xdiv2f(rgbgreen[indx - 1] + rgbgreen[indx + 1]))</a>
<a name="ln1417">                                     : 0.f;</a>
<a name="ln1418">            Dgrb2[indx &gt;&gt; 1].v = nyquist2[indx &gt;&gt; 1]</a>
<a name="ln1419">                                     ? SQR(rgbgreen[indx] - xdiv2f(rgbgreen[indx - v1] + rgbgreen[indx + v1]))</a>
<a name="ln1420">                                     : 0.f;</a>
<a name="ln1421">          }</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">        // end of standard interpolation</a>
<a name="ln1425"> </a>
<a name="ln1426">        // refine Nyquist areas using G curvatures</a>
<a name="ln1427">        if(doNyquist)</a>
<a name="ln1428">        {</a>
<a name="ln1429">          for(int rr = nystartrow; rr &lt; nyendrow; rr++)</a>
<a name="ln1430">            for(int indx = rr * ts + nystartcol + (FC(rr, 2, filters) &amp; 1); indx &lt; rr * ts + nyendcol;</a>
<a name="ln1431">                indx += 2)</a>
<a name="ln1432">            {</a>
<a name="ln1433"> </a>
<a name="ln1434">              if(nyquist2[indx &gt;&gt; 1])</a>
<a name="ln1435">              {</a>
<a name="ln1436">                // local averages (over Nyquist pixels only) of G curvature squared</a>
<a name="ln1437">                float gvarh</a>
<a name="ln1438">                    = epssq + (gquinc[0] * Dgrb2[indx &gt;&gt; 1].h</a>
<a name="ln1439">                               + gquinc[1] * (Dgrb2[(indx - m1) &gt;&gt; 1].h + Dgrb2[(indx + p1) &gt;&gt; 1].h</a>
<a name="ln1440">                                              + Dgrb2[(indx - p1) &gt;&gt; 1].h + Dgrb2[(indx + m1) &gt;&gt; 1].h)</a>
<a name="ln1441">                               + gquinc[2] * (Dgrb2[(indx - v2) &gt;&gt; 1].h + Dgrb2[(indx - 2) &gt;&gt; 1].h</a>
<a name="ln1442">                                              + Dgrb2[(indx + 2) &gt;&gt; 1].h + Dgrb2[(indx + v2) &gt;&gt; 1].h)</a>
<a name="ln1443">                               + gquinc[3] * (Dgrb2[(indx - m2) &gt;&gt; 1].h + Dgrb2[(indx + p2) &gt;&gt; 1].h</a>
<a name="ln1444">                                              + Dgrb2[(indx - p2) &gt;&gt; 1].h + Dgrb2[(indx + m2) &gt;&gt; 1].h));</a>
<a name="ln1445">                float gvarv</a>
<a name="ln1446">                    = epssq + (gquinc[0] * Dgrb2[indx &gt;&gt; 1].v</a>
<a name="ln1447">                               + gquinc[1] * (Dgrb2[(indx - m1) &gt;&gt; 1].v + Dgrb2[(indx + p1) &gt;&gt; 1].v</a>
<a name="ln1448">                                              + Dgrb2[(indx - p1) &gt;&gt; 1].v + Dgrb2[(indx + m1) &gt;&gt; 1].v)</a>
<a name="ln1449">                               + gquinc[2] * (Dgrb2[(indx - v2) &gt;&gt; 1].v + Dgrb2[(indx - 2) &gt;&gt; 1].v</a>
<a name="ln1450">                                              + Dgrb2[(indx + 2) &gt;&gt; 1].v + Dgrb2[(indx + v2) &gt;&gt; 1].v)</a>
<a name="ln1451">                               + gquinc[3] * (Dgrb2[(indx - m2) &gt;&gt; 1].v + Dgrb2[(indx + p2) &gt;&gt; 1].v</a>
<a name="ln1452">                                              + Dgrb2[(indx - p2) &gt;&gt; 1].v + Dgrb2[(indx + m2) &gt;&gt; 1].v));</a>
<a name="ln1453">                // use the results as weights for refined G interpolation</a>
<a name="ln1454">                Dgrb[0][indx &gt;&gt; 1] = (hcd[indx] * gvarv + vcd[indx] * gvarh) / (gvarv + gvarh);</a>
<a name="ln1455">                rgbgreen[indx] = cfa[indx] + Dgrb[0][indx &gt;&gt; 1];</a>
<a name="ln1456">              }</a>
<a name="ln1457">            }</a>
<a name="ln1458">        }</a>
<a name="ln1459"> </a>
<a name="ln1460"> </a>
<a name="ln1461">#ifdef __SSE2__</a>
<a name="ln1462"> </a>
<a name="ln1463">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1464">        {</a>
<a name="ln1465">          if((FC(rr, 2, filters) &amp; 1) == 0)</a>
<a name="ln1466">          {</a>
<a name="ln1467">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 8, indx += 8)</a>
<a name="ln1468">            {</a>
<a name="ln1469">              vfloat tempv = LC2VFU(cfa[indx + 1]);</a>
<a name="ln1470">              vfloat Dgrbsq1pv</a>
<a name="ln1471">                  = (SQRV(tempv - LC2VFU(cfa[indx + 1 - p1])) + SQRV(tempv - LC2VFU(cfa[indx + 1 + p1])));</a>
<a name="ln1472">              STVFU(delp[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + p1]) - LC2VFU(cfa[indx - p1])));</a>
<a name="ln1473">              STVFU(delm[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + m1]) - LC2VFU(cfa[indx - m1])));</a>
<a name="ln1474">              vfloat Dgrbsq1mv</a>
<a name="ln1475">                  = (SQRV(tempv - LC2VFU(cfa[indx + 1 - m1])) + SQRV(tempv - LC2VFU(cfa[indx + 1 + m1])));</a>
<a name="ln1476">              STVFU(Dgrbsq1m[indx &gt;&gt; 1], Dgrbsq1mv);</a>
<a name="ln1477">              STVFU(Dgrbsq1p[indx &gt;&gt; 1], Dgrbsq1pv);</a>
<a name="ln1478">            }</a>
<a name="ln1479">          }</a>
<a name="ln1480">          else</a>
<a name="ln1481">          {</a>
<a name="ln1482">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 8, indx += 8)</a>
<a name="ln1483">            {</a>
<a name="ln1484">              vfloat tempv = LC2VFU(cfa[indx]);</a>
<a name="ln1485">              vfloat Dgrbsq1pv</a>
<a name="ln1486">                  = (SQRV(tempv - LC2VFU(cfa[indx - p1])) + SQRV(tempv - LC2VFU(cfa[indx + p1])));</a>
<a name="ln1487">              STVFU(delp[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + 1 + p1]) - LC2VFU(cfa[indx + 1 - p1])));</a>
<a name="ln1488">              STVFU(delm[indx &gt;&gt; 1], vabsf(LC2VFU(cfa[indx + 1 + m1]) - LC2VFU(cfa[indx + 1 - m1])));</a>
<a name="ln1489">              vfloat Dgrbsq1mv</a>
<a name="ln1490">                  = (SQRV(tempv - LC2VFU(cfa[indx - m1])) + SQRV(tempv - LC2VFU(cfa[indx + m1])));</a>
<a name="ln1491">              STVFU(Dgrbsq1m[indx &gt;&gt; 1], Dgrbsq1mv);</a>
<a name="ln1492">              STVFU(Dgrbsq1p[indx &gt;&gt; 1], Dgrbsq1pv);</a>
<a name="ln1493">            }</a>
<a name="ln1494">          }</a>
<a name="ln1495">        }</a>
<a name="ln1496"> </a>
<a name="ln1497">#else</a>
<a name="ln1498"> </a>
<a name="ln1499">        for(int rr = 6; rr &lt; rr1 - 6; rr++)</a>
<a name="ln1500">        {</a>
<a name="ln1501">          if((FC(rr, 2, filters) &amp; 1) == 0)</a>
<a name="ln1502">          {</a>
<a name="ln1503">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1504">            {</a>
<a name="ln1505">              delp[indx &gt;&gt; 1] = fabsf(cfa[indx + p1] - cfa[indx - p1]);</a>
<a name="ln1506">              delm[indx &gt;&gt; 1] = fabsf(cfa[indx + m1] - cfa[indx - m1]);</a>
<a name="ln1507">              Dgrbsq1p[indx &gt;&gt; 1]</a>
<a name="ln1508">                  = (SQR(cfa[indx + 1] - cfa[indx + 1 - p1]) + SQR(cfa[indx + 1] - cfa[indx + 1 + p1]));</a>
<a name="ln1509">              Dgrbsq1m[indx &gt;&gt; 1]</a>
<a name="ln1510">                  = (SQR(cfa[indx + 1] - cfa[indx + 1 - m1]) + SQR(cfa[indx + 1] - cfa[indx + 1 + m1]));</a>
<a name="ln1511">            }</a>
<a name="ln1512">          }</a>
<a name="ln1513">          else</a>
<a name="ln1514">          {</a>
<a name="ln1515">            for(int cc = 6, indx = rr * ts + cc; cc &lt; cc1 - 6; cc += 2, indx += 2)</a>
<a name="ln1516">            {</a>
<a name="ln1517">              Dgrbsq1p[indx &gt;&gt; 1] = (SQR(cfa[indx] - cfa[indx - p1]) + SQR(cfa[indx] - cfa[indx + p1]));</a>
<a name="ln1518">              Dgrbsq1m[indx &gt;&gt; 1] = (SQR(cfa[indx] - cfa[indx - m1]) + SQR(cfa[indx] - cfa[indx + m1]));</a>
<a name="ln1519">              delp[indx &gt;&gt; 1] = fabsf(cfa[indx + 1 + p1] - cfa[indx + 1 - p1]);</a>
<a name="ln1520">              delm[indx &gt;&gt; 1] = fabsf(cfa[indx + 1 + m1] - cfa[indx + 1 - m1]);</a>
<a name="ln1521">            }</a>
<a name="ln1522">          }</a>
<a name="ln1523">        }</a>
<a name="ln1524"> </a>
<a name="ln1525">#endif</a>
<a name="ln1526"> </a>
<a name="ln1527">// diagonal interpolation correction</a>
<a name="ln1528"> </a>
<a name="ln1529">#ifdef __SSE2__</a>
<a name="ln1530">        vfloat gausseven0v = F2V(gausseven[0]);</a>
<a name="ln1531">        vfloat gausseven1v = F2V(gausseven[1]);</a>
<a name="ln1532">#endif</a>
<a name="ln1533"> </a>
<a name="ln1534">        for(int rr = 8; rr &lt; rr1 - 8; rr++)</a>
<a name="ln1535">        {</a>
<a name="ln1536">#ifdef __SSE2__</a>
<a name="ln1537"> </a>
<a name="ln1538">          for(int indx = rr * ts + 8 + (FC(rr, 2, filters) &amp; 1), indx1 = indx &gt;&gt; 1; indx &lt; rr * ts + cc1 - 8;</a>
<a name="ln1539">              indx += 8, indx1 += 4)</a>
<a name="ln1540">          {</a>
<a name="ln1541"> </a>
<a name="ln1542">            // diagonal colour ratios</a>
<a name="ln1543">            vfloat cfav = LC2VFU(cfa[indx]);</a>
<a name="ln1544"> </a>
<a name="ln1545">            vfloat temp1v = LC2VFU(cfa[indx + m1]);</a>
<a name="ln1546">            vfloat temp2v = LC2VFU(cfa[indx + m2]);</a>
<a name="ln1547">            vfloat rbsev = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1548">            rbsev = vself(vmaskf_lt(vabsf(onev - rbsev), arthreshv), cfav * rbsev,</a>
<a name="ln1549">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1550"> </a>
<a name="ln1551">            temp1v = LC2VFU(cfa[indx - m1]);</a>
<a name="ln1552">            temp2v = LC2VFU(cfa[indx - m2]);</a>
<a name="ln1553">            vfloat rbnwv = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1554">            rbnwv = vself(vmaskf_lt(vabsf(onev - rbnwv), arthreshv), cfav * rbnwv,</a>
<a name="ln1555">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1556"> </a>
<a name="ln1557">            temp1v = epsv + LVFU(delm[indx1]);</a>
<a name="ln1558">            vfloat wtsev = temp1v + LVFU(delm[(indx + m1) &gt;&gt; 1])</a>
<a name="ln1559">                           + LVFU(delm[(indx + m2) &gt;&gt; 1]); // same as for wtu,wtd,wtl,wtr</a>
<a name="ln1560">            vfloat wtnwv = temp1v + LVFU(delm[(indx - m1) &gt;&gt; 1]) + LVFU(delm[(indx - m2) &gt;&gt; 1]);</a>
<a name="ln1561"> </a>
<a name="ln1562">            vfloat rbmv = (wtsev * rbnwv + wtnwv * rbsev) / (wtsev + wtnwv);</a>
<a name="ln1563"> </a>
<a name="ln1564">            temp1v = ULIMV(rbmv, LC2VFU(cfa[indx - m1]), LC2VFU(cfa[indx + m1]));</a>
<a name="ln1565">            vfloat wtv = vmul2f(cfav - rbmv) / (epsv + rbmv + cfav);</a>
<a name="ln1566">            temp2v = vintpf(wtv, rbmv, temp1v);</a>
<a name="ln1567"> </a>
<a name="ln1568">            temp2v = vself(vmaskf_lt(rbmv + rbmv, cfav), temp1v, temp2v);</a>
<a name="ln1569">            temp2v = vself(vmaskf_lt(rbmv, cfav), temp2v, rbmv);</a>
<a name="ln1570">            STVFU(rbm[indx1], vself(vmaskf_gt(temp2v, clip_ptv),</a>
<a name="ln1571">                                    ULIMV(temp2v, LC2VFU(cfa[indx - m1]), LC2VFU(cfa[indx + m1])), temp2v));</a>
<a name="ln1572"> </a>
<a name="ln1573"> </a>
<a name="ln1574">            temp1v = LC2VFU(cfa[indx + p1]);</a>
<a name="ln1575">            temp2v = LC2VFU(cfa[indx + p2]);</a>
<a name="ln1576">            vfloat rbnev = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1577">            rbnev = vself(vmaskf_lt(vabsf(onev - rbnev), arthreshv), cfav * rbnev,</a>
<a name="ln1578">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1579"> </a>
<a name="ln1580">            temp1v = LC2VFU(cfa[indx - p1]);</a>
<a name="ln1581">            temp2v = LC2VFU(cfa[indx - p2]);</a>
<a name="ln1582">            vfloat rbswv = vmul2f(temp1v) / (epsv + cfav + temp2v);</a>
<a name="ln1583">            rbswv = vself(vmaskf_lt(vabsf(onev - rbswv), arthreshv), cfav * rbswv,</a>
<a name="ln1584">                          temp1v + zd5v * (cfav - temp2v));</a>
<a name="ln1585"> </a>
<a name="ln1586">            temp1v = epsv + LVFU(delp[indx1]);</a>
<a name="ln1587">            vfloat wtnev = temp1v + LVFU(delp[(indx + p1) &gt;&gt; 1]) + LVFU(delp[(indx + p2) &gt;&gt; 1]);</a>
<a name="ln1588">            vfloat wtswv = temp1v + LVFU(delp[(indx - p1) &gt;&gt; 1]) + LVFU(delp[(indx - p2) &gt;&gt; 1]);</a>
<a name="ln1589"> </a>
<a name="ln1590">            vfloat rbpv = (wtnev * rbswv + wtswv * rbnev) / (wtnev + wtswv);</a>
<a name="ln1591"> </a>
<a name="ln1592">            temp1v = ULIMV(rbpv, LC2VFU(cfa[indx - p1]), LC2VFU(cfa[indx + p1]));</a>
<a name="ln1593">            wtv = vmul2f(cfav - rbpv) / (epsv + rbpv + cfav);</a>
<a name="ln1594">            temp2v = vintpf(wtv, rbpv, temp1v);</a>
<a name="ln1595"> </a>
<a name="ln1596">            temp2v = vself(vmaskf_lt(rbpv + rbpv, cfav), temp1v, temp2v);</a>
<a name="ln1597">            temp2v = vself(vmaskf_lt(rbpv, cfav), temp2v, rbpv);</a>
<a name="ln1598">            STVFU(rbp[indx1], vself(vmaskf_gt(temp2v, clip_ptv),</a>
<a name="ln1599">                                    ULIMV(temp2v, LC2VFU(cfa[indx - p1]), LC2VFU(cfa[indx + p1])), temp2v));</a>
<a name="ln1600"> </a>
<a name="ln1601">            vfloat rbvarmv</a>
<a name="ln1602">                = epssqv</a>
<a name="ln1603">                  + (gausseven0v * (LVFU(Dgrbsq1m[(indx - v1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx - 1) &gt;&gt; 1])</a>
<a name="ln1604">                                    + LVFU(Dgrbsq1m[(indx + 1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + v1) &gt;&gt; 1]))</a>
<a name="ln1605">                     + gausseven1v</a>
<a name="ln1606">                           * (LVFU(Dgrbsq1m[(indx - v2 - 1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx - v2 + 1) &gt;&gt; 1])</a>
<a name="ln1607">                              + LVFU(Dgrbsq1m[(indx - 2 - v1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + 2 - v1) &gt;&gt; 1])</a>
<a name="ln1608">                              + LVFU(Dgrbsq1m[(indx - 2 + v1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + 2 + v1) &gt;&gt; 1])</a>
<a name="ln1609">                              + LVFU(Dgrbsq1m[(indx + v2 - 1) &gt;&gt; 1]) + LVFU(Dgrbsq1m[(indx + v2 + 1) &gt;&gt; 1])));</a>
<a name="ln1610">            STVFU(pmwt[indx1],</a>
<a name="ln1611">                  rbvarmv / ((epssqv</a>
<a name="ln1612">                              + (gausseven0v</a>
<a name="ln1613">                                     * (LVFU(Dgrbsq1p[(indx - v1) &gt;&gt; 1]) + LVFU(Dgrbsq1p[(indx - 1) &gt;&gt; 1])</a>
<a name="ln1614">                                        + LVFU(Dgrbsq1p[(indx + 1) &gt;&gt; 1]) + LVFU(Dgrbsq1p[(indx + v1) &gt;&gt; 1]))</a>
<a name="ln1615">                                 + gausseven1v * (LVFU(Dgrbsq1p[(indx - v2 - 1) &gt;&gt; 1])</a>
<a name="ln1616">                                                  + LVFU(Dgrbsq1p[(indx - v2 + 1) &gt;&gt; 1])</a>
<a name="ln1617">                                                  + LVFU(Dgrbsq1p[(indx - 2 - v1) &gt;&gt; 1])</a>
<a name="ln1618">                                                  + LVFU(Dgrbsq1p[(indx + 2 - v1) &gt;&gt; 1])</a>
<a name="ln1619">                                                  + LVFU(Dgrbsq1p[(indx - 2 + v1) &gt;&gt; 1])</a>
<a name="ln1620">                                                  + LVFU(Dgrbsq1p[(indx + 2 + v1) &gt;&gt; 1])</a>
<a name="ln1621">                                                  + LVFU(Dgrbsq1p[(indx + v2 - 1) &gt;&gt; 1])</a>
<a name="ln1622">                                                  + LVFU(Dgrbsq1p[(indx + v2 + 1) &gt;&gt; 1]))))</a>
<a name="ln1623">                             + rbvarmv));</a>
<a name="ln1624">          }</a>
<a name="ln1625"> </a>
<a name="ln1626">#else</a>
<a name="ln1627"> </a>
<a name="ln1628">          for(int cc = 8 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, indx1 = indx &gt;&gt; 1; cc &lt; cc1 - 8;</a>
<a name="ln1629">              cc += 2, indx += 2, indx1++)</a>
<a name="ln1630">          {</a>
<a name="ln1631"> </a>
<a name="ln1632">            // diagonal colour ratios</a>
<a name="ln1633">            float crse = xmul2f(cfa[indx + m1]) / (eps + cfa[indx] + (cfa[indx + m2]));</a>
<a name="ln1634">            float crnw = xmul2f(cfa[indx - m1]) / (eps + cfa[indx] + (cfa[indx - m2]));</a>
<a name="ln1635">            float crne = xmul2f(cfa[indx + p1]) / (eps + cfa[indx] + (cfa[indx + p2]));</a>
<a name="ln1636">            float crsw = xmul2f(cfa[indx - p1]) / (eps + cfa[indx] + (cfa[indx - p2]));</a>
<a name="ln1637">            // colour differences in diagonal directions</a>
<a name="ln1638">            float rbse, rbnw, rbne, rbsw;</a>
<a name="ln1639"> </a>
<a name="ln1640">            // assign B/R at R/B sites</a>
<a name="ln1641">            if(fabsf(1.f - crse) &lt; arthresh)</a>
<a name="ln1642">            {</a>
<a name="ln1643">              rbse = cfa[indx] * crse; // use this if more precise diag interp is necessary</a>
<a name="ln1644">            }</a>
<a name="ln1645">            else</a>
<a name="ln1646">            {</a>
<a name="ln1647">              rbse = (cfa[indx + m1]) + xdiv2f(cfa[indx] - cfa[indx + m2]);</a>
<a name="ln1648">            }</a>
<a name="ln1649"> </a>
<a name="ln1650">            if(fabsf(1.f - crnw) &lt; arthresh)</a>
<a name="ln1651">            {</a>
<a name="ln1652">              rbnw = cfa[indx] * crnw;</a>
<a name="ln1653">            }</a>
<a name="ln1654">            else</a>
<a name="ln1655">            {</a>
<a name="ln1656">              rbnw = (cfa[indx - m1]) + xdiv2f(cfa[indx] - cfa[indx - m2]);</a>
<a name="ln1657">            }</a>
<a name="ln1658"> </a>
<a name="ln1659">            if(fabsf(1.f - crne) &lt; arthresh)</a>
<a name="ln1660">            {</a>
<a name="ln1661">              rbne = cfa[indx] * crne;</a>
<a name="ln1662">            }</a>
<a name="ln1663">            else</a>
<a name="ln1664">            {</a>
<a name="ln1665">              rbne = (cfa[indx + p1]) + xdiv2f(cfa[indx] - cfa[indx + p2]);</a>
<a name="ln1666">            }</a>
<a name="ln1667"> </a>
<a name="ln1668">            if(fabsf(1.f - crsw) &lt; arthresh)</a>
<a name="ln1669">            {</a>
<a name="ln1670">              rbsw = cfa[indx] * crsw;</a>
<a name="ln1671">            }</a>
<a name="ln1672">            else</a>
<a name="ln1673">            {</a>
<a name="ln1674">              rbsw = (cfa[indx - p1]) + xdiv2f(cfa[indx] - cfa[indx - p2]);</a>
<a name="ln1675">            }</a>
<a name="ln1676"> </a>
<a name="ln1677">            float wtse = eps + delm[indx1] + delm[(indx + m1) &gt;&gt; 1]</a>
<a name="ln1678">                         + delm[(indx + m2) &gt;&gt; 1]; // same as for wtu,wtd,wtl,wtr</a>
<a name="ln1679">            float wtnw = eps + delm[indx1] + delm[(indx - m1) &gt;&gt; 1] + delm[(indx - m2) &gt;&gt; 1];</a>
<a name="ln1680">            float wtne = eps + delp[indx1] + delp[(indx + p1) &gt;&gt; 1] + delp[(indx + p2) &gt;&gt; 1];</a>
<a name="ln1681">            float wtsw = eps + delp[indx1] + delp[(indx - p1) &gt;&gt; 1] + delp[(indx - p2) &gt;&gt; 1];</a>
<a name="ln1682"> </a>
<a name="ln1683"> </a>
<a name="ln1684">            rbm[indx1] = (wtse * rbnw + wtnw * rbse) / (wtse + wtnw);</a>
<a name="ln1685">            rbp[indx1] = (wtne * rbsw + wtsw * rbne) / (wtne + wtsw);</a>
<a name="ln1686"> </a>
<a name="ln1687">            // variance of R-B in plus/minus directions</a>
<a name="ln1688">            float rbvarm</a>
<a name="ln1689">                = epssq</a>
<a name="ln1690">                  + (gausseven[0] * (Dgrbsq1m[(indx - v1) &gt;&gt; 1] + Dgrbsq1m[(indx - 1) &gt;&gt; 1]</a>
<a name="ln1691">                                     + Dgrbsq1m[(indx + 1) &gt;&gt; 1] + Dgrbsq1m[(indx + v1) &gt;&gt; 1])</a>
<a name="ln1692">                     + gausseven[1] * (Dgrbsq1m[(indx - v2 - 1) &gt;&gt; 1] + Dgrbsq1m[(indx - v2 + 1) &gt;&gt; 1]</a>
<a name="ln1693">                                       + Dgrbsq1m[(indx - 2 - v1) &gt;&gt; 1] + Dgrbsq1m[(indx + 2 - v1) &gt;&gt; 1]</a>
<a name="ln1694">                                       + Dgrbsq1m[(indx - 2 + v1) &gt;&gt; 1] + Dgrbsq1m[(indx + 2 + v1) &gt;&gt; 1]</a>
<a name="ln1695">                                       + Dgrbsq1m[(indx + v2 - 1) &gt;&gt; 1] + Dgrbsq1m[(indx + v2 + 1) &gt;&gt; 1]));</a>
<a name="ln1696">            pmwt[indx1]</a>
<a name="ln1697">                = rbvarm</a>
<a name="ln1698">                  / ((epssq + (gausseven[0] * (Dgrbsq1p[(indx - v1) &gt;&gt; 1] + Dgrbsq1p[(indx - 1) &gt;&gt; 1]</a>
<a name="ln1699">                                               + Dgrbsq1p[(indx + 1) &gt;&gt; 1] + Dgrbsq1p[(indx + v1) &gt;&gt; 1])</a>
<a name="ln1700">                               + gausseven[1]</a>
<a name="ln1701">                                     * (Dgrbsq1p[(indx - v2 - 1) &gt;&gt; 1] + Dgrbsq1p[(indx - v2 + 1) &gt;&gt; 1]</a>
<a name="ln1702">                                        + Dgrbsq1p[(indx - 2 - v1) &gt;&gt; 1] + Dgrbsq1p[(indx + 2 - v1) &gt;&gt; 1]</a>
<a name="ln1703">                                        + Dgrbsq1p[(indx - 2 + v1) &gt;&gt; 1] + Dgrbsq1p[(indx + 2 + v1) &gt;&gt; 1]</a>
<a name="ln1704">                                        + Dgrbsq1p[(indx + v2 - 1) &gt;&gt; 1] + Dgrbsq1p[(indx + v2 + 1) &gt;&gt; 1])))</a>
<a name="ln1705">                     + rbvarm);</a>
<a name="ln1706"> </a>
<a name="ln1707">            // bound the interpolation in regions of high saturation</a>
<a name="ln1708"> </a>
<a name="ln1709">            if(rbp[indx1] &lt; cfa[indx])</a>
<a name="ln1710">            {</a>
<a name="ln1711">              if(xmul2f(rbp[indx1]) &lt; cfa[indx])</a>
<a name="ln1712">              {</a>
<a name="ln1713">                rbp[indx1] = ULIM(rbp[indx1], cfa[indx - p1], cfa[indx + p1]);</a>
<a name="ln1714">              }</a>
<a name="ln1715">              else</a>
<a name="ln1716">              {</a>
<a name="ln1717">                float pwt = xmul2f(cfa[indx] - rbp[indx1]) / (eps + rbp[indx1] + cfa[indx]);</a>
<a name="ln1718">                rbp[indx1]</a>
<a name="ln1719">                    = pwt * rbp[indx1] + (1.f - pwt) * ULIM(rbp[indx1], cfa[indx - p1], cfa[indx + p1]);</a>
<a name="ln1720">              }</a>
<a name="ln1721">            }</a>
<a name="ln1722"> </a>
<a name="ln1723">            if(rbm[indx1] &lt; cfa[indx])</a>
<a name="ln1724">            {</a>
<a name="ln1725">              if(xmul2f(rbm[indx1]) &lt; cfa[indx])</a>
<a name="ln1726">              {</a>
<a name="ln1727">                rbm[indx1] = ULIM(rbm[indx1], cfa[indx - m1], cfa[indx + m1]);</a>
<a name="ln1728">              }</a>
<a name="ln1729">              else</a>
<a name="ln1730">              {</a>
<a name="ln1731">                float mwt = xmul2f(cfa[indx] - rbm[indx1]) / (eps + rbm[indx1] + cfa[indx]);</a>
<a name="ln1732">                rbm[indx1]</a>
<a name="ln1733">                    = mwt * rbm[indx1] + (1.f - mwt) * ULIM(rbm[indx1], cfa[indx - m1], cfa[indx + m1]);</a>
<a name="ln1734">              }</a>
<a name="ln1735">            }</a>
<a name="ln1736"> </a>
<a name="ln1737">            if(rbp[indx1] &gt; clip_pt)</a>
<a name="ln1738">            {</a>
<a name="ln1739">              rbp[indx1] = ULIM(rbp[indx1], cfa[indx - p1], cfa[indx + p1]);</a>
<a name="ln1740">            }</a>
<a name="ln1741"> </a>
<a name="ln1742">            if(rbm[indx1] &gt; clip_pt)</a>
<a name="ln1743">            {</a>
<a name="ln1744">              rbm[indx1] = ULIM(rbm[indx1], cfa[indx - m1], cfa[indx + m1]);</a>
<a name="ln1745">            }</a>
<a name="ln1746">          }</a>
<a name="ln1747"> </a>
<a name="ln1748">#endif</a>
<a name="ln1749">        }</a>
<a name="ln1750"> </a>
<a name="ln1751">#ifdef __SSE2__</a>
<a name="ln1752">        vfloat zd25v = F2V(0.25f);</a>
<a name="ln1753">#endif</a>
<a name="ln1754"> </a>
<a name="ln1755">        for(int rr = 10; rr &lt; rr1 - 10; rr++)</a>
<a name="ln1756">#ifdef __SSE2__</a>
<a name="ln1757">          for(int indx = rr * ts + 10 + (FC(rr, 2, filters) &amp; 1), indx1 = indx &gt;&gt; 1;</a>
<a name="ln1758">              indx &lt; rr * ts + cc1 - 10; indx += 8, indx1 += 4)</a>
<a name="ln1759">          {</a>
<a name="ln1760"> </a>
<a name="ln1761">            // first ask if one gets more directional discrimination from nearby B/R sites</a>
<a name="ln1762">            vfloat pmwtaltv = zd25v * (LVFU(pmwt[(indx - m1) &gt;&gt; 1]) + LVFU(pmwt[(indx + p1) &gt;&gt; 1])</a>
<a name="ln1763">                                       + LVFU(pmwt[(indx - p1) &gt;&gt; 1]) + LVFU(pmwt[(indx + m1) &gt;&gt; 1]));</a>
<a name="ln1764">            vfloat tempv = LVFU(pmwt[indx1]);</a>
<a name="ln1765">            tempv = vself(vmaskf_lt(vabsf(zd5v - tempv), vabsf(zd5v - pmwtaltv)), pmwtaltv, tempv);</a>
<a name="ln1766">            STVFU(pmwt[indx1], tempv);</a>
<a name="ln1767">            STVFU(rbint[indx1],</a>
<a name="ln1768">                  zd5v * (LC2VFU(cfa[indx]) + vintpf(tempv, LVFU(rbp[indx1]), LVFU(rbm[indx1]))));</a>
<a name="ln1769">          }</a>
<a name="ln1770"> </a>
<a name="ln1771">#else</a>
<a name="ln1772"> </a>
<a name="ln1773">          for(int cc = 10 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, indx1 = indx &gt;&gt; 1; cc &lt; cc1 - 10;</a>
<a name="ln1774">              cc += 2, indx += 2, indx1++)</a>
<a name="ln1775">          {</a>
<a name="ln1776"> </a>
<a name="ln1777">            // first ask if one gets more directional discrimination from nearby B/R sites</a>
<a name="ln1778">            float pmwtalt = xdivf(pmwt[(indx - m1) &gt;&gt; 1] + pmwt[(indx + p1) &gt;&gt; 1] + pmwt[(indx - p1) &gt;&gt; 1]</a>
<a name="ln1779">                                      + pmwt[(indx + m1) &gt;&gt; 1],</a>
<a name="ln1780">                                  2);</a>
<a name="ln1781"> </a>
<a name="ln1782">            if(fabsf(0.5f - pmwt[indx1]) &lt; fabsf(0.5f - pmwtalt))</a>
<a name="ln1783">            {</a>
<a name="ln1784">              pmwt[indx1] = pmwtalt; // a better result was obtained from the neighbours</a>
<a name="ln1785">            }</a>
<a name="ln1786"> </a>
<a name="ln1787">            rbint[indx1] = xdiv2f(cfa[indx] + rbm[indx1] * (1.f - pmwt[indx1])</a>
<a name="ln1788">                                  + rbp[indx1] * pmwt[indx1]); // this is R+B, interpolated</a>
<a name="ln1789">          }</a>
<a name="ln1790"> </a>
<a name="ln1791">#endif</a>
<a name="ln1792"> </a>
<a name="ln1793">        for(int rr = 12; rr &lt; rr1 - 12; rr++)</a>
<a name="ln1794">#ifdef __SSE2__</a>
<a name="ln1795">          for(int indx = rr * ts + 12 + (FC(rr, 2, filters) &amp; 1), indx1 = indx &gt;&gt; 1;</a>
<a name="ln1796">              indx &lt; rr * ts + cc1 - 12; indx += 8, indx1 += 4)</a>
<a name="ln1797">          {</a>
<a name="ln1798">            vmask copymask = vmaskf_ge(vabsf(zd5v - LVFU(pmwt[indx1])), vabsf(zd5v - LVFU(hvwt[indx1])));</a>
<a name="ln1799"> </a>
<a name="ln1800">            if(_mm_movemask_ps((vfloat)copymask))</a>
<a name="ln1801">            { // if for any of the 4 pixels the condition is true, do the maths for all 4 pixels and mask the</a>
<a name="ln1802">              // unused out at the end</a>
<a name="ln1803">              // now interpolate G vertically/horizontally using R+B values</a>
<a name="ln1804">              // unfortunately, since G interpolation cannot be done diagonally this may lead to colour shifts</a>
<a name="ln1805">              // colour ratios for G interpolation</a>
<a name="ln1806">              vfloat rbintv = LVFU(rbint[indx1]);</a>
<a name="ln1807"> </a>
<a name="ln1808">              // interpolated G via adaptive ratios or Hamilton-Adams in each cardinal direction</a>
<a name="ln1809">              vfloat cruv = vmul2f(LC2VFU(cfa[indx - v1])) / (epsv + rbintv + LVFU(rbint[(indx1 - v1)]));</a>
<a name="ln1810">              vfloat guv = rbintv * cruv;</a>
<a name="ln1811">              vfloat gu2v = LC2VFU(cfa[indx - v1]) + zd5v * (rbintv - LVFU(rbint[(indx1 - v1)]));</a>
<a name="ln1812">              guv = vself(vmaskf_lt(vabsf(onev - cruv), arthreshv), guv, gu2v);</a>
<a name="ln1813"> </a>
<a name="ln1814">              vfloat crdv = vmul2f(LC2VFU(cfa[indx + v1])) / (epsv + rbintv + LVFU(rbint[(indx1 + v1)]));</a>
<a name="ln1815">              vfloat gdv = rbintv * crdv;</a>
<a name="ln1816">              vfloat gd2v = LC2VFU(cfa[indx + v1]) + zd5v * (rbintv - LVFU(rbint[(indx1 + v1)]));</a>
<a name="ln1817">              gdv = vself(vmaskf_lt(vabsf(onev - crdv), arthreshv), gdv, gd2v);</a>
<a name="ln1818"> </a>
<a name="ln1819">              vfloat Gintvv = (LC2VFU(dirwts0[indx - v1]) * gdv + LC2VFU(dirwts0[indx + v1]) * guv)</a>
<a name="ln1820">                              / (LC2VFU(dirwts0[indx + v1]) + LC2VFU(dirwts0[indx - v1]));</a>
<a name="ln1821">              vfloat Gint1v = ULIMV(Gintvv, LC2VFU(cfa[indx - v1]), LC2VFU(cfa[indx + v1]));</a>
<a name="ln1822">              vfloat vwtv = vmul2f(rbintv - Gintvv) / (epsv + Gintvv + rbintv);</a>
<a name="ln1823">              vfloat Gint2v = vintpf(vwtv, Gintvv, Gint1v);</a>
<a name="ln1824">              Gint1v = vself(vmaskf_lt(vmul2f(Gintvv), rbintv), Gint1v, Gint2v);</a>
<a name="ln1825">              Gintvv = vself(vmaskf_lt(Gintvv, rbintv), Gint1v, Gintvv);</a>
<a name="ln1826">              Gintvv = vself(vmaskf_gt(Gintvv, clip_ptv),</a>
<a name="ln1827">                             ULIMV(Gintvv, LC2VFU(cfa[indx - v1]), LC2VFU(cfa[indx + v1])), Gintvv);</a>
<a name="ln1828"> </a>
<a name="ln1829">              vfloat crlv = vmul2f(LC2VFU(cfa[indx - 1])) / (epsv + rbintv + LVFU(rbint[(indx1 - 1)]));</a>
<a name="ln1830">              vfloat glv = rbintv * crlv;</a>
<a name="ln1831">              vfloat gl2v = LC2VFU(cfa[indx - 1]) + zd5v * (rbintv - LVFU(rbint[(indx1 - 1)]));</a>
<a name="ln1832">              glv = vself(vmaskf_lt(vabsf(onev - crlv), arthreshv), glv, gl2v);</a>
<a name="ln1833"> </a>
<a name="ln1834">              vfloat crrv = vmul2f(LC2VFU(cfa[indx + 1])) / (epsv + rbintv + LVFU(rbint[(indx1 + 1)]));</a>
<a name="ln1835">              vfloat grv = rbintv * crrv;</a>
<a name="ln1836">              vfloat gr2v = LC2VFU(cfa[indx + 1]) + zd5v * (rbintv - LVFU(rbint[(indx1 + 1)]));</a>
<a name="ln1837">              grv = vself(vmaskf_lt(vabsf(onev - crrv), arthreshv), grv, gr2v);</a>
<a name="ln1838"> </a>
<a name="ln1839">              vfloat Ginthv = (LC2VFU(dirwts1[indx - 1]) * grv + LC2VFU(dirwts1[indx + 1]) * glv)</a>
<a name="ln1840">                              / (LC2VFU(dirwts1[indx - 1]) + LC2VFU(dirwts1[indx + 1]));</a>
<a name="ln1841">              vfloat Gint1h = ULIMV(Ginthv, LC2VFU(cfa[indx - 1]), LC2VFU(cfa[indx + 1]));</a>
<a name="ln1842">              vfloat hwtv = vmul2f(rbintv - Ginthv) / (epsv + Ginthv + rbintv);</a>
<a name="ln1843">              vfloat Gint2h = vintpf(hwtv, Ginthv, Gint1h);</a>
<a name="ln1844">              Gint1h = vself(vmaskf_lt(vmul2f(Ginthv), rbintv), Gint1h, Gint2h);</a>
<a name="ln1845">              Ginthv = vself(vmaskf_lt(Ginthv, rbintv), Gint1h, Ginthv);</a>
<a name="ln1846">              Ginthv = vself(vmaskf_gt(Ginthv, clip_ptv),</a>
<a name="ln1847">                             ULIMV(Ginthv, LC2VFU(cfa[indx - 1]), LC2VFU(cfa[indx + 1])), Ginthv);</a>
<a name="ln1848"> </a>
<a name="ln1849">              vfloat greenv</a>
<a name="ln1850">                  = vself(copymask, vintpf(LVFU(hvwt[indx1]), Gintvv, Ginthv), LC2VFU(rgbgreen[indx]));</a>
<a name="ln1851">              STC2VFU(rgbgreen[indx], greenv);</a>
<a name="ln1852"> </a>
<a name="ln1853">              STVFU(Dgrb[0][indx1], vself(copymask, greenv - LC2VFU(cfa[indx]), LVFU(Dgrb[0][indx1])));</a>
<a name="ln1854">            }</a>
<a name="ln1855">          }</a>
<a name="ln1856"> </a>
<a name="ln1857">#else</a>
<a name="ln1858"> </a>
<a name="ln1859">          for(int cc = 12 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, indx1 = indx &gt;&gt; 1; cc &lt; cc1 - 12;</a>
<a name="ln1860">              cc += 2, indx += 2, indx1++)</a>
<a name="ln1861">          {</a>
<a name="ln1862"> </a>
<a name="ln1863">            if(fabsf(0.5f - pmwt[indx &gt;&gt; 1]) &lt; fabsf(0.5f - hvwt[indx &gt;&gt; 1]))</a>
<a name="ln1864">            {</a>
<a name="ln1865">              continue;</a>
<a name="ln1866">            }</a>
<a name="ln1867"> </a>
<a name="ln1868">            // now interpolate G vertically/horizontally using R+B values</a>
<a name="ln1869">            // unfortunately, since G interpolation cannot be done diagonally this may lead to colour shifts</a>
<a name="ln1870"> </a>
<a name="ln1871">            // colour ratios for G interpolation</a>
<a name="ln1872">            float cru = cfa[indx - v1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 - v1)]);</a>
<a name="ln1873">            float crd = cfa[indx + v1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 + v1)]);</a>
<a name="ln1874">            float crl = cfa[indx - 1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 - 1)]);</a>
<a name="ln1875">            float crr = cfa[indx + 1] * 2.0 / (eps + rbint[indx1] + rbint[(indx1 + 1)]);</a>
<a name="ln1876"> </a>
<a name="ln1877">            // interpolation of G in four directions</a>
<a name="ln1878">            float gu, gd, gl, gr;</a>
<a name="ln1879"> </a>
<a name="ln1880">            // interpolated G via adaptive ratios or Hamilton-Adams in each cardinal direction</a>
<a name="ln1881">            if(fabsf(1.f - cru) &lt; arthresh)</a>
<a name="ln1882">            {</a>
<a name="ln1883">              gu = rbint[indx1] * cru;</a>
<a name="ln1884">            }</a>
<a name="ln1885">            else</a>
<a name="ln1886">            {</a>
<a name="ln1887">              gu = cfa[indx - v1] + xdiv2f(rbint[indx1] - rbint[(indx1 - v1)]);</a>
<a name="ln1888">            }</a>
<a name="ln1889"> </a>
<a name="ln1890">            if(fabsf(1.f - crd) &lt; arthresh)</a>
<a name="ln1891">            {</a>
<a name="ln1892">              gd = rbint[indx1] * crd;</a>
<a name="ln1893">            }</a>
<a name="ln1894">            else</a>
<a name="ln1895">            {</a>
<a name="ln1896">              gd = cfa[indx + v1] + xdiv2f(rbint[indx1] - rbint[(indx1 + v1)]);</a>
<a name="ln1897">            }</a>
<a name="ln1898"> </a>
<a name="ln1899">            if(fabsf(1.f - crl) &lt; arthresh)</a>
<a name="ln1900">            {</a>
<a name="ln1901">              gl = rbint[indx1] * crl;</a>
<a name="ln1902">            }</a>
<a name="ln1903">            else</a>
<a name="ln1904">            {</a>
<a name="ln1905">              gl = cfa[indx - 1] + xdiv2f(rbint[indx1] - rbint[(indx1 - 1)]);</a>
<a name="ln1906">            }</a>
<a name="ln1907"> </a>
<a name="ln1908">            if(fabsf(1.f - crr) &lt; arthresh)</a>
<a name="ln1909">            {</a>
<a name="ln1910">              gr = rbint[indx1] * crr;</a>
<a name="ln1911">            }</a>
<a name="ln1912">            else</a>
<a name="ln1913">            {</a>
<a name="ln1914">              gr = cfa[indx + 1] + xdiv2f(rbint[indx1] - rbint[(indx1 + 1)]);</a>
<a name="ln1915">            }</a>
<a name="ln1916"> </a>
<a name="ln1917">            // interpolated G via adaptive weights of cardinal evaluations</a>
<a name="ln1918">            float Gintv = (dirwts0[indx - v1] * gd + dirwts0[indx + v1] * gu)</a>
<a name="ln1919">                          / (dirwts0[indx + v1] + dirwts0[indx - v1]);</a>
<a name="ln1920">            float Ginth</a>
<a name="ln1921">                = (dirwts1[indx - 1] * gr + dirwts1[indx + 1] * gl) / (dirwts1[indx - 1] + dirwts1[indx + 1]);</a>
<a name="ln1922"> </a>
<a name="ln1923">            // bound the interpolation in regions of high saturation</a>
<a name="ln1924">            if(Gintv &lt; rbint[indx1])</a>
<a name="ln1925">            {</a>
<a name="ln1926">              if(2 * Gintv &lt; rbint[indx1])</a>
<a name="ln1927">              {</a>
<a name="ln1928">                Gintv = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]);</a>
<a name="ln1929">              }</a>
<a name="ln1930">              else</a>
<a name="ln1931">              {</a>
<a name="ln1932">                float vwt = 2.0 * (rbint[indx1] - Gintv) / (eps + Gintv + rbint[indx1]);</a>
<a name="ln1933">                Gintv = vwt * Gintv + (1.f - vwt) * ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]);</a>
<a name="ln1934">              }</a>
<a name="ln1935">            }</a>
<a name="ln1936"> </a>
<a name="ln1937">            if(Ginth &lt; rbint[indx1])</a>
<a name="ln1938">            {</a>
<a name="ln1939">              if(2 * Ginth &lt; rbint[indx1])</a>
<a name="ln1940">              {</a>
<a name="ln1941">                Ginth = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]);</a>
<a name="ln1942">              }</a>
<a name="ln1943">              else</a>
<a name="ln1944">              {</a>
<a name="ln1945">                float hwt = 2.0 * (rbint[indx1] - Ginth) / (eps + Ginth + rbint[indx1]);</a>
<a name="ln1946">                Ginth = hwt * Ginth + (1.f - hwt) * ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]);</a>
<a name="ln1947">              }</a>
<a name="ln1948">            }</a>
<a name="ln1949"> </a>
<a name="ln1950">            if(Ginth &gt; clip_pt)</a>
<a name="ln1951">            {</a>
<a name="ln1952">              Ginth = ULIM(Ginth, cfa[indx - 1], cfa[indx + 1]);</a>
<a name="ln1953">            }</a>
<a name="ln1954"> </a>
<a name="ln1955">            if(Gintv &gt; clip_pt)</a>
<a name="ln1956">            {</a>
<a name="ln1957">              Gintv = ULIM(Gintv, cfa[indx - v1], cfa[indx + v1]);</a>
<a name="ln1958">            }</a>
<a name="ln1959"> </a>
<a name="ln1960">            rgbgreen[indx] = Ginth * (1.f - hvwt[indx1]) + Gintv * hvwt[indx1];</a>
<a name="ln1961">            Dgrb[0][indx &gt;&gt; 1] = rgbgreen[indx] - cfa[indx];</a>
<a name="ln1962">          }</a>
<a name="ln1963"> </a>
<a name="ln1964">#endif</a>
<a name="ln1965"> </a>
<a name="ln1966">        // end of diagonal interpolation correction</a>
<a name="ln1967"> </a>
<a name="ln1968">        // fancy chrominance interpolation</a>
<a name="ln1969">        //(ey,ex) is location of R site</a>
<a name="ln1970">        for(int rr = 13 - ey; rr &lt; rr1 - 12; rr += 2)</a>
<a name="ln1971">          for(int indx1 = (rr * ts + 13 - ex) &gt;&gt; 1; indx1&lt;(rr * ts + cc1 - 12)&gt;&gt; 1; indx1++)</a>
<a name="ln1972">          {                                  // B coset</a>
<a name="ln1973">            Dgrb[1][indx1] = Dgrb[0][indx1]; // split out G-B from G-R</a>
<a name="ln1974">            Dgrb[0][indx1] = 0;</a>
<a name="ln1975">          }</a>
<a name="ln1976"> </a>
<a name="ln1977">#ifdef __SSE2__</a>
<a name="ln1978">        vfloat oned325v = F2V(1.325f);</a>
<a name="ln1979">        vfloat zd175v = F2V(0.175f);</a>
<a name="ln1980">        vfloat zd075v = F2V(0.075f);</a>
<a name="ln1981">#endif</a>
<a name="ln1982"> </a>
<a name="ln1983">        for(int rr = 14; rr &lt; rr1 - 14; rr++)</a>
<a name="ln1984">#ifdef __SSE2__</a>
<a name="ln1985">          for(int cc = 14 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, c = 1 - FC(rr, cc, filters) / 2;</a>
<a name="ln1986">              cc &lt; cc1 - 14; cc += 8, indx += 8)</a>
<a name="ln1987">          {</a>
<a name="ln1988">            vfloat tempv = epsv + vabsf(LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1]));</a>
<a name="ln1989">            vfloat temp2v = epsv + vabsf(LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1]));</a>
<a name="ln1990">            vfloat wtnwv</a>
<a name="ln1991">                = onev / (tempv + vabsf(LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - m3) &gt;&gt; 1]))</a>
<a name="ln1992">                          + vabsf(LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - m3) &gt;&gt; 1])));</a>
<a name="ln1993">            vfloat wtnev</a>
<a name="ln1994">                = onev / (temp2v + vabsf(LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + p3) &gt;&gt; 1]))</a>
<a name="ln1995">                          + vabsf(LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + p3) &gt;&gt; 1])));</a>
<a name="ln1996">            vfloat wtswv</a>
<a name="ln1997">                = onev / (temp2v + vabsf(LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + m3) &gt;&gt; 1]))</a>
<a name="ln1998">                          + vabsf(LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - p3) &gt;&gt; 1])));</a>
<a name="ln1999">            vfloat wtsev</a>
<a name="ln2000">                = onev / (tempv + vabsf(LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx - p3) &gt;&gt; 1]))</a>
<a name="ln2001">                          + vabsf(LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1]) - LVFU(Dgrb[c][(indx + m3) &gt;&gt; 1])));</a>
<a name="ln2002"> </a>
<a name="ln2003">            STVFU(Dgrb[c][indx &gt;&gt; 1], (wtnwv * (oned325v * LVFU(Dgrb[c][(indx - m1) &gt;&gt; 1])</a>
<a name="ln2004">                                                - zd175v * LVFU(Dgrb[c][(indx - m3) &gt;&gt; 1])</a>
<a name="ln2005">                                                - zd075v * (LVFU(Dgrb[c][(indx - m1 - 2) &gt;&gt; 1])</a>
<a name="ln2006">                                                            + LVFU(Dgrb[c][(indx - m1 - v2) &gt;&gt; 1])))</a>
<a name="ln2007">                                       + wtnev * (oned325v * LVFU(Dgrb[c][(indx + p1) &gt;&gt; 1])</a>
<a name="ln2008">                                                  - zd175v * LVFU(Dgrb[c][(indx + p3) &gt;&gt; 1])</a>
<a name="ln2009">                                                  - zd075v * (LVFU(Dgrb[c][(indx + p1 + 2) &gt;&gt; 1])</a>
<a name="ln2010">                                                              + LVFU(Dgrb[c][(indx + p1 + v2) &gt;&gt; 1])))</a>
<a name="ln2011">                                       + wtswv * (oned325v * LVFU(Dgrb[c][(indx - p1) &gt;&gt; 1])</a>
<a name="ln2012">                                                  - zd175v * LVFU(Dgrb[c][(indx - p3) &gt;&gt; 1])</a>
<a name="ln2013">                                                  - zd075v * (LVFU(Dgrb[c][(indx - p1 - 2) &gt;&gt; 1])</a>
<a name="ln2014">                                                              + LVFU(Dgrb[c][(indx - p1 - v2) &gt;&gt; 1])))</a>
<a name="ln2015">                                       + wtsev * (oned325v * LVFU(Dgrb[c][(indx + m1) &gt;&gt; 1])</a>
<a name="ln2016">                                                  - zd175v * LVFU(Dgrb[c][(indx + m3) &gt;&gt; 1])</a>
<a name="ln2017">                                                  - zd075v * (LVFU(Dgrb[c][(indx + m1 + 2) &gt;&gt; 1])</a>
<a name="ln2018">                                                              + LVFU(Dgrb[c][(indx + m1 + v2) &gt;&gt; 1]))))</a>
<a name="ln2019">                                          / (wtnwv + wtnev + wtswv + wtsev));</a>
<a name="ln2020">          }</a>
<a name="ln2021"> </a>
<a name="ln2022">#else</a>
<a name="ln2023"> </a>
<a name="ln2024">          for(int cc = 14 + (FC(rr, 2, filters) &amp; 1), indx = rr * ts + cc, c = 1 - FC(rr, cc, filters) / 2;</a>
<a name="ln2025">              cc &lt; cc1 - 14; cc += 2, indx += 2)</a>
<a name="ln2026">          {</a>
<a name="ln2027">            float wtnw = 1.f / (eps + fabsf(Dgrb[c][(indx - m1) &gt;&gt; 1] - Dgrb[c][(indx + m1) &gt;&gt; 1])</a>
<a name="ln2028">                                + fabsf(Dgrb[c][(indx - m1) &gt;&gt; 1] - Dgrb[c][(indx - m3) &gt;&gt; 1])</a>
<a name="ln2029">                                + fabsf(Dgrb[c][(indx + m1) &gt;&gt; 1] - Dgrb[c][(indx - m3) &gt;&gt; 1]));</a>
<a name="ln2030">            float wtne = 1.f / (eps + fabsf(Dgrb[c][(indx + p1) &gt;&gt; 1] - Dgrb[c][(indx - p1) &gt;&gt; 1])</a>
<a name="ln2031">                                + fabsf(Dgrb[c][(indx + p1) &gt;&gt; 1] - Dgrb[c][(indx + p3) &gt;&gt; 1])</a>
<a name="ln2032">                                + fabsf(Dgrb[c][(indx - p1) &gt;&gt; 1] - Dgrb[c][(indx + p3) &gt;&gt; 1]));</a>
<a name="ln2033">            float wtsw = 1.f / (eps + fabsf(Dgrb[c][(indx - p1) &gt;&gt; 1] - Dgrb[c][(indx + p1) &gt;&gt; 1])</a>
<a name="ln2034">                                + fabsf(Dgrb[c][(indx - p1) &gt;&gt; 1] - Dgrb[c][(indx + m3) &gt;&gt; 1])</a>
<a name="ln2035">                                + fabsf(Dgrb[c][(indx + p1) &gt;&gt; 1] - Dgrb[c][(indx - p3) &gt;&gt; 1]));</a>
<a name="ln2036">            float wtse = 1.f / (eps + fabsf(Dgrb[c][(indx + m1) &gt;&gt; 1] - Dgrb[c][(indx - m1) &gt;&gt; 1])</a>
<a name="ln2037">                                + fabsf(Dgrb[c][(indx + m1) &gt;&gt; 1] - Dgrb[c][(indx - p3) &gt;&gt; 1])</a>
<a name="ln2038">                                + fabsf(Dgrb[c][(indx - m1) &gt;&gt; 1] - Dgrb[c][(indx + m3) &gt;&gt; 1]));</a>
<a name="ln2039"> </a>
<a name="ln2040">            Dgrb[c][indx &gt;&gt; 1]</a>
<a name="ln2041">                = (wtnw * (1.325f * Dgrb[c][(indx - m1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx - m3) &gt;&gt; 1]</a>
<a name="ln2042">                           - 0.075f * Dgrb[c][(indx - m1 - 2) &gt;&gt; 1] - 0.075f * Dgrb[c][(indx - m1 - v2) &gt;&gt; 1])</a>
<a name="ln2043">                   + wtne * (1.325f * Dgrb[c][(indx + p1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx + p3) &gt;&gt; 1]</a>
<a name="ln2044">                             - 0.075f * Dgrb[c][(indx + p1 + 2) &gt;&gt; 1]</a>
<a name="ln2045">                             - 0.075f * Dgrb[c][(indx + p1 + v2) &gt;&gt; 1])</a>
<a name="ln2046">                   + wtsw * (1.325f * Dgrb[c][(indx - p1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx - p3) &gt;&gt; 1]</a>
<a name="ln2047">                             - 0.075f * Dgrb[c][(indx - p1 - 2) &gt;&gt; 1]</a>
<a name="ln2048">                             - 0.075f * Dgrb[c][(indx - p1 - v2) &gt;&gt; 1])</a>
<a name="ln2049">                   + wtse * (1.325f * Dgrb[c][(indx + m1) &gt;&gt; 1] - 0.175f * Dgrb[c][(indx + m3) &gt;&gt; 1]</a>
<a name="ln2050">                             - 0.075f * Dgrb[c][(indx + m1 + 2) &gt;&gt; 1]</a>
<a name="ln2051">                             - 0.075f * Dgrb[c][(indx + m1 + v2) &gt;&gt; 1]))</a>
<a name="ln2052">                  / (wtnw + wtne + wtsw + wtse);</a>
<a name="ln2053">          }</a>
<a name="ln2054"> </a>
<a name="ln2055">#endif</a>
<a name="ln2056"> </a>
<a name="ln2057">#ifdef __SSE2__</a>
<a name="ln2058">        int offset;</a>
<a name="ln2059">        vfloat twov = F2V(2.f);</a>
<a name="ln2060">        vmask selmask;</a>
<a name="ln2061"> </a>
<a name="ln2062">        if((FC(16, 2, filters) &amp; 1) == 1)</a>
<a name="ln2063">        {</a>
<a name="ln2064">          selmask = _mm_set_epi32(0xffffffff, 0, 0xffffffff, 0);</a>
<a name="ln2065">          offset = 1;</a>
<a name="ln2066">        }</a>
<a name="ln2067">        else</a>
<a name="ln2068">        {</a>
<a name="ln2069">          selmask = _mm_set_epi32(0, 0xffffffff, 0, 0xffffffff);</a>
<a name="ln2070">          offset = 0;</a>
<a name="ln2071">        }</a>
<a name="ln2072"> </a>
<a name="ln2073">#endif</a>
<a name="ln2074"> </a>
<a name="ln2075">        for(int rr = 16; rr &lt; rr1 - 16; rr++)</a>
<a name="ln2076">        {</a>
<a name="ln2077">          int row = rr + top;</a>
<a name="ln2078">          int col = left + 16;</a>
<a name="ln2079">          int indx = rr * ts + 16;</a>
<a name="ln2080">#ifdef __SSE2__</a>
<a name="ln2081">          offset = 1 - offset;</a>
<a name="ln2082">          selmask = vnotm(selmask);</a>
<a name="ln2083"> </a>
<a name="ln2084">          for(; indx &lt; rr * ts + cc1 - 18 - (cc1 &amp; 1); indx += 4, col += 4)</a>
<a name="ln2085">          {</a>
<a name="ln2086">            if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2087">            {</a>
<a name="ln2088">              vfloat greenv = LVF(rgbgreen[indx]);</a>
<a name="ln2089">              vfloat temp00v = vdup(LVFU(hvwt[(indx - v1) &gt;&gt; 1]));</a>
<a name="ln2090">              vfloat temp01v = vdup(LVFU(hvwt[(indx + v1) &gt;&gt; 1]));</a>
<a name="ln2091">              vfloat tempv = onev / (temp00v + twov - vdup(LVFU(hvwt[(indx + 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2092">                                     - vdup(LVFU(hvwt[(indx - 1 + offset) &gt;&gt; 1])) + temp01v);</a>
<a name="ln2093"> </a>
<a name="ln2094">              vfloat redv1 = greenv</a>
<a name="ln2095">                             - (temp00v * vdup(LVFU(Dgrb[0][(indx - v1) &gt;&gt; 1]))</a>
<a name="ln2096">                                + (onev - vdup(LVFU(hvwt[(indx + 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2097">                                      * vdup(LVFU(Dgrb[0][(indx + 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2098">                                + (onev - vdup(LVFU(hvwt[(indx - 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2099">                                      * vdup(LVFU(Dgrb[0][(indx - 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2100">                                + temp01v * vdup(LVFU(Dgrb[0][(indx + v1) &gt;&gt; 1])))</a>
<a name="ln2101">                                   * tempv;</a>
<a name="ln2102">              vfloat bluev1 = greenv</a>
<a name="ln2103">                              - (temp00v * vdup(LVFU(Dgrb[1][(indx - v1) &gt;&gt; 1]))</a>
<a name="ln2104">                                 + (onev - vdup(LVFU(hvwt[(indx + 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2105">                                       * vdup(LVFU(Dgrb[1][(indx + 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2106">                                 + (onev - vdup(LVFU(hvwt[(indx - 1 + offset) &gt;&gt; 1])))</a>
<a name="ln2107">                                       * vdup(LVFU(Dgrb[1][(indx - 1 + offset) &gt;&gt; 1]))</a>
<a name="ln2108">                                 + temp01v * vdup(LVFU(Dgrb[1][(indx + v1) &gt;&gt; 1])))</a>
<a name="ln2109">                                    * tempv;</a>
<a name="ln2110">              vfloat redv2 = greenv - vdup(LVFU(Dgrb[0][indx &gt;&gt; 1]));</a>
<a name="ln2111">              vfloat bluev2 = greenv - vdup(LVFU(Dgrb[1][indx &gt;&gt; 1]));</a>
<a name="ln2112">              __attribute__((aligned(16))) float _r[4];</a>
<a name="ln2113">              __attribute__((aligned(16))) float _b[4];</a>
<a name="ln2114">              STVF(*_r, vself(selmask, redv1, redv2));</a>
<a name="ln2115">              STVF(*_b, vself(selmask, bluev1, bluev2));</a>
<a name="ln2116">              for(int c = 0; c &lt; 4; c++)</a>
<a name="ln2117">              {</a>
<a name="ln2118">                out[(row * roi_out-&gt;width + col + c) * 4] = clampnan(_r[c], 0.0, 1.0);</a>
<a name="ln2119">                out[(row * roi_out-&gt;width + col + c) * 4 + 2] = clampnan(_b[c], 0.0, 1.0);</a>
<a name="ln2120">              }</a>
<a name="ln2121">            }</a>
<a name="ln2122">          }</a>
<a name="ln2123"> </a>
<a name="ln2124">          if(offset == 0)</a>
<a name="ln2125">          {</a>
<a name="ln2126">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2127">            {</a>
<a name="ln2128">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2129">              {</a>
<a name="ln2130">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2131">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2132">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2133">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2134">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2135">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2136">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2137">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2138">                                         * temp,</a>
<a name="ln2139">                               0.0, 1.0);</a>
<a name="ln2140">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2141">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2142">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2143">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2144">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2145">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2146">                                         * temp,</a>
<a name="ln2147">                               0.0, 1.0);</a>
<a name="ln2148">              }</a>
<a name="ln2149"> </a>
<a name="ln2150">              indx++;</a>
<a name="ln2151">              col++;</a>
<a name="ln2152">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2153">              {</a>
<a name="ln2154">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2155">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2156">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2157">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2158">              }</a>
<a name="ln2159">            }</a>
<a name="ln2160"> </a>
<a name="ln2161">            if(cc1 &amp; 1)</a>
<a name="ln2162">            { // width of tile is odd</a>
<a name="ln2163">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2164">              {</a>
<a name="ln2165">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2166">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2167">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2168">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2169">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2170">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2171">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2172">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2173">                                         * temp,</a>
<a name="ln2174">                               0.0, 1.0);</a>
<a name="ln2175">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2176">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2177">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2178">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2179">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2180">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2181">                                         * temp,</a>
<a name="ln2182">                               0.0, 1.0);</a>
<a name="ln2183">              }</a>
<a name="ln2184">            }</a>
<a name="ln2185">          }</a>
<a name="ln2186">          else</a>
<a name="ln2187">          {</a>
<a name="ln2188">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2189">            {</a>
<a name="ln2190">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2191">              {</a>
<a name="ln2192">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2193">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2194">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2195">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2196">              }</a>
<a name="ln2197"> </a>
<a name="ln2198">              indx++;</a>
<a name="ln2199">              col++;</a>
<a name="ln2200">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2201">              {</a>
<a name="ln2202">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2203">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2204">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2205">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2206">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2207">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2208">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2209">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2210">                                         * temp,</a>
<a name="ln2211">                               0.0, 1.0);</a>
<a name="ln2212">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2213">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2214">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2215">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2216">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2217">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2218">                                         * temp,</a>
<a name="ln2219">                               0.0, 1.0);</a>
<a name="ln2220">              }</a>
<a name="ln2221">            }</a>
<a name="ln2222"> </a>
<a name="ln2223">            if(cc1 &amp; 1)</a>
<a name="ln2224">            { // width of tile is odd</a>
<a name="ln2225">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2226">              {</a>
<a name="ln2227">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2228">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2229">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2230">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2231">              }</a>
<a name="ln2232">            }</a>
<a name="ln2233">          }</a>
<a name="ln2234"> </a>
<a name="ln2235">#else</a>
<a name="ln2236"> </a>
<a name="ln2237">          if((FC(rr, 2, filters) &amp; 1) == 1)</a>
<a name="ln2238">          {</a>
<a name="ln2239">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2240">            {</a>
<a name="ln2241">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2242">              {</a>
<a name="ln2243">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2244">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2245">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2246">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2247">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2248">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2249">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2250">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2251">                                         * temp,</a>
<a name="ln2252">                               0.0, 1.0);</a>
<a name="ln2253">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2254">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2255">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2256">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2257">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2258">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2259">                                         * temp,</a>
<a name="ln2260">                               0.0, 1.0);</a>
<a name="ln2261">              }</a>
<a name="ln2262"> </a>
<a name="ln2263">              indx++;</a>
<a name="ln2264">              col++;</a>
<a name="ln2265">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2266">              {</a>
<a name="ln2267">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2268">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2269">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2270">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0, 1.0);</a>
<a name="ln2271">              }</a>
<a name="ln2272">            }</a>
<a name="ln2273"> </a>
<a name="ln2274">            if(cc1 &amp; 1)</a>
<a name="ln2275">            { // width of tile is odd</a>
<a name="ln2276">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2277">              {</a>
<a name="ln2278">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2279">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2280">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2281">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2282">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2283">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2284">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2285">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2286">                                         * temp,</a>
<a name="ln2287">                               0.0, 1.0);</a>
<a name="ln2288">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2289">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2290">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2291">                                      + (1.f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2292">                                      + (1.f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2293">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2294">                                         * temp,</a>
<a name="ln2295">                               0.0, 1.0);</a>
<a name="ln2296">              }</a>
<a name="ln2297">            }</a>
<a name="ln2298">          }</a>
<a name="ln2299">          else</a>
<a name="ln2300">          {</a>
<a name="ln2301">            for(; indx &lt; rr * ts + cc1 - 16 - (cc1 &amp; 1); indx++, col++)</a>
<a name="ln2302">            {</a>
<a name="ln2303">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2304">              {</a>
<a name="ln2305">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2306">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2307">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2308">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2309">              }</a>
<a name="ln2310"> </a>
<a name="ln2311">              indx++;</a>
<a name="ln2312">              col++;</a>
<a name="ln2313">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2314">              {</a>
<a name="ln2315">                float temp = 1.f / (hvwt[(indx - v1) &gt;&gt; 1] + 2.f - hvwt[(indx + 1) &gt;&gt; 1]</a>
<a name="ln2316">                                    - hvwt[(indx - 1) &gt;&gt; 1] + hvwt[(indx + v1) &gt;&gt; 1]);</a>
<a name="ln2317"> </a>
<a name="ln2318">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2319">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2320">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[0][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2321">                                      + (1.0f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[0][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2322">                                      + (1.0f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[0][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2323">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[0][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2324">                                         * temp,</a>
<a name="ln2325">                               0.0f, 1.0f);</a>
<a name="ln2326"> </a>
<a name="ln2327">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2328">                    = clampnan(rgbgreen[indx]</a>
<a name="ln2329">                                   - ((hvwt[(indx - v1) &gt;&gt; 1]) * Dgrb[1][(indx - v1) &gt;&gt; 1]</a>
<a name="ln2330">                                      + (1.0f - hvwt[(indx + 1) &gt;&gt; 1]) * Dgrb[1][(indx + 1) &gt;&gt; 1]</a>
<a name="ln2331">                                      + (1.0f - hvwt[(indx - 1) &gt;&gt; 1]) * Dgrb[1][(indx - 1) &gt;&gt; 1]</a>
<a name="ln2332">                                      + (hvwt[(indx + v1) &gt;&gt; 1]) * Dgrb[1][(indx + v1) &gt;&gt; 1])</a>
<a name="ln2333">                                         * temp,</a>
<a name="ln2334">                               0.0f, 1.0f);</a>
<a name="ln2335">              }</a>
<a name="ln2336">            }</a>
<a name="ln2337"> </a>
<a name="ln2338">            if(cc1 &amp; 1)</a>
<a name="ln2339">            { // width of tile is odd</a>
<a name="ln2340">              if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2341">              {</a>
<a name="ln2342">                out[(row * roi_out-&gt;width + col) * 4]</a>
<a name="ln2343">                    = clampnan(rgbgreen[indx] - Dgrb[0][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2344">                out[(row * roi_out-&gt;width + col) * 4 + 2]</a>
<a name="ln2345">                    = clampnan(rgbgreen[indx] - Dgrb[1][indx &gt;&gt; 1], 0.0f, 1.0f);</a>
<a name="ln2346">              }</a>
<a name="ln2347">            }</a>
<a name="ln2348">          }</a>
<a name="ln2349"> </a>
<a name="ln2350">#endif</a>
<a name="ln2351">        }</a>
<a name="ln2352"> </a>
<a name="ln2353">        // copy smoothed results back to image matrix</a>
<a name="ln2354">        for(int rr = 16; rr &lt; rr1 - 16; rr++)</a>
<a name="ln2355">        {</a>
<a name="ln2356">          int row = rr + top;</a>
<a name="ln2357">          int cc = 16;</a>
<a name="ln2358">          // TODO (darktable): we have the pixel colors interleaved so writing them in blocks using SSE2 is</a>
<a name="ln2359">          // not possible. or is it?</a>
<a name="ln2360">          // #ifdef __SSE2__</a>
<a name="ln2361">          //</a>
<a name="ln2362">          //           for(; cc &lt; cc1 - 19; cc += 4)</a>
<a name="ln2363">          //           {</a>
<a name="ln2364">          //             STVFU(out[(row * roi_out-&gt;width + (cc + left))  * 4 + 1], LVF(rgbgreen[rr * ts +</a>
<a name="ln2365">          //             cc]));</a>
<a name="ln2366">          //           }</a>
<a name="ln2367">          //</a>
<a name="ln2368">          // #endif</a>
<a name="ln2369"> </a>
<a name="ln2370">          for(; cc &lt; cc1 - 16; cc++)</a>
<a name="ln2371">          {</a>
<a name="ln2372">            int col = cc + left;</a>
<a name="ln2373">            int indx = rr * ts + cc;</a>
<a name="ln2374">            if(col &lt; roi_out-&gt;width &amp;&amp; row &lt; roi_out-&gt;height)</a>
<a name="ln2375">              out[(row * roi_out-&gt;width + col) * 4 + 1] = clampnan(rgbgreen[indx], 0.0f, 1.0f);</a>
<a name="ln2376">          }</a>
<a name="ln2377">        }</a>
<a name="ln2378"> </a>
<a name="ln2379">        //         if(plistener)</a>
<a name="ln2380">        //         {</a>
<a name="ln2381">        //           progresscounter++;</a>
<a name="ln2382">        //</a>
<a name="ln2383">        //           if(progresscounter % 32 == 0)</a>
<a name="ln2384">        //           {</a>
<a name="ln2385">        // #ifdef _OPENMP</a>
<a name="ln2386">        // #pragma omp critical(amazeprogress)</a>
<a name="ln2387">        // #endif</a>
<a name="ln2388">        //             {</a>
<a name="ln2389">        //               progress += (double)32 * ((ts - 32) * (ts - 32)) / (height * width);</a>
<a name="ln2390">        //               progress = progress &gt; 1.0 ? 1.0 : progress;</a>
<a name="ln2391">        //               plistener-&gt;setProgress(progress);</a>
<a name="ln2392">        //             }</a>
<a name="ln2393">        //           }</a>
<a name="ln2394">        //         }</a>
<a name="ln2395">      }</a>
<a name="ln2396">    } // end of main loop</a>
<a name="ln2397"> </a>
<a name="ln2398">    // clean up</a>
<a name="ln2399">    free(buffer);</a>
<a name="ln2400">  }</a>
<a name="ln2401"> </a>
<a name="ln2402">  //   if(plistener)</a>
<a name="ln2403">  //   {</a>
<a name="ln2404">  //     plistener-&gt;setProgress(1.0);</a>
<a name="ln2405">  //   }</a>
<a name="ln2406">}</a>
<a name="ln2407">// }</a>
<a name="ln2408"> </a>
<a name="ln2409">/*==================================================================================</a>
<a name="ln2410"> * end of raw therapee code</a>
<a name="ln2411"> *==================================================================================*/</a>
<a name="ln2412"> </a>
<a name="ln2413">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2414">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2415">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="268"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v764/" target="_blank">V764</a> Possible incorrect order of arguments passed to 'LIM' function: 'c' and 'b'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
