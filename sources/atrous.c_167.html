
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln19">#include &quot;common/debug.h&quot;</a>
<a name="ln20">#include &quot;common/opencl.h&quot;</a>
<a name="ln21">#include &quot;control/conf.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop.h&quot;</a>
<a name="ln24">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln25">#include &quot;develop/tiling.h&quot;</a>
<a name="ln26">#include &quot;dtgtk/drawingarea.h&quot;</a>
<a name="ln27">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln28">#include &quot;gui/draw.h&quot;</a>
<a name="ln29">#include &quot;gui/gtk.h&quot;</a>
<a name="ln30">#include &quot;gui/presets.h&quot;</a>
<a name="ln31">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;math.h&gt;</a>
<a name="ln34">#include &lt;memory.h&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#if defined(__SSE__)</a>
<a name="ln37">#include &lt;xmmintrin.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">#define INSET DT_PIXEL_APPLY_DPI(5)</a>
<a name="ln41">#define INFL .3f</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">DT_MODULE_INTROSPECTION(1, dt_iop_atrous_params_t)</a>
<a name="ln45"> </a>
<a name="ln46">#define BANDS 6</a>
<a name="ln47">#define MAX_NUM_SCALES 8 // 2*2^(i+1) + 1 = 1025px support for i = 8</a>
<a name="ln48">#define RES 64</a>
<a name="ln49"> </a>
<a name="ln50">#define dt_atrous_show_upper_label(cr, text, layout, ink)                                                    \</a>
<a name="ln51">  pango_layout_set_text(layout, text, -1);                                                                   \</a>
<a name="ln52">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);                                                        \</a>
<a name="ln53">  cairo_move_to(cr, .5 * (width - ink.width), (.08 * height) - ink.height);                                  \</a>
<a name="ln54">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">#define dt_atrous_show_lower_label(cr, text, layout, ink)                                                    \</a>
<a name="ln58">  pango_layout_set_text(layout, text, -1);                                                                   \</a>
<a name="ln59">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);                                                        \</a>
<a name="ln60">  cairo_move_to(cr, .5 * (width - ink.width), (.98 * height) - ink.height);                                  \</a>
<a name="ln61">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">typedef enum atrous_channel_t</a>
<a name="ln65">{</a>
<a name="ln66">  atrous_L = 0,  // luminance boost</a>
<a name="ln67">  atrous_c = 1,  // chrominance boost</a>
<a name="ln68">  atrous_s = 2,  // edge sharpness</a>
<a name="ln69">  atrous_Lt = 3, // luminance noise threshold</a>
<a name="ln70">  atrous_ct = 4, // chrominance noise threshold</a>
<a name="ln71">  atrous_none = 5</a>
<a name="ln72">} atrous_channel_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef struct dt_iop_atrous_params_t</a>
<a name="ln75">{</a>
<a name="ln76">  int32_t octaves;</a>
<a name="ln77">  float x[atrous_none][BANDS], y[atrous_none][BANDS];</a>
<a name="ln78">} dt_iop_atrous_params_t;</a>
<a name="ln79"> </a>
<a name="ln80">typedef struct dt_iop_atrous_gui_data_t</a>
<a name="ln81">{</a>
<a name="ln82">  GtkWidget *mix;</a>
<a name="ln83">  GtkDrawingArea *area;</a>
<a name="ln84">  GtkNotebook *channel_tabs;</a>
<a name="ln85">  double mouse_x, mouse_y, mouse_pick;</a>
<a name="ln86">  float mouse_radius;</a>
<a name="ln87">  dt_iop_atrous_params_t drag_params;</a>
<a name="ln88">  int dragging;</a>
<a name="ln89">  int x_move;</a>
<a name="ln90">  dt_draw_curve_t *minmax_curve;</a>
<a name="ln91">  atrous_channel_t channel, channel2;</a>
<a name="ln92">  float draw_xs[RES], draw_ys[RES];</a>
<a name="ln93">  float draw_min_xs[RES], draw_min_ys[RES];</a>
<a name="ln94">  float draw_max_xs[RES], draw_max_ys[RES];</a>
<a name="ln95">  float band_hist[MAX_NUM_SCALES];</a>
<a name="ln96">  float band_max;</a>
<a name="ln97">  float sample[MAX_NUM_SCALES];</a>
<a name="ln98">  int num_samples;</a>
<a name="ln99">} dt_iop_atrous_gui_data_t;</a>
<a name="ln100"> </a>
<a name="ln101">typedef struct dt_iop_atrous_global_data_t</a>
<a name="ln102">{</a>
<a name="ln103">  int kernel_decompose;</a>
<a name="ln104">  int kernel_synthesize;</a>
<a name="ln105">} dt_iop_atrous_global_data_t;</a>
<a name="ln106"> </a>
<a name="ln107">typedef struct dt_iop_atrous_data_t</a>
<a name="ln108">{</a>
<a name="ln109">  // demosaic pattern</a>
<a name="ln110">  int32_t octaves;</a>
<a name="ln111">  dt_draw_curve_t *curve[atrous_none];</a>
<a name="ln112">} dt_iop_atrous_data_t;</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">const char *name()</a>
<a name="ln116">{</a>
<a name="ln117">  return _(&quot;equalizer&quot;);</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int default_group()</a>
<a name="ln121">{</a>
<a name="ln122">  return IOP_GROUP_CORRECT;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">int flags()</a>
<a name="ln126">{</a>
<a name="ln127">  return IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_ALLOW_TILING;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln131">{</a>
<a name="ln132">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;mix&quot;));</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln136">{</a>
<a name="ln137">  dt_accel_connect_slider_iop(self, &quot;mix&quot;, ((dt_iop_atrous_gui_data_t *)self-&gt;gui_data)-&gt;mix);</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">#if defined(__SSE2__)</a>
<a name="ln142"> </a>
<a name="ln143">#define ALIGNED(a) __attribute__((aligned(a)))</a>
<a name="ln144">#define VEC4(a)                                                                                              \</a>
<a name="ln145">  {                                                                                                          \</a>
<a name="ln146">    (a), (a), (a), (a)                                                                                       \</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">static const __m128 fone ALIGNED(16) = VEC4(0x3f800000u);</a>
<a name="ln150">static const __m128 femo ALIGNED(16) = VEC4(0x00adf880u);</a>
<a name="ln151">static const __m128 ooo1 ALIGNED(16) = { 0.f, 0.f, 0.f, 1.f };</a>
<a name="ln152"> </a>
<a name="ln153">/* SSE intrinsics version of dt_fast_expf defined in darktable.h */</a>
<a name="ln154">static inline __m128 dt_fast_expf_sse2(const __m128 x)</a>
<a name="ln155">{</a>
<a name="ln156">  __m128 f = _mm_add_ps(fone, _mm_mul_ps(x, femo)); // f(n) = i1 + x(n)*(i2-i1)</a>
<a name="ln157">  __m128i i = _mm_cvtps_epi32(f);                   // i(n) = int(f(n))</a>
<a name="ln158">  __m128i mask = _mm_srai_epi32(i, 31);             // mask(n) = 0xffffffff if i(n) &lt; 0</a>
<a name="ln159">  i = _mm_andnot_si128(mask, i);                    // i(n) = 0 if i(n) &lt; 0</a>
<a name="ln160">  return _mm_castsi128_ps(i);                       // return *(float*)&amp;i</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">#endif</a>
<a name="ln164"> </a>
<a name="ln165">static inline void weight(const float *c1, const float *c2, const float sharpen, float *weight)</a>
<a name="ln166">{</a>
<a name="ln167">  float square[3];</a>
<a name="ln168">  for(int c = 0; c &lt; 3; c++) square[c] = c1[c] - c2[c];</a>
<a name="ln169">  for(int c = 0; c &lt; 3; c++) square[c] = square[c] * square[c];</a>
<a name="ln170"> </a>
<a name="ln171">  const float wl = dt_fast_expf(-sharpen * square[0]);</a>
<a name="ln172">  const float wc = dt_fast_expf(-sharpen * (square[1] + square[2]));</a>
<a name="ln173"> </a>
<a name="ln174">  weight[0] = wl;</a>
<a name="ln175">  weight[1] = wc;</a>
<a name="ln176">  weight[2] = wc;</a>
<a name="ln177">  weight[3] = 1.0f;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">#if defined(__SSE2__)</a>
<a name="ln181">/* Computes the vector</a>
<a name="ln182"> * (wl, wc, wc, 1)</a>
<a name="ln183"> *</a>
<a name="ln184"> * where:</a>
<a name="ln185"> * wl = exp(-sharpen*SQR(c1[0] - c2[0]))</a>
<a name="ln186"> *    = exp(-s*d1) (as noted in code comments below)</a>
<a name="ln187"> * wc = exp(-sharpen*(SQR(c1[1] - c2[1]) + SQR(c1[2] - c2[2]))</a>
<a name="ln188"> *    = exp(-s*(d2+d3)) (as noted in code comments below)</a>
<a name="ln189"> */</a>
<a name="ln190">static inline __m128 weight_sse2(const __m128 *c1, const __m128 *c2, const float sharpen)</a>
<a name="ln191">{</a>
<a name="ln192">  const __m128 vsharpen = _mm_set1_ps(-sharpen); // (-s, -s, -s, -s)</a>
<a name="ln193">  __m128 diff = _mm_sub_ps(*c1, *c2);</a>
<a name="ln194">  __m128 square = _mm_mul_ps(diff, diff);                                   // (?, d3, d2, d1)</a>
<a name="ln195">  __m128 square2 = _mm_shuffle_ps(square, square, _MM_SHUFFLE(3, 1, 2, 0)); // (?, d2, d3, d1)</a>
<a name="ln196">  __m128 added = _mm_add_ps(square, square2);                               // (?, d2+d3, d2+d3, 2*d1)</a>
<a name="ln197">  added = _mm_sub_ss(added, square);                                        // (?, d2+d3, d2+d3, d1)</a>
<a name="ln198">  __m128 sharpened = _mm_mul_ps(added, vsharpen);                   // (?, -s*(d2+d3), -s*(d2+d3), -s*d1)</a>
<a name="ln199">  __m128 exp = dt_fast_expf_sse2(sharpened);                        // (?, wc, wc, wl)</a>
<a name="ln200">  exp = _mm_castsi128_ps(_mm_slli_si128(_mm_castps_si128(exp), 4)); // (wc, wc, wl, 0)</a>
<a name="ln201">  exp = _mm_castsi128_ps(_mm_srli_si128(_mm_castps_si128(exp), 4)); // (0, wc, wc, wl)</a>
<a name="ln202">  exp = _mm_or_ps(exp, ooo1);                                       // (1, wc, wc, wl)</a>
<a name="ln203">  return exp;</a>
<a name="ln204">}</a>
<a name="ln205">#endif</a>
<a name="ln206"> </a>
<a name="ln207">#define SUM_PIXEL_CONTRIBUTION_COMMON(ii, jj)                                                                \</a>
<a name="ln208">  {                                                                                                          \</a>
<a name="ln209">    const float f = filter[(ii)] * filter[(jj)];                                                             \</a>
<a name="ln210">    float wp[4] = { 0.0f, 0.0f, 0.0f, 0.0f };                                                                \</a>
<a name="ln211">    weight(px, px2, sharpen, wp);                                                                            \</a>
<a name="ln212">    float w[4] = { 0.0f, 0.0f, 0.0f, 0.0f };                                                                 \</a>
<a name="ln213">    for(int c = 0; c &lt; 4; c++) w[c] = f * wp[c];                                                             \</a>
<a name="ln214">    float pd[4] = { 0.0f, 0.0f, 0.0f, 0.0f };                                                                \</a>
<a name="ln215">    for(int c = 0; c &lt; 4; c++) pd[c] = w[c] * px2[c];                                                        \</a>
<a name="ln216">    for(int c = 0; c &lt; 4; c++) sum[c] += pd[c];                                                              \</a>
<a name="ln217">    for(int c = 0; c &lt; 4; c++) wgt[c] += w[c];                                                               \</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">#if defined(__SSE2__)</a>
<a name="ln221">#define SUM_PIXEL_CONTRIBUTION_COMMON_SSE2(ii, jj)                                                           \</a>
<a name="ln222">  {                                                                                                          \</a>
<a name="ln223">    const __m128 f = _mm_set1_ps(filter[(ii)] * filter[(jj)]);                                               \</a>
<a name="ln224">    const __m128 wp = weight_sse2(px, px2, sharpen);                                                         \</a>
<a name="ln225">    const __m128 w = _mm_mul_ps(f, wp);                                                                      \</a>
<a name="ln226">    const __m128 pd = _mm_mul_ps(w, *px2);                                                                   \</a>
<a name="ln227">    sum = _mm_add_ps(sum, pd);                                                                               \</a>
<a name="ln228">    wgt = _mm_add_ps(wgt, w);                                                                                \</a>
<a name="ln229">  }</a>
<a name="ln230">#endif</a>
<a name="ln231"> </a>
<a name="ln232">#define SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj)                                                             \</a>
<a name="ln233">  do                                                                                                         \</a>
<a name="ln234">  {                                                                                                          \</a>
<a name="ln235">    const int iii = (ii)-2;                                                                                  \</a>
<a name="ln236">    const int jjj = (jj)-2;                                                                                  \</a>
<a name="ln237">    int x = i + mult * iii;                                                                                  \</a>
<a name="ln238">    int y = j + mult * jjj;                                                                                  \</a>
<a name="ln239">                                                                                                             \</a>
<a name="ln240">    if(x &lt; 0) x = 0;                                                                                         \</a>
<a name="ln241">    if(x &gt;= width) x = width - 1;                                                                            \</a>
<a name="ln242">    if(y &lt; 0) y = 0;                                                                                         \</a>
<a name="ln243">    if(y &gt;= height) y = height - 1;                                                                          \</a>
<a name="ln244">                                                                                                             \</a>
<a name="ln245">    px2 = ((float *)in) + 4 * x + (size_t)4 * y * width;                                                     \</a>
<a name="ln246">                                                                                                             \</a>
<a name="ln247">    SUM_PIXEL_CONTRIBUTION_COMMON(ii, jj);                                                                   \</a>
<a name="ln248">  } while(0)</a>
<a name="ln249"> </a>
<a name="ln250">#if defined(__SSE2__)</a>
<a name="ln251">#define SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE2(ii, jj)                                                        \</a>
<a name="ln252">  do                                                                                                         \</a>
<a name="ln253">  {                                                                                                          \</a>
<a name="ln254">    const int iii = (ii)-2;                                                                                  \</a>
<a name="ln255">    const int jjj = (jj)-2;                                                                                  \</a>
<a name="ln256">    int x = i + mult * iii;                                                                                  \</a>
<a name="ln257">    int y = j + mult * jjj;                                                                                  \</a>
<a name="ln258">                                                                                                             \</a>
<a name="ln259">    if(x &lt; 0) x = 0;                                                                                         \</a>
<a name="ln260">    if(x &gt;= width) x = width - 1;                                                                            \</a>
<a name="ln261">    if(y &lt; 0) y = 0;                                                                                         \</a>
<a name="ln262">    if(y &gt;= height) y = height - 1;                                                                          \</a>
<a name="ln263">                                                                                                             \</a>
<a name="ln264">    px2 = ((__m128 *)in) + x + (size_t)y * width;                                                            \</a>
<a name="ln265">                                                                                                             \</a>
<a name="ln266">    SUM_PIXEL_CONTRIBUTION_COMMON_SSE2(ii, jj);                                                              \</a>
<a name="ln267">  } while(0)</a>
<a name="ln268">#endif</a>
<a name="ln269"> </a>
<a name="ln270">#define ROW_PROLOGUE                                                                                         \</a>
<a name="ln271">  const float *px = ((float *)in) + (size_t)4 * j * width;                                                   \</a>
<a name="ln272">  const float *px2;                                                                                          \</a>
<a name="ln273">  float *pdetail = detail + (size_t)4 * j * width;                                                           \</a>
<a name="ln274">  float *pcoarse = out + (size_t)4 * j * width;</a>
<a name="ln275"> </a>
<a name="ln276">#if defined(__SSE2__)</a>
<a name="ln277">#define ROW_PROLOGUE_SSE                                                                                     \</a>
<a name="ln278">  const __m128 *px = ((__m128 *)in) + (size_t)j * width;                                                     \</a>
<a name="ln279">  const __m128 *px2;                                                                                         \</a>
<a name="ln280">  float *pdetail = detail + (size_t)4 * j * width;                                                           \</a>
<a name="ln281">  float *pcoarse = out + (size_t)4 * j * width;</a>
<a name="ln282">#endif</a>
<a name="ln283"> </a>
<a name="ln284">#define SUM_PIXEL_PROLOGUE                                                                                   \</a>
<a name="ln285">  float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f };                                                                 \</a>
<a name="ln286">  float wgt[4] = { 0.0f, 0.0f, 0.0f, 0.0f };</a>
<a name="ln287"> </a>
<a name="ln288">#if defined(__SSE2__)</a>
<a name="ln289">#define SUM_PIXEL_PROLOGUE_SSE                                                                               \</a>
<a name="ln290">  __m128 sum = _mm_setzero_ps();                                                                             \</a>
<a name="ln291">  __m128 wgt = _mm_setzero_ps();</a>
<a name="ln292">#endif</a>
<a name="ln293"> </a>
<a name="ln294">#define SUM_PIXEL_EPILOGUE                                                                                   \</a>
<a name="ln295">  for(int c = 0; c &lt; 4; c++) sum[c] /= wgt[c];                                                               \</a>
<a name="ln296">                                                                                                             \</a>
<a name="ln297">  for(int c = 0; c &lt; 4; c++) pdetail[c] = (px[c] - sum[c]);                                                  \</a>
<a name="ln298">  for(int c = 0; c &lt; 4; c++) pcoarse[c] = sum[c];                                                            \</a>
<a name="ln299">  px += 4;                                                                                                   \</a>
<a name="ln300">  pdetail += 4;                                                                                              \</a>
<a name="ln301">  pcoarse += 4;</a>
<a name="ln302"> </a>
<a name="ln303">#if defined(__SSE2__)</a>
<a name="ln304">#define SUM_PIXEL_EPILOGUE_SSE                                                                               \</a>
<a name="ln305">  sum = _mm_mul_ps(sum, _mm_rcp_ps(wgt));                                                                    \</a>
<a name="ln306">                                                                                                             \</a>
<a name="ln307">  _mm_stream_ps(pdetail, _mm_sub_ps(*px, sum));                                                              \</a>
<a name="ln308">  _mm_stream_ps(pcoarse, sum);                                                                               \</a>
<a name="ln309">  px++;                                                                                                      \</a>
<a name="ln310">  pdetail += 4;                                                                                              \</a>
<a name="ln311">  pcoarse += 4;</a>
<a name="ln312">#endif</a>
<a name="ln313"> </a>
<a name="ln314">typedef void((*eaw_decompose_t)(float *const out, const float *const in, float *const detail, const int scale,</a>
<a name="ln315">                                const float sharpen, const int32_t width, const int32_t height));</a>
<a name="ln316"> </a>
<a name="ln317">static void eaw_decompose(float *const out, const float *const in, float *const detail, const int scale,</a>
<a name="ln318">                          const float sharpen, const int32_t width, const int32_t height)</a>
<a name="ln319">{</a>
<a name="ln320">  const int mult = 1 &lt;&lt; scale;</a>
<a name="ln321">  static const float filter[5] = { 1.0f / 16.0f, 4.0f / 16.0f, 6.0f / 16.0f, 4.0f / 16.0f, 1.0f / 16.0f };</a>
<a name="ln322"> </a>
<a name="ln323">/* The first &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln324"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln325">#ifdef _OPENMP</a>
<a name="ln326">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln327">#endif</a>
<a name="ln328">  for(int j = 0; j &lt; 2 * mult; j++)</a>
<a name="ln329">  {</a>
<a name="ln330">    ROW_PROLOGUE</a>
<a name="ln331"> </a>
<a name="ln332">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln333">    {</a>
<a name="ln334">      SUM_PIXEL_PROLOGUE</a>
<a name="ln335">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln336">      {</a>
<a name="ln337">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln338">        {</a>
<a name="ln339">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln340">        }</a>
<a name="ln341">      }</a>
<a name="ln342">      SUM_PIXEL_EPILOGUE</a>
<a name="ln343">    }</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">#ifdef _OPENMP</a>
<a name="ln347">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln348">#endif</a>
<a name="ln349">  for(int j = 2 * mult; j &lt; height - 2 * mult; j++)</a>
<a name="ln350">  {</a>
<a name="ln351">    ROW_PROLOGUE</a>
<a name="ln352"> </a>
<a name="ln353">    /* The first &quot;2*mult&quot; pixels use the macro with tests because the 5x5 kernel</a>
<a name="ln354">     * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln355">    for(int i = 0; i &lt; 2 * mult; i++)</a>
<a name="ln356">    {</a>
<a name="ln357">      SUM_PIXEL_PROLOGUE</a>
<a name="ln358">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln359">      {</a>
<a name="ln360">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln361">        {</a>
<a name="ln362">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln363">        }</a>
<a name="ln364">      }</a>
<a name="ln365">      SUM_PIXEL_EPILOGUE</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    /* For pixels [2*mult, width-2*mult], we can safely use macro w/o tests</a>
<a name="ln369">     * to avoid unneeded branching in the inner loops */</a>
<a name="ln370">    for(int i = 2 * mult; i &lt; width - 2 * mult; i++)</a>
<a name="ln371">    {</a>
<a name="ln372">      SUM_PIXEL_PROLOGUE</a>
<a name="ln373">      px2 = ((float *)in) + (size_t)4 * (i - 2 * mult + (size_t)(j - 2 * mult) * width);</a>
<a name="ln374">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln375">      {</a>
<a name="ln376">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln377">        {</a>
<a name="ln378">          SUM_PIXEL_CONTRIBUTION_COMMON(ii, jj);</a>
<a name="ln379">          px2 += (size_t)4 * mult;</a>
<a name="ln380">        }</a>
<a name="ln381">        px2 += (size_t)4 * (width - 5) * mult;</a>
<a name="ln382">      }</a>
<a name="ln383">      SUM_PIXEL_EPILOGUE</a>
<a name="ln384">    }</a>
<a name="ln385"> </a>
<a name="ln386">    /* Last two pixels in the row require a slow variant... blablabla */</a>
<a name="ln387">    for(int i = width - 2 * mult; i &lt; width; i++)</a>
<a name="ln388">    {</a>
<a name="ln389">      SUM_PIXEL_PROLOGUE</a>
<a name="ln390">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln391">      {</a>
<a name="ln392">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln393">        {</a>
<a name="ln394">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln395">        }</a>
<a name="ln396">      }</a>
<a name="ln397">      SUM_PIXEL_EPILOGUE</a>
<a name="ln398">    }</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">/* The last &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln402"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln403">#ifdef _OPENMP</a>
<a name="ln404">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln405">#endif</a>
<a name="ln406">  for(int j = height - 2 * mult; j &lt; height; j++)</a>
<a name="ln407">  {</a>
<a name="ln408">    ROW_PROLOGUE</a>
<a name="ln409"> </a>
<a name="ln410">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln411">    {</a>
<a name="ln412">      SUM_PIXEL_PROLOGUE</a>
<a name="ln413">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln414">      {</a>
<a name="ln415">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln416">        {</a>
<a name="ln417">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln418">        }</a>
<a name="ln419">      }</a>
<a name="ln420">      SUM_PIXEL_EPILOGUE</a>
<a name="ln421">    }</a>
<a name="ln422">  }</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">#undef SUM_PIXEL_CONTRIBUTION_COMMON</a>
<a name="ln426">#undef SUM_PIXEL_CONTRIBUTION_WITH_TEST</a>
<a name="ln427">#undef ROW_PROLOGUE</a>
<a name="ln428">#undef SUM_PIXEL_PROLOGUE</a>
<a name="ln429">#undef SUM_PIXEL_EPILOGUE</a>
<a name="ln430"> </a>
<a name="ln431">#if defined(__SSE2__)</a>
<a name="ln432">static void eaw_decompose_sse2(float *const out, const float *const in, float *const detail, const int scale,</a>
<a name="ln433">                               const float sharpen, const int32_t width, const int32_t height)</a>
<a name="ln434">{</a>
<a name="ln435">  const int mult = 1 &lt;&lt; scale;</a>
<a name="ln436">  static const float filter[5] = { 1.0f / 16.0f, 4.0f / 16.0f, 6.0f / 16.0f, 4.0f / 16.0f, 1.0f / 16.0f };</a>
<a name="ln437"> </a>
<a name="ln438">/* The first &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln439"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln440">#ifdef _OPENMP</a>
<a name="ln441">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln442">#endif</a>
<a name="ln443">  for(int j = 0; j &lt; 2 * mult; j++)</a>
<a name="ln444">  {</a>
<a name="ln445">    ROW_PROLOGUE_SSE</a>
<a name="ln446"> </a>
<a name="ln447">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln448">    {</a>
<a name="ln449">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln450">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln451">      {</a>
<a name="ln452">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln453">        {</a>
<a name="ln454">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE2(ii, jj);</a>
<a name="ln455">        }</a>
<a name="ln456">      }</a>
<a name="ln457">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln458">    }</a>
<a name="ln459">  }</a>
<a name="ln460"> </a>
<a name="ln461">#ifdef _OPENMP</a>
<a name="ln462">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln463">#endif</a>
<a name="ln464">  for(int j = 2 * mult; j &lt; height - 2 * mult; j++)</a>
<a name="ln465">  {</a>
<a name="ln466">    ROW_PROLOGUE_SSE</a>
<a name="ln467"> </a>
<a name="ln468">    /* The first &quot;2*mult&quot; pixels use the macro with tests because the 5x5 kernel</a>
<a name="ln469">     * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln470">    for(int i = 0; i &lt; 2 * mult; i++)</a>
<a name="ln471">    {</a>
<a name="ln472">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln473">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln474">      {</a>
<a name="ln475">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln476">        {</a>
<a name="ln477">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE2(ii, jj);</a>
<a name="ln478">        }</a>
<a name="ln479">      }</a>
<a name="ln480">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln481">    }</a>
<a name="ln482"> </a>
<a name="ln483">    /* For pixels [2*mult, width-2*mult], we can safely use macro w/o tests</a>
<a name="ln484">     * to avoid unneeded branching in the inner loops */</a>
<a name="ln485">    for(int i = 2 * mult; i &lt; width - 2 * mult; i++)</a>
<a name="ln486">    {</a>
<a name="ln487">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln488">      px2 = ((__m128 *)in) + i - 2 * mult + (size_t)(j - 2 * mult) * width;</a>
<a name="ln489">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln490">      {</a>
<a name="ln491">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln492">        {</a>
<a name="ln493">          SUM_PIXEL_CONTRIBUTION_COMMON_SSE2(ii, jj);</a>
<a name="ln494">          px2 += mult;</a>
<a name="ln495">        }</a>
<a name="ln496">        px2 += (width - 5) * mult;</a>
<a name="ln497">      }</a>
<a name="ln498">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln499">    }</a>
<a name="ln500"> </a>
<a name="ln501">    /* Last two pixels in the row require a slow variant... blablabla */</a>
<a name="ln502">    for(int i = width - 2 * mult; i &lt; width; i++)</a>
<a name="ln503">    {</a>
<a name="ln504">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln505">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln506">      {</a>
<a name="ln507">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln508">        {</a>
<a name="ln509">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE2(ii, jj);</a>
<a name="ln510">        }</a>
<a name="ln511">      }</a>
<a name="ln512">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln513">    }</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">/* The last &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln517"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln518">#ifdef _OPENMP</a>
<a name="ln519">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln520">#endif</a>
<a name="ln521">  for(int j = height - 2 * mult; j &lt; height; j++)</a>
<a name="ln522">  {</a>
<a name="ln523">    ROW_PROLOGUE_SSE</a>
<a name="ln524"> </a>
<a name="ln525">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln526">    {</a>
<a name="ln527">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln528">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln529">      {</a>
<a name="ln530">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln531">        {</a>
<a name="ln532">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE2(ii, jj);</a>
<a name="ln533">        }</a>
<a name="ln534">      }</a>
<a name="ln535">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln536">    }</a>
<a name="ln537">  }</a>
<a name="ln538"> </a>
<a name="ln539">  _mm_sfence();</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">#undef SUM_PIXEL_CONTRIBUTION_COMMON_SSE2</a>
<a name="ln543">#undef SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE2</a>
<a name="ln544">#undef ROW_PROLOGUE_SSE</a>
<a name="ln545">#undef SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln546">#undef SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln547">#endif</a>
<a name="ln548"> </a>
<a name="ln549">typedef void((*eaw_synthesize_t)(float *const out, const float *const in, const float *const detail,</a>
<a name="ln550">                                 const float *thrsf, const float *boostf, const int32_t width,</a>
<a name="ln551">                                 const int32_t height));</a>
<a name="ln552"> </a>
<a name="ln553">static void eaw_synthesize(float *const out, const float *const in, const float *const detail,</a>
<a name="ln554">                           const float *thrsf, const float *boostf, const int32_t width, const int32_t height)</a>
<a name="ln555">{</a>
<a name="ln556">  const float threshold[4] = { thrsf[0], thrsf[1], thrsf[2], thrsf[3] };</a>
<a name="ln557">  const float boost[4] = { boostf[0], boostf[1], boostf[2], boostf[3] };</a>
<a name="ln558"> </a>
<a name="ln559">#ifdef _OPENMP</a>
<a name="ln560">#pragma omp parallel for SIMD() default(none) schedule(static) collapse(2)</a>
<a name="ln561">#endif</a>
<a name="ln562">  for(size_t k = 0; k &lt; (size_t)4 * width * height; k += 4)</a>
<a name="ln563">  {</a>
<a name="ln564">    for(size_t c = 0; c &lt; 4; c++)</a>
<a name="ln565">    {</a>
<a name="ln566">      const float absamt = fmaxf(0.0f, (fabsf(detail[k + c]) - threshold[c]));</a>
<a name="ln567">      const float amount = copysignf(absamt, detail[k + c]);</a>
<a name="ln568">      out[k + c] = in[k + c] + (boost[c] * amount);</a>
<a name="ln569">    }</a>
<a name="ln570">  }</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">#if defined(__SSE2__)</a>
<a name="ln574">static void eaw_synthesize_sse2(float *const out, const float *const in, const float *const detail,</a>
<a name="ln575">                                const float *thrsf, const float *boostf, const int32_t width,</a>
<a name="ln576">                                const int32_t height)</a>
<a name="ln577">{</a>
<a name="ln578">  const __m128 threshold = _mm_set_ps(thrsf[3], thrsf[2], thrsf[1], thrsf[0]);</a>
<a name="ln579">  const __m128 boost = _mm_set_ps(boostf[3], boostf[2], boostf[1], boostf[0]);</a>
<a name="ln580"> </a>
<a name="ln581">#ifdef _OPENMP</a>
<a name="ln582">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln583">#endif</a>
<a name="ln584">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln585">  {</a>
<a name="ln586">    // TODO: prefetch? _mm_prefetch()</a>
<a name="ln587">    const __m128 *pin = (__m128 *)in + (size_t)j * width;</a>
<a name="ln588">    __m128 *pdetail = (__m128 *)detail + (size_t)j * width;</a>
<a name="ln589">    float *pout = out + (size_t)4 * j * width;</a>
<a name="ln590">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln591">    {</a>
<a name="ln592">      const __m128i maski = _mm_set1_epi32(0x80000000u);</a>
<a name="ln593">      const __m128 *mask = (__m128 *)&amp;maski;</a>
<a name="ln594">      const __m128 absamt</a>
<a name="ln595">          = _mm_max_ps(_mm_setzero_ps(), _mm_sub_ps(_mm_andnot_ps(*mask, *pdetail), threshold));</a>
<a name="ln596">      const __m128 amount = _mm_or_ps(_mm_and_ps(*pdetail, *mask), absamt);</a>
<a name="ln597">      _mm_stream_ps(pout, _mm_add_ps(*pin, _mm_mul_ps(boost, amount)));</a>
<a name="ln598">      pdetail++;</a>
<a name="ln599">      pin++;</a>
<a name="ln600">      pout += 4;</a>
<a name="ln601">    }</a>
<a name="ln602">  }</a>
<a name="ln603">  _mm_sfence();</a>
<a name="ln604">}</a>
<a name="ln605">#endif</a>
<a name="ln606"> </a>
<a name="ln607">static int get_samples(float *t, const dt_iop_atrous_data_t *const d, const dt_iop_roi_t *roi_in,</a>
<a name="ln608">                       const dt_dev_pixelpipe_iop_t *const piece)</a>
<a name="ln609">{</a>
<a name="ln610">  const float scale = roi_in-&gt;scale;</a>
<a name="ln611">  const float supp0</a>
<a name="ln612">      = MIN(2 * (2 &lt;&lt; (MAX_NUM_SCALES - 1)) + 1, MAX(piece-&gt;buf_in.height, piece-&gt;buf_in.width) * 0.2f);</a>
<a name="ln613">  const float i0 = dt_log2f((supp0 - 1.0f) * .5f);</a>
<a name="ln614">  int i = 0;</a>
<a name="ln615">  for(; i &lt; MAX_NUM_SCALES; i++)</a>
<a name="ln616">  {</a>
<a name="ln617">    // actual filter support on scaled buffer</a>
<a name="ln618">    const float supp = 2 * (2 &lt;&lt; i) + 1;</a>
<a name="ln619">    // approximates this filter size on unscaled input image:</a>
<a name="ln620">    const float supp_in = supp * (1.0f / scale);</a>
<a name="ln621">    const float i_in = dt_log2f((supp_in - 1) * .5f) - 1.0f;</a>
<a name="ln622">    t[i] = 1.0f - (i_in + .5f) / i0;</a>
<a name="ln623">    if(t[i] &lt; 0.0f) break;</a>
<a name="ln624">  }</a>
<a name="ln625">  return i;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">static int get_scales(float (*thrs)[4], float (*boost)[4], float *sharp, const dt_iop_atrous_data_t *const d,</a>
<a name="ln629">                      const dt_iop_roi_t *roi_in, const dt_dev_pixelpipe_iop_t *const piece)</a>
<a name="ln630">{</a>
<a name="ln631">  // we want coeffs to span max 20% of the image</a>
<a name="ln632">  // finest is 5x5 filter</a>
<a name="ln633">  //</a>
<a name="ln634">  // 1:1 : w=20% buf_in.width                     w=5x5</a>
<a name="ln635">  //     : ^ ...            ....            ....  ^</a>
<a name="ln636">  // buf :  17x17  9x9  5x5     2*2^k+1</a>
<a name="ln637">  // .....</a>
<a name="ln638">  // . . . . .</a>
<a name="ln639">  // .   .   .   .   .</a>
<a name="ln640">  // cut off too fine ones, if image is not detailed enough (due to roi_in-&gt;scale)</a>
<a name="ln641">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln642">  // largest desired filter on input buffer (20% of input dim)</a>
<a name="ln643">  const float supp0</a>
<a name="ln644">      = MIN(2 * (2 &lt;&lt; (MAX_NUM_SCALES - 1)) + 1,</a>
<a name="ln645">            MAX(piece-&gt;buf_in.height * piece-&gt;iscale, piece-&gt;buf_in.width * piece-&gt;iscale) * 0.2f);</a>
<a name="ln646">  const float i0 = dt_log2f((supp0 - 1.0f) * .5f);</a>
<a name="ln647">  int i = 0;</a>
<a name="ln648">  for(; i &lt; MAX_NUM_SCALES; i++)</a>
<a name="ln649">  {</a>
<a name="ln650">    // actual filter support on scaled buffer</a>
<a name="ln651">    const float supp = 2 * (2 &lt;&lt; i) + 1;</a>
<a name="ln652">    // approximates this filter size on unscaled input image:</a>
<a name="ln653">    const float supp_in = supp * (1.0f / scale);</a>
<a name="ln654">    const float i_in = dt_log2f((supp_in - 1) * .5f) - 1.0f;</a>
<a name="ln655">    // i_in = max_scale .. .. .. 0</a>
<a name="ln656">    const float t = 1.0f - (i_in + .5f) / i0;</a>
<a name="ln657">    boost[i][3] = boost[i][0] = 2.0f * dt_draw_curve_calc_value(d-&gt;curve[atrous_L], t);</a>
<a name="ln658">    boost[i][1] = boost[i][2] = 2.0f * dt_draw_curve_calc_value(d-&gt;curve[atrous_c], t);</a>
<a name="ln659">    for(int k = 0; k &lt; 4; k++) boost[i][k] *= boost[i][k];</a>
<a name="ln660">    thrs[i][0] = thrs[i][3] = powf(2.0f, -7.0f * (1.0f - t)) * 10.0f</a>
<a name="ln661">                              * dt_draw_curve_calc_value(d-&gt;curve[atrous_Lt], t);</a>
<a name="ln662">    thrs[i][1] = thrs[i][2] = powf(2.0f, -7.0f * (1.0f - t)) * 20.0f</a>
<a name="ln663">                              * dt_draw_curve_calc_value(d-&gt;curve[atrous_ct], t);</a>
<a name="ln664">    sharp[i] = 0.0025f * dt_draw_curve_calc_value(d-&gt;curve[atrous_s], t);</a>
<a name="ln665">    // printf(&quot;scale %d boost %f %f thrs %f %f sharpen %f\n&quot;, i, boost[i][0], boost[i][2], thrs[i][0],</a>
<a name="ln666">    // thrs[i][1], sharp[i]);</a>
<a name="ln667">    if(t &lt; 0.0f) break;</a>
<a name="ln668">  }</a>
<a name="ln669">  // ensure that return value max_scale is such that</a>
<a name="ln670">  // 2 * 2 *(1 &lt;&lt; max_scale) &lt;= min(width, height)</a>
<a name="ln671">  const int max_scale_roi = (int)floorf(dt_log2f((float)MIN(roi_in-&gt;width, roi_in-&gt;height))) - 2;</a>
<a name="ln672">  return MIN(max_scale_roi, i);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">/* just process the supplied image buffer, upstream default_process_tiling() does the rest */</a>
<a name="ln676">static void process_wavelets(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln677">                             const void *const i, void *const o, const dt_iop_roi_t *const roi_in,</a>
<a name="ln678">                             const dt_iop_roi_t *const roi_out, const eaw_decompose_t decompose,</a>
<a name="ln679">                             const eaw_synthesize_t synthesize)</a>
<a name="ln680">{</a>
<a name="ln681">  dt_iop_atrous_data_t *d = (dt_iop_atrous_data_t *)piece-&gt;data;</a>
<a name="ln682">  float thrs[MAX_NUM_SCALES][4];</a>
<a name="ln683">  float boost[MAX_NUM_SCALES][4];</a>
<a name="ln684">  float sharp[MAX_NUM_SCALES];</a>
<a name="ln685">  const int max_scale = get_scales(thrs, boost, sharp, d, roi_in, piece);</a>
<a name="ln686"> </a>
<a name="ln687">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln688">  {</a>
<a name="ln689">    dt_iop_atrous_gui_data_t *g = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln690">    g-&gt;num_samples = get_samples(g-&gt;sample, d, roi_in, piece);</a>
<a name="ln691">    // tries to acquire gdk lock and this prone to deadlock:</a>
<a name="ln692">    // dt_control_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695">  float *detail[MAX_NUM_SCALES] = { NULL };</a>
<a name="ln696">  float *tmp = NULL;</a>
<a name="ln697">  float *buf2 = NULL;</a>
<a name="ln698">  float *buf1 = NULL;</a>
<a name="ln699"> </a>
<a name="ln700">  const int width = roi_out-&gt;width;</a>
<a name="ln701">  const int height = roi_out-&gt;height;</a>
<a name="ln702"> </a>
<a name="ln703">  tmp = (float *)dt_alloc_align(64, (size_t)sizeof(float) * 4 * width * height);</a>
<a name="ln704">  if(tmp == NULL)</a>
<a name="ln705">  {</a>
<a name="ln706">    fprintf(stderr, &quot;[atrous] failed to allocate coarse buffer!\n&quot;);</a>
<a name="ln707">    goto error;</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln711">  {</a>
<a name="ln712">    detail[k] = (float *)dt_alloc_align(64, (size_t)sizeof(float) * 4 * width * height);</a>
<a name="ln713">    if(detail[k] == NULL)</a>
<a name="ln714">    {</a>
<a name="ln715">      fprintf(stderr, &quot;[atrous] failed to allocate one of the detail buffers!\n&quot;);</a>
<a name="ln716">      goto error;</a>
<a name="ln717">    }</a>
<a name="ln718">  }</a>
<a name="ln719"> </a>
<a name="ln720">  buf1 = (float *)i;</a>
<a name="ln721">  buf2 = tmp;</a>
<a name="ln722"> </a>
<a name="ln723">  for(int scale = 0; scale &lt; max_scale; scale++)</a>
<a name="ln724">  {</a>
<a name="ln725">    decompose(buf2, buf1, detail[scale], scale, sharp[scale], width, height);</a>
<a name="ln726">    if(scale == 0) buf1 = (float *)o; // now switch to (float *)o for buffer ping-pong between buf1 and buf2</a>
<a name="ln727">    float *buf3 = buf2;</a>
<a name="ln728">    buf2 = buf1;</a>
<a name="ln729">    buf1 = buf3;</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  for(int scale = max_scale - 1; scale &gt;= 0; scale--)</a>
<a name="ln733">  {</a>
<a name="ln734">    synthesize(buf2, buf1, detail[scale], thrs[scale], boost[scale], width, height);</a>
<a name="ln735">    float *buf3 = buf2;</a>
<a name="ln736">    buf2 = buf1;</a>
<a name="ln737">    buf1 = buf3;</a>
<a name="ln738">  }</a>
<a name="ln739">  /* due to symmetric processing, output will be left in (float *)o */</a>
<a name="ln740"> </a>
<a name="ln741">  for(int k = 0; k &lt; max_scale; k++) dt_free_align(detail[k]);</a>
<a name="ln742">  dt_free_align(tmp);</a>
<a name="ln743"> </a>
<a name="ln744">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(i, o, width, height);</a>
<a name="ln745"> </a>
<a name="ln746">  return;</a>
<a name="ln747"> </a>
<a name="ln748">error:</a>
<a name="ln749">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln750">    if(detail[k] != NULL) dt_free_align(detail[k]);</a>
<a name="ln751">  if(tmp != NULL) dt_free_align(tmp);</a>
<a name="ln752">  return;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">void process(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const void *const i,</a>
<a name="ln756">             void *const o, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln757">{</a>
<a name="ln758">  process_wavelets(self, piece, i, o, roi_in, roi_out, eaw_decompose, eaw_synthesize);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">#if defined(__SSE2__)</a>
<a name="ln762">void process_sse2(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const void *const i,</a>
<a name="ln763">                  void *const o, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln764">{</a>
<a name="ln765">  process_wavelets(self, piece, i, o, roi_in, roi_out, eaw_decompose_sse2, eaw_synthesize_sse2);</a>
<a name="ln766">}</a>
<a name="ln767">#endif</a>
<a name="ln768"> </a>
<a name="ln769">#ifdef HAVE_OPENCL</a>
<a name="ln770">/* this version is adapted to the new global tiling mechanism. it no longer does tiling by itself. */</a>
<a name="ln771">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln772">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln773">{</a>
<a name="ln774">  dt_iop_atrous_data_t *d = (dt_iop_atrous_data_t *)piece-&gt;data;</a>
<a name="ln775">  float thrs[MAX_NUM_SCALES][4];</a>
<a name="ln776">  float boost[MAX_NUM_SCALES][4];</a>
<a name="ln777">  float sharp[MAX_NUM_SCALES];</a>
<a name="ln778">  const int max_scale = get_scales(thrs, boost, sharp, d, roi_in, piece);</a>
<a name="ln779"> </a>
<a name="ln780">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln781">  {</a>
<a name="ln782">    dt_iop_atrous_gui_data_t *g = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln783">    g-&gt;num_samples = get_samples(g-&gt;sample, d, roi_in, piece);</a>
<a name="ln784">    // dt_control_queue_redraw_widget(GTK_WIDGET(g-&gt;area));</a>
<a name="ln785">    // tries to acquire gdk lock and this prone to deadlock:</a>
<a name="ln786">    // dt_control_queue_draw(GTK_WIDGET(g-&gt;area));</a>
<a name="ln787">  }</a>
<a name="ln788"> </a>
<a name="ln789">  dt_iop_atrous_global_data_t *gd = (dt_iop_atrous_global_data_t *)self-&gt;data;</a>
<a name="ln790"> </a>
<a name="ln791">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln792">  cl_int err = -999;</a>
<a name="ln793">  cl_mem dev_filter = NULL;</a>
<a name="ln794">  cl_mem dev_tmp = NULL;</a>
<a name="ln795">  cl_mem *dev_detail = calloc(max_scale, sizeof(cl_mem));</a>
<a name="ln796"> </a>
<a name="ln797">  float m[] = { 0.0625f, 0.25f, 0.375f, 0.25f, 0.0625f }; // 1/16, 4/16, 6/16, 4/16, 1/16</a>
<a name="ln798">  float mm[5][5];</a>
<a name="ln799">  for(int j = 0; j &lt; 5; j++)</a>
<a name="ln800">    for(int i = 0; i &lt; 5; i++) mm[j][i] = m[i] * m[j];</a>
<a name="ln801"> </a>
<a name="ln802">  dev_filter = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 25, mm);</a>
<a name="ln803">  if(dev_filter == NULL) goto error;</a>
<a name="ln804"> </a>
<a name="ln805">  /* allocate space for a temporary buffer. we don't want to use dev_in in the buffer ping-pong below, as we</a>
<a name="ln806">     need to keep it for blendops */</a>
<a name="ln807">  dev_tmp = dt_opencl_alloc_device(devid, roi_out-&gt;width, roi_out-&gt;height, 4 * sizeof(float));</a>
<a name="ln808">  if(dev_tmp == NULL) goto error;</a>
<a name="ln809"> </a>
<a name="ln810">  /* allocate space to store detail information. Requires a number of additional buffers, each with full image</a>
<a name="ln811">   * size */</a>
<a name="ln812">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln813">  {</a>
<a name="ln814">    dev_detail[k] = dt_opencl_alloc_device(devid, roi_out-&gt;width, roi_out-&gt;height, 4 * sizeof(float));</a>
<a name="ln815">    if(dev_detail[k] == NULL) goto error;</a>
<a name="ln816">  }</a>
<a name="ln817"> </a>
<a name="ln818">  const int width = roi_out-&gt;width;</a>
<a name="ln819">  const int height = roi_out-&gt;height;</a>
<a name="ln820">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln821">  size_t origin[] = { 0, 0, 0 };</a>
<a name="ln822">  size_t region[] = { width, height, 1 };</a>
<a name="ln823"> </a>
<a name="ln824">  // copy original input from dev_in -&gt; dev_out as starting point</a>
<a name="ln825">  err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_out, origin, origin, region);</a>
<a name="ln826">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln827"> </a>
<a name="ln828">  /* decompose image into detail scales and coarse (the latter is left in dev_tmp or dev_out) */</a>
<a name="ln829">  for(int s = 0; s &lt; max_scale; s++)</a>
<a name="ln830">  {</a>
<a name="ln831">    const int scale = s;</a>
<a name="ln832"> </a>
<a name="ln833">    if(s &amp; 1)</a>
<a name="ln834">    {</a>
<a name="ln835">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln836">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln837">    }</a>
<a name="ln838">    else</a>
<a name="ln839">    {</a>
<a name="ln840">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 0, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln841">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln842">    }</a>
<a name="ln843">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 2, sizeof(cl_mem), (void *)&amp;dev_detail[s]);</a>
<a name="ln844">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln845">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln846">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 5, sizeof(unsigned int), (void *)&amp;scale);</a>
<a name="ln847">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 6, sizeof(float), (void *)&amp;sharp[s]);</a>
<a name="ln848">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_decompose, 7, sizeof(cl_mem), (void *)&amp;dev_filter);</a>
<a name="ln849"> </a>
<a name="ln850">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_decompose, sizes);</a>
<a name="ln851">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln852"> </a>
<a name="ln853">    // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln854">    dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln855">  }</a>
<a name="ln856"> </a>
<a name="ln857">  /* now synthesize again */</a>
<a name="ln858">  for(int scale = max_scale - 1; scale &gt;= 0; scale--)</a>
<a name="ln859">  {</a>
<a name="ln860">    if(scale &amp; 1)</a>
<a name="ln861">    {</a>
<a name="ln862">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln863">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln864">    }</a>
<a name="ln865">    else</a>
<a name="ln866">    {</a>
<a name="ln867">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 0, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln868">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln869">    }</a>
<a name="ln870"> </a>
<a name="ln871">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 2, sizeof(cl_mem), (void *)&amp;dev_detail[scale]);</a>
<a name="ln872">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln873">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln874">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 5, sizeof(float), (void *)&amp;thrs[scale][0]);</a>
<a name="ln875">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 6, sizeof(float), (void *)&amp;thrs[scale][1]);</a>
<a name="ln876">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 7, sizeof(float), (void *)&amp;thrs[scale][2]);</a>
<a name="ln877">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 8, sizeof(float), (void *)&amp;thrs[scale][3]);</a>
<a name="ln878">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 9, sizeof(float), (void *)&amp;boost[scale][0]);</a>
<a name="ln879">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 10, sizeof(float), (void *)&amp;boost[scale][1]);</a>
<a name="ln880">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 11, sizeof(float), (void *)&amp;boost[scale][2]);</a>
<a name="ln881">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_synthesize, 12, sizeof(float), (void *)&amp;boost[scale][3]);</a>
<a name="ln882"> </a>
<a name="ln883">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_synthesize, sizes);</a>
<a name="ln884">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln885"> </a>
<a name="ln886">    // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln887">    dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln891">    dt_opencl_finish(devid);</a>
<a name="ln892"> </a>
<a name="ln893">  dt_opencl_release_mem_object(dev_filter);</a>
<a name="ln894">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln895">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln896">    dt_opencl_release_mem_object(dev_detail[k]);</a>
<a name="ln897">  free(dev_detail);</a>
<a name="ln898">  return TRUE;</a>
<a name="ln899"> </a>
<a name="ln900">error:</a>
<a name="ln901">  dt_opencl_release_mem_object(dev_filter);</a>
<a name="ln902">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln903">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln904">    dt_opencl_release_mem_object(dev_detail[k]);</a>
<a name="ln905">  free(dev_detail);</a>
<a name="ln906">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_atrous] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln907">  return FALSE;</a>
<a name="ln908">}</a>
<a name="ln909">#endif</a>
<a name="ln910"> </a>
<a name="ln911">void tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln912">                     const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln913">                     struct dt_develop_tiling_t *tiling)</a>
<a name="ln914">{</a>
<a name="ln915">  dt_iop_atrous_data_t *d = (dt_iop_atrous_data_t *)piece-&gt;data;</a>
<a name="ln916">  float thrs[MAX_NUM_SCALES][4];</a>
<a name="ln917">  float boost[MAX_NUM_SCALES][4];</a>
<a name="ln918">  float sharp[MAX_NUM_SCALES];</a>
<a name="ln919">  const int max_scale = get_scales(thrs, boost, sharp, d, roi_in, piece);</a>
<a name="ln920">  const int max_filter_radius = 2 * (1 &lt;&lt; max_scale); // 2 * 2^max_scale</a>
<a name="ln921"> </a>
<a name="ln922">  tiling-&gt;factor = 3.0f + max_scale; // in + out + tmp + scale buffers</a>
<a name="ln923">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln924">  tiling-&gt;overhead = 0;</a>
<a name="ln925">  tiling-&gt;overlap = max_filter_radius;</a>
<a name="ln926">  tiling-&gt;xalign = 1;</a>
<a name="ln927">  tiling-&gt;yalign = 1;</a>
<a name="ln928">  return;</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">void init(dt_iop_module_t *module)</a>
<a name="ln932">{</a>
<a name="ln933">  module-&gt;params = calloc(1, sizeof(dt_iop_atrous_params_t));</a>
<a name="ln934">  module-&gt;default_params = calloc(1, sizeof(dt_iop_atrous_params_t));</a>
<a name="ln935">  module-&gt;default_enabled = 0;</a>
<a name="ln936">  module-&gt;priority = 571; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln937">  module-&gt;params_size = sizeof(dt_iop_atrous_params_t);</a>
<a name="ln938">  module-&gt;gui_data = NULL;</a>
<a name="ln939">  dt_iop_atrous_params_t tmp;</a>
<a name="ln940">  tmp.octaves = 3;</a>
<a name="ln941">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln942">  {</a>
<a name="ln943">    tmp.y[atrous_L][k] = tmp.y[atrous_s][k] = tmp.y[atrous_c][k] = 0.5f;</a>
<a name="ln944">    tmp.x[atrous_L][k] = tmp.x[atrous_s][k] = tmp.x[atrous_c][k] = k / (BANDS - 1.0f);</a>
<a name="ln945">    tmp.y[atrous_Lt][k] = tmp.y[atrous_ct][k] = 0.0f;</a>
<a name="ln946">    tmp.x[atrous_Lt][k] = tmp.x[atrous_ct][k] = k / (BANDS - 1.0f);</a>
<a name="ln947">  }</a>
<a name="ln948">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_atrous_params_t));</a>
<a name="ln949">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_atrous_params_t));</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln953">{</a>
<a name="ln954">  const int program = 1; // from programs.conf</a>
<a name="ln955">  dt_iop_atrous_global_data_t *gd</a>
<a name="ln956">      = (dt_iop_atrous_global_data_t *)malloc(sizeof(dt_iop_atrous_global_data_t));</a>
<a name="ln957">  module-&gt;data = gd;</a>
<a name="ln958">  gd-&gt;kernel_decompose = dt_opencl_create_kernel(program, &quot;eaw_decompose&quot;);</a>
<a name="ln959">  gd-&gt;kernel_synthesize = dt_opencl_create_kernel(program, &quot;eaw_synthesize&quot;);</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">void cleanup(dt_iop_module_t *module)</a>
<a name="ln963">{</a>
<a name="ln964">  free(module-&gt;params);</a>
<a name="ln965">  module-&gt;params = NULL;</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln969">{</a>
<a name="ln970">  dt_iop_atrous_global_data_t *gd = (dt_iop_atrous_global_data_t *)module-&gt;data;</a>
<a name="ln971">  dt_opencl_free_kernel(gd-&gt;kernel_decompose);</a>
<a name="ln972">  dt_opencl_free_kernel(gd-&gt;kernel_synthesize);</a>
<a name="ln973">  free(module-&gt;data);</a>
<a name="ln974">  module-&gt;data = NULL;</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln978">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln979">{</a>
<a name="ln980">  dt_iop_atrous_params_t *p = (dt_iop_atrous_params_t *)params;</a>
<a name="ln981">  dt_iop_atrous_data_t *d = (dt_iop_atrous_data_t *)piece-&gt;data;</a>
<a name="ln982">#if 0</a>
<a name="ln983">  printf(&quot;---------- atrous preset begin\n&quot;);</a>
<a name="ln984">  printf(&quot;p.octaves = %d;\n&quot;, p-&gt;octaves);</a>
<a name="ln985">  for(int ch=0; ch&lt;atrous_none; ch++) for(int k=0; k&lt;BANDS; k++)</a>
<a name="ln986">    {</a>
<a name="ln987">      printf(&quot;p.x[%d][%d] = %f;\n&quot;, ch, k, p-&gt;x[ch][k]);</a>
<a name="ln988">      printf(&quot;p.y[%d][%d] = %f;\n&quot;, ch, k, p-&gt;y[ch][k]);</a>
<a name="ln989">    }</a>
<a name="ln990">  printf(&quot;---------- atrous preset end\n&quot;);</a>
<a name="ln991">#endif</a>
<a name="ln992">  d-&gt;octaves = p-&gt;octaves;</a>
<a name="ln993">  for(int ch = 0; ch &lt; atrous_none; ch++)</a>
<a name="ln994">    for(int k = 0; k &lt; BANDS; k++) dt_draw_curve_set_point(d-&gt;curve[ch], k, p-&gt;x[ch][k], p-&gt;y[ch][k]);</a>
<a name="ln995">  int l = 0;</a>
<a name="ln996">  for(int k = (int)MIN(pipe-&gt;iwidth * pipe-&gt;iscale, pipe-&gt;iheight * pipe-&gt;iscale); k; k &gt;&gt;= 1) l++;</a>
<a name="ln997">  d-&gt;octaves = MIN(BANDS, l);</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1001">{</a>
<a name="ln1002">  dt_iop_atrous_data_t *d = (dt_iop_atrous_data_t *)malloc(sizeof(dt_iop_atrous_data_t));</a>
<a name="ln1003">  dt_iop_atrous_params_t *default_params = (dt_iop_atrous_params_t *)self-&gt;default_params;</a>
<a name="ln1004">  piece-&gt;data = (void *)d;</a>
<a name="ln1005">  for(int ch = 0; ch &lt; atrous_none; ch++)</a>
<a name="ln1006">  {</a>
<a name="ln1007">    d-&gt;curve[ch] = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln1008">    for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1009">      (void)dt_draw_curve_add_point(d-&gt;curve[ch], default_params-&gt;x[ch][k], default_params-&gt;y[ch][k]);</a>
<a name="ln1010">  }</a>
<a name="ln1011">  int l = 0;</a>
<a name="ln1012">  for(int k = (int)MIN(pipe-&gt;iwidth * pipe-&gt;iscale, pipe-&gt;iheight * pipe-&gt;iscale); k; k &gt;&gt;= 1) l++;</a>
<a name="ln1013">  d-&gt;octaves = MIN(BANDS, l);</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1017">{</a>
<a name="ln1018">  dt_iop_atrous_data_t *d = (dt_iop_atrous_data_t *)(piece-&gt;data);</a>
<a name="ln1019">  for(int ch = 0; ch &lt; atrous_none; ch++) dt_draw_curve_destroy(d-&gt;curve[ch]);</a>
<a name="ln1020">  free(piece-&gt;data);</a>
<a name="ln1021">  piece-&gt;data = NULL;</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">#define GAUSS(x, sigma) expf( -(1.0f - x) * (1.0f - x) / (sigma * sigma)) / (2.0 * sigma * powf(M_PI, 0.5f))</a>
<a name="ln1025"> </a>
<a name="ln1026">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln1027">{</a>
<a name="ln1028">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln1029">  dt_iop_atrous_params_t p;</a>
<a name="ln1030">  p.octaves = 7;</a>
<a name="ln1031"> </a>
<a name="ln1032">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1033">  {</a>
<a name="ln1034">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1035">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1036">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1037">    p.y[atrous_L][k] = fmaxf(.5f, .75f - .5f * k / (BANDS - 1.0));</a>
<a name="ln1038">    p.y[atrous_c][k] = fmaxf(.5f, .55f - .5f * k / (BANDS - 1.0));</a>
<a name="ln1039">    p.y[atrous_s][k] = fminf(.5f, .2f + .35f * k / (BANDS - 1.0));</a>
<a name="ln1040">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1041">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1042">    p.y[atrous_Lt][k] = 0.0f;</a>
<a name="ln1043">    p.y[atrous_ct][k] = 0.0f;</a>
<a name="ln1044">  }</a>
<a name="ln1045">  dt_gui_presets_add_generic(C_(&quot;eq_preset&quot;, &quot;coarse&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1046">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1047">  {</a>
<a name="ln1048">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1049">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1050">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1051">    p.y[atrous_L][k] = .5f + .25f * k / (float)BANDS;</a>
<a name="ln1052">    p.y[atrous_c][k] = .5f;</a>
<a name="ln1053">    p.y[atrous_s][k] = .5f;</a>
<a name="ln1054">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1055">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1056">    p.y[atrous_Lt][k] = .2f * k / (float)BANDS;</a>
<a name="ln1057">    p.y[atrous_ct][k] = .3f * k / (float)BANDS;</a>
<a name="ln1058">  }</a>
<a name="ln1059">  dt_gui_presets_add_generic(_(&quot;denoise &amp; sharpen&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1060">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1061">  {</a>
<a name="ln1062">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1063">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1064">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1065">    p.y[atrous_L][k] = .5f + .25f * k / (float)BANDS;</a>
<a name="ln1066">    p.y[atrous_c][k] = .5f;</a>
<a name="ln1067">    p.y[atrous_s][k] = .5f;</a>
<a name="ln1068">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1069">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1070">    p.y[atrous_Lt][k] = 0.0f;</a>
<a name="ln1071">    p.y[atrous_ct][k] = 0.0f;</a>
<a name="ln1072">  }</a>
<a name="ln1073">  dt_gui_presets_add_generic(C_(&quot;atrous&quot;, &quot;sharpen&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1074">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1075">  {</a>
<a name="ln1076">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1077">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1078">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1079">    p.y[atrous_L][k] = .5f;</a>
<a name="ln1080">    p.y[atrous_c][k] = .5f;</a>
<a name="ln1081">    p.y[atrous_s][k] = .0f;</a>
<a name="ln1082">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1083">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1084">    p.y[atrous_Lt][k] = .0f;</a>
<a name="ln1085">    p.y[atrous_ct][k] = fmaxf(0.0f, (.60f * k / (float)BANDS) - 0.30f);</a>
<a name="ln1086">  }</a>
<a name="ln1087">  dt_gui_presets_add_generic(_(&quot;denoise chroma&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1088">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1089">  {</a>
<a name="ln1090">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1091">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1092">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1093">    p.y[atrous_L][k] = .5f; //-.2f*k/(float)BANDS;</a>
<a name="ln1094">    p.y[atrous_c][k] = .5f; // fmaxf(0.0f, .5f-.3f*k/(float)BANDS);</a>
<a name="ln1095">    p.y[atrous_s][k] = .5f;</a>
<a name="ln1096">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1097">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1098">    p.y[atrous_Lt][k] = .2f * k / (float)BANDS;</a>
<a name="ln1099">    p.y[atrous_ct][k] = .3f * k / (float)BANDS;</a>
<a name="ln1100">  }</a>
<a name="ln1101">  dt_gui_presets_add_generic(_(&quot;denoise&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1102">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1103">  {</a>
<a name="ln1104">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1105">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1106">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1107">    p.y[atrous_L][k] = fminf(.5f, .3f + .35f * k / (BANDS - 1.0));</a>
<a name="ln1108">    p.y[atrous_c][k] = .5f;</a>
<a name="ln1109">    p.y[atrous_s][k] = .0f;</a>
<a name="ln1110">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1111">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1112">    p.y[atrous_Lt][k] = 0.0f;</a>
<a name="ln1113">    p.y[atrous_ct][k] = 0.0f;</a>
<a name="ln1114">  }</a>
<a name="ln1115">  p.y[atrous_L][0] = .5f;</a>
<a name="ln1116">  dt_gui_presets_add_generic(_(&quot;bloom&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1117">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1118">  {</a>
<a name="ln1119">    p.x[atrous_L][k] = k / (BANDS - 1.0);</a>
<a name="ln1120">    p.x[atrous_c][k] = k / (BANDS - 1.0);</a>
<a name="ln1121">    p.x[atrous_s][k] = k / (BANDS - 1.0);</a>
<a name="ln1122">    p.y[atrous_L][k] = 0.6f;</a>
<a name="ln1123">    p.y[atrous_c][k] = .55f;</a>
<a name="ln1124">    p.y[atrous_s][k] = .0f;</a>
<a name="ln1125">    p.x[atrous_Lt][k] = k / (BANDS - 1.0);</a>
<a name="ln1126">    p.x[atrous_ct][k] = k / (BANDS - 1.0);</a>
<a name="ln1127">    p.y[atrous_Lt][k] = 0.0f;</a>
<a name="ln1128">    p.y[atrous_ct][k] = 0.0f;</a>
<a name="ln1129">  }</a>
<a name="ln1130">  dt_gui_presets_add_generic(_(&quot;clarity&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1131"> </a>
<a name="ln1132">  float sigma = 1 / (BANDS - 1.0);</a>
<a name="ln1133"> </a>
<a name="ln1134">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1135">  {</a>
<a name="ln1136">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1137">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1138">    float medium = GAUSS(x, sigma);</a>
<a name="ln1139">    float coarse = GAUSS(x, 2 * sigma);</a>
<a name="ln1140">    float coeff = 0.5f + (coarse + medium + fine) / 18.0f;</a>
<a name="ln1141">    float noise = (coarse + medium + fine) / 810;</a>
<a name="ln1142"> </a>
<a name="ln1143">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1144">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1145">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1146">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1147">  }</a>
<a name="ln1148">  dt_gui_presets_add_generic(_(&quot;deblur: large blur, strength 4&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1149"> </a>
<a name="ln1150">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1151">  {</a>
<a name="ln1152">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1153">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1154">    float medium = GAUSS(x, sigma);</a>
<a name="ln1155">    float coarse = GAUSS(x, 2 * sigma);</a>
<a name="ln1156">    float coeff = 0.5f + (coarse + medium + fine) / 24.0f;</a>
<a name="ln1157">    float noise = (coarse + medium + fine) / 1080;</a>
<a name="ln1158"> </a>
<a name="ln1159">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1160">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1161">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1162">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1163">  }</a>
<a name="ln1164">  dt_gui_presets_add_generic(_(&quot;deblur: large blur, strength 3&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1165">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1166">  {</a>
<a name="ln1167">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1168">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1169">    float medium = GAUSS(x, sigma);</a>
<a name="ln1170">    float coeff = 0.5f + (medium + fine) / 21.0f;</a>
<a name="ln1171">    float noise = (medium + fine) / 720;</a>
<a name="ln1172"> </a>
<a name="ln1173">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1174">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1175">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1176">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1177">  }</a>
<a name="ln1178">  dt_gui_presets_add_generic(_(&quot;deblur: medium blur, strength 3&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1179">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1180">  {</a>
<a name="ln1181">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1182">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1183">    float coeff = 0.5f + fine / 14.25f;</a>
<a name="ln1184">    float noise = fine / 360;</a>
<a name="ln1185"> </a>
<a name="ln1186">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1187">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1188">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1189">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1190">  }</a>
<a name="ln1191">  dt_gui_presets_add_generic(_(&quot;deblur: fine blur, strength 3&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1195">  {</a>
<a name="ln1196">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1197">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1198">    float medium = GAUSS(x, sigma);</a>
<a name="ln1199">    float coarse = GAUSS(x, 2 * sigma);</a>
<a name="ln1200">    float coeff = 0.5f + (coarse + medium + fine) / 32.0f;</a>
<a name="ln1201">    float noise = (coarse + medium + fine) / 1440;</a>
<a name="ln1202"> </a>
<a name="ln1203">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1204">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1205">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1206">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1207">  }</a>
<a name="ln1208">  dt_gui_presets_add_generic(_(&quot;deblur: large blur, strength 2&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1209">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1210">  {</a>
<a name="ln1211">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1212">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1213">    float medium = GAUSS(x, sigma);</a>
<a name="ln1214">    float coeff = 0.5f + (medium + fine) / 28.0f;</a>
<a name="ln1215">    float noise = (medium + fine) / 960;</a>
<a name="ln1216"> </a>
<a name="ln1217">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1218">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1219">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1220">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1221">  }</a>
<a name="ln1222">  dt_gui_presets_add_generic(_(&quot;deblur: medium blur, strength 2&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1223">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1224">  {</a>
<a name="ln1225">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1226">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1227">    float coeff = 0.5f + fine / 19.0f;</a>
<a name="ln1228">    float noise = fine / 480;</a>
<a name="ln1229"> </a>
<a name="ln1230">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1231">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1232">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1233">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1234">  }</a>
<a name="ln1235">  dt_gui_presets_add_generic(_(&quot;deblur: fine blur, strength 2&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1236"> </a>
<a name="ln1237"> </a>
<a name="ln1238">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1239">  {</a>
<a name="ln1240">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1241">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1242">    float medium = GAUSS(x, sigma);</a>
<a name="ln1243">    float coarse = GAUSS(x, 2 * sigma);</a>
<a name="ln1244">    float coeff = 0.5f + (coarse + medium + fine) / 48.0f;</a>
<a name="ln1245">    float noise = (coarse + medium + fine) / 2160;</a>
<a name="ln1246"> </a>
<a name="ln1247">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1248">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1249">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1250">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1251">  }</a>
<a name="ln1252">  dt_gui_presets_add_generic(_(&quot;deblur: large blur, strength 1&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1253">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1254">  {</a>
<a name="ln1255">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1256">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1257">    float medium = GAUSS(x, sigma);</a>
<a name="ln1258">    float coeff = 0.5f + (medium + fine) / 42.0f;</a>
<a name="ln1259">    float noise = (medium + fine) / 1440;</a>
<a name="ln1260"> </a>
<a name="ln1261">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1262">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1263">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1264">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1265">  }</a>
<a name="ln1266">  dt_gui_presets_add_generic(_(&quot;deblur: medium blur, strength 1&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1267">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1268">  {</a>
<a name="ln1269">    float x = log2f(128.0 * k / (BANDS - 1.0) + 1.0) / log2f(129.0);</a>
<a name="ln1270">    float fine = GAUSS(x, 0.5 * sigma);</a>
<a name="ln1271">    float coeff = 0.5f + fine / 28.5f;</a>
<a name="ln1272">    float noise = fine / 720;</a>
<a name="ln1273"> </a>
<a name="ln1274">    p.x[atrous_L][k] = p.x[atrous_c][k] = p.x[atrous_s][k] = x;</a>
<a name="ln1275">    p.y[atrous_L][k] = p.y[atrous_c][k] = p.y[atrous_s][k] = coeff;</a>
<a name="ln1276">    p.x[atrous_Lt][k] = p.x[atrous_ct][k] = x;</a>
<a name="ln1277">    p.y[atrous_Lt][k] = p.y[atrous_ct][k] = noise;</a>
<a name="ln1278">  }</a>
<a name="ln1279">  dt_gui_presets_add_generic(_(&quot;deblur: fine blur, strength 1&quot;), self-&gt;op, self-&gt;version(), &amp;p, sizeof(p), 1);</a>
<a name="ln1280"> </a>
<a name="ln1281">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284">static void reset_mix(dt_iop_module_t *self)</a>
<a name="ln1285">{</a>
<a name="ln1286">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1287">  c-&gt;drag_params = *(dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1288">  const int old = self-&gt;dt-&gt;gui-&gt;reset;</a>
<a name="ln1289">  self-&gt;dt-&gt;gui-&gt;reset = 1;</a>
<a name="ln1290">  dt_bauhaus_slider_set(c-&gt;mix, 1.0f);</a>
<a name="ln1291">  self-&gt;dt-&gt;gui-&gt;reset = old;</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln1295">{</a>
<a name="ln1296">  reset_mix(self);</a>
<a name="ln1297">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln1298">}</a>
<a name="ln1299"> </a>
<a name="ln1300"> </a>
<a name="ln1301">// gui stuff:</a>
<a name="ln1302"> </a>
<a name="ln1303">static gboolean area_enter_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln1304">{</a>
<a name="ln1305">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1306">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1307">  if(!c-&gt;dragging) c-&gt;mouse_y = fabs(c-&gt;mouse_y);</a>
<a name="ln1308">  gtk_widget_queue_draw(widget);</a>
<a name="ln1309">  return TRUE;</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312">static gboolean area_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln1313">{</a>
<a name="ln1314">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1315">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1316">  if(!c-&gt;dragging) c-&gt;mouse_y = -fabs(c-&gt;mouse_y);</a>
<a name="ln1317">  gtk_widget_queue_draw(widget);</a>
<a name="ln1318">  return TRUE;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">// fills in new parameters based on mouse position (in 0,1)</a>
<a name="ln1322">static void get_params(dt_iop_atrous_params_t *p, const int ch, const double mouse_x, const double mouse_y,</a>
<a name="ln1323">                       const float rad)</a>
<a name="ln1324">{</a>
<a name="ln1325">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1326">  {</a>
<a name="ln1327">    const float f = expf(-(mouse_x - p-&gt;x[ch][k]) * (mouse_x - p-&gt;x[ch][k]) / (rad * rad));</a>
<a name="ln1328">    p-&gt;y[ch][k] = MAX(0.0f, MIN(1.0f, (1 - f) * p-&gt;y[ch][k] + f * mouse_y));</a>
<a name="ln1329">  }</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">static gboolean area_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln1333">{</a>
<a name="ln1334">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1335">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1336">  dt_iop_atrous_params_t p = *(dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1337"> </a>
<a name="ln1338">  for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1339">    dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.x[(int)c-&gt;channel2][k], p.y[(int)c-&gt;channel2][k]);</a>
<a name="ln1340">  const int inset = INSET;</a>
<a name="ln1341">  GtkAllocation allocation;</a>
<a name="ln1342">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1343">  int width = allocation.width, height = allocation.height;</a>
<a name="ln1344">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln1345">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln1346">  // clear bg, match color of the notebook tabs:</a>
<a name="ln1347">  GdkRGBA bright_bg_color, really_dark_bg_color;</a>
<a name="ln1348">  GtkStyleContext *context = gtk_widget_get_style_context(self-&gt;expander);</a>
<a name="ln1349">  gboolean color_found = gtk_style_context_lookup_color (context, &quot;selected_bg_color&quot;, &amp;bright_bg_color);</a>
<a name="ln1350">  if(!color_found)</a>
<a name="ln1351">  {</a>
<a name="ln1352">    bright_bg_color.red = 1.0;</a>
<a name="ln1353">    bright_bg_color.green = 0.0;</a>
<a name="ln1354">    bright_bg_color.blue = 0.0;</a>
<a name="ln1355">    bright_bg_color.alpha = 1.0;</a>
<a name="ln1356">  }</a>
<a name="ln1357"> </a>
<a name="ln1358">  color_found = gtk_style_context_lookup_color (context, &quot;really_dark_bg_color&quot;, &amp;really_dark_bg_color);</a>
<a name="ln1359">  if(!color_found)</a>
<a name="ln1360">  {</a>
<a name="ln1361">    really_dark_bg_color.red = 1.0;</a>
<a name="ln1362">    really_dark_bg_color.green = 0.0;</a>
<a name="ln1363">    really_dark_bg_color.blue = 0.0;</a>
<a name="ln1364">    really_dark_bg_color.alpha = 1.0;</a>
<a name="ln1365">  }</a>
<a name="ln1366"> </a>
<a name="ln1367">  gdk_cairo_set_source_rgba(cr, &amp;bright_bg_color);</a>
<a name="ln1368">  cairo_paint(cr);</a>
<a name="ln1369"> </a>
<a name="ln1370">  cairo_translate(cr, inset, inset);</a>
<a name="ln1371">  width -= 2 * inset;</a>
<a name="ln1372">  height -= 2 * inset;</a>
<a name="ln1373"> </a>
<a name="ln1374">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0));</a>
<a name="ln1375">  gdk_cairo_set_source_rgba(cr, &amp;really_dark_bg_color);</a>
<a name="ln1376">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln1377">  cairo_stroke(cr);</a>
<a name="ln1378"> </a>
<a name="ln1379">  gdk_cairo_set_source_rgba(cr, &amp;bright_bg_color);</a>
<a name="ln1380">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln1381">  cairo_fill(cr);</a>
<a name="ln1382"> </a>
<a name="ln1383">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln1384">  {</a>
<a name="ln1385">    int ch2 = (int)c-&gt;channel2;</a>
<a name="ln1386"> </a>
<a name="ln1387">    // draw min/max curves:</a>
<a name="ln1388">    get_params(&amp;p, ch2, c-&gt;mouse_x, 1., c-&gt;mouse_radius);</a>
<a name="ln1389">    for(int k = 0; k &lt; BANDS; k++) dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.x[ch2][k], p.y[ch2][k]);</a>
<a name="ln1390">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, RES, c-&gt;draw_min_xs, c-&gt;draw_min_ys);</a>
<a name="ln1391"> </a>
<a name="ln1392">    p = *(dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1393">    get_params(&amp;p, ch2, c-&gt;mouse_x, .0, c-&gt;mouse_radius);</a>
<a name="ln1394">    for(int k = 0; k &lt; BANDS; k++) dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.x[ch2][k], p.y[ch2][k]);</a>
<a name="ln1395">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, RES, c-&gt;draw_max_xs, c-&gt;draw_max_ys);</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  // draw grid</a>
<a name="ln1399">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(.4));</a>
<a name="ln1400">  gdk_cairo_set_source_rgba(cr, &amp;really_dark_bg_color);</a>
<a name="ln1401">  dt_draw_grid(cr, 8, 0, 0, width, height);</a>
<a name="ln1402"> </a>
<a name="ln1403">  cairo_save(cr);</a>
<a name="ln1404"> </a>
<a name="ln1405">  // draw selected cursor</a>
<a name="ln1406">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.));</a>
<a name="ln1407">  cairo_translate(cr, 0, height);</a>
<a name="ln1408"> </a>
<a name="ln1409">// draw frequency histogram in bg.</a>
<a name="ln1410">#if 1</a>
<a name="ln1411">  if(c-&gt;num_samples &gt; 0)</a>
<a name="ln1412">  {</a>
<a name="ln1413">    cairo_save(cr);</a>
<a name="ln1414">    for(int k = 1; k &lt; c-&gt;num_samples; k += 2)</a>
<a name="ln1415">    {</a>
<a name="ln1416">      cairo_set_source_rgba(cr, really_dark_bg_color.red, really_dark_bg_color.green, really_dark_bg_color.blue, .3);</a>
<a name="ln1417">      cairo_move_to(cr, width * c-&gt;sample[k - 1], 0.0f);</a>
<a name="ln1418">      cairo_line_to(cr, width * c-&gt;sample[k - 1], -height);</a>
<a name="ln1419">      cairo_line_to(cr, width * c-&gt;sample[k], -height);</a>
<a name="ln1420">      cairo_line_to(cr, width * c-&gt;sample[k], 0.0f);</a>
<a name="ln1421">      cairo_fill(cr);</a>
<a name="ln1422">    }</a>
<a name="ln1423">    if(c-&gt;num_samples &amp; 1)</a>
<a name="ln1424">    {</a>
<a name="ln1425">      cairo_move_to(cr, width * c-&gt;sample[c-&gt;num_samples - 1], 0.0f);</a>
<a name="ln1426">      cairo_line_to(cr, width * c-&gt;sample[c-&gt;num_samples - 1], -height);</a>
<a name="ln1427">      cairo_line_to(cr, 0.0f, -height);</a>
<a name="ln1428">      cairo_line_to(cr, 0.0f, 0.0f);</a>
<a name="ln1429">      cairo_fill(cr);</a>
<a name="ln1430">    }</a>
<a name="ln1431">    cairo_restore(cr);</a>
<a name="ln1432">  }</a>
<a name="ln1433">  if(c-&gt;band_max &gt; 0)</a>
<a name="ln1434">  {</a>
<a name="ln1435">    cairo_save(cr);</a>
<a name="ln1436">    cairo_scale(cr, width / (BANDS - 1.0), -(height - DT_PIXEL_APPLY_DPI(5)) / c-&gt;band_max);</a>
<a name="ln1437">    cairo_set_source_rgba(cr, really_dark_bg_color.red, really_dark_bg_color.green, really_dark_bg_color.blue, .3);</a>
<a name="ln1438">    cairo_move_to(cr, 0, 0);</a>
<a name="ln1439">    for(int k = 0; k &lt; BANDS; k++) cairo_line_to(cr, k, c-&gt;band_hist[k]);</a>
<a name="ln1440">    cairo_line_to(cr, BANDS - 1.0, 0.);</a>
<a name="ln1441">    cairo_close_path(cr);</a>
<a name="ln1442">    cairo_fill(cr);</a>
<a name="ln1443">    cairo_restore(cr);</a>
<a name="ln1444">  }</a>
<a name="ln1445">#endif</a>
<a name="ln1446"> </a>
<a name="ln1447">  // cairo_set_operator(cr, CAIRO_OPERATOR_ADD);</a>
<a name="ln1448">  cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln1449">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.));</a>
<a name="ln1450">  for(int i = 0; i &lt;= atrous_s; i++)</a>
<a name="ln1451">  {</a>
<a name="ln1452">    // draw curves, selected last.</a>
<a name="ln1453">    int ch = ((int)c-&gt;channel + i + 1) % (atrous_s + 1);</a>
<a name="ln1454">    int ch2 = -1;</a>
<a name="ln1455">    const float bgmul = i &lt; atrous_s ? 0.5f : 1.0f;</a>
<a name="ln1456">    switch(ch)</a>
<a name="ln1457">    {</a>
<a name="ln1458">      case atrous_L:</a>
<a name="ln1459">        cairo_set_source_rgba(cr, .6, .6, .6, .3 * bgmul);</a>
<a name="ln1460">        ch2 = atrous_Lt;</a>
<a name="ln1461">        break;</a>
<a name="ln1462">      case atrous_c:</a>
<a name="ln1463">        cairo_set_source_rgba(cr, .4, .2, .0, .4 * bgmul);</a>
<a name="ln1464">        ch2 = atrous_ct;</a>
<a name="ln1465">        break;</a>
<a name="ln1466">      default: // case atrous_s:</a>
<a name="ln1467">        cairo_set_source_rgba(cr, .1, .2, .3, .4 * bgmul);</a>
<a name="ln1468">        break;</a>
<a name="ln1469">    }</a>
<a name="ln1470">    p = *(dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1471"> </a>
<a name="ln1472">    // reverse order if bottom is active (to end up with correct values in minmax_curve):</a>
<a name="ln1473">    if(c-&gt;channel2 == ch2)</a>
<a name="ln1474">    {</a>
<a name="ln1475">      ch2 = ch;</a>
<a name="ln1476">      ch = c-&gt;channel2;</a>
<a name="ln1477">    }</a>
<a name="ln1478"> </a>
<a name="ln1479">    if(ch2 &gt;= 0)</a>
<a name="ln1480">    {</a>
<a name="ln1481">      for(int k = 0; k &lt; BANDS; k++) dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.x[ch2][k], p.y[ch2][k]);</a>
<a name="ln1482">      dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, RES, c-&gt;draw_xs, c-&gt;draw_ys);</a>
<a name="ln1483">      cairo_move_to(cr, width, -height * p.y[ch2][BANDS - 1]);</a>
<a name="ln1484">      for(int k = RES - 2; k &gt;= 0; k--)</a>
<a name="ln1485">        cairo_line_to(cr, k * width / (float)(RES - 1), -height * c-&gt;draw_ys[k]);</a>
<a name="ln1486">    }</a>
<a name="ln1487">    else</a>
<a name="ln1488">      cairo_move_to(cr, 0, 0);</a>
<a name="ln1489">    for(int k = 0; k &lt; BANDS; k++) dt_draw_curve_set_point(c-&gt;minmax_curve, k, p.x[ch][k], p.y[ch][k]);</a>
<a name="ln1490">    dt_draw_curve_calc_values(c-&gt;minmax_curve, 0.0, 1.0, RES, c-&gt;draw_xs, c-&gt;draw_ys);</a>
<a name="ln1491">    for(int k = 0; k &lt; RES; k++) cairo_line_to(cr, k * width / (float)(RES - 1), -height * c-&gt;draw_ys[k]);</a>
<a name="ln1492">    if(ch2 &lt; 0) cairo_line_to(cr, width, 0);</a>
<a name="ln1493">    cairo_close_path(cr);</a>
<a name="ln1494">    cairo_stroke_preserve(cr);</a>
<a name="ln1495">    cairo_fill(cr);</a>
<a name="ln1496">  }</a>
<a name="ln1497"> </a>
<a name="ln1498">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln1499">  {</a>
<a name="ln1500">    int ch = (int)c-&gt;channel;</a>
<a name="ln1501">    int ch2 = (int)c-&gt;channel2;</a>
<a name="ln1502"> </a>
<a name="ln1503">    // draw dots on knots</a>
<a name="ln1504">    cairo_save(cr);</a>
<a name="ln1505">    if(ch != ch2)</a>
<a name="ln1506">      cairo_set_source_rgb(cr, 0.1, 0.1, 0.1);</a>
<a name="ln1507">    else</a>
<a name="ln1508">      cairo_set_source_rgb(cr, 0.7, 0.7, 0.7);</a>
<a name="ln1509">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.));</a>
<a name="ln1510">    for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1511">    {</a>
<a name="ln1512">      cairo_arc(cr, width * p.x[ch2][k], -height * p.y[ch2][k], DT_PIXEL_APPLY_DPI(3.0), 0.0, 2.0 * M_PI);</a>
<a name="ln1513">      if(c-&gt;x_move == k)</a>
<a name="ln1514">        cairo_fill(cr);</a>
<a name="ln1515">      else</a>
<a name="ln1516">        cairo_stroke(cr);</a>
<a name="ln1517">    }</a>
<a name="ln1518">    cairo_restore(cr);</a>
<a name="ln1519">  }</a>
<a name="ln1520"> </a>
<a name="ln1521">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln1522">  {</a>
<a name="ln1523">    // draw min/max, if selected</a>
<a name="ln1524">    // cairo_set_source_rgba(cr, .6, .6, .6, .5);</a>
<a name="ln1525">    cairo_move_to(cr, 0, -height * c-&gt;draw_min_ys[0]);</a>
<a name="ln1526">    for(int k = 1; k &lt; RES; k++) cairo_line_to(cr, k * width / (float)(RES - 1), -height * c-&gt;draw_min_ys[k]);</a>
<a name="ln1527">    for(int k = RES - 1; k &gt;= 0; k--)</a>
<a name="ln1528">      cairo_line_to(cr, k * width / (float)(RES - 1), -height * c-&gt;draw_max_ys[k]);</a>
<a name="ln1529">    cairo_close_path(cr);</a>
<a name="ln1530">    cairo_fill(cr);</a>
<a name="ln1531">    // draw mouse focus circle</a>
<a name="ln1532">    cairo_set_source_rgba(cr, .9, .9, .9, .5);</a>
<a name="ln1533">    const float pos = RES * c-&gt;mouse_x;</a>
<a name="ln1534">    int k = (int)pos;</a>
<a name="ln1535">    const float f = k - pos;</a>
<a name="ln1536">    if(k &gt;= RES - 1) k = RES - 2;</a>
<a name="ln1537">    float ht = -height * (f * c-&gt;draw_ys[k] + (1 - f) * c-&gt;draw_ys[k + 1]);</a>
<a name="ln1538">    cairo_arc(cr, c-&gt;mouse_x * width, ht, c-&gt;mouse_radius * width, 0, 2. * M_PI);</a>
<a name="ln1539">    cairo_stroke(cr);</a>
<a name="ln1540">  }</a>
<a name="ln1541"> </a>
<a name="ln1542">  cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);</a>
<a name="ln1543"> </a>
<a name="ln1544">  // draw x positions</a>
<a name="ln1545">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.));</a>
<a name="ln1546">  cairo_set_source_rgb(cr, 0.6, 0.6, 0.6);</a>
<a name="ln1547">  const float arrw = DT_PIXEL_APPLY_DPI(7.0f);</a>
<a name="ln1548">  for(int k = 1; k &lt; BANDS - 1; k++)</a>
<a name="ln1549">  {</a>
<a name="ln1550">    cairo_move_to(cr, width * p.x[(int)c-&gt;channel][k], inset - DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln1551">    cairo_rel_line_to(cr, -arrw * .5f, 0);</a>
<a name="ln1552">    cairo_rel_line_to(cr, arrw * .5f, -arrw);</a>
<a name="ln1553">    cairo_rel_line_to(cr, arrw * .5f, arrw);</a>
<a name="ln1554">    cairo_close_path(cr);</a>
<a name="ln1555">    if(c-&gt;x_move == k)</a>
<a name="ln1556">      cairo_fill(cr);</a>
<a name="ln1557">    else</a>
<a name="ln1558">      cairo_stroke(cr);</a>
<a name="ln1559">  }</a>
<a name="ln1560"> </a>
<a name="ln1561">  cairo_restore(cr);</a>
<a name="ln1562"> </a>
<a name="ln1563">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln1564">  {</a>
<a name="ln1565">    // draw labels:</a>
<a name="ln1566">    PangoLayout *layout;</a>
<a name="ln1567">    PangoRectangle ink;</a>
<a name="ln1568">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln1569">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln1570">    pango_font_description_set_absolute_size(desc, (.06 * height) * PANGO_SCALE);</a>
<a name="ln1571">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln1572">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln1573">    gdk_cairo_set_source_rgba(cr, &amp;really_dark_bg_color);</a>
<a name="ln1574">    cairo_select_font_face(cr, &quot;sans-serif&quot;, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);</a>
<a name="ln1575">    cairo_set_font_size(cr, .06 * height);</a>
<a name="ln1576">    pango_layout_set_text(layout, _(&quot;coarse&quot;), -1);</a>
<a name="ln1577">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1578">    cairo_move_to(cr, .02 * width - ink.y, .14 * height + ink.width);</a>
<a name="ln1579">    cairo_save(cr);</a>
<a name="ln1580">    cairo_rotate(cr, -M_PI * .5f);</a>
<a name="ln1581">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln1582">    cairo_restore(cr);</a>
<a name="ln1583">    pango_layout_set_text(layout, _(&quot;fine&quot;), -1);</a>
<a name="ln1584">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln1585">    cairo_move_to(cr, .98 * width - ink.height, .14 * height + ink.width);</a>
<a name="ln1586">    cairo_save(cr);</a>
<a name="ln1587">    cairo_rotate(cr, -M_PI * .5f);</a>
<a name="ln1588">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln1589">    cairo_restore(cr);</a>
<a name="ln1590"> </a>
<a name="ln1591">    switch(c-&gt;channel2)</a>
<a name="ln1592">    {</a>
<a name="ln1593">      case atrous_L:</a>
<a name="ln1594">      case atrous_c:</a>
<a name="ln1595">        dt_atrous_show_upper_label(cr, _(&quot;contrasty&quot;), layout, ink);</a>
<a name="ln1596">        dt_atrous_show_lower_label(cr, _(&quot;smooth&quot;), layout, ink);</a>
<a name="ln1597">        break;</a>
<a name="ln1598">      case atrous_Lt:</a>
<a name="ln1599">      case atrous_ct:</a>
<a name="ln1600">        dt_atrous_show_upper_label(cr, _(&quot;smooth&quot;), layout, ink);</a>
<a name="ln1601">        dt_atrous_show_lower_label(cr, _(&quot;noisy&quot;), layout, ink);</a>
<a name="ln1602">        break;</a>
<a name="ln1603">      default: // case atrous_s:</a>
<a name="ln1604">        dt_atrous_show_upper_label(cr, _(&quot;bold&quot;), layout, ink);</a>
<a name="ln1605">        dt_atrous_show_lower_label(cr, _(&quot;dull&quot;), layout, ink);</a>
<a name="ln1606">        break;</a>
<a name="ln1607">    }</a>
<a name="ln1608">    pango_font_description_free(desc);</a>
<a name="ln1609">    g_object_unref(layout);</a>
<a name="ln1610">  }</a>
<a name="ln1611"> </a>
<a name="ln1612"> </a>
<a name="ln1613">  cairo_destroy(cr);</a>
<a name="ln1614">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln1615">  cairo_paint(crf);</a>
<a name="ln1616">  cairo_surface_destroy(cst);</a>
<a name="ln1617">  return TRUE;</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">static gboolean area_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln1621">{</a>
<a name="ln1622">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1623">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1624">  dt_iop_atrous_params_t *p = (dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1625">  const int inset = INSET;</a>
<a name="ln1626">  GtkAllocation allocation;</a>
<a name="ln1627">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1628">  int height = allocation.height - 2 * inset, width = allocation.width - 2 * inset;</a>
<a name="ln1629">  if(!c-&gt;dragging) c-&gt;mouse_x = CLAMP(event-&gt;x - inset, 0, width) / (float)width;</a>
<a name="ln1630">  c-&gt;mouse_y = 1.0 - CLAMP(event-&gt;y - inset, 0, height) / (float)height;</a>
<a name="ln1631">  int ch2 = c-&gt;channel;</a>
<a name="ln1632">  if(c-&gt;channel == atrous_L) ch2 = atrous_Lt;</a>
<a name="ln1633">  if(c-&gt;channel == atrous_c) ch2 = atrous_ct;</a>
<a name="ln1634">  if(c-&gt;dragging)</a>
<a name="ln1635">  {</a>
<a name="ln1636">    // drag y-positions</a>
<a name="ln1637">    *p = c-&gt;drag_params;</a>
<a name="ln1638">    if(c-&gt;x_move &gt;= 0)</a>
<a name="ln1639">    {</a>
<a name="ln1640">      const float mx = CLAMP(event-&gt;x - inset, 0, width) / (float)width;</a>
<a name="ln1641">      if(c-&gt;x_move &gt; 0 &amp;&amp; c-&gt;x_move &lt; BANDS - 1)</a>
<a name="ln1642">      {</a>
<a name="ln1643">        const float minx = p-&gt;x[c-&gt;channel][c-&gt;x_move - 1] + 0.001f;</a>
<a name="ln1644">        const float maxx = p-&gt;x[c-&gt;channel][c-&gt;x_move + 1] - 0.001f;</a>
<a name="ln1645">        p-&gt;x[ch2][c-&gt;x_move] = p-&gt;x[c-&gt;channel][c-&gt;x_move] = fminf(maxx, fmaxf(minx, mx));</a>
<a name="ln1646">      }</a>
<a name="ln1647">    }</a>
<a name="ln1648">    else</a>
<a name="ln1649">    {</a>
<a name="ln1650">      get_params(p, c-&gt;channel2, c-&gt;mouse_x, c-&gt;mouse_y + c-&gt;mouse_pick, c-&gt;mouse_radius);</a>
<a name="ln1651">    }</a>
<a name="ln1652">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1653">  }</a>
<a name="ln1654">  else if(event-&gt;y &gt; height)</a>
<a name="ln1655">  {</a>
<a name="ln1656">    // move x-positions</a>
<a name="ln1657">    c-&gt;x_move = 0;</a>
<a name="ln1658">    float dist = fabs(p-&gt;x[c-&gt;channel][0] - c-&gt;mouse_x);</a>
<a name="ln1659">    for(int k = 1; k &lt; BANDS; k++)</a>
<a name="ln1660">    {</a>
<a name="ln1661">      float d2 = fabs(p-&gt;x[c-&gt;channel][k] - c-&gt;mouse_x);</a>
<a name="ln1662">      if(d2 &lt; dist)</a>
<a name="ln1663">      {</a>
<a name="ln1664">        c-&gt;x_move = k;</a>
<a name="ln1665">        dist = d2;</a>
<a name="ln1666">      }</a>
<a name="ln1667">    }</a>
<a name="ln1668">  }</a>
<a name="ln1669">  else</a>
<a name="ln1670">  {</a>
<a name="ln1671">    // choose between bottom and top curve:</a>
<a name="ln1672">    int ch = c-&gt;channel;</a>
<a name="ln1673">    float dist = 1000000.0f;</a>
<a name="ln1674">    for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1675">    {</a>
<a name="ln1676">      float d2 = fabs(p-&gt;x[c-&gt;channel][k] - c-&gt;mouse_x);</a>
<a name="ln1677">      if(d2 &lt; dist)</a>
<a name="ln1678">      {</a>
<a name="ln1679">        if(fabs(c-&gt;mouse_y - p-&gt;y[ch][k]) &lt; fabs(c-&gt;mouse_y - p-&gt;y[ch2][k]))</a>
<a name="ln1680">          c-&gt;channel2 = ch;</a>
<a name="ln1681">        else</a>
<a name="ln1682">          c-&gt;channel2 = ch2;</a>
<a name="ln1683">        dist = d2;</a>
<a name="ln1684">      }</a>
<a name="ln1685">    }</a>
<a name="ln1686">    // don't move x-positions:</a>
<a name="ln1687">    c-&gt;x_move = -1;</a>
<a name="ln1688">  }</a>
<a name="ln1689">  gtk_widget_queue_draw(widget);</a>
<a name="ln1690">  gint x, y;</a>
<a name="ln1691">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln1692">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln1693">      gdk_seat_get_pointer(gdk_display_get_default_seat(gtk_widget_get_display(widget))),</a>
<a name="ln1694">      &amp;x, &amp;y, 0);</a>
<a name="ln1695">#else</a>
<a name="ln1696">  gdk_window_get_device_position(event-&gt;window,</a>
<a name="ln1697">                                 gdk_device_manager_get_client_pointer(</a>
<a name="ln1698">                                     gdk_display_get_device_manager(gdk_window_get_display(event-&gt;window))),</a>
<a name="ln1699">                                 &amp;x, &amp;y, NULL);</a>
<a name="ln1700">#endif</a>
<a name="ln1701">  return TRUE;</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">static gboolean area_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln1705">{</a>
<a name="ln1706">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1707">  if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln1708">  {</a>
<a name="ln1709">    // reset current curve</a>
<a name="ln1710">    dt_iop_atrous_params_t *p = (dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1711">    dt_iop_atrous_params_t *d = (dt_iop_atrous_params_t *)self-&gt;default_params;</a>
<a name="ln1712">    dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1713">    reset_mix(self);</a>
<a name="ln1714">    for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1715">    {</a>
<a name="ln1716">      p-&gt;x[c-&gt;channel2][k] = d-&gt;x[c-&gt;channel2][k];</a>
<a name="ln1717">      p-&gt;y[c-&gt;channel2][k] = d-&gt;y[c-&gt;channel2][k];</a>
<a name="ln1718">    }</a>
<a name="ln1719">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1720">    gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln1721">  }</a>
<a name="ln1722">  else if(event-&gt;button == 1)</a>
<a name="ln1723">  {</a>
<a name="ln1724">    // set active point</a>
<a name="ln1725">    dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1726">    reset_mix(self);</a>
<a name="ln1727">    const int inset = INSET;</a>
<a name="ln1728">    GtkAllocation allocation;</a>
<a name="ln1729">    gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln1730">    int height = allocation.height - 2 * inset, width = allocation.width - 2 * inset;</a>
<a name="ln1731">    c-&gt;mouse_pick</a>
<a name="ln1732">        = dt_draw_curve_calc_value(c-&gt;minmax_curve, CLAMP(event-&gt;x - inset, 0, width) / (float)width);</a>
<a name="ln1733">    c-&gt;mouse_pick -= 1.0 - CLAMP(event-&gt;y - inset, 0, height) / (float)height;</a>
<a name="ln1734">    c-&gt;dragging = 1;</a>
<a name="ln1735">    return TRUE;</a>
<a name="ln1736">  }</a>
<a name="ln1737">  return FALSE;</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">static gboolean area_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln1741">{</a>
<a name="ln1742">  if(event-&gt;button == 1)</a>
<a name="ln1743">  {</a>
<a name="ln1744">    dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1745">    dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1746">    c-&gt;dragging = 0;</a>
<a name="ln1747">    reset_mix(self);</a>
<a name="ln1748">    return TRUE;</a>
<a name="ln1749">  }</a>
<a name="ln1750">  return FALSE;</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">static gboolean area_scrolled(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln1754">{</a>
<a name="ln1755">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1756">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1757"> </a>
<a name="ln1758">  gdouble delta_y;</a>
<a name="ln1759">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln1760">  {</a>
<a name="ln1761">    c-&gt;mouse_radius = CLAMP(c-&gt;mouse_radius * (1.0 + 0.1 * delta_y), 0.25 / BANDS, 1.0);</a>
<a name="ln1762">    gtk_widget_queue_draw(widget);</a>
<a name="ln1763">  }</a>
<a name="ln1764">  return TRUE;</a>
<a name="ln1765">}</a>
<a name="ln1766"> </a>
<a name="ln1767">static void tab_switch(GtkNotebook *notebook, GtkWidget *page, guint page_num, gpointer user_data)</a>
<a name="ln1768">{</a>
<a name="ln1769">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1770">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1771">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1772">  c-&gt;channel = c-&gt;channel2 = (atrous_channel_t)page_num;</a>
<a name="ln1773">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">static void mix_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1777">{</a>
<a name="ln1778">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln1779">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1780">  dt_iop_atrous_params_t *p = (dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1781">  dt_iop_atrous_params_t *d = (dt_iop_atrous_params_t *)self-&gt;default_params;</a>
<a name="ln1782">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1783">  const float mix = dt_bauhaus_slider_get(slider);</a>
<a name="ln1784">  for(int ch = 0; ch &lt; atrous_none; ch++)</a>
<a name="ln1785">    for(int k = 0; k &lt; BANDS; k++)</a>
<a name="ln1786">    {</a>
<a name="ln1787">      p-&gt;x[ch][k] = fminf(1.0f, fmaxf(0.0f, d-&gt;x[ch][k] + mix * (c-&gt;drag_params.x[ch][k] - d-&gt;x[ch][k])));</a>
<a name="ln1788">      p-&gt;y[ch][k] = fminf(1.0f, fmaxf(0.0f, d-&gt;y[ch][k] + mix * (c-&gt;drag_params.y[ch][k] - d-&gt;y[ch][k])));</a>
<a name="ln1789">    }</a>
<a name="ln1790">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln1791">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1795">{</a>
<a name="ln1796">  self-&gt;gui_data = malloc(sizeof(dt_iop_atrous_gui_data_t));</a>
<a name="ln1797">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1798">  dt_iop_atrous_params_t *p = (dt_iop_atrous_params_t *)self-&gt;params;</a>
<a name="ln1799"> </a>
<a name="ln1800">  c-&gt;num_samples = 0;</a>
<a name="ln1801">  c-&gt;band_max = 0;</a>
<a name="ln1802">  c-&gt;channel = c-&gt;channel2 = dt_conf_get_int(&quot;plugins/darkroom/atrous/gui_channel&quot;);</a>
<a name="ln1803">  int ch = (int)c-&gt;channel;</a>
<a name="ln1804">  c-&gt;minmax_curve = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln1805">  for(int k = 0; k &lt; BANDS; k++) (void)dt_draw_curve_add_point(c-&gt;minmax_curve, p-&gt;x[ch][k], p-&gt;y[ch][k]);</a>
<a name="ln1806">  c-&gt;mouse_x = c-&gt;mouse_y = c-&gt;mouse_pick = -1.0;</a>
<a name="ln1807">  c-&gt;dragging = 0;</a>
<a name="ln1808">  c-&gt;x_move = -1;</a>
<a name="ln1809">  c-&gt;mouse_radius = 1.0 / BANDS;</a>
<a name="ln1810">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln1811">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1812">  GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln1813">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), vbox, FALSE, FALSE, 0);</a>
<a name="ln1814"> </a>
<a name="ln1815">  c-&gt;channel_tabs = GTK_NOTEBOOK(gtk_notebook_new());</a>
<a name="ln1816"> </a>
<a name="ln1817">  gtk_notebook_append_page(GTK_NOTEBOOK(c-&gt;channel_tabs),</a>
<a name="ln1818">                           GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)), gtk_label_new(_(&quot;luma&quot;)));</a>
<a name="ln1819">  gtk_widget_set_tooltip_text(gtk_notebook_get_tab_label(c-&gt;channel_tabs, gtk_notebook_get_nth_page(c-&gt;channel_tabs, -1)),</a>
<a name="ln1820">                              _(&quot;change lightness at each feature size&quot;));</a>
<a name="ln1821">  gtk_notebook_append_page(GTK_NOTEBOOK(c-&gt;channel_tabs),</a>
<a name="ln1822">                           GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln1823">                           gtk_label_new(_(&quot;chroma&quot;)));</a>
<a name="ln1824">  gtk_widget_set_tooltip_text(gtk_notebook_get_tab_label(c-&gt;channel_tabs, gtk_notebook_get_nth_page(c-&gt;channel_tabs, -1)),</a>
<a name="ln1825">                              _(&quot;change color saturation at each feature size&quot;));</a>
<a name="ln1826">  gtk_notebook_append_page(GTK_NOTEBOOK(c-&gt;channel_tabs),</a>
<a name="ln1827">                           GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)), gtk_label_new(_(&quot;edges&quot;)));</a>
<a name="ln1828">  gtk_widget_set_tooltip_text(gtk_notebook_get_tab_label(c-&gt;channel_tabs, gtk_notebook_get_nth_page(c-&gt;channel_tabs, -1)),</a>
<a name="ln1829">                              _(&quot;change edge halos at each feature size\nonly changes results of luma and chroma tabs&quot;));</a>
<a name="ln1830"> </a>
<a name="ln1831">  gtk_widget_show_all(GTK_WIDGET(gtk_notebook_get_nth_page(c-&gt;channel_tabs, c-&gt;channel)));</a>
<a name="ln1832">  gtk_notebook_set_current_page(GTK_NOTEBOOK(c-&gt;channel_tabs), c-&gt;channel);</a>
<a name="ln1833"> </a>
<a name="ln1834">  gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(c-&gt;channel_tabs), FALSE, FALSE, 0);</a>
<a name="ln1835"> </a>
<a name="ln1836">  g_signal_connect(G_OBJECT(c-&gt;channel_tabs), &quot;switch_page&quot;, G_CALLBACK(tab_switch), self);</a>
<a name="ln1837"> </a>
<a name="ln1838">  // graph</a>
<a name="ln1839">  c-&gt;area = GTK_DRAWING_AREA(dtgtk_drawing_area_new_with_aspect_ratio(0.75));</a>
<a name="ln1840">  gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(c-&gt;area), TRUE, TRUE, 0);</a>
<a name="ln1841"> </a>
<a name="ln1842">  gtk_widget_add_events(GTK_WIDGET(c-&gt;area), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln1843">                                             | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln1844">                                             | GDK_LEAVE_NOTIFY_MASK | darktable.gui-&gt;scroll_mask);</a>
<a name="ln1845">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;draw&quot;, G_CALLBACK(area_draw), self);</a>
<a name="ln1846">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;button-press-event&quot;, G_CALLBACK(area_button_press), self);</a>
<a name="ln1847">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;button-release-event&quot;, G_CALLBACK(area_button_release), self);</a>
<a name="ln1848">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;motion-notify-event&quot;, G_CALLBACK(area_motion_notify), self);</a>
<a name="ln1849">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;leave-notify-event&quot;, G_CALLBACK(area_leave_notify), self);</a>
<a name="ln1850">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;enter-notify-event&quot;, G_CALLBACK(area_enter_notify), self);</a>
<a name="ln1851">  g_signal_connect(G_OBJECT(c-&gt;area), &quot;scroll-event&quot;, G_CALLBACK(area_scrolled), self);</a>
<a name="ln1852"> </a>
<a name="ln1853">  // mix slider</a>
<a name="ln1854">  c-&gt;mix = dt_bauhaus_slider_new_with_range(self, -2.0f, 2.0f, 0.1f, 1.0f, 3);</a>
<a name="ln1855">  dt_bauhaus_widget_set_label(c-&gt;mix, NULL, _(&quot;mix&quot;));</a>
<a name="ln1856">  gtk_widget_set_tooltip_text(c-&gt;mix, _(&quot;make effect stronger or weaker&quot;));</a>
<a name="ln1857">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), c-&gt;mix, TRUE, TRUE, 0);</a>
<a name="ln1858">  g_signal_connect(G_OBJECT(c-&gt;mix), &quot;value-changed&quot;, G_CALLBACK(mix_callback), self);</a>
<a name="ln1859">}</a>
<a name="ln1860"> </a>
<a name="ln1861">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln1862">{</a>
<a name="ln1863">  dt_iop_atrous_gui_data_t *c = (dt_iop_atrous_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1864">  dt_conf_set_int(&quot;plugins/darkroom/atrous/gui_channel&quot;, c-&gt;channel);</a>
<a name="ln1865">  dt_draw_curve_destroy(c-&gt;minmax_curve);</a>
<a name="ln1866">  free(self-&gt;gui_data);</a>
<a name="ln1867">  self-&gt;gui_data = NULL;</a>
<a name="ln1868">}</a>
<a name="ln1869"> </a>
<a name="ln1870">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1871">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1872">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="814"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dev_detail'. Check lines: 814, 795.</p></div>
<div class="balloon" rel="948"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 948, 933.</p></div>
<div class="balloon" rel="949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 949, 934.</p></div>
<div class="balloon" rel="958"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 958, 956.</p></div>
<div class="balloon" rel="1007"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 1007, 1002.</p></div>
<div class="balloon" rel="1521"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 1498, 1521.</p></div>
<div class="balloon" rel="1800"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'c'. Check lines: 1800, 1796.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
