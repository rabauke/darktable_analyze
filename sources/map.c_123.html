
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2012-2016 tobias ellinghaus.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/geo.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln26">#include &quot;common/undo.h&quot;</a>
<a name="ln27">#include &quot;control/conf.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln30">#include &quot;gui/drag_and_drop.h&quot;</a>
<a name="ln31">#include &quot;gui/draw.h&quot;</a>
<a name="ln32">#include &quot;libs/lib.h&quot;</a>
<a name="ln33">#include &quot;views/view.h&quot;</a>
<a name="ln34">#include &quot;views/view_api.h&quot;</a>
<a name="ln35">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;osm-gps-map.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">DT_MODULE(1)</a>
<a name="ln40"> </a>
<a name="ln41">typedef struct dt_undo_geotag_t</a>
<a name="ln42">{</a>
<a name="ln43">  int imgid;</a>
<a name="ln44">  float longitude, latitude, elevation;</a>
<a name="ln45">} dt_undo_geotag_t;</a>
<a name="ln46"> </a>
<a name="ln47">typedef struct dt_map_t</a>
<a name="ln48">{</a>
<a name="ln49">  GtkWidget *center;</a>
<a name="ln50">  OsmGpsMap *map;</a>
<a name="ln51">  OsmGpsMapSource_t map_source;</a>
<a name="ln52">  OsmGpsMapLayer *osd;</a>
<a name="ln53">  GSList *images;</a>
<a name="ln54">  GdkPixbuf *image_pin, *place_pin;</a>
<a name="ln55">  gint selected_image;</a>
<a name="ln56">  gboolean start_drag;</a>
<a name="ln57">  struct</a>
<a name="ln58">  {</a>
<a name="ln59">    sqlite3_stmt *main_query;</a>
<a name="ln60">  } statements;</a>
<a name="ln61">  gboolean drop_filmstrip_activated;</a>
<a name="ln62">  gboolean filter_images_drawn;</a>
<a name="ln63">  int max_images_drawn;</a>
<a name="ln64">} dt_map_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef struct dt_map_image_t</a>
<a name="ln67">{</a>
<a name="ln68">  gint imgid;</a>
<a name="ln69">  OsmGpsMapImage *image;</a>
<a name="ln70">  gint width, height;</a>
<a name="ln71">} dt_map_image_t;</a>
<a name="ln72"> </a>
<a name="ln73">static const int thumb_size = 64, thumb_border = 1, image_pin_size = 13, place_pin_size = 72;</a>
<a name="ln74">static const uint32_t thumb_frame_color = 0x000000aa;</a>
<a name="ln75">static const uint32_t pin_outer_color = 0x0000aaaa;</a>
<a name="ln76">static const uint32_t pin_inner_color = 0xffffffee;</a>
<a name="ln77">static const uint32_t pin_line_color = 0x000000ff;</a>
<a name="ln78"> </a>
<a name="ln79">/* proxy function to center map view on location at a zoom level */</a>
<a name="ln80">static void _view_map_center_on_location(const dt_view_t *view, gdouble lon, gdouble lat, gdouble zoom);</a>
<a name="ln81">/* proxy function to center map view on a bounding box */</a>
<a name="ln82">static void _view_map_center_on_bbox(const dt_view_t *view, gdouble lon1, gdouble lat1, gdouble lon2, gdouble lat2);</a>
<a name="ln83">/* proxy function to show or hide the osd */</a>
<a name="ln84">static void _view_map_show_osd(const dt_view_t *view, gboolean enabled);</a>
<a name="ln85">/* proxy function to set the map source */</a>
<a name="ln86">static void _view_map_set_map_source(const dt_view_t *view, OsmGpsMapSource_t map_source);</a>
<a name="ln87">/* wrapper for setting the map source in the GObject */</a>
<a name="ln88">static void _view_map_set_map_source_g_object(const dt_view_t *view, OsmGpsMapSource_t map_source);</a>
<a name="ln89">/* proxy function to check if preferences have changed */</a>
<a name="ln90">static void _view_map_check_preference_changed(gpointer instance, gpointer user_data);</a>
<a name="ln91">/* proxy function to add a marker to the map */</a>
<a name="ln92">static GObject *_view_map_add_marker(const dt_view_t *view, dt_geo_map_display_t type, GList *points);</a>
<a name="ln93">/* proxy function to remove a marker from the map */</a>
<a name="ln94">static gboolean _view_map_remove_marker(const dt_view_t *view, dt_geo_map_display_t type, GObject *marker);</a>
<a name="ln95"> </a>
<a name="ln96">/* callback when the collection changs */</a>
<a name="ln97">static void _view_map_collection_changed(gpointer instance, gpointer user_data);</a>
<a name="ln98">/* callback when an image is selected in filmstrip, centers map */</a>
<a name="ln99">static void _view_map_filmstrip_activate_callback(gpointer instance, gpointer user_data);</a>
<a name="ln100">/* callback when an image is dropped from filmstrip */</a>
<a name="ln101">static void drag_and_drop_received(GtkWidget *widget, GdkDragContext *context, gint x, gint y,</a>
<a name="ln102">                                   GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln103">                                   gpointer data);</a>
<a name="ln104">/* callback when the user drags images FROM the map */</a>
<a name="ln105">static void _view_map_dnd_get_callback(GtkWidget *widget, GdkDragContext *context,</a>
<a name="ln106">                                       GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln107">                                       dt_view_t *self);</a>
<a name="ln108">/* callback that readds the images to the map */</a>
<a name="ln109">static void _view_map_changed_callback(OsmGpsMap *map, dt_view_t *self);</a>
<a name="ln110">/* callback that handles double clicks on the map */</a>
<a name="ln111">static gboolean _view_map_button_press_callback(GtkWidget *w, GdkEventButton *e, dt_view_t *self);</a>
<a name="ln112">/* callback when the mouse is moved */</a>
<a name="ln113">static gboolean _view_map_motion_notify_callback(GtkWidget *w, GdkEventMotion *e, dt_view_t *self);</a>
<a name="ln114">static gboolean _view_map_dnd_failed_callback(GtkWidget *widget, GdkDragContext *drag_context,</a>
<a name="ln115">                                              GtkDragResult result, dt_view_t *self);</a>
<a name="ln116">static void _view_map_dnd_remove_callback(GtkWidget *widget, GdkDragContext *context, gint x, gint y,</a>
<a name="ln117">                                          GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln118">                                          gpointer data);</a>
<a name="ln119"> </a>
<a name="ln120">static void _set_image_location(dt_view_t *self, int imgid, float longitude, float latitude, float elevation,</a>
<a name="ln121">                                gboolean set_elevation, gboolean record_undo);</a>
<a name="ln122">static void _get_image_location(int imgid, float *longitude, float *latitude, float *elevation);</a>
<a name="ln123"> </a>
<a name="ln124">static gboolean _view_map_prefs_changed(dt_map_t *lib);</a>
<a name="ln125">static void _view_map_build_main_query(dt_map_t *lib);</a>
<a name="ln126"> </a>
<a name="ln127">/* center map to on the baricenter of the image list */</a>
<a name="ln128">static gboolean _view_map_center_on_image_list(dt_view_t *self, const GList *selected_images);</a>
<a name="ln129">/* center map on the given image */</a>
<a name="ln130">static void _view_map_center_on_image(dt_view_t *self, const int32_t imgid);</a>
<a name="ln131"> </a>
<a name="ln132">const char *name(dt_view_t *self)</a>
<a name="ln133">{</a>
<a name="ln134">  return _(&quot;map&quot;);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">uint32_t view(const dt_view_t *self)</a>
<a name="ln138">{</a>
<a name="ln139">  return DT_VIEW_MAP;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">#ifdef USE_LUA</a>
<a name="ln143"> </a>
<a name="ln144">static int latitude_member(lua_State *L)</a>
<a name="ln145">{</a>
<a name="ln146">  dt_view_t *module = *(dt_view_t **)lua_touserdata(L, 1);</a>
<a name="ln147">  dt_map_t *lib = (dt_map_t *)module-&gt;data;</a>
<a name="ln148">  if(lua_gettop(L) != 3)</a>
<a name="ln149">  {</a>
<a name="ln150">    if(dt_view_manager_get_current_view(darktable.view_manager) != module)</a>
<a name="ln151">    {</a>
<a name="ln152">      lua_pushnumber(L, dt_conf_get_float(&quot;plugins/map/latitude&quot;));</a>
<a name="ln153">    }</a>
<a name="ln154">    else</a>
<a name="ln155">    {</a>
<a name="ln156">      float value;</a>
<a name="ln157">      g_object_get(G_OBJECT(lib-&gt;map), &quot;latitude&quot;, &amp;value, NULL);</a>
<a name="ln158">      lua_pushnumber(L, value);</a>
<a name="ln159">    }</a>
<a name="ln160">    return 1;</a>
<a name="ln161">  }</a>
<a name="ln162">  else</a>
<a name="ln163">  {</a>
<a name="ln164">    luaL_checktype(L, 3, LUA_TNUMBER);</a>
<a name="ln165">    float lat = lua_tonumber(L, 3);</a>
<a name="ln166">    lat = CLAMP(lat, -90, 90);</a>
<a name="ln167">    if(dt_view_manager_get_current_view(darktable.view_manager) != module)</a>
<a name="ln168">    {</a>
<a name="ln169">      dt_conf_set_float(&quot;plugins/map/latitude&quot;, lat);</a>
<a name="ln170">    }</a>
<a name="ln171">    else</a>
<a name="ln172">    {</a>
<a name="ln173">      float value;</a>
<a name="ln174">      g_object_get(G_OBJECT(lib-&gt;map), &quot;longitude&quot;, &amp;value, NULL);</a>
<a name="ln175">      osm_gps_map_set_center(lib-&gt;map, lat, value);</a>
<a name="ln176">    }</a>
<a name="ln177">    return 0;</a>
<a name="ln178">  }</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static int longitude_member(lua_State *L)</a>
<a name="ln182">{</a>
<a name="ln183">  dt_view_t *module = *(dt_view_t **)lua_touserdata(L, 1);</a>
<a name="ln184">  dt_map_t *lib = (dt_map_t *)module-&gt;data;</a>
<a name="ln185">  if(lua_gettop(L) != 3)</a>
<a name="ln186">  {</a>
<a name="ln187">    if(dt_view_manager_get_current_view(darktable.view_manager) != module)</a>
<a name="ln188">    {</a>
<a name="ln189">      lua_pushnumber(L, dt_conf_get_float(&quot;plugins/map/longitude&quot;));</a>
<a name="ln190">    }</a>
<a name="ln191">    else</a>
<a name="ln192">    {</a>
<a name="ln193">      float value;</a>
<a name="ln194">      g_object_get(G_OBJECT(lib-&gt;map), &quot;longitude&quot;, &amp;value, NULL);</a>
<a name="ln195">      lua_pushnumber(L, value);</a>
<a name="ln196">    }</a>
<a name="ln197">    return 1;</a>
<a name="ln198">  }</a>
<a name="ln199">  else</a>
<a name="ln200">  {</a>
<a name="ln201">    luaL_checktype(L, 3, LUA_TNUMBER);</a>
<a name="ln202">    float longi = lua_tonumber(L, 3);</a>
<a name="ln203">    longi = CLAMP(longi, -180, 180);</a>
<a name="ln204">    if(dt_view_manager_get_current_view(darktable.view_manager) != module)</a>
<a name="ln205">    {</a>
<a name="ln206">      dt_conf_set_float(&quot;plugins/map/longitude&quot;, longi);</a>
<a name="ln207">    }</a>
<a name="ln208">    else</a>
<a name="ln209">    {</a>
<a name="ln210">      float value;</a>
<a name="ln211">      g_object_get(G_OBJECT(lib-&gt;map), &quot;latitude&quot;, &amp;value, NULL);</a>
<a name="ln212">      osm_gps_map_set_center(lib-&gt;map, value, longi);</a>
<a name="ln213">    }</a>
<a name="ln214">    return 0;</a>
<a name="ln215">  }</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">static int zoom_member(lua_State *L)</a>
<a name="ln219">{</a>
<a name="ln220">  dt_view_t *module = *(dt_view_t **)lua_touserdata(L, 1);</a>
<a name="ln221">  dt_map_t *lib = (dt_map_t *)module-&gt;data;</a>
<a name="ln222">  if(lua_gettop(L) != 3)</a>
<a name="ln223">  {</a>
<a name="ln224">    if(dt_view_manager_get_current_view(darktable.view_manager) != module)</a>
<a name="ln225">    {</a>
<a name="ln226">      lua_pushnumber(L, dt_conf_get_float(&quot;plugins/map/zoom&quot;));</a>
<a name="ln227">    }</a>
<a name="ln228">    else</a>
<a name="ln229">    {</a>
<a name="ln230">      int value;</a>
<a name="ln231">      g_object_get(G_OBJECT(lib-&gt;map), &quot;zoom&quot;, &amp;value, NULL);</a>
<a name="ln232">      lua_pushnumber(L, value);</a>
<a name="ln233">    }</a>
<a name="ln234">    return 1;</a>
<a name="ln235">  }</a>
<a name="ln236">  else</a>
<a name="ln237">  {</a>
<a name="ln238">    // we rely on osm to correctly clamp zoom (checked in osm source</a>
<a name="ln239">    // lua can have temporarily false values but it will fix itself when entering map</a>
<a name="ln240">    // unfortunately we can't get the min max when lib-&gt;map doesn't exist</a>
<a name="ln241">    luaL_checktype(L, 3, LUA_TNUMBER);</a>
<a name="ln242">    int zoom = luaL_checkinteger(L, 3);</a>
<a name="ln243">    if(dt_view_manager_get_current_view(darktable.view_manager) != module)</a>
<a name="ln244">    {</a>
<a name="ln245">      dt_conf_set_int(&quot;plugins/map/zoom&quot;, zoom);</a>
<a name="ln246">    }</a>
<a name="ln247">    else</a>
<a name="ln248">    {</a>
<a name="ln249">      osm_gps_map_set_zoom(lib-&gt;map, zoom);</a>
<a name="ln250">    }</a>
<a name="ln251">    return 0;</a>
<a name="ln252">  }</a>
<a name="ln253">}</a>
<a name="ln254">#endif // USE_LUA</a>
<a name="ln255"> </a>
<a name="ln256">#ifndef HAVE_OSMGPSMAP_110_OR_NEWER</a>
<a name="ln257">// the following functions were taken from libosmgpsmap</a>
<a name="ln258">// Copyright (C) Marcus Bauer 2008 &lt;marcus.bauer@gmail.com&gt;</a>
<a name="ln259">// Copyright (C) 2013 John Stowers &lt;john.stowers@gmail.com&gt;</a>
<a name="ln260">// Copyright (C) 2014 Martijn Goedhart &lt;goedhart.martijn@gmail.com&gt;</a>
<a name="ln261"> </a>
<a name="ln262">#if FLT_RADIX == 2</a>
<a name="ln263">  #define LOG2(x) (ilogb(x))</a>
<a name="ln264">#else</a>
<a name="ln265">  #define LOG2(x) ((int)floor(log2(abs(x))))</a>
<a name="ln266">#endif</a>
<a name="ln267"> </a>
<a name="ln268">#define TILESIZE 256</a>
<a name="ln269"> </a>
<a name="ln270">static float deg2rad(float deg)</a>
<a name="ln271">{</a>
<a name="ln272">  return (deg * M_PI / 180.0);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">static int latlon2zoom(int pix_height, int pix_width, float lat1, float lat2, float lon1, float lon2)</a>
<a name="ln276">{</a>
<a name="ln277">  float lat1_m = atanh(sin(lat1));</a>
<a name="ln278">  float lat2_m = atanh(sin(lat2));</a>
<a name="ln279">  int zoom_lon = LOG2((double)(2 * pix_width * M_PI) / (TILESIZE * (lon2 - lon1)));</a>
<a name="ln280">  int zoom_lat = LOG2((double)(2 * pix_height * M_PI) / (TILESIZE * (lat2_m - lat1_m)));</a>
<a name="ln281">  return MIN(zoom_lon, zoom_lat);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">#undef LOG2</a>
<a name="ln285">#undef TILESIZE</a>
<a name="ln286"> </a>
<a name="ln287">//  Copyright (C) 2013 John Stowers &lt;john.stowers@gmail.com&gt;</a>
<a name="ln288">//  Copyright (C) Marcus Bauer 2008 &lt;marcus.bauer@gmail.com&gt;</a>
<a name="ln289">//  Copyright (C) John Stowers 2009 &lt;john.stowers@gmail.com&gt;</a>
<a name="ln290">//  Copyright (C) Till Harbaum 2009 &lt;till@harbaum.org&gt;</a>
<a name="ln291">//</a>
<a name="ln292">//  Contributions by</a>
<a name="ln293">//  Everaldo Canuto 2009 &lt;everaldo.canuto@gmail.com&gt;</a>
<a name="ln294">static void osm_gps_map_zoom_fit_bbox(OsmGpsMap *map, float latitude1, float latitude2, float longitude1, float longitude2)</a>
<a name="ln295">{</a>
<a name="ln296">  GtkAllocation allocation;</a>
<a name="ln297">  int zoom;</a>
<a name="ln298">  gtk_widget_get_allocation(GTK_WIDGET (map), &amp;allocation);</a>
<a name="ln299">  zoom = latlon2zoom(allocation.height, allocation.width, deg2rad(latitude1), deg2rad(latitude2), deg2rad(longitude1), deg2rad(longitude2));</a>
<a name="ln300">  osm_gps_map_set_center(map, (latitude1 + latitude2) / 2, (longitude1 + longitude2) / 2);</a>
<a name="ln301">  osm_gps_map_set_zoom(map, zoom);</a>
<a name="ln302">}</a>
<a name="ln303">#endif // HAVE_OSMGPSMAP_110_OR_NEWER</a>
<a name="ln304"> </a>
<a name="ln305">static GdkPixbuf *init_image_pin()</a>
<a name="ln306">{</a>
<a name="ln307">  int w = DT_PIXEL_APPLY_DPI(thumb_size + 2 * thumb_border), h = DT_PIXEL_APPLY_DPI(image_pin_size);</a>
<a name="ln308">  float r, g, b, a;</a>
<a name="ln309">  r = ((thumb_frame_color &amp; 0xff000000) &gt;&gt; 24) / 255.0;</a>
<a name="ln310">  g = ((thumb_frame_color &amp; 0x00ff0000) &gt;&gt; 16) / 255.0;</a>
<a name="ln311">  b = ((thumb_frame_color &amp; 0x0000ff00) &gt;&gt; 8) / 255.0;</a>
<a name="ln312">  a = ((thumb_frame_color &amp; 0x000000ff) &gt;&gt; 0) / 255.0;</a>
<a name="ln313"> </a>
<a name="ln314">  cairo_surface_t *cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, w, h);</a>
<a name="ln315">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln316">  cairo_set_source_rgba(cr, r, g, b, a);</a>
<a name="ln317">  dtgtk_cairo_paint_map_pin(cr, 0, 0, w, h, 0, NULL);</a>
<a name="ln318">  cairo_destroy(cr);</a>
<a name="ln319">  uint8_t *data = cairo_image_surface_get_data(cst);</a>
<a name="ln320">  dt_draw_cairo_to_gdk_pixbuf(data, w, h);</a>
<a name="ln321">  size_t size = w * h * 4;</a>
<a name="ln322">  uint8_t *buf = (uint8_t *)malloc(size);</a>
<a name="ln323">  memcpy(buf, data, size);</a>
<a name="ln324">  GdkPixbuf *pixbuf = gdk_pixbuf_new_from_data(buf, GDK_COLORSPACE_RGB, TRUE, 8, w, h, w * 4,</a>
<a name="ln325">                                               (GdkPixbufDestroyNotify)free, NULL);</a>
<a name="ln326">  cairo_surface_destroy(cst);</a>
<a name="ln327">  return pixbuf;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">static GdkPixbuf *init_place_pin()</a>
<a name="ln331">{</a>
<a name="ln332">  int w = DT_PIXEL_APPLY_DPI(place_pin_size), h = DT_PIXEL_APPLY_DPI(place_pin_size);</a>
<a name="ln333">  float r, g, b, a;</a>
<a name="ln334"> </a>
<a name="ln335">  cairo_surface_t *cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, w, h);</a>
<a name="ln336">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln337"> </a>
<a name="ln338">  // outer shape</a>
<a name="ln339">  r = ((pin_outer_color &amp; 0xff000000) &gt;&gt; 24) / 255.0;</a>
<a name="ln340">  g = ((pin_outer_color &amp; 0x00ff0000) &gt;&gt; 16) / 255.0;</a>
<a name="ln341">  b = ((pin_outer_color &amp; 0x0000ff00) &gt;&gt; 8) / 255.0;</a>
<a name="ln342">  a = ((pin_outer_color &amp; 0x000000ff) &gt;&gt; 0) / 255.0;</a>
<a name="ln343">  cairo_set_source_rgba(cr, r, g, b, a);</a>
<a name="ln344">  cairo_arc(cr, 0.5 * w, 0.333 * h, 0.333 * h - 2, 150.0 * (M_PI / 180.0), 30.0 * (M_PI / 180.0));</a>
<a name="ln345">  cairo_line_to(cr, 0.5 * w, h - 2);</a>
<a name="ln346">  cairo_close_path(cr);</a>
<a name="ln347">  cairo_fill_preserve(cr);</a>
<a name="ln348"> </a>
<a name="ln349">  r = ((pin_line_color &amp; 0xff000000) &gt;&gt; 24) / 255.0;</a>
<a name="ln350">  g = ((pin_line_color &amp; 0x00ff0000) &gt;&gt; 16) / 255.0;</a>
<a name="ln351">  b = ((pin_line_color &amp; 0x0000ff00) &gt;&gt; 8) / 255.0;</a>
<a name="ln352">  a = ((pin_line_color &amp; 0x000000ff) &gt;&gt; 0) / 255.0;</a>
<a name="ln353">  cairo_set_source_rgba(cr, r, g, b, a);</a>
<a name="ln354">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1));</a>
<a name="ln355">  cairo_stroke(cr);</a>
<a name="ln356"> </a>
<a name="ln357">  // inner circle</a>
<a name="ln358">  r = ((pin_inner_color &amp; 0xff000000) &gt;&gt; 24) / 255.0;</a>
<a name="ln359">  g = ((pin_inner_color &amp; 0x00ff0000) &gt;&gt; 16) / 255.0;</a>
<a name="ln360">  b = ((pin_inner_color &amp; 0x0000ff00) &gt;&gt; 8) / 255.0;</a>
<a name="ln361">  a = ((pin_inner_color &amp; 0x000000ff) &gt;&gt; 0) / 255.0;</a>
<a name="ln362">  cairo_set_source_rgba(cr, r, g, b, a);</a>
<a name="ln363">  cairo_arc(cr, 0.5 * w, 0.333 * h, 0.17 * h, 0, 2.0 * M_PI);</a>
<a name="ln364">  cairo_fill(cr);</a>
<a name="ln365"> </a>
<a name="ln366">  cairo_destroy(cr);</a>
<a name="ln367">  uint8_t *data = cairo_image_surface_get_data(cst);</a>
<a name="ln368">  dt_draw_cairo_to_gdk_pixbuf(data, w, h);</a>
<a name="ln369">  size_t size = w * h * 4;</a>
<a name="ln370">  uint8_t *buf = (uint8_t *)malloc(size);</a>
<a name="ln371">  memcpy(buf, data, size);</a>
<a name="ln372">  GdkPixbuf *pixbuf = gdk_pixbuf_new_from_data(buf, GDK_COLORSPACE_RGB, TRUE, 8, w, h, w * 4,</a>
<a name="ln373">                                               (GdkPixbufDestroyNotify)free, NULL);</a>
<a name="ln374">  cairo_surface_destroy(cst);</a>
<a name="ln375">  return pixbuf;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">void init(dt_view_t *self)</a>
<a name="ln379">{</a>
<a name="ln380">  self-&gt;data = calloc(1, sizeof(dt_map_t));</a>
<a name="ln381"> </a>
<a name="ln382">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln383"> </a>
<a name="ln384">  if(darktable.gui)</a>
<a name="ln385">  {</a>
<a name="ln386">    lib-&gt;image_pin = init_image_pin();</a>
<a name="ln387">    lib-&gt;place_pin = init_place_pin();</a>
<a name="ln388">    lib-&gt;drop_filmstrip_activated = FALSE;</a>
<a name="ln389"> </a>
<a name="ln390">    OsmGpsMapSource_t map_source</a>
<a name="ln391">        = OSM_GPS_MAP_SOURCE_OPENSTREETMAP; // open street map should be a nice default ...</a>
<a name="ln392">    gchar *old_map_source = dt_conf_get_string(&quot;plugins/map/map_source&quot;);</a>
<a name="ln393">    if(old_map_source &amp;&amp; old_map_source[0] != '\0')</a>
<a name="ln394">    {</a>
<a name="ln395">      // find the number of the stored map_source</a>
<a name="ln396">      for(int i = 0; i &lt;= OSM_GPS_MAP_SOURCE_LAST; i++)</a>
<a name="ln397">      {</a>
<a name="ln398">        const gchar *new_map_source = osm_gps_map_source_get_friendly_name(i);</a>
<a name="ln399">        if(!g_strcmp0(old_map_source, new_map_source))</a>
<a name="ln400">        {</a>
<a name="ln401">          if(osm_gps_map_source_is_valid(i)) map_source = i;</a>
<a name="ln402">          break;</a>
<a name="ln403">        }</a>
<a name="ln404">      }</a>
<a name="ln405">    }</a>
<a name="ln406">    else</a>
<a name="ln407">      dt_conf_set_string(&quot;plugins/map/map_source&quot;, osm_gps_map_source_get_friendly_name(map_source));</a>
<a name="ln408">    g_free(old_map_source);</a>
<a name="ln409"> </a>
<a name="ln410">    lib-&gt;map_source = map_source;</a>
<a name="ln411"> </a>
<a name="ln412">    lib-&gt;map = g_object_new(OSM_TYPE_GPS_MAP, &quot;map-source&quot;, OSM_GPS_MAP_SOURCE_NULL, &quot;proxy-uri&quot;,</a>
<a name="ln413">                            g_getenv(&quot;http_proxy&quot;), NULL);</a>
<a name="ln414"> </a>
<a name="ln415">    GtkWidget *parent = gtk_widget_get_parent(gtk_widget_get_parent(dt_ui_center(darktable.gui-&gt;ui)));</a>
<a name="ln416">    gtk_box_pack_start(GTK_BOX(parent), GTK_WIDGET(lib-&gt;map), TRUE, TRUE, 0);</a>
<a name="ln417"> </a>
<a name="ln418">    lib-&gt;osd = g_object_new(OSM_TYPE_GPS_MAP_OSD, &quot;show-scale&quot;, TRUE, &quot;show-coordinates&quot;, TRUE, &quot;show-dpad&quot;,</a>
<a name="ln419">                            TRUE, &quot;show-zoom&quot;, TRUE,</a>
<a name="ln420">#ifdef HAVE_OSMGPSMAP_NEWER_THAN_110</a>
<a name="ln421">                            &quot;show-copyright&quot;, TRUE,</a>
<a name="ln422">#endif</a>
<a name="ln423">                            NULL);</a>
<a name="ln424"> </a>
<a name="ln425">    if(dt_conf_get_bool(&quot;plugins/map/show_map_osd&quot;))</a>
<a name="ln426">    {</a>
<a name="ln427">      osm_gps_map_layer_add(OSM_GPS_MAP(lib-&gt;map), lib-&gt;osd);</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430">    /* allow drag&amp;drop of images from filmstrip */</a>
<a name="ln431">    gtk_drag_dest_set(GTK_WIDGET(lib-&gt;map), GTK_DEST_DEFAULT_ALL, target_list_internal, n_targets_internal,</a>
<a name="ln432">                      GDK_ACTION_COPY);</a>
<a name="ln433">    g_signal_connect(GTK_WIDGET(lib-&gt;map), &quot;drag-data-received&quot;, G_CALLBACK(drag_and_drop_received), self);</a>
<a name="ln434">    g_signal_connect(GTK_WIDGET(lib-&gt;map), &quot;changed&quot;, G_CALLBACK(_view_map_changed_callback), self);</a>
<a name="ln435">    g_signal_connect_after(G_OBJECT(lib-&gt;map), &quot;button-press-event&quot;,</a>
<a name="ln436">                           G_CALLBACK(_view_map_button_press_callback), self);</a>
<a name="ln437">    g_signal_connect(G_OBJECT(lib-&gt;map), &quot;motion-notify-event&quot;, G_CALLBACK(_view_map_motion_notify_callback),</a>
<a name="ln438">                     self);</a>
<a name="ln439"> </a>
<a name="ln440">    /* allow drag&amp;drop of images from the map, too */</a>
<a name="ln441">    g_signal_connect(GTK_WIDGET(lib-&gt;map), &quot;drag-data-get&quot;, G_CALLBACK(_view_map_dnd_get_callback), self);</a>
<a name="ln442">    g_signal_connect(GTK_WIDGET(lib-&gt;map), &quot;drag-failed&quot;, G_CALLBACK(_view_map_dnd_failed_callback), self);</a>
<a name="ln443">  }</a>
<a name="ln444"> </a>
<a name="ln445">  /* build the query string */</a>
<a name="ln446">  lib-&gt;statements.main_query = NULL;</a>
<a name="ln447">  _view_map_build_main_query(lib);</a>
<a name="ln448"> </a>
<a name="ln449">#ifdef USE_LUA</a>
<a name="ln450">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln451">  luaA_Type my_type = dt_lua_module_entry_get_type(L, &quot;view&quot;, self-&gt;module_name);</a>
<a name="ln452">  lua_pushcfunction(L, latitude_member);</a>
<a name="ln453">  dt_lua_gtk_wrap(L);</a>
<a name="ln454">  dt_lua_type_register_type(L, my_type, &quot;latitude&quot;);</a>
<a name="ln455">  lua_pushcfunction(L, longitude_member);</a>
<a name="ln456">  dt_lua_gtk_wrap(L);</a>
<a name="ln457">  dt_lua_type_register_type(L, my_type, &quot;longitude&quot;);</a>
<a name="ln458">  lua_pushcfunction(L, zoom_member);</a>
<a name="ln459">  dt_lua_gtk_wrap(L);</a>
<a name="ln460">  dt_lua_type_register_type(L, my_type, &quot;zoom&quot;);</a>
<a name="ln461"> </a>
<a name="ln462">#endif // USE_LUA</a>
<a name="ln463">  /* connect collection changed signal */</a>
<a name="ln464">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED,</a>
<a name="ln465">                            G_CALLBACK(_view_map_collection_changed), (gpointer)self);</a>
<a name="ln466">  /* connect preference changed signal */</a>
<a name="ln467">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE,</a>
<a name="ln468">                            G_CALLBACK(_view_map_check_preference_changed), (gpointer)self);</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">void cleanup(dt_view_t *self)</a>
<a name="ln472">{</a>
<a name="ln473">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln474"> </a>
<a name="ln475">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_view_map_collection_changed), self);</a>
<a name="ln476">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_view_map_check_preference_changed), self);</a>
<a name="ln477"> </a>
<a name="ln478">  if(darktable.gui)</a>
<a name="ln479">  {</a>
<a name="ln480">    g_object_unref(G_OBJECT(lib-&gt;image_pin));</a>
<a name="ln481">    g_object_unref(G_OBJECT(lib-&gt;place_pin));</a>
<a name="ln482">    g_object_unref(G_OBJECT(lib-&gt;osd));</a>
<a name="ln483">    osm_gps_map_image_remove_all(lib-&gt;map);</a>
<a name="ln484">    if(lib-&gt;images)</a>
<a name="ln485">    {</a>
<a name="ln486">      g_slist_free_full(lib-&gt;images, g_free);</a>
<a name="ln487">      lib-&gt;images = NULL;</a>
<a name="ln488">    }</a>
<a name="ln489">    // FIXME: it would be nice to cleanly destroy the object, but we are doing this inside expose() so</a>
<a name="ln490">    // removing the widget can cause segfaults.</a>
<a name="ln491">    //     g_object_unref(G_OBJECT(lib-&gt;map));</a>
<a name="ln492">  }</a>
<a name="ln493">  if(lib-&gt;statements.main_query) sqlite3_finalize(lib-&gt;statements.main_query);</a>
<a name="ln494">  free(self-&gt;data);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">void configure(dt_view_t *self, int wd, int ht)</a>
<a name="ln498">{</a>
<a name="ln499">  // dt_capture_t *lib=(dt_capture_t*)self-&gt;data;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">int try_enter(dt_view_t *self)</a>
<a name="ln503">{</a>
<a name="ln504">  return 0;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">static gboolean _view_map_redraw(gpointer user_data)</a>
<a name="ln508">{</a>
<a name="ln509">  dt_view_t *self = (dt_view_t *)user_data;</a>
<a name="ln510">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln511">  g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln512">  return FALSE; // remove the function again</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">static void _view_map_changed_callback(OsmGpsMap *map, dt_view_t *self)</a>
<a name="ln516">{</a>
<a name="ln517">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln518"> </a>
<a name="ln519">  OsmGpsMapPoint bb[2];</a>
<a name="ln520"> </a>
<a name="ln521">  /* get bounding box coords */</a>
<a name="ln522">  osm_gps_map_get_bbox(map, &amp;bb[0], &amp;bb[1]);</a>
<a name="ln523">  float bb_0_lat = 0.0, bb_0_lon = 0.0, bb_1_lat = 0.0, bb_1_lon = 0.0;</a>
<a name="ln524">  osm_gps_map_point_get_degrees(&amp;bb[0], &amp;bb_0_lat, &amp;bb_0_lon);</a>
<a name="ln525">  osm_gps_map_point_get_degrees(&amp;bb[1], &amp;bb_1_lat, &amp;bb_1_lon);</a>
<a name="ln526"> </a>
<a name="ln527">  /* make the bounding box a little bigger to the west and south */</a>
<a name="ln528">  float lat0 = 0.0, lon0 = 0.0, lat1 = 0.0, lon1 = 0.0;</a>
<a name="ln529">  OsmGpsMapPoint *pt0 = osm_gps_map_point_new_degrees(0.0, 0.0),</a>
<a name="ln530">                 *pt1 = osm_gps_map_point_new_degrees(0.0, 0.0);</a>
<a name="ln531">  osm_gps_map_convert_screen_to_geographic(map, 0, 0, pt0);</a>
<a name="ln532">  osm_gps_map_convert_screen_to_geographic(map, 1.5 * thumb_size, 1.5 * thumb_size, pt1);</a>
<a name="ln533">  osm_gps_map_point_get_degrees(pt0, &amp;lat0, &amp;lon0);</a>
<a name="ln534">  osm_gps_map_point_get_degrees(pt1, &amp;lat1, &amp;lon1);</a>
<a name="ln535">  osm_gps_map_point_free(pt0);</a>
<a name="ln536">  osm_gps_map_point_free(pt1);</a>
<a name="ln537">  double south_border = lat0 - lat1, west_border = lon1 - lon0;</a>
<a name="ln538"> </a>
<a name="ln539">  /* get map view state and store  */</a>
<a name="ln540">  int zoom;</a>
<a name="ln541">  float center_lat, center_lon;</a>
<a name="ln542">  g_object_get(G_OBJECT(map), &quot;zoom&quot;, &amp;zoom, &quot;latitude&quot;, &amp;center_lat, &quot;longitude&quot;, &amp;center_lon, NULL);</a>
<a name="ln543">  dt_conf_set_float(&quot;plugins/map/longitude&quot;, center_lon);</a>
<a name="ln544">  dt_conf_set_float(&quot;plugins/map/latitude&quot;, center_lat);</a>
<a name="ln545">  dt_conf_set_int(&quot;plugins/map/zoom&quot;, zoom);</a>
<a name="ln546"> </a>
<a name="ln547">  /* check if the prefs have changed and rebuild main_query if needed */</a>
<a name="ln548">  if(_view_map_prefs_changed(lib)) _view_map_build_main_query(lib);</a>
<a name="ln549"> </a>
<a name="ln550">  /* let's reset and reuse the main_query statement */</a>
<a name="ln551">  DT_DEBUG_SQLITE3_CLEAR_BINDINGS(lib-&gt;statements.main_query);</a>
<a name="ln552">  DT_DEBUG_SQLITE3_RESET(lib-&gt;statements.main_query);</a>
<a name="ln553"> </a>
<a name="ln554">  /* bind bounding box coords for the main query */</a>
<a name="ln555">  DT_DEBUG_SQLITE3_BIND_DOUBLE(lib-&gt;statements.main_query, 1, bb_0_lon - west_border);</a>
<a name="ln556">  DT_DEBUG_SQLITE3_BIND_DOUBLE(lib-&gt;statements.main_query, 2, bb_1_lon);</a>
<a name="ln557">  DT_DEBUG_SQLITE3_BIND_DOUBLE(lib-&gt;statements.main_query, 3, bb_0_lat);</a>
<a name="ln558">  DT_DEBUG_SQLITE3_BIND_DOUBLE(lib-&gt;statements.main_query, 4, bb_1_lat - south_border);</a>
<a name="ln559">  DT_DEBUG_SQLITE3_BIND_DOUBLE(lib-&gt;statements.main_query, 5, center_lat);</a>
<a name="ln560">  DT_DEBUG_SQLITE3_BIND_DOUBLE(lib-&gt;statements.main_query, 6, center_lon);</a>
<a name="ln561"> </a>
<a name="ln562">  /* remove the old images */</a>
<a name="ln563">  if(lib-&gt;images)</a>
<a name="ln564">  {</a>
<a name="ln565">    // we can't use osm_gps_map_image_remove_all() because we want to keep the marker</a>
<a name="ln566">    for(GSList *iter = lib-&gt;images; iter; iter = g_slist_next(iter))</a>
<a name="ln567">    {</a>
<a name="ln568">      dt_map_image_t *image = (dt_map_image_t *)iter-&gt;data;</a>
<a name="ln569">      osm_gps_map_image_remove(map, image-&gt;image);</a>
<a name="ln570">    }</a>
<a name="ln571">    g_slist_free_full(lib-&gt;images, g_free);</a>
<a name="ln572">    lib-&gt;images = NULL;</a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575">  /* add all images to the map */</a>
<a name="ln576">  gboolean needs_redraw = FALSE;</a>
<a name="ln577">  const int _thumb_size = DT_PIXEL_APPLY_DPI(thumb_size);</a>
<a name="ln578">  dt_mipmap_size_t mip = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, _thumb_size, _thumb_size);</a>
<a name="ln579">  while(sqlite3_step(lib-&gt;statements.main_query) == SQLITE_ROW)</a>
<a name="ln580">  {</a>
<a name="ln581">    int imgid = sqlite3_column_int(lib-&gt;statements.main_query, 0);</a>
<a name="ln582">    dt_mipmap_buffer_t buf;</a>
<a name="ln583">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, mip, DT_MIPMAP_BEST_EFFORT, 'r');</a>
<a name="ln584"> </a>
<a name="ln585">    if(buf.buf)</a>
<a name="ln586">    {</a>
<a name="ln587">      GdkPixbuf *source = NULL, *thumb = NULL;</a>
<a name="ln588"> </a>
<a name="ln589">      for(size_t i = 3; i &lt; (size_t)4 * buf.width * buf.height; i += 4) buf.buf[i] = UINT8_MAX;</a>
<a name="ln590"> </a>
<a name="ln591">      int w = _thumb_size, h = _thumb_size;</a>
<a name="ln592">      const float _thumb_border = DT_PIXEL_APPLY_DPI(thumb_border), _pin_size = DT_PIXEL_APPLY_DPI(image_pin_size);</a>
<a name="ln593">      if(buf.width &lt; buf.height)</a>
<a name="ln594">        w = (buf.width * _thumb_size) / buf.height; // portrait</a>
<a name="ln595">      else</a>
<a name="ln596">        h = (buf.height * _thumb_size) / buf.width; // landscape</a>
<a name="ln597"> </a>
<a name="ln598">      // next we get a pixbuf for the image</a>
<a name="ln599">      source = gdk_pixbuf_new_from_data(buf.buf, GDK_COLORSPACE_RGB, TRUE, 8, buf.width, buf.height,</a>
<a name="ln600">                                        buf.width * 4, NULL, NULL);</a>
<a name="ln601">      if(!source) goto map_changed_failure;</a>
<a name="ln602"> </a>
<a name="ln603">      // now we want a slightly larger pixbuf that we can put the image on</a>
<a name="ln604">      thumb = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, w + 2 * _thumb_border,</a>
<a name="ln605">                             h + 2 * _thumb_border + _pin_size);</a>
<a name="ln606">      if(!thumb) goto map_changed_failure;</a>
<a name="ln607">      gdk_pixbuf_fill(thumb, thumb_frame_color);</a>
<a name="ln608"> </a>
<a name="ln609">      // put the image onto the frame</a>
<a name="ln610">      gdk_pixbuf_scale(source, thumb, _thumb_border, _thumb_border, w, h, _thumb_border, _thumb_border,</a>
<a name="ln611">                       (1.0 * w) / buf.width, (1.0 * h) / buf.height, GDK_INTERP_HYPER);</a>
<a name="ln612"> </a>
<a name="ln613">      // and finally add the pin</a>
<a name="ln614">      gdk_pixbuf_copy_area(lib-&gt;image_pin, 0, 0, w + 2 * _thumb_border, _pin_size, thumb, 0, h + 2 * _thumb_border);</a>
<a name="ln615"> </a>
<a name="ln616">      const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln617">      if(!cimg) goto map_changed_failure;</a>
<a name="ln618">      dt_map_image_t *entry = (dt_map_image_t *)malloc(sizeof(dt_map_image_t));</a>
<a name="ln619">      if(!entry)</a>
<a name="ln620">      {</a>
<a name="ln621">        dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln622">        goto map_changed_failure;</a>
<a name="ln623">      }</a>
<a name="ln624">      entry-&gt;imgid = imgid;</a>
<a name="ln625">      entry-&gt;image = osm_gps_map_image_add_with_alignment(map, cimg-&gt;latitude, cimg-&gt;longitude, thumb, 0, 1);</a>
<a name="ln626">      entry-&gt;width = w;</a>
<a name="ln627">      entry-&gt;height = h;</a>
<a name="ln628">      lib-&gt;images = g_slist_prepend(lib-&gt;images, entry);</a>
<a name="ln629">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln630"> </a>
<a name="ln631">    map_changed_failure:</a>
<a name="ln632">      if(source) g_object_unref(source);</a>
<a name="ln633">      if(thumb) g_object_unref(thumb);</a>
<a name="ln634">    }</a>
<a name="ln635">    else</a>
<a name="ln636">      needs_redraw = TRUE;</a>
<a name="ln637">    dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln638">  }</a>
<a name="ln639"> </a>
<a name="ln640">  // not exactly thread safe, but should be good enough for updating the display</a>
<a name="ln641">  static int timeout_event_source = 0;</a>
<a name="ln642">  if(needs_redraw &amp;&amp; timeout_event_source == 0)</a>
<a name="ln643">    timeout_event_source = g_timeout_add_seconds(</a>
<a name="ln644">        1, _view_map_redraw, self); // try again in a second, maybe some pictures have loaded by then</a>
<a name="ln645">  else</a>
<a name="ln646">    timeout_event_source = 0;</a>
<a name="ln647"> </a>
<a name="ln648">  // activate this callback late in the process as we need the filmstrip proxy to be setup. This is not the</a>
<a name="ln649">  // case in the initialization phase.</a>
<a name="ln650">  if(!lib-&gt;drop_filmstrip_activated &amp;&amp; darktable.view_manager-&gt;proxy.filmstrip.module)</a>
<a name="ln651">  {</a>
<a name="ln652">    g_signal_connect(</a>
<a name="ln653">        darktable.view_manager-&gt;proxy.filmstrip.widget(darktable.view_manager-&gt;proxy.filmstrip.module),</a>
<a name="ln654">        &quot;drag-data-received&quot;, G_CALLBACK(_view_map_dnd_remove_callback), self);</a>
<a name="ln655">    lib-&gt;drop_filmstrip_activated = TRUE;</a>
<a name="ln656">  }</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">static int _view_map_get_img_at_pos(dt_view_t *self, double x, double y)</a>
<a name="ln660">{</a>
<a name="ln661">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln662">  GSList *iter;</a>
<a name="ln663"> </a>
<a name="ln664">  for(iter = lib-&gt;images; iter != NULL; iter = iter-&gt;next)</a>
<a name="ln665">  {</a>
<a name="ln666">    dt_map_image_t *entry = (dt_map_image_t *)iter-&gt;data;</a>
<a name="ln667">    OsmGpsMapImage *image = entry-&gt;image;</a>
<a name="ln668">    OsmGpsMapPoint *pt = (OsmGpsMapPoint *)osm_gps_map_image_get_point(image);</a>
<a name="ln669">    gint img_x = 0, img_y = 0;</a>
<a name="ln670">    osm_gps_map_convert_geographic_to_screen(lib-&gt;map, pt, &amp;img_x, &amp;img_y);</a>
<a name="ln671">    img_y -= DT_PIXEL_APPLY_DPI(image_pin_size);</a>
<a name="ln672">    if(x &gt;= img_x &amp;&amp; x &lt;= img_x + entry-&gt;width &amp;&amp; y &lt;= img_y &amp;&amp; y &gt;= img_y - entry-&gt;height)</a>
<a name="ln673">      return entry-&gt;imgid;</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  return 0;</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">static gboolean _view_map_motion_notify_callback(GtkWidget *widget, GdkEventMotion *e, dt_view_t *self)</a>
<a name="ln680">{</a>
<a name="ln681">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln682"> </a>
<a name="ln683">  if(lib-&gt;start_drag &amp;&amp; lib-&gt;selected_image &gt; 0)</a>
<a name="ln684">  {</a>
<a name="ln685">    for(GSList *iter = lib-&gt;images; iter != NULL; iter = iter-&gt;next)</a>
<a name="ln686">    {</a>
<a name="ln687">      dt_map_image_t *entry = (dt_map_image_t *)iter-&gt;data;</a>
<a name="ln688">      OsmGpsMapImage *image = entry-&gt;image;</a>
<a name="ln689">      if(entry-&gt;imgid == lib-&gt;selected_image)</a>
<a name="ln690">      {</a>
<a name="ln691">        osm_gps_map_image_remove(lib-&gt;map, image);</a>
<a name="ln692">        break;</a>
<a name="ln693">      }</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">    lib-&gt;start_drag = FALSE;</a>
<a name="ln697">    GtkTargetList *targets = gtk_target_list_new(target_list_all, n_targets_all);</a>
<a name="ln698"> </a>
<a name="ln699">    // FIXME: for some reason the image is only shown when it's above a certain size,</a>
<a name="ln700">    // which happens to be &gt; than the normal-DPI one. When dragging from filmstrip it works though.</a>
<a name="ln701">    const int _thumb_size = DT_PIXEL_APPLY_DPI(thumb_size);</a>
<a name="ln702">    dt_mipmap_buffer_t buf;</a>
<a name="ln703">    dt_mipmap_size_t mip = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, _thumb_size, _thumb_size);</a>
<a name="ln704">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, lib-&gt;selected_image, mip, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln705"> </a>
<a name="ln706">    if(buf.buf)</a>
<a name="ln707">    {</a>
<a name="ln708">      GdkPixbuf *source = NULL, *thumb = NULL;</a>
<a name="ln709"> </a>
<a name="ln710">      for(size_t i = 3; i &lt; (size_t)4 * buf.width * buf.height; i += 4) buf.buf[i] = UINT8_MAX;</a>
<a name="ln711"> </a>
<a name="ln712">      int w = _thumb_size, h = _thumb_size;</a>
<a name="ln713">      const float _thumb_border = DT_PIXEL_APPLY_DPI(thumb_border);</a>
<a name="ln714">      if(buf.width &lt; buf.height)</a>
<a name="ln715">        w = (buf.width * _thumb_size) / buf.height; // portrait</a>
<a name="ln716">      else</a>
<a name="ln717">        h = (buf.height * _thumb_size) / buf.width; // landscape</a>
<a name="ln718"> </a>
<a name="ln719">      // next we get a pixbuf for the image</a>
<a name="ln720">      source = gdk_pixbuf_new_from_data(buf.buf, GDK_COLORSPACE_RGB, TRUE, 8, buf.width, buf.height,</a>
<a name="ln721">                                        buf.width * 4, NULL, NULL);</a>
<a name="ln722"> </a>
<a name="ln723">      // now we want a slightly larger pixbuf that we can put the image on</a>
<a name="ln724">      thumb = gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, w + 2 * _thumb_border, h + 2 * _thumb_border);</a>
<a name="ln725">      gdk_pixbuf_fill(thumb, thumb_frame_color);</a>
<a name="ln726"> </a>
<a name="ln727">      // put the image onto the frame</a>
<a name="ln728">      gdk_pixbuf_scale(source, thumb, _thumb_border, _thumb_border, w, h, _thumb_border, _thumb_border,</a>
<a name="ln729">                       (1.0 * w) / buf.width, (1.0 * h) / buf.height, GDK_INTERP_HYPER);</a>
<a name="ln730"> </a>
<a name="ln731">      GdkDragContext *context = gtk_drag_begin_with_coordinates(GTK_WIDGET(lib-&gt;map), targets,</a>
<a name="ln732">                                                                GDK_ACTION_COPY, 1, (GdkEvent *)e, -1, -1);</a>
<a name="ln733"> </a>
<a name="ln734">      gtk_drag_set_icon_pixbuf(context, thumb, 0, h + 2 * _thumb_border);</a>
<a name="ln735"> </a>
<a name="ln736">      if(source) g_object_unref(source);</a>
<a name="ln737">      if(thumb) g_object_unref(thumb);</a>
<a name="ln738">    }</a>
<a name="ln739"> </a>
<a name="ln740">    dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln741"> </a>
<a name="ln742">    gtk_target_list_unref(targets);</a>
<a name="ln743">    return TRUE;</a>
<a name="ln744">  }</a>
<a name="ln745">  return FALSE;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">static gboolean _view_map_button_press_callback(GtkWidget *w, GdkEventButton *e, dt_view_t *self)</a>
<a name="ln749">{</a>
<a name="ln750">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln751">  if(e-&gt;button == 1)</a>
<a name="ln752">  {</a>
<a name="ln753">    // check if the click was on an image or just some random position</a>
<a name="ln754">    lib-&gt;selected_image = _view_map_get_img_at_pos(self, e-&gt;x, e-&gt;y);</a>
<a name="ln755">    if(e-&gt;type == GDK_BUTTON_PRESS &amp;&amp; lib-&gt;selected_image &gt; 0)</a>
<a name="ln756">    {</a>
<a name="ln757">      lib-&gt;start_drag = TRUE;</a>
<a name="ln758">      return TRUE;</a>
<a name="ln759">    }</a>
<a name="ln760">    if(e-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln761">    {</a>
<a name="ln762">      if(lib-&gt;selected_image &gt; 0)</a>
<a name="ln763">      {</a>
<a name="ln764">        // open the image in darkroom</a>
<a name="ln765">        dt_control_set_mouse_over_id(lib-&gt;selected_image);</a>
<a name="ln766">        dt_ctl_switch_mode_to(&quot;darkroom&quot;);</a>
<a name="ln767">        return TRUE;</a>
<a name="ln768">      }</a>
<a name="ln769">      else</a>
<a name="ln770">      {</a>
<a name="ln771">        // zoom into that position</a>
<a name="ln772">        float longitude, latitude;</a>
<a name="ln773">        OsmGpsMapPoint *pt = osm_gps_map_point_new_degrees(0.0, 0.0);</a>
<a name="ln774">        osm_gps_map_convert_screen_to_geographic(lib-&gt;map, e-&gt;x, e-&gt;y, pt);</a>
<a name="ln775">        osm_gps_map_point_get_degrees(pt, &amp;latitude, &amp;longitude);</a>
<a name="ln776">        osm_gps_map_point_free(pt);</a>
<a name="ln777">        int zoom, max_zoom;</a>
<a name="ln778">        g_object_get(G_OBJECT(lib-&gt;map), &quot;zoom&quot;, &amp;zoom, &quot;max-zoom&quot;, &amp;max_zoom, NULL);</a>
<a name="ln779">        zoom = MIN(zoom + 1, max_zoom);</a>
<a name="ln780">        _view_map_center_on_location(self, longitude, latitude, zoom);</a>
<a name="ln781">      }</a>
<a name="ln782">      return TRUE;</a>
<a name="ln783">    }</a>
<a name="ln784">  }</a>
<a name="ln785">  return FALSE;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">static gboolean _display_selected(gpointer user_data)</a>
<a name="ln789">{</a>
<a name="ln790">  dt_view_t *self = (dt_view_t *)user_data;</a>
<a name="ln791">  gboolean done = FALSE;</a>
<a name="ln792"> </a>
<a name="ln793">  GList *selected_images = dt_collection_get_selected(darktable.collection, -1);</a>
<a name="ln794">  if(selected_images)</a>
<a name="ln795">  {</a>
<a name="ln796">    done = _view_map_center_on_image_list(self, selected_images);</a>
<a name="ln797">    g_list_free(selected_images);</a>
<a name="ln798">  }</a>
<a name="ln799"> </a>
<a name="ln800">  if(!done)</a>
<a name="ln801">  {</a>
<a name="ln802">    dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln803">    GList *collection_images = dt_collection_get_all(darktable.collection, lib-&gt;max_images_drawn);</a>
<a name="ln804">    if(collection_images)</a>
<a name="ln805">    {</a>
<a name="ln806">      done = _view_map_center_on_image_list(self, collection_images);</a>
<a name="ln807">      g_list_free(collection_images);</a>
<a name="ln808">    }</a>
<a name="ln809">  }</a>
<a name="ln810">  return FALSE; // don't call again</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">void enter(dt_view_t *self)</a>
<a name="ln814">{</a>
<a name="ln815">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln816"> </a>
<a name="ln817">  lib-&gt;selected_image = 0;</a>
<a name="ln818">  lib-&gt;start_drag = FALSE;</a>
<a name="ln819"> </a>
<a name="ln820">  /* set the correct map source */</a>
<a name="ln821">  _view_map_set_map_source_g_object(self, lib-&gt;map_source);</a>
<a name="ln822"> </a>
<a name="ln823">  /* replace center widget */</a>
<a name="ln824">  GtkWidget *parent = gtk_widget_get_parent(gtk_widget_get_parent(dt_ui_center(darktable.gui-&gt;ui)));</a>
<a name="ln825">  gtk_widget_hide(gtk_widget_get_parent(dt_ui_center(darktable.gui-&gt;ui)));</a>
<a name="ln826"> </a>
<a name="ln827">  gtk_box_reorder_child(GTK_BOX(parent), GTK_WIDGET(lib-&gt;map), 2);</a>
<a name="ln828"> </a>
<a name="ln829">  gtk_widget_show_all(GTK_WIDGET(lib-&gt;map));</a>
<a name="ln830"> </a>
<a name="ln831">  /* setup proxy functions */</a>
<a name="ln832">  darktable.view_manager-&gt;proxy.map.view = self;</a>
<a name="ln833">  darktable.view_manager-&gt;proxy.map.center_on_location = _view_map_center_on_location;</a>
<a name="ln834">  darktable.view_manager-&gt;proxy.map.center_on_bbox = _view_map_center_on_bbox;</a>
<a name="ln835">  darktable.view_manager-&gt;proxy.map.show_osd = _view_map_show_osd;</a>
<a name="ln836">  darktable.view_manager-&gt;proxy.map.set_map_source = _view_map_set_map_source;</a>
<a name="ln837">  darktable.view_manager-&gt;proxy.map.add_marker = _view_map_add_marker;</a>
<a name="ln838">  darktable.view_manager-&gt;proxy.map.remove_marker = _view_map_remove_marker;</a>
<a name="ln839"> </a>
<a name="ln840">  /* restore last zoom,location in map */</a>
<a name="ln841">  float lon = dt_conf_get_float(&quot;plugins/map/longitude&quot;);</a>
<a name="ln842">  lon = CLAMP(lon, -180, 180);</a>
<a name="ln843">  float lat = dt_conf_get_float(&quot;plugins/map/latitude&quot;);</a>
<a name="ln844">  lat = CLAMP(lat, -90, 90);</a>
<a name="ln845">  const int zoom = dt_conf_get_int(&quot;plugins/map/zoom&quot;);</a>
<a name="ln846"> </a>
<a name="ln847">  osm_gps_map_set_center_and_zoom(lib-&gt;map, lat, lon, zoom);</a>
<a name="ln848"> </a>
<a name="ln849">  /* connect signal for filmstrip image activate */</a>
<a name="ln850">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE,</a>
<a name="ln851">                            G_CALLBACK(_view_map_filmstrip_activate_callback), self);</a>
<a name="ln852"> </a>
<a name="ln853">  /* scroll filmstrip to the first selected image */</a>
<a name="ln854">  GList *selected_images = dt_collection_get_selected(darktable.collection, 1);</a>
<a name="ln855">  if(selected_images)</a>
<a name="ln856">  {</a>
<a name="ln857">    dt_view_filmstrip_scroll_to_image(darktable.view_manager, GPOINTER_TO_INT(selected_images-&gt;data), FALSE);</a>
<a name="ln858">    g_list_free(selected_images);</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  g_timeout_add(250, _display_selected, self);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">void leave(dt_view_t *self)</a>
<a name="ln865">{</a>
<a name="ln866">  /* disable the map source again. no need to risk network traffic while we are not in map mode. */</a>
<a name="ln867">  _view_map_set_map_source_g_object(self, OSM_GPS_MAP_SOURCE_NULL);</a>
<a name="ln868"> </a>
<a name="ln869">  /* disconnect from filmstrip image activate */</a>
<a name="ln870">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_view_map_filmstrip_activate_callback),</a>
<a name="ln871">                               (gpointer)self);</a>
<a name="ln872"> </a>
<a name="ln873">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln874"> </a>
<a name="ln875">  gtk_widget_hide(GTK_WIDGET(lib-&gt;map));</a>
<a name="ln876">  gtk_widget_show_all(gtk_widget_get_parent(dt_ui_center(darktable.gui-&gt;ui)));</a>
<a name="ln877"> </a>
<a name="ln878">  /* reset proxy */</a>
<a name="ln879">  darktable.view_manager-&gt;proxy.map.view = NULL;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">void mouse_moved(dt_view_t *self, double x, double y, double pressure, int which)</a>
<a name="ln883">{</a>
<a name="ln884">  // redraw center on mousemove</a>
<a name="ln885">  dt_control_queue_redraw_center();</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">void init_key_accels(dt_view_t *self)</a>
<a name="ln889">{</a>
<a name="ln890">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;undo&quot;), GDK_KEY_z, GDK_CONTROL_MASK);</a>
<a name="ln891">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;redo&quot;), GDK_KEY_y, GDK_CONTROL_MASK);</a>
<a name="ln892">  // Film strip shortcuts</a>
<a name="ln893">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;toggle film strip&quot;), GDK_KEY_f, GDK_CONTROL_MASK);</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">static gboolean _view_map_undo_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln897">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln898">{</a>
<a name="ln899">  dt_undo_do_undo(darktable.undo, DT_UNDO_GEOTAG);</a>
<a name="ln900">  return TRUE;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">static gboolean _view_map_redo_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln904">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln905">{</a>
<a name="ln906">  dt_undo_do_redo(darktable.undo, DT_UNDO_GEOTAG);</a>
<a name="ln907">  return TRUE;</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910">static gboolean film_strip_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln911">                                     GdkModifierType modifier, gpointer data)</a>
<a name="ln912">{</a>
<a name="ln913">  dt_lib_module_t *m = darktable.view_manager-&gt;proxy.filmstrip.module;</a>
<a name="ln914">  gboolean vs = dt_lib_is_visible(m);</a>
<a name="ln915">  dt_lib_set_visible(m, !vs);</a>
<a name="ln916">  return TRUE;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">void connect_key_accels(dt_view_t *self)</a>
<a name="ln920">{</a>
<a name="ln921">  // undo/redo</a>
<a name="ln922">  GClosure *closure = g_cclosure_new(G_CALLBACK(_view_map_undo_callback), (gpointer)self, NULL);</a>
<a name="ln923">  dt_accel_connect_view(self, &quot;undo&quot;, closure);</a>
<a name="ln924">  closure = g_cclosure_new(G_CALLBACK(_view_map_redo_callback), (gpointer)self, NULL);</a>
<a name="ln925">  dt_accel_connect_view(self, &quot;redo&quot;, closure);</a>
<a name="ln926">  // Film strip shortcuts</a>
<a name="ln927">  closure = g_cclosure_new(G_CALLBACK(film_strip_key_accel), (gpointer)self, NULL);</a>
<a name="ln928">  dt_accel_connect_view(self, &quot;toggle film strip&quot;, closure);</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931"> </a>
<a name="ln932">static void _view_map_center_on_location(const dt_view_t *view, gdouble lon, gdouble lat, gdouble zoom)</a>
<a name="ln933">{</a>
<a name="ln934">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln935">  osm_gps_map_set_center_and_zoom(lib-&gt;map, lat, lon, zoom);</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">static void _view_map_center_on_bbox(const dt_view_t *view, gdouble lon1, gdouble lat1, gdouble lon2, gdouble lat2)</a>
<a name="ln939">{</a>
<a name="ln940">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln941">  osm_gps_map_zoom_fit_bbox(lib-&gt;map, lat1, lat2, lon1, lon2);</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">static void _view_map_show_osd(const dt_view_t *view, gboolean enabled)</a>
<a name="ln945">{</a>
<a name="ln946">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln947"> </a>
<a name="ln948">  gboolean old_value = dt_conf_get_bool(&quot;plugins/map/show_map_osd&quot;);</a>
<a name="ln949">  if(enabled == old_value) return;</a>
<a name="ln950"> </a>
<a name="ln951">  dt_conf_set_bool(&quot;plugins/map/show_map_osd&quot;, enabled);</a>
<a name="ln952">  if(enabled)</a>
<a name="ln953">    osm_gps_map_layer_add(OSM_GPS_MAP(lib-&gt;map), lib-&gt;osd);</a>
<a name="ln954">  else</a>
<a name="ln955">    osm_gps_map_layer_remove(OSM_GPS_MAP(lib-&gt;map), lib-&gt;osd);</a>
<a name="ln956"> </a>
<a name="ln957">  g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">static void _view_map_set_map_source_g_object(const dt_view_t *view, OsmGpsMapSource_t map_source)</a>
<a name="ln961">{</a>
<a name="ln962">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln963"> </a>
<a name="ln964">  GValue value = {</a>
<a name="ln965">    0,</a>
<a name="ln966">  };</a>
<a name="ln967">  g_value_init(&amp;value, G_TYPE_INT);</a>
<a name="ln968">  g_value_set_int(&amp;value, map_source);</a>
<a name="ln969">  g_object_set_property(G_OBJECT(lib-&gt;map), &quot;map-source&quot;, &amp;value);</a>
<a name="ln970">  g_value_unset(&amp;value);</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">static void _view_map_set_map_source(const dt_view_t *view, OsmGpsMapSource_t map_source)</a>
<a name="ln974">{</a>
<a name="ln975">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln976"> </a>
<a name="ln977">  if(map_source == lib-&gt;map_source) return;</a>
<a name="ln978"> </a>
<a name="ln979">  lib-&gt;map_source = map_source;</a>
<a name="ln980">  dt_conf_set_string(&quot;plugins/map/map_source&quot;, osm_gps_map_source_get_friendly_name(map_source));</a>
<a name="ln981">  _view_map_set_map_source_g_object(view, map_source);</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984">static OsmGpsMapImage *_view_map_add_pin(const dt_view_t *view, GList *points)</a>
<a name="ln985">{</a>
<a name="ln986">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln987">  dt_geo_map_display_point_t *p = (dt_geo_map_display_point_t *)points-&gt;data;</a>
<a name="ln988">  return osm_gps_map_image_add_with_alignment(lib-&gt;map, p-&gt;lat, p-&gt;lon, lib-&gt;place_pin, 0.5, 1);</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">static gboolean _view_map_remove_pin(const dt_view_t *view, OsmGpsMapImage *pin)</a>
<a name="ln992">{</a>
<a name="ln993">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln994">  return osm_gps_map_image_remove(lib-&gt;map, pin);</a>
<a name="ln995">}</a>
<a name="ln996"> </a>
<a name="ln997">#ifdef HAVE_OSMGPSMAP_110_OR_NEWER</a>
<a name="ln998">static OsmGpsMapPolygon *_view_map_add_polygon(const dt_view_t *view, GList *points)</a>
<a name="ln999">{</a>
<a name="ln1000">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln1001"> </a>
<a name="ln1002">  OsmGpsMapPolygon *poly = osm_gps_map_polygon_new();</a>
<a name="ln1003">  OsmGpsMapTrack* track = osm_gps_map_track_new();</a>
<a name="ln1004"> </a>
<a name="ln1005">  for(GList *iter = g_list_first(points); iter; iter = g_list_next(iter))</a>
<a name="ln1006">  {</a>
<a name="ln1007">    dt_geo_map_display_point_t *p = (dt_geo_map_display_point_t *)iter-&gt;data;</a>
<a name="ln1008">    OsmGpsMapPoint* point = osm_gps_map_point_new_degrees(p-&gt;lat, p-&gt;lon);</a>
<a name="ln1009">    osm_gps_map_track_add_point(track, point);</a>
<a name="ln1010">  }</a>
<a name="ln1011"> </a>
<a name="ln1012">  g_object_set(poly, &quot;track&quot;, track, (gchar *)0);</a>
<a name="ln1013">  g_object_set(poly, &quot;editable&quot;, FALSE, (gchar *)0);</a>
<a name="ln1014">  g_object_set(poly, &quot;shaded&quot;, FALSE, (gchar *)0);</a>
<a name="ln1015"> </a>
<a name="ln1016">  osm_gps_map_polygon_add(lib-&gt;map, poly);</a>
<a name="ln1017"> </a>
<a name="ln1018">  return poly;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">static gboolean _view_map_remove_polygon(const dt_view_t *view, OsmGpsMapPolygon *polygon)</a>
<a name="ln1022">{</a>
<a name="ln1023">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln1024">  return osm_gps_map_polygon_remove(lib-&gt;map, polygon);</a>
<a name="ln1025">}</a>
<a name="ln1026">#endif</a>
<a name="ln1027"> </a>
<a name="ln1028">static OsmGpsMapTrack *_view_map_add_track(const dt_view_t *view, GList *points)</a>
<a name="ln1029">{</a>
<a name="ln1030">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln1031"> </a>
<a name="ln1032">  OsmGpsMapTrack* track = osm_gps_map_track_new();</a>
<a name="ln1033"> </a>
<a name="ln1034">  for(GList *iter = g_list_first(points); iter; iter = g_list_next(iter))</a>
<a name="ln1035">  {</a>
<a name="ln1036">    dt_geo_map_display_point_t *p = (dt_geo_map_display_point_t *)iter-&gt;data;</a>
<a name="ln1037">    OsmGpsMapPoint* point = osm_gps_map_point_new_degrees(p-&gt;lat, p-&gt;lon);</a>
<a name="ln1038">    osm_gps_map_track_add_point(track, point);</a>
<a name="ln1039">  }</a>
<a name="ln1040"> </a>
<a name="ln1041">  g_object_set(track, &quot;editable&quot;, FALSE, (gchar *)0);</a>
<a name="ln1042"> </a>
<a name="ln1043">  osm_gps_map_track_add(lib-&gt;map, track);</a>
<a name="ln1044"> </a>
<a name="ln1045">  return track;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">static gboolean _view_map_remove_track(const dt_view_t *view, OsmGpsMapTrack *track)</a>
<a name="ln1049">{</a>
<a name="ln1050">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln1051">  return osm_gps_map_track_remove(lib-&gt;map, track);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">static GObject *_view_map_add_marker(const dt_view_t *view, dt_geo_map_display_t type, GList *points)</a>
<a name="ln1055">{</a>
<a name="ln1056">  switch(type)</a>
<a name="ln1057">  {</a>
<a name="ln1058">    case MAP_DISPLAY_POINT: return G_OBJECT(_view_map_add_pin(view, points));</a>
<a name="ln1059">    case MAP_DISPLAY_TRACK: return G_OBJECT(_view_map_add_track(view, points));</a>
<a name="ln1060">#ifdef HAVE_OSMGPSMAP_110_OR_NEWER</a>
<a name="ln1061">    case MAP_DISPLAY_POLYGON: return G_OBJECT(_view_map_add_polygon(view, points));</a>
<a name="ln1062">#endif</a>
<a name="ln1063">    default: return NULL;</a>
<a name="ln1064">  }</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067">static gboolean _view_map_remove_marker(const dt_view_t *view, dt_geo_map_display_t type, GObject *marker)</a>
<a name="ln1068">{</a>
<a name="ln1069">  if(type == MAP_DISPLAY_NONE) return FALSE;</a>
<a name="ln1070"> </a>
<a name="ln1071">  switch(type)</a>
<a name="ln1072">  {</a>
<a name="ln1073">    case MAP_DISPLAY_POINT: return _view_map_remove_pin(view, OSM_GPS_MAP_IMAGE(marker));</a>
<a name="ln1074">    case MAP_DISPLAY_TRACK: return _view_map_remove_track(view, OSM_GPS_MAP_TRACK(marker));</a>
<a name="ln1075">#ifdef HAVE_OSMGPSMAP_110_OR_NEWER</a>
<a name="ln1076">    case MAP_DISPLAY_POLYGON: return _view_map_remove_polygon(view, OSM_GPS_MAP_POLYGON(marker));</a>
<a name="ln1077">#endif</a>
<a name="ln1078">    default: return FALSE;</a>
<a name="ln1079">  }</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082"> </a>
<a name="ln1083">static void _view_map_check_preference_changed(gpointer instance, gpointer user_data)</a>
<a name="ln1084">{</a>
<a name="ln1085">  dt_view_t *view = (dt_view_t *)user_data;</a>
<a name="ln1086">  dt_map_t *lib = (dt_map_t *)view-&gt;data;</a>
<a name="ln1087"> </a>
<a name="ln1088">  if(_view_map_prefs_changed(lib)) g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">static void _view_map_collection_changed(gpointer instance, gpointer user_data)</a>
<a name="ln1092">{</a>
<a name="ln1093">  dt_view_t *self = (dt_view_t *)user_data;</a>
<a name="ln1094">   dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1095"> </a>
<a name="ln1096">  if(darktable.view_manager-&gt;proxy.map.view)</a>
<a name="ln1097">  {</a>
<a name="ln1098">    GList *collection_images = dt_collection_get_all(darktable.collection, lib-&gt;max_images_drawn);</a>
<a name="ln1099">    if(collection_images)</a>
<a name="ln1100">    {</a>
<a name="ln1101">      _view_map_center_on_image_list(self, collection_images);</a>
<a name="ln1102">      g_list_free(collection_images);</a>
<a name="ln1103">    }</a>
<a name="ln1104">  }</a>
<a name="ln1105"> </a>
<a name="ln1106">  if(dt_conf_get_bool(&quot;plugins/map/filter_images_drawn&quot;))</a>
<a name="ln1107">  {</a>
<a name="ln1108">    /* only redraw when map mode is currently active, otherwise enter() does the magic */</a>
<a name="ln1109">    if(darktable.view_manager-&gt;proxy.map.view) g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln1110">  }</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">static void _view_map_center_on_image(dt_view_t *self, const int32_t imgid)</a>
<a name="ln1114">{</a>
<a name="ln1115">  if(imgid)</a>
<a name="ln1116">  {</a>
<a name="ln1117">    const dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1118">    float longitude = 0;</a>
<a name="ln1119">    float latitude = 0;</a>
<a name="ln1120">    float elevation = 0;</a>
<a name="ln1121">    _get_image_location(imgid, &amp;longitude, &amp;latitude, &amp;elevation);</a>
<a name="ln1122"> </a>
<a name="ln1123">    if(!isnan(longitude) &amp;&amp; !isnan(latitude))</a>
<a name="ln1124">    {</a>
<a name="ln1125">      int zoom;</a>
<a name="ln1126">      g_object_get(G_OBJECT(lib-&gt;map), &quot;zoom&quot;, &amp;zoom, NULL);</a>
<a name="ln1127">      _view_map_center_on_location(self, longitude, latitude, zoom);</a>
<a name="ln1128">    }</a>
<a name="ln1129">  }</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">static gboolean _view_map_center_on_image_list(dt_view_t *self, const GList *selected_images)</a>
<a name="ln1133">{</a>
<a name="ln1134">  // TODO: do something better than this approximation</a>
<a name="ln1135">  const float FIVE_KM = (0.01f * 1.852) * 5.0; // minimum context around single image/place</a>
<a name="ln1136"> </a>
<a name="ln1137">  GList const *l = selected_images;</a>
<a name="ln1138">  float max_longitude = -INFINITY;</a>
<a name="ln1139">  float max_latitude = -INFINITY;</a>
<a name="ln1140">  float min_longitude = INFINITY;</a>
<a name="ln1141">  float min_latitude = INFINITY;</a>
<a name="ln1142">  int count = 0;</a>
<a name="ln1143"> </a>
<a name="ln1144">  while(l)</a>
<a name="ln1145">  {</a>
<a name="ln1146">    const int imgid = GPOINTER_TO_INT(l-&gt;data);</a>
<a name="ln1147">    float lon = 0, lat = 0, el = 0;</a>
<a name="ln1148">    _get_image_location(imgid, &amp;lon, &amp;lat, &amp;el);</a>
<a name="ln1149"> </a>
<a name="ln1150">    if(!isnan(lon) &amp;&amp; !isnan(lat))</a>
<a name="ln1151">    {</a>
<a name="ln1152">      max_longitude = MAX(max_longitude, lon);</a>
<a name="ln1153">      min_longitude = MIN(min_longitude, lon);</a>
<a name="ln1154">      max_latitude = MAX(max_latitude, lat);</a>
<a name="ln1155">      min_latitude = MIN(min_latitude, lat);</a>
<a name="ln1156">      count++;</a>
<a name="ln1157">    }</a>
<a name="ln1158">    l = g_list_next(l);</a>
<a name="ln1159">  }</a>
<a name="ln1160"> </a>
<a name="ln1161">  if(count&gt;0)</a>
<a name="ln1162">  {</a>
<a name="ln1163">    // enlarge the bounding box to avoid having the pictures on the border, and this will give a bit of context.</a>
<a name="ln1164"> </a>
<a name="ln1165">    float d_lon = max_longitude - min_longitude;</a>
<a name="ln1166">    float d_lat = max_latitude - min_latitude;</a>
<a name="ln1167"> </a>
<a name="ln1168">    if(d_lon&gt;1.0)</a>
<a name="ln1169">      d_lon /= 100.0;</a>
<a name="ln1170">    else</a>
<a name="ln1171">      d_lon = (FIVE_KM - d_lon) / 2.0;</a>
<a name="ln1172"> </a>
<a name="ln1173">    if(d_lat&gt;1.0)</a>
<a name="ln1174">      d_lat /= 100.0;</a>
<a name="ln1175">    else</a>
<a name="ln1176">      d_lat = (FIVE_KM - d_lat) / 2.0;</a>
<a name="ln1177"> </a>
<a name="ln1178">    max_longitude = CLAMP(max_longitude + d_lon, -180, 180);</a>
<a name="ln1179">    min_longitude = CLAMP(min_longitude - d_lon, -180, 180);</a>
<a name="ln1180"> </a>
<a name="ln1181">    max_latitude = CLAMP(max_latitude + d_lat, -90, 90);</a>
<a name="ln1182">    min_latitude = CLAMP(min_latitude - d_lat, -90, 90);</a>
<a name="ln1183"> </a>
<a name="ln1184">    _view_map_center_on_bbox(self, min_longitude, min_latitude, max_longitude, max_latitude);</a>
<a name="ln1185">    return TRUE;</a>
<a name="ln1186">  }</a>
<a name="ln1187">  else</a>
<a name="ln1188">    return FALSE;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">static void _view_map_filmstrip_activate_callback(gpointer instance, gpointer user_data)</a>
<a name="ln1192">{</a>
<a name="ln1193">  dt_view_t *self = (dt_view_t *)user_data;</a>
<a name="ln1194">  const int32_t imgid = dt_view_filmstrip_get_activated_imgid(darktable.view_manager);</a>
<a name="ln1195">  _view_map_center_on_image(self, imgid);</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198">static void pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *data)</a>
<a name="ln1199">{</a>
<a name="ln1200">  dt_view_t *self = (dt_view_t *)user_data;</a>
<a name="ln1201">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1202"> </a>
<a name="ln1203">  if(type == DT_UNDO_GEOTAG)</a>
<a name="ln1204">  {</a>
<a name="ln1205">    dt_undo_geotag_t *geotag = (dt_undo_geotag_t *)data;</a>
<a name="ln1206">    _set_image_location(self, geotag-&gt;imgid, geotag-&gt;longitude, geotag-&gt;latitude, geotag-&gt;elevation, TRUE, FALSE);</a>
<a name="ln1207">    g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln1208">  }</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211">static void _push_position(dt_view_t *self, int imgid, float longitude, float latitude, float elevation)</a>
<a name="ln1212">{</a>
<a name="ln1213">  dt_undo_geotag_t *geotag = malloc(sizeof(dt_undo_geotag_t));</a>
<a name="ln1214"> </a>
<a name="ln1215">  geotag-&gt;imgid = imgid;</a>
<a name="ln1216">  geotag-&gt;longitude = longitude;</a>
<a name="ln1217">  geotag-&gt;latitude = latitude;</a>
<a name="ln1218">  geotag-&gt;elevation = elevation;</a>
<a name="ln1219"> </a>
<a name="ln1220">  dt_undo_record(darktable.undo, self, DT_UNDO_GEOTAG, (dt_undo_data_t *)geotag, &amp;pop_undo, free);</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">static void _get_image_location(int imgid, float *longitude, float *latitude, float *elevation)</a>
<a name="ln1224">{</a>
<a name="ln1225">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1226">  *longitude = img-&gt;longitude;</a>
<a name="ln1227">  *latitude = img-&gt;latitude;</a>
<a name="ln1228">  *elevation = img-&gt;elevation;</a>
<a name="ln1229">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">static void _check_imgid(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *item)</a>
<a name="ln1233">{</a>
<a name="ln1234">  dt_undo_geotag_t *geotag = (dt_undo_geotag_t *)item;</a>
<a name="ln1235">  int *state = (int *)user_data;</a>
<a name="ln1236">  if (geotag-&gt;imgid == state[0])</a>
<a name="ln1237">    state[1] = 1;</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">static gboolean _in_undo(int imgid)</a>
<a name="ln1241">{</a>
<a name="ln1242">  int state[2];</a>
<a name="ln1243">  state[0] = imgid;</a>
<a name="ln1244">  state[1] = 0;</a>
<a name="ln1245">  dt_undo_iterate_internal(darktable.undo, DT_UNDO_GEOTAG, &amp;state, _check_imgid);</a>
<a name="ln1246">  return state[1];</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">static void _set_image_location(dt_view_t *self, int imgid, float longitude, float latitude, float elevation,</a>
<a name="ln1250">                                gboolean set_elevation, gboolean record_undo)</a>
<a name="ln1251">{</a>
<a name="ln1252">  dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln1253"> </a>
<a name="ln1254">  img-&gt;longitude = longitude;</a>
<a name="ln1255">  img-&gt;latitude = latitude;</a>
<a name="ln1256">  if(set_elevation) img-&gt;elevation = elevation;</a>
<a name="ln1257"> </a>
<a name="ln1258">  if(record_undo) _push_position(self, imgid, img-&gt;longitude, img-&gt;latitude, img-&gt;elevation);</a>
<a name="ln1259"> </a>
<a name="ln1260">  dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_SAFE);</a>
<a name="ln1261"> </a>
<a name="ln1262">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_MOUSE_OVER_IMAGE_CHANGE);</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">static void _view_map_add_image_to_map(dt_view_t *self, int imgid, gint x, gint y)</a>
<a name="ln1266">{</a>
<a name="ln1267">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1268">  float longitude, latitude;</a>
<a name="ln1269">  OsmGpsMapPoint *pt = osm_gps_map_point_new_degrees(0.0, 0.0);</a>
<a name="ln1270">  osm_gps_map_convert_screen_to_geographic(lib-&gt;map, x, y, pt);</a>
<a name="ln1271">  osm_gps_map_point_get_degrees(pt, &amp;latitude, &amp;longitude);</a>
<a name="ln1272">  osm_gps_map_point_free(pt);</a>
<a name="ln1273"> </a>
<a name="ln1274">  _set_image_location(self, imgid, longitude, latitude, 0.0, FALSE, TRUE);</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">static void _view_map_record_current_location(dt_view_t *self, int imgid)</a>
<a name="ln1278">{</a>
<a name="ln1279">  float longitude, latitude, elevation;</a>
<a name="ln1280">  _get_image_location(imgid, &amp;longitude, &amp;latitude, &amp;elevation);</a>
<a name="ln1281">  if (!_in_undo(imgid))</a>
<a name="ln1282">    _push_position(self, imgid, longitude, latitude, elevation);</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285">static void drag_and_drop_received(GtkWidget *widget, GdkDragContext *context, gint x, gint y,</a>
<a name="ln1286">                                   GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln1287">                                   gpointer data)</a>
<a name="ln1288">{</a>
<a name="ln1289">  dt_view_t *self = (dt_view_t *)data;</a>
<a name="ln1290">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1291"> </a>
<a name="ln1292">  gboolean success = FALSE;</a>
<a name="ln1293"> </a>
<a name="ln1294">  if((selection_data != NULL) &amp;&amp; (gtk_selection_data_get_length(selection_data) &gt;= 0)</a>
<a name="ln1295">     &amp;&amp; target_type == DND_TARGET_IMGID)</a>
<a name="ln1296">  {</a>
<a name="ln1297">    int *imgid = (int *)gtk_selection_data_get_data(selection_data);</a>
<a name="ln1298">    if(*imgid &gt; 0)</a>
<a name="ln1299">    {</a>
<a name="ln1300">      _view_map_record_current_location(self, *imgid);</a>
<a name="ln1301">      _view_map_add_image_to_map(self, *imgid, x, y);</a>
<a name="ln1302">      success = TRUE;</a>
<a name="ln1303">    }</a>
<a name="ln1304">    else if(*imgid == -1) // everything which is selected</a>
<a name="ln1305">    {</a>
<a name="ln1306">      sqlite3_stmt *stmt;</a>
<a name="ln1307"> </a>
<a name="ln1308">      // record initial image position for images not yet in the undo list</a>
<a name="ln1309"> </a>
<a name="ln1310">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT imgid FROM main.selected_images&quot;,</a>
<a name="ln1311">                                  -1, &amp;stmt, NULL);</a>
<a name="ln1312"> </a>
<a name="ln1313">      // create an undo group for current image position</a>
<a name="ln1314"> </a>
<a name="ln1315">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1316">        _view_map_record_current_location(self, sqlite3_column_int(stmt, 0));</a>
<a name="ln1317"> </a>
<a name="ln1318">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT imgid FROM main.selected_images&quot;,</a>
<a name="ln1319">                                  -1, &amp;stmt, NULL);</a>
<a name="ln1320">      while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1321">        _view_map_add_image_to_map(self, sqlite3_column_int(stmt, 0), x, y);</a>
<a name="ln1322">      sqlite3_finalize(stmt);</a>
<a name="ln1323">      success = TRUE;</a>
<a name="ln1324">    }</a>
<a name="ln1325">  }</a>
<a name="ln1326">  gtk_drag_finish(context, success, FALSE, time);</a>
<a name="ln1327">  if(success) g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330">static void _view_map_dnd_get_callback(GtkWidget *widget, GdkDragContext *context,</a>
<a name="ln1331">                                       GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln1332">                                       dt_view_t *self)</a>
<a name="ln1333">{</a>
<a name="ln1334">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1335"> </a>
<a name="ln1336">  g_assert(selection_data != NULL);</a>
<a name="ln1337"> </a>
<a name="ln1338">  int imgid = lib-&gt;selected_image;</a>
<a name="ln1339"> </a>
<a name="ln1340">  switch(target_type)</a>
<a name="ln1341">  {</a>
<a name="ln1342">    case DND_TARGET_IMGID:</a>
<a name="ln1343">      gtk_selection_data_set(selection_data, gtk_selection_data_get_target(selection_data), _DWORD,</a>
<a name="ln1344">                             (guchar *)&amp;imgid, sizeof(imgid));</a>
<a name="ln1345">      break;</a>
<a name="ln1346">    default: // return the location of the file as a last resort</a>
<a name="ln1347">    case DND_TARGET_URI:</a>
<a name="ln1348">    {</a>
<a name="ln1349">      gchar pathname[PATH_MAX] = { 0 };</a>
<a name="ln1350">      gboolean from_cache = TRUE;</a>
<a name="ln1351">      dt_image_full_path(imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln1352">      gchar *uri = g_strdup_printf(&quot;file://%s&quot;, pathname); // TODO: should we add the host?</a>
<a name="ln1353">      gtk_selection_data_set(selection_data, gtk_selection_data_get_target(selection_data), _BYTE,</a>
<a name="ln1354">                             (guchar *)uri, strlen(uri));</a>
<a name="ln1355">      g_free(uri);</a>
<a name="ln1356">      break;</a>
<a name="ln1357">    }</a>
<a name="ln1358">  }</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">static void _view_map_dnd_remove_callback(GtkWidget *widget, GdkDragContext *context, gint x, gint y,</a>
<a name="ln1362">                                          GtkSelectionData *selection_data, guint target_type, guint time,</a>
<a name="ln1363">                                          gpointer data)</a>
<a name="ln1364">{</a>
<a name="ln1365">  dt_view_t *self = (dt_view_t *)data;</a>
<a name="ln1366">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1367"> </a>
<a name="ln1368">  gboolean success = FALSE;</a>
<a name="ln1369"> </a>
<a name="ln1370">  if((selection_data != NULL) &amp;&amp; (gtk_selection_data_get_length(selection_data) &gt;= 0)</a>
<a name="ln1371">     &amp;&amp; target_type == DND_TARGET_IMGID)</a>
<a name="ln1372">  {</a>
<a name="ln1373">    int *imgid = (int *)gtk_selection_data_get_data(selection_data);</a>
<a name="ln1374">    if(*imgid &gt; 0)</a>
<a name="ln1375">    {</a>
<a name="ln1376">      //  the image was dropped into the filmstrip, let's remove it in this case</a>
<a name="ln1377">      _set_image_location(self, *imgid, NAN, NAN, NAN, TRUE, TRUE);</a>
<a name="ln1378">      success = TRUE;</a>
<a name="ln1379">    }</a>
<a name="ln1380">  }</a>
<a name="ln1381">  gtk_drag_finish(context, success, FALSE, time);</a>
<a name="ln1382">  if(success) g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln1383">}</a>
<a name="ln1384"> </a>
<a name="ln1385">static gboolean _view_map_dnd_failed_callback(GtkWidget *widget, GdkDragContext *drag_context,</a>
<a name="ln1386">                                              GtkDragResult result, dt_view_t *self)</a>
<a name="ln1387">{</a>
<a name="ln1388">  dt_map_t *lib = (dt_map_t *)self-&gt;data;</a>
<a name="ln1389"> </a>
<a name="ln1390">  g_signal_emit_by_name(lib-&gt;map, &quot;changed&quot;);</a>
<a name="ln1391"> </a>
<a name="ln1392">  return TRUE;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">static gboolean _view_map_prefs_changed(dt_map_t *lib)</a>
<a name="ln1396">{</a>
<a name="ln1397">  gboolean prefs_changed = FALSE;</a>
<a name="ln1398">  int max_images_drawn = dt_conf_get_int(&quot;plugins/map/max_images_drawn&quot;);</a>
<a name="ln1399">  gboolean filter_images_drawn = dt_conf_get_bool(&quot;plugins/map/filter_images_drawn&quot;);</a>
<a name="ln1400"> </a>
<a name="ln1401">  if(lib-&gt;max_images_drawn != max_images_drawn) prefs_changed = TRUE;</a>
<a name="ln1402">  if(lib-&gt;filter_images_drawn != filter_images_drawn) prefs_changed = TRUE;</a>
<a name="ln1403"> </a>
<a name="ln1404">  return prefs_changed;</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">static void _view_map_build_main_query(dt_map_t *lib)</a>
<a name="ln1408">{</a>
<a name="ln1409">  char *geo_query;</a>
<a name="ln1410"> </a>
<a name="ln1411">  if(lib-&gt;statements.main_query) sqlite3_finalize(lib-&gt;statements.main_query);</a>
<a name="ln1412"> </a>
<a name="ln1413">  lib-&gt;max_images_drawn = dt_conf_get_int(&quot;plugins/map/max_images_drawn&quot;);</a>
<a name="ln1414">  if(lib-&gt;max_images_drawn == 0) lib-&gt;max_images_drawn = 100;</a>
<a name="ln1415">  lib-&gt;filter_images_drawn = dt_conf_get_bool(&quot;plugins/map/filter_images_drawn&quot;);</a>
<a name="ln1416">  geo_query = g_strdup_printf(&quot;SELECT * FROM (SELECT id, latitude FROM %s WHERE longitude &gt;= ?1 AND &quot;</a>
<a name="ln1417">                              &quot;longitude &lt;= ?2 AND latitude &lt;= ?3 AND latitude &gt;= ?4 AND longitude NOT NULL AND &quot;</a>
<a name="ln1418">                              &quot;latitude NOT NULL ORDER BY ABS(latitude - ?5), ABS(longitude - ?6) LIMIT 0, %d) &quot;</a>
<a name="ln1419">                              &quot;ORDER BY (180 - latitude), id&quot;,</a>
<a name="ln1420">                              lib-&gt;filter_images_drawn</a>
<a name="ln1421">                              ? &quot;main.images i INNER JOIN memory.collected_images c ON i.id = c.imgid&quot;</a>
<a name="ln1422">                              : &quot;main.images&quot;,</a>
<a name="ln1423">                              lib-&gt;max_images_drawn);</a>
<a name="ln1424"> </a>
<a name="ln1425">  /* prepare the main query statement */</a>
<a name="ln1426">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), geo_query, -1, &amp;lib-&gt;statements.main_query, NULL);</a>
<a name="ln1427"> </a>
<a name="ln1428">  g_free(geo_query);</a>
<a name="ln1429">}</a>
<a name="ln1430"> </a>
<a name="ln1431">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1432">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1433">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="323"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 323, 322.</p></div>
<div class="balloon" rel="371"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 371, 370.</p></div>
<div class="balloon" rel="386"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lib'. Check lines: 386, 380.</p></div>
<div class="balloon" rel="1215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'geotag'. Check lines: 1215, 1213.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
