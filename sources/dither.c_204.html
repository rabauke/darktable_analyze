
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012--2013 Ulrich Pegelow</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/imageio.h&quot;</a>
<a name="ln23">#include &quot;common/opencl.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28">#include &quot;develop/tiling.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/gradientslider.h&quot;</a>
<a name="ln30">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln31">#include &quot;gui/gtk.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34">#include &lt;assert.h&gt;</a>
<a name="ln35">#include &lt;math.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln40">#include &lt;inttypes.h&gt;</a>
<a name="ln41">#if defined(__SSE__)</a>
<a name="ln42">#include &lt;xmmintrin.h&gt;</a>
<a name="ln43">#endif</a>
<a name="ln44"> </a>
<a name="ln45">#define CLIP(x) ((x &lt; 0) ? 0.0 : (x &gt; 1.0) ? 1.0 : x)</a>
<a name="ln46">#define TEA_ROUNDS 8</a>
<a name="ln47"> </a>
<a name="ln48">DT_MODULE_INTROSPECTION(1, dt_iop_dither_params_t)</a>
<a name="ln49"> </a>
<a name="ln50">typedef void(_find_nearest_color)(float *val, float *err, const float f, const float rf);</a>
<a name="ln51"> </a>
<a name="ln52">#if defined(__SSE__)</a>
<a name="ln53">typedef __m128(_find_nearest_color_sse)(float *val, const float f, const float rf);</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">typedef enum dt_iop_dither_type_t</a>
<a name="ln57">{</a>
<a name="ln58">  DITHER_RANDOM,</a>
<a name="ln59">  DITHER_FS1BIT,</a>
<a name="ln60">  DITHER_FS4BIT_GRAY,</a>
<a name="ln61">  DITHER_FS8BIT,</a>
<a name="ln62">  DITHER_FS16BIT,</a>
<a name="ln63">  DITHER_FSAUTO</a>
<a name="ln64">} dt_iop_dither_type_t;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">typedef struct dt_iop_dither_params_t</a>
<a name="ln68">{</a>
<a name="ln69">  dt_iop_dither_type_t dither_type;</a>
<a name="ln70">  int palette; // reserved for future extensions</a>
<a name="ln71">  struct</a>
<a name="ln72">  {</a>
<a name="ln73">    float radius;   // reserved for future extensions</a>
<a name="ln74">    float range[4]; // reserved for future extensions</a>
<a name="ln75">    float damping;</a>
<a name="ln76">  } random;</a>
<a name="ln77">} dt_iop_dither_params_t;</a>
<a name="ln78"> </a>
<a name="ln79">typedef struct dt_iop_dither_gui_data_t</a>
<a name="ln80">{</a>
<a name="ln81">  GtkWidget *dither_type;</a>
<a name="ln82">  GtkWidget *random;</a>
<a name="ln83">  GtkWidget *radius;</a>
<a name="ln84">  GtkWidget *range;</a>
<a name="ln85">  GtkWidget *range_label;</a>
<a name="ln86">  GtkWidget *damping;</a>
<a name="ln87">} dt_iop_dither_gui_data_t;</a>
<a name="ln88"> </a>
<a name="ln89">typedef struct dt_iop_dither_data_t</a>
<a name="ln90">{</a>
<a name="ln91">  dt_iop_dither_type_t dither_type;</a>
<a name="ln92">  struct</a>
<a name="ln93">  {</a>
<a name="ln94">    float radius;</a>
<a name="ln95">    float range[4];</a>
<a name="ln96">    float damping;</a>
<a name="ln97">  } random;</a>
<a name="ln98">} dt_iop_dither_data_t;</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">const char *name()</a>
<a name="ln102">{</a>
<a name="ln103">  return _(&quot;dithering&quot;);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">int default_group()</a>
<a name="ln107">{</a>
<a name="ln108">  return IOP_GROUP_CORRECT;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">int flags()</a>
<a name="ln112">{</a>
<a name="ln113">  return IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln118">{</a>
<a name="ln119">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln120"> </a>
<a name="ln121">  dt_iop_dither_params_t tmp</a>
<a name="ln122">      = (dt_iop_dither_params_t){ DITHER_FSAUTO, 0, { 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }, -200.0f } };</a>
<a name="ln123">  // add the preset.</a>
<a name="ln124">  dt_gui_presets_add_generic(_(&quot;dither&quot;), self-&gt;op, self-&gt;version(), &amp;tmp, sizeof(dt_iop_dither_params_t), 1);</a>
<a name="ln125">  // make it auto-apply for all images:</a>
<a name="ln126">  // dt_gui_presets_update_autoapply(_(&quot;dither&quot;), self-&gt;op, self-&gt;version(), 1);</a>
<a name="ln127"> </a>
<a name="ln128">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131"> </a>
<a name="ln132">// dither pixel into gray, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln133">static void _find_nearest_color_n_levels_gray(float *val, float *err, const float f, const float rf)</a>
<a name="ln134">{</a>
<a name="ln135">  const float in = 0.30f * val[0] + 0.59f * val[1] + 0.11f * val[2]; // RGB -&gt; GRAY</a>
<a name="ln136"> </a>
<a name="ln137">  float tmp = in * f;</a>
<a name="ln138">  int itmp = floorf(tmp);</a>
<a name="ln139"> </a>
<a name="ln140">  float new = (tmp - itmp &gt; 0.5f ? (float)(itmp + 1) : (float)itmp) * rf;</a>
<a name="ln141"> </a>
<a name="ln142">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln143">  {</a>
<a name="ln144">    err[c] = val[c] - new;</a>
<a name="ln145">    val[c] = new;</a>
<a name="ln146">  }</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">#if defined(__SSE2__)</a>
<a name="ln150">// dither pixel into gray, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln151">static __m128 _find_nearest_color_n_levels_gray_sse(float *val, const float f, const float rf)</a>
<a name="ln152">{</a>
<a name="ln153">  __m128 err;</a>
<a name="ln154">  __m128 new;</a>
<a name="ln155"> </a>
<a name="ln156">  const float in = 0.30f * val[0] + 0.59f * val[1] + 0.11f * val[2]; // RGB -&gt; GRAY</a>
<a name="ln157"> </a>
<a name="ln158">  float tmp = in * f;</a>
<a name="ln159">  int itmp = floorf(tmp);</a>
<a name="ln160"> </a>
<a name="ln161">  new = _mm_set1_ps(tmp - itmp &gt; 0.5f ? (float)(itmp + 1) * rf : (float)itmp * rf);</a>
<a name="ln162">  err = _mm_sub_ps(_mm_load_ps(val), new);</a>
<a name="ln163">  _mm_store_ps(val, new);</a>
<a name="ln164"> </a>
<a name="ln165">  return err;</a>
<a name="ln166">}</a>
<a name="ln167">#endif</a>
<a name="ln168"> </a>
<a name="ln169">// dither pixel into RGB, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln170">static void _find_nearest_color_n_levels_rgb(float *val, float *err, const float f, const float rf)</a>
<a name="ln171">{</a>
<a name="ln172">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln173">  {</a>
<a name="ln174">    float old = val[c];</a>
<a name="ln175">    float tmp = old * f;</a>
<a name="ln176">    float itmp = floorf(tmp);</a>
<a name="ln177">    float new = (tmp - itmp &gt; 0.5f ? itmp + 1 : itmp) * rf;</a>
<a name="ln178"> </a>
<a name="ln179">    val[c] = new;</a>
<a name="ln180">    err[c] = old - new;</a>
<a name="ln181">  }</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">#if defined(__SSE2__)</a>
<a name="ln185">// dither pixel into RGB, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln186">static __m128 _find_nearest_color_n_levels_rgb_sse2(float *val, const float f, const float rf)</a>
<a name="ln187">{</a>
<a name="ln188">  __m128 old = _mm_load_ps(val);</a>
<a name="ln189">  __m128 tmp = _mm_mul_ps(old, _mm_set1_ps(f));        // old * f</a>
<a name="ln190">  __m128 itmp = _mm_cvtepi32_ps(_mm_cvtps_epi32(tmp)); // floor(tmp)</a>
<a name="ln191">  __m128 new = _mm_mul_ps(</a>
<a name="ln192">      _mm_add_ps(itmp,</a>
<a name="ln193">                 _mm_and_ps(_mm_cmpgt_ps(_mm_sub_ps(tmp, itmp), // (tmp - itmp &gt; 0.5f ? itmp + 1 : itmp) * rf</a>
<a name="ln194">                                         _mm_set1_ps(0.5f)),</a>
<a name="ln195">                            _mm_set1_ps(1.0f))),</a>
<a name="ln196">      _mm_set1_ps(rf));</a>
<a name="ln197"> </a>
<a name="ln198">  _mm_store_ps(val, new);</a>
<a name="ln199"> </a>
<a name="ln200">  return _mm_sub_ps(old, new);</a>
<a name="ln201">}</a>
<a name="ln202">#endif</a>
<a name="ln203"> </a>
<a name="ln204">static inline void _diffuse_error(float *val, const float *err, const float factor)</a>
<a name="ln205">{</a>
<a name="ln206">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln207">  {</a>
<a name="ln208">    val[c] += err[c] * factor;</a>
<a name="ln209">  }</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">#if defined(__SSE__)</a>
<a name="ln213">static inline void _diffuse_error_sse(float *val, const __m128 err, const float factor)</a>
<a name="ln214">{</a>
<a name="ln215">  _mm_store_ps(val,</a>
<a name="ln216">               _mm_add_ps(_mm_load_ps(val), _mm_mul_ps(err, _mm_set1_ps(factor)))); // *val += err * factor</a>
<a name="ln217">}</a>
<a name="ln218">#endif</a>
<a name="ln219"> </a>
<a name="ln220">static inline float clipnan(const float x)</a>
<a name="ln221">{</a>
<a name="ln222">  float r;</a>
<a name="ln223"> </a>
<a name="ln224">  if(isnan(x))</a>
<a name="ln225">    r = 0.5f;</a>
<a name="ln226">  else // normal number</a>
<a name="ln227">    r = (isless(x, 0.0f) ? 0.0f : (isgreater(x, 1.0f) ? 1.0f : x));</a>
<a name="ln228"> </a>
<a name="ln229">  return r;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static void process_floyd_steinberg(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln233">                                    const void *const ivoid, void *const ovoid,</a>
<a name="ln234">                                    const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln235">{</a>
<a name="ln236">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln237"> </a>
<a name="ln238">  const int width = roi_in-&gt;width;</a>
<a name="ln239">  const int height = roi_in-&gt;height;</a>
<a name="ln240">  const int ch = piece-&gt;colors;</a>
<a name="ln241">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln242">  const int l1 = floorf(1.0f + dt_log2f(1.0f / scale));</a>
<a name="ln243"> </a>
<a name="ln244">  _find_nearest_color *nearest_color = NULL;</a>
<a name="ln245">  unsigned int levels = 1;</a>
<a name="ln246">  int bds = (piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT) ? l1 * l1 : 1;</a>
<a name="ln247"> </a>
<a name="ln248">  switch(data-&gt;dither_type)</a>
<a name="ln249">  {</a>
<a name="ln250">    case DITHER_FS1BIT:</a>
<a name="ln251">      nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln252">      levels = MAX(2, MIN(bds + 1, 256));</a>
<a name="ln253">      break;</a>
<a name="ln254">    case DITHER_FS4BIT_GRAY:</a>
<a name="ln255">      nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln256">      levels = MAX(16, MIN(15 * bds + 1, 256));</a>
<a name="ln257">      break;</a>
<a name="ln258">    case DITHER_FS8BIT:</a>
<a name="ln259">      nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln260">      levels = 256;</a>
<a name="ln261">      break;</a>
<a name="ln262">    case DITHER_FS16BIT:</a>
<a name="ln263">      nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln264">      levels = 65536;</a>
<a name="ln265">      break;</a>
<a name="ln266">    case DITHER_FSAUTO:</a>
<a name="ln267">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_CHANNEL_MASK)</a>
<a name="ln268">      {</a>
<a name="ln269">        case IMAGEIO_RGB:</a>
<a name="ln270">          nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln271">          break;</a>
<a name="ln272">        case IMAGEIO_GRAY:</a>
<a name="ln273">          nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln274">          break;</a>
<a name="ln275">      }</a>
<a name="ln276"> </a>
<a name="ln277">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_PREC_MASK)</a>
<a name="ln278">      {</a>
<a name="ln279">        case IMAGEIO_INT8:</a>
<a name="ln280">          levels = 256;</a>
<a name="ln281">          break;</a>
<a name="ln282">        case IMAGEIO_INT12:</a>
<a name="ln283">          levels = 4096;</a>
<a name="ln284">          break;</a>
<a name="ln285">        case IMAGEIO_INT16:</a>
<a name="ln286">          levels = 65536;</a>
<a name="ln287">          break;</a>
<a name="ln288">        case IMAGEIO_BW:</a>
<a name="ln289">          levels = 2;</a>
<a name="ln290">          break;</a>
<a name="ln291">        case IMAGEIO_INT32:</a>
<a name="ln292">        case IMAGEIO_FLOAT:</a>
<a name="ln293">        default:</a>
<a name="ln294">          nearest_color = NULL;</a>
<a name="ln295">          break;</a>
<a name="ln296">      }</a>
<a name="ln297">      // no automatic dithering for preview and thumbnail</a>
<a name="ln298">      if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln299">        nearest_color = NULL;</a>
<a name="ln300">      break;</a>
<a name="ln301">    case DITHER_RANDOM:</a>
<a name="ln302">      // this function won't ever be called for that type</a>
<a name="ln303">      // instead, process_random() will be called</a>
<a name="ln304">      __builtin_unreachable();</a>
<a name="ln305">      break;</a>
<a name="ln306">  }</a>
<a name="ln307"> </a>
<a name="ln308">#ifdef _OPENMP</a>
<a name="ln309">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln310">#endif</a>
<a name="ln311">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln312">  {</a>
<a name="ln313">    const float *in = (const float *)ivoid + (size_t)ch * width * j;</a>
<a name="ln314">    float *out = (float *)ovoid + (size_t)ch * width * j;</a>
<a name="ln315">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln316">    {</a>
<a name="ln317">      out[0] = clipnan(in[0]);</a>
<a name="ln318">      out[1] = clipnan(in[1]);</a>
<a name="ln319">      out[2] = clipnan(in[2]);</a>
<a name="ln320">    }</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  if(nearest_color == NULL) return;</a>
<a name="ln324"> </a>
<a name="ln325">  const float f = levels - 1;</a>
<a name="ln326">  const float rf = 1.0 / f;</a>
<a name="ln327">  float err[4];</a>
<a name="ln328"> </a>
<a name="ln329">  // dither without error diffusion on very tiny images</a>
<a name="ln330">  if(width &lt; 3 || height &lt; 3)</a>
<a name="ln331">  {</a>
<a name="ln332">    for(int j = 0; j &lt; height; j++)</a>
<a name="ln333">    {</a>
<a name="ln334">      float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln335">      for(int i = 0; i &lt; width; i++) nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln339">    return;</a>
<a name="ln340">  }</a>
<a name="ln341"> </a>
<a name="ln342">  // floyd-steinberg dithering follows here</a>
<a name="ln343"> </a>
<a name="ln344">  // first height-1 rows</a>
<a name="ln345">  for(int j = 0; j &lt; height - 1; j++)</a>
<a name="ln346">  {</a>
<a name="ln347">    float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln348"> </a>
<a name="ln349">    // first column</a>
<a name="ln350">    nearest_color(out, err, f, rf);</a>
<a name="ln351">    _diffuse_error(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln352">    _diffuse_error(out + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln353">    _diffuse_error(out + ch * (width + 1), err, 1.0f / 16.0f);</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">    // main part of image</a>
<a name="ln357">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln358">    {</a>
<a name="ln359">      nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln360">      _diffuse_error(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln361">      _diffuse_error(out + ch * (i - 1) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln362">      _diffuse_error(out + ch * i + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln363">      _diffuse_error(out + ch * (i + 1) + ch * width, err, 1.0f / 16.0f);</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    // last column</a>
<a name="ln367">    nearest_color(out + ch * (width - 1), err, f, rf);</a>
<a name="ln368">    _diffuse_error(out + ch * (width - 2) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln369">    _diffuse_error(out + ch * (width - 1) + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln370">  }</a>
<a name="ln371"> </a>
<a name="ln372">  // last row</a>
<a name="ln373">  {</a>
<a name="ln374">    float *out = ((float *)ovoid) + (size_t)ch * (height - 1) * width;</a>
<a name="ln375"> </a>
<a name="ln376">    // lower left pixel</a>
<a name="ln377">    nearest_color(out, err, f, rf);</a>
<a name="ln378">    _diffuse_error(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln379"> </a>
<a name="ln380">    // main part of last row</a>
<a name="ln381">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln382">    {</a>
<a name="ln383">      nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln384">      _diffuse_error(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    // lower right pixel</a>
<a name="ln388">    nearest_color(out + ch * (width - 1), err, f, rf);</a>
<a name="ln389"> </a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  // copy alpha channel if needed</a>
<a name="ln393">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">#if defined(__SSE2__)</a>
<a name="ln397">static void process_floyd_steinberg_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln398">                                         const void *const ivoid, void *const ovoid,</a>
<a name="ln399">                                         const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln400">{</a>
<a name="ln401">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln402"> </a>
<a name="ln403">  const int width = roi_in-&gt;width;</a>
<a name="ln404">  const int height = roi_in-&gt;height;</a>
<a name="ln405">  const int ch = piece-&gt;colors;</a>
<a name="ln406">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln407">  const int l1 = floorf(1.0f + dt_log2f(1.0f / scale));</a>
<a name="ln408"> </a>
<a name="ln409">  _find_nearest_color_sse *nearest_color = NULL;</a>
<a name="ln410">  unsigned int levels = 1;</a>
<a name="ln411">  int bds = (piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT) ? l1 * l1 : 1;</a>
<a name="ln412"> </a>
<a name="ln413">  switch(data-&gt;dither_type)</a>
<a name="ln414">  {</a>
<a name="ln415">    case DITHER_FS1BIT:</a>
<a name="ln416">      nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln417">      levels = MAX(2, MIN(bds + 1, 256));</a>
<a name="ln418">      break;</a>
<a name="ln419">    case DITHER_FS4BIT_GRAY:</a>
<a name="ln420">      nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln421">      levels = MAX(16, MIN(15 * bds + 1, 256));</a>
<a name="ln422">      break;</a>
<a name="ln423">    case DITHER_FS8BIT:</a>
<a name="ln424">      nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln425">      levels = 256;</a>
<a name="ln426">      break;</a>
<a name="ln427">    case DITHER_FS16BIT:</a>
<a name="ln428">      nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln429">      levels = 65536;</a>
<a name="ln430">      break;</a>
<a name="ln431">    case DITHER_FSAUTO:</a>
<a name="ln432">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_CHANNEL_MASK)</a>
<a name="ln433">      {</a>
<a name="ln434">        case IMAGEIO_RGB:</a>
<a name="ln435">          nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln436">          break;</a>
<a name="ln437">        case IMAGEIO_GRAY:</a>
<a name="ln438">          nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln439">          break;</a>
<a name="ln440">      }</a>
<a name="ln441"> </a>
<a name="ln442">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_PREC_MASK)</a>
<a name="ln443">      {</a>
<a name="ln444">        case IMAGEIO_INT8:</a>
<a name="ln445">          levels = 256;</a>
<a name="ln446">          break;</a>
<a name="ln447">        case IMAGEIO_INT12:</a>
<a name="ln448">          levels = 4096;</a>
<a name="ln449">          break;</a>
<a name="ln450">        case IMAGEIO_INT16:</a>
<a name="ln451">          levels = 65536;</a>
<a name="ln452">          break;</a>
<a name="ln453">        case IMAGEIO_BW:</a>
<a name="ln454">          levels = 2;</a>
<a name="ln455">          break;</a>
<a name="ln456">        case IMAGEIO_INT32:</a>
<a name="ln457">        case IMAGEIO_FLOAT:</a>
<a name="ln458">        default:</a>
<a name="ln459">          nearest_color = NULL;</a>
<a name="ln460">          break;</a>
<a name="ln461">      }</a>
<a name="ln462">      // no automatic dithering for preview and thumbnail</a>
<a name="ln463">      if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln464">        nearest_color = NULL;</a>
<a name="ln465">      break;</a>
<a name="ln466">    case DITHER_RANDOM:</a>
<a name="ln467">      // this function won't ever be called for that type</a>
<a name="ln468">      // instead, process_random() will be called</a>
<a name="ln469">      __builtin_unreachable();</a>
<a name="ln470">      break;</a>
<a name="ln471">  }</a>
<a name="ln472"> </a>
<a name="ln473">#ifdef _OPENMP</a>
<a name="ln474">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln475">#endif</a>
<a name="ln476">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln477">  {</a>
<a name="ln478">    const float *in = (const float *)ivoid + (size_t)ch * width * j;</a>
<a name="ln479">    float *out = (float *)ovoid + (size_t)ch * width * j;</a>
<a name="ln480">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln481">    {</a>
<a name="ln482">      out[0] = clipnan(in[0]);</a>
<a name="ln483">      out[1] = clipnan(in[1]);</a>
<a name="ln484">      out[2] = clipnan(in[2]);</a>
<a name="ln485">    }</a>
<a name="ln486">  }</a>
<a name="ln487"> </a>
<a name="ln488">  if(nearest_color == NULL) return;</a>
<a name="ln489"> </a>
<a name="ln490">  const float f = levels - 1;</a>
<a name="ln491">  const float rf = 1.0 / f;</a>
<a name="ln492">  __m128 err;</a>
<a name="ln493"> </a>
<a name="ln494">  // dither without error diffusion on very tiny images</a>
<a name="ln495">  if(width &lt; 3 || height &lt; 3)</a>
<a name="ln496">  {</a>
<a name="ln497">    for(int j = 0; j &lt; height; j++)</a>
<a name="ln498">    {</a>
<a name="ln499">      float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln500">      for(int i = 0; i &lt; width; i++) (void)nearest_color(out + ch * i, f, rf);</a>
<a name="ln501">    }</a>
<a name="ln502"> </a>
<a name="ln503">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln504">    return;</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  // floyd-steinberg dithering follows here</a>
<a name="ln508"> </a>
<a name="ln509">  // first height-1 rows</a>
<a name="ln510">  for(int j = 0; j &lt; height - 1; j++)</a>
<a name="ln511">  {</a>
<a name="ln512">    float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln513"> </a>
<a name="ln514">    // first column</a>
<a name="ln515">    err = nearest_color(out, f, rf);</a>
<a name="ln516">    _diffuse_error_sse(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln517">    _diffuse_error_sse(out + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln518">    _diffuse_error_sse(out + ch * (width + 1), err, 1.0f / 16.0f);</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">    // main part of image</a>
<a name="ln522">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln523">    {</a>
<a name="ln524">      err = nearest_color(out + ch * i, f, rf);</a>
<a name="ln525">      _diffuse_error_sse(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln526">      _diffuse_error_sse(out + ch * (i - 1) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln527">      _diffuse_error_sse(out + ch * i + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln528">      _diffuse_error_sse(out + ch * (i + 1) + ch * width, err, 1.0f / 16.0f);</a>
<a name="ln529">    }</a>
<a name="ln530"> </a>
<a name="ln531">    // last column</a>
<a name="ln532">    err = nearest_color(out + ch * (width - 1), f, rf);</a>
<a name="ln533">    _diffuse_error_sse(out + ch * (width - 2) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln534">    _diffuse_error_sse(out + ch * (width - 1) + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  // last row</a>
<a name="ln538">  {</a>
<a name="ln539">    float *out = ((float *)ovoid) + (size_t)ch * (height - 1) * width;</a>
<a name="ln540"> </a>
<a name="ln541">    // lower left pixel</a>
<a name="ln542">    err = nearest_color(out, f, rf);</a>
<a name="ln543">    _diffuse_error_sse(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln544"> </a>
<a name="ln545">    // main part of last row</a>
<a name="ln546">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln547">    {</a>
<a name="ln548">      err = nearest_color(out + ch * i, f, rf);</a>
<a name="ln549">      _diffuse_error_sse(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">    // lower right pixel</a>
<a name="ln553">    (void)nearest_color(out + ch * (width - 1), f, rf);</a>
<a name="ln554"> </a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  // copy alpha channel if needed</a>
<a name="ln558">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln559">}</a>
<a name="ln560">#endif</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">static void encrypt_tea(unsigned int *arg)</a>
<a name="ln564">{</a>
<a name="ln565">  const unsigned int key[] = { 0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e };</a>
<a name="ln566">  unsigned int v0 = arg[0], v1 = arg[1];</a>
<a name="ln567">  unsigned int sum = 0;</a>
<a name="ln568">  unsigned int delta = 0x9e3779b9;</a>
<a name="ln569">  for(int i = 0; i &lt; TEA_ROUNDS; i++)</a>
<a name="ln570">  {</a>
<a name="ln571">    sum += delta;</a>
<a name="ln572">    v0 += ((v1 &lt;&lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[1]);</a>
<a name="ln573">    v1 += ((v0 &lt;&lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + key[3]);</a>
<a name="ln574">  }</a>
<a name="ln575">  arg[0] = v0;</a>
<a name="ln576">  arg[1] = v1;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579"> </a>
<a name="ln580">static float tpdf(unsigned int urandom)</a>
<a name="ln581">{</a>
<a name="ln582">  float frandom = (float)urandom / 0xFFFFFFFFu;</a>
<a name="ln583"> </a>
<a name="ln584">  return (frandom &lt; 0.5f ? (sqrtf(2.0f * frandom) - 1.0f) : (1.0f - sqrtf(2.0f * (1.0f - frandom))));</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">static void process_random(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln589">                           const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln590">                           const dt_iop_roi_t *const roi_out)</a>
<a name="ln591">{</a>
<a name="ln592">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln593"> </a>
<a name="ln594">  const int width = roi_in-&gt;width;</a>
<a name="ln595">  const int height = roi_in-&gt;height;</a>
<a name="ln596">  const int ch = piece-&gt;colors;</a>
<a name="ln597"> </a>
<a name="ln598">  const float dither = powf(2.0f, data-&gt;random.damping / 10.0f);</a>
<a name="ln599"> </a>
<a name="ln600">  unsigned int *const tea_states = calloc(2 * dt_get_num_threads(), sizeof(unsigned int));</a>
<a name="ln601"> </a>
<a name="ln602">#ifdef _OPENMP</a>
<a name="ln603">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln604">#endif</a>
<a name="ln605">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln606">  {</a>
<a name="ln607">    const size_t k = (size_t)ch * width * j;</a>
<a name="ln608">    const float *in = (const float *)ivoid + k;</a>
<a name="ln609">    float *out = (float *)ovoid + k;</a>
<a name="ln610">    unsigned int *tea_state = tea_states + 2 * dt_get_thread_num();</a>
<a name="ln611">    tea_state[0] = j * height + dt_get_thread_num();</a>
<a name="ln612">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln613">    {</a>
<a name="ln614">      encrypt_tea(tea_state);</a>
<a name="ln615">      float dith = dither * tpdf(tea_state[0]);</a>
<a name="ln616"> </a>
<a name="ln617">      out[0] = CLIP(in[0] + dith);</a>
<a name="ln618">      out[1] = CLIP(in[1] + dith);</a>
<a name="ln619">      out[2] = CLIP(in[2] + dith);</a>
<a name="ln620">    }</a>
<a name="ln621">  }</a>
<a name="ln622"> </a>
<a name="ln623">  free(tea_states);</a>
<a name="ln624"> </a>
<a name="ln625">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628"> </a>
<a name="ln629">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln630">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln631">{</a>
<a name="ln632">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln633"> </a>
<a name="ln634">  if(data-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln635">    process_random(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln636">  else</a>
<a name="ln637">    process_floyd_steinberg(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">#if defined(__SSE2__)</a>
<a name="ln641">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln642">                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln643">{</a>
<a name="ln644">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln645"> </a>
<a name="ln646">  if(data-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln647">    process_random(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln648">  else</a>
<a name="ln649">    process_floyd_steinberg_sse2(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln650">}</a>
<a name="ln651">#endif</a>
<a name="ln652"> </a>
<a name="ln653">static void method_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln654">{</a>
<a name="ln655">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln656">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln657">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln658">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln659">  p-&gt;dither_type = dt_bauhaus_combobox_get(widget);</a>
<a name="ln660"> </a>
<a name="ln661">  if(p-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln662">    gtk_widget_show(GTK_WIDGET(g-&gt;random));</a>
<a name="ln663">  else</a>
<a name="ln664">    gtk_widget_hide(GTK_WIDGET(g-&gt;random));</a>
<a name="ln665"> </a>
<a name="ln666">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">#if 0</a>
<a name="ln670">static void</a>
<a name="ln671">radius_callback (GtkWidget *slider, gpointer user_data)</a>
<a name="ln672">{</a>
<a name="ln673">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln674">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln675">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln676">  p-&gt;random.radius = dt_bauhaus_slider_get(slider);</a>
<a name="ln677">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln678">}</a>
<a name="ln679">#endif</a>
<a name="ln680"> </a>
<a name="ln681">static void damping_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln682">{</a>
<a name="ln683">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln684">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln685">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln686">  p-&gt;random.damping = dt_bauhaus_slider_get(slider);</a>
<a name="ln687">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">#if 0</a>
<a name="ln691">static void</a>
<a name="ln692">range_callback (GtkWidget *slider, gpointer user_data)</a>
<a name="ln693">{</a>
<a name="ln694">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln695">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln696">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln697">  p-&gt;random.range[0] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 0);</a>
<a name="ln698">  p-&gt;random.range[1] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 1);</a>
<a name="ln699">  p-&gt;random.range[2] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 2);</a>
<a name="ln700">  p-&gt;random.range[3] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 3);</a>
<a name="ln701">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln702">}</a>
<a name="ln703">#endif</a>
<a name="ln704"> </a>
<a name="ln705">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln706">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln707">{</a>
<a name="ln708">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)p1;</a>
<a name="ln709">  dt_iop_dither_data_t *d = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln710"> </a>
<a name="ln711">  d-&gt;dither_type = p-&gt;dither_type;</a>
<a name="ln712">  memcpy(&amp;(d-&gt;random.range), &amp;(p-&gt;random.range), sizeof(p-&gt;random.range));</a>
<a name="ln713">  d-&gt;random.radius = p-&gt;random.radius;</a>
<a name="ln714">  d-&gt;random.damping = p-&gt;random.damping;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln718">{</a>
<a name="ln719">  piece-&gt;data = malloc(sizeof(dt_iop_dither_data_t));</a>
<a name="ln720">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln724">{</a>
<a name="ln725">  free(piece-&gt;data);</a>
<a name="ln726">  piece-&gt;data = NULL;</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729"> </a>
<a name="ln730">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln731">{</a>
<a name="ln732">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln733">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln734">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)module-&gt;params;</a>
<a name="ln735">  dt_bauhaus_combobox_set(g-&gt;dither_type, p-&gt;dither_type);</a>
<a name="ln736">#if 0</a>
<a name="ln737">  dt_bauhaus_slider_set(g-&gt;radius, p-&gt;random.radius);</a>
<a name="ln738"> </a>
<a name="ln739">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[0], 0);</a>
<a name="ln740">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[1], 1);</a>
<a name="ln741">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[2], 2);</a>
<a name="ln742">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[3], 3);</a>
<a name="ln743">#endif</a>
<a name="ln744"> </a>
<a name="ln745">  dt_bauhaus_slider_set(g-&gt;damping, p-&gt;random.damping);</a>
<a name="ln746"> </a>
<a name="ln747">  if(p-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln748">    gtk_widget_show(GTK_WIDGET(g-&gt;random));</a>
<a name="ln749">  else</a>
<a name="ln750">    gtk_widget_hide(GTK_WIDGET(g-&gt;random));</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">void init(dt_iop_module_t *module)</a>
<a name="ln754">{</a>
<a name="ln755">  module-&gt;params = calloc(1, sizeof(dt_iop_dither_params_t));</a>
<a name="ln756">  module-&gt;default_params = calloc(1, sizeof(dt_iop_dither_params_t));</a>
<a name="ln757">  module-&gt;default_enabled = 0;</a>
<a name="ln758">  module-&gt;priority = 985; // module order created by iop_dependencies.py, do not edit!</a>
<a name="ln759">  module-&gt;params_size = sizeof(dt_iop_dither_params_t);</a>
<a name="ln760">  module-&gt;gui_data = NULL;</a>
<a name="ln761">  dt_iop_dither_params_t tmp</a>
<a name="ln762">      = (dt_iop_dither_params_t){ DITHER_FSAUTO, 0, { 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }, -200.0f } };</a>
<a name="ln763">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_dither_params_t));</a>
<a name="ln764">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_dither_params_t));</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767"> </a>
<a name="ln768">void cleanup(dt_iop_module_t *module)</a>
<a name="ln769">{</a>
<a name="ln770">  free(module-&gt;params);</a>
<a name="ln771">  module-&gt;params = NULL;</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln775">{</a>
<a name="ln776">  self-&gt;gui_data = malloc(sizeof(dt_iop_dither_gui_data_t));</a>
<a name="ln777">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln778">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln779"> </a>
<a name="ln780">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln781">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln782">  g-&gt;random = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln783"> </a>
<a name="ln784">  g-&gt;dither_type = dt_bauhaus_combobox_new(self);</a>
<a name="ln785">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;random&quot;));</a>
<a name="ln786">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 1-bit B&amp;W&quot;));</a>
<a name="ln787">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 4-bit gray&quot;));</a>
<a name="ln788">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 8-bit RGB&quot;));</a>
<a name="ln789">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 16-bit RGB&quot;));</a>
<a name="ln790">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg auto&quot;));</a>
<a name="ln791">  dt_bauhaus_widget_set_label(g-&gt;dither_type, NULL, _(&quot;method&quot;));</a>
<a name="ln792"> </a>
<a name="ln793">#if 0</a>
<a name="ln794">  g-&gt;radius = dt_bauhaus_slider_new_with_range(self, 0.0, 200.0, 0.1, p-&gt;random.radius, 2);</a>
<a name="ln795">  gtk_widget_set_tooltip_text(g-&gt;radius, _(&quot;radius for blurring step&quot;));</a>
<a name="ln796">  dt_bauhaus_widget_set_label(g-&gt;radius, NULL, _(&quot;radius&quot;));</a>
<a name="ln797"> </a>
<a name="ln798">  g-&gt;range = dtgtk_gradient_slider_multivalue_new(4);</a>
<a name="ln799">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG, 0);</a>
<a name="ln800">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG, 1);</a>
<a name="ln801">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG, 2);</a>
<a name="ln802">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG, 3);</a>
<a name="ln803">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[0], 0);</a>
<a name="ln804">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[1], 1);</a>
<a name="ln805">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[2], 2);</a>
<a name="ln806">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[3], 3);</a>
<a name="ln807">  gtk_widget_set_tooltip_text(g-&gt;range, _(&quot;the gradient range where to apply random dither&quot;));</a>
<a name="ln808">  g-&gt;range_label = gtk_label_new(_(&quot;gradient range&quot;));</a>
<a name="ln809"> </a>
<a name="ln810">  GtkWidget *rlabel = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln811">  gtk_box_pack_start(GTK_BOX(rlabel), GTK_WIDGET(g-&gt;range_label), FALSE, FALSE, 0);</a>
<a name="ln812">#endif</a>
<a name="ln813"> </a>
<a name="ln814">  g-&gt;damping = dt_bauhaus_slider_new_with_range(self, -200.0, 0.0, 1.0, p-&gt;random.damping, 3);</a>
<a name="ln815">  gtk_widget_set_tooltip_text(g-&gt;damping, _(&quot;damping level of random dither&quot;));</a>
<a name="ln816">  dt_bauhaus_widget_set_label(g-&gt;damping, NULL, _(&quot;damping&quot;));</a>
<a name="ln817">  dt_bauhaus_slider_set_format(g-&gt;damping, &quot;%.0fdB&quot;);</a>
<a name="ln818"> </a>
<a name="ln819">#if 0</a>
<a name="ln820">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;radius, TRUE, TRUE, 0);</a>
<a name="ln821">  gtk_box_pack_start(GTK_BOX(g-&gt;random), rlabel, TRUE, TRUE, 0);</a>
<a name="ln822">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;range, TRUE, TRUE, 0);</a>
<a name="ln823">#endif</a>
<a name="ln824">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;damping, TRUE, TRUE, 0);</a>
<a name="ln825"> </a>
<a name="ln826">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;dither_type, TRUE, TRUE, 0);</a>
<a name="ln827">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;random, TRUE, TRUE, 0);</a>
<a name="ln828"> </a>
<a name="ln829">  g_signal_connect(G_OBJECT(g-&gt;dither_type), &quot;value-changed&quot;, G_CALLBACK(method_callback), self);</a>
<a name="ln830">#if 0</a>
<a name="ln831">  g_signal_connect (G_OBJECT (g-&gt;radius), &quot;value-changed&quot;,</a>
<a name="ln832">                    G_CALLBACK (radius_callback), self);</a>
<a name="ln833">  g_signal_connect (G_OBJECT (g-&gt;range), &quot;value-changed&quot;,</a>
<a name="ln834">                    G_CALLBACK (range_callback), self);</a>
<a name="ln835">#endif</a>
<a name="ln836">  g_signal_connect(G_OBJECT(g-&gt;damping), &quot;value-changed&quot;, G_CALLBACK(damping_callback), self);</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln840">{</a>
<a name="ln841">  free(self-&gt;gui_data);</a>
<a name="ln842">  self-&gt;gui_data = NULL;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln846">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln847">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="610"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'tea_states' pointer in the 'tea_states + 2 * dt_get_thread_num()' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 610, 600.</p></div>
<div class="balloon" rel="763"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 763, 755.</p></div>
<div class="balloon" rel="764"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 764, 756.</p></div>
<div class="balloon" rel="782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 782, 776.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
