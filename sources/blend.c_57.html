
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 henrik andersson.</a>
<a name="ln4">    copyright (c) 2011--2014 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;blend.h&quot;</a>
<a name="ln20">#include &quot;common/gaussian.h&quot;</a>
<a name="ln21">#include &quot;common/guided_filter.h&quot;</a>
<a name="ln22">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln23">#include &quot;common/math.h&quot;</a>
<a name="ln24">#include &quot;common/opencl.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/masks.h&quot;</a>
<a name="ln28">#include &quot;develop/tiling.h&quot;</a>
<a name="ln29">#include &lt;math.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">typedef struct _blend_buffer_desc_t</a>
<a name="ln33">{</a>
<a name="ln34">  dt_iop_colorspace_type_t cst;</a>
<a name="ln35">  size_t stride;</a>
<a name="ln36">  size_t ch;</a>
<a name="ln37">  size_t bch;</a>
<a name="ln38">} _blend_buffer_desc_t;</a>
<a name="ln39"> </a>
<a name="ln40">typedef void(_blend_row_func)(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln41">                              int flag);</a>
<a name="ln42"> </a>
<a name="ln43">static inline float _Hue_2_RGB(float v1, float v2, float vH)</a>
<a name="ln44">{</a>
<a name="ln45">  if(vH &lt; 0.0f) vH += 1.0f;</a>
<a name="ln46">  if(vH &gt; 1.0f) vH -= 1.0f;</a>
<a name="ln47">  if((6.0f * vH) &lt; 1.0f) return (v1 + (v2 - v1) * 6.0f * vH);</a>
<a name="ln48">  if((2.0f * vH) &lt; 1.0f) return (v2);</a>
<a name="ln49">  if((3.0f * vH) &lt; 2.0f) return (v1 + (v2 - v1) * ((2.0f / 3.0f) - vH) * 6.0f);</a>
<a name="ln50">  return (v1);</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">static inline void _HSL_2_RGB(const float *HSL, float *RGB)</a>
<a name="ln54">{</a>
<a name="ln55">  float H = HSL[0];</a>
<a name="ln56">  float S = HSL[1];</a>
<a name="ln57">  float L = HSL[2];</a>
<a name="ln58"> </a>
<a name="ln59">  float var_1, var_2;</a>
<a name="ln60"> </a>
<a name="ln61">  if(S &lt; 1e-6f)</a>
<a name="ln62">  {</a>
<a name="ln63">    RGB[0] = RGB[1] = RGB[2] = L;</a>
<a name="ln64">  }</a>
<a name="ln65">  else</a>
<a name="ln66">  {</a>
<a name="ln67">    if(L &lt; 0.5f)</a>
<a name="ln68">      var_2 = L * (1.0f + S);</a>
<a name="ln69">    else</a>
<a name="ln70">      var_2 = (L + S) - (S * L);</a>
<a name="ln71"> </a>
<a name="ln72">    var_1 = 2.0f * L - var_2;</a>
<a name="ln73"> </a>
<a name="ln74">    RGB[0] = _Hue_2_RGB(var_1, var_2, H + (1.0f / 3.0f));</a>
<a name="ln75">    RGB[1] = _Hue_2_RGB(var_1, var_2, H);</a>
<a name="ln76">    RGB[2] = _Hue_2_RGB(var_1, var_2, H - (1.0f / 3.0f));</a>
<a name="ln77">  }</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">static inline void _RGB_2_HSV(const float *RGB, float *HSV)</a>
<a name="ln81">{</a>
<a name="ln82">  float r = RGB[0], g = RGB[1], b = RGB[2];</a>
<a name="ln83">  float *h = HSV, *s = HSV + 1, *v = HSV + 2;</a>
<a name="ln84"> </a>
<a name="ln85">  float min = fminf(r, fminf(g, b));</a>
<a name="ln86">  float max = fmaxf(r, fmaxf(g, b));</a>
<a name="ln87">  float delta = max - min;</a>
<a name="ln88"> </a>
<a name="ln89">  *v = max;</a>
<a name="ln90"> </a>
<a name="ln91">  if(fabsf(max) &gt; 1e-6f &amp;&amp; fabsf(delta) &gt; 1e-6f)</a>
<a name="ln92">  {</a>
<a name="ln93">    *s = delta / max;</a>
<a name="ln94">  }</a>
<a name="ln95">  else</a>
<a name="ln96">  {</a>
<a name="ln97">    *s = 0.0f;</a>
<a name="ln98">    *h = 0.0f;</a>
<a name="ln99">    return;</a>
<a name="ln100">  }</a>
<a name="ln101"> </a>
<a name="ln102">  if(r == max)</a>
<a name="ln103">    *h = (g - b) / delta;</a>
<a name="ln104">  else if(g == max)</a>
<a name="ln105">    *h = 2.0f + (b - r) / delta;</a>
<a name="ln106">  else</a>
<a name="ln107">    *h = 4.0f + (r - g) / delta;</a>
<a name="ln108"> </a>
<a name="ln109">  *h /= 6.0f;</a>
<a name="ln110"> </a>
<a name="ln111">  if(*h &lt; 0) *h += 1.0f;</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">static inline void _HSV_2_RGB(const float *HSV, float *RGB)</a>
<a name="ln115">{</a>
<a name="ln116">  float h = 6.0f * HSV[0], s = HSV[1], v = HSV[2];</a>
<a name="ln117">  float *r = RGB, *g = RGB + 1, *b = RGB + 2;</a>
<a name="ln118"> </a>
<a name="ln119">  if(fabsf(s) &lt; 1e-6f)</a>
<a name="ln120">  {</a>
<a name="ln121">    *r = *g = *b = v;</a>
<a name="ln122">    return;</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  float i = floorf(h);</a>
<a name="ln126">  float f = h - i;</a>
<a name="ln127">  float p = v * (1.0f - s);</a>
<a name="ln128">  float q = v * (1.0f - s * f);</a>
<a name="ln129">  float t = v * (1.0f - s * (1.0f - f));</a>
<a name="ln130"> </a>
<a name="ln131">  switch((int)i)</a>
<a name="ln132">  {</a>
<a name="ln133">    case 0:</a>
<a name="ln134">      *r = v;</a>
<a name="ln135">      *g = t;</a>
<a name="ln136">      *b = p;</a>
<a name="ln137">      break;</a>
<a name="ln138">    case 1:</a>
<a name="ln139">      *r = q;</a>
<a name="ln140">      *g = v;</a>
<a name="ln141">      *b = p;</a>
<a name="ln142">      break;</a>
<a name="ln143">    case 2:</a>
<a name="ln144">      *r = p;</a>
<a name="ln145">      *g = v;</a>
<a name="ln146">      *b = t;</a>
<a name="ln147">      break;</a>
<a name="ln148">    case 3:</a>
<a name="ln149">      *r = p;</a>
<a name="ln150">      *g = q;</a>
<a name="ln151">      *b = v;</a>
<a name="ln152">      break;</a>
<a name="ln153">    case 4:</a>
<a name="ln154">      *r = t;</a>
<a name="ln155">      *g = p;</a>
<a name="ln156">      *b = v;</a>
<a name="ln157">      break;</a>
<a name="ln158">    case 5:</a>
<a name="ln159">    default:</a>
<a name="ln160">      *r = v;</a>
<a name="ln161">      *g = p;</a>
<a name="ln162">      *b = q;</a>
<a name="ln163">      break;</a>
<a name="ln164">  }</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">static inline void _CLAMP_XYZ(float *XYZ, const float *min, const float *max)</a>
<a name="ln168">{</a>
<a name="ln169">  XYZ[0] =clamp_range_f(XYZ[0], min[0], max[0]);</a>
<a name="ln170">  XYZ[1] =clamp_range_f(XYZ[1], min[1], max[1]);</a>
<a name="ln171">  XYZ[2] =clamp_range_f(XYZ[2], min[2], max[2]);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">static inline void _PX_COPY(const float *src, float *dst)</a>
<a name="ln175">{</a>
<a name="ln176">  dst[0] = src[0];</a>
<a name="ln177">  dst[1] = src[1];</a>
<a name="ln178">  dst[2] = src[2];</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static inline float _blendif_factor(dt_iop_colorspace_type_t cst, const float *input, const float *output,</a>
<a name="ln182">                                    const unsigned int blendif, const float *parameters,</a>
<a name="ln183">                                    const unsigned int mask_mode, const unsigned int mask_combine,</a>
<a name="ln184">                                    const dt_iop_order_iccprofile_info_t *work_profile)</a>
<a name="ln185">{</a>
<a name="ln186">  float result = 1.0f;</a>
<a name="ln187">  float scaled[DEVELOP_BLENDIF_SIZE] = { 0.5f };</a>
<a name="ln188">  unsigned int channel_mask = 0;</a>
<a name="ln189"> </a>
<a name="ln190">  if(!(mask_mode &amp; DEVELOP_MASK_CONDITIONAL)) return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln191"> </a>
<a name="ln192">  switch(cst)</a>
<a name="ln193">  {</a>
<a name="ln194">    case iop_cs_Lab:</a>
<a name="ln195">      scaled[DEVELOP_BLENDIF_L_in] =clamp_range_f(input[0]/100.0f, 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln196">      scaled[DEVELOP_BLENDIF_A_in]</a>
<a name="ln197">          =clamp_range_f((input[1]+128.0f)/256.0f, 0.0f, 1.0f); // a scaled to 0..1</a>
<a name="ln198">      scaled[DEVELOP_BLENDIF_B_in]</a>
<a name="ln199">          =clamp_range_f((input[2]+128.0f)/256.0f, 0.0f, 1.0f);                 // b scaled to 0..1</a>
<a name="ln200">      scaled[DEVELOP_BLENDIF_L_out] =clamp_range_f(output[0]/100.0f, 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln201">      scaled[DEVELOP_BLENDIF_A_out]</a>
<a name="ln202">          =clamp_range_f((output[1]+128.0f)/256.0f, 0.0f, 1.0f); // a scaled to 0..1</a>
<a name="ln203">      scaled[DEVELOP_BLENDIF_B_out]</a>
<a name="ln204">          =clamp_range_f((output[2]+128.0f)/256.0f, 0.0f, 1.0f); // b scaled to 0..1</a>
<a name="ln205"> </a>
<a name="ln206">      if(blendif &amp; 0x7f00) // do we need to consider LCh ?</a>
<a name="ln207">      {</a>
<a name="ln208">        float LCH_input[3];</a>
<a name="ln209">        float LCH_output[3];</a>
<a name="ln210">        dt_Lab_2_LCH(input, LCH_input);</a>
<a name="ln211">        dt_Lab_2_LCH(output, LCH_output);</a>
<a name="ln212"> </a>
<a name="ln213">        scaled[DEVELOP_BLENDIF_C_in] =clamp_range_f(LCH_input[1]/(128.0f*sqrtf(2.0f)), 0.0f,</a>
<a name="ln214">                                                    1.0f);                     // C scaled to 0..1</a>
<a name="ln215">        scaled[DEVELOP_BLENDIF_h_in] =clamp_range_f(LCH_input[2], 0.0f, 1.0f); // h scaled to 0..1</a>
<a name="ln216"> </a>
<a name="ln217">        scaled[DEVELOP_BLENDIF_C_out] =clamp_range_f(LCH_output[1]/(128.0f*sqrtf(2.0f)), 0.0f,</a>
<a name="ln218">                                                     1.0f);                      // C scaled to 0..1</a>
<a name="ln219">        scaled[DEVELOP_BLENDIF_h_out] =clamp_range_f(LCH_output[2], 0.0f, 1.0f); // h scaled to 0..1</a>
<a name="ln220">      }</a>
<a name="ln221"> </a>
<a name="ln222">      channel_mask = DEVELOP_BLENDIF_Lab_MASK;</a>
<a name="ln223"> </a>
<a name="ln224">      break;</a>
<a name="ln225">    case iop_cs_rgb:</a>
<a name="ln226">      if(work_profile == NULL)</a>
<a name="ln227">        scaled[DEVELOP_BLENDIF_GRAY_in] =clamp_range_f(0.3f*input[0]+0.59f*input[1]+0.11f*input[2], 0.0f,</a>
<a name="ln228">                                                       1.0f); // Gray scaled to 0..1</a>
<a name="ln229">      else</a>
<a name="ln230">        scaled[DEVELOP_BLENDIF_GRAY_in] =clamp_range_f(dt_ioppr_get_rgb_matrix_luminance(input, work_profile), 0.0f,</a>
<a name="ln231">                                                       1.0f);                // Gray scaled to 0..1</a>
<a name="ln232">      scaled[DEVELOP_BLENDIF_RED_in] =clamp_range_f(input[0], 0.0f, 1.0f);   // Red</a>
<a name="ln233">      scaled[DEVELOP_BLENDIF_GREEN_in] =clamp_range_f(input[1], 0.0f, 1.0f); // Green</a>
<a name="ln234">      scaled[DEVELOP_BLENDIF_BLUE_in] =clamp_range_f(input[2], 0.0f, 1.0f);  // Blue</a>
<a name="ln235">      if(work_profile == NULL)</a>
<a name="ln236">        scaled[DEVELOP_BLENDIF_GRAY_out] =clamp_range_f(0.3f*output[0]+0.59f*output[1]+0.11f*output[2],</a>
<a name="ln237">                                                        0.0f, 1.0f); // Gray scaled to 0..1</a>
<a name="ln238">      else</a>
<a name="ln239">        scaled[DEVELOP_BLENDIF_GRAY_out] =clamp_range_f(dt_ioppr_get_rgb_matrix_luminance(output, work_profile),</a>
<a name="ln240">                                                        0.0f, 1.0f);           // Gray scaled to 0..1</a>
<a name="ln241">      scaled[DEVELOP_BLENDIF_RED_out] =clamp_range_f(output[0], 0.0f, 1.0f);   // Red</a>
<a name="ln242">      scaled[DEVELOP_BLENDIF_GREEN_out] =clamp_range_f(output[1], 0.0f, 1.0f); // Green</a>
<a name="ln243">      scaled[DEVELOP_BLENDIF_BLUE_out] =clamp_range_f(output[2], 0.0f, 1.0f);  // Blue</a>
<a name="ln244"> </a>
<a name="ln245">      if(blendif &amp; 0x7f00) // do we need to consider HSL ?</a>
<a name="ln246">      {</a>
<a name="ln247">        float HSL_input[3];</a>
<a name="ln248">        float HSL_output[3];</a>
<a name="ln249">        dt_RGB_2_HSL(input, HSL_input);</a>
<a name="ln250">        dt_RGB_2_HSL(output, HSL_output);</a>
<a name="ln251"> </a>
<a name="ln252">        scaled[DEVELOP_BLENDIF_H_in] =clamp_range_f(HSL_input[0], 0.0f, 1.0f); // H scaled to 0..1</a>
<a name="ln253">        scaled[DEVELOP_BLENDIF_S_in] =clamp_range_f(HSL_input[1], 0.0f, 1.0f); // S scaled to 0..1</a>
<a name="ln254">        scaled[DEVELOP_BLENDIF_l_in] =clamp_range_f(HSL_input[2], 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln255"> </a>
<a name="ln256">        scaled[DEVELOP_BLENDIF_H_out] =clamp_range_f(HSL_output[0], 0.0f, 1.0f); // H scaled to 0..1</a>
<a name="ln257">        scaled[DEVELOP_BLENDIF_S_out] =clamp_range_f(HSL_output[1], 0.0f, 1.0f); // S scaled to 0..1</a>
<a name="ln258">        scaled[DEVELOP_BLENDIF_l_out] =clamp_range_f(HSL_output[2], 0.0f, 1.0f); // L scaled to 0..1</a>
<a name="ln259">      }</a>
<a name="ln260"> </a>
<a name="ln261">      channel_mask = DEVELOP_BLENDIF_RGB_MASK;</a>
<a name="ln262"> </a>
<a name="ln263">      break;</a>
<a name="ln264">    default:</a>
<a name="ln265">      return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f; // not implemented for other color spaces</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  for(int ch = 0; ch &lt;= DEVELOP_BLENDIF_MAX; ch++)</a>
<a name="ln269">  {</a>
<a name="ln270">    if((channel_mask &amp; (1 &lt;&lt; ch)) == 0) continue; // skip blendif channels not used in this color space</a>
<a name="ln271"> </a>
<a name="ln272">    if((blendif &amp; (1 &lt;&lt; ch)) == 0) // deal with channels where sliders span the whole range</a>
<a name="ln273">    {</a>
<a name="ln274">      result *= !(blendif &amp; (1 &lt;&lt; (ch + 16))) == !(mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f : 0.0f;</a>
<a name="ln275">      continue;</a>
<a name="ln276">    }</a>
<a name="ln277"> </a>
<a name="ln278">    if(result &lt;= 0.000001f) break; // no need to continue if we are already at or close to zero</a>
<a name="ln279"> </a>
<a name="ln280">    float factor;</a>
<a name="ln281">    if(scaled[ch] &gt;= parameters[4 * ch + 1] &amp;&amp; scaled[ch] &lt;= parameters[4 * ch + 2])</a>
<a name="ln282">    {</a>
<a name="ln283">      factor = 1.0f;</a>
<a name="ln284">    }</a>
<a name="ln285">    else if(scaled[ch] &gt; parameters[4 * ch + 0] &amp;&amp; scaled[ch] &lt; parameters[4 * ch + 1])</a>
<a name="ln286">    {</a>
<a name="ln287">      factor</a>
<a name="ln288">          = (scaled[ch] - parameters[4 * ch + 0]) / fmaxf(0.01f, parameters[4 * ch + 1] - parameters[4 * ch + 0]);</a>
<a name="ln289">    }</a>
<a name="ln290">    else if(scaled[ch] &gt; parameters[4 * ch + 2] &amp;&amp; scaled[ch] &lt; parameters[4 * ch + 3])</a>
<a name="ln291">    {</a>
<a name="ln292">      factor = 1.0f</a>
<a name="ln293">               - (scaled[ch] - parameters[4 * ch + 2])</a>
<a name="ln294">                     / fmaxf(0.01f, parameters[4 * ch + 3] - parameters[4 * ch + 2]);</a>
<a name="ln295">    }</a>
<a name="ln296">    else</a>
<a name="ln297">      factor = 0.0f;</a>
<a name="ln298"> </a>
<a name="ln299">    if((blendif &amp; (1 &lt;&lt; (ch + 16))) != 0) factor = 1.0f - factor; // inverted channel?</a>
<a name="ln300"> </a>
<a name="ln301">    result *= ((mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - factor : factor);</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  return (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - result : result;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static inline void _blend_colorspace_channel_range(dt_iop_colorspace_type_t cst, float *min, float *max)</a>
<a name="ln308">{</a>
<a name="ln309">  switch(cst)</a>
<a name="ln310">  {</a>
<a name="ln311">    case iop_cs_Lab: // after scaling !!!</a>
<a name="ln312">      min[0] = 0.0f;</a>
<a name="ln313">      max[0] = 1.0f;</a>
<a name="ln314">      min[1] = -1.0f;</a>
<a name="ln315">      max[1] = 1.0f;</a>
<a name="ln316">      min[2] = -1.0f;</a>
<a name="ln317">      max[2] = 1.0f;</a>
<a name="ln318">      min[3] = 0.0f;</a>
<a name="ln319">      max[3] = 1.0f;</a>
<a name="ln320">      break;</a>
<a name="ln321">    default:</a>
<a name="ln322">      min[0] = 0.0f;</a>
<a name="ln323">      max[0] = 1.0f;</a>
<a name="ln324">      min[1] = 0.0f;</a>
<a name="ln325">      max[1] = 1.0f;</a>
<a name="ln326">      min[2] = 0.0f;</a>
<a name="ln327">      max[2] = 1.0f;</a>
<a name="ln328">      min[3] = 0.0f;</a>
<a name="ln329">      max[3] = 1.0f;</a>
<a name="ln330">      break;</a>
<a name="ln331">  }</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">static inline void _blend_Lab_scale(const float *i, float *o)</a>
<a name="ln335">{</a>
<a name="ln336">  o[0] = i[0] / 100.0f;</a>
<a name="ln337">  o[1] = i[1] / 128.0f;</a>
<a name="ln338">  o[2] = i[2] / 128.0f;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">static inline void _blend_Lab_rescale(const float *i, float *o)</a>
<a name="ln342">{</a>
<a name="ln343">  o[0] = i[0] * 100.0f;</a>
<a name="ln344">  o[1] = i[1] * 128.0f;</a>
<a name="ln345">  o[2] = i[2] * 128.0f;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">static inline void _blend_noop(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln350">                               const float *min, const float *max)</a>
<a name="ln351">{</a>
<a name="ln352">  for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln353">  {</a>
<a name="ln354">    for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] =clamp_range_f(a[j+k], min ? min[k] : -INFINITY, max ? max[k] : INFINITY);</a>
<a name="ln355">    if(bd-&gt;cst != iop_cs_RAW) b[j + 3] = mask[i];</a>
<a name="ln356">  }</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">/* generate blend mask */</a>
<a name="ln361">static void _blend_make_mask(const _blend_buffer_desc_t *bd, const unsigned int blendif,</a>
<a name="ln362">                             const float *blendif_parameters, const unsigned int mask_mode,</a>
<a name="ln363">                             const unsigned int mask_combine, const float gopacity, const float *a, const float *b,</a>
<a name="ln364">                             float *mask, const dt_iop_order_iccprofile_info_t *const work_profile)</a>
<a name="ln365">{</a>
<a name="ln366">  for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln367">  {</a>
<a name="ln368">    float form = mask[i];</a>
<a name="ln369">    float conditional = _blendif_factor(bd-&gt;cst, &amp;a[j], &amp;b[j], blendif, blendif_parameters, mask_mode,</a>
<a name="ln370">                                        mask_combine, work_profile);</a>
<a name="ln371">    float opacity = (mask_combine &amp; DEVELOP_COMBINE_INCL) ? 1.0f - (1.0f - form) * (1.0f - conditional)</a>
<a name="ln372">                                                          : form * conditional;</a>
<a name="ln373">    opacity = (mask_combine &amp; DEVELOP_COMBINE_INV) ? 1.0f - opacity : opacity;</a>
<a name="ln374">    mask[i] = opacity * gopacity;</a>
<a name="ln375">  }</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">/* normal blend with clamping */</a>
<a name="ln379">static void _blend_normal_bounded(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln380">                                  int flag)</a>
<a name="ln381">{</a>
<a name="ln382">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln383">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln384"> </a>
<a name="ln385">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln386">  {</a>
<a name="ln387">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln388">    {</a>
<a name="ln389">      float local_opacity = mask[i];</a>
<a name="ln390">      float ta[3], tb[3];</a>
<a name="ln391">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln392">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln393"> </a>
<a name="ln394">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+tb[0]*local_opacity, min[0], max[0]);</a>
<a name="ln395"> </a>
<a name="ln396">      if(flag == 0)</a>
<a name="ln397">      {</a>
<a name="ln398">        tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity)+tb[1]*local_opacity, min[1], max[1]);</a>
<a name="ln399">        tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity)+tb[2]*local_opacity, min[2], max[2]);</a>
<a name="ln400">      }</a>
<a name="ln401">      else</a>
<a name="ln402">      {</a>
<a name="ln403">        tb[1] = ta[1];</a>
<a name="ln404">        tb[2] = ta[2];</a>
<a name="ln405">      }</a>
<a name="ln406"> </a>
<a name="ln407">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln408">      b[j + 3] = local_opacity;</a>
<a name="ln409">    }</a>
<a name="ln410">  }</a>
<a name="ln411">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln412">  {</a>
<a name="ln413">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln414">    {</a>
<a name="ln415">      float local_opacity = mask[i];</a>
<a name="ln416">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln417">        b[j + k]</a>
<a name="ln418">            =clamp_range_f(a[j+k]*(1.0f-local_opacity)+b[j+k]*local_opacity, min[k], max[k]);</a>
<a name="ln419">      b[j + 3] = local_opacity;</a>
<a name="ln420">    }</a>
<a name="ln421">  }</a>
<a name="ln422">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln423">  {</a>
<a name="ln424">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln425">    {</a>
<a name="ln426">      float local_opacity = mask[i];</a>
<a name="ln427">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln428">        b[j + k]</a>
<a name="ln429">            =clamp_range_f(a[j+k]*(1.0f-local_opacity)+b[j+k]*local_opacity, min[k], max[k]);</a>
<a name="ln430">    }</a>
<a name="ln431">  }</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">/* normal blend without any clamping */</a>
<a name="ln435">static void _blend_normal_unbounded(const _blend_buffer_desc_t *bd, const float *a, float *b,</a>
<a name="ln436">                                    const float *mask, int flag)</a>
<a name="ln437">{</a>
<a name="ln438">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln439">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln440"> </a>
<a name="ln441">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln442">  {</a>
<a name="ln443">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln444">    {</a>
<a name="ln445">      float local_opacity = mask[i];</a>
<a name="ln446">      float ta[3], tb[3];</a>
<a name="ln447">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln448">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln449"> </a>
<a name="ln450">      tb[0] = ta[0] * (1.0f - local_opacity) + tb[0] * local_opacity;</a>
<a name="ln451"> </a>
<a name="ln452">      if(flag == 0)</a>
<a name="ln453">      {</a>
<a name="ln454">        tb[1] = ta[1] * (1.0f - local_opacity) + tb[1] * local_opacity;</a>
<a name="ln455">        tb[2] = ta[2] * (1.0f - local_opacity) + tb[2] * local_opacity;</a>
<a name="ln456">      }</a>
<a name="ln457">      else</a>
<a name="ln458">      {</a>
<a name="ln459">        tb[1] = ta[1];</a>
<a name="ln460">        tb[2] = ta[2];</a>
<a name="ln461">      }</a>
<a name="ln462"> </a>
<a name="ln463">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln464">      b[j + 3] = local_opacity;</a>
<a name="ln465">    }</a>
<a name="ln466">  }</a>
<a name="ln467">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln468">  {</a>
<a name="ln469">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln470">    {</a>
<a name="ln471">      float local_opacity = mask[i];</a>
<a name="ln472">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln473">        b[j + k] = a[j + k] * (1.0f - local_opacity) + b[j + k] * local_opacity;</a>
<a name="ln474">      b[j + 3] = local_opacity;</a>
<a name="ln475">    }</a>
<a name="ln476">  }</a>
<a name="ln477">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln478">  {</a>
<a name="ln479">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln480">    {</a>
<a name="ln481">      float local_opacity = mask[i];</a>
<a name="ln482">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln483">        b[j + k] = a[j + k] * (1.0f - local_opacity) + b[j + k] * local_opacity;</a>
<a name="ln484">    }</a>
<a name="ln485">  }</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">/* lighten */</a>
<a name="ln489">static void _blend_lighten(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln490">                           int flag)</a>
<a name="ln491">{</a>
<a name="ln492">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln493">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln494"> </a>
<a name="ln495">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln496">  {</a>
<a name="ln497">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln498">    {</a>
<a name="ln499">      float local_opacity = mask[i];</a>
<a name="ln500">      float ta[3], tb[3], tbo;</a>
<a name="ln501">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln502">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln503"> </a>
<a name="ln504">      tbo = tb[0];</a>
<a name="ln505">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+(ta[0]&gt;tb[0] ? ta[0] : tb[0])*local_opacity,</a>
<a name="ln506">                           min[0], max[0]);</a>
<a name="ln507"> </a>
<a name="ln508">      if(flag == 0)</a>
<a name="ln509">      {</a>
<a name="ln510">        tb[1] =clamp_range_f(ta[1]*(1.0f-fabsf(tbo-tb[0]))+0.5f*(ta[1]+tb[1])*fabsf(tbo-tb[0]),</a>
<a name="ln511">                             min[1], max[1]);</a>
<a name="ln512">        tb[2] =clamp_range_f(ta[2]*(1.0f-fabsf(tbo-tb[0]))+0.5f*(ta[2]+tb[2])*fabsf(tbo-tb[0]),</a>
<a name="ln513">                             min[2], max[2]);</a>
<a name="ln514">      }</a>
<a name="ln515">      else</a>
<a name="ln516">      {</a>
<a name="ln517">        tb[1] = ta[1];</a>
<a name="ln518">        tb[2] = ta[2];</a>
<a name="ln519">      }</a>
<a name="ln520"> </a>
<a name="ln521">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln522">      b[j + 3] = local_opacity;</a>
<a name="ln523">    }</a>
<a name="ln524">  }</a>
<a name="ln525">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln526">  {</a>
<a name="ln527">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln528">    {</a>
<a name="ln529">      float local_opacity = mask[i];</a>
<a name="ln530">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln531">        b[j + k] =clamp_range_f(a[j+k]*(1.0f-local_opacity)+fmaxf(a[j+k], b[j+k])*local_opacity,</a>
<a name="ln532">                                min[k], max[k]);</a>
<a name="ln533">      b[j + 3] = local_opacity;</a>
<a name="ln534">    }</a>
<a name="ln535">  }</a>
<a name="ln536">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln537">  {</a>
<a name="ln538">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln539">    {</a>
<a name="ln540">      float local_opacity = mask[i];</a>
<a name="ln541">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln542">        b[j + k] =clamp_range_f(a[j+k]*(1.0f-local_opacity)+fmaxf(a[j+k], b[j+k])*local_opacity,</a>
<a name="ln543">                                min[k], max[k]);</a>
<a name="ln544">    }</a>
<a name="ln545">  }</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">/* darken */</a>
<a name="ln549">static void _blend_darken(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln550">                          int flag)</a>
<a name="ln551">{</a>
<a name="ln552">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln553">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln554"> </a>
<a name="ln555">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln556">  {</a>
<a name="ln557">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln558">    {</a>
<a name="ln559">      float local_opacity = mask[i];</a>
<a name="ln560">      float ta[3], tb[3], tbo;</a>
<a name="ln561">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln562">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln563"> </a>
<a name="ln564">      tbo = tb[0];</a>
<a name="ln565">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+(ta[0]&lt;tb[0] ? ta[0] : tb[0])*local_opacity,</a>
<a name="ln566">                           min[0], max[0]);</a>
<a name="ln567"> </a>
<a name="ln568">      if(flag == 0)</a>
<a name="ln569">      {</a>
<a name="ln570">        tb[1] =clamp_range_f(ta[1]*(1.0f-fabsf(tbo-tb[0]))+0.5f*(ta[1]+tb[1])*fabsf(tbo-tb[0]),</a>
<a name="ln571">                             min[1], max[1]);</a>
<a name="ln572">        tb[2] =clamp_range_f(ta[2]*(1.0f-fabsf(tbo-tb[0]))+0.5f*(ta[2]+tb[2])*fabsf(tbo-tb[0]),</a>
<a name="ln573">                             min[2], max[2]);</a>
<a name="ln574">      }</a>
<a name="ln575">      else</a>
<a name="ln576">      {</a>
<a name="ln577">        tb[1] = ta[1];</a>
<a name="ln578">        tb[2] = ta[2];</a>
<a name="ln579">      }</a>
<a name="ln580"> </a>
<a name="ln581">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln582">      b[j + 3] = local_opacity;</a>
<a name="ln583">    }</a>
<a name="ln584">  }</a>
<a name="ln585">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln586">  {</a>
<a name="ln587">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln588">    {</a>
<a name="ln589">      float local_opacity = mask[i];</a>
<a name="ln590">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln591">        b[j + k] =clamp_range_f(a[j+k]*(1.0f-local_opacity)+fminf(a[j+k], b[j+k])*local_opacity,</a>
<a name="ln592">                                min[k], max[k]);</a>
<a name="ln593">      b[j + 3] = local_opacity;</a>
<a name="ln594">    }</a>
<a name="ln595">  }</a>
<a name="ln596">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln597">  {</a>
<a name="ln598">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln599">    {</a>
<a name="ln600">      float local_opacity = mask[i];</a>
<a name="ln601">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln602">        b[j + k] =clamp_range_f(a[j+k]*(1.0f-local_opacity)+fminf(a[j+k], b[j+k])*local_opacity,</a>
<a name="ln603">                                min[k], max[k]);</a>
<a name="ln604">    }</a>
<a name="ln605">  }</a>
<a name="ln606">  // return fminf(a,b);</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">/* multiply */</a>
<a name="ln610">static void _blend_multiply(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln611">                            int flag)</a>
<a name="ln612">{</a>
<a name="ln613">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln614">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln615"> </a>
<a name="ln616">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln617">  {</a>
<a name="ln618">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln619">    {</a>
<a name="ln620">      float local_opacity = mask[i];</a>
<a name="ln621">      float ta[3], tb[3];</a>
<a name="ln622">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln623"> </a>
<a name="ln624">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln625">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln626">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln627">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln628">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln629"> </a>
<a name="ln630">      tb[0] =clamp_range_f((la*(1.0f-local_opacity))+((la*lb)*local_opacity), min[0], max[0])</a>
<a name="ln631">              - fabsf(min[0]);</a>
<a name="ln632"> </a>
<a name="ln633">      if(flag == 0)</a>
<a name="ln634">      {</a>
<a name="ln635">        if(ta[0] &gt; 0.01f)</a>
<a name="ln636">        {</a>
<a name="ln637">          tb[1]</a>
<a name="ln638">              =clamp_range_f(ta[1]*(1.0f-local_opacity)+(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity,</a>
<a name="ln639">                             min[1], max[1]);</a>
<a name="ln640">          tb[2]</a>
<a name="ln641">              =clamp_range_f(ta[2]*(1.0f-local_opacity)+(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity,</a>
<a name="ln642">                             min[2], max[2]);</a>
<a name="ln643">        }</a>
<a name="ln644">        else</a>
<a name="ln645">        {</a>
<a name="ln646">          tb[1]</a>
<a name="ln647">              =clamp_range_f(ta[1]*(1.0f-local_opacity)+(ta[1]+tb[1])*tb[0]/0.01f*local_opacity,</a>
<a name="ln648">                             min[1], max[1]);</a>
<a name="ln649">          tb[2]</a>
<a name="ln650">              =clamp_range_f(ta[2]*(1.0f-local_opacity)+(ta[2]+tb[2])*tb[0]/0.01f*local_opacity,</a>
<a name="ln651">                             min[2], max[2]);</a>
<a name="ln652">        }</a>
<a name="ln653">      }</a>
<a name="ln654">      else</a>
<a name="ln655">      {</a>
<a name="ln656">        tb[1] = ta[1];</a>
<a name="ln657">        tb[2] = ta[2];</a>
<a name="ln658">      }</a>
<a name="ln659"> </a>
<a name="ln660">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln661">      b[j + 3] = local_opacity;</a>
<a name="ln662">    }</a>
<a name="ln663">  }</a>
<a name="ln664">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln665">  {</a>
<a name="ln666">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln667">    {</a>
<a name="ln668">      float local_opacity = mask[i];</a>
<a name="ln669">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln670">        b[j + k] =clamp_range_f(</a>
<a name="ln671">            a[j+k]*(1.0f-local_opacity)+(a[j+k]*b[j+k])*local_opacity, min[k], max[k]);</a>
<a name="ln672">      b[j + 3] = local_opacity;</a>
<a name="ln673">    }</a>
<a name="ln674">  }</a>
<a name="ln675">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln676">  {</a>
<a name="ln677">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln678">    {</a>
<a name="ln679">      float local_opacity = mask[i];</a>
<a name="ln680">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln681"> </a>
<a name="ln682">        b[j + k] =clamp_range_f(</a>
<a name="ln683">            a[j+k]*(1.0f-local_opacity)+(a[j+k]*b[j+k])*local_opacity, min[k], max[k]);</a>
<a name="ln684">    }</a>
<a name="ln685">  }</a>
<a name="ln686">  // return (a*b);</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">/* average */</a>
<a name="ln690">static void _blend_average(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln691">                           int flag)</a>
<a name="ln692">{</a>
<a name="ln693">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln694">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln695"> </a>
<a name="ln696">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln697">  {</a>
<a name="ln698">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln699">    {</a>
<a name="ln700">      float local_opacity = mask[i];</a>
<a name="ln701">      float ta[3], tb[3];</a>
<a name="ln702">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln703">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln704"> </a>
<a name="ln705">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+(ta[0]+tb[0])/2.0f*local_opacity, min[0],</a>
<a name="ln706">                           max[0]);</a>
<a name="ln707"> </a>
<a name="ln708">      if(flag == 0)</a>
<a name="ln709">      {</a>
<a name="ln710">        tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity)+(ta[1]+tb[1])/2.0f*local_opacity, min[1],</a>
<a name="ln711">                             max[1]);</a>
<a name="ln712">        tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity)+(ta[2]+tb[2])/2.0f*local_opacity, min[2],</a>
<a name="ln713">                             max[2]);</a>
<a name="ln714">      }</a>
<a name="ln715">      else</a>
<a name="ln716">      {</a>
<a name="ln717">        tb[1] = ta[1];</a>
<a name="ln718">        tb[2] = ta[2];</a>
<a name="ln719">      }</a>
<a name="ln720"> </a>
<a name="ln721">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln722">      b[j + 3] = local_opacity;</a>
<a name="ln723">    }</a>
<a name="ln724">  }</a>
<a name="ln725">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln726">  {</a>
<a name="ln727">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln728">    {</a>
<a name="ln729">      float local_opacity = mask[i];</a>
<a name="ln730">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln731">        b[j + k] =clamp_range_f(</a>
<a name="ln732">            a[j+k]*(1.0f-local_opacity)+(a[j+k]+b[j+k])/2.0f*local_opacity, min[k], max[k]);</a>
<a name="ln733"> </a>
<a name="ln734">      b[j + 3] = local_opacity;</a>
<a name="ln735">    }</a>
<a name="ln736">  }</a>
<a name="ln737">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln738">  {</a>
<a name="ln739">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln740">    {</a>
<a name="ln741">      float local_opacity = mask[i];</a>
<a name="ln742">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln743">        b[j + k] =clamp_range_f(</a>
<a name="ln744">            a[j+k]*(1.0f-local_opacity)+(a[j+k]+b[j+k])/2.0f*local_opacity, min[k], max[k]);</a>
<a name="ln745">    }</a>
<a name="ln746">  }</a>
<a name="ln747">  // return (a+b)/2.0;</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/* add */</a>
<a name="ln751">static void _blend_add(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln752">{</a>
<a name="ln753">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln754">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln755"> </a>
<a name="ln756">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln757">  {</a>
<a name="ln758">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln759">    {</a>
<a name="ln760">      float local_opacity = mask[i];</a>
<a name="ln761">      float ta[3], tb[3];</a>
<a name="ln762">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln763">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln764"> </a>
<a name="ln765">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+(ta[0]+tb[0])*local_opacity, min[0],</a>
<a name="ln766">                           max[0]);</a>
<a name="ln767"> </a>
<a name="ln768">      if(flag == 0)</a>
<a name="ln769">      {</a>
<a name="ln770">        tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity)+(ta[1]+tb[1])*local_opacity, min[1],</a>
<a name="ln771">                             max[1]);</a>
<a name="ln772">        tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity)+(ta[2]+tb[2])*local_opacity, min[2],</a>
<a name="ln773">                             max[2]);</a>
<a name="ln774">      }</a>
<a name="ln775">      else</a>
<a name="ln776">      {</a>
<a name="ln777">        tb[1] = ta[1];</a>
<a name="ln778">        tb[2] = ta[2];</a>
<a name="ln779">      }</a>
<a name="ln780"> </a>
<a name="ln781">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln782">      b[j + 3] = local_opacity;</a>
<a name="ln783">    }</a>
<a name="ln784">  }</a>
<a name="ln785">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln786">  {</a>
<a name="ln787">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln788">    {</a>
<a name="ln789">      float local_opacity = mask[i];</a>
<a name="ln790">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln791">        b[j + k] =clamp_range_f(</a>
<a name="ln792">            a[j+k]*(1.0f-local_opacity)+(a[j+k]+b[j+k])*local_opacity, min[k], max[k]);</a>
<a name="ln793">      b[j + 3] = local_opacity;</a>
<a name="ln794">    }</a>
<a name="ln795">  }</a>
<a name="ln796">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln797">  {</a>
<a name="ln798">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln799">    {</a>
<a name="ln800">      float local_opacity = mask[i];</a>
<a name="ln801">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln802">        b[j + k] =clamp_range_f(</a>
<a name="ln803">            a[j+k]*(1.0f-local_opacity)+(a[j+k]+b[j+k])*local_opacity, min[k], max[k]);</a>
<a name="ln804">    }</a>
<a name="ln805">  }</a>
<a name="ln806">  /*</a>
<a name="ln807">  float max,min;</a>
<a name="ln808">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln809">  return clamp_range_f(a+b,min,max);</a>
<a name="ln810">  */</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">/* substract */</a>
<a name="ln814">static void _blend_substract(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln815">                             int flag)</a>
<a name="ln816">{</a>
<a name="ln817">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln818">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln819"> </a>
<a name="ln820">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln821">  {</a>
<a name="ln822">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln823">    {</a>
<a name="ln824">      float local_opacity = mask[i];</a>
<a name="ln825">      float ta[3], tb[3];</a>
<a name="ln826">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln827">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln828"> </a>
<a name="ln829">      tb[0] =clamp_range_f(</a>
<a name="ln830">          ta[0]*(1.0f-local_opacity)+((tb[0]+ta[0])-(fabsf(min[0]+max[0])))*local_opacity,</a>
<a name="ln831">          min[0], max[0]);</a>
<a name="ln832"> </a>
<a name="ln833">      if(flag == 0)</a>
<a name="ln834">      {</a>
<a name="ln835">        tb[1] =clamp_range_f(</a>
<a name="ln836">            ta[1]*(1.0f-local_opacity)+((tb[1]+ta[1])-(fabsf(min[1]+max[1])))*local_opacity,</a>
<a name="ln837">            min[1], max[1]);</a>
<a name="ln838">        tb[2] =clamp_range_f(</a>
<a name="ln839">            ta[2]*(1.0f-local_opacity)+((tb[2]+ta[2])-(fabsf(min[2]+max[2])))*local_opacity,</a>
<a name="ln840">            min[2], max[2]);</a>
<a name="ln841">      }</a>
<a name="ln842">      else</a>
<a name="ln843">      {</a>
<a name="ln844">        tb[1] = ta[1];</a>
<a name="ln845">        tb[2] = ta[2];</a>
<a name="ln846">      }</a>
<a name="ln847"> </a>
<a name="ln848">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln849">      b[j + 3] = local_opacity;</a>
<a name="ln850">    }</a>
<a name="ln851">  }</a>
<a name="ln852">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln853">  {</a>
<a name="ln854">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln855">    {</a>
<a name="ln856">      float local_opacity = mask[i];</a>
<a name="ln857">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln858">        b[j + k] =clamp_range_f(a[j+k]*(1.0f-local_opacity)</a>
<a name="ln859">                                +((b[j+k]+a[j+k])-(fabsf(min[k]+max[k])))*local_opacity,</a>
<a name="ln860">                                min[k], max[k]);</a>
<a name="ln861">      b[j + 3] = local_opacity;</a>
<a name="ln862">    }</a>
<a name="ln863">  }</a>
<a name="ln864">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln865">  {</a>
<a name="ln866">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln867">    {</a>
<a name="ln868">      float local_opacity = mask[i];</a>
<a name="ln869">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln870">        b[j + k] =clamp_range_f(a[j+k]*(1.0f-local_opacity)</a>
<a name="ln871">                                +((b[j+k]+a[j+k])-(fabsf(min[k]+max[k])))*local_opacity,</a>
<a name="ln872">                                min[k], max[k]);</a>
<a name="ln873">    }</a>
<a name="ln874">  }</a>
<a name="ln875">  /*</a>
<a name="ln876">  float max,min;</a>
<a name="ln877">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln878">  return ((a+b&lt;max) ? 0:(b+a-max));</a>
<a name="ln879">  */</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">/* difference (deprecated) */</a>
<a name="ln883">static void _blend_difference(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln884">                              int flag)</a>
<a name="ln885">{</a>
<a name="ln886">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln887">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln888"> </a>
<a name="ln889">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln890">  {</a>
<a name="ln891">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln892">    {</a>
<a name="ln893">      float local_opacity = mask[i];</a>
<a name="ln894">      float ta[3], tb[3];</a>
<a name="ln895">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln896">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln897">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln898">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln899">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln900">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln901"> </a>
<a name="ln902">      tb[0] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln903">              - fabsf(min[0]);</a>
<a name="ln904"> </a>
<a name="ln905">      if(flag == 0)</a>
<a name="ln906">      {</a>
<a name="ln907">        lmax = max[1] + fabsf(min[1]);</a>
<a name="ln908">        la =clamp_range_f(ta[1]+fabsf(min[1]), lmin, lmax);</a>
<a name="ln909">        lb =clamp_range_f(tb[1]+fabsf(min[1]), lmin, lmax);</a>
<a name="ln910">        tb[1] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln911">                - fabsf(min[1]);</a>
<a name="ln912">        lmax = max[2] + fabsf(min[2]);</a>
<a name="ln913">        la =clamp_range_f(ta[2]+fabsf(min[2]), lmin, lmax);</a>
<a name="ln914">        lb =clamp_range_f(tb[2]+fabsf(min[2]), lmin, lmax);</a>
<a name="ln915">        tb[2] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln916">                - fabsf(min[2]);</a>
<a name="ln917">      }</a>
<a name="ln918">      else</a>
<a name="ln919">      {</a>
<a name="ln920">        tb[1] = ta[1];</a>
<a name="ln921">        tb[2] = ta[2];</a>
<a name="ln922">      }</a>
<a name="ln923"> </a>
<a name="ln924">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln925">      b[j + 3] = local_opacity;</a>
<a name="ln926">    }</a>
<a name="ln927">  }</a>
<a name="ln928">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln929">  {</a>
<a name="ln930">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln931">    {</a>
<a name="ln932">      float local_opacity = mask[i];</a>
<a name="ln933">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln934">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln935">      {</a>
<a name="ln936">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln937">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln938">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln939"> </a>
<a name="ln940">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln941">                   - fabsf(min[k]);</a>
<a name="ln942">      }</a>
<a name="ln943">      b[j + 3] = local_opacity;</a>
<a name="ln944">    }</a>
<a name="ln945">  }</a>
<a name="ln946">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln947">  {</a>
<a name="ln948">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln949">    {</a>
<a name="ln950">      float local_opacity = mask[i];</a>
<a name="ln951">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln952">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln953">      {</a>
<a name="ln954">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln955">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln956">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln957"> </a>
<a name="ln958">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln959">                   - fabsf(min[k]);</a>
<a name="ln960">      }</a>
<a name="ln961">    }</a>
<a name="ln962">  }</a>
<a name="ln963">  // return fabsf(a-b);</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">/* difference 2 (new) */</a>
<a name="ln967">static void _blend_difference2(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln968">                               int flag)</a>
<a name="ln969">{</a>
<a name="ln970">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln971">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln972"> </a>
<a name="ln973">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln974">  {</a>
<a name="ln975">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln976">    {</a>
<a name="ln977">      float local_opacity = mask[i];</a>
<a name="ln978">      float ta[3], tb[3];</a>
<a name="ln979">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln980">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln981"> </a>
<a name="ln982">      tb[0] = fabsf(ta[0] - tb[0]) / fabsf(max[0] - min[0]);</a>
<a name="ln983">      tb[1] = fabsf(ta[1] - tb[1]) / fabsf(max[1] - min[1]);</a>
<a name="ln984">      tb[2] = fabsf(ta[2] - tb[2]) / fabsf(max[2] - min[2]);</a>
<a name="ln985">      tb[0] = fmaxf(tb[0], fmaxf(tb[1], tb[2]));</a>
<a name="ln986"> </a>
<a name="ln987">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+tb[0]*local_opacity, min[0], max[0]);</a>
<a name="ln988"> </a>
<a name="ln989">      if(flag == 0)</a>
<a name="ln990">      {</a>
<a name="ln991">        tb[1] = 0.0f;</a>
<a name="ln992">        tb[2] = 0.0f;</a>
<a name="ln993">      }</a>
<a name="ln994">      else</a>
<a name="ln995">      {</a>
<a name="ln996">        tb[1] = ta[1];</a>
<a name="ln997">        tb[2] = ta[2];</a>
<a name="ln998">      }</a>
<a name="ln999"> </a>
<a name="ln1000">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1001">      b[j + 3] = local_opacity;</a>
<a name="ln1002">    }</a>
<a name="ln1003">  }</a>
<a name="ln1004">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1005">  {</a>
<a name="ln1006">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1007">    {</a>
<a name="ln1008">      float local_opacity = mask[i];</a>
<a name="ln1009">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1010">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1011">      {</a>
<a name="ln1012">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1013">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1014">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1015"> </a>
<a name="ln1016">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln1017">                   - fabsf(min[k]);</a>
<a name="ln1018">      }</a>
<a name="ln1019"> </a>
<a name="ln1020">      b[j + 3] = local_opacity;</a>
<a name="ln1021">    }</a>
<a name="ln1022">  }</a>
<a name="ln1023">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1024">  {</a>
<a name="ln1025">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1026">    {</a>
<a name="ln1027">      float local_opacity = mask[i];</a>
<a name="ln1028">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1029">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1030">      {</a>
<a name="ln1031">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1032">        la = a[j + k] + fabsf(min[k]);</a>
<a name="ln1033">        lb = b[j + k] + fabsf(min[k]);</a>
<a name="ln1034"> </a>
<a name="ln1035">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity)+fabsf(la-lb)*local_opacity, lmin, lmax)</a>
<a name="ln1036">                   - fabsf(min[k]);</a>
<a name="ln1037">      }</a>
<a name="ln1038">    }</a>
<a name="ln1039">  }</a>
<a name="ln1040">  // return fabsf(a-b);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">/* screen */</a>
<a name="ln1044">static void _blend_screen(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1045">                          int flag)</a>
<a name="ln1046">{</a>
<a name="ln1047">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1048">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1049"> </a>
<a name="ln1050">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1051">  {</a>
<a name="ln1052">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1053">    {</a>
<a name="ln1054">      float local_opacity = mask[i];</a>
<a name="ln1055">      float ta[3], tb[3];</a>
<a name="ln1056">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1057">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1058">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1059">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1060">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1061">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1062"> </a>
<a name="ln1063">      tb[0] =clamp_range_f(la*(1.0f-local_opacity)+((lmax-(lmax-la)*(lmax-lb)))*local_opacity,</a>
<a name="ln1064">                           lmin, lmax)</a>
<a name="ln1065">              - fabsf(min[0]);</a>
<a name="ln1066"> </a>
<a name="ln1067">      if(flag == 0)</a>
<a name="ln1068">      {</a>
<a name="ln1069">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1070">        {</a>
<a name="ln1071">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity)</a>
<a name="ln1072">                               +0.5f*(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity,</a>
<a name="ln1073">                               min[1], max[1]);</a>
<a name="ln1074">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity)</a>
<a name="ln1075">                               +0.5f*(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity,</a>
<a name="ln1076">                               min[2], max[2]);</a>
<a name="ln1077">        }</a>
<a name="ln1078">        else</a>
<a name="ln1079">        {</a>
<a name="ln1080">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity)</a>
<a name="ln1081">                               +0.5f*(ta[1]+tb[1])*tb[0]/0.01f*local_opacity,</a>
<a name="ln1082">                               min[1], max[1]);</a>
<a name="ln1083">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity)</a>
<a name="ln1084">                               +0.5f*(ta[2]+tb[2])*tb[0]/0.01f*local_opacity,</a>
<a name="ln1085">                               min[2], max[2]);</a>
<a name="ln1086">        }</a>
<a name="ln1087">      }</a>
<a name="ln1088">      else</a>
<a name="ln1089">      {</a>
<a name="ln1090">        tb[1] = ta[1];</a>
<a name="ln1091">        tb[2] = ta[2];</a>
<a name="ln1092">      }</a>
<a name="ln1093"> </a>
<a name="ln1094">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1095">      b[j + 3] = local_opacity;</a>
<a name="ln1096">    }</a>
<a name="ln1097">  }</a>
<a name="ln1098">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1099">  {</a>
<a name="ln1100">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1101">    {</a>
<a name="ln1102">      float local_opacity = mask[i];</a>
<a name="ln1103">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1104">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1105">      {</a>
<a name="ln1106">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1107">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1108">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1109"> </a>
<a name="ln1110">        b[j + k]</a>
<a name="ln1111">            =clamp_range_f(la*(1.0f-local_opacity)+(lmax-(lmax-la)*(lmax-lb))*local_opacity,</a>
<a name="ln1112">                           lmin, lmax)</a>
<a name="ln1113">              - fabsf(min[k]);</a>
<a name="ln1114">      }</a>
<a name="ln1115">      b[j + 3] = local_opacity;</a>
<a name="ln1116">    }</a>
<a name="ln1117">  }</a>
<a name="ln1118">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1119">  {</a>
<a name="ln1120">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1121">    {</a>
<a name="ln1122">      float local_opacity = mask[i];</a>
<a name="ln1123">      float lmin = 0.0f, lmax, la, lb;</a>
<a name="ln1124">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1125">      {</a>
<a name="ln1126">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1127">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1128">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1129"> </a>
<a name="ln1130">        b[j + k]</a>
<a name="ln1131">            =clamp_range_f(la*(1.0f-local_opacity)+(lmax-(lmax-la)*(lmax-lb))*local_opacity,</a>
<a name="ln1132">                           lmin, lmax)</a>
<a name="ln1133">              - fabsf(min[k]);</a>
<a name="ln1134">      }</a>
<a name="ln1135">    }</a>
<a name="ln1136">  }</a>
<a name="ln1137">  /*</a>
<a name="ln1138">  float max,min;</a>
<a name="ln1139">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1140">  return max - (max-a) * (max-b);</a>
<a name="ln1141">  */</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">/* overlay */</a>
<a name="ln1145">static void _blend_overlay(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1146">                           int flag)</a>
<a name="ln1147">{</a>
<a name="ln1148">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1149">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1150"> </a>
<a name="ln1151">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1152">  {</a>
<a name="ln1153">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1154">    {</a>
<a name="ln1155">      float local_opacity = mask[i];</a>
<a name="ln1156">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1157">      float ta[3], tb[3];</a>
<a name="ln1158">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1159">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1160">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1161">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1162">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1163">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1164">      halfmax = lmax / 2.0f;</a>
<a name="ln1165">      doublemax = lmax * 2.0f;</a>
<a name="ln1166"> </a>
<a name="ln1167">      tb[0] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1168">                           +(la&gt;halfmax ? lmax-(lmax-doublemax*(la-halfmax))*(lmax-lb)</a>
<a name="ln1169">                                        : (doublemax*la)*lb)</a>
<a name="ln1170">                            *local_opacity2,</a>
<a name="ln1171">                           lmin, lmax)</a>
<a name="ln1172">              - fabsf(min[0]);</a>
<a name="ln1173"> </a>
<a name="ln1174">      if(flag == 0)</a>
<a name="ln1175">      {</a>
<a name="ln1176">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1177">        {</a>
<a name="ln1178">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1179">                               +(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1180">                               min[1], max[1]);</a>
<a name="ln1181">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1182">                               +(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1183">                               min[2], max[2]);</a>
<a name="ln1184">        }</a>
<a name="ln1185">        else</a>
<a name="ln1186">        {</a>
<a name="ln1187">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1188">                               +(ta[1]+tb[1])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1189">                               min[1], max[1]);</a>
<a name="ln1190">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1191">                               +(ta[2]+tb[2])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1192">                               min[2], max[2]);</a>
<a name="ln1193">        }</a>
<a name="ln1194">      }</a>
<a name="ln1195">      else</a>
<a name="ln1196">      {</a>
<a name="ln1197">        tb[1] = ta[1];</a>
<a name="ln1198">        tb[2] = ta[2];</a>
<a name="ln1199">      }</a>
<a name="ln1200"> </a>
<a name="ln1201">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1202">      b[j + 3] = local_opacity;</a>
<a name="ln1203">    }</a>
<a name="ln1204">  }</a>
<a name="ln1205">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1206">  {</a>
<a name="ln1207">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1208">    {</a>
<a name="ln1209">      float local_opacity = mask[i];</a>
<a name="ln1210">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1211">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1212">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1213">      {</a>
<a name="ln1214">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1215">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1216">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1217">        halfmax = lmax / 2.0f;</a>
<a name="ln1218">        doublemax = lmax * 2.0f;</a>
<a name="ln1219"> </a>
<a name="ln1220">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1221">                                +(la&gt;halfmax ? lmax-(lmax-doublemax*(la-halfmax))*(lmax-lb)</a>
<a name="ln1222">                                             : doublemax*la*lb)</a>
<a name="ln1223">                                 *local_opacity2,</a>
<a name="ln1224">                                lmin, lmax)</a>
<a name="ln1225">                   - fabsf(min[k]);</a>
<a name="ln1226">      }</a>
<a name="ln1227">      b[j + 3] = local_opacity;</a>
<a name="ln1228">    }</a>
<a name="ln1229">  }</a>
<a name="ln1230">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1231">  {</a>
<a name="ln1232">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1233">    {</a>
<a name="ln1234">      float local_opacity = mask[i];</a>
<a name="ln1235">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1236">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1237">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1238">      {</a>
<a name="ln1239">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1240">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1241">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1242">        halfmax = lmax / 2.0f;</a>
<a name="ln1243">        doublemax = lmax * 2.0f;</a>
<a name="ln1244"> </a>
<a name="ln1245">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1246">                                +(la&gt;halfmax ? lmax-(lmax-doublemax*(la-halfmax))*(lmax-lb)</a>
<a name="ln1247">                                             : doublemax*la*lb)</a>
<a name="ln1248">                                 *local_opacity2,</a>
<a name="ln1249">                                lmin, lmax)</a>
<a name="ln1250">                   - fabsf(min[k]);</a>
<a name="ln1251">      }</a>
<a name="ln1252">    }</a>
<a name="ln1253">  }</a>
<a name="ln1254">  /*</a>
<a name="ln1255">    float max,min;</a>
<a name="ln1256">    _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1257">    const float halfmax=max/2.0;</a>
<a name="ln1258">    const float doublemax=max*2.0;</a>
<a name="ln1259">    return (a&gt;halfmax) ? max - (max - doublemax*(a-halfmax)) * (max-b) :</a>
<a name="ln1260">    (doublemax*a) * b;</a>
<a name="ln1261">    */</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/* softlight */</a>
<a name="ln1265">static void _blend_softlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1266">                             int flag)</a>
<a name="ln1267">{</a>
<a name="ln1268"> </a>
<a name="ln1269">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1270">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1271"> </a>
<a name="ln1272">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1273">  {</a>
<a name="ln1274">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1275">    {</a>
<a name="ln1276">      float local_opacity = mask[i];</a>
<a name="ln1277">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1278">      float ta[3], tb[3];</a>
<a name="ln1279">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1280">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1281">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1282">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1283">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1284">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1285">      halfmax = lmax / 2.0f;</a>
<a name="ln1286"> </a>
<a name="ln1287">      tb[0] =clamp_range_f(</a>
<a name="ln1288">          la*(1.0f-local_opacity2)</a>
<a name="ln1289">          +(lb&gt;halfmax ? lmax-(lmax-la)*(lmax-(lb-halfmax)) : la*(lb+halfmax))</a>
<a name="ln1290">           *local_opacity2,</a>
<a name="ln1291">          lmin, lmax)</a>
<a name="ln1292">              - fabsf(min[0]);</a>
<a name="ln1293"> </a>
<a name="ln1294">      if(flag == 0)</a>
<a name="ln1295">      {</a>
<a name="ln1296">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1297">        {</a>
<a name="ln1298">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1299">                               +(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1300">                               min[1], max[1]);</a>
<a name="ln1301">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1302">                               +(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1303">                               min[2], max[2]);</a>
<a name="ln1304">        }</a>
<a name="ln1305">        else</a>
<a name="ln1306">        {</a>
<a name="ln1307">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1308">                               +(ta[1]+tb[1])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1309">                               min[1], max[1]);</a>
<a name="ln1310">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1311">                               +(ta[2]+tb[2])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1312">                               min[2], max[2]);</a>
<a name="ln1313">        }</a>
<a name="ln1314">      }</a>
<a name="ln1315">      else</a>
<a name="ln1316">      {</a>
<a name="ln1317">        tb[1] = ta[1];</a>
<a name="ln1318">        tb[2] = ta[2];</a>
<a name="ln1319">      }</a>
<a name="ln1320"> </a>
<a name="ln1321">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1322">      b[j + 3] = local_opacity;</a>
<a name="ln1323">    }</a>
<a name="ln1324">  }</a>
<a name="ln1325">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1326">  {</a>
<a name="ln1327">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1328">    {</a>
<a name="ln1329">      float local_opacity = mask[i];</a>
<a name="ln1330">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1331">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1332">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1333">      {</a>
<a name="ln1334">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1335">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1336">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1337">        halfmax = lmax / 2.0f;</a>
<a name="ln1338"> </a>
<a name="ln1339">        b[j + k] =clamp_range_f(</a>
<a name="ln1340">            la*(1.0f-local_opacity2)</a>
<a name="ln1341">            +(lb&gt;halfmax ? lmax-(lmax-la)*(lmax-(lb-halfmax)) : la*(lb+halfmax))</a>
<a name="ln1342">             *local_opacity2,</a>
<a name="ln1343">            lmin, lmax)</a>
<a name="ln1344">                   - fabsf(min[k]);</a>
<a name="ln1345"> </a>
<a name="ln1346">        b[j + 3] = local_opacity;</a>
<a name="ln1347">      }</a>
<a name="ln1348">    }</a>
<a name="ln1349">  }</a>
<a name="ln1350">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1351">  {</a>
<a name="ln1352">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1353">    {</a>
<a name="ln1354">      float local_opacity = mask[i];</a>
<a name="ln1355">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1356">      float lmin = 0.0f, lmax, la, lb, halfmax;</a>
<a name="ln1357">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1358">      {</a>
<a name="ln1359">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1360">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1361">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1362">        halfmax = lmax / 2.0f;</a>
<a name="ln1363"> </a>
<a name="ln1364">        b[j + k] =clamp_range_f(</a>
<a name="ln1365">            la*(1.0f-local_opacity2)</a>
<a name="ln1366">            +(lb&gt;halfmax ? lmax-(lmax-la)*(lmax-(lb-halfmax)) : la*(lb+halfmax))</a>
<a name="ln1367">             *local_opacity2,</a>
<a name="ln1368">            lmin, lmax)</a>
<a name="ln1369">                   - fabsf(min[k]);</a>
<a name="ln1370">      }</a>
<a name="ln1371">    }</a>
<a name="ln1372">  }</a>
<a name="ln1373">  /*</a>
<a name="ln1374">  float max,min;</a>
<a name="ln1375">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1376">  const float halfmax=max/2.0;</a>
<a name="ln1377">  return (b&gt;halfmax) ? max - (max-a) * (max - (b-halfmax)) : a * (b+halfmax);</a>
<a name="ln1378">  */</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381">/* hardlight */</a>
<a name="ln1382">static void _blend_hardlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1383">                             int flag)</a>
<a name="ln1384">{</a>
<a name="ln1385">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1386">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1387"> </a>
<a name="ln1388">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1389">  {</a>
<a name="ln1390">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1391">    {</a>
<a name="ln1392">      float local_opacity = mask[i];</a>
<a name="ln1393">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1394">      float ta[3], tb[3];</a>
<a name="ln1395">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1396">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1397">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1398">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1399">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1400">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1401">      halfmax = lmax / 2.0f;</a>
<a name="ln1402">      doublemax = lmax * 2.0f;</a>
<a name="ln1403"> </a>
<a name="ln1404">      tb[0] =clamp_range_f((la*(1.0f-local_opacity2))</a>
<a name="ln1405">                           +(lb&gt;halfmax ? lmax-(lmax-doublemax*(la-halfmax))*(lmax-lb)</a>
<a name="ln1406">                                        : doublemax*la*lb)</a>
<a name="ln1407">                            *local_opacity2,</a>
<a name="ln1408">                           lmin, lmax)</a>
<a name="ln1409">              - fabsf(min[0]);</a>
<a name="ln1410"> </a>
<a name="ln1411">      if(flag == 0)</a>
<a name="ln1412">      {</a>
<a name="ln1413">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1414">        {</a>
<a name="ln1415">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1416">                               +(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1417">                               min[1], max[1]);</a>
<a name="ln1418">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1419">                               +(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1420">                               min[2], max[2]);</a>
<a name="ln1421">        }</a>
<a name="ln1422">        else</a>
<a name="ln1423">        {</a>
<a name="ln1424">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1425">                               +(ta[1]+tb[1])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1426">                               min[1], max[1]);</a>
<a name="ln1427">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1428">                               +(ta[2]+tb[2])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1429">                               min[2], max[2]);</a>
<a name="ln1430">        }</a>
<a name="ln1431">      }</a>
<a name="ln1432">      else</a>
<a name="ln1433">      {</a>
<a name="ln1434">        tb[1] = ta[1];</a>
<a name="ln1435">        tb[2] = ta[2];</a>
<a name="ln1436">      }</a>
<a name="ln1437"> </a>
<a name="ln1438">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1439">      b[j + 3] = local_opacity;</a>
<a name="ln1440">    }</a>
<a name="ln1441">  }</a>
<a name="ln1442">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1443">  {</a>
<a name="ln1444">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1445">    {</a>
<a name="ln1446">      float local_opacity = mask[i];</a>
<a name="ln1447">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1448">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1449">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1450">      {</a>
<a name="ln1451">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1452">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1453">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1454">        halfmax = lmax / 2.0f;</a>
<a name="ln1455">        doublemax = lmax * 2.0f;</a>
<a name="ln1456"> </a>
<a name="ln1457">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1458">                                +(lb&gt;halfmax ? lmax-(lmax-doublemax*(la-halfmax))*(lmax-lb)</a>
<a name="ln1459">                                             : doublemax*la*lb)</a>
<a name="ln1460">                                 *local_opacity2,</a>
<a name="ln1461">                                lmin, lmax)</a>
<a name="ln1462">                   - fabsf(min[k]);</a>
<a name="ln1463">      }</a>
<a name="ln1464">      b[j + 3] = local_opacity;</a>
<a name="ln1465">    }</a>
<a name="ln1466">  }</a>
<a name="ln1467">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1468">  {</a>
<a name="ln1469">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1470">    {</a>
<a name="ln1471">      float local_opacity = mask[i];</a>
<a name="ln1472">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1473">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1474">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1475">      {</a>
<a name="ln1476">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1477">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1478">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1479">        halfmax = lmax / 2.0f;</a>
<a name="ln1480">        doublemax = lmax * 2.0f;</a>
<a name="ln1481"> </a>
<a name="ln1482">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1483">                                +(lb&gt;halfmax ? lmax-(lmax-doublemax*(la-halfmax))*(lmax-lb)</a>
<a name="ln1484">                                             : doublemax*la*lb)</a>
<a name="ln1485">                                 *local_opacity2,</a>
<a name="ln1486">                                lmin, lmax)</a>
<a name="ln1487">                   - fabsf(min[k]);</a>
<a name="ln1488">      }</a>
<a name="ln1489">    }</a>
<a name="ln1490">  }</a>
<a name="ln1491">  /*</a>
<a name="ln1492">  float max,min;</a>
<a name="ln1493">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1494">  const float halfmax=max/2.0;</a>
<a name="ln1495">  const float doublemax=max*2.0;</a>
<a name="ln1496">  return (b&gt;halfmax) ? max - (max - doublemax*(a-halfmax)) * (max-b) :</a>
<a name="ln1497">  (doublemax*a) * b;</a>
<a name="ln1498">  */</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/* vividlight */</a>
<a name="ln1502">static void _blend_vividlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1503">                              int flag)</a>
<a name="ln1504">{</a>
<a name="ln1505">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1506">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1507"> </a>
<a name="ln1508">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1509">  {</a>
<a name="ln1510">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1511">    {</a>
<a name="ln1512">      float local_opacity = mask[i];</a>
<a name="ln1513">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1514">      float ta[3], tb[3];</a>
<a name="ln1515">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1516">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1517">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1518">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1519">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1520">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1521">      halfmax = lmax / 2.0f;</a>
<a name="ln1522">      doublemax = lmax * 2.0f;</a>
<a name="ln1523"> </a>
<a name="ln1524">      tb[0] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1525">                           +(lb&gt;halfmax ? (lb&gt;=lmax ? lmax : la/(doublemax*(lmax-lb)))</a>
<a name="ln1526">                                        : (lb&lt;=lmin ? lmin : lmax-(lmax-la)/(doublemax*lb)))</a>
<a name="ln1527">                            *local_opacity2,</a>
<a name="ln1528">                           lmin, lmax)</a>
<a name="ln1529">              - fabsf(min[0]);</a>
<a name="ln1530"> </a>
<a name="ln1531">      if(flag == 0)</a>
<a name="ln1532">      {</a>
<a name="ln1533">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1534">        {</a>
<a name="ln1535">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1536">                               +(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1537">                               min[1], max[1]);</a>
<a name="ln1538">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1539">                               +(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1540">                               min[2], max[2]);</a>
<a name="ln1541">        }</a>
<a name="ln1542">        else</a>
<a name="ln1543">        {</a>
<a name="ln1544">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1545">                               +(ta[1]+tb[1])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1546">                               min[1], max[1]);</a>
<a name="ln1547">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1548">                               +(ta[2]+tb[2])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1549">                               min[2], max[2]);</a>
<a name="ln1550">        }</a>
<a name="ln1551">      }</a>
<a name="ln1552">      else</a>
<a name="ln1553">      {</a>
<a name="ln1554">        tb[1] = ta[1];</a>
<a name="ln1555">        tb[2] = ta[2];</a>
<a name="ln1556">      }</a>
<a name="ln1557"> </a>
<a name="ln1558">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1559">      b[j + 3] = local_opacity;</a>
<a name="ln1560">    }</a>
<a name="ln1561">  }</a>
<a name="ln1562">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1563">  {</a>
<a name="ln1564">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1565">    {</a>
<a name="ln1566">      float local_opacity = mask[i];</a>
<a name="ln1567">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1568">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1569">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1570">      {</a>
<a name="ln1571">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1572">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1573">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1574">        halfmax = lmax / 2.0f;</a>
<a name="ln1575">        doublemax = lmax * 2.0f;</a>
<a name="ln1576"> </a>
<a name="ln1577">        b[j + k] =clamp_range_f((la*(1.0f-local_opacity2))</a>
<a name="ln1578">                                +(lb&gt;halfmax ? (lb&gt;=lmax ? lmax : la/(doublemax*(lmax-lb)))</a>
<a name="ln1579">                                             : (lb&lt;=lmin ? lmin : lmax-(lmax-la)/(doublemax*lb)))</a>
<a name="ln1580">                                 *local_opacity2,</a>
<a name="ln1581">                                lmin, lmax)</a>
<a name="ln1582">                   - fabsf(min[k]);</a>
<a name="ln1583">      }</a>
<a name="ln1584">      b[j + 3] = local_opacity;</a>
<a name="ln1585">    }</a>
<a name="ln1586">  }</a>
<a name="ln1587">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1588">  {</a>
<a name="ln1589">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1590">    {</a>
<a name="ln1591">      float local_opacity = mask[i];</a>
<a name="ln1592">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1593">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1594">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1595">      {</a>
<a name="ln1596">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1597">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1598">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1599">        halfmax = lmax / 2.0f;</a>
<a name="ln1600">        doublemax = lmax * 2.0f;</a>
<a name="ln1601"> </a>
<a name="ln1602">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1603">                                +(lb&gt;halfmax ? (lb&gt;=lmax ? lmax : la/(doublemax*(lmax-lb)))</a>
<a name="ln1604">                                             : (lb&lt;=lmin ? lmin : lmax-(lmax-la)/(doublemax*lb)))</a>
<a name="ln1605">                                 *local_opacity2,</a>
<a name="ln1606">                                lmin, lmax)</a>
<a name="ln1607">                   - fabsf(min[k]);</a>
<a name="ln1608">      }</a>
<a name="ln1609">    }</a>
<a name="ln1610">  }</a>
<a name="ln1611">  /*</a>
<a name="ln1612">  float max,min;</a>
<a name="ln1613">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1614">  const float halfmax=max/2.0;</a>
<a name="ln1615">  const float doublemax=max*2.0;</a>
<a name="ln1616">  return (b&gt;halfmax) ? a / (doublemax*(max-b)) : max - (max-a) / (doublemax*b);</a>
<a name="ln1617">  */</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">/* linearlight */</a>
<a name="ln1621">static void _blend_linearlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1622">                               int flag)</a>
<a name="ln1623">{</a>
<a name="ln1624">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1625">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1626"> </a>
<a name="ln1627">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1628">  {</a>
<a name="ln1629">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1630">    {</a>
<a name="ln1631">      float local_opacity = mask[i];</a>
<a name="ln1632">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1633">      float ta[3], tb[3];</a>
<a name="ln1634">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1635">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1636">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1637">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1638">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1639">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1640">      doublemax = lmax * 2.0f;</a>
<a name="ln1641"> </a>
<a name="ln1642">      tb[0] =clamp_range_f(la*(1.0f-local_opacity2)+(la+doublemax*lb-lmax)*local_opacity2, lmin,</a>
<a name="ln1643">                           lmax)</a>
<a name="ln1644">              - fabsf(min[0]);</a>
<a name="ln1645"> </a>
<a name="ln1646">      if(flag == 0)</a>
<a name="ln1647">      {</a>
<a name="ln1648">        if(ta[0] &gt; 0.01f)</a>
<a name="ln1649">        {</a>
<a name="ln1650">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1651">                               +(ta[1]+tb[1])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1652">                               min[1], max[1]);</a>
<a name="ln1653">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1654">                               +(ta[2]+tb[2])*tb[0]/ta[0]*local_opacity2,</a>
<a name="ln1655">                               min[2], max[2]);</a>
<a name="ln1656">        }</a>
<a name="ln1657">        else</a>
<a name="ln1658">        {</a>
<a name="ln1659">          tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity2)</a>
<a name="ln1660">                               +(ta[1]+tb[1])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1661">                               min[1], max[1]);</a>
<a name="ln1662">          tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity2)</a>
<a name="ln1663">                               +(ta[2]+tb[2])*tb[0]/0.01f*local_opacity2,</a>
<a name="ln1664">                               min[2], max[2]);</a>
<a name="ln1665">        }</a>
<a name="ln1666">      }</a>
<a name="ln1667">      else</a>
<a name="ln1668">      {</a>
<a name="ln1669">        tb[1] = ta[1];</a>
<a name="ln1670">        tb[2] = ta[2];</a>
<a name="ln1671">      }</a>
<a name="ln1672"> </a>
<a name="ln1673">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1674">      b[j + 3] = local_opacity;</a>
<a name="ln1675">    }</a>
<a name="ln1676">  }</a>
<a name="ln1677">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1678">  {</a>
<a name="ln1679">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1680">    {</a>
<a name="ln1681">      float local_opacity = mask[i];</a>
<a name="ln1682">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1683">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1684">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1685">      {</a>
<a name="ln1686">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1687">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1688">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1689">        doublemax = lmax * 2.0f;</a>
<a name="ln1690"> </a>
<a name="ln1691">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)+(la+doublemax*lb-lmax)*local_opacity2,</a>
<a name="ln1692">                                lmin, lmax)</a>
<a name="ln1693">                   - fabsf(min[k]);</a>
<a name="ln1694">      }</a>
<a name="ln1695">      b[j + 3] = local_opacity;</a>
<a name="ln1696">    }</a>
<a name="ln1697">  }</a>
<a name="ln1698">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1699">  {</a>
<a name="ln1700">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1701">    {</a>
<a name="ln1702">      float local_opacity = mask[i];</a>
<a name="ln1703">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1704">      float lmin = 0.0f, lmax, la, lb, doublemax;</a>
<a name="ln1705">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1706">      {</a>
<a name="ln1707">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1708">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1709">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1710">        doublemax = lmax * 2.0f;</a>
<a name="ln1711"> </a>
<a name="ln1712">        b[j + k] =clamp_range_f(la*(1.0f-local_opacity2)+(la+doublemax*lb-lmax)*local_opacity2,</a>
<a name="ln1713">                                lmin, lmax)</a>
<a name="ln1714">                   - fabsf(min[k]);</a>
<a name="ln1715">      }</a>
<a name="ln1716">    }</a>
<a name="ln1717">  }</a>
<a name="ln1718">  /*</a>
<a name="ln1719">  float max,min;</a>
<a name="ln1720">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1721">  const float halfmax=max/2.0;</a>
<a name="ln1722">  const float doublemax=max*2.0;</a>
<a name="ln1723">  return a +doublemax*b-max;</a>
<a name="ln1724">  */</a>
<a name="ln1725">}</a>
<a name="ln1726"> </a>
<a name="ln1727">/* pinlight */</a>
<a name="ln1728">static void _blend_pinlight(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1729">                            int flag)</a>
<a name="ln1730">{</a>
<a name="ln1731">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1732">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1733"> </a>
<a name="ln1734">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1735">  {</a>
<a name="ln1736">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1737">    {</a>
<a name="ln1738">      float local_opacity = mask[i];</a>
<a name="ln1739">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1740">      float ta[3], tb[3];</a>
<a name="ln1741">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1742">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1743">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1744">      lmax = max[0] + fabsf(min[0]);</a>
<a name="ln1745">      la =clamp_range_f(ta[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1746">      lb =clamp_range_f(tb[0]+fabsf(min[0]), lmin, lmax);</a>
<a name="ln1747">      halfmax = lmax / 2.0f;</a>
<a name="ln1748">      doublemax = lmax * 2.0f;</a>
<a name="ln1749"> </a>
<a name="ln1750">      tb[0]</a>
<a name="ln1751">          =clamp_range_f(la*(1.0f-local_opacity2)</a>
<a name="ln1752">                         +(lb&gt;halfmax ? fmaxf(la, doublemax*(lb-halfmax)) : fminf(la, doublemax*lb))</a>
<a name="ln1753">                          *local_opacity2,</a>
<a name="ln1754">                         lmin, lmax)</a>
<a name="ln1755">            - fabsf(min[0]);</a>
<a name="ln1756"> </a>
<a name="ln1757">      tb[1] =clamp_range_f(ta[1], min[1], max[1]);</a>
<a name="ln1758">      tb[2] =clamp_range_f(ta[2], min[2], max[2]);</a>
<a name="ln1759"> </a>
<a name="ln1760">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1761">      b[j + 3] = local_opacity;</a>
<a name="ln1762">    }</a>
<a name="ln1763">  }</a>
<a name="ln1764">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1765">  {</a>
<a name="ln1766">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1767">    {</a>
<a name="ln1768">      float local_opacity = mask[i];</a>
<a name="ln1769">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1770">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1771">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1772">      {</a>
<a name="ln1773">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1774">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1775">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1776">        halfmax = lmax / 2.0f;</a>
<a name="ln1777">        doublemax = lmax * 2.0f;</a>
<a name="ln1778"> </a>
<a name="ln1779">        b[j + k] =clamp_range_f(</a>
<a name="ln1780">            (la*(1.0f-local_opacity2))</a>
<a name="ln1781">            +(lb&gt;halfmax ? fmaxf(la, doublemax*(lb-halfmax)) : fminf(la, doublemax*lb))</a>
<a name="ln1782">             *local_opacity2,</a>
<a name="ln1783">            lmin, lmax)</a>
<a name="ln1784">                   - fabsf(min[k]);</a>
<a name="ln1785">      }</a>
<a name="ln1786">      b[j + 3] = local_opacity;</a>
<a name="ln1787">    }</a>
<a name="ln1788">  }</a>
<a name="ln1789">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1790">  {</a>
<a name="ln1791">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1792">    {</a>
<a name="ln1793">      float local_opacity = mask[i];</a>
<a name="ln1794">      float local_opacity2 = local_opacity * local_opacity;</a>
<a name="ln1795">      float lmin = 0.0f, lmax, la, lb, halfmax, doublemax;</a>
<a name="ln1796">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln1797">      {</a>
<a name="ln1798">        lmax = max[k] + fabsf(min[k]);</a>
<a name="ln1799">        la =clamp_range_f(a[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1800">        lb =clamp_range_f(b[j+k]+fabsf(min[k]), lmin, lmax);</a>
<a name="ln1801">        halfmax = lmax / 2.0f;</a>
<a name="ln1802">        doublemax = lmax * 2.0f;</a>
<a name="ln1803"> </a>
<a name="ln1804">        b[j + k] =clamp_range_f(</a>
<a name="ln1805">            (la*(1.0f-local_opacity2)</a>
<a name="ln1806">             +(lb&gt;halfmax ? fmaxf(la, doublemax*(lb-halfmax)) : fminf(la, doublemax*lb))</a>
<a name="ln1807">              *local_opacity2),</a>
<a name="ln1808">            lmin, lmax)</a>
<a name="ln1809">                   - fabsf(min[k]);</a>
<a name="ln1810">      }</a>
<a name="ln1811">    }</a>
<a name="ln1812">  }</a>
<a name="ln1813">  /*</a>
<a name="ln1814">  float max,min;</a>
<a name="ln1815">  _blend_colorspace_channel_range(cst,channel,&amp;min,&amp;max);</a>
<a name="ln1816">  const float halfmax=max/2.0;</a>
<a name="ln1817">  const float doublemax=max*2.0;</a>
<a name="ln1818">  return (b&gt;halfmax) ? fmaxf(a,doublemax*(b-halfmax)) : fminf(a,doublemax*b);</a>
<a name="ln1819">  */</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">/* lightness blend */</a>
<a name="ln1823">static void _blend_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1824">                             int flag)</a>
<a name="ln1825">{</a>
<a name="ln1826">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1827">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1828"> </a>
<a name="ln1829">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1830">  {</a>
<a name="ln1831">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1832">    {</a>
<a name="ln1833">      float local_opacity = mask[i];</a>
<a name="ln1834">      float ta[3], tb[3];</a>
<a name="ln1835">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1836">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1837"> </a>
<a name="ln1838">      // no need to transfer to LCH as L is the same as in Lab, and C and H</a>
<a name="ln1839">      // remain unchanged</a>
<a name="ln1840">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+tb[0]*local_opacity, min[0], max[0]);</a>
<a name="ln1841">      tb[1] =clamp_range_f(ta[1], min[1], max[1]);</a>
<a name="ln1842">      tb[2] =clamp_range_f(ta[2], min[2], max[2]);</a>
<a name="ln1843"> </a>
<a name="ln1844">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1845">      b[j + 3] = local_opacity;</a>
<a name="ln1846">    }</a>
<a name="ln1847">  }</a>
<a name="ln1848">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1849">  {</a>
<a name="ln1850">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1851">    {</a>
<a name="ln1852">      float local_opacity = mask[i];</a>
<a name="ln1853">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1854">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1855"> </a>
<a name="ln1856">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1857">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1858"> </a>
<a name="ln1859">      dt_RGB_2_HSL(ta, tta);</a>
<a name="ln1860">      dt_RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1861"> </a>
<a name="ln1862">      ttb[0] = tta[0];</a>
<a name="ln1863">      ttb[1] = tta[1];</a>
<a name="ln1864">      ttb[2] = (tta[2] * (1.0f - local_opacity)) + ttb[2] * local_opacity;</a>
<a name="ln1865"> </a>
<a name="ln1866">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1867">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1868"> </a>
<a name="ln1869">      b[j + 3] = local_opacity;</a>
<a name="ln1870">    }</a>
<a name="ln1871">  }</a>
<a name="ln1872">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1873">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876">/* chroma blend */</a>
<a name="ln1877">static void _blend_chroma(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln1878">                          int flag)</a>
<a name="ln1879">{</a>
<a name="ln1880">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1881">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1882"> </a>
<a name="ln1883">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1884">  {</a>
<a name="ln1885">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1886">    {</a>
<a name="ln1887">      float local_opacity = mask[i];</a>
<a name="ln1888">      float ta[3], tb[3];</a>
<a name="ln1889">      float tta[3], ttb[3];</a>
<a name="ln1890">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1891">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1892">      dt_Lab_2_LCH(ta, tta);</a>
<a name="ln1893"> </a>
<a name="ln1894">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1895">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1896">      dt_Lab_2_LCH(tb, ttb);</a>
<a name="ln1897"> </a>
<a name="ln1898">      ttb[0] = tta[0];</a>
<a name="ln1899">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln1900">      ttb[2] = tta[2];</a>
<a name="ln1901"> </a>
<a name="ln1902">      dt_LCH_2_Lab(ttb, tb);</a>
<a name="ln1903">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1904">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1905"> </a>
<a name="ln1906">      b[j + 3] = local_opacity;</a>
<a name="ln1907">    }</a>
<a name="ln1908">  }</a>
<a name="ln1909">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1910">  {</a>
<a name="ln1911">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1912">    {</a>
<a name="ln1913">      float local_opacity = mask[i];</a>
<a name="ln1914">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1915">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1916"> </a>
<a name="ln1917">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1918">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1919"> </a>
<a name="ln1920">      dt_RGB_2_HSL(ta, tta);</a>
<a name="ln1921">      dt_RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1922"> </a>
<a name="ln1923">      ttb[0] = tta[0];</a>
<a name="ln1924">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln1925">      ttb[2] = tta[2];</a>
<a name="ln1926"> </a>
<a name="ln1927">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1928">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1929"> </a>
<a name="ln1930">      b[j + 3] = local_opacity;</a>
<a name="ln1931">    }</a>
<a name="ln1932">  }</a>
<a name="ln1933">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln1934">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937">/* hue blend */</a>
<a name="ln1938">static void _blend_hue(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln1939">{</a>
<a name="ln1940">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln1941">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln1942"> </a>
<a name="ln1943">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln1944">  {</a>
<a name="ln1945">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1946">    {</a>
<a name="ln1947">      float local_opacity = mask[i];</a>
<a name="ln1948">      float ta[3], tb[3];</a>
<a name="ln1949">      float tta[3], ttb[3];</a>
<a name="ln1950">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln1951">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1952">      dt_Lab_2_LCH(ta, tta);</a>
<a name="ln1953"> </a>
<a name="ln1954">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln1955">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1956">      dt_Lab_2_LCH(tb, ttb);</a>
<a name="ln1957"> </a>
<a name="ln1958">      ttb[0] = tta[0];</a>
<a name="ln1959">      ttb[1] = tta[1];</a>
<a name="ln1960">      /* blend hue along shortest distance on color circle */</a>
<a name="ln1961">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln1962">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln1963">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln1964"> </a>
<a name="ln1965">      dt_LCH_2_Lab(ttb, tb);</a>
<a name="ln1966">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln1967">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln1968"> </a>
<a name="ln1969">      b[j + 3] = local_opacity;</a>
<a name="ln1970">    }</a>
<a name="ln1971">  }</a>
<a name="ln1972">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln1973">  {</a>
<a name="ln1974">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln1975">    {</a>
<a name="ln1976">      float local_opacity = mask[i];</a>
<a name="ln1977">      float ta[3], tta[3], ttb[3];</a>
<a name="ln1978">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln1979"> </a>
<a name="ln1980">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln1981">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1982"> </a>
<a name="ln1983">      dt_RGB_2_HSL(ta, tta);</a>
<a name="ln1984">      dt_RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln1985"> </a>
<a name="ln1986">      /* blend hue along shortest distance on color circle */</a>
<a name="ln1987">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln1988">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln1989">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln1990">      ttb[1] = tta[1];</a>
<a name="ln1991">      ttb[2] = tta[2];</a>
<a name="ln1992"> </a>
<a name="ln1993">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln1994">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln1995"> </a>
<a name="ln1996">      b[j + 3] = local_opacity;</a>
<a name="ln1997">    }</a>
<a name="ln1998">  }</a>
<a name="ln1999">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2000">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">/* color blend; blend hue and chroma, but not lightness */</a>
<a name="ln2004">static void _blend_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask, int flag)</a>
<a name="ln2005">{</a>
<a name="ln2006">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2007">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2008"> </a>
<a name="ln2009">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2010">  {</a>
<a name="ln2011">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2012">    {</a>
<a name="ln2013">      float local_opacity = mask[i];</a>
<a name="ln2014">      float ta[3], tb[3];</a>
<a name="ln2015">      float tta[3], ttb[3];</a>
<a name="ln2016">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2017">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2018">      dt_Lab_2_LCH(ta, tta);</a>
<a name="ln2019"> </a>
<a name="ln2020">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2021">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2022">      dt_Lab_2_LCH(tb, ttb);</a>
<a name="ln2023"> </a>
<a name="ln2024">      ttb[0] = tta[0];</a>
<a name="ln2025">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2026"> </a>
<a name="ln2027">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2028">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2029">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2030">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2031"> </a>
<a name="ln2032">      dt_LCH_2_Lab(ttb, tb);</a>
<a name="ln2033">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2034">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2035"> </a>
<a name="ln2036"> </a>
<a name="ln2037">      b[j + 3] = local_opacity;</a>
<a name="ln2038">    }</a>
<a name="ln2039">  }</a>
<a name="ln2040">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2041">  {</a>
<a name="ln2042">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2043">    {</a>
<a name="ln2044">      float local_opacity = mask[i];</a>
<a name="ln2045">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2046">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2047"> </a>
<a name="ln2048">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2049">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2050"> </a>
<a name="ln2051">      dt_RGB_2_HSL(ta, tta);</a>
<a name="ln2052">      dt_RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2053"> </a>
<a name="ln2054">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2055">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2056">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2057">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2058"> </a>
<a name="ln2059">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2060">      ttb[2] = tta[2];</a>
<a name="ln2061"> </a>
<a name="ln2062">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2063">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2064"> </a>
<a name="ln2065">      b[j + 3] = local_opacity;</a>
<a name="ln2066">    }</a>
<a name="ln2067">  }</a>
<a name="ln2068">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2069">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2070">}</a>
<a name="ln2071"> </a>
<a name="ln2072">/* color adjustment; blend hue and chroma; take lightness from module output */</a>
<a name="ln2073">static void _blend_coloradjust(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2074">                               int flag)</a>
<a name="ln2075">{</a>
<a name="ln2076">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2077">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2078"> </a>
<a name="ln2079">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2080">  {</a>
<a name="ln2081">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2082">    {</a>
<a name="ln2083">      float local_opacity = mask[i];</a>
<a name="ln2084">      float ta[3], tb[3];</a>
<a name="ln2085">      float tta[3], ttb[3];</a>
<a name="ln2086">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2087">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2088">      dt_Lab_2_LCH(ta, tta);</a>
<a name="ln2089"> </a>
<a name="ln2090">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2091">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2092">      dt_Lab_2_LCH(tb, ttb);</a>
<a name="ln2093"> </a>
<a name="ln2094">      // ttb[0] (output lightness) unchanged</a>
<a name="ln2095">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2096"> </a>
<a name="ln2097">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2098">      float d = fabsf(tta[2] - ttb[2]);</a>
<a name="ln2099">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2100">      ttb[2] = fmodf((tta[2] * (1.0f - s)) + ttb[2] * s + 1.0f, 1.0f);</a>
<a name="ln2101"> </a>
<a name="ln2102">      dt_LCH_2_Lab(ttb, tb);</a>
<a name="ln2103">      _CLAMP_XYZ(tb, min, max);</a>
<a name="ln2104">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2105"> </a>
<a name="ln2106">      b[j + 3] = local_opacity;</a>
<a name="ln2107">    }</a>
<a name="ln2108">  }</a>
<a name="ln2109">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2110">  {</a>
<a name="ln2111">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2112">    {</a>
<a name="ln2113">      float local_opacity = mask[i];</a>
<a name="ln2114">      float ta[3], tta[3], ttb[3];</a>
<a name="ln2115">      _PX_COPY(&amp;a[j], ta);</a>
<a name="ln2116"> </a>
<a name="ln2117">      _CLAMP_XYZ(ta, min, max);</a>
<a name="ln2118">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2119"> </a>
<a name="ln2120">      dt_RGB_2_HSL(ta, tta);</a>
<a name="ln2121">      dt_RGB_2_HSL(&amp;b[j], ttb);</a>
<a name="ln2122"> </a>
<a name="ln2123">      /* blend hue along shortest distance on color circle */</a>
<a name="ln2124">      float d = fabsf(tta[0] - ttb[0]);</a>
<a name="ln2125">      float s = d &gt; 0.5f ? -local_opacity * (1.0f - d) / d : local_opacity;</a>
<a name="ln2126">      ttb[0] = fmodf((tta[0] * (1.0f - s)) + ttb[0] * s + 1.0f, 1.0f);</a>
<a name="ln2127"> </a>
<a name="ln2128">      ttb[1] = (tta[1] * (1.0f - local_opacity)) + ttb[1] * local_opacity;</a>
<a name="ln2129">      // ttb[2] (output lightness) unchanged</a>
<a name="ln2130"> </a>
<a name="ln2131">      _HSL_2_RGB(ttb, &amp;b[j]);</a>
<a name="ln2132">      _CLAMP_XYZ(&amp;b[j], min, max);</a>
<a name="ln2133"> </a>
<a name="ln2134">      b[j + 3] = local_opacity;</a>
<a name="ln2135">    }</a>
<a name="ln2136">  }</a>
<a name="ln2137">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2138">    _blend_noop(bd, a, b, mask, min, max); // Noop for Raw</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141">/* inverse blend */</a>
<a name="ln2142">static void _blend_inverse(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2143">                           int flag)</a>
<a name="ln2144">{</a>
<a name="ln2145">  float max[4] = { 0 }, min[4] = { 0 };</a>
<a name="ln2146">  _blend_colorspace_channel_range(bd-&gt;cst, min, max);</a>
<a name="ln2147"> </a>
<a name="ln2148">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2149">  {</a>
<a name="ln2150">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2151">    {</a>
<a name="ln2152">      float local_opacity = mask[i];</a>
<a name="ln2153">      float ta[3], tb[3];</a>
<a name="ln2154">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2155">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2156"> </a>
<a name="ln2157">      tb[0] =clamp_range_f(ta[0]*(1.0f-local_opacity)+tb[0]*local_opacity, min[0], max[0]);</a>
<a name="ln2158"> </a>
<a name="ln2159">      if(flag == 0)</a>
<a name="ln2160">      {</a>
<a name="ln2161">        tb[1] =clamp_range_f(ta[1]*(1.0f-local_opacity)+tb[1]*local_opacity, min[1], max[1]);</a>
<a name="ln2162">        tb[2] =clamp_range_f(ta[2]*(1.0f-local_opacity)+tb[2]*local_opacity, min[2], max[2]);</a>
<a name="ln2163">      }</a>
<a name="ln2164">      else</a>
<a name="ln2165">      {</a>
<a name="ln2166">        tb[1] = ta[1];</a>
<a name="ln2167">        tb[2] = ta[2];</a>
<a name="ln2168">      }</a>
<a name="ln2169"> </a>
<a name="ln2170">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2171">      b[j + 3] = local_opacity;</a>
<a name="ln2172">    }</a>
<a name="ln2173">  }</a>
<a name="ln2174">  else if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2175">  {</a>
<a name="ln2176">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2177">    {</a>
<a name="ln2178">      float local_opacity = mask[i];</a>
<a name="ln2179">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln2180">        b[j + k]</a>
<a name="ln2181">            =clamp_range_f(a[j+k]*(1.0f-local_opacity)+b[j+k]*local_opacity, min[k], max[k]);</a>
<a name="ln2182">      b[j + 3] = local_opacity;</a>
<a name="ln2183">    }</a>
<a name="ln2184">  }</a>
<a name="ln2185">  else /* if(bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2186">  {</a>
<a name="ln2187">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2188">    {</a>
<a name="ln2189">      float local_opacity = mask[i];</a>
<a name="ln2190">      for(int k = 0; k &lt; bd-&gt;bch; k++)</a>
<a name="ln2191">        b[j + k]</a>
<a name="ln2192">            =clamp_range_f(a[j+k]*(1.0f-local_opacity)+b[j+k]*local_opacity, min[k], max[k]);</a>
<a name="ln2193">    }</a>
<a name="ln2194">  }</a>
<a name="ln2195">}</a>
<a name="ln2196"> </a>
<a name="ln2197">/* blend only lightness in Lab color space without any clamping (a noop for</a>
<a name="ln2198"> * other color spaces) */</a>
<a name="ln2199">static void _blend_Lab_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2200">                                 int flag)</a>
<a name="ln2201">{</a>
<a name="ln2202">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2203">  {</a>
<a name="ln2204">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2205">    {</a>
<a name="ln2206">      float local_opacity = mask[i];</a>
<a name="ln2207">      float ta[3], tb[3];</a>
<a name="ln2208">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2209">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2210"> </a>
<a name="ln2211">      tb[0] = ta[0] * (1.0f - local_opacity) + tb[0] * local_opacity;</a>
<a name="ln2212">      tb[1] = ta[1];</a>
<a name="ln2213">      tb[2] = ta[2];</a>
<a name="ln2214"> </a>
<a name="ln2215">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2216">      b[j + 3] = local_opacity;</a>
<a name="ln2217">    }</a>
<a name="ln2218">  }</a>
<a name="ln2219">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2220">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">/* blend only a-channel in Lab color space without any clamping (a noop for</a>
<a name="ln2224"> * other color spaces) */</a>
<a name="ln2225">static void _blend_Lab_a(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2226">                         int flag)</a>
<a name="ln2227">{</a>
<a name="ln2228">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2229">  {</a>
<a name="ln2230">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2231">    {</a>
<a name="ln2232">      float local_opacity = mask[i];</a>
<a name="ln2233">      float ta[3], tb[3];</a>
<a name="ln2234">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2235">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2236"> </a>
<a name="ln2237">      tb[0] = ta[0];</a>
<a name="ln2238">      tb[1] = ta[1] * (1.0f - local_opacity) + tb[1] * local_opacity;</a>
<a name="ln2239">      tb[2] = ta[2];</a>
<a name="ln2240"> </a>
<a name="ln2241">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2242">      b[j + 3] = local_opacity;</a>
<a name="ln2243">    }</a>
<a name="ln2244">  }</a>
<a name="ln2245">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2246">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2247">}</a>
<a name="ln2248"> </a>
<a name="ln2249">/* blend only b-channel in Lab color space without any clamping (a noop for</a>
<a name="ln2250"> * other color spaces) */</a>
<a name="ln2251">static void _blend_Lab_b(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2252">                         int flag)</a>
<a name="ln2253">{</a>
<a name="ln2254">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2255">  {</a>
<a name="ln2256">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2257">    {</a>
<a name="ln2258">      float local_opacity = mask[i];</a>
<a name="ln2259">      float ta[3], tb[3];</a>
<a name="ln2260">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2261">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2262"> </a>
<a name="ln2263">      tb[0] = ta[0];</a>
<a name="ln2264">      tb[1] = ta[1];</a>
<a name="ln2265">      tb[2] = ta[2] * (1.0f - local_opacity) + tb[2] * local_opacity;</a>
<a name="ln2266"> </a>
<a name="ln2267">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2268">      b[j + 3] = local_opacity;</a>
<a name="ln2269">    }</a>
<a name="ln2270">  }</a>
<a name="ln2271">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2272">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2273">}</a>
<a name="ln2274"> </a>
<a name="ln2275"> </a>
<a name="ln2276">/* blend only color in Lab color space without any clamping (a noop for other</a>
<a name="ln2277"> * color spaces) */</a>
<a name="ln2278">static void _blend_Lab_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2279">                             int flag)</a>
<a name="ln2280">{</a>
<a name="ln2281">  if(bd-&gt;cst == iop_cs_Lab)</a>
<a name="ln2282">  {</a>
<a name="ln2283">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2284">    {</a>
<a name="ln2285">      float local_opacity = mask[i];</a>
<a name="ln2286">      float ta[3], tb[3];</a>
<a name="ln2287">      _blend_Lab_scale(&amp;a[j], ta);</a>
<a name="ln2288">      _blend_Lab_scale(&amp;b[j], tb);</a>
<a name="ln2289"> </a>
<a name="ln2290">      tb[0] = ta[0];</a>
<a name="ln2291">      tb[1] = ta[1] * (1.0f - local_opacity) + tb[1] * local_opacity;</a>
<a name="ln2292">      tb[2] = ta[2] * (1.0f - local_opacity) + tb[2] * local_opacity;</a>
<a name="ln2293"> </a>
<a name="ln2294">      if(flag != 0)</a>
<a name="ln2295">      {</a>
<a name="ln2296">        tb[1] = ta[1];</a>
<a name="ln2297">        tb[2] = ta[2];</a>
<a name="ln2298">      }</a>
<a name="ln2299"> </a>
<a name="ln2300">      _blend_Lab_rescale(tb, &amp;b[j]);</a>
<a name="ln2301">      b[j + 3] = local_opacity;</a>
<a name="ln2302">    }</a>
<a name="ln2303">  }</a>
<a name="ln2304">  else /* if(bd-&gt;cst == iop_cs_rgb || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2305">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for RGB and Raw (unclamped)</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">/* blend only lightness in HSV color space without any clamping (a noop for</a>
<a name="ln2309"> * other color spaces) */</a>
<a name="ln2310">static void _blend_HSV_lightness(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2311">                                 int flag)</a>
<a name="ln2312">{</a>
<a name="ln2313">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2314">  {</a>
<a name="ln2315">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2316">    {</a>
<a name="ln2317">      float local_opacity = mask[i];</a>
<a name="ln2318">      float ta[3], tb[3];</a>
<a name="ln2319">      _RGB_2_HSV(&amp;a[j], ta);</a>
<a name="ln2320">      _RGB_2_HSV(&amp;b[j], tb);</a>
<a name="ln2321"> </a>
<a name="ln2322">      // hue and saturation from input image</a>
<a name="ln2323">      tb[0] = ta[0];</a>
<a name="ln2324">      tb[1] = ta[1];</a>
<a name="ln2325"> </a>
<a name="ln2326">      // blend lightness between input and output</a>
<a name="ln2327">      tb[2] = ta[2] * (1.0f - local_opacity) + tb[2] * local_opacity;</a>
<a name="ln2328"> </a>
<a name="ln2329">      _HSV_2_RGB(tb, &amp;b[j]);</a>
<a name="ln2330">      b[j + 3] = local_opacity;</a>
<a name="ln2331">    }</a>
<a name="ln2332">  }</a>
<a name="ln2333">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2334">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2335">}</a>
<a name="ln2336"> </a>
<a name="ln2337">/* blend only color in HSV color space without any clamping (a noop for other</a>
<a name="ln2338"> * color spaces) */</a>
<a name="ln2339">static void _blend_HSV_color(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2340">                             int flag)</a>
<a name="ln2341">{</a>
<a name="ln2342">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2343">  {</a>
<a name="ln2344">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2345">    {</a>
<a name="ln2346">      float local_opacity = mask[i];</a>
<a name="ln2347">      float ta[3], tb[3];</a>
<a name="ln2348">      _RGB_2_HSV(&amp;a[j], ta);</a>
<a name="ln2349">      _RGB_2_HSV(&amp;b[j], tb);</a>
<a name="ln2350"> </a>
<a name="ln2351">      // convert from polar to cartesian coordinates</a>
<a name="ln2352">      float xa = ta[1] * cosf(2.0f * DT_M_PI_F * ta[0]);</a>
<a name="ln2353">      float ya = ta[1] * sinf(2.0f * DT_M_PI_F * ta[0]);</a>
<a name="ln2354">      float xb = tb[1] * cosf(2.0f * DT_M_PI_F * tb[0]);</a>
<a name="ln2355">      float yb = tb[1] * sinf(2.0f * DT_M_PI_F * tb[0]);</a>
<a name="ln2356"> </a>
<a name="ln2357">      // blend color vectors of input and output</a>
<a name="ln2358">      float xc = xa * (1.0f - local_opacity) + xb * local_opacity;</a>
<a name="ln2359">      float yc = ya * (1.0f - local_opacity) + yb * local_opacity;</a>
<a name="ln2360"> </a>
<a name="ln2361">      tb[0] = atan2f(yc, xc) / (2.0f * DT_M_PI_F);</a>
<a name="ln2362">      if(tb[0] &lt; 0.0f) tb[0] += 1.0f;</a>
<a name="ln2363">      tb[1] = sqrtf(xc * xc + yc * yc);</a>
<a name="ln2364"> </a>
<a name="ln2365">      // lightness from input image</a>
<a name="ln2366">      tb[2] = ta[2];</a>
<a name="ln2367"> </a>
<a name="ln2368">      _HSV_2_RGB(tb, &amp;b[j]);</a>
<a name="ln2369">      b[j + 3] = local_opacity;</a>
<a name="ln2370">    }</a>
<a name="ln2371">  }</a>
<a name="ln2372">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2373">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2374">}</a>
<a name="ln2375"> </a>
<a name="ln2376">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2377"> * other color spaces) */</a>
<a name="ln2378">static void _blend_RGB_R(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2379">                         int flag)</a>
<a name="ln2380">{</a>
<a name="ln2381">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2382">  {</a>
<a name="ln2383">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2384">    {</a>
<a name="ln2385">      float local_opacity = mask[i];</a>
<a name="ln2386"> </a>
<a name="ln2387">      b[j + 0] = a[j + 0] * (1.0f - local_opacity) + b[j + 0] * local_opacity;</a>
<a name="ln2388">      b[j + 1] = a[j + 1];</a>
<a name="ln2389">      b[j + 2] = a[j + 2];</a>
<a name="ln2390">      b[j + 3] = local_opacity;</a>
<a name="ln2391">    }</a>
<a name="ln2392">  }</a>
<a name="ln2393">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2394">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2395"> </a>
<a name="ln2396">}</a>
<a name="ln2397"> </a>
<a name="ln2398">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2399"> * other color spaces) */</a>
<a name="ln2400">static void _blend_RGB_G(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2401">                         int flag)</a>
<a name="ln2402">{</a>
<a name="ln2403">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2404">  {</a>
<a name="ln2405">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2406">    {</a>
<a name="ln2407">      float local_opacity = mask[i];</a>
<a name="ln2408"> </a>
<a name="ln2409">      b[j + 0] = a[j + 0];</a>
<a name="ln2410">      b[j + 1] = a[j + 1] * (1.0f - local_opacity) + b[j + 1] * local_opacity;</a>
<a name="ln2411">      b[j + 2] = a[j + 2];</a>
<a name="ln2412">      b[j + 3] = local_opacity;</a>
<a name="ln2413">    }</a>
<a name="ln2414">  }</a>
<a name="ln2415">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2416">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2417">}</a>
<a name="ln2418"> </a>
<a name="ln2419">/* blend only R-channel in RGB color space without any clamping (a noop for</a>
<a name="ln2420"> * other color spaces) */</a>
<a name="ln2421">static void _blend_RGB_B(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2422">                         int flag)</a>
<a name="ln2423">{</a>
<a name="ln2424">  if(bd-&gt;cst == iop_cs_rgb)</a>
<a name="ln2425">  {</a>
<a name="ln2426">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2427">    {</a>
<a name="ln2428">      float local_opacity = mask[i];</a>
<a name="ln2429"> </a>
<a name="ln2430">      b[j + 0] = a[j + 0];</a>
<a name="ln2431">      b[j + 1] = a[j + 1];</a>
<a name="ln2432">      b[j + 2] = a[j + 2] * (1.0f - local_opacity) + b[j + 2] * local_opacity;</a>
<a name="ln2433">      b[j + 3] = local_opacity;</a>
<a name="ln2434">    }</a>
<a name="ln2435">  }</a>
<a name="ln2436">  else /* if(bd-&gt;cst == iop_cs_Lab || bd-&gt;cst == iop_cs_RAW) */</a>
<a name="ln2437">    _blend_noop(bd, a, b, mask, NULL, NULL); // Noop for Lab and Raw (unclamped)</a>
<a name="ln2438">}</a>
<a name="ln2439"> </a>
<a name="ln2440"> </a>
<a name="ln2441">static void display_channel(const _blend_buffer_desc_t *bd, const float *a, float *b, const float *mask,</a>
<a name="ln2442">                            dt_dev_pixelpipe_display_mask_t channel,</a>
<a name="ln2443">                            const dt_iop_order_iccprofile_info_t *work_profile)</a>
<a name="ln2444">{</a>
<a name="ln2445"> </a>
<a name="ln2446">  switch(channel &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln2447">  {</a>
<a name="ln2448">    case DT_DEV_PIXELPIPE_DISPLAY_L:</a>
<a name="ln2449">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2450">      {</a>
<a name="ln2451">        const float c =clamp_range_f(a[j]/100.0f, 0.0f, 1.0f);</a>
<a name="ln2452">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2453">      }</a>
<a name="ln2454">      break;</a>
<a name="ln2455">    case (DT_DEV_PIXELPIPE_DISPLAY_L | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2456">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2457">      {</a>
<a name="ln2458">        const float c =clamp_range_f(b[j]/100.0f, 0.0f, 1.0f);</a>
<a name="ln2459">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2460">      }</a>
<a name="ln2461">      break;</a>
<a name="ln2462">    case DT_DEV_PIXELPIPE_DISPLAY_a:</a>
<a name="ln2463">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2464">      {</a>
<a name="ln2465">        const float c =clamp_range_f((a[j+1]+128.0f)/256.0f, 0.0f, 1.0f);</a>
<a name="ln2466">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2467">      }</a>
<a name="ln2468">      break;</a>
<a name="ln2469">    case (DT_DEV_PIXELPIPE_DISPLAY_a | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2470">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2471">      {</a>
<a name="ln2472">        const float c =clamp_range_f((b[j+1]+128.0f)/256.0f, 0.0f, 1.0f);</a>
<a name="ln2473">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2474">      }</a>
<a name="ln2475">      break;</a>
<a name="ln2476">    case DT_DEV_PIXELPIPE_DISPLAY_b:</a>
<a name="ln2477">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2478">      {</a>
<a name="ln2479">        const float c =clamp_range_f((a[j+2]+128.0f)/256.0f, 0.0f, 1.0f);</a>
<a name="ln2480">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2481">      }</a>
<a name="ln2482">      break;</a>
<a name="ln2483">    case (DT_DEV_PIXELPIPE_DISPLAY_b | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2484">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2485">      {</a>
<a name="ln2486">        const float c =clamp_range_f((b[j+2]+128.0f)/256.0f, 0.0f, 1.0f);</a>
<a name="ln2487">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2488">      }</a>
<a name="ln2489">      break;</a>
<a name="ln2490">    case DT_DEV_PIXELPIPE_DISPLAY_R:</a>
<a name="ln2491">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2492">      {</a>
<a name="ln2493">        const float c =clamp_range_f(a[j], 0.0f, 1.0f);</a>
<a name="ln2494">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2495">      }</a>
<a name="ln2496">      break;</a>
<a name="ln2497">    case (DT_DEV_PIXELPIPE_DISPLAY_R | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2498">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2499">      {</a>
<a name="ln2500">        const float c =clamp_range_f(b[j], 0.0f, 1.0f);</a>
<a name="ln2501">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2502">      }</a>
<a name="ln2503">      break;</a>
<a name="ln2504">    case DT_DEV_PIXELPIPE_DISPLAY_G:</a>
<a name="ln2505">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2506">      {</a>
<a name="ln2507">        const float c =clamp_range_f(a[j+1], 0.0f, 1.0f);</a>
<a name="ln2508">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2509">      }</a>
<a name="ln2510">      break;</a>
<a name="ln2511">    case (DT_DEV_PIXELPIPE_DISPLAY_G | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2512">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2513">      {</a>
<a name="ln2514">        const float c =clamp_range_f(b[j+1], 0.0f, 1.0f);</a>
<a name="ln2515">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2516">      }</a>
<a name="ln2517">      break;</a>
<a name="ln2518">    case DT_DEV_PIXELPIPE_DISPLAY_B:</a>
<a name="ln2519">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2520">      {</a>
<a name="ln2521">        const float c =clamp_range_f(a[j+2], 0.0f, 1.0f);</a>
<a name="ln2522">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2523">      }</a>
<a name="ln2524">      break;</a>
<a name="ln2525">    case (DT_DEV_PIXELPIPE_DISPLAY_B | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2526">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2527">      {</a>
<a name="ln2528">        const float c =clamp_range_f(b[j+2], 0.0f, 1.0f);</a>
<a name="ln2529">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2530">      }</a>
<a name="ln2531">      break;</a>
<a name="ln2532">    case DT_DEV_PIXELPIPE_DISPLAY_GRAY:</a>
<a name="ln2533">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2534">      {</a>
<a name="ln2535">        const float c = (work_profile == NULL)</a>
<a name="ln2536">                            ? clamp_range_f(0.3f*a[j]+0.59f*a[j+1]+0.11f*a[j+2], 0.0f, 1.0f)</a>
<a name="ln2537">                            : clamp_range_f(dt_ioppr_get_rgb_matrix_luminance(a+j, work_profile), 0.0f, 1.0f);</a>
<a name="ln2538">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2539">      }</a>
<a name="ln2540">      break;</a>
<a name="ln2541">    case (DT_DEV_PIXELPIPE_DISPLAY_GRAY | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2542">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2543">      {</a>
<a name="ln2544">        const float c = (work_profile == NULL)</a>
<a name="ln2545">                            ? clamp_range_f(0.3f*b[j]+0.59f*b[j+1]+0.11f*b[j+2], 0.0f, 1.0f)</a>
<a name="ln2546">                            : clamp_range_f(dt_ioppr_get_rgb_matrix_luminance(b+j, work_profile), 0.0f, 1.0f);</a>
<a name="ln2547">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2548">      }</a>
<a name="ln2549">      break;</a>
<a name="ln2550">    case DT_DEV_PIXELPIPE_DISPLAY_LCH_C:</a>
<a name="ln2551">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2552">      {</a>
<a name="ln2553">        float LCH[3];</a>
<a name="ln2554">        dt_Lab_2_LCH(a + j, LCH);</a>
<a name="ln2555">        const float c =clamp_range_f(LCH[1]/(128.0f*sqrtf(2.0f)), 0.0f, 1.0f);</a>
<a name="ln2556">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2557">      }</a>
<a name="ln2558">      break;</a>
<a name="ln2559">    case (DT_DEV_PIXELPIPE_DISPLAY_LCH_C | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2560">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2561">      {</a>
<a name="ln2562">        float LCH[3];</a>
<a name="ln2563">        dt_Lab_2_LCH(b + j, LCH);</a>
<a name="ln2564">        const float c =clamp_range_f(LCH[1]/(128.0f*sqrtf(2.0f)), 0.0f, 1.0f);</a>
<a name="ln2565">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2566">      }</a>
<a name="ln2567">      break;</a>
<a name="ln2568">    case DT_DEV_PIXELPIPE_DISPLAY_LCH_h:</a>
<a name="ln2569">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2570">      {</a>
<a name="ln2571">        float LCH[3];</a>
<a name="ln2572">        dt_Lab_2_LCH(a + j, LCH);</a>
<a name="ln2573">        const float c =clamp_range_f(LCH[2], 0.0f, 1.0f);</a>
<a name="ln2574">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2575">      }</a>
<a name="ln2576">      break;</a>
<a name="ln2577">    case (DT_DEV_PIXELPIPE_DISPLAY_LCH_h | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2578">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2579">      {</a>
<a name="ln2580">        float LCH[3];</a>
<a name="ln2581">        dt_Lab_2_LCH(b + j, LCH);</a>
<a name="ln2582">        const float c =clamp_range_f(LCH[2], 0.0f, 1.0f);</a>
<a name="ln2583">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2584">      }</a>
<a name="ln2585">      break;</a>
<a name="ln2586">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_H:</a>
<a name="ln2587">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2588">      {</a>
<a name="ln2589">        float HSL[3];</a>
<a name="ln2590">        dt_RGB_2_HSL(a + j, HSL);</a>
<a name="ln2591">        const float c =clamp_range_f(HSL[0], 0.0f, 1.0f);</a>
<a name="ln2592">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2593">      }</a>
<a name="ln2594">      break;</a>
<a name="ln2595">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_H | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2596">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2597">      {</a>
<a name="ln2598">        float HSL[3];</a>
<a name="ln2599">        dt_RGB_2_HSL(b + j, HSL);</a>
<a name="ln2600">        const float c =clamp_range_f(HSL[0], 0.0f, 1.0f);</a>
<a name="ln2601">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2602">      }</a>
<a name="ln2603">      break;</a>
<a name="ln2604">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_S:</a>
<a name="ln2605">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2606">      {</a>
<a name="ln2607">        float HSL[3];</a>
<a name="ln2608">        dt_RGB_2_HSL(a + j, HSL);</a>
<a name="ln2609">        const float c =clamp_range_f(HSL[1], 0.0f, 1.0f);</a>
<a name="ln2610">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2611">      }</a>
<a name="ln2612">      break;</a>
<a name="ln2613">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_S | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2614">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2615">      {</a>
<a name="ln2616">        float HSL[3];</a>
<a name="ln2617">        dt_RGB_2_HSL(b + j, HSL);</a>
<a name="ln2618">        const float c =clamp_range_f(HSL[1], 0.0f, 1.0f);</a>
<a name="ln2619">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2620">      }</a>
<a name="ln2621">      break;</a>
<a name="ln2622">    case DT_DEV_PIXELPIPE_DISPLAY_HSL_l:</a>
<a name="ln2623">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2624">      {</a>
<a name="ln2625">        float HSL[3];</a>
<a name="ln2626">        dt_RGB_2_HSL(a + j, HSL);</a>
<a name="ln2627">        const float c =clamp_range_f(HSL[2], 0.0f, 1.0f);</a>
<a name="ln2628">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2629">      }</a>
<a name="ln2630">      break;</a>
<a name="ln2631">    case (DT_DEV_PIXELPIPE_DISPLAY_HSL_l | DT_DEV_PIXELPIPE_DISPLAY_OUTPUT):</a>
<a name="ln2632">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2633">      {</a>
<a name="ln2634">        float HSL[3];</a>
<a name="ln2635">        dt_RGB_2_HSL(b + j, HSL);</a>
<a name="ln2636">        const float c =clamp_range_f(HSL[2], 0.0f, 1.0f);</a>
<a name="ln2637">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = c;</a>
<a name="ln2638">      }</a>
<a name="ln2639">      break;</a>
<a name="ln2640">    default:</a>
<a name="ln2641">      for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2642">      {</a>
<a name="ln2643">        for(int k = 0; k &lt; bd-&gt;bch; k++) b[j + k] = 0.0f;</a>
<a name="ln2644">      }</a>
<a name="ln2645">      break;</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  if(bd-&gt;cst != iop_cs_rgb)</a>
<a name="ln2649">  {</a>
<a name="ln2650">    for(size_t i = 0, j = 0; j &lt; bd-&gt;stride; i++, j += bd-&gt;ch)</a>
<a name="ln2651">      b[j + 3] = mask[i];</a>
<a name="ln2652">  }</a>
<a name="ln2653">}</a>
<a name="ln2654"> </a>
<a name="ln2655"> </a>
<a name="ln2656">_blend_row_func *dt_develop_choose_blend_func(const unsigned int blend_mode)</a>
<a name="ln2657">{</a>
<a name="ln2658">  _blend_row_func *blend = NULL;</a>
<a name="ln2659"> </a>
<a name="ln2660">  /* select the blend operator */</a>
<a name="ln2661">  switch(blend_mode)</a>
<a name="ln2662">  {</a>
<a name="ln2663">    case DEVELOP_BLEND_LIGHTEN:</a>
<a name="ln2664">      blend = _blend_lighten;</a>
<a name="ln2665">      break;</a>
<a name="ln2666">    case DEVELOP_BLEND_DARKEN:</a>
<a name="ln2667">      blend = _blend_darken;</a>
<a name="ln2668">      break;</a>
<a name="ln2669">    case DEVELOP_BLEND_MULTIPLY:</a>
<a name="ln2670">      blend = _blend_multiply;</a>
<a name="ln2671">      break;</a>
<a name="ln2672">    case DEVELOP_BLEND_AVERAGE:</a>
<a name="ln2673">      blend = _blend_average;</a>
<a name="ln2674">      break;</a>
<a name="ln2675">    case DEVELOP_BLEND_ADD:</a>
<a name="ln2676">      blend = _blend_add;</a>
<a name="ln2677">      break;</a>
<a name="ln2678">    case DEVELOP_BLEND_SUBSTRACT:</a>
<a name="ln2679">      blend = _blend_substract;</a>
<a name="ln2680">      break;</a>
<a name="ln2681">    case DEVELOP_BLEND_DIFFERENCE:</a>
<a name="ln2682">      blend = _blend_difference;</a>
<a name="ln2683">      break;</a>
<a name="ln2684">    case DEVELOP_BLEND_DIFFERENCE2:</a>
<a name="ln2685">      blend = _blend_difference2;</a>
<a name="ln2686">      break;</a>
<a name="ln2687">    case DEVELOP_BLEND_SCREEN:</a>
<a name="ln2688">      blend = _blend_screen;</a>
<a name="ln2689">      break;</a>
<a name="ln2690">    case DEVELOP_BLEND_OVERLAY:</a>
<a name="ln2691">      blend = _blend_overlay;</a>
<a name="ln2692">      break;</a>
<a name="ln2693">    case DEVELOP_BLEND_SOFTLIGHT:</a>
<a name="ln2694">      blend = _blend_softlight;</a>
<a name="ln2695">      break;</a>
<a name="ln2696">    case DEVELOP_BLEND_HARDLIGHT:</a>
<a name="ln2697">      blend = _blend_hardlight;</a>
<a name="ln2698">      break;</a>
<a name="ln2699">    case DEVELOP_BLEND_VIVIDLIGHT:</a>
<a name="ln2700">      blend = _blend_vividlight;</a>
<a name="ln2701">      break;</a>
<a name="ln2702">    case DEVELOP_BLEND_LINEARLIGHT:</a>
<a name="ln2703">      blend = _blend_linearlight;</a>
<a name="ln2704">      break;</a>
<a name="ln2705">    case DEVELOP_BLEND_PINLIGHT:</a>
<a name="ln2706">      blend = _blend_pinlight;</a>
<a name="ln2707">      break;</a>
<a name="ln2708">    case DEVELOP_BLEND_LIGHTNESS:</a>
<a name="ln2709">      blend = _blend_lightness;</a>
<a name="ln2710">      break;</a>
<a name="ln2711">    case DEVELOP_BLEND_CHROMA:</a>
<a name="ln2712">      blend = _blend_chroma;</a>
<a name="ln2713">      break;</a>
<a name="ln2714">    case DEVELOP_BLEND_HUE:</a>
<a name="ln2715">      blend = _blend_hue;</a>
<a name="ln2716">      break;</a>
<a name="ln2717">    case DEVELOP_BLEND_COLOR:</a>
<a name="ln2718">      blend = _blend_color;</a>
<a name="ln2719">      break;</a>
<a name="ln2720">    case DEVELOP_BLEND_INVERSE:</a>
<a name="ln2721">      blend = _blend_inverse;</a>
<a name="ln2722">      break;</a>
<a name="ln2723">    case DEVELOP_BLEND_NORMAL:</a>
<a name="ln2724">    case DEVELOP_BLEND_BOUNDED:</a>
<a name="ln2725">      blend = _blend_normal_bounded;</a>
<a name="ln2726">      break;</a>
<a name="ln2727">    case DEVELOP_BLEND_COLORADJUST:</a>
<a name="ln2728">      blend = _blend_coloradjust;</a>
<a name="ln2729">      break;</a>
<a name="ln2730">    case DEVELOP_BLEND_LAB_LIGHTNESS:</a>
<a name="ln2731">    case DEVELOP_BLEND_LAB_L:</a>
<a name="ln2732">      blend = _blend_Lab_lightness;</a>
<a name="ln2733">      break;</a>
<a name="ln2734">    case DEVELOP_BLEND_LAB_A:</a>
<a name="ln2735">      blend = _blend_Lab_a;</a>
<a name="ln2736">      break;</a>
<a name="ln2737">    case DEVELOP_BLEND_LAB_B:</a>
<a name="ln2738">      blend = _blend_Lab_b;</a>
<a name="ln2739">      break;</a>
<a name="ln2740">    case DEVELOP_BLEND_LAB_COLOR:</a>
<a name="ln2741">      blend = _blend_Lab_color;</a>
<a name="ln2742">      break;</a>
<a name="ln2743">    case DEVELOP_BLEND_HSV_LIGHTNESS:</a>
<a name="ln2744">      blend = _blend_HSV_lightness;</a>
<a name="ln2745">      break;</a>
<a name="ln2746">    case DEVELOP_BLEND_HSV_COLOR:</a>
<a name="ln2747">      blend = _blend_HSV_color;</a>
<a name="ln2748">      break;</a>
<a name="ln2749">    case DEVELOP_BLEND_RGB_R:</a>
<a name="ln2750">      blend = _blend_RGB_R;</a>
<a name="ln2751">      break;</a>
<a name="ln2752">    case DEVELOP_BLEND_RGB_G:</a>
<a name="ln2753">      blend = _blend_RGB_G;</a>
<a name="ln2754">      break;</a>
<a name="ln2755">    case DEVELOP_BLEND_RGB_B:</a>
<a name="ln2756">      blend = _blend_RGB_B;</a>
<a name="ln2757">      break;</a>
<a name="ln2758"> </a>
<a name="ln2759">    /* fallback to normal blend */</a>
<a name="ln2760">    case DEVELOP_BLEND_NORMAL2:</a>
<a name="ln2761">    case DEVELOP_BLEND_UNBOUNDED:</a>
<a name="ln2762">    default:</a>
<a name="ln2763">      blend = _blend_normal_unbounded;</a>
<a name="ln2764">      break;</a>
<a name="ln2765">  }</a>
<a name="ln2766"> </a>
<a name="ln2767">  return blend;</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770">void dt_develop_blend_process(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2771">                              const void *const ivoid, void *const ovoid, const struct dt_iop_roi_t *const roi_in,</a>
<a name="ln2772">                              const struct dt_iop_roi_t *const roi_out)</a>
<a name="ln2773">{</a>
<a name="ln2774">  if(piece-&gt;pipe-&gt;bypass_blendif &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)) return;</a>
<a name="ln2775"> </a>
<a name="ln2776">  const dt_develop_blend_params_t *const d = (const dt_develop_blend_params_t *const)piece-&gt;blendop_data;</a>
<a name="ln2777">  if(!d) return;</a>
<a name="ln2778"> </a>
<a name="ln2779">  const unsigned int mask_mode = d-&gt;mask_mode;</a>
<a name="ln2780">  // check if blend is disabled</a>
<a name="ln2781">  if(!(mask_mode &amp; DEVELOP_MASK_ENABLED)) return;</a>
<a name="ln2782"> </a>
<a name="ln2783">  const int ch = piece-&gt;colors;           // the number of channels in the buffer</a>
<a name="ln2784">  const int bch = (ch == 1) ? 1 : ch - 1; // the number of channels to blend (all but alpha)</a>
<a name="ln2785">  const int xoffs = roi_out-&gt;x - roi_in-&gt;x;</a>
<a name="ln2786">  const int yoffs = roi_out-&gt;y - roi_in-&gt;y;</a>
<a name="ln2787">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln2788">  const int iheight = roi_in-&gt;height;</a>
<a name="ln2789">  const int owidth = roi_out-&gt;width;</a>
<a name="ln2790">  const int oheight = roi_out-&gt;height;</a>
<a name="ln2791">  const size_t buffsize = (size_t)owidth * oheight;</a>
<a name="ln2792">  const float iscale = roi_in-&gt;scale;</a>
<a name="ln2793">  const float oscale = roi_out-&gt;scale;</a>
<a name="ln2794">  const _Bool rois_equal = iwidth == owidth || iheight == oheight || xoffs == 0 || yoffs == 0;</a>
<a name="ln2795"> </a>
<a name="ln2796">  // In most cases of blending-enabled modules input and output of the module have</a>
<a name="ln2797">  // the exact same dimensions. Only in very special cases we allow a module's input</a>
<a name="ln2798">  // to exceed its output. This is namely the case for the spot removal module where</a>
<a name="ln2799">  // the source of a patch might lie outside the roi of the output image. Therefore:</a>
<a name="ln2800">  // We can only handle blending if roi_out and roi_in have the same scale and</a>
<a name="ln2801">  // if roi_out fits into the area given by roi_in. xoffs and yoffs describe the relative</a>
<a name="ln2802">  // offset of the input image to the output image.</a>
<a name="ln2803">  if(oscale != iscale || xoffs &lt; 0 || yoffs &lt; 0</a>
<a name="ln2804">     || ((xoffs &gt; 0 || yoffs &gt; 0) &amp;&amp; (owidth + xoffs &gt; iwidth || oheight + yoffs &gt; iheight)))</a>
<a name="ln2805">  {</a>
<a name="ln2806">    dt_control_log(_(&quot;skipped blending in module '%s': roi's do not match&quot;), self-&gt;op);</a>
<a name="ln2807">    return;</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  // only non-zero if mask_display was set by an _earlier_ module</a>
<a name="ln2811">  const dt_dev_pixelpipe_display_mask_t mask_display = piece-&gt;pipe-&gt;mask_display;</a>
<a name="ln2812"> </a>
<a name="ln2813">  // does user want us to display a specific channel?</a>
<a name="ln2814">  const dt_dev_pixelpipe_display_mask_t request_mask_display =</a>
<a name="ln2815">    (self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module) &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe)</a>
<a name="ln2816">     &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL))</a>
<a name="ln2817">        ? self-&gt;request_mask_display</a>
<a name="ln2818">        : DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln2819"> </a>
<a name="ln2820">  // check if we only should blend lightness channel. will affect only Lab space</a>
<a name="ln2821">  const int blendflag = self-&gt;flags() &amp; IOP_FLAGS_BLEND_ONLY_LIGHTNESS;</a>
<a name="ln2822"> </a>
<a name="ln2823">  // get channel max values depending on colorspace</a>
<a name="ln2824">  const dt_iop_colorspace_type_t cst = self-&gt;blend_colorspace(self, piece-&gt;pipe, piece);</a>
<a name="ln2825">  const dt_iop_order_iccprofile_info_t *const work_profile = dt_ioppr_get_pipe_work_profile_info(piece-&gt;pipe);</a>
<a name="ln2826"> </a>
<a name="ln2827">  // check if mask should be suppressed temporarily (i.e. just set to global</a>
<a name="ln2828">  // opacity value)</a>
<a name="ln2829">  const _Bool suppress_mask = self-&gt;suppress_mask &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)</a>
<a name="ln2830">                              &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe) &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL);</a>
<a name="ln2831">  const _Bool mask_feather = d-&gt;feathering_radius &gt; 0.1f;</a>
<a name="ln2832">  const _Bool mask_blur = d-&gt;blur_radius &gt; 0.1f;</a>
<a name="ln2833">  const _Bool mask_tone_curve = fabsf(d-&gt;contrast) &gt;= 0.01f || fabsf(d-&gt;brightness) &gt;= 0.01f;</a>
<a name="ln2834"> </a>
<a name="ln2835">  // get the clipped opacity value  0 - 1</a>
<a name="ln2836">  const float opacity = fminf(fmaxf(0.0f, (d-&gt;opacity / 100.0f)), 1.0f);</a>
<a name="ln2837"> </a>
<a name="ln2838">  // allocate space for blend mask</a>
<a name="ln2839">  float *_mask = dt_alloc_align(64, buffsize * sizeof(float));</a>
<a name="ln2840">  if(!_mask)</a>
<a name="ln2841">  {</a>
<a name="ln2842">    dt_control_log(_(&quot;could not allocate buffer for blending&quot;));</a>
<a name="ln2843">    return;</a>
<a name="ln2844">  }</a>
<a name="ln2845">  float *const mask = _mask;</a>
<a name="ln2846"> </a>
<a name="ln2847">  if(mask_mode == DEVELOP_MASK_ENABLED || suppress_mask)</a>
<a name="ln2848">  {</a>
<a name="ln2849">    // blend uniformly (no drawn or parametric mask)</a>
<a name="ln2850"> </a>
<a name="ln2851">#ifdef _OPENMP</a>
<a name="ln2852">#pragma omp parallel for default(none) \</a>
<a name="ln2853">    dt_omp_firstprivate(buffsize, mask, opacity)</a>
<a name="ln2854">#endif</a>
<a name="ln2855">    for(size_t i = 0; i &lt; buffsize; i++) mask[i] = opacity;</a>
<a name="ln2856">  }</a>
<a name="ln2857">  else if(mask_mode &amp; DEVELOP_MASK_RASTER)</a>
<a name="ln2858">  {</a>
<a name="ln2859">    /* use a raster mask from another module earlier in the pipe */</a>
<a name="ln2860">    gboolean free_mask = FALSE; // if no transformations were applied we get the cached original back</a>
<a name="ln2861">    float *raster_mask = dt_dev_get_raster_mask(piece-&gt;pipe, self-&gt;raster_mask.sink.source, self-&gt;raster_mask.sink.id,</a>
<a name="ln2862">                                                self, &amp;free_mask);</a>
<a name="ln2863"> </a>
<a name="ln2864">    if(raster_mask)</a>
<a name="ln2865">    {</a>
<a name="ln2866">      // invert if required</a>
<a name="ln2867">      if(d-&gt;raster_mask_invert)</a>
<a name="ln2868">#ifdef _OPENMP</a>
<a name="ln2869">  #pragma omp parallel for default(none) \</a>
<a name="ln2870">        dt_omp_firstprivate(buffsize, mask, opacity) \</a>
<a name="ln2871">        shared(raster_mask)</a>
<a name="ln2872">#endif</a>
<a name="ln2873">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = (1.0 - raster_mask[i]) * opacity;</a>
<a name="ln2874">      else</a>
<a name="ln2875">#ifdef _OPENMP</a>
<a name="ln2876">  #pragma omp parallel for default(none) \</a>
<a name="ln2877">        dt_omp_firstprivate(buffsize, mask, opacity) \</a>
<a name="ln2878">        shared(raster_mask)</a>
<a name="ln2879">#endif</a>
<a name="ln2880">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = raster_mask[i] * opacity;</a>
<a name="ln2881">      if(free_mask) dt_free_align(raster_mask);</a>
<a name="ln2882">    }</a>
<a name="ln2883">    else</a>
<a name="ln2884">    {</a>
<a name="ln2885">      // fallback for when the raster mask couldn't be applied</a>
<a name="ln2886">      const float value = d-&gt;raster_mask_invert ? 0.0 : 1.0;</a>
<a name="ln2887">#ifdef _OPENMP</a>
<a name="ln2888">  #pragma omp parallel for default(none) \</a>
<a name="ln2889">      dt_omp_firstprivate(buffsize, mask, value)</a>
<a name="ln2890">#endif</a>
<a name="ln2891">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = value;</a>
<a name="ln2892">    }</a>
<a name="ln2893">  }</a>
<a name="ln2894">  else</a>
<a name="ln2895">  {</a>
<a name="ln2896">    // we blend with a drawn and/or parametric mask</a>
<a name="ln2897"> </a>
<a name="ln2898">    // get the drawn mask if there is one</a>
<a name="ln2899">    dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, d-&gt;mask_id);</a>
<a name="ln2900"> </a>
<a name="ln2901">    if(form &amp;&amp; (!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln2902">    {</a>
<a name="ln2903">      dt_masks_group_render_roi(self, piece, form, roi_out, mask);</a>
<a name="ln2904"> </a>
<a name="ln2905">      if(d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS)</a>
<a name="ln2906">      {</a>
<a name="ln2907">        // if we have a mask and this flag is set -&gt; invert the mask</a>
<a name="ln2908">#ifdef _OPENMP</a>
<a name="ln2909">#pragma omp parallel for default(none) \</a>
<a name="ln2910">        dt_omp_firstprivate(buffsize, mask)</a>
<a name="ln2911">#endif</a>
<a name="ln2912">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = 1.0f - mask[i];</a>
<a name="ln2913">      }</a>
<a name="ln2914">    }</a>
<a name="ln2915">    else if((!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln2916">    {</a>
<a name="ln2917">      // no form defined but drawn mask active</a>
<a name="ln2918">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln2919">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS) ? 0.0f : 1.0f;</a>
<a name="ln2920">#ifdef _OPENMP</a>
<a name="ln2921">#pragma omp parallel for default(none) \</a>
<a name="ln2922">      dt_omp_firstprivate(buffsize, mask, fill)</a>
<a name="ln2923">#endif</a>
<a name="ln2924">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln2925">    }</a>
<a name="ln2926">    else</a>
<a name="ln2927">    {</a>
<a name="ln2928">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln2929">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln2930">#ifdef _OPENMP</a>
<a name="ln2931">#pragma omp parallel for default(none) \</a>
<a name="ln2932">      dt_omp_firstprivate(buffsize, mask, fill)</a>
<a name="ln2933">#endif</a>
<a name="ln2934">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln2935">    }</a>
<a name="ln2936"> </a>
<a name="ln2937">    // get parametric mask (if any) and apply global opacity</a>
<a name="ln2938">#ifdef _OPENMP</a>
<a name="ln2939">#pragma omp parallel for default(none) \</a>
<a name="ln2940">    dt_omp_firstprivate(bch, ch, cst, d, oheight, opacity, ivoid, iwidth, \</a>
<a name="ln2941">                        mask, owidth, ovoid, work_profile, xoffs, yoffs)</a>
<a name="ln2942">#endif</a>
<a name="ln2943">    for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln2944">    {</a>
<a name="ln2945">      size_t iindex = ((y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln2946">      size_t oindex = y * owidth * ch;</a>
<a name="ln2947">      _blend_buffer_desc_t bd = { .cst = cst, .stride = (size_t)owidth * ch, .ch = ch, .bch = bch };</a>
<a name="ln2948">      float *in = (float *)ivoid + iindex;</a>
<a name="ln2949">      float *out = (float *)ovoid + oindex;</a>
<a name="ln2950">      float *m = mask + y * owidth;</a>
<a name="ln2951">      _blend_make_mask(&amp;bd, d-&gt;blendif, d-&gt;blendif_parameters, d-&gt;mask_mode, d-&gt;mask_combine, opacity, in, out, m,</a>
<a name="ln2952">                       work_profile);</a>
<a name="ln2953">    }</a>
<a name="ln2954"> </a>
<a name="ln2955">    if(mask_feather)</a>
<a name="ln2956">    {</a>
<a name="ln2957">      int w = (int)(2 * d-&gt;feathering_radius * roi_out-&gt;scale / piece-&gt;iscale + 0.5f);</a>
<a name="ln2958">      if(w &lt; 1) w = 1;</a>
<a name="ln2959">      float sqrt_eps = 1.f;</a>
<a name="ln2960">      float guide_weight = 1.f;</a>
<a name="ln2961">      switch(cst)</a>
<a name="ln2962">      {</a>
<a name="ln2963">        case iop_cs_rgb:</a>
<a name="ln2964">          guide_weight = 100.f;</a>
<a name="ln2965">          break;</a>
<a name="ln2966">        case iop_cs_Lab:</a>
<a name="ln2967">          guide_weight = 1.f;</a>
<a name="ln2968">          break;</a>
<a name="ln2969">        case iop_cs_RAW:</a>
<a name="ln2970">        default:</a>
<a name="ln2971">          assert(0);</a>
<a name="ln2972">      }</a>
<a name="ln2973">      float *mask_bak = dt_alloc_align(64, sizeof(*mask_bak) * buffsize);</a>
<a name="ln2974">      memcpy(mask_bak, mask, sizeof(*mask_bak) * buffsize);</a>
<a name="ln2975">      float *guide = d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN ? (float *)ivoid : (float *)ovoid;</a>
<a name="ln2976">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN)</a>
<a name="ln2977">      {</a>
<a name="ln2978">        float *const guide_tmp = dt_alloc_align(64, sizeof(*guide_tmp) * buffsize * ch);</a>
<a name="ln2979">#ifdef _OPENMP</a>
<a name="ln2980">#pragma omp parallel for default(none) \</a>
<a name="ln2981">        dt_omp_firstprivate(ch, guide_tmp, ivoid, iwidth, oheight, owidth, xoffs, yoffs)</a>
<a name="ln2982">#endif</a>
<a name="ln2983">        for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln2984">        {</a>
<a name="ln2985">          size_t iindex = ((size_t)(y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln2986">          size_t oindex = (size_t)(y + yoffs) * owidth * ch;</a>
<a name="ln2987">          memcpy(guide_tmp + oindex, (float *)ivoid + iindex, sizeof(*guide_tmp) * owidth * ch);</a>
<a name="ln2988">        }</a>
<a name="ln2989">        guide = guide_tmp;</a>
<a name="ln2990">      }</a>
<a name="ln2991">      guided_filter(guide, mask_bak, mask, owidth, oheight, ch, w, sqrt_eps, guide_weight, 0.f, 1.f);</a>
<a name="ln2992">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN) dt_free_align(guide);</a>
<a name="ln2993">      dt_free_align(mask_bak);</a>
<a name="ln2994">    }</a>
<a name="ln2995">    if(mask_blur)</a>
<a name="ln2996">    {</a>
<a name="ln2997">      const float sigma = d-&gt;blur_radius * roi_out-&gt;scale / piece-&gt;iscale;</a>
<a name="ln2998">      const float mmax[] = { 1.0f };</a>
<a name="ln2999">      const float mmin[] = { 0.0f };</a>
<a name="ln3000"> </a>
<a name="ln3001">      dt_gaussian_t *g = dt_gaussian_init(owidth, oheight, 1, mmax, mmin, sigma, 0);</a>
<a name="ln3002">      if(g)</a>
<a name="ln3003">      {</a>
<a name="ln3004">        dt_gaussian_blur(g, mask, mask);</a>
<a name="ln3005">        dt_gaussian_free(g);</a>
<a name="ln3006">      }</a>
<a name="ln3007">    }</a>
<a name="ln3008"> </a>
<a name="ln3009">    if(mask_tone_curve &amp;&amp; opacity &gt; 1e-4f)</a>
<a name="ln3010">    {</a>
<a name="ln3011">      const float e = expf(3.f * d-&gt;contrast);</a>
<a name="ln3012">      const float brightness = d-&gt;brightness;</a>
<a name="ln3013">#ifdef _OPENMP</a>
<a name="ln3014">#pragma omp parallel for default(none) \</a>
<a name="ln3015">      dt_omp_firstprivate(brightness, buffsize, e, mask, opacity)</a>
<a name="ln3016">#endif</a>
<a name="ln3017">      for(size_t k = 0; k &lt; buffsize; k++)</a>
<a name="ln3018">      {</a>
<a name="ln3019">        float x = mask[k] / opacity;</a>
<a name="ln3020">        x = 2.f * x - 1.f;</a>
<a name="ln3021">        if (1.f - brightness &lt;= 0.f)</a>
<a name="ln3022">          x = mask[k] &lt;= FLT_EPSILON ? -1.f : 1.f;</a>
<a name="ln3023">        else if (1.f + brightness &lt;= 0.f)</a>
<a name="ln3024">          x = mask[k] &gt;= 1.f - FLT_EPSILON ? 1.f : -1.f;</a>
<a name="ln3025">        else if (brightness &gt; 0.f)</a>
<a name="ln3026">        {</a>
<a name="ln3027">          x = (x + brightness) / (1.f - brightness);</a>
<a name="ln3028">          x = fminf(x, 1.f);</a>
<a name="ln3029">        }</a>
<a name="ln3030">        else</a>
<a name="ln3031">        {</a>
<a name="ln3032">          x = (x + brightness) / (1.f + brightness);</a>
<a name="ln3033">          x = fmaxf(x, -1.f);</a>
<a name="ln3034">        }</a>
<a name="ln3035">        mask[k] = ((x * e / (1.f + (e - 1.f) * fabsf(x))) / 2.f + 0.5f) * opacity;</a>
<a name="ln3036">      }</a>
<a name="ln3037">    }</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040">  // now apply blending with per-pixel opacity value as defined in mask</a>
<a name="ln3041">  // select the blend operator</a>
<a name="ln3042">  _blend_row_func *const blend = dt_develop_choose_blend_func(d-&gt;blend_mode);</a>
<a name="ln3043">#ifdef _OPENMP</a>
<a name="ln3044">#pragma omp parallel for default(none) \</a>
<a name="ln3045">  dt_omp_firstprivate(bch, blend, blendflag, ch, cst, ivoid, iwidth, mask, \</a>
<a name="ln3046">                      mask_display, oheight, ovoid, owidth, \</a>
<a name="ln3047">                      request_mask_display, work_profile, xoffs, yoffs)</a>
<a name="ln3048">#endif</a>
<a name="ln3049">  for(size_t y = 0; y &lt; oheight; y++)</a>
<a name="ln3050">  {</a>
<a name="ln3051">    size_t iindex = ((y + yoffs) * iwidth + xoffs) * ch;</a>
<a name="ln3052">    size_t oindex = y * owidth * ch;</a>
<a name="ln3053">    _blend_buffer_desc_t bd = { .cst = cst, .stride = (size_t)owidth * ch, .ch = ch, .bch = bch };</a>
<a name="ln3054">    float *in = (float *)ivoid + iindex;</a>
<a name="ln3055">    float *out = (float *)ovoid + oindex;</a>
<a name="ln3056">    float *m = mask + y * owidth;</a>
<a name="ln3057"> </a>
<a name="ln3058">    if(request_mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln3059">      display_channel(&amp;bd, in, out, m, request_mask_display, work_profile);</a>
<a name="ln3060">    else</a>
<a name="ln3061">      blend(&amp;bd, in, out, m, blendflag);</a>
<a name="ln3062"> </a>
<a name="ln3063">    if((mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) &amp;&amp; cst != iop_cs_RAW)</a>
<a name="ln3064">      for(size_t j = 0; j &lt; bd.stride; j += 4) out[j + 3] = in[j + 3];</a>
<a name="ln3065">  }</a>
<a name="ln3066"> </a>
<a name="ln3067">  // register if _this_ module should expose mask or display channel</a>
<a name="ln3068">  if(request_mask_display &amp; (DT_DEV_PIXELPIPE_DISPLAY_MASK | DT_DEV_PIXELPIPE_DISPLAY_CHANNEL))</a>
<a name="ln3069">  {</a>
<a name="ln3070">    piece-&gt;pipe-&gt;mask_display = request_mask_display;</a>
<a name="ln3071">  }</a>
<a name="ln3072"> </a>
<a name="ln3073">  // check if we should store the mask for export or use in subsequent modules</a>
<a name="ln3074">  // TODO: should we skip raster masks?</a>
<a name="ln3075">  if(piece-&gt;pipe-&gt;store_all_raster_masks || dt_iop_is_raster_mask_used(self, 0))</a>
<a name="ln3076">  {</a>
<a name="ln3077">    g_hash_table_replace(piece-&gt;raster_masks, GINT_TO_POINTER(0), _mask);</a>
<a name="ln3078">  }</a>
<a name="ln3079">  else</a>
<a name="ln3080">  {</a>
<a name="ln3081">    g_hash_table_remove(piece-&gt;raster_masks, GINT_TO_POINTER(0));</a>
<a name="ln3082">    dt_free_align(_mask);</a>
<a name="ln3083">  }</a>
<a name="ln3084">}</a>
<a name="ln3085"> </a>
<a name="ln3086">#ifdef HAVE_OPENCL</a>
<a name="ln3087">int dt_develop_blend_process_cl(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln3088">                                cl_mem dev_in, cl_mem dev_out, const struct dt_iop_roi_t *roi_in,</a>
<a name="ln3089">                                const struct dt_iop_roi_t *roi_out)</a>
<a name="ln3090">{</a>
<a name="ln3091">  if(piece-&gt;pipe-&gt;bypass_blendif &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)) return TRUE;</a>
<a name="ln3092"> </a>
<a name="ln3093">  dt_develop_blend_params_t *const d = (dt_develop_blend_params_t *const)piece-&gt;blendop_data;</a>
<a name="ln3094">  if(!d) return TRUE;</a>
<a name="ln3095"> </a>
<a name="ln3096">  const unsigned int mask_mode = d-&gt;mask_mode;</a>
<a name="ln3097">  // check if blend is disabled: just return, output is already in dev_out</a>
<a name="ln3098">  if(!(mask_mode &amp; DEVELOP_MASK_ENABLED)) return TRUE;</a>
<a name="ln3099"> </a>
<a name="ln3100">  const int ch = piece-&gt;colors; // the number of channels in the buffer</a>
<a name="ln3101">  const int xoffs = roi_out-&gt;x - roi_in-&gt;x;</a>
<a name="ln3102">  const int yoffs = roi_out-&gt;y - roi_in-&gt;y;</a>
<a name="ln3103">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln3104">  const int iheight = roi_in-&gt;height;</a>
<a name="ln3105">  const int owidth = roi_out-&gt;width;</a>
<a name="ln3106">  const int oheight = roi_out-&gt;height;</a>
<a name="ln3107">  const size_t buffsize = (size_t)owidth * oheight;</a>
<a name="ln3108">  const float iscale = roi_in-&gt;scale;</a>
<a name="ln3109">  const float oscale = roi_out-&gt;scale;</a>
<a name="ln3110">  const _Bool rois_equal = iwidth == owidth || iheight == oheight || xoffs == 0 || yoffs == 0;</a>
<a name="ln3111"> </a>
<a name="ln3112">  // In most cases of blending-enabled modules input and output of the module have</a>
<a name="ln3113">  // the exact same dimensions. Only in very special cases we allow a module's input</a>
<a name="ln3114">  // to exceed its output. This is namely the case for the spot removal module where</a>
<a name="ln3115">  // the source of a patch might lie outside the roi of the output image. Therefore:</a>
<a name="ln3116">  // We can only handle blending if roi_out and roi_in have the same scale and</a>
<a name="ln3117">  // if roi_out fits into the area given by roi_in. xoffs and yoffs describe the relative</a>
<a name="ln3118">  // offset of the input image to the output image. */</a>
<a name="ln3119">  if(oscale != iscale || xoffs &lt; 0 || yoffs &lt; 0</a>
<a name="ln3120">     || ((xoffs &gt; 0 || yoffs &gt; 0) &amp;&amp; (owidth + xoffs &gt; iwidth || oheight + yoffs &gt; iheight)))</a>
<a name="ln3121">  {</a>
<a name="ln3122">    dt_control_log(_(&quot;skipped blending in module '%s': roi's do not match&quot;), self-&gt;op);</a>
<a name="ln3123">    return TRUE;</a>
<a name="ln3124">  }</a>
<a name="ln3125"> </a>
<a name="ln3126">  // only non-zero if mask_display was set by an _earlier_ module</a>
<a name="ln3127">  const dt_dev_pixelpipe_display_mask_t mask_display = piece-&gt;pipe-&gt;mask_display;</a>
<a name="ln3128"> </a>
<a name="ln3129">  // does user want us to display a specific channel?</a>
<a name="ln3130">  const dt_dev_pixelpipe_display_mask_t request_mask_display</a>
<a name="ln3131">      = (self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module) &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe)</a>
<a name="ln3132">         &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL))</a>
<a name="ln3133">            ? self-&gt;request_mask_display</a>
<a name="ln3134">            : DT_DEV_PIXELPIPE_DISPLAY_NONE;</a>
<a name="ln3135"> </a>
<a name="ln3136">  // check if we only should blend lightness channel. will affect only Lab space</a>
<a name="ln3137">  const int blendflag = self-&gt;flags() &amp; IOP_FLAGS_BLEND_ONLY_LIGHTNESS;</a>
<a name="ln3138"> </a>
<a name="ln3139">  // get channel max values depending on colorspace</a>
<a name="ln3140">  const dt_iop_colorspace_type_t cst = self-&gt;blend_colorspace(self, piece-&gt;pipe, piece);</a>
<a name="ln3141"> </a>
<a name="ln3142">  // check if mask should be suppressed temporarily (i.e. just set to global</a>
<a name="ln3143">  // opacity value)</a>
<a name="ln3144">  const _Bool suppress_mask = self-&gt;suppress_mask &amp;&amp; self-&gt;dev-&gt;gui_attached &amp;&amp; (self == self-&gt;dev-&gt;gui_module)</a>
<a name="ln3145">                              &amp;&amp; (piece-&gt;pipe == self-&gt;dev-&gt;pipe) &amp;&amp; (mask_mode &amp; DEVELOP_MASK_MASK_CONDITIONAL);</a>
<a name="ln3146">  const _Bool mask_feather = d-&gt;feathering_radius &gt; 0.1f;</a>
<a name="ln3147">  const _Bool mask_blur = d-&gt;blur_radius &gt; 0.1f;</a>
<a name="ln3148">  const _Bool mask_tone_curve = fabsf(d-&gt;contrast) &gt;= 0.01f || fabsf(d-&gt;brightness) &gt;= 0.01f;</a>
<a name="ln3149"> </a>
<a name="ln3150">  // get the clipped opacity value  0 - 1</a>
<a name="ln3151">  const float opacity = fminf(fmaxf(0.0f, (d-&gt;opacity / 100.0f)), 1.0f);</a>
<a name="ln3152"> </a>
<a name="ln3153">  // allocate space for blend mask</a>
<a name="ln3154">  float *_mask = dt_alloc_align(64, buffsize * sizeof(float));</a>
<a name="ln3155">  if(!_mask)</a>
<a name="ln3156">  {</a>
<a name="ln3157">    dt_control_log(_(&quot;could not allocate buffer for blending&quot;));</a>
<a name="ln3158">    return FALSE;</a>
<a name="ln3159">  }</a>
<a name="ln3160">  float *const mask = _mask;</a>
<a name="ln3161"> </a>
<a name="ln3162">  // setup some kernels</a>
<a name="ln3163">  int kernel_mask;</a>
<a name="ln3164">  int kernel;</a>
<a name="ln3165">  switch(cst)</a>
<a name="ln3166">  {</a>
<a name="ln3167">    case iop_cs_RAW:</a>
<a name="ln3168">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_RAW;</a>
<a name="ln3169">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_RAW;</a>
<a name="ln3170">      break;</a>
<a name="ln3171"> </a>
<a name="ln3172">    case iop_cs_rgb:</a>
<a name="ln3173">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_rgb;</a>
<a name="ln3174">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_rgb;</a>
<a name="ln3175">      break;</a>
<a name="ln3176"> </a>
<a name="ln3177">    case iop_cs_Lab:</a>
<a name="ln3178">    default:</a>
<a name="ln3179">      kernel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_Lab;</a>
<a name="ln3180">      kernel_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_Lab;</a>
<a name="ln3181">      break;</a>
<a name="ln3182">  }</a>
<a name="ln3183">  int kernel_mask_tone_curve = darktable.opencl-&gt;blendop-&gt;kernel_blendop_mask_tone_curve;</a>
<a name="ln3184">  int kernel_set_mask = darktable.opencl-&gt;blendop-&gt;kernel_blendop_set_mask;</a>
<a name="ln3185">  int kernel_display_channel = darktable.opencl-&gt;blendop-&gt;kernel_blendop_display_channel;</a>
<a name="ln3186"> </a>
<a name="ln3187">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3188">  const int offs[2] = { xoffs, yoffs };</a>
<a name="ln3189">  const size_t sizes[] = { ROUNDUPWD(owidth), ROUNDUPHT(oheight), 1 };</a>
<a name="ln3190"> </a>
<a name="ln3191">  cl_int err = -999;</a>
<a name="ln3192">  cl_mem dev_m = NULL;</a>
<a name="ln3193">  cl_mem dev_mask_1 = NULL;</a>
<a name="ln3194">  cl_mem dev_mask_2 = NULL;</a>
<a name="ln3195">  cl_mem dev_tmp = NULL;</a>
<a name="ln3196">  cl_mem dev_guide = NULL;</a>
<a name="ln3197">  cl_mem dev_profile_info = NULL;</a>
<a name="ln3198">  cl_mem dev_profile_lut = NULL;</a>
<a name="ln3199">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl;</a>
<a name="ln3200">  cl_float *profile_lut_cl = NULL;</a>
<a name="ln3201">  size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3202">  size_t region[] = { owidth, oheight, 1 };</a>
<a name="ln3203"> </a>
<a name="ln3204">  // copy blend parameters to constant device memory</a>
<a name="ln3205">  dev_m = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 4 * DEVELOP_BLENDIF_SIZE,</a>
<a name="ln3206">                                                 d-&gt;blendif_parameters);</a>
<a name="ln3207">  if(dev_m == NULL) goto error;</a>
<a name="ln3208"> </a>
<a name="ln3209">  dev_mask_1 = dt_opencl_alloc_device(devid, owidth, oheight, sizeof(float));</a>
<a name="ln3210">  if(dev_mask_1 == NULL) goto error;</a>
<a name="ln3211"> </a>
<a name="ln3212">  const dt_iop_order_iccprofile_info_t *const work_profile = dt_ioppr_get_pipe_work_profile_info(piece-&gt;pipe);</a>
<a name="ln3213"> </a>
<a name="ln3214">  err = dt_ioppr_build_iccprofile_params_cl(work_profile, devid, &amp;profile_info_cl, &amp;profile_lut_cl,</a>
<a name="ln3215">                                            &amp;dev_profile_info, &amp;dev_profile_lut);</a>
<a name="ln3216">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3217"> </a>
<a name="ln3218">  if(mask_mode == DEVELOP_MASK_ENABLED || suppress_mask)</a>
<a name="ln3219">  {</a>
<a name="ln3220">    // blend uniformly (no drawn or parametric mask)</a>
<a name="ln3221"> </a>
<a name="ln3222">    // set dev_mask with global opacity value</a>
<a name="ln3223">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 0, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3224">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 1, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3225">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 2, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3226">    dt_opencl_set_kernel_arg(devid, kernel_set_mask, 3, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3227">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_set_mask, sizes);</a>
<a name="ln3228">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3229">  }</a>
<a name="ln3230">  else if(mask_mode &amp; DEVELOP_MASK_RASTER)</a>
<a name="ln3231">  {</a>
<a name="ln3232">    /* use a raster mask from another module earlier in the pipe */</a>
<a name="ln3233">    gboolean free_mask = FALSE; // if no transformations were applied we get the cached original back</a>
<a name="ln3234">    float *raster_mask = dt_dev_get_raster_mask(piece-&gt;pipe, self-&gt;raster_mask.sink.source, self-&gt;raster_mask.sink.id,</a>
<a name="ln3235">                                                self, &amp;free_mask);</a>
<a name="ln3236"> </a>
<a name="ln3237">    if(raster_mask)</a>
<a name="ln3238">    {</a>
<a name="ln3239">      // invert if required</a>
<a name="ln3240">      if(d-&gt;raster_mask_invert)</a>
<a name="ln3241">#ifdef _OPENMP</a>
<a name="ln3242">  #pragma omp parallel for default(none) \</a>
<a name="ln3243">        dt_omp_firstprivate(buffsize, mask, opacity) \</a>
<a name="ln3244">        shared(raster_mask)</a>
<a name="ln3245">#endif</a>
<a name="ln3246">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = (1.0 - raster_mask[i]) * opacity;</a>
<a name="ln3247">      else</a>
<a name="ln3248">#ifdef _OPENMP</a>
<a name="ln3249">  #pragma omp parallel for default(none) \</a>
<a name="ln3250">        dt_omp_firstprivate(buffsize, mask, opacity) \</a>
<a name="ln3251">        shared(raster_mask)</a>
<a name="ln3252">#endif</a>
<a name="ln3253">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = raster_mask[i] * opacity;</a>
<a name="ln3254">      if(free_mask) dt_free_align(raster_mask);</a>
<a name="ln3255">    }</a>
<a name="ln3256">    else</a>
<a name="ln3257">    {</a>
<a name="ln3258">      // fallback for when the raster mask couldn't be applied</a>
<a name="ln3259">      const float value = d-&gt;raster_mask_invert ? 0.0 : 1.0;</a>
<a name="ln3260">#ifdef _OPENMP</a>
<a name="ln3261">  #pragma omp parallel for default(none) \</a>
<a name="ln3262">      dt_omp_firstprivate(buffsize, mask, value)</a>
<a name="ln3263">#endif</a>
<a name="ln3264">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = value;</a>
<a name="ln3265">    }</a>
<a name="ln3266"> </a>
<a name="ln3267">    err = dt_opencl_write_host_to_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3268">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3269">  }</a>
<a name="ln3270">  else</a>
<a name="ln3271">  {</a>
<a name="ln3272">    // we blend with a drawn and/or parametric mask</a>
<a name="ln3273"> </a>
<a name="ln3274">    // get the drawn mask if there is one</a>
<a name="ln3275">    dt_masks_form_t *form = dt_masks_get_from_id_ext(piece-&gt;pipe-&gt;forms, d-&gt;mask_id);</a>
<a name="ln3276"> </a>
<a name="ln3277">    if(form &amp;&amp; (!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln3278">    {</a>
<a name="ln3279">      dt_masks_group_render_roi(self, piece, form, roi_out, mask);</a>
<a name="ln3280"> </a>
<a name="ln3281">      if(d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS)</a>
<a name="ln3282">      {</a>
<a name="ln3283">        // if we have a mask and this flag is set -&gt; invert the mask</a>
<a name="ln3284">#ifdef _OPENMP</a>
<a name="ln3285">  #pragma omp parallel for default(none) \</a>
<a name="ln3286">      dt_omp_firstprivate(buffsize, mask)</a>
<a name="ln3287">#endif</a>
<a name="ln3288">        for(size_t i = 0; i &lt; buffsize; i++) mask[i] = 1.0f - mask[i];</a>
<a name="ln3289">      }</a>
<a name="ln3290">    }</a>
<a name="ln3291">    else if((!(self-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)) &amp;&amp; (d-&gt;mask_mode &amp; DEVELOP_MASK_MASK))</a>
<a name="ln3292">    {</a>
<a name="ln3293">      // no form defined but drawn mask active</a>
<a name="ln3294">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln3295">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_MASKS_POS) ? 0.0f : 1.0f;</a>
<a name="ln3296">#ifdef _OPENMP</a>
<a name="ln3297">  #pragma omp parallel for default(none) \</a>
<a name="ln3298">      dt_omp_firstprivate(buffsize, fill, mask)</a>
<a name="ln3299">#endif</a>
<a name="ln3300">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln3301">    }</a>
<a name="ln3302">    else</a>
<a name="ln3303">    {</a>
<a name="ln3304">      // we fill the buffer with 1.0f or 0.0f depending on mask_combine</a>
<a name="ln3305">      const float fill = (d-&gt;mask_combine &amp; DEVELOP_COMBINE_INCL) ? 0.0f : 1.0f;</a>
<a name="ln3306">#ifdef _OPENMP</a>
<a name="ln3307">  #pragma omp parallel for default(none) \</a>
<a name="ln3308">      dt_omp_firstprivate(buffsize, fill, mask)</a>
<a name="ln3309">#endif</a>
<a name="ln3310">      for(size_t i = 0; i &lt; buffsize; i++) mask[i] = fill;</a>
<a name="ln3311">    }</a>
<a name="ln3312"> </a>
<a name="ln3313">    // write mask from host to device</a>
<a name="ln3314">    dev_mask_2 = dt_opencl_alloc_device(devid, owidth, oheight, sizeof(float));</a>
<a name="ln3315">    if(dev_mask_2 == NULL) goto error;</a>
<a name="ln3316">    err = dt_opencl_write_host_to_device(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3317">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3318"> </a>
<a name="ln3319">    // The following call to clFinish() works around a bug in some OpenCL</a>
<a name="ln3320">    // drivers (namely AMD).</a>
<a name="ln3321">    // Without this synchronization point, reads to dev_in would often not</a>
<a name="ln3322">    // return the correct value.</a>
<a name="ln3323">    // This depends on the module after which blending is called. One of the</a>
<a name="ln3324">    // affected ones is sharpen.</a>
<a name="ln3325">    dt_opencl_finish(devid);</a>
<a name="ln3326"> </a>
<a name="ln3327">    // get parametric mask (if any) and apply global opacity</a>
<a name="ln3328">    const unsigned blendif = d-&gt;blendif;</a>
<a name="ln3329">    const unsigned int mask_combine = d-&gt;mask_combine;</a>
<a name="ln3330">    const int use_work_profile = (work_profile == NULL) ? 0 : 1;</a>
<a name="ln3331">    dt_opencl_set_kernel_arg(devid, kernel_mask, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3332">    dt_opencl_set_kernel_arg(devid, kernel_mask, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3333">    dt_opencl_set_kernel_arg(devid, kernel_mask, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3334">    dt_opencl_set_kernel_arg(devid, kernel_mask, 3, sizeof(cl_mem), (void *)&amp;dev_mask_2);</a>
<a name="ln3335">    dt_opencl_set_kernel_arg(devid, kernel_mask, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3336">    dt_opencl_set_kernel_arg(devid, kernel_mask, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3337">    dt_opencl_set_kernel_arg(devid, kernel_mask, 6, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3338">    dt_opencl_set_kernel_arg(devid, kernel_mask, 7, sizeof(unsigned), (void *)&amp;blendif);</a>
<a name="ln3339">    dt_opencl_set_kernel_arg(devid, kernel_mask, 8, sizeof(cl_mem), (void *)&amp;dev_m);</a>
<a name="ln3340">    dt_opencl_set_kernel_arg(devid, kernel_mask, 9, sizeof(unsigned), (void *)&amp;mask_mode);</a>
<a name="ln3341">    dt_opencl_set_kernel_arg(devid, kernel_mask, 10, sizeof(unsigned), (void *)&amp;mask_combine);</a>
<a name="ln3342">    dt_opencl_set_kernel_arg(devid, kernel_mask, 11, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3343">    dt_opencl_set_kernel_arg(devid, kernel_mask, 12, sizeof(cl_mem), (void *)&amp;dev_profile_info);</a>
<a name="ln3344">    dt_opencl_set_kernel_arg(devid, kernel_mask, 13, sizeof(cl_mem), (void *)&amp;dev_profile_lut);</a>
<a name="ln3345">    dt_opencl_set_kernel_arg(devid, kernel_mask, 14, sizeof(int), (void *)&amp;use_work_profile);</a>
<a name="ln3346">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_mask, sizes);</a>
<a name="ln3347">    if(err != CL_SUCCESS)</a>
<a name="ln3348">    {</a>
<a name="ln3349">      fprintf(stderr, &quot;[dt_develop_blend_process_cl] error %i enqueue kernel\n&quot;, err);</a>
<a name="ln3350">      goto error;</a>
<a name="ln3351">    }</a>
<a name="ln3352"> </a>
<a name="ln3353">    if(mask_feather)</a>
<a name="ln3354">    {</a>
<a name="ln3355">      int w = (int)(2 * d-&gt;feathering_radius * roi_out-&gt;scale / piece-&gt;iscale + 0.5f);</a>
<a name="ln3356">      if (w &lt; 1)</a>
<a name="ln3357">        w = 1;</a>
<a name="ln3358">      float sqrt_eps = 1.f;</a>
<a name="ln3359">      float guide_weight = 1.f;</a>
<a name="ln3360">      switch(cst)</a>
<a name="ln3361">      {</a>
<a name="ln3362">      case iop_cs_rgb:</a>
<a name="ln3363">        guide_weight = 100.f;</a>
<a name="ln3364">        break;</a>
<a name="ln3365">      case iop_cs_Lab:</a>
<a name="ln3366">        guide_weight = 1.f;</a>
<a name="ln3367">        break;</a>
<a name="ln3368">      case iop_cs_RAW:</a>
<a name="ln3369">      default:</a>
<a name="ln3370">        assert(0);</a>
<a name="ln3371">      }</a>
<a name="ln3372">      cl_mem guide = d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN ? dev_in : dev_out;</a>
<a name="ln3373">      if(!rois_equal &amp;&amp; d-&gt;feathering_guide == DEVELOP_MASK_GUIDE_IN)</a>
<a name="ln3374">      {</a>
<a name="ln3375">        dev_guide = dt_opencl_alloc_device(devid, owidth, oheight, 4 * sizeof(float));</a>
<a name="ln3376">        if(dev_guide == NULL) goto error;</a>
<a name="ln3377">        guide = dev_guide;</a>
<a name="ln3378">        size_t origin_1[] = { xoffs, yoffs, 0 };</a>
<a name="ln3379">        size_t origin_2[] = { 0, 0, 0 };</a>
<a name="ln3380">        err = dt_opencl_enqueue_copy_image(devid, dev_in, guide, origin_2, origin_1, region);</a>
<a name="ln3381">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3382">      }</a>
<a name="ln3383">      guided_filter_cl(devid, guide, dev_mask_2, dev_mask_1, owidth, oheight, ch, w, sqrt_eps, guide_weight, 0.f,</a>
<a name="ln3384">                       1.f);</a>
<a name="ln3385">      if(dev_guide)</a>
<a name="ln3386">      {</a>
<a name="ln3387">        dt_opencl_release_mem_object(dev_guide);</a>
<a name="ln3388">        dev_guide = NULL;</a>
<a name="ln3389">      }</a>
<a name="ln3390">    }</a>
<a name="ln3391">    else</a>
<a name="ln3392">    {</a>
<a name="ln3393">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3394">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3395">      dev_mask_2 = tmp;</a>
<a name="ln3396">    }</a>
<a name="ln3397"> </a>
<a name="ln3398">    if(mask_blur)</a>
<a name="ln3399">    {</a>
<a name="ln3400">      const float sigma = d-&gt;blur_radius * roi_out-&gt;scale / piece-&gt;iscale;</a>
<a name="ln3401">      const float mmax[] = { 1.0f };</a>
<a name="ln3402">      const float mmin[] = { 0.0f };</a>
<a name="ln3403"> </a>
<a name="ln3404">      dt_gaussian_cl_t *g = dt_gaussian_init_cl(devid, owidth, oheight, 1, mmax, mmin, sigma, 0);</a>
<a name="ln3405">      if(g)</a>
<a name="ln3406">      {</a>
<a name="ln3407">        dt_gaussian_blur_cl(g, dev_mask_1, dev_mask_2);</a>
<a name="ln3408">        dt_gaussian_free_cl(g);</a>
<a name="ln3409">      }</a>
<a name="ln3410">    }</a>
<a name="ln3411">    else</a>
<a name="ln3412">    {</a>
<a name="ln3413">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3414">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3415">      dev_mask_2 = tmp;</a>
<a name="ln3416">    }</a>
<a name="ln3417"> </a>
<a name="ln3418">    if(mask_tone_curve)</a>
<a name="ln3419">    {</a>
<a name="ln3420">      const float e = expf(3.f * d-&gt;contrast);</a>
<a name="ln3421">      const float brightness = d-&gt;brightness;</a>
<a name="ln3422">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 0, sizeof(cl_mem), (void *)&amp;dev_mask_2);</a>
<a name="ln3423">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 1, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3424">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 2, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3425">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 3, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3426">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 4, sizeof(float), (void *)&amp;e);</a>
<a name="ln3427">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 5, sizeof(float), (void *)&amp;brightness);</a>
<a name="ln3428">      dt_opencl_set_kernel_arg(devid, kernel_mask_tone_curve, 6, sizeof(float), (void *)&amp;opacity);</a>
<a name="ln3429">      err = dt_opencl_enqueue_kernel_2d(devid, kernel_mask_tone_curve, sizes);</a>
<a name="ln3430">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3431">    }</a>
<a name="ln3432">    else</a>
<a name="ln3433">    {</a>
<a name="ln3434">      cl_mem tmp = dev_mask_1;</a>
<a name="ln3435">      dev_mask_1 = dev_mask_2;</a>
<a name="ln3436">      dev_mask_2 = tmp;</a>
<a name="ln3437">    }</a>
<a name="ln3438"> </a>
<a name="ln3439">    // get rid of dev_mask_2</a>
<a name="ln3440">    dt_opencl_release_mem_object(dev_mask_2);</a>
<a name="ln3441">    dev_mask_2 = NULL;</a>
<a name="ln3442">  }</a>
<a name="ln3443"> </a>
<a name="ln3444">  // get temporary buffer for output image to overcome readonly/writeonly limitation</a>
<a name="ln3445">  dev_tmp = dt_opencl_alloc_device(devid, owidth, oheight, 4 * sizeof(float));</a>
<a name="ln3446">  if(dev_tmp == NULL) goto error;</a>
<a name="ln3447"> </a>
<a name="ln3448">  err = dt_opencl_enqueue_copy_image(devid, dev_out, dev_tmp, origin, origin, region);</a>
<a name="ln3449">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3450"> </a>
<a name="ln3451">  if(request_mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_ANY)</a>
<a name="ln3452">  {</a>
<a name="ln3453">    // let us display a specific channel</a>
<a name="ln3454">    const int use_work_profile = (work_profile == NULL) ? 0 : 1;</a>
<a name="ln3455">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3456">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3457">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3458">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 3, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3459">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3460">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3461">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 6, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3462">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 7, sizeof(int), (void *)&amp;request_mask_display);</a>
<a name="ln3463">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 8, sizeof(cl_mem), (void *)&amp;dev_profile_info);</a>
<a name="ln3464">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 9, sizeof(cl_mem), (void *)&amp;dev_profile_lut);</a>
<a name="ln3465">    dt_opencl_set_kernel_arg(devid, kernel_display_channel, 10, sizeof(int), (void *)&amp;use_work_profile);</a>
<a name="ln3466">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_display_channel, sizes);</a>
<a name="ln3467">    if(err != CL_SUCCESS)</a>
<a name="ln3468">    {</a>
<a name="ln3469">      fprintf(stderr, &quot;[dt_develop_blend_process_cl] error %i enqueue kernel\n&quot;, err);</a>
<a name="ln3470">      goto error;</a>
<a name="ln3471">    }</a>
<a name="ln3472">  }</a>
<a name="ln3473">  else</a>
<a name="ln3474">  {</a>
<a name="ln3475">    // apply blending with per-pixel opacity value as defined in dev_mask_1</a>
<a name="ln3476">    const unsigned int blend_mode = d-&gt;blend_mode;</a>
<a name="ln3477">    dt_opencl_set_kernel_arg(devid, kernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3478">    dt_opencl_set_kernel_arg(devid, kernel, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3479">    dt_opencl_set_kernel_arg(devid, kernel, 2, sizeof(cl_mem), (void *)&amp;dev_mask_1);</a>
<a name="ln3480">    dt_opencl_set_kernel_arg(devid, kernel, 3, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3481">    dt_opencl_set_kernel_arg(devid, kernel, 4, sizeof(int), (void *)&amp;owidth);</a>
<a name="ln3482">    dt_opencl_set_kernel_arg(devid, kernel, 5, sizeof(int), (void *)&amp;oheight);</a>
<a name="ln3483">    dt_opencl_set_kernel_arg(devid, kernel, 6, sizeof(unsigned), (void *)&amp;blend_mode);</a>
<a name="ln3484">    dt_opencl_set_kernel_arg(devid, kernel, 7, sizeof(int), (void *)&amp;blendflag);</a>
<a name="ln3485">    dt_opencl_set_kernel_arg(devid, kernel, 8, 2 * sizeof(int), (void *)&amp;offs);</a>
<a name="ln3486">    dt_opencl_set_kernel_arg(devid, kernel, 9, sizeof(int), (void *)&amp;mask_display);</a>
<a name="ln3487">    err = dt_opencl_enqueue_kernel_2d(devid, kernel, sizes);</a>
<a name="ln3488">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3489">  }</a>
<a name="ln3490"> </a>
<a name="ln3491">  // register if _this_ module should expose mask or display channel</a>
<a name="ln3492">  if(request_mask_display &amp; (DT_DEV_PIXELPIPE_DISPLAY_MASK | DT_DEV_PIXELPIPE_DISPLAY_CHANNEL))</a>
<a name="ln3493">  {</a>
<a name="ln3494">    piece-&gt;pipe-&gt;mask_display = request_mask_display;</a>
<a name="ln3495">  }</a>
<a name="ln3496"> </a>
<a name="ln3497"> </a>
<a name="ln3498">  // check if we should store the mask for export or use in subsequent modules</a>
<a name="ln3499">  // TODO: should we skip raster masks?</a>
<a name="ln3500">  if(piece-&gt;pipe-&gt;store_all_raster_masks || dt_iop_is_raster_mask_used(self, 0))</a>
<a name="ln3501">  {</a>
<a name="ln3502">    //  get back final mask from the device to store it for later use</a>
<a name="ln3503">    if(!(mask_mode &amp; DEVELOP_MASK_RASTER))</a>
<a name="ln3504">    {</a>
<a name="ln3505">      err = dt_opencl_copy_device_to_host(devid, mask, dev_mask_1, owidth, oheight, sizeof(float));</a>
<a name="ln3506">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3507">    }</a>
<a name="ln3508">    g_hash_table_replace(piece-&gt;raster_masks, GINT_TO_POINTER(0), _mask);</a>
<a name="ln3509">    }</a>
<a name="ln3510">  else</a>
<a name="ln3511">  {</a>
<a name="ln3512">    g_hash_table_remove(piece-&gt;raster_masks, GINT_TO_POINTER(0));</a>
<a name="ln3513">    dt_free_align(_mask);</a>
<a name="ln3514">  }</a>
<a name="ln3515"> </a>
<a name="ln3516">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3517">  dt_opencl_release_mem_object(dev_mask_1);</a>
<a name="ln3518">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3519">  dt_ioppr_free_iccprofile_params_cl(&amp;profile_info_cl, &amp;profile_lut_cl, &amp;dev_profile_info, &amp;dev_profile_lut);</a>
<a name="ln3520">  return TRUE;</a>
<a name="ln3521"> </a>
<a name="ln3522">error:</a>
<a name="ln3523">  dt_free_align(_mask);</a>
<a name="ln3524">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3525">  dt_opencl_release_mem_object(dev_mask_1);</a>
<a name="ln3526">  dt_opencl_release_mem_object(dev_mask_2);</a>
<a name="ln3527">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3528">  dt_opencl_release_mem_object(dev_guide);</a>
<a name="ln3529">  dt_ioppr_free_iccprofile_params_cl(&amp;profile_info_cl, &amp;profile_lut_cl, &amp;dev_profile_info, &amp;dev_profile_lut);</a>
<a name="ln3530">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_blendop] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3531">  return FALSE;</a>
<a name="ln3532">}</a>
<a name="ln3533">#endif</a>
<a name="ln3534"> </a>
<a name="ln3535">/** global init of blendops */</a>
<a name="ln3536">dt_blendop_cl_global_t *dt_develop_blend_init_cl_global(void)</a>
<a name="ln3537">{</a>
<a name="ln3538">#ifdef HAVE_OPENCL</a>
<a name="ln3539">  dt_blendop_cl_global_t *b = (dt_blendop_cl_global_t *)calloc(1, sizeof(dt_blendop_cl_global_t));</a>
<a name="ln3540"> </a>
<a name="ln3541">  const int program = 3; // blendop.cl, from programs.conf</a>
<a name="ln3542">  b-&gt;kernel_blendop_mask_Lab = dt_opencl_create_kernel(program, &quot;blendop_mask_Lab&quot;);</a>
<a name="ln3543">  b-&gt;kernel_blendop_mask_RAW = dt_opencl_create_kernel(program, &quot;blendop_mask_RAW&quot;);</a>
<a name="ln3544">  b-&gt;kernel_blendop_mask_rgb = dt_opencl_create_kernel(program, &quot;blendop_mask_rgb&quot;);</a>
<a name="ln3545">  b-&gt;kernel_blendop_Lab = dt_opencl_create_kernel(program, &quot;blendop_Lab&quot;);</a>
<a name="ln3546">  b-&gt;kernel_blendop_RAW = dt_opencl_create_kernel(program, &quot;blendop_RAW&quot;);</a>
<a name="ln3547">  b-&gt;kernel_blendop_rgb = dt_opencl_create_kernel(program, &quot;blendop_rgb&quot;);</a>
<a name="ln3548">  b-&gt;kernel_blendop_mask_tone_curve = dt_opencl_create_kernel(program, &quot;blendop_mask_tone_curve&quot;);</a>
<a name="ln3549">  b-&gt;kernel_blendop_set_mask = dt_opencl_create_kernel(program, &quot;blendop_set_mask&quot;);</a>
<a name="ln3550">  b-&gt;kernel_blendop_display_channel = dt_opencl_create_kernel(program, &quot;blendop_display_channel&quot;);</a>
<a name="ln3551">  return b;</a>
<a name="ln3552">#else</a>
<a name="ln3553">  return NULL;</a>
<a name="ln3554">#endif</a>
<a name="ln3555">}</a>
<a name="ln3556"> </a>
<a name="ln3557">/** global cleanup of blendops */</a>
<a name="ln3558">void dt_develop_blend_free_cl_global(dt_blendop_cl_global_t *b)</a>
<a name="ln3559">{</a>
<a name="ln3560">#ifdef HAVE_OPENCL</a>
<a name="ln3561">  if(!b) return;</a>
<a name="ln3562"> </a>
<a name="ln3563">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_Lab);</a>
<a name="ln3564">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_RAW);</a>
<a name="ln3565">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_rgb);</a>
<a name="ln3566">  dt_opencl_free_kernel(b-&gt;kernel_blendop_Lab);</a>
<a name="ln3567">  dt_opencl_free_kernel(b-&gt;kernel_blendop_RAW);</a>
<a name="ln3568">  dt_opencl_free_kernel(b-&gt;kernel_blendop_rgb);</a>
<a name="ln3569">  dt_opencl_free_kernel(b-&gt;kernel_blendop_mask_tone_curve);</a>
<a name="ln3570">  dt_opencl_free_kernel(b-&gt;kernel_blendop_set_mask);</a>
<a name="ln3571">  dt_opencl_free_kernel(b-&gt;kernel_blendop_display_channel);</a>
<a name="ln3572"> </a>
<a name="ln3573">  free(b);</a>
<a name="ln3574">#endif</a>
<a name="ln3575">}</a>
<a name="ln3576"> </a>
<a name="ln3577">/** blend version */</a>
<a name="ln3578">int dt_develop_blend_version(void)</a>
<a name="ln3579">{</a>
<a name="ln3580">  return DEVELOP_BLEND_VERSION;</a>
<a name="ln3581">}</a>
<a name="ln3582"> </a>
<a name="ln3583">/** report back specific memory requirements for blend step (only relevant for OpenCL path) */</a>
<a name="ln3584">void tiling_callback_blendop(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln3585">                             const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln3586">                             struct dt_develop_tiling_t *tiling)</a>
<a name="ln3587">{</a>
<a name="ln3588">  tiling-&gt;factor = 3.5f; // in + out + (guide, tmp) + two quarter buffers for the mask</a>
<a name="ln3589">  tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln3590">  tiling-&gt;overhead = 0;</a>
<a name="ln3591">  tiling-&gt;overlap = 0;</a>
<a name="ln3592">  tiling-&gt;xalign = 1;</a>
<a name="ln3593">  tiling-&gt;yalign = 1;</a>
<a name="ln3594">}</a>
<a name="ln3595"> </a>
<a name="ln3596">/** check if content of params is all zero, indicating a non-initialized set of</a>
<a name="ln3597">   blend parameters</a>
<a name="ln3598">    which needs special care. */</a>
<a name="ln3599">gboolean dt_develop_blend_params_is_all_zero(const void *params, size_t length)</a>
<a name="ln3600">{</a>
<a name="ln3601">  const char *data = (const char *)params;</a>
<a name="ln3602"> </a>
<a name="ln3603">  for(size_t k = 0; k &lt; length; k++)</a>
<a name="ln3604">    if(data[k]) return FALSE;</a>
<a name="ln3605"> </a>
<a name="ln3606">  return TRUE;</a>
<a name="ln3607">}</a>
<a name="ln3608"> </a>
<a name="ln3609">/** update blendop params from older versions */</a>
<a name="ln3610">int dt_develop_blend_legacy_params(dt_iop_module_t *module, const void *const old_params,</a>
<a name="ln3611">                                   const int old_version, void *new_params, const int new_version,</a>
<a name="ln3612">                                   const int length)</a>
<a name="ln3613">{</a>
<a name="ln3614">  // first deal with all-zero parmameter sets, regardless of version number.</a>
<a name="ln3615">  // these occurred in previous</a>
<a name="ln3616">  // darktable versions when modules</a>
<a name="ln3617">  // without blend support stored zero-initialized data in history stack. that's</a>
<a name="ln3618">  // no problem unless the module</a>
<a name="ln3619">  // gets blend</a>
<a name="ln3620">  // support later (e.g. module exposure). remedy: we simply initialize with the</a>
<a name="ln3621">  // current default blend params</a>
<a name="ln3622">  // in this case.</a>
<a name="ln3623">  if(dt_develop_blend_params_is_all_zero(old_params, length))</a>
<a name="ln3624">  {</a>
<a name="ln3625">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3626">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3627"> </a>
<a name="ln3628">    *n = *d;</a>
<a name="ln3629">    return 0;</a>
<a name="ln3630">  }</a>
<a name="ln3631"> </a>
<a name="ln3632">  if(old_version == 1 &amp;&amp; new_version == 9)</a>
<a name="ln3633">  {</a>
<a name="ln3634">    if(length != sizeof(dt_develop_blend_params1_t)) return 1;</a>
<a name="ln3635"> </a>
<a name="ln3636">    dt_develop_blend_params1_t *o = (dt_develop_blend_params1_t *)old_params;</a>
<a name="ln3637">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3638">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3639"> </a>
<a name="ln3640">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3641">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3642">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3643">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3644">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3645">    return 0;</a>
<a name="ln3646">  }</a>
<a name="ln3647"> </a>
<a name="ln3648">  if(old_version == 2 &amp;&amp; new_version == 9)</a>
<a name="ln3649">  {</a>
<a name="ln3650">    if(length != sizeof(dt_develop_blend_params2_t)) return 1;</a>
<a name="ln3651"> </a>
<a name="ln3652">    dt_develop_blend_params2_t *o = (dt_develop_blend_params2_t *)old_params;</a>
<a name="ln3653">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3654">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3655"> </a>
<a name="ln3656">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3657">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3658">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3659">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3660">                        : 0;</a>
<a name="ln3661">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3662">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3663">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3664">    n-&gt;blendif = o-&gt;blendif &amp; 0xff; // only just in case: knock out all bits</a>
<a name="ln3665">                                    // which were undefined in version</a>
<a name="ln3666">                                    // 2; also switch off old &quot;active&quot; bit</a>
<a name="ln3667">    for(int i = 0; i &lt; (4 * 8); i++) n-&gt;blendif_parameters[i] = o-&gt;blendif_parameters[i];</a>
<a name="ln3668"> </a>
<a name="ln3669">    return 0;</a>
<a name="ln3670">  }</a>
<a name="ln3671"> </a>
<a name="ln3672">  if(old_version == 3 &amp;&amp; new_version == 9)</a>
<a name="ln3673">  {</a>
<a name="ln3674">    if(length != sizeof(dt_develop_blend_params3_t)) return 1;</a>
<a name="ln3675"> </a>
<a name="ln3676">    dt_develop_blend_params3_t *o = (dt_develop_blend_params3_t *)old_params;</a>
<a name="ln3677">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3678">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3679"> </a>
<a name="ln3680">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3681">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3682">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3683">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3684">                        : 0;</a>
<a name="ln3685">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3686">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3687">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3688">    n-&gt;blendif = o-&gt;blendif &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active); // knock out old unused &quot;active&quot; flag</a>
<a name="ln3689">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3690"> </a>
<a name="ln3691">    return 0;</a>
<a name="ln3692">  }</a>
<a name="ln3693"> </a>
<a name="ln3694">  if(old_version == 4 &amp;&amp; new_version == 9)</a>
<a name="ln3695">  {</a>
<a name="ln3696">    if(length != sizeof(dt_develop_blend_params4_t)) return 1;</a>
<a name="ln3697"> </a>
<a name="ln3698">    dt_develop_blend_params4_t *o = (dt_develop_blend_params4_t *)old_params;</a>
<a name="ln3699">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3700">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3701"> </a>
<a name="ln3702">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3703">    n-&gt;mask_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_MASK_DISABLED : DEVELOP_MASK_ENABLED;</a>
<a name="ln3704">    n-&gt;mask_mode |= ((o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active)) &amp;&amp; (n-&gt;mask_mode == DEVELOP_MASK_ENABLED))</a>
<a name="ln3705">                        ? DEVELOP_MASK_CONDITIONAL</a>
<a name="ln3706">                        : 0;</a>
<a name="ln3707">    n-&gt;blend_mode = (o-&gt;mode == DEVELOP_BLEND_DISABLED) ? DEVELOP_BLEND_NORMAL2 : o-&gt;mode;</a>
<a name="ln3708">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3709">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3710">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3711">    n-&gt;blendif = o-&gt;blendif &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active); // knock out old unused &quot;active&quot; flag</a>
<a name="ln3712">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3713"> </a>
<a name="ln3714">    return 0;</a>
<a name="ln3715">  }</a>
<a name="ln3716"> </a>
<a name="ln3717">  if(old_version == 5 &amp;&amp; new_version == 9)</a>
<a name="ln3718">  {</a>
<a name="ln3719">    if(length != sizeof(dt_develop_blend_params5_t)) return 1;</a>
<a name="ln3720"> </a>
<a name="ln3721">    dt_develop_blend_params5_t *o = (dt_develop_blend_params5_t *)old_params;</a>
<a name="ln3722">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3723">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3724"> </a>
<a name="ln3725">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3726">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3727">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3728">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3729">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3730">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3731">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3732">    // this is needed as version 5 contained a bug which screwed up history</a>
<a name="ln3733">    // stacks of even older</a>
<a name="ln3734">    // versions. potentially bad history stacks can be identified by an active</a>
<a name="ln3735">    // bit no. 32 in blendif.</a>
<a name="ln3736">    n-&gt;blendif = (o-&gt;blendif &amp; (1u &lt;&lt; DEVELOP_BLENDIF_active) ? o-&gt;blendif | 31 : o-&gt;blendif)</a>
<a name="ln3737">                 &amp; ~(1u &lt;&lt; DEVELOP_BLENDIF_active);</a>
<a name="ln3738">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3739"> </a>
<a name="ln3740">    return 0;</a>
<a name="ln3741">  }</a>
<a name="ln3742"> </a>
<a name="ln3743">  if(old_version == 6 &amp;&amp; new_version == 9)</a>
<a name="ln3744">  {</a>
<a name="ln3745">    if(length != sizeof(dt_develop_blend_params6_t)) return 1;</a>
<a name="ln3746"> </a>
<a name="ln3747">    dt_develop_blend_params6_t *o = (dt_develop_blend_params6_t *)old_params;</a>
<a name="ln3748">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3749">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3750"> </a>
<a name="ln3751">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3752">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3753">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3754">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3755">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3756">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3757">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3758">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3759">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3760">    return 0;</a>
<a name="ln3761">  }</a>
<a name="ln3762"> </a>
<a name="ln3763">  if(old_version == 7 &amp;&amp; new_version == 9)</a>
<a name="ln3764">  {</a>
<a name="ln3765">    if(length != sizeof(dt_develop_blend_params7_t)) return 1;</a>
<a name="ln3766"> </a>
<a name="ln3767">    dt_develop_blend_params7_t *o = (dt_develop_blend_params7_t *)old_params;</a>
<a name="ln3768">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3769">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3770"> </a>
<a name="ln3771">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3772">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3773">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3774">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3775">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3776">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3777">    n-&gt;blur_radius = o-&gt;radius;</a>
<a name="ln3778">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3779">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3780">    return 0;</a>
<a name="ln3781">  }</a>
<a name="ln3782"> </a>
<a name="ln3783">  if(old_version == 8 &amp;&amp; new_version == 9)</a>
<a name="ln3784">  {</a>
<a name="ln3785">    if(length != sizeof(dt_develop_blend_params8_t)) return 1;</a>
<a name="ln3786"> </a>
<a name="ln3787">    dt_develop_blend_params8_t *o = (dt_develop_blend_params8_t *)old_params;</a>
<a name="ln3788">    dt_develop_blend_params_t *n = (dt_develop_blend_params_t *)new_params;</a>
<a name="ln3789">    dt_develop_blend_params_t *d = (dt_develop_blend_params_t *)module-&gt;default_blendop_params;</a>
<a name="ln3790"> </a>
<a name="ln3791">    *n = *d; // start with a fresh copy of default parameters</a>
<a name="ln3792">    n-&gt;mask_mode = o-&gt;mask_mode;</a>
<a name="ln3793">    n-&gt;blend_mode = o-&gt;blend_mode;</a>
<a name="ln3794">    n-&gt;opacity = o-&gt;opacity;</a>
<a name="ln3795">    n-&gt;mask_combine = o-&gt;mask_combine;</a>
<a name="ln3796">    n-&gt;mask_id = o-&gt;mask_id;</a>
<a name="ln3797">    n-&gt;blendif = o-&gt;blendif;</a>
<a name="ln3798">    n-&gt;feathering_radius = o-&gt;feathering_radius;</a>
<a name="ln3799">    n-&gt;feathering_guide = o-&gt;feathering_guide;</a>
<a name="ln3800">    n-&gt;blur_radius = o-&gt;blur_radius;</a>
<a name="ln3801">    n-&gt;contrast = o-&gt;contrast;</a>
<a name="ln3802">    n-&gt;brightness = o-&gt;brightness;</a>
<a name="ln3803">    memcpy(n-&gt;blendif_parameters, o-&gt;blendif_parameters, 4 * DEVELOP_BLENDIF_SIZE * sizeof(float));</a>
<a name="ln3804">    return 0;</a>
<a name="ln3805">  }</a>
<a name="ln3806"> </a>
<a name="ln3807">  return 1;</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">int dt_develop_blend_legacy_params_from_so(dt_iop_module_so_t *module_so, const void *const old_params,</a>
<a name="ln3811">                                           const int old_version, void *new_params, const int new_version,</a>
<a name="ln3812">                                           const int length)</a>
<a name="ln3813">{</a>
<a name="ln3814">  // we need a dt_iop_module_t for dt_develop_blend_legacy_params()</a>
<a name="ln3815">  dt_iop_module_t *module;</a>
<a name="ln3816">  module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln3817">  if(dt_iop_load_module_by_so(module, module_so, NULL))</a>
<a name="ln3818">  {</a>
<a name="ln3819">    free(module);</a>
<a name="ln3820">    return 1;</a>
<a name="ln3821">  }</a>
<a name="ln3822"> </a>
<a name="ln3823">  if(module-&gt;params_size == 0)</a>
<a name="ln3824">  {</a>
<a name="ln3825">    dt_iop_cleanup_module(module);</a>
<a name="ln3826">    free(module);</a>
<a name="ln3827">    return 1;</a>
<a name="ln3828">  }</a>
<a name="ln3829"> </a>
<a name="ln3830">  // convert the old blend params to new</a>
<a name="ln3831">  int res = dt_develop_blend_legacy_params(module, old_params, old_version,</a>
<a name="ln3832">                                           new_params, dt_develop_blend_version(),</a>
<a name="ln3833">                                           length);</a>
<a name="ln3834">  dt_iop_cleanup_module(module);</a>
<a name="ln3835">  free(module);</a>
<a name="ln3836">  return res;</a>
<a name="ln3837">}</a>
<a name="ln3838"> </a>
<a name="ln3839">// tools/update_modelines.sh</a>
<a name="ln3840">// remove-trailing-space on;</a>
<a name="ln3841">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3842">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3843">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1063"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: '((lmax - (lmax - la) * (lmax - lb)))'. One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="3077"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3081"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_remove' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3508"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3512"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_hash_table_remove' function. Inspect the second argument.</p></div>
<div class="balloon" rel="3542"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'b'. Check lines: 3542, 3539.</p></div>
<div class="balloon" rel="3823"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 3823, 3816.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
