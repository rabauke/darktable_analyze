
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2012 johannes hanika.</a>
<a name="ln4">    copyright (c) 2010--2012 henrik andersson.</a>
<a name="ln5">    copyright (c) 2010--2012 tobias ellinghaus.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20">#ifdef HAVE_CONFIG_H</a>
<a name="ln21">#include &quot;config.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23"> </a>
<a name="ln24">#if !defined(__APPLE__) &amp;&amp; !defined(__FreeBSD__) &amp;&amp; !defined(__OpenBSD__) &amp;&amp; !defined(__DragonFly__)</a>
<a name="ln25">#include &lt;malloc.h&gt;</a>
<a name="ln26">#endif</a>
<a name="ln27">#ifdef __APPLE__</a>
<a name="ln28">#include &lt;sys/malloc.h&gt;</a>
<a name="ln29">#endif</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;common/collection.h&quot;</a>
<a name="ln32">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln33">#include &quot;common/darktable.h&quot;</a>
<a name="ln34">#include &quot;common/exif.h&quot;</a>
<a name="ln35">#include &quot;common/pwstorage/pwstorage.h&quot;</a>
<a name="ln36">#include &quot;common/selection.h&quot;</a>
<a name="ln37">#include &quot;common/system_signal_handling.h&quot;</a>
<a name="ln38">#ifdef HAVE_GPHOTO2</a>
<a name="ln39">#include &quot;common/camera_control.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln42">#include &quot;common/cpuid.h&quot;</a>
<a name="ln43">#include &quot;common/film.h&quot;</a>
<a name="ln44">#include &quot;common/grealpath.h&quot;</a>
<a name="ln45">#include &quot;common/image.h&quot;</a>
<a name="ln46">#include &quot;common/image_cache.h&quot;</a>
<a name="ln47">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln48">#include &quot;common/l10n.h&quot;</a>
<a name="ln49">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln50">#include &quot;common/noiseprofiles.h&quot;</a>
<a name="ln51">#include &quot;common/opencl.h&quot;</a>
<a name="ln52">#include &quot;common/points.h&quot;</a>
<a name="ln53">#include &quot;common/resource_limits.h&quot;</a>
<a name="ln54">#include &quot;common/undo.h&quot;</a>
<a name="ln55">#include &quot;control/conf.h&quot;</a>
<a name="ln56">#include &quot;control/control.h&quot;</a>
<a name="ln57">#include &quot;control/crawler.h&quot;</a>
<a name="ln58">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln59">#include &quot;control/signal.h&quot;</a>
<a name="ln60">#include &quot;develop/blend.h&quot;</a>
<a name="ln61">#include &quot;develop/imageop.h&quot;</a>
<a name="ln62">#include &quot;gui/gtk.h&quot;</a>
<a name="ln63">#include &quot;gui/guides.h&quot;</a>
<a name="ln64">#include &quot;gui/presets.h&quot;</a>
<a name="ln65">#include &quot;libs/lib.h&quot;</a>
<a name="ln66">#include &quot;lua/init.h&quot;</a>
<a name="ln67">#include &quot;views/view.h&quot;</a>
<a name="ln68">#include &lt;errno.h&gt;</a>
<a name="ln69">#include &lt;glib.h&gt;</a>
<a name="ln70">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln71">#include &lt;stdint.h&gt;</a>
<a name="ln72">#include &lt;stdio.h&gt;</a>
<a name="ln73">#include &lt;stdlib.h&gt;</a>
<a name="ln74">#include &lt;string.h&gt;</a>
<a name="ln75">#include &lt;sys/param.h&gt;</a>
<a name="ln76">#include &lt;sys/types.h&gt;</a>
<a name="ln77">#include &lt;unistd.h&gt;</a>
<a name="ln78">#include &lt;locale.h&gt;</a>
<a name="ln79"> </a>
<a name="ln80">#if defined(__SSE__)</a>
<a name="ln81">#include &lt;xmmintrin.h&gt;</a>
<a name="ln82">#endif</a>
<a name="ln83"> </a>
<a name="ln84">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln85">#include &lt;magick/api.h&gt;</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88">#include &quot;dbus.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">#if defined(__SUNOS__)</a>
<a name="ln91">#include &lt;sys/varargs.h&gt;</a>
<a name="ln92">#endif</a>
<a name="ln93"> </a>
<a name="ln94">#ifdef _OPENMP</a>
<a name="ln95">#include &lt;omp.h&gt;</a>
<a name="ln96">#endif</a>
<a name="ln97"> </a>
<a name="ln98">#ifdef USE_LUA</a>
<a name="ln99">#include &quot;lua/configuration.h&quot;</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">darktable_t darktable;</a>
<a name="ln103"> </a>
<a name="ln104">static int usage(const char *argv0)</a>
<a name="ln105">{</a>
<a name="ln106">#ifdef _WIN32</a>
<a name="ln107">  char *logfile = g_build_filename(g_get_user_cache_dir(), &quot;darktable&quot;, &quot;darktable-log.txt&quot;, NULL);</a>
<a name="ln108">#endif</a>
<a name="ln109"> </a>
<a name="ln110">  printf(&quot;usage: %s [options] [IMG_1234.{RAW,..}|image_folder/]\n&quot;, argv0);</a>
<a name="ln111">  printf(&quot;\n&quot;);</a>
<a name="ln112">  printf(&quot;options:\n&quot;);</a>
<a name="ln113">  printf(&quot;\n&quot;);</a>
<a name="ln114">  printf(&quot;  --cachedir &lt;user cache directory&gt;\n&quot;);</a>
<a name="ln115">  printf(&quot;  --conf &lt;key&gt;=&lt;value&gt;\n&quot;);</a>
<a name="ln116">  printf(&quot;  --configdir &lt;user config directory&gt;\n&quot;);</a>
<a name="ln117">  printf(&quot;  -d {all,cache,camctl,camsupport,control,dev,fswatch,input,lighttable,\n&quot;);</a>
<a name="ln118">  printf(&quot;      lua, masks,memory,nan,opencl,perf,pwstorage,print,sql}\n&quot;);</a>
<a name="ln119">  printf(&quot;  --datadir &lt;data directory&gt;\n&quot;);</a>
<a name="ln120">#ifdef HAVE_OPENCL</a>
<a name="ln121">  printf(&quot;  --disable-opencl\n&quot;);</a>
<a name="ln122">#endif</a>
<a name="ln123">  printf(&quot;  -h, --help&quot;);</a>
<a name="ln124">#ifdef _WIN32</a>
<a name="ln125">  printf(&quot;, /?&quot;);</a>
<a name="ln126">#endif</a>
<a name="ln127">  printf(&quot;\n&quot;);</a>
<a name="ln128">  printf(&quot;  --library &lt;library file&gt;\n&quot;);</a>
<a name="ln129">  printf(&quot;  --localedir &lt;locale directory&gt;\n&quot;);</a>
<a name="ln130">#ifdef USE_LUA</a>
<a name="ln131">  printf(&quot;  --luacmd &lt;lua command&gt;\n&quot;);</a>
<a name="ln132">#endif</a>
<a name="ln133">  printf(&quot;  --moduledir &lt;module directory&gt;\n&quot;);</a>
<a name="ln134">  printf(&quot;  --noiseprofiles &lt;noiseprofiles json file&gt;\n&quot;);</a>
<a name="ln135">  printf(&quot;  -t &lt;num openmp threads&gt;\n&quot;);</a>
<a name="ln136">  printf(&quot;  --tmpdir &lt;tmp directory&gt;\n&quot;);</a>
<a name="ln137">  printf(&quot;  --version\n&quot;);</a>
<a name="ln138">#ifdef _WIN32</a>
<a name="ln139">  printf(&quot;\n&quot;);</a>
<a name="ln140">  printf(&quot;  note: debug log and output will be written to this file:\n&quot;);</a>
<a name="ln141">  printf(&quot;        %s\n&quot;, logfile);</a>
<a name="ln142">#endif</a>
<a name="ln143"> </a>
<a name="ln144">#ifdef _WIN32</a>
<a name="ln145">  g_free(logfile);</a>
<a name="ln146">#endif</a>
<a name="ln147"> </a>
<a name="ln148">  return 1;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">gboolean dt_supported_image(const gchar *filename)</a>
<a name="ln152">{</a>
<a name="ln153">  gboolean supported = FALSE;</a>
<a name="ln154">  char *ext = g_strrstr(filename, &quot;.&quot;);</a>
<a name="ln155">  if(!ext)</a>
<a name="ln156">    return FALSE;</a>
<a name="ln157">  ext++;</a>
<a name="ln158">  for(const char **i = dt_supported_extensions; *i != NULL; i++)</a>
<a name="ln159">    if(!g_ascii_strncasecmp(ext, *i, strlen(*i)))</a>
<a name="ln160">    {</a>
<a name="ln161">      supported = TRUE;</a>
<a name="ln162">      break;</a>
<a name="ln163">    }</a>
<a name="ln164">  return supported;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">static void strip_semicolons_from_keymap(const char *path)</a>
<a name="ln168">{</a>
<a name="ln169">  char pathtmp[PATH_MAX] = { 0 };</a>
<a name="ln170">  FILE *fin = g_fopen(path, &quot;rb&quot;);</a>
<a name="ln171">  FILE *fout;</a>
<a name="ln172">  int i;</a>
<a name="ln173">  int c = '\0';</a>
<a name="ln174"> </a>
<a name="ln175">  if(!fin) return;</a>
<a name="ln176"> </a>
<a name="ln177">  snprintf(pathtmp, sizeof(pathtmp), &quot;%s_tmp&quot;, path);</a>
<a name="ln178">  fout = g_fopen(pathtmp, &quot;wb&quot;);</a>
<a name="ln179"> </a>
<a name="ln180">  if(!fout)</a>
<a name="ln181">  {</a>
<a name="ln182">    fclose(fin);</a>
<a name="ln183">    return;</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  // First ignoring the first three lines</a>
<a name="ln187">  for(i = 0; i &lt; 3; i++)</a>
<a name="ln188">  {</a>
<a name="ln189">    while(c != '\n' &amp;&amp; c != '\r' &amp;&amp; c != EOF) c = fgetc(fin);</a>
<a name="ln190">    while(c == '\n' || c == '\r') c = fgetc(fin);</a>
<a name="ln191">  }</a>
<a name="ln192"> </a>
<a name="ln193">  // Then ignore the first two characters of each line, copying the rest out</a>
<a name="ln194">  while(c != EOF)</a>
<a name="ln195">  {</a>
<a name="ln196">    fseek(fin, 2, SEEK_CUR);</a>
<a name="ln197">    do</a>
<a name="ln198">    {</a>
<a name="ln199">      c = fgetc(fin);</a>
<a name="ln200">      if(c != EOF) fputc(c, fout);</a>
<a name="ln201">    } while(c != '\n' &amp;&amp; c != '\r' &amp;&amp; c != EOF);</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  fclose(fin);</a>
<a name="ln205">  fclose(fout);</a>
<a name="ln206"> </a>
<a name="ln207">  GFile *gpath = g_file_new_for_path(path);</a>
<a name="ln208">  GFile *gpathtmp = g_file_new_for_path(pathtmp);</a>
<a name="ln209"> </a>
<a name="ln210">  g_file_delete(gpath, NULL, NULL);</a>
<a name="ln211">  g_file_move(gpathtmp, gpath, 0, NULL, NULL, NULL, NULL);</a>
<a name="ln212">  g_object_unref(gpath);</a>
<a name="ln213">  g_object_unref(gpathtmp);</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">int dt_load_from_string(const gchar *input, gboolean open_image_in_dr, gboolean *single_image)</a>
<a name="ln217">{</a>
<a name="ln218">  int id = 0;</a>
<a name="ln219">  if(input == NULL || input[0] == '\0') return 0;</a>
<a name="ln220"> </a>
<a name="ln221">  char *filename = dt_util_normalize_path(input);</a>
<a name="ln222"> </a>
<a name="ln223">  if(filename == NULL)</a>
<a name="ln224">  {</a>
<a name="ln225">    dt_control_log(_(&quot;found strange path `%s'&quot;), input);</a>
<a name="ln226">    return 0;</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  if(g_file_test(filename, G_FILE_TEST_IS_DIR))</a>
<a name="ln230">  {</a>
<a name="ln231">    // import a directory into a film roll</a>
<a name="ln232">    unsigned int last_char = strlen(filename) - 1;</a>
<a name="ln233">    if(filename[last_char] == '/') filename[last_char] = '\0';</a>
<a name="ln234">    id = dt_film_import(filename);</a>
<a name="ln235">    if(id)</a>
<a name="ln236">    {</a>
<a name="ln237">      dt_film_open(id);</a>
<a name="ln238">      dt_ctl_switch_mode_to(&quot;lighttable&quot;);</a>
<a name="ln239">    }</a>
<a name="ln240">    else</a>
<a name="ln241">    {</a>
<a name="ln242">      dt_control_log(_(&quot;error loading directory `%s'&quot;), filename);</a>
<a name="ln243">    }</a>
<a name="ln244">    if(single_image) *single_image = FALSE;</a>
<a name="ln245">  }</a>
<a name="ln246">  else</a>
<a name="ln247">  {</a>
<a name="ln248">    // import a single image</a>
<a name="ln249">    gchar *directory = g_path_get_dirname((const gchar *)filename);</a>
<a name="ln250">    dt_film_t film;</a>
<a name="ln251">    const int filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln252">    id = dt_image_import(filmid, filename, TRUE);</a>
<a name="ln253">    g_free(directory);</a>
<a name="ln254">    if(id)</a>
<a name="ln255">    {</a>
<a name="ln256">      dt_film_open(filmid);</a>
<a name="ln257">      // make sure buffers are loaded (load full for testing)</a>
<a name="ln258">      dt_mipmap_buffer_t buf;</a>
<a name="ln259">      dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, id, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln260">      gboolean loaded = (buf.buf != NULL);</a>
<a name="ln261">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln262">      if(!loaded)</a>
<a name="ln263">      {</a>
<a name="ln264">        id = 0;</a>
<a name="ln265">        dt_control_log(_(&quot;file `%s' has unknown format!&quot;), filename);</a>
<a name="ln266">      }</a>
<a name="ln267">      else</a>
<a name="ln268">      {</a>
<a name="ln269">        if(open_image_in_dr)</a>
<a name="ln270">        {</a>
<a name="ln271">          dt_control_set_mouse_over_id(id);</a>
<a name="ln272">          dt_ctl_switch_mode_to(&quot;darkroom&quot;);</a>
<a name="ln273">        }</a>
<a name="ln274">      }</a>
<a name="ln275">    }</a>
<a name="ln276">    else</a>
<a name="ln277">    {</a>
<a name="ln278">      dt_control_log(_(&quot;error loading file `%s'&quot;), filename);</a>
<a name="ln279">    }</a>
<a name="ln280">    if(single_image) *single_image = TRUE;</a>
<a name="ln281">  }</a>
<a name="ln282">  g_free(filename);</a>
<a name="ln283">  return id;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">static void dt_codepaths_init()</a>
<a name="ln287">{</a>
<a name="ln288">#ifdef HAVE_BUILTIN_CPU_SUPPORTS</a>
<a name="ln289">  __builtin_cpu_init();</a>
<a name="ln290">#endif</a>
<a name="ln291"> </a>
<a name="ln292">  memset(&amp;(darktable.codepath), 0, sizeof(darktable.codepath));</a>
<a name="ln293"> </a>
<a name="ln294">  // first, enable whatever codepath this CPU supports</a>
<a name="ln295">  {</a>
<a name="ln296">#ifdef HAVE_BUILTIN_CPU_SUPPORTS</a>
<a name="ln297">    darktable.codepath.SSE2 = (__builtin_cpu_supports(&quot;sse&quot;) &amp;&amp; __builtin_cpu_supports(&quot;sse2&quot;));</a>
<a name="ln298">#else</a>
<a name="ln299">    dt_cpu_flags_t flags = dt_detect_cpu_features();</a>
<a name="ln300">    darktable.codepath.SSE2 = ((flags &amp; (CPU_FLAG_SSE)) &amp;&amp; (flags &amp; (CPU_FLAG_SSE2)));</a>
<a name="ln301">#endif</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  // second, apply overrides from conf</a>
<a name="ln305">  // NOTE: all intrinsics sets can only be overridden to OFF</a>
<a name="ln306">  if(!dt_conf_get_bool(&quot;codepaths/sse2&quot;)) darktable.codepath.SSE2 = 0;</a>
<a name="ln307"> </a>
<a name="ln308">  // last: do we have any intrinsics sets enabled?</a>
<a name="ln309">  darktable.codepath._no_intrinsics = !(darktable.codepath.SSE2);</a>
<a name="ln310"> </a>
<a name="ln311">// if there is no SSE, we must enable plain codepath by default,</a>
<a name="ln312">// else, enable it conditionally.</a>
<a name="ln313">#if defined(__SSE__)</a>
<a name="ln314">  // disabled by default, needs to be manually enabled if needed.</a>
<a name="ln315">  // disabling all optimized codepaths enables it automatically.</a>
<a name="ln316">  if(dt_conf_get_bool(&quot;codepaths/openmp_simd&quot;) || darktable.codepath._no_intrinsics)</a>
<a name="ln317">#endif</a>
<a name="ln318">  {</a>
<a name="ln319">    darktable.codepath.OPENMP_SIMD = 1;</a>
<a name="ln320">    fprintf(stderr, &quot;[dt_codepaths_init] will be using HIGHLY EXPERIMENTAL plain OpenMP SIMD codepath.\n&quot;);</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">#if defined(__SSE__)</a>
<a name="ln324">  if(darktable.codepath._no_intrinsics)</a>
<a name="ln325">#endif</a>
<a name="ln326">  {</a>
<a name="ln327">    fprintf(stderr, &quot;[dt_codepaths_init] SSE2-optimized codepath is disabled or unavailable.\n&quot;);</a>
<a name="ln328">    fprintf(stderr,</a>
<a name="ln329">            &quot;[dt_codepaths_init] expect a LOT of functionality to be broken. you have been warned.\n&quot;);</a>
<a name="ln330">  }</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">int dt_init(int argc, char *argv[], const gboolean init_gui, const gboolean load_data, lua_State *L)</a>
<a name="ln334">{</a>
<a name="ln335">  double start_wtime = dt_get_wtime();</a>
<a name="ln336"> </a>
<a name="ln337">#ifndef _WIN32</a>
<a name="ln338">  if(getuid() == 0 || geteuid() == 0)</a>
<a name="ln339">    printf(</a>
<a name="ln340">        &quot;WARNING: either your user id or the effective user id are 0. are you running darktable as root?\n&quot;);</a>
<a name="ln341">#endif</a>
<a name="ln342"> </a>
<a name="ln343">#if defined(__SSE__)</a>
<a name="ln344">  // make everything go a lot faster.</a>
<a name="ln345">  _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);</a>
<a name="ln346">#endif</a>
<a name="ln347"> </a>
<a name="ln348">  dt_set_signal_handlers();</a>
<a name="ln349"> </a>
<a name="ln350">#include &quot;is_supported_platform.h&quot;</a>
<a name="ln351"> </a>
<a name="ln352">  int sse2_supported = 0;</a>
<a name="ln353"> </a>
<a name="ln354">#ifdef HAVE_BUILTIN_CPU_SUPPORTS</a>
<a name="ln355">  // NOTE: _may_i_use_cpu_feature() looks better, but only available in ICC</a>
<a name="ln356">  __builtin_cpu_init();</a>
<a name="ln357">  sse2_supported = __builtin_cpu_supports(&quot;sse2&quot;);</a>
<a name="ln358">#else</a>
<a name="ln359">  sse2_supported = dt_detect_cpu_features() &amp; CPU_FLAG_SSE2;</a>
<a name="ln360">#endif</a>
<a name="ln361">  if(!sse2_supported)</a>
<a name="ln362">  {</a>
<a name="ln363">    fprintf(stderr, &quot;[dt_init] SSE2 instruction set is unavailable.\n&quot;);</a>
<a name="ln364">    fprintf(stderr, &quot;[dt_init] expect a LOT of functionality to be broken. you have been warned.\n&quot;);</a>
<a name="ln365">  }</a>
<a name="ln366"> </a>
<a name="ln367">#ifdef M_MMAP_THRESHOLD</a>
<a name="ln368">  mallopt(M_MMAP_THRESHOLD, 128 * 1024); /* use mmap() for large allocations */</a>
<a name="ln369">#endif</a>
<a name="ln370"> </a>
<a name="ln371">  // make sure that stack/frame limits are good (musl)</a>
<a name="ln372">  dt_set_rlimits();</a>
<a name="ln373"> </a>
<a name="ln374">  // we have to have our share dir in XDG_DATA_DIRS,</a>
<a name="ln375">  // otherwise GTK+ won't find our logo for the about screen (and maybe other things)</a>
<a name="ln376">  {</a>
<a name="ln377">    const gchar *xdg_data_dirs = g_getenv(&quot;XDG_DATA_DIRS&quot;);</a>
<a name="ln378">    gchar *new_xdg_data_dirs = NULL;</a>
<a name="ln379">    gboolean set_env = TRUE;</a>
<a name="ln380">    if(xdg_data_dirs != NULL &amp;&amp; *xdg_data_dirs != '\0')</a>
<a name="ln381">    {</a>
<a name="ln382">      // check if DARKTABLE_SHAREDIR is already in there</a>
<a name="ln383">      gboolean found = FALSE;</a>
<a name="ln384">      gchar **tokens = g_strsplit(xdg_data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);</a>
<a name="ln385">      // xdg_data_dirs is neither NULL nor empty =&gt; tokens != NULL</a>
<a name="ln386">      for(char **iter = tokens; *iter != NULL; iter++)</a>
<a name="ln387">        if(!strcmp(DARKTABLE_SHAREDIR, *iter))</a>
<a name="ln388">        {</a>
<a name="ln389">          found = TRUE;</a>
<a name="ln390">          break;</a>
<a name="ln391">        }</a>
<a name="ln392">      g_strfreev(tokens);</a>
<a name="ln393">      if(found)</a>
<a name="ln394">        set_env = FALSE;</a>
<a name="ln395">      else</a>
<a name="ln396">        new_xdg_data_dirs = g_strjoin(G_SEARCHPATH_SEPARATOR_S, DARKTABLE_SHAREDIR, xdg_data_dirs, NULL);</a>
<a name="ln397">    }</a>
<a name="ln398">    else</a>
<a name="ln399">    {</a>
<a name="ln400">#ifndef _WIN32</a>
<a name="ln401">      // see http://standards.freedesktop.org/basedir-spec/latest/ar01s03.html for a reason to use those as a</a>
<a name="ln402">      // default</a>
<a name="ln403">      if(!g_strcmp0(DARKTABLE_SHAREDIR, &quot;/usr/local/share&quot;)</a>
<a name="ln404">         || !g_strcmp0(DARKTABLE_SHAREDIR, &quot;/usr/local/share/&quot;)</a>
<a name="ln405">         || !g_strcmp0(DARKTABLE_SHAREDIR, &quot;/usr/share&quot;) || !g_strcmp0(DARKTABLE_SHAREDIR, &quot;/usr/share/&quot;))</a>
<a name="ln406">        new_xdg_data_dirs = g_strdup(&quot;/usr/local/share/&quot; G_SEARCHPATH_SEPARATOR_S &quot;/usr/share/&quot;);</a>
<a name="ln407">      else</a>
<a name="ln408">        new_xdg_data_dirs = g_strdup_printf(&quot;%s&quot; G_SEARCHPATH_SEPARATOR_S &quot;/usr/local/share/&quot; G_SEARCHPATH_SEPARATOR_S</a>
<a name="ln409">                                            &quot;/usr/share/&quot;, DARKTABLE_SHAREDIR);</a>
<a name="ln410">#else</a>
<a name="ln411">      set_env = FALSE;</a>
<a name="ln412">#endif</a>
<a name="ln413">    }</a>
<a name="ln414"> </a>
<a name="ln415">    if(set_env) g_setenv(&quot;XDG_DATA_DIRS&quot;, new_xdg_data_dirs, 1);</a>
<a name="ln416">    g_free(new_xdg_data_dirs);</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  setlocale(LC_ALL, &quot;&quot;);</a>
<a name="ln420">  bindtextdomain(GETTEXT_PACKAGE, DARKTABLE_LOCALEDIR);</a>
<a name="ln421">  bind_textdomain_codeset(GETTEXT_PACKAGE, &quot;UTF-8&quot;);</a>
<a name="ln422">  textdomain(GETTEXT_PACKAGE);</a>
<a name="ln423"> </a>
<a name="ln424">  // init all pointers to 0:</a>
<a name="ln425">  memset(&amp;darktable, 0, sizeof(darktable_t));</a>
<a name="ln426"> </a>
<a name="ln427">  darktable.start_wtime = start_wtime;</a>
<a name="ln428"> </a>
<a name="ln429">  darktable.progname = argv[0];</a>
<a name="ln430"> </a>
<a name="ln431">  // FIXME: move there into dt_database_t</a>
<a name="ln432">  dt_pthread_mutex_init(&amp;(darktable.db_insert), NULL);</a>
<a name="ln433">  dt_pthread_mutex_init(&amp;(darktable.plugin_threadsafe), NULL);</a>
<a name="ln434">  dt_pthread_mutex_init(&amp;(darktable.capabilities_threadsafe), NULL);</a>
<a name="ln435">  dt_pthread_mutex_init(&amp;(darktable.exiv2_threadsafe), NULL);</a>
<a name="ln436">  darktable.control = (dt_control_t *)calloc(1, sizeof(dt_control_t));</a>
<a name="ln437"> </a>
<a name="ln438">  // database</a>
<a name="ln439">  char *dbfilename_from_command = NULL;</a>
<a name="ln440">  char *noiseprofiles_from_command = NULL;</a>
<a name="ln441">  char *datadir_from_command = NULL;</a>
<a name="ln442">  char *moduledir_from_command = NULL;</a>
<a name="ln443">  char *localedir_from_command = NULL;</a>
<a name="ln444">  char *tmpdir_from_command = NULL;</a>
<a name="ln445">  char *configdir_from_command = NULL;</a>
<a name="ln446">  char *cachedir_from_command = NULL;</a>
<a name="ln447"> </a>
<a name="ln448">#ifdef HAVE_OPENCL</a>
<a name="ln449">  gboolean exclude_opencl = FALSE;</a>
<a name="ln450">  gboolean print_statistics = (strstr(argv[0], &quot;darktable-cltest&quot;) == NULL);</a>
<a name="ln451">#endif</a>
<a name="ln452"> </a>
<a name="ln453">#ifdef USE_LUA</a>
<a name="ln454">  char *lua_command = NULL;</a>
<a name="ln455">#endif</a>
<a name="ln456"> </a>
<a name="ln457">  darktable.num_openmp_threads = 1;</a>
<a name="ln458">#ifdef _OPENMP</a>
<a name="ln459">  darktable.num_openmp_threads = omp_get_num_procs();</a>
<a name="ln460">#endif</a>
<a name="ln461">  darktable.unmuted = 0;</a>
<a name="ln462">  GSList *config_override = NULL;</a>
<a name="ln463">  for(int k = 1; k &lt; argc; k++)</a>
<a name="ln464">  {</a>
<a name="ln465">#ifdef _WIN32</a>
<a name="ln466">    if(!strcmp(argv[k], &quot;/?&quot;))</a>
<a name="ln467">    {</a>
<a name="ln468">      return usage(argv[0]);</a>
<a name="ln469">    }</a>
<a name="ln470">#endif</a>
<a name="ln471">    if(argv[k][0] == '-')</a>
<a name="ln472">    {</a>
<a name="ln473">      if(!strcmp(argv[k], &quot;--help&quot;) || !strcmp(argv[k], &quot;-h&quot;))</a>
<a name="ln474">      {</a>
<a name="ln475">        return usage(argv[0]);</a>
<a name="ln476">      }</a>
<a name="ln477">      else if(!strcmp(argv[k], &quot;--version&quot;))</a>
<a name="ln478">      {</a>
<a name="ln479">#ifdef USE_LUA</a>
<a name="ln480">        const char *lua_api_version = strcmp(LUA_API_VERSION_SUFFIX, &quot;&quot;) ?</a>
<a name="ln481">                                      STR(LUA_API_VERSION_MAJOR) &quot;.&quot;</a>
<a name="ln482">                                      STR(LUA_API_VERSION_MINOR) &quot;.&quot;</a>
<a name="ln483">                                      STR(LUA_API_VERSION_PATCH) &quot;-&quot;</a>
<a name="ln484">                                      LUA_API_VERSION_SUFFIX :</a>
<a name="ln485">                                      STR(LUA_API_VERSION_MAJOR) &quot;.&quot;</a>
<a name="ln486">                                      STR(LUA_API_VERSION_MINOR) &quot;.&quot;</a>
<a name="ln487">                                      STR(LUA_API_VERSION_PATCH);</a>
<a name="ln488">#endif</a>
<a name="ln489">        printf(&quot;this is %s\ncopyright (c) 2009-%s johannes hanika\n&quot; PACKAGE_BUGREPORT &quot;\n\ncompile options:\n&quot;</a>
<a name="ln490">               &quot;  bit depth is %s\n&quot;</a>
<a name="ln491">#ifdef _DEBUG</a>
<a name="ln492">               &quot;  debug build\n&quot;</a>
<a name="ln493">#else</a>
<a name="ln494">               &quot;  normal build\n&quot;</a>
<a name="ln495">#endif</a>
<a name="ln496">#if defined(__SSE2__) &amp;&amp; defined(__SSE__)</a>
<a name="ln497">               &quot;  SSE2 optimized codepath enabled\n&quot;</a>
<a name="ln498">#else</a>
<a name="ln499">               &quot;  SSE2 optimized codepath disabled\n&quot;</a>
<a name="ln500">#endif</a>
<a name="ln501">#ifdef _OPENMP</a>
<a name="ln502">               &quot;  OpenMP support enabled\n&quot;</a>
<a name="ln503">#else</a>
<a name="ln504">               &quot;  OpenMP support disabled\n&quot;</a>
<a name="ln505">#endif</a>
<a name="ln506"> </a>
<a name="ln507">#ifdef HAVE_OPENCL</a>
<a name="ln508">               &quot;  OpenCL support enabled\n&quot;</a>
<a name="ln509">#else</a>
<a name="ln510">               &quot;  OpenCL support disabled\n&quot;</a>
<a name="ln511">#endif</a>
<a name="ln512"> </a>
<a name="ln513">#ifdef USE_LUA</a>
<a name="ln514">               &quot;  Lua support enabled, API version %s\n&quot;</a>
<a name="ln515">#else</a>
<a name="ln516">               &quot;  Lua support disabled\n&quot;</a>
<a name="ln517">#endif</a>
<a name="ln518"> </a>
<a name="ln519">#ifdef USE_COLORDGTK</a>
<a name="ln520">               &quot;  Colord support enabled\n&quot;</a>
<a name="ln521">#else</a>
<a name="ln522">               &quot;  Colord support disabled\n&quot;</a>
<a name="ln523">#endif</a>
<a name="ln524"> </a>
<a name="ln525">#ifdef HAVE_GPHOTO2</a>
<a name="ln526">               &quot;  gPhoto2 support enabled\n&quot;</a>
<a name="ln527">#else</a>
<a name="ln528">               &quot;  gPhoto2 support disabled\n&quot;</a>
<a name="ln529">#endif</a>
<a name="ln530"> </a>
<a name="ln531">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln532">               &quot;  GraphicsMagick support enabled\n&quot;</a>
<a name="ln533">#else</a>
<a name="ln534">               &quot;  GraphicsMagick support disabled\n&quot;</a>
<a name="ln535">#endif</a>
<a name="ln536"> </a>
<a name="ln537">#ifdef HAVE_OPENEXR</a>
<a name="ln538">               &quot;  OpenEXR support enabled\n&quot;</a>
<a name="ln539">#else</a>
<a name="ln540">               &quot;  OpenEXR support disabled\n&quot;</a>
<a name="ln541">#endif</a>
<a name="ln542">               ,</a>
<a name="ln543">               darktable_package_string,</a>
<a name="ln544">               darktable_last_commit_year,</a>
<a name="ln545">               (sizeof(void *) == 8 ? &quot;64 bit&quot; : sizeof(void *) == 4 ? &quot;32 bit&quot; : &quot;unknown&quot;)</a>
<a name="ln546">#if USE_LUA</a>
<a name="ln547">                   ,</a>
<a name="ln548">               lua_api_version</a>
<a name="ln549">#endif</a>
<a name="ln550">               );</a>
<a name="ln551">        return 1;</a>
<a name="ln552">      }</a>
<a name="ln553">      else if(!strcmp(argv[k], &quot;--library&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln554">      {</a>
<a name="ln555">        dbfilename_from_command = argv[++k];</a>
<a name="ln556">        argv[k-1] = NULL;</a>
<a name="ln557">        argv[k] = NULL;</a>
<a name="ln558">      }</a>
<a name="ln559">      else if(!strcmp(argv[k], &quot;--datadir&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln560">      {</a>
<a name="ln561">        datadir_from_command = argv[++k];</a>
<a name="ln562">        argv[k-1] = NULL;</a>
<a name="ln563">        argv[k] = NULL;</a>
<a name="ln564">      }</a>
<a name="ln565">      else if(!strcmp(argv[k], &quot;--moduledir&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln566">      {</a>
<a name="ln567">        moduledir_from_command = argv[++k];</a>
<a name="ln568">        argv[k-1] = NULL;</a>
<a name="ln569">        argv[k] = NULL;</a>
<a name="ln570">      }</a>
<a name="ln571">      else if(!strcmp(argv[k], &quot;--tmpdir&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln572">      {</a>
<a name="ln573">        tmpdir_from_command = argv[++k];</a>
<a name="ln574">        argv[k-1] = NULL;</a>
<a name="ln575">        argv[k] = NULL;</a>
<a name="ln576">      }</a>
<a name="ln577">      else if(!strcmp(argv[k], &quot;--configdir&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln578">      {</a>
<a name="ln579">        configdir_from_command = argv[++k];</a>
<a name="ln580">        argv[k-1] = NULL;</a>
<a name="ln581">        argv[k] = NULL;</a>
<a name="ln582">      }</a>
<a name="ln583">      else if(!strcmp(argv[k], &quot;--cachedir&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln584">      {</a>
<a name="ln585">        cachedir_from_command = argv[++k];</a>
<a name="ln586">        argv[k-1] = NULL;</a>
<a name="ln587">        argv[k] = NULL;</a>
<a name="ln588">      }</a>
<a name="ln589">      else if(!strcmp(argv[k], &quot;--localedir&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln590">      {</a>
<a name="ln591">        localedir_from_command = argv[++k];</a>
<a name="ln592">        bindtextdomain(GETTEXT_PACKAGE, localedir_from_command);</a>
<a name="ln593">        argv[k-1] = NULL;</a>
<a name="ln594">        argv[k] = NULL;</a>
<a name="ln595">      }</a>
<a name="ln596">      else if(argv[k][1] == 'd' &amp;&amp; argc &gt; k + 1)</a>
<a name="ln597">      {</a>
<a name="ln598">        if(!strcmp(argv[k + 1], &quot;all&quot;))</a>
<a name="ln599">          darktable.unmuted = 0xffffffff; // enable all debug information</a>
<a name="ln600">        else if(!strcmp(argv[k + 1], &quot;cache&quot;))</a>
<a name="ln601">          darktable.unmuted |= DT_DEBUG_CACHE; // enable debugging for lib/film/cache module</a>
<a name="ln602">        else if(!strcmp(argv[k + 1], &quot;control&quot;))</a>
<a name="ln603">          darktable.unmuted |= DT_DEBUG_CONTROL; // enable debugging for scheduler module</a>
<a name="ln604">        else if(!strcmp(argv[k + 1], &quot;dev&quot;))</a>
<a name="ln605">          darktable.unmuted |= DT_DEBUG_DEV; // develop module</a>
<a name="ln606">        else if(!strcmp(argv[k + 1], &quot;input&quot;))</a>
<a name="ln607">          darktable.unmuted |= DT_DEBUG_INPUT; // input devices</a>
<a name="ln608">        else if(!strcmp(argv[k + 1], &quot;camctl&quot;))</a>
<a name="ln609">          darktable.unmuted |= DT_DEBUG_CAMCTL; // camera control module</a>
<a name="ln610">        else if(!strcmp(argv[k + 1], &quot;perf&quot;))</a>
<a name="ln611">          darktable.unmuted |= DT_DEBUG_PERF; // performance measurements</a>
<a name="ln612">        else if(!strcmp(argv[k + 1], &quot;pwstorage&quot;))</a>
<a name="ln613">          darktable.unmuted |= DT_DEBUG_PWSTORAGE; // pwstorage module</a>
<a name="ln614">        else if(!strcmp(argv[k + 1], &quot;opencl&quot;))</a>
<a name="ln615">          darktable.unmuted |= DT_DEBUG_OPENCL; // gpu accel via opencl</a>
<a name="ln616">        else if(!strcmp(argv[k + 1], &quot;sql&quot;))</a>
<a name="ln617">          darktable.unmuted |= DT_DEBUG_SQL; // SQLite3 queries</a>
<a name="ln618">        else if(!strcmp(argv[k + 1], &quot;memory&quot;))</a>
<a name="ln619">          darktable.unmuted |= DT_DEBUG_MEMORY; // some stats on mem usage now and then.</a>
<a name="ln620">        else if(!strcmp(argv[k + 1], &quot;lighttable&quot;))</a>
<a name="ln621">          darktable.unmuted |= DT_DEBUG_LIGHTTABLE; // lighttable related stuff.</a>
<a name="ln622">        else if(!strcmp(argv[k + 1], &quot;nan&quot;))</a>
<a name="ln623">          darktable.unmuted |= DT_DEBUG_NAN; // check for NANs when processing the pipe.</a>
<a name="ln624">        else if(!strcmp(argv[k + 1], &quot;masks&quot;))</a>
<a name="ln625">          darktable.unmuted |= DT_DEBUG_MASKS; // masks related stuff.</a>
<a name="ln626">        else if(!strcmp(argv[k + 1], &quot;lua&quot;))</a>
<a name="ln627">          darktable.unmuted |= DT_DEBUG_LUA; // lua errors are reported on console</a>
<a name="ln628">        else if(!strcmp(argv[k + 1], &quot;print&quot;))</a>
<a name="ln629">          darktable.unmuted |= DT_DEBUG_PRINT; // print errors are reported on console</a>
<a name="ln630">        else if(!strcmp(argv[k + 1], &quot;camsupport&quot;))</a>
<a name="ln631">          darktable.unmuted |= DT_DEBUG_CAMERA_SUPPORT; // camera support warnings are reported on console</a>
<a name="ln632">        else</a>
<a name="ln633">          return usage(argv[0]);</a>
<a name="ln634">        k++;</a>
<a name="ln635">        argv[k-1] = NULL;</a>
<a name="ln636">        argv[k] = NULL;</a>
<a name="ln637">      }</a>
<a name="ln638">      else if(argv[k][1] == 't' &amp;&amp; argc &gt; k + 1)</a>
<a name="ln639">      {</a>
<a name="ln640">        darktable.num_openmp_threads = CLAMP(atol(argv[k + 1]), 1, 100);</a>
<a name="ln641">        printf(&quot;[dt_init] using %d threads for openmp parallel sections\n&quot;, darktable.num_openmp_threads);</a>
<a name="ln642">        k++;</a>
<a name="ln643">        argv[k-1] = NULL;</a>
<a name="ln644">        argv[k] = NULL;</a>
<a name="ln645">      }</a>
<a name="ln646">      else if(!strcmp(argv[k], &quot;--conf&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln647">      {</a>
<a name="ln648">        gchar *keyval = g_strdup(argv[++k]), *c = keyval;</a>
<a name="ln649">        argv[k-1] = NULL;</a>
<a name="ln650">        argv[k] = NULL;</a>
<a name="ln651">        gchar *end = keyval + strlen(keyval);</a>
<a name="ln652">        while(*c != '=' &amp;&amp; c &lt; end) c++;</a>
<a name="ln653">        if(*c == '=' &amp;&amp; *(c + 1) != '\0')</a>
<a name="ln654">        {</a>
<a name="ln655">          *c++ = '\0';</a>
<a name="ln656">          dt_conf_string_entry_t *entry = (dt_conf_string_entry_t *)g_malloc(sizeof(dt_conf_string_entry_t));</a>
<a name="ln657">          entry-&gt;key = g_strdup(keyval);</a>
<a name="ln658">          entry-&gt;value = g_strdup(c);</a>
<a name="ln659">          config_override = g_slist_append(config_override, entry);</a>
<a name="ln660">        }</a>
<a name="ln661">        g_free(keyval);</a>
<a name="ln662">      }</a>
<a name="ln663">      else if(!strcmp(argv[k], &quot;--noiseprofiles&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln664">      {</a>
<a name="ln665">        noiseprofiles_from_command = argv[++k];</a>
<a name="ln666">        argv[k-1] = NULL;</a>
<a name="ln667">        argv[k] = NULL;</a>
<a name="ln668">      }</a>
<a name="ln669">      else if(!strcmp(argv[k], &quot;--luacmd&quot;) &amp;&amp; argc &gt; k + 1)</a>
<a name="ln670">      {</a>
<a name="ln671">#ifdef USE_LUA</a>
<a name="ln672">        lua_command = argv[++k];</a>
<a name="ln673">#else</a>
<a name="ln674">        ++k;</a>
<a name="ln675">#endif</a>
<a name="ln676">        argv[k-1] = NULL;</a>
<a name="ln677">        argv[k] = NULL;</a>
<a name="ln678">      }</a>
<a name="ln679">      else if(!strcmp(argv[k], &quot;--disable-opencl&quot;))</a>
<a name="ln680">      {</a>
<a name="ln681">#ifdef HAVE_OPENCL</a>
<a name="ln682">        exclude_opencl = TRUE;</a>
<a name="ln683">#endif</a>
<a name="ln684">        argv[k] = NULL;</a>
<a name="ln685">      }</a>
<a name="ln686">      else if(!strcmp(argv[k], &quot;--&quot;))</a>
<a name="ln687">      {</a>
<a name="ln688">        // &quot;--&quot; confuses the argument parser of glib/gtk. remove it.</a>
<a name="ln689">        argv[k] = NULL;</a>
<a name="ln690">        break;</a>
<a name="ln691">      }</a>
<a name="ln692">      else</a>
<a name="ln693">        return usage(argv[0]); // fail on unrecognized options</a>
<a name="ln694">    }</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  // remove the NULLs to not confuse gtk_init() later.</a>
<a name="ln698">  for(int i = 1; i &lt; argc; i++)</a>
<a name="ln699">  {</a>
<a name="ln700">    int k;</a>
<a name="ln701">    for(k = i; k &lt; argc; k++)</a>
<a name="ln702">      if(argv[k] != NULL) break;</a>
<a name="ln703"> </a>
<a name="ln704">    if(k &gt; i)</a>
<a name="ln705">    {</a>
<a name="ln706">      k -= i;</a>
<a name="ln707">      for(int j = i + k; j &lt; argc; j++)</a>
<a name="ln708">      {</a>
<a name="ln709">        argv[j-k] = argv[j];</a>
<a name="ln710">        argv[j] = NULL;</a>
<a name="ln711">      }</a>
<a name="ln712">      argc -= k;</a>
<a name="ln713">    }</a>
<a name="ln714">  }</a>
<a name="ln715"> </a>
<a name="ln716">  if(darktable.unmuted &amp; DT_DEBUG_MEMORY)</a>
<a name="ln717">  {</a>
<a name="ln718">    fprintf(stderr, &quot;[memory] at startup\n&quot;);</a>
<a name="ln719">    dt_print_mem_usage();</a>
<a name="ln720">  }</a>
<a name="ln721"> </a>
<a name="ln722">  if(init_gui)</a>
<a name="ln723">  {</a>
<a name="ln724">    // I doubt that connecting to dbus for darktable-cli makes sense</a>
<a name="ln725">    darktable.dbus = dt_dbus_init();</a>
<a name="ln726"> </a>
<a name="ln727">    // make sure that we have no stale global progress bar visible. thus it's run as early as possible</a>
<a name="ln728">    dt_control_progress_init(darktable.control);</a>
<a name="ln729">  }</a>
<a name="ln730"> </a>
<a name="ln731">#ifdef _OPENMP</a>
<a name="ln732">  omp_set_num_threads(darktable.num_openmp_threads);</a>
<a name="ln733">#endif</a>
<a name="ln734">  dt_loc_init_datadir(datadir_from_command);</a>
<a name="ln735">  dt_loc_init_plugindir(moduledir_from_command);</a>
<a name="ln736">  dt_loc_init_localedir(localedir_from_command);</a>
<a name="ln737">  if(dt_loc_init_tmp_dir(tmpdir_from_command))</a>
<a name="ln738">  {</a>
<a name="ln739">    fprintf(stderr, &quot;error: invalid temporary directory: %s\n&quot;, darktable.tmpdir);</a>
<a name="ln740">    return usage(argv[0]);</a>
<a name="ln741">  }</a>
<a name="ln742">  dt_loc_init_user_config_dir(configdir_from_command);</a>
<a name="ln743">  dt_loc_init_user_cache_dir(cachedir_from_command);</a>
<a name="ln744"> </a>
<a name="ln745">#ifdef USE_LUA</a>
<a name="ln746">  dt_lua_init_early(L);</a>
<a name="ln747">#endif</a>
<a name="ln748"> </a>
<a name="ln749">  // thread-safe init:</a>
<a name="ln750">  dt_exif_init();</a>
<a name="ln751">  char datadir[PATH_MAX] = { 0 };</a>
<a name="ln752">  dt_loc_get_user_config_dir(datadir, sizeof(datadir));</a>
<a name="ln753">  char darktablerc[PATH_MAX] = { 0 };</a>
<a name="ln754">  snprintf(darktablerc, sizeof(darktablerc), &quot;%s/darktablerc&quot;, datadir);</a>
<a name="ln755"> </a>
<a name="ln756">  // initialize the config backend. this needs to be done first...</a>
<a name="ln757">  darktable.conf = (dt_conf_t *)calloc(1, sizeof(dt_conf_t));</a>
<a name="ln758">  dt_conf_init(darktable.conf, darktablerc, config_override);</a>
<a name="ln759">  g_slist_free_full(config_override, g_free);</a>
<a name="ln760"> </a>
<a name="ln761">  // set the interface language and prepare selection for prefs</a>
<a name="ln762">  darktable.l10n = dt_l10n_init(init_gui);</a>
<a name="ln763"> </a>
<a name="ln764">  // we need this REALLY early so that error messages can be shown, however after gtk_disable_setlocale</a>
<a name="ln765">  if(init_gui)</a>
<a name="ln766">  {</a>
<a name="ln767">#ifdef GDK_WINDOWING_WAYLAND</a>
<a name="ln768">    // There are currently bad interactions with Wayland (drop-downs</a>
<a name="ln769">    // are very narrow, scroll events lost). Until this is fixed, give</a>
<a name="ln770">    // priority to the XWayland backend for Wayland users.</a>
<a name="ln771">    gdk_set_allowed_backends(&quot;x11,*&quot;);</a>
<a name="ln772">#endif</a>
<a name="ln773">    gtk_init(&amp;argc, &amp;argv);</a>
<a name="ln774"> </a>
<a name="ln775">    // execute a performance check and configuration if needed</a>
<a name="ln776">    int last_configure_version = dt_conf_get_int(&quot;performance_configuration_version_completed&quot;);</a>
<a name="ln777">    if(last_configure_version &lt; DT_CURRENT_PERFORMANCE_CONFIGURE_VERSION)</a>
<a name="ln778">    {</a>
<a name="ln779">      // ask the user whether he/she would like</a>
<a name="ln780">      // dt to make changes in the settings</a>
<a name="ln781">      gboolean run_configure = dt_gui_show_standalone_yes_no_dialog(</a>
<a name="ln782">          _(&quot;darktable - run performance configuration?&quot;),</a>
<a name="ln783">          _(&quot;we have an updated performance configuration logic - executing that might improve the performance of &quot;</a>
<a name="ln784">            &quot;darktable.\nthis will potentially overwrite some of your existing settings - especially in case you &quot;</a>
<a name="ln785">            &quot;have manually modified them to custom values.\nwould you like to execute this update of the &quot;</a>
<a name="ln786">            &quot;performance configuration?\n&quot;),</a>
<a name="ln787">          _(&quot;no&quot;), _(&quot;yes&quot;));</a>
<a name="ln788"> </a>
<a name="ln789">      if(run_configure)</a>
<a name="ln790">        dt_configure_performance();</a>
<a name="ln791">      else</a>
<a name="ln792">        // make sure to set this, otherwise the user will be nagged until he eventually agrees</a>
<a name="ln793">        dt_conf_set_int(&quot;performance_configuration_version_completed&quot;, DT_CURRENT_PERFORMANCE_CONFIGURE_VERSION);</a>
<a name="ln794">    }</a>
<a name="ln795">  }</a>
<a name="ln796"> </a>
<a name="ln797">  // detect cpu features and decide which codepaths to enable</a>
<a name="ln798">  dt_codepaths_init();</a>
<a name="ln799"> </a>
<a name="ln800">  // get the list of color profiles</a>
<a name="ln801">  darktable.color_profiles = dt_colorspaces_init();</a>
<a name="ln802"> </a>
<a name="ln803">  // initialize the database</a>
<a name="ln804">  darktable.db = dt_database_init(dbfilename_from_command, load_data);</a>
<a name="ln805">  if(darktable.db == NULL)</a>
<a name="ln806">  {</a>
<a name="ln807">    printf(&quot;ERROR : cannot open database\n&quot;);</a>
<a name="ln808">    return 1;</a>
<a name="ln809">  }</a>
<a name="ln810">  else if(!dt_database_get_lock_acquired(darktable.db))</a>
<a name="ln811">  {</a>
<a name="ln812">    gboolean image_loaded_elsewhere = FALSE;</a>
<a name="ln813">#ifndef MAC_INTEGRATION</a>
<a name="ln814">    // send the images to the other instance via dbus</a>
<a name="ln815">    fprintf(stderr, &quot;trying to open the images in the running instance\n&quot;);</a>
<a name="ln816"> </a>
<a name="ln817">    GDBusConnection *connection = NULL;</a>
<a name="ln818">    for(int i = 1; i &lt; argc; i++)</a>
<a name="ln819">    {</a>
<a name="ln820">      // make the filename absolute ...</a>
<a name="ln821">      if(argv[i] == NULL || *argv[i] == '\0') continue;</a>
<a name="ln822">      gchar *filename = dt_util_normalize_path(argv[i]);</a>
<a name="ln823">      if(filename == NULL) continue;</a>
<a name="ln824">      if(!connection) connection = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, NULL);</a>
<a name="ln825">      // ... and send it to the running instance of darktable</a>
<a name="ln826">      image_loaded_elsewhere = g_dbus_connection_call_sync(connection, &quot;org.darktable.service&quot;, &quot;/darktable&quot;,</a>
<a name="ln827">                                                           &quot;org.darktable.service.Remote&quot;, &quot;Open&quot;,</a>
<a name="ln828">                                                           g_variant_new(&quot;(s)&quot;, filename), NULL,</a>
<a name="ln829">                                                           G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL) != NULL;</a>
<a name="ln830">      g_free(filename);</a>
<a name="ln831">    }</a>
<a name="ln832">    if(connection) g_object_unref(connection);</a>
<a name="ln833">#endif</a>
<a name="ln834"> </a>
<a name="ln835">    if(!image_loaded_elsewhere) dt_database_show_error(darktable.db);</a>
<a name="ln836"> </a>
<a name="ln837">    return 1;</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  // Initialize the signal system</a>
<a name="ln841">  darktable.signals = dt_control_signal_init();</a>
<a name="ln842"> </a>
<a name="ln843">  // Make sure that the database and xmp files are in sync</a>
<a name="ln844">  // We need conf and db to be up and running for that which is the case here.</a>
<a name="ln845">  // FIXME: is this also useful in non-gui mode?</a>
<a name="ln846">  GList *changed_xmp_files = NULL;</a>
<a name="ln847">  if(init_gui &amp;&amp; dt_conf_get_bool(&quot;run_crawler_on_start&quot;))</a>
<a name="ln848">  {</a>
<a name="ln849">    changed_xmp_files = dt_control_crawler_run();</a>
<a name="ln850">  }</a>
<a name="ln851"> </a>
<a name="ln852">  if(init_gui)</a>
<a name="ln853">  {</a>
<a name="ln854">    dt_control_init(darktable.control);</a>
<a name="ln855">  }</a>
<a name="ln856">  else</a>
<a name="ln857">  {</a>
<a name="ln858">    if(dbfilename_from_command &amp;&amp; !strcmp(dbfilename_from_command, &quot;:memory:&quot;))</a>
<a name="ln859">      dt_gui_presets_init(); // init preset db schema.</a>
<a name="ln860">    darktable.control-&gt;running = 0;</a>
<a name="ln861">    darktable.control-&gt;accelerators = NULL;</a>
<a name="ln862">    dt_pthread_mutex_init(&amp;darktable.control-&gt;run_mutex, NULL);</a>
<a name="ln863">  }</a>
<a name="ln864"> </a>
<a name="ln865">  // initialize collection query</a>
<a name="ln866">  darktable.collection = dt_collection_new(NULL);</a>
<a name="ln867"> </a>
<a name="ln868">  /* initialize selection */</a>
<a name="ln869">  darktable.selection = dt_selection_new();</a>
<a name="ln870"> </a>
<a name="ln871">  /* capabilities set to NULL */</a>
<a name="ln872">  darktable.capabilities = NULL;</a>
<a name="ln873"> </a>
<a name="ln874">  // Initialize the password storage engine</a>
<a name="ln875">  darktable.pwstorage = dt_pwstorage_new();</a>
<a name="ln876"> </a>
<a name="ln877">  darktable.guides = dt_guides_init();</a>
<a name="ln878"> </a>
<a name="ln879">  darktable.themes = NULL;</a>
<a name="ln880"> </a>
<a name="ln881">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln882">  /* GraphicsMagick init */</a>
<a name="ln883">  InitializeMagick(darktable.progname);</a>
<a name="ln884"> </a>
<a name="ln885">  // *SIGH*</a>
<a name="ln886">  dt_set_signal_handlers();</a>
<a name="ln887">#endif</a>
<a name="ln888"> </a>
<a name="ln889">  darktable.opencl = (dt_opencl_t *)calloc(1, sizeof(dt_opencl_t));</a>
<a name="ln890">#ifdef HAVE_OPENCL</a>
<a name="ln891">  dt_opencl_init(darktable.opencl, exclude_opencl, print_statistics);</a>
<a name="ln892">#endif</a>
<a name="ln893"> </a>
<a name="ln894">  darktable.points = (dt_points_t *)calloc(1, sizeof(dt_points_t));</a>
<a name="ln895">  dt_points_init(darktable.points, dt_get_num_threads());</a>
<a name="ln896"> </a>
<a name="ln897">  darktable.noiseprofile_parser = dt_noiseprofile_init(noiseprofiles_from_command);</a>
<a name="ln898"> </a>
<a name="ln899">  // must come before mipmap_cache, because that one will need to access</a>
<a name="ln900">  // image dimensions stored in here:</a>
<a name="ln901">  darktable.image_cache = (dt_image_cache_t *)calloc(1, sizeof(dt_image_cache_t));</a>
<a name="ln902">  dt_image_cache_init(darktable.image_cache);</a>
<a name="ln903"> </a>
<a name="ln904">  darktable.mipmap_cache = (dt_mipmap_cache_t *)calloc(1, sizeof(dt_mipmap_cache_t));</a>
<a name="ln905">  dt_mipmap_cache_init(darktable.mipmap_cache);</a>
<a name="ln906"> </a>
<a name="ln907">  // The GUI must be initialized before the views, because the init()</a>
<a name="ln908">  // functions of the views depend on darktable.control-&gt;accels_* to register</a>
<a name="ln909">  // their keyboard accelerators</a>
<a name="ln910"> </a>
<a name="ln911">  if(init_gui)</a>
<a name="ln912">  {</a>
<a name="ln913">    darktable.gui = (dt_gui_gtk_t *)calloc(1, sizeof(dt_gui_gtk_t));</a>
<a name="ln914">    if(dt_gui_gtk_init(darktable.gui)) return 1;</a>
<a name="ln915">    dt_bauhaus_init();</a>
<a name="ln916">  }</a>
<a name="ln917">  else</a>
<a name="ln918">    darktable.gui = NULL;</a>
<a name="ln919"> </a>
<a name="ln920">  darktable.view_manager = (dt_view_manager_t *)calloc(1, sizeof(dt_view_manager_t));</a>
<a name="ln921">  dt_view_manager_init(darktable.view_manager);</a>
<a name="ln922"> </a>
<a name="ln923">  // check whether we were able to load darkroom view. if we failed, we'll crash everywhere later on.</a>
<a name="ln924">  if(!darktable.develop) return 1;</a>
<a name="ln925"> </a>
<a name="ln926">  darktable.imageio = (dt_imageio_t *)calloc(1, sizeof(dt_imageio_t));</a>
<a name="ln927">  dt_imageio_init(darktable.imageio);</a>
<a name="ln928"> </a>
<a name="ln929">  // load the darkroom mode plugins once:</a>
<a name="ln930">  dt_iop_load_modules_so();</a>
<a name="ln931"> </a>
<a name="ln932">  if(init_gui)</a>
<a name="ln933">  {</a>
<a name="ln934">#ifdef HAVE_GPHOTO2</a>
<a name="ln935">    // Initialize the camera control.</a>
<a name="ln936">    // this is done late so that the gui can react to the signal sent but before switching to lighttable!</a>
<a name="ln937">    darktable.camctl = dt_camctl_new();</a>
<a name="ln938">#endif</a>
<a name="ln939"> </a>
<a name="ln940">    darktable.lib = (dt_lib_t *)calloc(1, sizeof(dt_lib_t));</a>
<a name="ln941">    dt_lib_init(darktable.lib);</a>
<a name="ln942"> </a>
<a name="ln943">    dt_gui_gtk_load_config();</a>
<a name="ln944"> </a>
<a name="ln945">    // init the gui part of views</a>
<a name="ln946">    dt_view_manager_gui_init(darktable.view_manager);</a>
<a name="ln947">    // Loading the keybindings</a>
<a name="ln948">    char keyfile[PATH_MAX] = { 0 };</a>
<a name="ln949"> </a>
<a name="ln950">    // First dump the default keymapping</a>
<a name="ln951">    snprintf(keyfile, sizeof(keyfile), &quot;%s/keyboardrc_default&quot;, datadir);</a>
<a name="ln952">    gtk_accel_map_save(keyfile);</a>
<a name="ln953"> </a>
<a name="ln954">    // Removing extraneous semi-colons from the default keymap</a>
<a name="ln955">    strip_semicolons_from_keymap(keyfile);</a>
<a name="ln956"> </a>
<a name="ln957">    // Then load any modified keys if available</a>
<a name="ln958">    snprintf(keyfile, sizeof(keyfile), &quot;%s/keyboardrc&quot;, datadir);</a>
<a name="ln959">    if(g_file_test(keyfile, G_FILE_TEST_EXISTS))</a>
<a name="ln960">      gtk_accel_map_load(keyfile);</a>
<a name="ln961">    else</a>
<a name="ln962">      gtk_accel_map_save(keyfile); // Save the default keymap if none is present</a>
<a name="ln963"> </a>
<a name="ln964">    // initialize undo struct</a>
<a name="ln965">    darktable.undo = dt_undo_init();</a>
<a name="ln966">  }</a>
<a name="ln967"> </a>
<a name="ln968">  if(darktable.unmuted &amp; DT_DEBUG_MEMORY)</a>
<a name="ln969">  {</a>
<a name="ln970">    fprintf(stderr, &quot;[memory] after successful startup\n&quot;);</a>
<a name="ln971">    dt_print_mem_usage();</a>
<a name="ln972">  }</a>
<a name="ln973"> </a>
<a name="ln974">  dt_image_local_copy_synch();</a>
<a name="ln975"> </a>
<a name="ln976">/* init lua last, since it's user made stuff it must be in the real environment */</a>
<a name="ln977">#ifdef USE_LUA</a>
<a name="ln978">  dt_lua_init(darktable.lua_state.state, lua_command);</a>
<a name="ln979">#endif</a>
<a name="ln980"> </a>
<a name="ln981">  if(init_gui)</a>
<a name="ln982">  {</a>
<a name="ln983">    const char *mode = &quot;lighttable&quot;;</a>
<a name="ln984">    // april 1st: you have to earn using dt first! or know that you can switch views with keyboard shortcuts</a>
<a name="ln985">    time_t now;</a>
<a name="ln986">    time(&amp;now);</a>
<a name="ln987">    struct tm lt;</a>
<a name="ln988">    localtime_r(&amp;now, &amp;lt);</a>
<a name="ln989">    if(lt.tm_mon == 3 &amp;&amp; lt.tm_mday == 1)</a>
<a name="ln990">    {</a>
<a name="ln991">      int current_year = lt.tm_year + 1900;</a>
<a name="ln992">      int last_year = dt_conf_get_int(&quot;ui_last/april1st&quot;);</a>
<a name="ln993">      if(last_year &lt; current_year)</a>
<a name="ln994">      {</a>
<a name="ln995">        dt_conf_set_int(&quot;ui_last/april1st&quot;, current_year);</a>
<a name="ln996">        mode = &quot;knight&quot;;</a>
<a name="ln997">      }</a>
<a name="ln998">    }</a>
<a name="ln999">    // we have to call dt_ctl_switch_mode_to() here already to not run into a lua deadlock.</a>
<a name="ln1000">    // having another call later is ok</a>
<a name="ln1001">    dt_ctl_switch_mode_to(mode);</a>
<a name="ln1002"> </a>
<a name="ln1003">#ifndef MAC_INTEGRATION</a>
<a name="ln1004">    // load image(s) specified on cmdline.</a>
<a name="ln1005">    // this has to happen after lua is initialized as image import can run lua code</a>
<a name="ln1006">    // If only one image is listed, attempt to load it in darkroom</a>
<a name="ln1007">    int last_id = 0;</a>
<a name="ln1008">    gboolean only_single_images = TRUE;</a>
<a name="ln1009">    int loaded_images = 0;</a>
<a name="ln1010"> </a>
<a name="ln1011">    for(int i = 1; i &lt; argc; i++)</a>
<a name="ln1012">    {</a>
<a name="ln1013">      gboolean single_image = FALSE;</a>
<a name="ln1014">      if(argv[i] == NULL || *argv[i] == '\0') continue;</a>
<a name="ln1015">      int new_id = dt_load_from_string(argv[i], FALSE, &amp;single_image);</a>
<a name="ln1016">      if(new_id &gt; 0)</a>
<a name="ln1017">      {</a>
<a name="ln1018">        last_id = new_id;</a>
<a name="ln1019">        loaded_images++;</a>
<a name="ln1020">        if(!single_image) only_single_images = FALSE;</a>
<a name="ln1021">      }</a>
<a name="ln1022">    }</a>
<a name="ln1023"> </a>
<a name="ln1024">    if(loaded_images == 1 &amp;&amp; only_single_images)</a>
<a name="ln1025">    {</a>
<a name="ln1026">      dt_control_set_mouse_over_id(last_id);</a>
<a name="ln1027">      dt_ctl_switch_mode_to(&quot;darkroom&quot;);</a>
<a name="ln1028">    }</a>
<a name="ln1029">#endif</a>
<a name="ln1030">  }</a>
<a name="ln1031"> </a>
<a name="ln1032">  // last but not least construct the popup that asks the user about images whose xmp files are newer than the</a>
<a name="ln1033">  // db entry</a>
<a name="ln1034">  if(init_gui &amp;&amp; changed_xmp_files)</a>
<a name="ln1035">  {</a>
<a name="ln1036">    dt_control_crawler_show_image_list(changed_xmp_files);</a>
<a name="ln1037">  }</a>
<a name="ln1038"> </a>
<a name="ln1039">  dt_print(DT_DEBUG_CONTROL, &quot;[init] startup took %f seconds\n&quot;, dt_get_wtime() - start_wtime);</a>
<a name="ln1040"> </a>
<a name="ln1041">  return 0;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">void dt_cleanup()</a>
<a name="ln1045">{</a>
<a name="ln1046">  const int init_gui = (darktable.gui != NULL);</a>
<a name="ln1047"> </a>
<a name="ln1048">#ifdef HAVE_PRINT</a>
<a name="ln1049">  dt_printers_abort_discovery();</a>
<a name="ln1050">#endif</a>
<a name="ln1051"> </a>
<a name="ln1052">#ifdef USE_LUA</a>
<a name="ln1053">  dt_lua_finalize_early();</a>
<a name="ln1054">#endif</a>
<a name="ln1055">  if(init_gui)</a>
<a name="ln1056">  {</a>
<a name="ln1057">    dt_ctl_switch_mode_to(&quot;&quot;);</a>
<a name="ln1058">    dt_dbus_destroy(darktable.dbus);</a>
<a name="ln1059"> </a>
<a name="ln1060">    dt_control_shutdown(darktable.control);</a>
<a name="ln1061"> </a>
<a name="ln1062">    dt_lib_cleanup(darktable.lib);</a>
<a name="ln1063">    free(darktable.lib);</a>
<a name="ln1064">  }</a>
<a name="ln1065">#ifdef USE_LUA</a>
<a name="ln1066">  dt_lua_finalize();</a>
<a name="ln1067">#endif</a>
<a name="ln1068">  dt_view_manager_cleanup(darktable.view_manager);</a>
<a name="ln1069">  free(darktable.view_manager);</a>
<a name="ln1070">  if(init_gui)</a>
<a name="ln1071">  {</a>
<a name="ln1072">    dt_imageio_cleanup(darktable.imageio);</a>
<a name="ln1073">    free(darktable.imageio);</a>
<a name="ln1074">    free(darktable.gui);</a>
<a name="ln1075">  }</a>
<a name="ln1076">  dt_image_cache_cleanup(darktable.image_cache);</a>
<a name="ln1077">  free(darktable.image_cache);</a>
<a name="ln1078">  dt_mipmap_cache_cleanup(darktable.mipmap_cache);</a>
<a name="ln1079">  free(darktable.mipmap_cache);</a>
<a name="ln1080">  if(init_gui)</a>
<a name="ln1081">  {</a>
<a name="ln1082">    dt_control_cleanup(darktable.control);</a>
<a name="ln1083">    free(darktable.control);</a>
<a name="ln1084">    dt_undo_cleanup(darktable.undo);</a>
<a name="ln1085">  }</a>
<a name="ln1086">  dt_colorspaces_cleanup(darktable.color_profiles);</a>
<a name="ln1087">  dt_conf_cleanup(darktable.conf);</a>
<a name="ln1088">  free(darktable.conf);</a>
<a name="ln1089">  dt_points_cleanup(darktable.points);</a>
<a name="ln1090">  free(darktable.points);</a>
<a name="ln1091">  dt_iop_unload_modules_so();</a>
<a name="ln1092">  dt_opencl_cleanup(darktable.opencl);</a>
<a name="ln1093">  free(darktable.opencl);</a>
<a name="ln1094">#ifdef HAVE_GPHOTO2</a>
<a name="ln1095">  dt_camctl_destroy((dt_camctl_t *)darktable.camctl);</a>
<a name="ln1096">#endif</a>
<a name="ln1097">  dt_pwstorage_destroy(darktable.pwstorage);</a>
<a name="ln1098"> </a>
<a name="ln1099">#ifdef HAVE_GRAPHICSMAGICK</a>
<a name="ln1100">  DestroyMagick();</a>
<a name="ln1101">#endif</a>
<a name="ln1102"> </a>
<a name="ln1103">  dt_guides_cleanup(darktable.guides);</a>
<a name="ln1104"> </a>
<a name="ln1105">  dt_database_destroy(darktable.db);</a>
<a name="ln1106"> </a>
<a name="ln1107">  if(init_gui)</a>
<a name="ln1108">  {</a>
<a name="ln1109">    dt_bauhaus_cleanup();</a>
<a name="ln1110">  }</a>
<a name="ln1111"> </a>
<a name="ln1112">  dt_capabilities_cleanup();</a>
<a name="ln1113"> </a>
<a name="ln1114">  dt_pthread_mutex_destroy(&amp;(darktable.db_insert));</a>
<a name="ln1115">  dt_pthread_mutex_destroy(&amp;(darktable.plugin_threadsafe));</a>
<a name="ln1116">  dt_pthread_mutex_destroy(&amp;(darktable.capabilities_threadsafe));</a>
<a name="ln1117">  dt_pthread_mutex_destroy(&amp;(darktable.exiv2_threadsafe));</a>
<a name="ln1118"> </a>
<a name="ln1119">  dt_exif_cleanup();</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">void dt_print(dt_debug_thread_t thread, const char *msg, ...)</a>
<a name="ln1123">{</a>
<a name="ln1124">  if(darktable.unmuted &amp; thread)</a>
<a name="ln1125">  {</a>
<a name="ln1126">    printf(&quot;%f &quot;, dt_get_wtime() - darktable.start_wtime);</a>
<a name="ln1127">    va_list ap;</a>
<a name="ln1128">    va_start(ap, msg);</a>
<a name="ln1129">    vprintf(msg, ap);</a>
<a name="ln1130">    va_end(ap);</a>
<a name="ln1131">    fflush(stdout);</a>
<a name="ln1132">  }</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">void dt_gettime_t(char *datetime, size_t datetime_len, time_t t)</a>
<a name="ln1136">{</a>
<a name="ln1137">  struct tm tt;</a>
<a name="ln1138">  (void)localtime_r(&amp;t, &amp;tt);</a>
<a name="ln1139">  strftime(datetime, datetime_len, &quot;%Y:%m:%d %H:%M:%S&quot;, &amp;tt);</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">void dt_gettime(char *datetime, size_t datetime_len)</a>
<a name="ln1143">{</a>
<a name="ln1144">  dt_gettime_t(datetime, datetime_len, time(NULL));</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">void *dt_alloc_align(size_t alignment, size_t size)</a>
<a name="ln1148">{</a>
<a name="ln1149">#if defined(__FreeBSD_version) &amp;&amp; __FreeBSD_version &lt; 700013</a>
<a name="ln1150">  return malloc(size);</a>
<a name="ln1151">#elif defined(_WIN32)</a>
<a name="ln1152">  return _aligned_malloc(size, alignment);</a>
<a name="ln1153">#else</a>
<a name="ln1154">  void *ptr = NULL;</a>
<a name="ln1155">  if(posix_memalign(&amp;ptr, alignment, size)) return NULL;</a>
<a name="ln1156">  return ptr;</a>
<a name="ln1157">#endif</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160">#ifdef _WIN32</a>
<a name="ln1161">void dt_free_align(void *mem)</a>
<a name="ln1162">{</a>
<a name="ln1163">  _aligned_free(mem);</a>
<a name="ln1164">}</a>
<a name="ln1165">#endif</a>
<a name="ln1166"> </a>
<a name="ln1167">void dt_show_times(const dt_times_t *start, const char *prefix, const char *suffix, ...)</a>
<a name="ln1168">{</a>
<a name="ln1169">  dt_times_t end;</a>
<a name="ln1170">  char buf[160]; /* Arbitrary size, should be lots big enough for everything used in DT */</a>
<a name="ln1171">  int i;</a>
<a name="ln1172"> </a>
<a name="ln1173">  /* Skip all the calculations an everything if -d perf isn't on */</a>
<a name="ln1174">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1175">  {</a>
<a name="ln1176">    dt_get_times(&amp;end);</a>
<a name="ln1177">    i = snprintf(buf, sizeof(buf), &quot;%s took %.3f secs (%.3f CPU)&quot;, prefix, end.clock - start-&gt;clock,</a>
<a name="ln1178">                 end.user - start-&gt;user);</a>
<a name="ln1179">    if(suffix != NULL)</a>
<a name="ln1180">    {</a>
<a name="ln1181">      va_list ap;</a>
<a name="ln1182">      va_start(ap, suffix);</a>
<a name="ln1183">      buf[i++] = ' ';</a>
<a name="ln1184">      vsnprintf(buf + i, sizeof buf - i, suffix, ap);</a>
<a name="ln1185">      va_end(ap);</a>
<a name="ln1186">    }</a>
<a name="ln1187">    dt_print(DT_DEBUG_PERF, &quot;%s\n&quot;, buf);</a>
<a name="ln1188">  }</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">void dt_configure_performance()</a>
<a name="ln1192">{</a>
<a name="ln1193">  const int atom_cores = dt_get_num_atom_cores();</a>
<a name="ln1194">  const int threads = dt_get_num_threads();</a>
<a name="ln1195">  const size_t mem = dt_get_total_memory();</a>
<a name="ln1196">  const int bits = (sizeof(void *) == 4) ? 32 : 64;</a>
<a name="ln1197">  gchar *demosaic_quality = dt_conf_get_string(&quot;plugins/darkroom/demosaic/quality&quot;);</a>
<a name="ln1198"> </a>
<a name="ln1199">  fprintf(stderr, &quot;[defaults] found a %d-bit system with %zu kb ram and %d cores (%d atom based)\n&quot;, bits, mem,</a>
<a name="ln1200">          threads, atom_cores);</a>
<a name="ln1201"> </a>
<a name="ln1202">  if(mem &gt;= (8u &lt;&lt; 20) &amp;&amp; threads &gt; 4 &amp;&amp; bits == 64 &amp;&amp; atom_cores == 0)</a>
<a name="ln1203">  {</a>
<a name="ln1204">    // CONFIG 1: at least 8GB RAM, and more than 4 CPU cores, no atom, 64 bit</a>
<a name="ln1205">    // But respect if user has set higher values manually earlier</a>
<a name="ln1206">    fprintf(stderr, &quot;[defaults] setting very high quality defaults\n&quot;);</a>
<a name="ln1207"> </a>
<a name="ln1208">    dt_conf_set_int(&quot;worker_threads&quot;, MAX(8, dt_conf_get_int(&quot;worker_threads&quot;)));</a>
<a name="ln1209">    // if machine has at least 8GB RAM, use half of the total memory size</a>
<a name="ln1210">    dt_conf_set_int(&quot;host_memory_limit&quot;, MAX(mem &gt;&gt; 11, dt_conf_get_int(&quot;host_memory_limit&quot;)));</a>
<a name="ln1211">    dt_conf_set_int(&quot;singlebuffer_limit&quot;, MAX(16, dt_conf_get_int(&quot;singlebuffer_limit&quot;)));</a>
<a name="ln1212">    if(demosaic_quality == NULL || !strcmp(demosaic_quality, &quot;always bilinear (fast)&quot;))</a>
<a name="ln1213">      dt_conf_set_string(&quot;plugins/darkroom/demosaic/quality&quot;, &quot;at most PPG (reasonable)&quot;);</a>
<a name="ln1214">    dt_conf_set_bool(&quot;plugins/lighttable/low_quality_thumbnails&quot;, FALSE);</a>
<a name="ln1215">  }</a>
<a name="ln1216">  else if(mem &gt; (2u &lt;&lt; 20) &amp;&amp; threads &gt;= 4 &amp;&amp; bits == 64 &amp;&amp; atom_cores == 0)</a>
<a name="ln1217">  {</a>
<a name="ln1218">    // CONFIG 2: at least 2GB RAM, and at least 4 CPU cores, no atom, 64 bit</a>
<a name="ln1219">    // But respect if user has set higher values manually earlier</a>
<a name="ln1220">    fprintf(stderr, &quot;[defaults] setting high quality defaults\n&quot;);</a>
<a name="ln1221"> </a>
<a name="ln1222">    dt_conf_set_int(&quot;worker_threads&quot;, MAX(8, dt_conf_get_int(&quot;worker_threads&quot;)));</a>
<a name="ln1223">    dt_conf_set_int(&quot;host_memory_limit&quot;, MAX(1500, dt_conf_get_int(&quot;host_memory_limit&quot;)));</a>
<a name="ln1224">    dt_conf_set_int(&quot;singlebuffer_limit&quot;, MAX(16, dt_conf_get_int(&quot;singlebuffer_limit&quot;)));</a>
<a name="ln1225">    if(demosaic_quality == NULL ||!strcmp(demosaic_quality, &quot;always bilinear (fast)&quot;))</a>
<a name="ln1226">      dt_conf_set_string(&quot;plugins/darkroom/demosaic/quality&quot;, &quot;at most PPG (reasonable)&quot;);</a>
<a name="ln1227">    dt_conf_set_bool(&quot;plugins/lighttable/low_quality_thumbnails&quot;, FALSE);</a>
<a name="ln1228">  }</a>
<a name="ln1229">  else if(mem &lt; (1u &lt;&lt; 20) || threads &lt;= 2 || bits == 32 || atom_cores &gt; 0)</a>
<a name="ln1230">  {</a>
<a name="ln1231">    // CONFIG 3: For less than 1GB RAM or 2 or less cores, or 32-bit or for atom processors</a>
<a name="ln1232">    // use very low/conservative settings</a>
<a name="ln1233">    fprintf(stderr, &quot;[defaults] setting very conservative defaults\n&quot;);</a>
<a name="ln1234">    dt_conf_set_int(&quot;worker_threads&quot;, 1);</a>
<a name="ln1235">    dt_conf_set_int(&quot;host_memory_limit&quot;, 500);</a>
<a name="ln1236">    dt_conf_set_int(&quot;singlebuffer_limit&quot;, 8);</a>
<a name="ln1237">    dt_conf_set_string(&quot;plugins/darkroom/demosaic/quality&quot;, &quot;always bilinear (fast)&quot;);</a>
<a name="ln1238">    dt_conf_set_bool(&quot;plugins/lighttable/low_quality_thumbnails&quot;, TRUE);</a>
<a name="ln1239">  }</a>
<a name="ln1240">  else</a>
<a name="ln1241">  {</a>
<a name="ln1242">    // CONFIG 4: for everything else use explicit defaults</a>
<a name="ln1243">    fprintf(stderr, &quot;[defaults] setting normal defaults\n&quot;);</a>
<a name="ln1244"> </a>
<a name="ln1245">    dt_conf_set_int(&quot;worker_threads&quot;, 2);</a>
<a name="ln1246">    dt_conf_set_int(&quot;host_memory_limit&quot;, 1500);</a>
<a name="ln1247">    dt_conf_set_int(&quot;singlebuffer_limit&quot;, 16);</a>
<a name="ln1248">    dt_conf_set_string(&quot;plugins/darkroom/demosaic/quality&quot;, &quot;at most PPG (reasonable)&quot;);</a>
<a name="ln1249">    dt_conf_set_bool(&quot;plugins/lighttable/low_quality_thumbnails&quot;, FALSE);</a>
<a name="ln1250">  }</a>
<a name="ln1251"> </a>
<a name="ln1252">  g_free(demosaic_quality);</a>
<a name="ln1253"> </a>
<a name="ln1254">  // store the current performance configure version as the last completed</a>
<a name="ln1255">  // that would prevent further execution of previous performance configuration run</a>
<a name="ln1256">  // at subsequent startups</a>
<a name="ln1257">  dt_conf_set_int(&quot;performance_configuration_version_completed&quot;, DT_CURRENT_PERFORMANCE_CONFIGURE_VERSION);  </a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260"> </a>
<a name="ln1261">int dt_capabilities_check(char *capability)</a>
<a name="ln1262">{</a>
<a name="ln1263">  GList *capabilities = darktable.capabilities;</a>
<a name="ln1264"> </a>
<a name="ln1265">  while(capabilities)</a>
<a name="ln1266">  {</a>
<a name="ln1267">    if(!strcmp(capabilities-&gt;data, capability))</a>
<a name="ln1268">    {</a>
<a name="ln1269">      return TRUE;</a>
<a name="ln1270">    }</a>
<a name="ln1271">    capabilities = g_list_next(capabilities);</a>
<a name="ln1272">  }</a>
<a name="ln1273">  return FALSE;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276"> </a>
<a name="ln1277">void dt_capabilities_add(char *capability)</a>
<a name="ln1278">{</a>
<a name="ln1279">  dt_pthread_mutex_lock(&amp;darktable.capabilities_threadsafe);</a>
<a name="ln1280"> </a>
<a name="ln1281">  if(!dt_capabilities_check(capability))</a>
<a name="ln1282">    darktable.capabilities = g_list_append(darktable.capabilities, capability);</a>
<a name="ln1283"> </a>
<a name="ln1284">  dt_pthread_mutex_unlock(&amp;darktable.capabilities_threadsafe);</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287"> </a>
<a name="ln1288">void dt_capabilities_remove(char *capability)</a>
<a name="ln1289">{</a>
<a name="ln1290">  dt_pthread_mutex_lock(&amp;darktable.capabilities_threadsafe);</a>
<a name="ln1291"> </a>
<a name="ln1292">  darktable.capabilities = g_list_remove(darktable.capabilities, capability);</a>
<a name="ln1293"> </a>
<a name="ln1294">  dt_pthread_mutex_unlock(&amp;darktable.capabilities_threadsafe);</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297"> </a>
<a name="ln1298">void dt_capabilities_cleanup()</a>
<a name="ln1299">{</a>
<a name="ln1300">  while(darktable.capabilities)</a>
<a name="ln1301">    darktable.capabilities = g_list_delete_link(darktable.capabilities, darktable.capabilities);</a>
<a name="ln1302">}</a>
<a name="ln1303"> </a>
<a name="ln1304"> </a>
<a name="ln1305">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1306">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1307">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1202"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bits == 64.</p></div>
<div class="balloon" rel="1216"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: bits == 64.</p></div>
<div class="balloon" rel="1229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: bits == 32.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
