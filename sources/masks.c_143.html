
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012 aldric renaudin.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &quot;develop/masks.h&quot;</a>
<a name="ln19">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/styles.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln28">#include &quot;gui/draw.h&quot;</a>
<a name="ln29">#include &quot;gui/gtk.h&quot;</a>
<a name="ln30">#include &quot;gui/styles.h&quot;</a>
<a name="ln31">#include &quot;libs/lib.h&quot;</a>
<a name="ln32">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">DT_MODULE(1)</a>
<a name="ln35"> </a>
<a name="ln36">#pragma GCC diagnostic ignored &quot;-Wshadow&quot;</a>
<a name="ln37"> </a>
<a name="ln38">static void _lib_masks_recreate_list(dt_lib_module_t *self);</a>
<a name="ln39">static void _lib_masks_update_list(dt_lib_module_t *self);</a>
<a name="ln40"> </a>
<a name="ln41">typedef struct dt_lib_masks_t</a>
<a name="ln42">{</a>
<a name="ln43">  /* vbox with managed history items */</a>
<a name="ln44">  GtkWidget *hbox;</a>
<a name="ln45">  GtkWidget *bt_circle, *bt_path, *bt_gradient, *bt_ellipse, *bt_brush;</a>
<a name="ln46">  GtkWidget *treeview;</a>
<a name="ln47">  GtkWidget *scroll_window;</a>
<a name="ln48"> </a>
<a name="ln49">  GdkPixbuf *ic_inverse, *ic_union, *ic_intersection, *ic_difference, *ic_exclusion, *ic_used;</a>
<a name="ln50">  int gui_reset;</a>
<a name="ln51">} dt_lib_masks_t;</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">const char *name(dt_lib_module_t *self)</a>
<a name="ln55">{</a>
<a name="ln56">  return _(&quot;mask manager&quot;);</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">const char **views(dt_lib_module_t *self)</a>
<a name="ln60">{</a>
<a name="ln61">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln62">  return v;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln66">{</a>
<a name="ln67">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">int position()</a>
<a name="ln71">{</a>
<a name="ln72">  return 10;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">typedef enum dt_masks_tree_cols_t</a>
<a name="ln76">{</a>
<a name="ln77">  TREE_TEXT = 0,</a>
<a name="ln78">  TREE_MODULE,</a>
<a name="ln79">  TREE_GROUPID,</a>
<a name="ln80">  TREE_FORMID,</a>
<a name="ln81">  TREE_EDITABLE,</a>
<a name="ln82">  TREE_IC_OP,</a>
<a name="ln83">  TREE_IC_OP_VISIBLE,</a>
<a name="ln84">  TREE_IC_INVERSE,</a>
<a name="ln85">  TREE_IC_INVERSE_VISIBLE,</a>
<a name="ln86">  TREE_IC_USED,</a>
<a name="ln87">  TREE_IC_USED_VISIBLE,</a>
<a name="ln88">  TREE_USED_TEXT,</a>
<a name="ln89">  TREE_COUNT</a>
<a name="ln90">} dt_masks_tree_cols_t;</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">static void _lib_masks_inactivate_icons(dt_lib_module_t *self)</a>
<a name="ln94">{</a>
<a name="ln95">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln96"> </a>
<a name="ln97">  // we set the add shape icons inactive</a>
<a name="ln98">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(lm-&gt;bt_circle), FALSE);</a>
<a name="ln99">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(lm-&gt;bt_ellipse), FALSE);</a>
<a name="ln100">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(lm-&gt;bt_path), FALSE);</a>
<a name="ln101">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(lm-&gt;bt_gradient), FALSE);</a>
<a name="ln102">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(lm-&gt;bt_brush), FALSE);</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">static void _tree_add_circle(GtkButton *button, dt_iop_module_t *module)</a>
<a name="ln107">{</a>
<a name="ln108">  // we create the new form</a>
<a name="ln109">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_CIRCLE);</a>
<a name="ln110">  dt_masks_change_form_gui(spot);</a>
<a name="ln111">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln112">  darktable.develop-&gt;form_gui-&gt;creation_module = module;</a>
<a name="ln113">  darktable.develop-&gt;form_gui-&gt;group_selected = 0;</a>
<a name="ln114">  dt_control_queue_redraw_center();</a>
<a name="ln115">}</a>
<a name="ln116">static void _bt_add_circle(GtkWidget *widget, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln117">{</a>
<a name="ln118">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln119"> </a>
<a name="ln120">  if(event-&gt;button == 1)</a>
<a name="ln121">  {</a>
<a name="ln122">    // we unset the creation mode</a>
<a name="ln123">    dt_masks_change_form_gui(NULL);</a>
<a name="ln124">    _lib_masks_inactivate_icons(self);</a>
<a name="ln125">    _tree_add_circle(NULL, NULL);</a>
<a name="ln126">  }</a>
<a name="ln127">}</a>
<a name="ln128">static void _tree_add_ellipse(GtkButton *button, dt_iop_module_t *module)</a>
<a name="ln129">{</a>
<a name="ln130">  // we create the new form</a>
<a name="ln131">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_ELLIPSE);</a>
<a name="ln132">  dt_masks_change_form_gui(spot);</a>
<a name="ln133">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln134">  darktable.develop-&gt;form_gui-&gt;creation_module = module;</a>
<a name="ln135">  darktable.develop-&gt;form_gui-&gt;group_selected = 0;</a>
<a name="ln136">  dt_control_queue_redraw_center();</a>
<a name="ln137">}</a>
<a name="ln138">static void _bt_add_ellipse(GtkWidget *widget, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln139">{</a>
<a name="ln140">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln141"> </a>
<a name="ln142">  if(event-&gt;button == 1)</a>
<a name="ln143">  {</a>
<a name="ln144">    // we unset the creation mode</a>
<a name="ln145">    dt_masks_change_form_gui(NULL);</a>
<a name="ln146">    _lib_masks_inactivate_icons(self);</a>
<a name="ln147">    _tree_add_ellipse(NULL, NULL);</a>
<a name="ln148">  }</a>
<a name="ln149">}</a>
<a name="ln150">static void _tree_add_path(GtkButton *button, dt_iop_module_t *module)</a>
<a name="ln151">{</a>
<a name="ln152">  // we create the new form</a>
<a name="ln153">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_PATH);</a>
<a name="ln154">  dt_masks_change_form_gui(spot);</a>
<a name="ln155">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln156">  darktable.develop-&gt;form_gui-&gt;creation_module = module;</a>
<a name="ln157">  darktable.develop-&gt;form_gui-&gt;group_selected = 0;</a>
<a name="ln158">  dt_control_queue_redraw_center();</a>
<a name="ln159">}</a>
<a name="ln160">static void _bt_add_path(GtkWidget *widget, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln161">{</a>
<a name="ln162">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln163"> </a>
<a name="ln164">  if(event-&gt;button == 1)</a>
<a name="ln165">  {</a>
<a name="ln166">    // we unset the creation mode</a>
<a name="ln167">    dt_masks_change_form_gui(NULL);</a>
<a name="ln168">    _lib_masks_inactivate_icons(self);</a>
<a name="ln169">    _tree_add_path(NULL, NULL);</a>
<a name="ln170">  }</a>
<a name="ln171">}</a>
<a name="ln172">static void _tree_add_gradient(GtkButton *button, dt_iop_module_t *module)</a>
<a name="ln173">{</a>
<a name="ln174">  // we create the new form</a>
<a name="ln175">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_GRADIENT);</a>
<a name="ln176">  dt_masks_change_form_gui(spot);</a>
<a name="ln177">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln178">  darktable.develop-&gt;form_gui-&gt;creation_module = module;</a>
<a name="ln179">  darktable.develop-&gt;form_gui-&gt;group_selected = 0;</a>
<a name="ln180">  dt_control_queue_redraw_center();</a>
<a name="ln181">}</a>
<a name="ln182">static void _bt_add_gradient(GtkWidget *widget, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln183">{</a>
<a name="ln184">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln185"> </a>
<a name="ln186">  if(event-&gt;button == 1)</a>
<a name="ln187">  {</a>
<a name="ln188">    // we unset the creation mode</a>
<a name="ln189">    dt_masks_change_form_gui(NULL);</a>
<a name="ln190">    _lib_masks_inactivate_icons(self);</a>
<a name="ln191">    _tree_add_gradient(NULL, NULL);</a>
<a name="ln192">  }</a>
<a name="ln193">}</a>
<a name="ln194">static void _tree_add_brush(GtkButton *button, dt_iop_module_t *module)</a>
<a name="ln195">{</a>
<a name="ln196">  // we create the new form</a>
<a name="ln197">  dt_masks_form_t *spot = dt_masks_create(DT_MASKS_BRUSH);</a>
<a name="ln198">  dt_masks_change_form_gui(spot);</a>
<a name="ln199">  darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln200">  darktable.develop-&gt;form_gui-&gt;creation_module = module;</a>
<a name="ln201">  darktable.develop-&gt;form_gui-&gt;group_selected = 0;</a>
<a name="ln202">  dt_control_queue_redraw_center();</a>
<a name="ln203">}</a>
<a name="ln204">static void _bt_add_brush(GtkWidget *widget, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln205">{</a>
<a name="ln206">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln207"> </a>
<a name="ln208">  if(event-&gt;button == 1)</a>
<a name="ln209">  {</a>
<a name="ln210">    // we unset the creation mode</a>
<a name="ln211">    dt_masks_change_form_gui(NULL);</a>
<a name="ln212">    _lib_masks_inactivate_icons(self);</a>
<a name="ln213">    _tree_add_brush(NULL, NULL);</a>
<a name="ln214">  }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">static void _tree_add_exist(GtkButton *button, dt_masks_form_t *grp)</a>
<a name="ln219">{</a>
<a name="ln220">  if(!grp || !(grp-&gt;type &amp; DT_MASKS_GROUP)) return;</a>
<a name="ln221">  // we get the new formid</a>
<a name="ln222">  int id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(button), &quot;formid&quot;));</a>
<a name="ln223"> </a>
<a name="ln224">  // we add the form in this group</a>
<a name="ln225">  dt_masks_form_t *form = dt_masks_get_from_id(darktable.develop, id);</a>
<a name="ln226">  if(form &amp;&amp; dt_masks_group_add_form(grp, form))</a>
<a name="ln227">  {</a>
<a name="ln228">    // we save the group</a>
<a name="ln229">    dt_masks_write_form(grp, darktable.develop);</a>
<a name="ln230"> </a>
<a name="ln231">    // and we apply the change</a>
<a name="ln232">    dt_dev_masks_list_change(darktable.develop);</a>
<a name="ln233">    dt_masks_update_image(darktable.develop);</a>
<a name="ln234">    dt_dev_masks_selection_change(darktable.develop, grp-&gt;formid, TRUE);</a>
<a name="ln235">  }</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">static void _tree_group(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln239">{</a>
<a name="ln240">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln241">  // we create the new group</a>
<a name="ln242">  dt_masks_form_t *grp = dt_masks_create(DT_MASKS_GROUP);</a>
<a name="ln243">  snprintf(grp-&gt;name, sizeof(grp-&gt;name), _(&quot;group #%d&quot;), g_list_length(darktable.develop-&gt;forms));</a>
<a name="ln244"> </a>
<a name="ln245">  // we add all selected forms to this group</a>
<a name="ln246">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln247">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln248"> </a>
<a name="ln249">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln250">  int pos = 0;</a>
<a name="ln251">  while(items)</a>
<a name="ln252">  {</a>
<a name="ln253">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln254">    GtkTreeIter iter;</a>
<a name="ln255">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln256">    {</a>
<a name="ln257">      GValue gv = {</a>
<a name="ln258">        0,</a>
<a name="ln259">      };</a>
<a name="ln260">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv);</a>
<a name="ln261">      int id = g_value_get_int(&amp;gv);</a>
<a name="ln262">      g_value_unset(&amp;gv);</a>
<a name="ln263">      if(id &gt; 0)</a>
<a name="ln264">      {</a>
<a name="ln265">        dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)malloc(sizeof(dt_masks_point_group_t));</a>
<a name="ln266">        fpt-&gt;formid = id;</a>
<a name="ln267">        fpt-&gt;parentid = grp-&gt;formid;</a>
<a name="ln268">        fpt-&gt;opacity = 1.0f;</a>
<a name="ln269">        fpt-&gt;state = DT_MASKS_STATE_USE;</a>
<a name="ln270">        if(pos &gt; 0) fpt-&gt;state |= DT_MASKS_STATE_UNION;</a>
<a name="ln271">        grp-&gt;points = g_list_append(grp-&gt;points, fpt);</a>
<a name="ln272">        pos++;</a>
<a name="ln273">      }</a>
<a name="ln274">    }</a>
<a name="ln275">    items = g_list_next(items);</a>
<a name="ln276">  }</a>
<a name="ln277"> </a>
<a name="ln278">  // we add this group to the general list</a>
<a name="ln279">  darktable.develop-&gt;forms = g_list_append(darktable.develop-&gt;forms, grp);</a>
<a name="ln280"> </a>
<a name="ln281">  // add we save</a>
<a name="ln282">  dt_masks_write_forms(darktable.develop);</a>
<a name="ln283">  _lib_masks_recreate_list(self);</a>
<a name="ln284">  // dt_masks_change_form_gui(grp);</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">static void _set_iter_name(dt_lib_masks_t *lm, dt_masks_form_t *form, int state, float opacity,</a>
<a name="ln288">                           GtkTreeModel *model, GtkTreeIter *iter)</a>
<a name="ln289">{</a>
<a name="ln290">  if(!form) return;</a>
<a name="ln291"> </a>
<a name="ln292">  char str[256] = &quot;&quot;;</a>
<a name="ln293">  g_strlcat(str, form-&gt;name, sizeof(str));</a>
<a name="ln294"> </a>
<a name="ln295">  if(opacity != 1.0f)</a>
<a name="ln296">  {</a>
<a name="ln297">    char str2[256] = &quot;&quot;;</a>
<a name="ln298">    g_strlcpy(str2, str, sizeof(str2));</a>
<a name="ln299">    snprintf(str, sizeof(str), &quot;%s %d%%&quot;, str2, (int)(opacity * 100));</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  GdkPixbuf *icop = NULL;</a>
<a name="ln303">  GdkPixbuf *icinv = NULL;</a>
<a name="ln304">  if(state &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln305">    icop = lm-&gt;ic_union;</a>
<a name="ln306">  else if(state &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln307">    icop = lm-&gt;ic_intersection;</a>
<a name="ln308">  else if(state &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln309">    icop = lm-&gt;ic_difference;</a>
<a name="ln310">  else if(state &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln311">    icop = lm-&gt;ic_exclusion;</a>
<a name="ln312">  if(state &amp; DT_MASKS_STATE_INVERSE) icinv = lm-&gt;ic_inverse;</a>
<a name="ln313"> </a>
<a name="ln314">  gtk_tree_store_set(GTK_TREE_STORE(model), iter, TREE_TEXT, str, TREE_IC_OP, icop, TREE_IC_OP_VISIBLE,</a>
<a name="ln315">                     (icop != NULL), TREE_IC_INVERSE, icinv, TREE_IC_INVERSE_VISIBLE, (icinv != NULL), -1);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static void _tree_cleanup(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln319">{</a>
<a name="ln320">  dt_masks_cleanup_unused(darktable.develop);</a>
<a name="ln321">  _lib_masks_recreate_list(self);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">static void _tree_inverse(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln325">{</a>
<a name="ln326">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln327"> </a>
<a name="ln328">  // now we go through all selected nodes</a>
<a name="ln329">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln330">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln331">  int change = 0;</a>
<a name="ln332">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln333">  while(items)</a>
<a name="ln334">  {</a>
<a name="ln335">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln336">    GtkTreeIter iter;</a>
<a name="ln337">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln338">    {</a>
<a name="ln339">      GValue gv = {</a>
<a name="ln340">        0,</a>
<a name="ln341">      };</a>
<a name="ln342">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln343">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln344">      g_value_unset(&amp;gv);</a>
<a name="ln345">      GValue gv3 = {</a>
<a name="ln346">        0,</a>
<a name="ln347">      };</a>
<a name="ln348">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln349">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln350">      g_value_unset(&amp;gv3);</a>
<a name="ln351">      dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grid);</a>
<a name="ln352">      if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln353">      {</a>
<a name="ln354">        // we search the entry to inverse</a>
<a name="ln355">        GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln356">        while(pts)</a>
<a name="ln357">        {</a>
<a name="ln358">          dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln359">          if(pt-&gt;formid == id)</a>
<a name="ln360">          {</a>
<a name="ln361">            if(pt-&gt;state &amp; DT_MASKS_STATE_INVERSE)</a>
<a name="ln362">              pt-&gt;state &amp;= ~DT_MASKS_STATE_INVERSE;</a>
<a name="ln363">            else</a>
<a name="ln364">              pt-&gt;state |= DT_MASKS_STATE_INVERSE;</a>
<a name="ln365">            _set_iter_name(lm, dt_masks_get_from_id(darktable.develop, id), pt-&gt;state, pt-&gt;opacity, model,</a>
<a name="ln366">                           &amp;iter);</a>
<a name="ln367">            change = 1;</a>
<a name="ln368">            break;</a>
<a name="ln369">          }</a>
<a name="ln370">          pts = g_list_next(pts);</a>
<a name="ln371">        }</a>
<a name="ln372">      }</a>
<a name="ln373">    }</a>
<a name="ln374">    items = g_list_next(items);</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  if(change)</a>
<a name="ln378">  {</a>
<a name="ln379">    dt_masks_write_forms(darktable.develop);</a>
<a name="ln380">    dt_masks_update_image(darktable.develop);</a>
<a name="ln381">    dt_control_queue_redraw_center();</a>
<a name="ln382">  }</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">static void _tree_intersection(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln386">{</a>
<a name="ln387">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln388"> </a>
<a name="ln389">  // now we go through all selected nodes</a>
<a name="ln390">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln391">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln392">  int change = 0;</a>
<a name="ln393">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln394">  while(items)</a>
<a name="ln395">  {</a>
<a name="ln396">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln397">    GtkTreeIter iter;</a>
<a name="ln398">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln399">    {</a>
<a name="ln400">      GValue gv = {</a>
<a name="ln401">        0,</a>
<a name="ln402">      };</a>
<a name="ln403">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln404">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln405">      g_value_unset(&amp;gv);</a>
<a name="ln406">      GValue gv3 = {</a>
<a name="ln407">        0,</a>
<a name="ln408">      };</a>
<a name="ln409">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln410">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln411">      g_value_unset(&amp;gv3);</a>
<a name="ln412">      dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grid);</a>
<a name="ln413">      if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln414">      {</a>
<a name="ln415">        // we search the entry to inverse</a>
<a name="ln416">        GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln417">        while(pts)</a>
<a name="ln418">        {</a>
<a name="ln419">          dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln420">          if(pt-&gt;formid == id)</a>
<a name="ln421">          {</a>
<a name="ln422">            if(!(pt-&gt;state &amp; DT_MASKS_STATE_INTERSECTION))</a>
<a name="ln423">            {</a>
<a name="ln424">              if(pt-&gt;state &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln425">                pt-&gt;state &amp;= ~DT_MASKS_STATE_DIFFERENCE;</a>
<a name="ln426">              else if(pt-&gt;state &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln427">                pt-&gt;state &amp;= ~DT_MASKS_STATE_UNION;</a>
<a name="ln428">              else if(pt-&gt;state &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln429">                pt-&gt;state &amp;= ~DT_MASKS_STATE_EXCLUSION;</a>
<a name="ln430">              pt-&gt;state |= DT_MASKS_STATE_INTERSECTION;</a>
<a name="ln431">              _set_iter_name(lm, dt_masks_get_from_id(darktable.develop, id), pt-&gt;state, pt-&gt;opacity, model,</a>
<a name="ln432">                             &amp;iter);</a>
<a name="ln433">              change = 1;</a>
<a name="ln434">            }</a>
<a name="ln435">            break;</a>
<a name="ln436">          }</a>
<a name="ln437">          pts = g_list_next(pts);</a>
<a name="ln438">        }</a>
<a name="ln439">      }</a>
<a name="ln440">    }</a>
<a name="ln441">    items = g_list_next(items);</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  if(change)</a>
<a name="ln445">  {</a>
<a name="ln446">    dt_masks_write_forms(darktable.develop);</a>
<a name="ln447">    dt_masks_update_image(darktable.develop);</a>
<a name="ln448">    dt_control_queue_redraw_center();</a>
<a name="ln449">  }</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">static void _tree_difference(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln453">{</a>
<a name="ln454">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln455"> </a>
<a name="ln456">  // now we go through all selected nodes</a>
<a name="ln457">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln458">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln459">  int change = 0;</a>
<a name="ln460">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln461">  while(items)</a>
<a name="ln462">  {</a>
<a name="ln463">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln464">    GtkTreeIter iter;</a>
<a name="ln465">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln466">    {</a>
<a name="ln467">      GValue gv = {</a>
<a name="ln468">        0,</a>
<a name="ln469">      };</a>
<a name="ln470">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln471">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln472">      g_value_unset(&amp;gv);</a>
<a name="ln473">      GValue gv3 = {</a>
<a name="ln474">        0,</a>
<a name="ln475">      };</a>
<a name="ln476">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln477">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln478">      g_value_unset(&amp;gv3);</a>
<a name="ln479">      dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grid);</a>
<a name="ln480">      if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln481">      {</a>
<a name="ln482">        // we search the entry to inverse</a>
<a name="ln483">        GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln484">        while(pts)</a>
<a name="ln485">        {</a>
<a name="ln486">          dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln487">          if(pt-&gt;formid == id)</a>
<a name="ln488">          {</a>
<a name="ln489">            if(!(pt-&gt;state &amp; DT_MASKS_STATE_DIFFERENCE))</a>
<a name="ln490">            {</a>
<a name="ln491">              if(pt-&gt;state &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln492">                pt-&gt;state &amp;= ~DT_MASKS_STATE_UNION;</a>
<a name="ln493">              else if(pt-&gt;state &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln494">                pt-&gt;state &amp;= ~DT_MASKS_STATE_INTERSECTION;</a>
<a name="ln495">              else if(pt-&gt;state &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln496">                pt-&gt;state &amp;= ~DT_MASKS_STATE_EXCLUSION;</a>
<a name="ln497">              pt-&gt;state |= DT_MASKS_STATE_DIFFERENCE;</a>
<a name="ln498">              _set_iter_name(lm, dt_masks_get_from_id(darktable.develop, id), pt-&gt;state, pt-&gt;opacity, model,</a>
<a name="ln499">                             &amp;iter);</a>
<a name="ln500">              change = 1;</a>
<a name="ln501">            }</a>
<a name="ln502">            break;</a>
<a name="ln503">          }</a>
<a name="ln504">          pts = g_list_next(pts);</a>
<a name="ln505">        }</a>
<a name="ln506">      }</a>
<a name="ln507">    }</a>
<a name="ln508">    items = g_list_next(items);</a>
<a name="ln509">  }</a>
<a name="ln510"> </a>
<a name="ln511">  if(change)</a>
<a name="ln512">  {</a>
<a name="ln513">    dt_masks_write_forms(darktable.develop);</a>
<a name="ln514">    dt_masks_update_image(darktable.develop);</a>
<a name="ln515">    dt_control_queue_redraw_center();</a>
<a name="ln516">  }</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">static void _tree_exclusion(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln520">{</a>
<a name="ln521">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln522"> </a>
<a name="ln523">  // now we go through all selected nodes</a>
<a name="ln524">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln525">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln526">  int change = 0;</a>
<a name="ln527">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln528">  while(items)</a>
<a name="ln529">  {</a>
<a name="ln530">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln531">    GtkTreeIter iter;</a>
<a name="ln532">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln533">    {</a>
<a name="ln534">      GValue gv = {</a>
<a name="ln535">        0,</a>
<a name="ln536">      };</a>
<a name="ln537">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln538">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln539">      g_value_unset(&amp;gv);</a>
<a name="ln540">      GValue gv3 = {</a>
<a name="ln541">        0,</a>
<a name="ln542">      };</a>
<a name="ln543">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln544">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln545">      g_value_unset(&amp;gv3);</a>
<a name="ln546">      dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grid);</a>
<a name="ln547">      if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln548">      {</a>
<a name="ln549">        // we search the entry to inverse</a>
<a name="ln550">        GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln551">        while(pts)</a>
<a name="ln552">        {</a>
<a name="ln553">          dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln554">          if(pt-&gt;formid == id)</a>
<a name="ln555">          {</a>
<a name="ln556">            if(!(pt-&gt;state &amp; DT_MASKS_STATE_EXCLUSION))</a>
<a name="ln557">            {</a>
<a name="ln558">              if(pt-&gt;state &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln559">                pt-&gt;state &amp;= ~DT_MASKS_STATE_DIFFERENCE;</a>
<a name="ln560">              else if(pt-&gt;state &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln561">                pt-&gt;state &amp;= ~DT_MASKS_STATE_INTERSECTION;</a>
<a name="ln562">              else if(pt-&gt;state &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln563">                pt-&gt;state &amp;= ~DT_MASKS_STATE_UNION;</a>
<a name="ln564">              pt-&gt;state |= DT_MASKS_STATE_EXCLUSION;</a>
<a name="ln565">              _set_iter_name(lm, dt_masks_get_from_id(darktable.develop, id), pt-&gt;state, pt-&gt;opacity, model,</a>
<a name="ln566">                             &amp;iter);</a>
<a name="ln567">              change = 1;</a>
<a name="ln568">            }</a>
<a name="ln569">            break;</a>
<a name="ln570">          }</a>
<a name="ln571">          pts = g_list_next(pts);</a>
<a name="ln572">        }</a>
<a name="ln573">      }</a>
<a name="ln574">    }</a>
<a name="ln575">    items = g_list_next(items);</a>
<a name="ln576">  }</a>
<a name="ln577"> </a>
<a name="ln578">  if(change)</a>
<a name="ln579">  {</a>
<a name="ln580">    dt_masks_write_forms(darktable.develop);</a>
<a name="ln581">    dt_masks_update_image(darktable.develop);</a>
<a name="ln582">    dt_control_queue_redraw_center();</a>
<a name="ln583">  }</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">static void _tree_union(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln587">{</a>
<a name="ln588">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln589"> </a>
<a name="ln590">  // now we go through all selected nodes</a>
<a name="ln591">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln592">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln593">  int change = 0;</a>
<a name="ln594">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln595">  while(items)</a>
<a name="ln596">  {</a>
<a name="ln597">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln598">    GtkTreeIter iter;</a>
<a name="ln599">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln600">    {</a>
<a name="ln601">      GValue gv = {</a>
<a name="ln602">        0,</a>
<a name="ln603">      };</a>
<a name="ln604">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln605">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln606">      g_value_unset(&amp;gv);</a>
<a name="ln607">      GValue gv3 = {</a>
<a name="ln608">        0,</a>
<a name="ln609">      };</a>
<a name="ln610">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln611">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln612">      g_value_unset(&amp;gv3);</a>
<a name="ln613">      dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grid);</a>
<a name="ln614">      if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln615">      {</a>
<a name="ln616">        // we search the entry to inverse</a>
<a name="ln617">        GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln618">        while(pts)</a>
<a name="ln619">        {</a>
<a name="ln620">          dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln621">          if(pt-&gt;formid == id)</a>
<a name="ln622">          {</a>
<a name="ln623">            if(!(pt-&gt;state &amp; DT_MASKS_STATE_UNION))</a>
<a name="ln624">            {</a>
<a name="ln625">              if(pt-&gt;state &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln626">                pt-&gt;state &amp;= ~DT_MASKS_STATE_DIFFERENCE;</a>
<a name="ln627">              else if(pt-&gt;state &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln628">                pt-&gt;state &amp;= ~DT_MASKS_STATE_INTERSECTION;</a>
<a name="ln629">              else if(pt-&gt;state &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln630">                pt-&gt;state &amp;= ~DT_MASKS_STATE_EXCLUSION;</a>
<a name="ln631">              pt-&gt;state |= DT_MASKS_STATE_UNION;</a>
<a name="ln632">              _set_iter_name(lm, dt_masks_get_from_id(darktable.develop, id), pt-&gt;state, pt-&gt;opacity, model,</a>
<a name="ln633">                             &amp;iter);</a>
<a name="ln634">              change = 1;</a>
<a name="ln635">            }</a>
<a name="ln636">            break;</a>
<a name="ln637">          }</a>
<a name="ln638">          pts = g_list_next(pts);</a>
<a name="ln639">        }</a>
<a name="ln640">      }</a>
<a name="ln641">    }</a>
<a name="ln642">    items = g_list_next(items);</a>
<a name="ln643">  }</a>
<a name="ln644"> </a>
<a name="ln645">  if(change)</a>
<a name="ln646">  {</a>
<a name="ln647">    dt_masks_write_forms(darktable.develop);</a>
<a name="ln648">    dt_masks_update_image(darktable.develop);</a>
<a name="ln649">    dt_control_queue_redraw_center();</a>
<a name="ln650">  }</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">static void _tree_moveup(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln654">{</a>
<a name="ln655">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln656"> </a>
<a name="ln657">  // we first discard all visible shapes</a>
<a name="ln658">  dt_masks_change_form_gui(NULL);</a>
<a name="ln659"> </a>
<a name="ln660">  // now we go through all selected nodes</a>
<a name="ln661">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln662">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln663">  lm-&gt;gui_reset = 1;</a>
<a name="ln664">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln665">  while(items)</a>
<a name="ln666">  {</a>
<a name="ln667">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln668">    GtkTreeIter iter;</a>
<a name="ln669">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln670">    {</a>
<a name="ln671">      GValue gv = {</a>
<a name="ln672">        0,</a>
<a name="ln673">      };</a>
<a name="ln674">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln675">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln676">      g_value_unset(&amp;gv);</a>
<a name="ln677">      GValue gv3 = {</a>
<a name="ln678">        0,</a>
<a name="ln679">      };</a>
<a name="ln680">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln681">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln682">      g_value_unset(&amp;gv3);</a>
<a name="ln683"> </a>
<a name="ln684">      dt_masks_form_move(dt_masks_get_from_id(darktable.develop, grid), id, 1);</a>
<a name="ln685">    }</a>
<a name="ln686">    items = g_list_next(items);</a>
<a name="ln687">  }</a>
<a name="ln688">  lm-&gt;gui_reset = 0;</a>
<a name="ln689">  _lib_masks_recreate_list(self);</a>
<a name="ln690">  dt_masks_update_image(darktable.develop);</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">static void _tree_movedown(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln694">{</a>
<a name="ln695">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln696"> </a>
<a name="ln697">  // we first discard all visible shapes</a>
<a name="ln698">  dt_masks_change_form_gui(NULL);</a>
<a name="ln699"> </a>
<a name="ln700">  // now we go through all selected nodes</a>
<a name="ln701">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln702">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln703">  lm-&gt;gui_reset = 1;</a>
<a name="ln704">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln705">  while(items)</a>
<a name="ln706">  {</a>
<a name="ln707">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln708">    GtkTreeIter iter;</a>
<a name="ln709">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln710">    {</a>
<a name="ln711">      GValue gv = {</a>
<a name="ln712">        0,</a>
<a name="ln713">      };</a>
<a name="ln714">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln715">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln716">      g_value_unset(&amp;gv);</a>
<a name="ln717">      GValue gv3 = {</a>
<a name="ln718">        0,</a>
<a name="ln719">      };</a>
<a name="ln720">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln721">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln722">      g_value_unset(&amp;gv3);</a>
<a name="ln723"> </a>
<a name="ln724">      dt_masks_form_move(dt_masks_get_from_id(darktable.develop, grid), id, 0);</a>
<a name="ln725">    }</a>
<a name="ln726">    items = g_list_next(items);</a>
<a name="ln727">  }</a>
<a name="ln728">  lm-&gt;gui_reset = 0;</a>
<a name="ln729">  _lib_masks_recreate_list(self);</a>
<a name="ln730">  dt_masks_update_image(darktable.develop);</a>
<a name="ln731">}</a>
<a name="ln732">static void _tree_delete_shape(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln733">{</a>
<a name="ln734">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln735"> </a>
<a name="ln736">  // we first discard all visible shapes</a>
<a name="ln737">  dt_masks_change_form_gui(NULL);</a>
<a name="ln738"> </a>
<a name="ln739">  // now we go through all selected nodes</a>
<a name="ln740">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln741">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln742">  dt_iop_module_t *module = NULL;</a>
<a name="ln743">  lm-&gt;gui_reset = 1;</a>
<a name="ln744">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln745">  while(items)</a>
<a name="ln746">  {</a>
<a name="ln747">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln748">    GtkTreeIter iter;</a>
<a name="ln749">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln750">    {</a>
<a name="ln751">      GValue gv = {</a>
<a name="ln752">        0,</a>
<a name="ln753">      };</a>
<a name="ln754">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln755">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln756">      g_value_unset(&amp;gv);</a>
<a name="ln757">      GValue gv3 = {</a>
<a name="ln758">        0,</a>
<a name="ln759">      };</a>
<a name="ln760">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln761">      int id = g_value_get_int(&amp;gv3);</a>
<a name="ln762">      g_value_unset(&amp;gv3);</a>
<a name="ln763">      GValue gv2 = {</a>
<a name="ln764">        0,</a>
<a name="ln765">      };</a>
<a name="ln766">      gtk_tree_model_get_value(model, &amp;iter, TREE_MODULE, &amp;gv2);</a>
<a name="ln767">      module = NULL;</a>
<a name="ln768">      if(G_VALUE_TYPE(&amp;gv2) == G_TYPE_POINTER) module = (dt_iop_module_t *)g_value_get_pointer(&amp;gv2);</a>
<a name="ln769">      g_value_unset(&amp;gv2);</a>
<a name="ln770"> </a>
<a name="ln771">      dt_masks_form_remove(module, dt_masks_get_from_id(darktable.develop, grid),</a>
<a name="ln772">                           dt_masks_get_from_id(darktable.develop, id));</a>
<a name="ln773">    }</a>
<a name="ln774">    items = g_list_next(items);</a>
<a name="ln775">  }</a>
<a name="ln776">  lm-&gt;gui_reset = 0;</a>
<a name="ln777">  _lib_masks_recreate_list(self);</a>
<a name="ln778">}</a>
<a name="ln779">static void _tree_duplicate_shape(GtkButton *button, dt_lib_module_t *self)</a>
<a name="ln780">{</a>
<a name="ln781">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln782"> </a>
<a name="ln783">  // we get the selected node</a>
<a name="ln784">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln785">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln786">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln787">  if(!items) return;</a>
<a name="ln788">  GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln789">  GtkTreeIter iter;</a>
<a name="ln790">  if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln791">  {</a>
<a name="ln792">    GValue gv3 = {</a>
<a name="ln793">      0,</a>
<a name="ln794">    };</a>
<a name="ln795">    gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln796">    int id = g_value_get_int(&amp;gv3);</a>
<a name="ln797">    g_value_unset(&amp;gv3);</a>
<a name="ln798"> </a>
<a name="ln799">    int nid = dt_masks_form_duplicate(darktable.develop, id);</a>
<a name="ln800">    if(nid &lt;= 0) return;</a>
<a name="ln801">    dt_dev_masks_list_change(darktable.develop);</a>
<a name="ln802">    dt_dev_masks_selection_change(darktable.develop, nid, TRUE);</a>
<a name="ln803">    //_lib_masks_recreate_list(self);</a>
<a name="ln804">  }</a>
<a name="ln805">}</a>
<a name="ln806">static void _tree_cell_editing_started(GtkCellRenderer *cell, GtkCellEditable *editable, const gchar *path,</a>
<a name="ln807">                                       gpointer data)</a>
<a name="ln808">{</a>
<a name="ln809">  dt_control_key_accelerators_off(darktable.control);</a>
<a name="ln810">}</a>
<a name="ln811">static void _tree_cell_edited(GtkCellRendererText *cell, gchar *path_string, gchar *new_text,</a>
<a name="ln812">                              dt_lib_module_t *self)</a>
<a name="ln813">{</a>
<a name="ln814">  dt_control_key_accelerators_on(darktable.control);</a>
<a name="ln815">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln816">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln817">  GtkTreeIter iter;</a>
<a name="ln818">  if(!gtk_tree_model_get_iter_from_string(model, &amp;iter, path_string)) return;</a>
<a name="ln819">  GValue gv3 = {</a>
<a name="ln820">    0,</a>
<a name="ln821">  };</a>
<a name="ln822">  gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln823">  int id = g_value_get_int(&amp;gv3);</a>
<a name="ln824">  g_value_unset(&amp;gv3);</a>
<a name="ln825">  dt_masks_form_t *form = dt_masks_get_from_id(darktable.develop, id);</a>
<a name="ln826">  if(!form) return;</a>
<a name="ln827"> </a>
<a name="ln828">  // we want to make sure that the new name is not an empty string. else this would convert</a>
<a name="ln829">  // in the xmp file into &quot;&lt;rdf:li/&gt;&quot; which produces problems. we use a single whitespace</a>
<a name="ln830">  // as the pure minimum text.</a>
<a name="ln831">  gchar *text = strlen(new_text) == 0 ? &quot; &quot; : new_text;</a>
<a name="ln832"> </a>
<a name="ln833">  // first, we need to update the mask name</a>
<a name="ln834"> </a>
<a name="ln835">  g_strlcpy(form-&gt;name, text, sizeof(form-&gt;name));</a>
<a name="ln836">  dt_masks_write_form(form, darktable.develop);</a>
<a name="ln837"> </a>
<a name="ln838">  // and we update the cell text</a>
<a name="ln839">  _set_iter_name(lm, form, 0, 1.0f, model, &amp;iter);</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">static void _tree_selection_change(GtkTreeSelection *selection, dt_lib_masks_t *self)</a>
<a name="ln843">{</a>
<a name="ln844">  if(self-&gt;gui_reset) return;</a>
<a name="ln845">  // we reset all &quot;show mask&quot; icon of iops</a>
<a name="ln846">  dt_masks_reset_show_masks_icons();</a>
<a name="ln847"> </a>
<a name="ln848">  // if selection empty, we hide all</a>
<a name="ln849">  int nb = gtk_tree_selection_count_selected_rows(selection);</a>
<a name="ln850">  if(nb == 0)</a>
<a name="ln851">  {</a>
<a name="ln852">    dt_masks_change_form_gui(NULL);</a>
<a name="ln853">    dt_control_queue_redraw_center();</a>
<a name="ln854">    return;</a>
<a name="ln855">  }</a>
<a name="ln856"> </a>
<a name="ln857">  // else, we create a new form group with the selection and display it</a>
<a name="ln858">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self-&gt;treeview));</a>
<a name="ln859">  dt_masks_form_t *grp = dt_masks_create(DT_MASKS_GROUP);</a>
<a name="ln860">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln861">  while(items)</a>
<a name="ln862">  {</a>
<a name="ln863">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln864">    GtkTreeIter iter;</a>
<a name="ln865">    if(gtk_tree_model_get_iter(model, &amp;iter, item))</a>
<a name="ln866">    {</a>
<a name="ln867">      GValue gv = {</a>
<a name="ln868">        0,</a>
<a name="ln869">      };</a>
<a name="ln870">      gtk_tree_model_get_value(model, &amp;iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln871">      int grid = g_value_get_int(&amp;gv);</a>
<a name="ln872">      g_value_unset(&amp;gv);</a>
<a name="ln873">      GValue gv2 = {</a>
<a name="ln874">        0,</a>
<a name="ln875">      };</a>
<a name="ln876">      gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv2);</a>
<a name="ln877">      int id = g_value_get_int(&amp;gv2);</a>
<a name="ln878">      g_value_unset(&amp;gv2);</a>
<a name="ln879">      dt_masks_form_t *form = dt_masks_get_from_id(darktable.develop, id);</a>
<a name="ln880">      if(form)</a>
<a name="ln881">      {</a>
<a name="ln882">        dt_masks_point_group_t *fpt = (dt_masks_point_group_t *)malloc(sizeof(dt_masks_point_group_t));</a>
<a name="ln883">        fpt-&gt;formid = id;</a>
<a name="ln884">        fpt-&gt;parentid = grid;</a>
<a name="ln885">        fpt-&gt;state = DT_MASKS_STATE_USE;</a>
<a name="ln886">        fpt-&gt;opacity = 1.0f;</a>
<a name="ln887">        grp-&gt;points = g_list_append(grp-&gt;points, fpt);</a>
<a name="ln888">        // we eventually set the &quot;show masks&quot; icon of iops</a>
<a name="ln889">        if(nb == 1 &amp;&amp; (form-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln890">        {</a>
<a name="ln891">          GValue gv2 = {</a>
<a name="ln892">            0,</a>
<a name="ln893">          };</a>
<a name="ln894">          gtk_tree_model_get_value(model, &amp;iter, TREE_MODULE, &amp;gv2);</a>
<a name="ln895">          dt_iop_module_t *module = g_value_peek_pointer(&amp;gv2);</a>
<a name="ln896">          g_value_unset(&amp;gv2);</a>
<a name="ln897">          if(module &amp;&amp; (module-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING)</a>
<a name="ln898">             &amp;&amp; !(module-&gt;flags() &amp; IOP_FLAGS_NO_MASKS))</a>
<a name="ln899">          {</a>
<a name="ln900">            dt_iop_gui_blend_data_t *bd = (dt_iop_gui_blend_data_t *)module-&gt;blend_data;</a>
<a name="ln901">            bd-&gt;masks_shown = 1;</a>
<a name="ln902">            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(bd-&gt;masks_edit), TRUE);</a>
<a name="ln903">            gtk_widget_queue_draw(bd-&gt;masks_edit);</a>
<a name="ln904">          }</a>
<a name="ln905">        }</a>
<a name="ln906">      }</a>
<a name="ln907">    }</a>
<a name="ln908">    items = g_list_next(items);</a>
<a name="ln909">  }</a>
<a name="ln910">  dt_masks_form_t *grp2 = dt_masks_create(DT_MASKS_GROUP);</a>
<a name="ln911">  grp2-&gt;formid = 0;</a>
<a name="ln912">  dt_masks_group_ungroup(grp2, grp);</a>
<a name="ln913">  dt_masks_change_form_gui(grp2);</a>
<a name="ln914">  darktable.develop-&gt;form_gui-&gt;edit_mode = DT_MASKS_EDIT_FULL;</a>
<a name="ln915">  dt_control_queue_redraw_center();</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">static int _tree_button_pressed(GtkWidget *treeview, GdkEventButton *event, dt_lib_module_t *self)</a>
<a name="ln919">{</a>
<a name="ln920">  // dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln921">  // we first need to adjust selection</a>
<a name="ln922">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));</a>
<a name="ln923">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(treeview));</a>
<a name="ln924"> </a>
<a name="ln925">  GtkTreePath *mouse_path = NULL;</a>
<a name="ln926">  GtkTreeIter iter;</a>
<a name="ln927">  dt_iop_module_t *module = NULL;</a>
<a name="ln928">  int on_row = 0;</a>
<a name="ln929">  if(gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(treeview), (gint)event-&gt;x, (gint)event-&gt;y, &amp;mouse_path, NULL,</a>
<a name="ln930">                                   NULL, NULL))</a>
<a name="ln931">  {</a>
<a name="ln932">    on_row = 1;</a>
<a name="ln933">    // we retrieve the iter and module from path</a>
<a name="ln934">    if(gtk_tree_model_get_iter(model, &amp;iter, mouse_path))</a>
<a name="ln935">    {</a>
<a name="ln936">      GValue gv = {</a>
<a name="ln937">        0,</a>
<a name="ln938">      };</a>
<a name="ln939">      gtk_tree_model_get_value(model, &amp;iter, TREE_MODULE, &amp;gv);</a>
<a name="ln940">      module = g_value_peek_pointer(&amp;gv);</a>
<a name="ln941">      g_value_unset(&amp;gv);</a>
<a name="ln942">    }</a>
<a name="ln943">  }</a>
<a name="ln944">  /* single click with the right mouse button? */</a>
<a name="ln945">  if(event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 1)</a>
<a name="ln946">  {</a>
<a name="ln947">    // if click on a blank space, then deselect all</a>
<a name="ln948">    if(!on_row)</a>
<a name="ln949">    {</a>
<a name="ln950">      gtk_tree_selection_unselect_all(selection);</a>
<a name="ln951">    }</a>
<a name="ln952">  }</a>
<a name="ln953">  else if(event-&gt;type == GDK_BUTTON_PRESS &amp;&amp; event-&gt;button == 3)</a>
<a name="ln954">  {</a>
<a name="ln955">    // if we are already inside the selection, no change</a>
<a name="ln956">    if(on_row &amp;&amp; !gtk_tree_selection_path_is_selected(selection, mouse_path))</a>
<a name="ln957">    {</a>
<a name="ln958">      if(!(event-&gt;state &amp; GDK_CONTROL_MASK)) gtk_tree_selection_unselect_all(selection);</a>
<a name="ln959">      gtk_tree_selection_select_path(selection, mouse_path);</a>
<a name="ln960">      gtk_tree_path_free(mouse_path);</a>
<a name="ln961">    }</a>
<a name="ln962"> </a>
<a name="ln963">    // and we display the context-menu</a>
<a name="ln964">    GtkMenuShell *menu;</a>
<a name="ln965">    GtkWidget *item;</a>
<a name="ln966">    menu = GTK_MENU_SHELL(gtk_menu_new());</a>
<a name="ln967"> </a>
<a name="ln968">    // we get all infos from selection</a>
<a name="ln969">    int nb = gtk_tree_selection_count_selected_rows(selection);</a>
<a name="ln970">    int from_group = 0;</a>
<a name="ln971"> </a>
<a name="ln972">    GtkTreePath *it0 = NULL;</a>
<a name="ln973">    int depth = 0;</a>
<a name="ln974">    if(nb &gt; 0)</a>
<a name="ln975">    {</a>
<a name="ln976">      it0 = (GtkTreePath *)g_list_nth_data(gtk_tree_selection_get_selected_rows(selection, NULL), 0);</a>
<a name="ln977">      depth = gtk_tree_path_get_depth(it0);</a>
<a name="ln978">    }</a>
<a name="ln979">    if(depth &gt; 1) from_group = 1;</a>
<a name="ln980"> </a>
<a name="ln981">    if(nb == 0)</a>
<a name="ln982">    {</a>
<a name="ln983">      item = gtk_menu_item_new_with_label(_(&quot;add circle&quot;));</a>
<a name="ln984">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_circle, module);</a>
<a name="ln985">      gtk_menu_shell_append(menu, item);</a>
<a name="ln986"> </a>
<a name="ln987">      item = gtk_menu_item_new_with_label(_(&quot;add ellipse&quot;));</a>
<a name="ln988">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_ellipse, module);</a>
<a name="ln989">      gtk_menu_shell_append(menu, item);</a>
<a name="ln990"> </a>
<a name="ln991">      item = gtk_menu_item_new_with_label(_(&quot;add path&quot;));</a>
<a name="ln992">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_path, module);</a>
<a name="ln993">      gtk_menu_shell_append(menu, item);</a>
<a name="ln994"> </a>
<a name="ln995">      item = gtk_menu_item_new_with_label(_(&quot;add gradient&quot;));</a>
<a name="ln996">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_gradient, module);</a>
<a name="ln997">      gtk_menu_shell_append(menu, item);</a>
<a name="ln998"> </a>
<a name="ln999">      gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1000">    }</a>
<a name="ln1001"> </a>
<a name="ln1002">    if(nb == 1)</a>
<a name="ln1003">    {</a>
<a name="ln1004">      // we check if the form is a group or not</a>
<a name="ln1005">      int grpid = 0;</a>
<a name="ln1006">      if(gtk_tree_model_get_iter(model, &amp;iter, it0))</a>
<a name="ln1007">      {</a>
<a name="ln1008">        GValue gv = {</a>
<a name="ln1009">          0,</a>
<a name="ln1010">        };</a>
<a name="ln1011">        gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv);</a>
<a name="ln1012">        grpid = g_value_get_int(&amp;gv);</a>
<a name="ln1013">        g_value_unset(&amp;gv);</a>
<a name="ln1014">      }</a>
<a name="ln1015">      dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grpid);</a>
<a name="ln1016">      if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln1017">      {</a>
<a name="ln1018">        item = gtk_menu_item_new_with_label(_(&quot;add brush&quot;));</a>
<a name="ln1019">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_brush, module);</a>
<a name="ln1020">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1021"> </a>
<a name="ln1022">        item = gtk_menu_item_new_with_label(_(&quot;add circle&quot;));</a>
<a name="ln1023">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_circle, module);</a>
<a name="ln1024">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1025"> </a>
<a name="ln1026">        item = gtk_menu_item_new_with_label(_(&quot;add ellipse&quot;));</a>
<a name="ln1027">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_ellipse, module);</a>
<a name="ln1028">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1029"> </a>
<a name="ln1030">        item = gtk_menu_item_new_with_label(_(&quot;add path&quot;));</a>
<a name="ln1031">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_path, module);</a>
<a name="ln1032">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1033"> </a>
<a name="ln1034">        item = gtk_menu_item_new_with_label(_(&quot;add gradient&quot;));</a>
<a name="ln1035">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_add_gradient, module);</a>
<a name="ln1036">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1037"> </a>
<a name="ln1038">        item = gtk_menu_item_new_with_label(_(&quot;add existing shape&quot;));</a>
<a name="ln1039">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1040">        gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1041">        // existing forms</a>
<a name="ln1042">        GtkWidget *menu0 = gtk_menu_new();</a>
<a name="ln1043">        gtk_menu_item_set_submenu(GTK_MENU_ITEM(item), menu0);</a>
<a name="ln1044">        GList *forms = g_list_first(darktable.develop-&gt;forms);</a>
<a name="ln1045">        while(forms)</a>
<a name="ln1046">        {</a>
<a name="ln1047">          dt_masks_form_t *form = (dt_masks_form_t *)forms-&gt;data;</a>
<a name="ln1048">          if((form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE)) || form-&gt;formid == grpid)</a>
<a name="ln1049">          {</a>
<a name="ln1050">            forms = g_list_next(forms);</a>
<a name="ln1051">            continue;</a>
<a name="ln1052">          }</a>
<a name="ln1053">          char str[10000] = &quot;&quot;;</a>
<a name="ln1054">          g_strlcat(str, form-&gt;name, sizeof(str));</a>
<a name="ln1055">          int nbuse = 0;</a>
<a name="ln1056"> </a>
<a name="ln1057">          // we search were this form is used</a>
<a name="ln1058">          GList *modules = g_list_first(darktable.develop-&gt;iop);</a>
<a name="ln1059">          while(modules)</a>
<a name="ln1060">          {</a>
<a name="ln1061">            dt_iop_module_t *m = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1062">            dt_masks_form_t *grp = dt_masks_get_from_id(m-&gt;dev, m-&gt;blend_params-&gt;mask_id);</a>
<a name="ln1063">            if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln1064">            {</a>
<a name="ln1065">              GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln1066">              while(pts)</a>
<a name="ln1067">              {</a>
<a name="ln1068">                dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln1069">                if(pt-&gt;formid == form-&gt;formid)</a>
<a name="ln1070">                {</a>
<a name="ln1071">                  if(m == module)</a>
<a name="ln1072">                  {</a>
<a name="ln1073">                    nbuse = -1;</a>
<a name="ln1074">                    break;</a>
<a name="ln1075">                  }</a>
<a name="ln1076">                  if(nbuse == 0) g_strlcat(str, &quot; (&quot;, sizeof(str));</a>
<a name="ln1077">                  g_strlcat(str, &quot; &quot;, sizeof(str));</a>
<a name="ln1078">                  gchar *module_label = dt_history_item_get_name(m);</a>
<a name="ln1079">                  g_strlcat(str, module_label, sizeof(str));</a>
<a name="ln1080">                  g_free(module_label);</a>
<a name="ln1081">                  nbuse++;</a>
<a name="ln1082">                }</a>
<a name="ln1083">                pts = g_list_next(pts);</a>
<a name="ln1084">              }</a>
<a name="ln1085">            }</a>
<a name="ln1086">            modules = g_list_next(modules);</a>
<a name="ln1087">          }</a>
<a name="ln1088">          if(nbuse != -1)</a>
<a name="ln1089">          {</a>
<a name="ln1090">            if(nbuse &gt; 0) g_strlcat(str, &quot; )&quot;, sizeof(str));</a>
<a name="ln1091"> </a>
<a name="ln1092">            // we add the menu entry</a>
<a name="ln1093">            item = gtk_menu_item_new_with_label(str);</a>
<a name="ln1094">            g_object_set_data(G_OBJECT(item), &quot;formid&quot;, GUINT_TO_POINTER(form-&gt;formid));</a>
<a name="ln1095">            g_signal_connect(G_OBJECT(item), &quot;activate&quot;, G_CALLBACK(_tree_add_exist), grp);</a>
<a name="ln1096">            gtk_menu_shell_append(menu, item);</a>
<a name="ln1097">          }</a>
<a name="ln1098"> </a>
<a name="ln1099">          forms = g_list_next(forms);</a>
<a name="ln1100">        }</a>
<a name="ln1101">      }</a>
<a name="ln1102">    }</a>
<a name="ln1103"> </a>
<a name="ln1104">    if(!from_group &amp;&amp; nb &gt; 0)</a>
<a name="ln1105">    {</a>
<a name="ln1106">      if(nb == 1)</a>
<a name="ln1107">      {</a>
<a name="ln1108">        item = gtk_menu_item_new_with_label(_(&quot;duplicate this shape&quot;));</a>
<a name="ln1109">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_duplicate_shape, self);</a>
<a name="ln1110">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1111">      }</a>
<a name="ln1112">      item = gtk_menu_item_new_with_label(_(&quot;delete this shape&quot;));</a>
<a name="ln1113">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_delete_shape, self);</a>
<a name="ln1114">      gtk_menu_shell_append(menu, item);</a>
<a name="ln1115">    }</a>
<a name="ln1116">    else if(nb &gt; 0 &amp;&amp; depth &lt; 3)</a>
<a name="ln1117">    {</a>
<a name="ln1118">      item = gtk_menu_item_new_with_label(_(&quot;remove from group&quot;));</a>
<a name="ln1119">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_delete_shape, self);</a>
<a name="ln1120">      gtk_menu_shell_append(menu, item);</a>
<a name="ln1121">    }</a>
<a name="ln1122"> </a>
<a name="ln1123">    if(nb &gt; 1 &amp;&amp; !from_group)</a>
<a name="ln1124">    {</a>
<a name="ln1125">      gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1126">      item = gtk_menu_item_new_with_label(_(&quot;group the forms&quot;));</a>
<a name="ln1127">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_group, self);</a>
<a name="ln1128">      gtk_menu_shell_append(menu, item);</a>
<a name="ln1129">    }</a>
<a name="ln1130"> </a>
<a name="ln1131"> </a>
<a name="ln1132">    if(from_group &amp;&amp; depth &lt; 3)</a>
<a name="ln1133">    {</a>
<a name="ln1134">      gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1135">      item = gtk_menu_item_new_with_label(_(&quot;use inversed shape&quot;));</a>
<a name="ln1136">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_inverse, self);</a>
<a name="ln1137">      gtk_menu_shell_append(menu, item);</a>
<a name="ln1138">      if(nb == 1)</a>
<a name="ln1139">      {</a>
<a name="ln1140">        gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1141">        item = gtk_menu_item_new_with_label(_(&quot;mode : union&quot;));</a>
<a name="ln1142">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_union, self);</a>
<a name="ln1143">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1144">        item = gtk_menu_item_new_with_label(_(&quot;mode : intersection&quot;));</a>
<a name="ln1145">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_intersection, self);</a>
<a name="ln1146">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1147">        item = gtk_menu_item_new_with_label(_(&quot;mode : difference&quot;));</a>
<a name="ln1148">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_difference, self);</a>
<a name="ln1149">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1150">        item = gtk_menu_item_new_with_label(_(&quot;mode : exclusion&quot;));</a>
<a name="ln1151">        g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_exclusion, self);</a>
<a name="ln1152">        gtk_menu_shell_append(menu, item);</a>
<a name="ln1153">      }</a>
<a name="ln1154">      gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1155">      item = gtk_menu_item_new_with_label(_(&quot;move up&quot;));</a>
<a name="ln1156">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_moveup, self);</a>
<a name="ln1157">      gtk_menu_shell_append(menu, item);</a>
<a name="ln1158">      item = gtk_menu_item_new_with_label(_(&quot;move down&quot;));</a>
<a name="ln1159">      g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_movedown, self);</a>
<a name="ln1160">      gtk_menu_shell_append(menu, item);</a>
<a name="ln1161">    }</a>
<a name="ln1162"> </a>
<a name="ln1163">    gtk_menu_shell_append(menu, gtk_separator_menu_item_new());</a>
<a name="ln1164">    item = gtk_menu_item_new_with_label(_(&quot;cleanup unused shapes&quot;));</a>
<a name="ln1165">    g_signal_connect(item, &quot;activate&quot;, (GCallback)_tree_cleanup, self);</a>
<a name="ln1166">    gtk_menu_shell_append(menu, item);</a>
<a name="ln1167"> </a>
<a name="ln1168">    gtk_widget_show_all(GTK_WIDGET(menu));</a>
<a name="ln1169"> </a>
<a name="ln1170">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1171">    gtk_menu_popup_at_pointer(GTK_MENU(menu), (GdkEvent *)event);</a>
<a name="ln1172">#else</a>
<a name="ln1173">    gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, gdk_event_get_time((GdkEvent *)event));</a>
<a name="ln1174">#endif</a>
<a name="ln1175"> </a>
<a name="ln1176">    return 1;</a>
<a name="ln1177">  }</a>
<a name="ln1178"> </a>
<a name="ln1179">  return 0;</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">static gboolean _tree_restrict_select(GtkTreeSelection *selection, GtkTreeModel *model, GtkTreePath *path,</a>
<a name="ln1183">                                      gboolean path_currently_selected, gpointer data)</a>
<a name="ln1184">{</a>
<a name="ln1185">  dt_lib_masks_t *self = (dt_lib_masks_t *)data;</a>
<a name="ln1186">  if(self-&gt;gui_reset) return TRUE;</a>
<a name="ln1187"> </a>
<a name="ln1188">  // if the change is SELECT-&gt;UNSELECT no pb</a>
<a name="ln1189">  if(path_currently_selected) return TRUE;</a>
<a name="ln1190"> </a>
<a name="ln1191">  // if selection is empty, no pb</a>
<a name="ln1192">  if(gtk_tree_selection_count_selected_rows(selection) == 0) return TRUE;</a>
<a name="ln1193"> </a>
<a name="ln1194">  // now we unselect all members of selection with not the same parent node</a>
<a name="ln1195">  // idem for all those with a different depth</a>
<a name="ln1196">  int *indices = gtk_tree_path_get_indices(path);</a>
<a name="ln1197">  int depth = gtk_tree_path_get_depth(path);</a>
<a name="ln1198"> </a>
<a name="ln1199">  GList *items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln1200">  while(items)</a>
<a name="ln1201">  {</a>
<a name="ln1202">    GtkTreePath *item = (GtkTreePath *)items-&gt;data;</a>
<a name="ln1203">    int dd = gtk_tree_path_get_depth(item);</a>
<a name="ln1204">    int *ii = gtk_tree_path_get_indices(item);</a>
<a name="ln1205">    int ok = 1;</a>
<a name="ln1206">    if(dd != depth)</a>
<a name="ln1207">      ok = 0;</a>
<a name="ln1208">    else if(dd == 1)</a>
<a name="ln1209">      ok = 1;</a>
<a name="ln1210">    else if(ii[dd - 2] != indices[dd - 2])</a>
<a name="ln1211">      ok = 0;</a>
<a name="ln1212">    if(!ok)</a>
<a name="ln1213">    {</a>
<a name="ln1214">      gtk_tree_selection_unselect_path(selection, item);</a>
<a name="ln1215">      items = g_list_first(gtk_tree_selection_get_selected_rows(selection, NULL));</a>
<a name="ln1216">      continue;</a>
<a name="ln1217">    }</a>
<a name="ln1218">    items = g_list_next(items);</a>
<a name="ln1219">  }</a>
<a name="ln1220">  return TRUE;</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">static gboolean _tree_query_tooltip(GtkWidget *widget, gint x, gint y, gboolean keyboard_tip,</a>
<a name="ln1224">                                    GtkTooltip *tooltip, gpointer data)</a>
<a name="ln1225">{</a>
<a name="ln1226">  GtkTreeIter iter;</a>
<a name="ln1227">  GtkTreeView *tree_view = GTK_TREE_VIEW(widget);</a>
<a name="ln1228">  GtkTreeModel *model = gtk_tree_view_get_model(tree_view);</a>
<a name="ln1229">  GtkTreePath *path = NULL;</a>
<a name="ln1230">  gchar *tmp;</a>
<a name="ln1231">  gboolean show;</a>
<a name="ln1232"> </a>
<a name="ln1233">  char buffer[512];</a>
<a name="ln1234"> </a>
<a name="ln1235">  if(!gtk_tree_view_get_tooltip_context(tree_view, &amp;x, &amp;y, keyboard_tip, &amp;model, &amp;path, &amp;iter)) return FALSE;</a>
<a name="ln1236"> </a>
<a name="ln1237">  gtk_tree_model_get(model, &amp;iter, TREE_IC_USED_VISIBLE, &amp;show, TREE_USED_TEXT, &amp;tmp, -1);</a>
<a name="ln1238">  if(!show) return FALSE;</a>
<a name="ln1239"> </a>
<a name="ln1240">  g_strlcpy(buffer, tmp, sizeof(buffer));</a>
<a name="ln1241">  gtk_tooltip_set_markup(tooltip, buffer);</a>
<a name="ln1242"> </a>
<a name="ln1243">  gtk_tree_view_set_tooltip_row(tree_view, tooltip, path);</a>
<a name="ln1244"> </a>
<a name="ln1245">  gtk_tree_path_free(path);</a>
<a name="ln1246">  g_free(tmp);</a>
<a name="ln1247"> </a>
<a name="ln1248">  return TRUE;</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">static int _is_form_used(int formid, dt_masks_form_t *grp, char *text, size_t text_length)</a>
<a name="ln1252">{</a>
<a name="ln1253">  int nb = 0;</a>
<a name="ln1254">  if(!grp)</a>
<a name="ln1255">  {</a>
<a name="ln1256">    GList *forms = g_list_first(darktable.develop-&gt;forms);</a>
<a name="ln1257">    while(forms)</a>
<a name="ln1258">    {</a>
<a name="ln1259">      dt_masks_form_t *form = (dt_masks_form_t *)forms-&gt;data;</a>
<a name="ln1260">      if(form-&gt;type &amp; DT_MASKS_GROUP) nb += _is_form_used(formid, form, text, text_length);</a>
<a name="ln1261">      forms = g_list_next(forms);</a>
<a name="ln1262">    }</a>
<a name="ln1263">  }</a>
<a name="ln1264">  else if(grp-&gt;type &amp; DT_MASKS_GROUP)</a>
<a name="ln1265">  {</a>
<a name="ln1266">    GList *points = g_list_first(grp-&gt;points);</a>
<a name="ln1267">    while(points)</a>
<a name="ln1268">    {</a>
<a name="ln1269">      dt_masks_point_group_t *point = (dt_masks_point_group_t *)points-&gt;data;</a>
<a name="ln1270">      dt_masks_form_t *form = dt_masks_get_from_id(darktable.develop, point-&gt;formid);</a>
<a name="ln1271">      if(form)</a>
<a name="ln1272">      {</a>
<a name="ln1273">        if(point-&gt;formid == formid)</a>
<a name="ln1274">        {</a>
<a name="ln1275">          nb++;</a>
<a name="ln1276">          if(nb &gt; 1) g_strlcat(text, &quot;\n&quot;, text_length);</a>
<a name="ln1277">          g_strlcat(text, grp-&gt;name, text_length);</a>
<a name="ln1278">        }</a>
<a name="ln1279">        if(form-&gt;type &amp; DT_MASKS_GROUP) nb += _is_form_used(formid, form, text, text_length);</a>
<a name="ln1280">      }</a>
<a name="ln1281">      points = g_list_next(points);</a>
<a name="ln1282">    }</a>
<a name="ln1283">  }</a>
<a name="ln1284">  return nb;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">static void _lib_masks_list_recurs(GtkTreeStore *treestore, GtkTreeIter *toplevel, dt_masks_form_t *form,</a>
<a name="ln1288">                                   int grp_id, dt_iop_module_t *module, int gstate, float opacity,</a>
<a name="ln1289">                                   dt_lib_masks_t *lm)</a>
<a name="ln1290">{</a>
<a name="ln1291">  if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE)) return;</a>
<a name="ln1292">  // we create the text entry</a>
<a name="ln1293">  char str[256] = &quot;&quot;;</a>
<a name="ln1294">  g_strlcat(str, form-&gt;name, sizeof(str));</a>
<a name="ln1295">  // we get the right pixbufs</a>
<a name="ln1296">  GdkPixbuf *icop = NULL;</a>
<a name="ln1297">  GdkPixbuf *icinv = NULL;</a>
<a name="ln1298">  GdkPixbuf *icuse = NULL;</a>
<a name="ln1299">  if(gstate &amp; DT_MASKS_STATE_UNION)</a>
<a name="ln1300">    icop = lm-&gt;ic_union;</a>
<a name="ln1301">  else if(gstate &amp; DT_MASKS_STATE_INTERSECTION)</a>
<a name="ln1302">    icop = lm-&gt;ic_intersection;</a>
<a name="ln1303">  else if(gstate &amp; DT_MASKS_STATE_DIFFERENCE)</a>
<a name="ln1304">    icop = lm-&gt;ic_difference;</a>
<a name="ln1305">  else if(gstate &amp; DT_MASKS_STATE_EXCLUSION)</a>
<a name="ln1306">    icop = lm-&gt;ic_exclusion;</a>
<a name="ln1307">  if(gstate &amp; DT_MASKS_STATE_INVERSE) icinv = lm-&gt;ic_inverse;</a>
<a name="ln1308">  char str2[1000] = &quot;&quot;;</a>
<a name="ln1309">  int nbuse = 0;</a>
<a name="ln1310">  if(grp_id == 0)</a>
<a name="ln1311">  {</a>
<a name="ln1312">    nbuse = _is_form_used(form-&gt;formid, NULL, str2, sizeof(str2));</a>
<a name="ln1313">    if(nbuse &gt; 0) icuse = lm-&gt;ic_used;</a>
<a name="ln1314">  }</a>
<a name="ln1315"> </a>
<a name="ln1316">  if(!(form-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln1317">  {</a>
<a name="ln1318">    // we just add it to the tree</a>
<a name="ln1319">    GtkTreeIter child;</a>
<a name="ln1320">    gtk_tree_store_append(treestore, &amp;child, toplevel);</a>
<a name="ln1321">    gtk_tree_store_set(treestore, &amp;child, TREE_TEXT, str, TREE_MODULE, module, TREE_GROUPID, grp_id,</a>
<a name="ln1322">                       TREE_FORMID, form-&gt;formid, TREE_EDITABLE, (grp_id == 0), TREE_IC_OP, icop,</a>
<a name="ln1323">                       TREE_IC_OP_VISIBLE, (icop != NULL), TREE_IC_INVERSE, icinv, TREE_IC_INVERSE_VISIBLE,</a>
<a name="ln1324">                       (icinv != NULL), TREE_IC_USED, icuse, TREE_IC_USED_VISIBLE, (nbuse &gt; 0),</a>
<a name="ln1325">                       TREE_USED_TEXT, str2, -1);</a>
<a name="ln1326">    _set_iter_name(lm, form, gstate, opacity, GTK_TREE_MODEL(treestore), &amp;child);</a>
<a name="ln1327">  }</a>
<a name="ln1328">  else</a>
<a name="ln1329">  {</a>
<a name="ln1330">    // we first check if it's a &quot;module&quot; group or not</a>
<a name="ln1331">    if(grp_id == 0 &amp;&amp; !module)</a>
<a name="ln1332">    {</a>
<a name="ln1333">      GList *iops = g_list_first(darktable.develop-&gt;iop);</a>
<a name="ln1334">      while(iops)</a>
<a name="ln1335">      {</a>
<a name="ln1336">        dt_iop_module_t *iop = (dt_iop_module_t *)iops-&gt;data;</a>
<a name="ln1337">        if((iop-&gt;flags() &amp; IOP_FLAGS_SUPPORTS_BLENDING) &amp;&amp; !(iop-&gt;flags() &amp; IOP_FLAGS_NO_MASKS)</a>
<a name="ln1338">           &amp;&amp; iop-&gt;blend_params-&gt;mask_id == form-&gt;formid)</a>
<a name="ln1339">        {</a>
<a name="ln1340">          module = iop;</a>
<a name="ln1341">          break;</a>
<a name="ln1342">        }</a>
<a name="ln1343">        iops = g_list_next(iops);</a>
<a name="ln1344">      }</a>
<a name="ln1345">    }</a>
<a name="ln1346"> </a>
<a name="ln1347">    // we add the group node to the tree</a>
<a name="ln1348">    GtkTreeIter child;</a>
<a name="ln1349">    gtk_tree_store_append(treestore, &amp;child, toplevel);</a>
<a name="ln1350">    gtk_tree_store_set(treestore, &amp;child, TREE_TEXT, str, TREE_MODULE, module, TREE_GROUPID, grp_id,</a>
<a name="ln1351">                       TREE_FORMID, form-&gt;formid, TREE_EDITABLE, (grp_id == 0), TREE_IC_OP, icop,</a>
<a name="ln1352">                       TREE_IC_OP_VISIBLE, (icop != NULL), TREE_IC_INVERSE, icinv, TREE_IC_INVERSE_VISIBLE,</a>
<a name="ln1353">                       (icinv != NULL), TREE_IC_USED, icuse, TREE_IC_USED_VISIBLE, (nbuse &gt; 0),</a>
<a name="ln1354">                       TREE_USED_TEXT, str2, -1);</a>
<a name="ln1355">    _set_iter_name(lm, form, gstate, opacity, GTK_TREE_MODEL(treestore), &amp;child);</a>
<a name="ln1356">    // we add all nodes to the tree</a>
<a name="ln1357">    GList *forms = g_list_first(form-&gt;points);</a>
<a name="ln1358">    while(forms)</a>
<a name="ln1359">    {</a>
<a name="ln1360">      dt_masks_point_group_t *grpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln1361">      dt_masks_form_t *f = dt_masks_get_from_id(darktable.develop, grpt-&gt;formid);</a>
<a name="ln1362">      if(f)</a>
<a name="ln1363">        _lib_masks_list_recurs(treestore, &amp;child, f, form-&gt;formid, module, grpt-&gt;state, grpt-&gt;opacity, lm);</a>
<a name="ln1364">      forms = g_list_next(forms);</a>
<a name="ln1365">    }</a>
<a name="ln1366">  }</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369">static void _lib_masks_recreate_list(dt_lib_module_t *self)</a>
<a name="ln1370">{</a>
<a name="ln1371">  /* first destroy all buttons in list */</a>
<a name="ln1372">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln1373">  if(lm-&gt;gui_reset) return;</a>
<a name="ln1374"> </a>
<a name="ln1375">  // if (lm-&gt;treeview) gtk_widget_destroy(lm-&gt;treeview);</a>
<a name="ln1376"> </a>
<a name="ln1377">  _lib_masks_inactivate_icons(self);</a>
<a name="ln1378"> </a>
<a name="ln1379">  GtkTreeStore *treestore;</a>
<a name="ln1380">  // we store : text ; *module ; groupid ; formid</a>
<a name="ln1381">  treestore = gtk_tree_store_new(TREE_COUNT, G_TYPE_STRING, G_TYPE_POINTER, G_TYPE_INT, G_TYPE_INT,</a>
<a name="ln1382">                                 G_TYPE_BOOLEAN, GDK_TYPE_PIXBUF, G_TYPE_BOOLEAN, GDK_TYPE_PIXBUF,</a>
<a name="ln1383">                                 G_TYPE_BOOLEAN, GDK_TYPE_PIXBUF, G_TYPE_BOOLEAN, G_TYPE_STRING);</a>
<a name="ln1384"> </a>
<a name="ln1385">  // we first add all groups</a>
<a name="ln1386">  GList *forms = g_list_first(darktable.develop-&gt;forms);</a>
<a name="ln1387">  while(forms)</a>
<a name="ln1388">  {</a>
<a name="ln1389">    dt_masks_form_t *form = (dt_masks_form_t *)forms-&gt;data;</a>
<a name="ln1390">    if(form-&gt;type &amp; DT_MASKS_GROUP) _lib_masks_list_recurs(treestore, NULL, form, 0, NULL, 0, 1.0, lm);</a>
<a name="ln1391">    forms = g_list_next(forms);</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  // and we add all forms</a>
<a name="ln1395">  forms = g_list_first(darktable.develop-&gt;forms);</a>
<a name="ln1396">  while(forms)</a>
<a name="ln1397">  {</a>
<a name="ln1398">    dt_masks_form_t *form = (dt_masks_form_t *)forms-&gt;data;</a>
<a name="ln1399">    if(!(form-&gt;type &amp; DT_MASKS_GROUP)) _lib_masks_list_recurs(treestore, NULL, form, 0, NULL, 0, 1.0, lm);</a>
<a name="ln1400">    forms = g_list_next(forms);</a>
<a name="ln1401">  }</a>
<a name="ln1402"> </a>
<a name="ln1403">  gtk_tree_view_set_model(GTK_TREE_VIEW(lm-&gt;treeview), GTK_TREE_MODEL(treestore));</a>
<a name="ln1404">  g_object_unref(treestore);</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">static gboolean _update_foreach(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln1408">{</a>
<a name="ln1409">  if(!iter) return 0;</a>
<a name="ln1410"> </a>
<a name="ln1411">  // we retrieve the ids</a>
<a name="ln1412">  GValue gv = {</a>
<a name="ln1413">    0,</a>
<a name="ln1414">  };</a>
<a name="ln1415">  gtk_tree_model_get_value(model, iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln1416">  int grid = g_value_get_int(&amp;gv);</a>
<a name="ln1417">  g_value_unset(&amp;gv);</a>
<a name="ln1418">  GValue gv3 = {</a>
<a name="ln1419">    0,</a>
<a name="ln1420">  };</a>
<a name="ln1421">  gtk_tree_model_get_value(model, iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln1422">  int id = g_value_get_int(&amp;gv3);</a>
<a name="ln1423">  g_value_unset(&amp;gv3);</a>
<a name="ln1424"> </a>
<a name="ln1425">  // we retrieve the forms</a>
<a name="ln1426">  dt_masks_form_t *form = dt_masks_get_from_id(darktable.develop, id);</a>
<a name="ln1427">  if(!form) return 0;</a>
<a name="ln1428">  dt_masks_form_t *grp = dt_masks_get_from_id(darktable.develop, grid);</a>
<a name="ln1429"> </a>
<a name="ln1430">  // and the values</a>
<a name="ln1431">  int state = 0;</a>
<a name="ln1432">  float opacity = 1.0f;</a>
<a name="ln1433"> </a>
<a name="ln1434">  if(grp &amp;&amp; (grp-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln1435">  {</a>
<a name="ln1436">    GList *pts = g_list_first(grp-&gt;points);</a>
<a name="ln1437">    while(pts)</a>
<a name="ln1438">    {</a>
<a name="ln1439">      dt_masks_point_group_t *pt = (dt_masks_point_group_t *)pts-&gt;data;</a>
<a name="ln1440">      if(pt-&gt;formid == id)</a>
<a name="ln1441">      {</a>
<a name="ln1442">        state = pt-&gt;state;</a>
<a name="ln1443">        opacity = pt-&gt;opacity;</a>
<a name="ln1444">        break;</a>
<a name="ln1445">      }</a>
<a name="ln1446">      pts = g_list_next(pts);</a>
<a name="ln1447">    }</a>
<a name="ln1448">  }</a>
<a name="ln1449"> </a>
<a name="ln1450">  _set_iter_name(data, form, state, opacity, model, iter);</a>
<a name="ln1451">  return 0;</a>
<a name="ln1452">}</a>
<a name="ln1453"> </a>
<a name="ln1454">static void _lib_masks_update_list(dt_lib_module_t *self)</a>
<a name="ln1455">{</a>
<a name="ln1456">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln1457">  // for each node , we refresh the string</a>
<a name="ln1458">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln1459">  gtk_tree_model_foreach(model, _update_foreach, lm);</a>
<a name="ln1460">}</a>
<a name="ln1461"> </a>
<a name="ln1462">static gboolean _remove_foreach(GtkTreeModel *model, GtkTreePath *path, GtkTreeIter *iter, gpointer data)</a>
<a name="ln1463">{</a>
<a name="ln1464">  if(!iter) return 0;</a>
<a name="ln1465">  GList **rl = (GList **)data;</a>
<a name="ln1466">  int refid = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(model), &quot;formid&quot;));</a>
<a name="ln1467">  int refgid = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(model), &quot;groupid&quot;));</a>
<a name="ln1468"> </a>
<a name="ln1469">  // we retrieve the id</a>
<a name="ln1470">  GValue gv = {</a>
<a name="ln1471">    0,</a>
<a name="ln1472">  };</a>
<a name="ln1473">  gtk_tree_model_get_value(model, iter, TREE_GROUPID, &amp;gv);</a>
<a name="ln1474">  int grid = g_value_get_int(&amp;gv);</a>
<a name="ln1475">  g_value_unset(&amp;gv);</a>
<a name="ln1476">  GValue gv3 = {</a>
<a name="ln1477">    0,</a>
<a name="ln1478">  };</a>
<a name="ln1479">  gtk_tree_model_get_value(model, iter, TREE_FORMID, &amp;gv3);</a>
<a name="ln1480">  int id = g_value_get_int(&amp;gv3);</a>
<a name="ln1481">  g_value_unset(&amp;gv3);</a>
<a name="ln1482"> </a>
<a name="ln1483">  if(grid == refgid &amp;&amp; id == refid)</a>
<a name="ln1484">  {</a>
<a name="ln1485">    GtkTreeRowReference *rowref = gtk_tree_row_reference_new(model, path);</a>
<a name="ln1486">    *rl = g_list_append(*rl, rowref);</a>
<a name="ln1487">  }</a>
<a name="ln1488">  return 0;</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">static void _lib_masks_remove_item(dt_lib_module_t *self, int formid, int parentid)</a>
<a name="ln1492">{</a>
<a name="ln1493">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln1494">  // for each node , we refresh the string</a>
<a name="ln1495">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln1496">  GList *rl = NULL;</a>
<a name="ln1497">  g_object_set_data(G_OBJECT(model), &quot;formid&quot;, GUINT_TO_POINTER(formid));</a>
<a name="ln1498">  g_object_set_data(G_OBJECT(model), &quot;groupid&quot;, GUINT_TO_POINTER(parentid));</a>
<a name="ln1499">  gtk_tree_model_foreach(model, _remove_foreach, &amp;rl);</a>
<a name="ln1500"> </a>
<a name="ln1501">  GList *rlt = g_list_first(rl);</a>
<a name="ln1502">  while(rlt)</a>
<a name="ln1503">  {</a>
<a name="ln1504">    GtkTreePath *path = gtk_tree_row_reference_get_path((GtkTreeRowReference *)rlt-&gt;data);</a>
<a name="ln1505">    if(path)</a>
<a name="ln1506">    {</a>
<a name="ln1507">      GtkTreeIter iter;</a>
<a name="ln1508">      if(gtk_tree_model_get_iter(model, &amp;iter, path))</a>
<a name="ln1509">      {</a>
<a name="ln1510">        gtk_tree_store_remove(GTK_TREE_STORE(model), &amp;iter);</a>
<a name="ln1511">      }</a>
<a name="ln1512">    }</a>
<a name="ln1513">    rlt = g_list_next(rlt);</a>
<a name="ln1514">  }</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517">static void _lib_history_change_callback(gpointer instance, gpointer user_data)</a>
<a name="ln1518">{</a>
<a name="ln1519">  // dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln1520">  //_lib_masks_recreate_list(self);</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523">static void _lib_masks_selection_change(dt_lib_module_t *self, int selectid, int throw_event)</a>
<a name="ln1524">{</a>
<a name="ln1525">  dt_lib_masks_t *lm = (dt_lib_masks_t *)self-&gt;data;</a>
<a name="ln1526">  if(!lm-&gt;treeview) return;</a>
<a name="ln1527"> </a>
<a name="ln1528">  // we first unselect all</a>
<a name="ln1529">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln1530">  lm-&gt;gui_reset = 1;</a>
<a name="ln1531">  gtk_tree_selection_unselect_all(selection);</a>
<a name="ln1532">  lm-&gt;gui_reset = 0;</a>
<a name="ln1533"> </a>
<a name="ln1534">  // we go through all nodes</a>
<a name="ln1535">  lm-&gt;gui_reset = 1 - throw_event;</a>
<a name="ln1536">  GtkTreeIter iter;</a>
<a name="ln1537">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(lm-&gt;treeview));</a>
<a name="ln1538">  gboolean valid = gtk_tree_model_get_iter_first(model, &amp;iter);</a>
<a name="ln1539">  while(valid)</a>
<a name="ln1540">  {</a>
<a name="ln1541">    // we get the formid from the iter</a>
<a name="ln1542">    GValue gv = {</a>
<a name="ln1543">      0,</a>
<a name="ln1544">    };</a>
<a name="ln1545">    gtk_tree_model_get_value(model, &amp;iter, TREE_FORMID, &amp;gv);</a>
<a name="ln1546">    int id = g_value_get_int(&amp;gv);</a>
<a name="ln1547">    g_value_unset(&amp;gv);</a>
<a name="ln1548">    if(id == selectid)</a>
<a name="ln1549">    {</a>
<a name="ln1550">      gtk_tree_selection_select_iter(selection, &amp;iter);</a>
<a name="ln1551">      break;</a>
<a name="ln1552">    }</a>
<a name="ln1553">    valid = gtk_tree_model_iter_next(model, &amp;iter);</a>
<a name="ln1554">  }</a>
<a name="ln1555">  lm-&gt;gui_reset = 0;</a>
<a name="ln1556">}</a>
<a name="ln1557"> </a>
<a name="ln1558">void gui_init(dt_lib_module_t *self)</a>
<a name="ln1559">{</a>
<a name="ln1560">  const int bs = DT_PIXEL_APPLY_DPI(14);</a>
<a name="ln1561">  const int bs2 = DT_PIXEL_APPLY_DPI(13);</a>
<a name="ln1562"> </a>
<a name="ln1563">  /* initialize ui widgets */</a>
<a name="ln1564">  dt_lib_masks_t *d = (dt_lib_masks_t *)g_malloc0(sizeof(dt_lib_masks_t));</a>
<a name="ln1565">  self-&gt;data = (void *)d;</a>
<a name="ln1566">  d-&gt;gui_reset = 0;</a>
<a name="ln1567"> </a>
<a name="ln1568">  // initialise all masks icons</a>
<a name="ln1569">  guchar *data = NULL;</a>
<a name="ln1570">  cairo_surface_t *inverse_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bs2, bs2);</a>
<a name="ln1571">  cairo_t *inverse_cr = cairo_create(inverse_cst);</a>
<a name="ln1572">  cairo_set_source_rgb(inverse_cr, 0.7, 0.7, 0.7);</a>
<a name="ln1573">  dtgtk_cairo_paint_masks_inverse(inverse_cr, 0, 0, bs2, bs2, 0, NULL);</a>
<a name="ln1574">  cairo_destroy(inverse_cr);</a>
<a name="ln1575">  data = cairo_image_surface_get_data(inverse_cst);</a>
<a name="ln1576">  dt_draw_cairo_to_gdk_pixbuf(data, bs2, bs2);</a>
<a name="ln1577">  d-&gt;ic_inverse = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, bs2, bs2,</a>
<a name="ln1578">                                           cairo_image_surface_get_stride(inverse_cst), NULL, NULL);</a>
<a name="ln1579"> </a>
<a name="ln1580">  cairo_surface_t *union_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bs2, bs2);</a>
<a name="ln1581">  cairo_t *union_cr = cairo_create(union_cst);</a>
<a name="ln1582">  cairo_set_source_rgb(union_cr, 0.7, 0.7, 0.7);</a>
<a name="ln1583">  dtgtk_cairo_paint_masks_union(union_cr, 0, 0, bs2, bs2, 0, NULL);</a>
<a name="ln1584">  cairo_destroy(union_cr);</a>
<a name="ln1585">  data = cairo_image_surface_get_data(union_cst);</a>
<a name="ln1586">  dt_draw_cairo_to_gdk_pixbuf(data, bs2, bs2);</a>
<a name="ln1587">  d-&gt;ic_union = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, bs2, bs2,</a>
<a name="ln1588">                                         cairo_image_surface_get_stride(union_cst), NULL, NULL);</a>
<a name="ln1589"> </a>
<a name="ln1590">  cairo_surface_t *intersection_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bs2, bs2);</a>
<a name="ln1591">  cairo_t *intersection_cr = cairo_create(intersection_cst);</a>
<a name="ln1592">  cairo_set_source_rgb(intersection_cr, 0.7, 0.7, 0.7);</a>
<a name="ln1593">  dtgtk_cairo_paint_masks_intersection(intersection_cr, 0, 0, bs2, bs2, 0, NULL);</a>
<a name="ln1594">  cairo_destroy(intersection_cr);</a>
<a name="ln1595">  data = cairo_image_surface_get_data(intersection_cst);</a>
<a name="ln1596">  dt_draw_cairo_to_gdk_pixbuf(data, bs2, bs2);</a>
<a name="ln1597">  d-&gt;ic_intersection = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, bs2, bs2,</a>
<a name="ln1598">                                                cairo_image_surface_get_stride(intersection_cst), NULL, NULL);</a>
<a name="ln1599"> </a>
<a name="ln1600">  cairo_surface_t *difference_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bs2, bs2);</a>
<a name="ln1601">  cairo_t *difference_cr = cairo_create(difference_cst);</a>
<a name="ln1602">  cairo_set_source_rgb(difference_cr, 0.7, 0.7, 0.7);</a>
<a name="ln1603">  dtgtk_cairo_paint_masks_difference(difference_cr, 0, 0, bs2, bs2, 0, NULL);</a>
<a name="ln1604">  cairo_destroy(difference_cr);</a>
<a name="ln1605">  data = cairo_image_surface_get_data(difference_cst);</a>
<a name="ln1606">  dt_draw_cairo_to_gdk_pixbuf(data, bs2, bs2);</a>
<a name="ln1607">  d-&gt;ic_difference = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, bs2, bs2,</a>
<a name="ln1608">                                              cairo_image_surface_get_stride(difference_cst), NULL, NULL);</a>
<a name="ln1609"> </a>
<a name="ln1610">  cairo_surface_t *exclusion_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bs2, bs2);</a>
<a name="ln1611">  cairo_t *exclusion_cr = cairo_create(exclusion_cst);</a>
<a name="ln1612">  cairo_set_source_rgb(exclusion_cr, 0.7, 0.7, 0.7);</a>
<a name="ln1613">  dtgtk_cairo_paint_masks_exclusion(exclusion_cr, 0, 0, bs2, bs2, 0, NULL);</a>
<a name="ln1614">  cairo_destroy(exclusion_cr);</a>
<a name="ln1615">  data = cairo_image_surface_get_data(exclusion_cst);</a>
<a name="ln1616">  dt_draw_cairo_to_gdk_pixbuf(data, bs2, bs2);</a>
<a name="ln1617">  d-&gt;ic_exclusion = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, bs2, bs2,</a>
<a name="ln1618">                                             cairo_image_surface_get_stride(exclusion_cst), NULL, NULL);</a>
<a name="ln1619"> </a>
<a name="ln1620">  cairo_surface_t *used_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bs2, bs2);</a>
<a name="ln1621">  cairo_t *used_cr = cairo_create(used_cst);</a>
<a name="ln1622">  cairo_set_source_rgb(used_cr, 0.7, 0.7, 0.7);</a>
<a name="ln1623">  dtgtk_cairo_paint_masks_used(used_cr, 0, 0, bs2, bs2, 0, NULL);</a>
<a name="ln1624">  cairo_destroy(used_cr);</a>
<a name="ln1625">  data = cairo_image_surface_get_data(used_cst);</a>
<a name="ln1626">  dt_draw_cairo_to_gdk_pixbuf(data, bs2, bs2);</a>
<a name="ln1627">  d-&gt;ic_used = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, bs2, bs2,</a>
<a name="ln1628">                                        cairo_image_surface_get_stride(used_cst), NULL, NULL);</a>
<a name="ln1629"> </a>
<a name="ln1630">  // initialise widgets</a>
<a name="ln1631">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);</a>
<a name="ln1632">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln1633">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln1634"> </a>
<a name="ln1635">  GtkWidget *label = gtk_label_new(_(&quot;created shapes&quot;));</a>
<a name="ln1636">  gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 0);</a>
<a name="ln1637"> </a>
<a name="ln1638">  d-&gt;bt_gradient</a>
<a name="ln1639">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_gradient, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1640">  g_signal_connect(G_OBJECT(d-&gt;bt_gradient), &quot;button-press-event&quot;, G_CALLBACK(_bt_add_gradient), self);</a>
<a name="ln1641">  gtk_widget_set_tooltip_text(d-&gt;bt_gradient, _(&quot;add gradient&quot;));</a>
<a name="ln1642">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;bt_gradient), FALSE);</a>
<a name="ln1643">  gtk_widget_set_size_request(GTK_WIDGET(d-&gt;bt_gradient), bs, bs);</a>
<a name="ln1644">  gtk_box_pack_end(GTK_BOX(hbox), d-&gt;bt_gradient, FALSE, FALSE, 0);</a>
<a name="ln1645"> </a>
<a name="ln1646">  d-&gt;bt_path = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_path, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1647">  g_signal_connect(G_OBJECT(d-&gt;bt_path), &quot;button-press-event&quot;, G_CALLBACK(_bt_add_path), self);</a>
<a name="ln1648">  gtk_widget_set_tooltip_text(d-&gt;bt_path, _(&quot;add path&quot;));</a>
<a name="ln1649">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;bt_path), FALSE);</a>
<a name="ln1650">  gtk_widget_set_size_request(GTK_WIDGET(d-&gt;bt_path), bs, bs);</a>
<a name="ln1651">  gtk_box_pack_end(GTK_BOX(hbox), d-&gt;bt_path, FALSE, FALSE, bs);</a>
<a name="ln1652"> </a>
<a name="ln1653">  d-&gt;bt_ellipse</a>
<a name="ln1654">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_ellipse, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1655">  g_signal_connect(G_OBJECT(d-&gt;bt_ellipse), &quot;button-press-event&quot;, G_CALLBACK(_bt_add_ellipse), self);</a>
<a name="ln1656">  gtk_widget_set_tooltip_text(d-&gt;bt_ellipse, _(&quot;add ellipse&quot;));</a>
<a name="ln1657">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;bt_ellipse), FALSE);</a>
<a name="ln1658">  gtk_widget_set_size_request(GTK_WIDGET(d-&gt;bt_ellipse), bs, bs);</a>
<a name="ln1659">  gtk_box_pack_end(GTK_BOX(hbox), d-&gt;bt_ellipse, FALSE, FALSE, 0);</a>
<a name="ln1660"> </a>
<a name="ln1661">  d-&gt;bt_circle</a>
<a name="ln1662">      = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_circle, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1663">  g_signal_connect(G_OBJECT(d-&gt;bt_circle), &quot;button-press-event&quot;, G_CALLBACK(_bt_add_circle), self);</a>
<a name="ln1664">  gtk_widget_set_tooltip_text(d-&gt;bt_circle, _(&quot;add circle&quot;));</a>
<a name="ln1665">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;bt_circle), FALSE);</a>
<a name="ln1666">  gtk_widget_set_size_request(GTK_WIDGET(d-&gt;bt_circle), bs, bs);</a>
<a name="ln1667">  gtk_box_pack_end(GTK_BOX(hbox), d-&gt;bt_circle, FALSE, FALSE, bs);</a>
<a name="ln1668"> </a>
<a name="ln1669">  d-&gt;bt_brush = dtgtk_togglebutton_new(dtgtk_cairo_paint_masks_brush, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1670">  g_signal_connect(G_OBJECT(d-&gt;bt_brush), &quot;button-press-event&quot;, G_CALLBACK(_bt_add_brush), self);</a>
<a name="ln1671">  gtk_widget_set_tooltip_text(d-&gt;bt_brush, _(&quot;add brush&quot;));</a>
<a name="ln1672">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;bt_brush), FALSE);</a>
<a name="ln1673">  gtk_widget_set_size_request(GTK_WIDGET(d-&gt;bt_brush), bs, bs);</a>
<a name="ln1674">  gtk_box_pack_end(GTK_BOX(hbox), d-&gt;bt_brush, FALSE, FALSE, 0);</a>
<a name="ln1675"> </a>
<a name="ln1676">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hbox, TRUE, TRUE, 0);</a>
<a name="ln1677"> </a>
<a name="ln1678">  d-&gt;scroll_window = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln1679">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(d-&gt;scroll_window), GTK_POLICY_AUTOMATIC,</a>
<a name="ln1680">                                 GTK_POLICY_AUTOMATIC);</a>
<a name="ln1681">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;scroll_window, TRUE, TRUE, 0);</a>
<a name="ln1682"> </a>
<a name="ln1683">  d-&gt;treeview = gtk_tree_view_new();</a>
<a name="ln1684">  GtkTreeViewColumn *col = gtk_tree_view_column_new();</a>
<a name="ln1685">  gtk_tree_view_column_set_title(col, &quot;shapes&quot;);</a>
<a name="ln1686">  gtk_tree_view_append_column(GTK_TREE_VIEW(d-&gt;treeview), col);</a>
<a name="ln1687"> </a>
<a name="ln1688">  GtkCellRenderer *renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln1689">  gtk_tree_view_column_pack_start(col, renderer, FALSE);</a>
<a name="ln1690">  gtk_tree_view_column_set_attributes(col, renderer, &quot;pixbuf&quot;, TREE_IC_OP, NULL);</a>
<a name="ln1691">  gtk_tree_view_column_add_attribute(col, renderer, &quot;visible&quot;, TREE_IC_OP_VISIBLE);</a>
<a name="ln1692">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln1693">  gtk_tree_view_column_pack_start(col, renderer, FALSE);</a>
<a name="ln1694">  gtk_tree_view_column_set_attributes(col, renderer, &quot;pixbuf&quot;, TREE_IC_INVERSE, NULL);</a>
<a name="ln1695">  gtk_tree_view_column_add_attribute(col, renderer, &quot;visible&quot;, TREE_IC_INVERSE_VISIBLE);</a>
<a name="ln1696">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln1697">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln1698">  gtk_tree_view_column_add_attribute(col, renderer, &quot;text&quot;, TREE_TEXT);</a>
<a name="ln1699">  gtk_tree_view_column_add_attribute(col, renderer, &quot;editable&quot;, TREE_EDITABLE);</a>
<a name="ln1700">  g_signal_connect(renderer, &quot;editing-started&quot;, (GCallback)_tree_cell_editing_started, self);</a>
<a name="ln1701">  g_signal_connect(renderer, &quot;edited&quot;, (GCallback)_tree_cell_edited, self);</a>
<a name="ln1702">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln1703">  gtk_tree_view_column_pack_end(col, renderer, FALSE);</a>
<a name="ln1704">  gtk_tree_view_column_set_attributes(col, renderer, &quot;pixbuf&quot;, TREE_IC_USED, NULL);</a>
<a name="ln1705">  gtk_tree_view_column_add_attribute(col, renderer, &quot;visible&quot;, TREE_IC_USED_VISIBLE);</a>
<a name="ln1706"> </a>
<a name="ln1707">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(d-&gt;treeview));</a>
<a name="ln1708">  gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln1709">  gtk_tree_selection_set_select_function(selection, _tree_restrict_select, d, NULL);</a>
<a name="ln1710">  gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(d-&gt;treeview), FALSE);</a>
<a name="ln1711">  gtk_widget_set_size_request(d-&gt;scroll_window, -1, DT_PIXEL_APPLY_DPI(300));</a>
<a name="ln1712">  gtk_container_add(GTK_CONTAINER(d-&gt;scroll_window), d-&gt;treeview);</a>
<a name="ln1713">  // gtk_tree_view_set_tooltip_column(GTK_TREE_VIEW(d-&gt;treeview),TREE_USED_TEXT);</a>
<a name="ln1714">  g_object_set(d-&gt;treeview, &quot;has-tooltip&quot;, TRUE, (gchar *)0);</a>
<a name="ln1715">  g_signal_connect(d-&gt;treeview, &quot;query-tooltip&quot;, G_CALLBACK(_tree_query_tooltip), NULL);</a>
<a name="ln1716"> </a>
<a name="ln1717">  g_signal_connect(selection, &quot;changed&quot;, G_CALLBACK(_tree_selection_change), d);</a>
<a name="ln1718">  g_signal_connect(d-&gt;treeview, &quot;button-press-event&quot;, (GCallback)_tree_button_pressed, self);</a>
<a name="ln1719"> </a>
<a name="ln1720">  gtk_widget_show_all(self-&gt;widget);</a>
<a name="ln1721"> </a>
<a name="ln1722">  /* connect to history change signal for updating the history view */</a>
<a name="ln1723">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE,</a>
<a name="ln1724">                            G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln1725"> </a>
<a name="ln1726">  // set proxy functions</a>
<a name="ln1727">  darktable.develop-&gt;proxy.masks.module = self;</a>
<a name="ln1728">  darktable.develop-&gt;proxy.masks.list_change = _lib_masks_recreate_list;</a>
<a name="ln1729">  darktable.develop-&gt;proxy.masks.list_update = _lib_masks_update_list;</a>
<a name="ln1730">  darktable.develop-&gt;proxy.masks.list_remove = _lib_masks_remove_item;</a>
<a name="ln1731">  darktable.develop-&gt;proxy.masks.selection_change = _lib_masks_selection_change;</a>
<a name="ln1732">}</a>
<a name="ln1733"> </a>
<a name="ln1734">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln1735">{</a>
<a name="ln1736">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln1737"> </a>
<a name="ln1738">  g_free(self-&gt;data);</a>
<a name="ln1739">  self-&gt;data = NULL;</a>
<a name="ln1740">}</a>
<a name="ln1741"> </a>
<a name="ln1742">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1743">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1744">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="266"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'fpt'. Check lines: 266, 265.</p></div>
<div class="balloon" rel="883"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'fpt'. Check lines: 883, 882.</p></div>
<div class="balloon" rel="1535"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'lm->gui_reset' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 1532, 1535.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
