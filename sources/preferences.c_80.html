
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika, Tobias Ellinghaus.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/debug.h&quot;</a>
<a name="ln24">#include &quot;common/l10n.h&quot;</a>
<a name="ln25">#include &quot;common/presets.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop.h&quot;</a>
<a name="ln28">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln29">#include &quot;gui/draw.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;gui/preferences.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;libs/lib.h&quot;</a>
<a name="ln34">#include &quot;preferences_gen.h&quot;</a>
<a name="ln35">#ifdef USE_LUA</a>
<a name="ln36">#include &quot;lua/preferences.h&quot;</a>
<a name="ln37">#endif</a>
<a name="ln38">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln39">#include &quot;osx/osx.h&quot;</a>
<a name="ln40">#endif</a>
<a name="ln41">#define ICON_SIZE 13</a>
<a name="ln42"> </a>
<a name="ln43">typedef struct dt_gui_presets_edit_dialog_t</a>
<a name="ln44">{</a>
<a name="ln45">  GtkTreeView *tree; // CHANGED!</a>
<a name="ln46">  gint rowid;        // CHANGED!</a>
<a name="ln47">  GtkLabel *name;</a>
<a name="ln48">  GtkEntry *description;</a>
<a name="ln49">  GtkCheckButton *autoapply, *filter;</a>
<a name="ln50">  GtkWidget *details;</a>
<a name="ln51">  GtkEntry *model, *maker, *lens;</a>
<a name="ln52">  GtkSpinButton *iso_min, *iso_max;</a>
<a name="ln53">  GtkWidget *exposure_min, *exposure_max;</a>
<a name="ln54">  GtkWidget *aperture_min, *aperture_max;</a>
<a name="ln55">  GtkSpinButton *focal_length_min, *focal_length_max;</a>
<a name="ln56">  GtkWidget *format_btn[3];</a>
<a name="ln57">} dt_gui_presets_edit_dialog_t;</a>
<a name="ln58"> </a>
<a name="ln59">// FIXME: this is copypasta from gui/presets.c. better put these somewhere so that all places can access the</a>
<a name="ln60">// same data.</a>
<a name="ln61">static const int dt_gui_presets_exposure_value_cnt = 24;</a>
<a name="ln62">static const float dt_gui_presets_exposure_value[]</a>
<a name="ln63">    = { 0.,       1. / 8000, 1. / 4000, 1. / 2000, 1. / 1000, 1. / 1000, 1. / 500, 1. / 250,</a>
<a name="ln64">        1. / 125, 1. / 60,   1. / 30,   1. / 15,   1. / 15,   1. / 8,    1. / 4,   1. / 2,</a>
<a name="ln65">        1,        2,         4,         8,         15,        30,        60,       FLT_MAX };</a>
<a name="ln66">static const char *dt_gui_presets_exposure_value_str[]</a>
<a name="ln67">    = { &quot;0&quot;,     &quot;1/8000&quot;, &quot;1/4000&quot;, &quot;1/2000&quot;, &quot;1/1000&quot;, &quot;1/1000&quot;, &quot;1/500&quot;, &quot;1/250&quot;,</a>
<a name="ln68">        &quot;1/125&quot;, &quot;1/60&quot;,   &quot;1/30&quot;,   &quot;1/15&quot;,   &quot;1/15&quot;,   &quot;1/8&quot;,    &quot;1/4&quot;,   &quot;1/2&quot;,</a>
<a name="ln69">        &quot;1\&quot;&quot;,   &quot;2\&quot;&quot;,    &quot;4\&quot;&quot;,    &quot;8\&quot;&quot;,    &quot;15\&quot;&quot;,   &quot;30\&quot;&quot;,   &quot;60\&quot;&quot;,  &quot;+&quot; };</a>
<a name="ln70">static const int dt_gui_presets_aperture_value_cnt = 19;</a>
<a name="ln71">static const float dt_gui_presets_aperture_value[]</a>
<a name="ln72">    = { 0,    0.5,  0.7,  1.0,  1.4,  2.0,  2.8,  4.0,   5.6,    8.0,</a>
<a name="ln73">        11.0, 16.0, 22.0, 32.0, 45.0, 64.0, 90.0, 128.0, FLT_MAX };</a>
<a name="ln74">static const char *dt_gui_presets_aperture_value_str[]</a>
<a name="ln75">    = { &quot;f/0&quot;,  &quot;f/0.5&quot;, &quot;f/0.7&quot;, &quot;f/1.0&quot;, &quot;f/1.4&quot;, &quot;f/2&quot;,  &quot;f/2.8&quot;, &quot;f/4&quot;,   &quot;f/5.6&quot;, &quot;f/8&quot;,</a>
<a name="ln76">        &quot;f/11&quot;, &quot;f/16&quot;,  &quot;f/22&quot;,  &quot;f/32&quot;,  &quot;f/45&quot;,  &quot;f/64&quot;, &quot;f/90&quot;,  &quot;f/128&quot;, &quot;f/+&quot; };</a>
<a name="ln77"> </a>
<a name="ln78">// format string and corresponding flag stored into the database</a>
<a name="ln79">static const char *dt_gui_presets_format_value_str[3] = { N_(&quot;normal images&quot;),</a>
<a name="ln80">                                                          N_(&quot;raw&quot;),</a>
<a name="ln81">                                                          N_(&quot;HDR&quot;)};</a>
<a name="ln82">static const int dt_gui_presets_format_flag[3] = { FOR_LDR, FOR_RAW, FOR_HDR };</a>
<a name="ln83"> </a>
<a name="ln84">// Values for the accelerators/presets treeview</a>
<a name="ln85"> </a>
<a name="ln86">enum</a>
<a name="ln87">{</a>
<a name="ln88">  A_ACCEL_COLUMN,</a>
<a name="ln89">  A_BINDING_COLUMN,</a>
<a name="ln90">  A_TRANS_COLUMN,</a>
<a name="ln91">  A_N_COLUMNS</a>
<a name="ln92">};</a>
<a name="ln93">enum</a>
<a name="ln94">{</a>
<a name="ln95">  P_ROWID_COLUMN,</a>
<a name="ln96">  P_OPERATION_COLUMN,</a>
<a name="ln97">  P_MODULE_COLUMN,</a>
<a name="ln98">  P_EDITABLE_COLUMN,</a>
<a name="ln99">  P_NAME_COLUMN,</a>
<a name="ln100">  P_MODEL_COLUMN,</a>
<a name="ln101">  P_MAKER_COLUMN,</a>
<a name="ln102">  P_LENS_COLUMN,</a>
<a name="ln103">  P_ISO_COLUMN,</a>
<a name="ln104">  P_EXPOSURE_COLUMN,</a>
<a name="ln105">  P_APERTURE_COLUMN,</a>
<a name="ln106">  P_FOCAL_LENGTH_COLUMN,</a>
<a name="ln107">  P_AUTOAPPLY_COLUMN,</a>
<a name="ln108">  P_N_COLUMNS</a>
<a name="ln109">};</a>
<a name="ln110"> </a>
<a name="ln111">static void init_tab_presets(GtkWidget *book);</a>
<a name="ln112">static void init_tab_accels(GtkWidget *book);</a>
<a name="ln113">static void tree_insert_accel(gpointer accel_struct, gpointer model_link);</a>
<a name="ln114">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln115">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods);</a>
<a name="ln116">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len);</a>
<a name="ln117">static void update_accels_model(gpointer widget, gpointer data);</a>
<a name="ln118">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len);</a>
<a name="ln119">static void delete_matching_accels(gpointer path, gpointer key_event);</a>
<a name="ln120">static void import_export(GtkButton *button, gpointer data);</a>
<a name="ln121">static void restore_defaults(GtkButton *button, gpointer data);</a>
<a name="ln122">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln123">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data);</a>
<a name="ln124">static void import_preset(GtkButton *button, gpointer data);</a>
<a name="ln125"> </a>
<a name="ln126">// Signal handlers</a>
<a name="ln127">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln128">                                      gpointer data);</a>
<a name="ln129">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln130">                                       gpointer data);</a>
<a name="ln131">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data);</a>
<a name="ln132">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln133">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data);</a>
<a name="ln134">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln135">                              gpointer d);</a>
<a name="ln136"> </a>
<a name="ln137">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module);</a>
<a name="ln138">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g);</a>
<a name="ln139"> </a>
<a name="ln140">static GtkWidget *_preferences_dialog;</a>
<a name="ln141"> </a>
<a name="ln142">///////////// gui theme selection</a>
<a name="ln143"> </a>
<a name="ln144">static void load_themes_dir(const char *basedir)</a>
<a name="ln145">{</a>
<a name="ln146">  char *themes_dir = g_build_filename(basedir, &quot;themes&quot;, NULL);</a>
<a name="ln147">  GDir *dir = g_dir_open(themes_dir, 0, NULL);</a>
<a name="ln148">  if(dir)</a>
<a name="ln149">  {</a>
<a name="ln150">    const gchar *d_name;</a>
<a name="ln151">    while((d_name = g_dir_read_name(dir)))</a>
<a name="ln152">      darktable.themes = g_list_append(darktable.themes, g_strdup(d_name));</a>
<a name="ln153">    g_dir_close(dir);</a>
<a name="ln154">  }</a>
<a name="ln155">  g_free(themes_dir);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">static void load_themes(void)</a>
<a name="ln159">{</a>
<a name="ln160">  // Clear theme list...</a>
<a name="ln161">  g_list_free_full(darktable.themes, g_free);</a>
<a name="ln162">  darktable.themes = NULL;</a>
<a name="ln163"> </a>
<a name="ln164">  // check themes dirs</a>
<a name="ln165">  gchar configdir[PATH_MAX] = { 0 };</a>
<a name="ln166">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln167">  dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln168">  dt_loc_get_user_config_dir(configdir, sizeof(configdir));</a>
<a name="ln169"> </a>
<a name="ln170">  load_themes_dir(datadir);</a>
<a name="ln171">  load_themes_dir(configdir);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">static void theme_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln175">{</a>
<a name="ln176">  const int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln177">  gchar *theme = g_list_nth(darktable.themes, selected)-&gt;data;</a>
<a name="ln178">  gchar *i = g_strrstr(theme, &quot;.&quot;);</a>
<a name="ln179">  if(i) *i = '\0';</a>
<a name="ln180">  dt_gui_load_theme(theme);</a>
<a name="ln181">  dt_bauhaus_load_theme();</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">///////////// gui language selection</a>
<a name="ln185"> </a>
<a name="ln186">static void language_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln187">{</a>
<a name="ln188">  int selected = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));</a>
<a name="ln189">  dt_l10n_language_t *language = (dt_l10n_language_t *)g_list_nth(darktable.l10n-&gt;languages, selected)-&gt;data;</a>
<a name="ln190">  if(darktable.l10n-&gt;sys_default == selected)</a>
<a name="ln191">  {</a>
<a name="ln192">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, &quot;&quot;);</a>
<a name="ln193">    darktable.l10n-&gt;selected = darktable.l10n-&gt;sys_default;</a>
<a name="ln194">  }</a>
<a name="ln195">  else</a>
<a name="ln196">  {</a>
<a name="ln197">    dt_conf_set_string(&quot;ui_last/gui_language&quot;, language-&gt;code);</a>
<a name="ln198">    darktable.l10n-&gt;selected = selected;</a>
<a name="ln199">  }</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static gboolean reset_language_widget(GtkWidget *label, GdkEventButton *event, GtkWidget *widget)</a>
<a name="ln203">{</a>
<a name="ln204">  if(event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln205">  {</a>
<a name="ln206">    gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;sys_default);</a>
<a name="ln207">    return TRUE;</a>
<a name="ln208">  }</a>
<a name="ln209">  return FALSE;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">static void hardcoded_gui(GtkWidget *grid, int *line)</a>
<a name="ln213">{</a>
<a name="ln214">  // language</a>
<a name="ln215"> </a>
<a name="ln216">  GtkWidget *label = gtk_label_new(_(&quot;interface language&quot;));</a>
<a name="ln217">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln218">  GtkWidget *labelev = gtk_event_box_new();</a>
<a name="ln219">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln220">  gtk_container_add(GTK_CONTAINER(labelev), label);</a>
<a name="ln221">  GtkWidget *widget = gtk_combo_box_text_new();</a>
<a name="ln222"> </a>
<a name="ln223">  for(GList *iter = darktable.l10n-&gt;languages; iter; iter = g_list_next(iter))</a>
<a name="ln224">  {</a>
<a name="ln225">    const char *name = dt_l10n_get_name(iter-&gt;data);</a>
<a name="ln226">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), darktable.l10n-&gt;selected);</a>
<a name="ln230">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(language_callback), 0);</a>
<a name="ln231">  gtk_widget_set_tooltip_text(labelev,  _(&quot;double click to reset to the system language&quot;));</a>
<a name="ln232">  gtk_event_box_set_visible_window(GTK_EVENT_BOX(labelev), FALSE);</a>
<a name="ln233">  gtk_widget_set_tooltip_text(widget, _(&quot;set the language of the user interface. the system default is marked with an * (needs a restart)&quot;));</a>
<a name="ln234">  gtk_grid_attach(GTK_GRID(grid), labelev, 0, (*line)++, 1, 1);</a>
<a name="ln235">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, labelev, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln236">  g_signal_connect(G_OBJECT(labelev), &quot;button-press-event&quot;, G_CALLBACK(reset_language_widget), (gpointer)widget);</a>
<a name="ln237"> </a>
<a name="ln238">  // theme</a>
<a name="ln239"> </a>
<a name="ln240">  load_themes();</a>
<a name="ln241"> </a>
<a name="ln242">  label = gtk_label_new(_(&quot;theme&quot;));</a>
<a name="ln243">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln244">  gtk_widget_add_events(labelev, GDK_BUTTON_PRESS_MASK);</a>
<a name="ln245">  widget = gtk_combo_box_text_new();</a>
<a name="ln246"> </a>
<a name="ln247">  // read all themes</a>
<a name="ln248">  char *theme_name = dt_conf_get_string(&quot;ui_last/theme&quot;);</a>
<a name="ln249">  int selected = 0;</a>
<a name="ln250">  int k = 0;</a>
<a name="ln251">  for(GList *iter = darktable.themes; iter; iter = g_list_next(iter))</a>
<a name="ln252">  {</a>
<a name="ln253">    gchar *name = g_strdup((gchar*)(iter-&gt;data));</a>
<a name="ln254">    // remove extension</a>
<a name="ln255">    gchar *i = g_strrstr(name, &quot;.&quot;);</a>
<a name="ln256">    if(i) *i = '\0';</a>
<a name="ln257">    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(widget), name);</a>
<a name="ln258">    if(!g_strcmp0(name, theme_name)) selected = k;</a>
<a name="ln259">    k++;</a>
<a name="ln260">  }</a>
<a name="ln261">  g_free(theme_name);</a>
<a name="ln262"> </a>
<a name="ln263">  gtk_combo_box_set_active(GTK_COMBO_BOX(widget), selected);</a>
<a name="ln264"> </a>
<a name="ln265">  g_signal_connect(G_OBJECT(widget), &quot;changed&quot;, G_CALLBACK(theme_callback), 0);</a>
<a name="ln266">  gtk_widget_set_tooltip_text(widget, _(&quot;set the theme for the user interface&quot;));</a>
<a name="ln267">  gtk_grid_attach(GTK_GRID(grid), label, 0, (*line)++, 1, 1);</a>
<a name="ln268">  gtk_grid_attach_next_to(GTK_GRID(grid), widget, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">///////////// end of gui language selection</a>
<a name="ln272"> </a>
<a name="ln273"> </a>
<a name="ln274">void dt_gui_preferences_show()</a>
<a name="ln275">{</a>
<a name="ln276">  GtkWindow *win = GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui));</a>
<a name="ln277">  _preferences_dialog = gtk_dialog_new_with_buttons(_(&quot;darktable preferences&quot;), win,</a>
<a name="ln278">                                                    GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln279">                                                    _(&quot;close&quot;), GTK_RESPONSE_ACCEPT, NULL);</a>
<a name="ln280">  gtk_window_set_default_size(GTK_WINDOW(_preferences_dialog), DT_PIXEL_APPLY_DPI(800), DT_PIXEL_APPLY_DPI(800));</a>
<a name="ln281">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln282">  dt_osx_disallow_fullscreen(_preferences_dialog);</a>
<a name="ln283">#endif</a>
<a name="ln284">  gtk_window_set_position(GTK_WINDOW(_preferences_dialog), GTK_WIN_POS_CENTER_ON_PARENT);</a>
<a name="ln285">  GtkWidget *content = gtk_dialog_get_content_area(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln286">  GtkWidget *notebook = gtk_notebook_new();</a>
<a name="ln287">  gtk_widget_set_size_request(notebook, DT_PIXEL_APPLY_DPI(500), DT_PIXEL_APPLY_DPI(500));</a>
<a name="ln288">  gtk_widget_set_name(notebook, &quot;preferences_notebook&quot;);</a>
<a name="ln289">  gtk_box_pack_start(GTK_BOX(content), notebook, TRUE, TRUE, 0);</a>
<a name="ln290"> </a>
<a name="ln291">  // Make sure remap mode is off initially</a>
<a name="ln292">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln293">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln294"> </a>
<a name="ln295">  init_tab_gui(_preferences_dialog, notebook, &amp;hardcoded_gui);</a>
<a name="ln296">  init_tab_core(_preferences_dialog, notebook, NULL);</a>
<a name="ln297">  init_tab_session(_preferences_dialog, notebook, NULL);</a>
<a name="ln298">  init_tab_accels(notebook);</a>
<a name="ln299">  init_tab_presets(notebook);</a>
<a name="ln300">#ifdef USE_LUA</a>
<a name="ln301">  GtkGrid* lua_grid = init_tab_lua(_preferences_dialog, notebook);</a>
<a name="ln302">#endif</a>
<a name="ln303">  gtk_widget_show_all(_preferences_dialog);</a>
<a name="ln304">  (void)gtk_dialog_run(GTK_DIALOG(_preferences_dialog));</a>
<a name="ln305">#ifdef USE_LUA</a>
<a name="ln306">  destroy_tab_lua(lua_grid);</a>
<a name="ln307">#endif</a>
<a name="ln308">  gtk_widget_destroy(_preferences_dialog);</a>
<a name="ln309"> </a>
<a name="ln310">  // Cleaning up any memory still allocated for remapping</a>
<a name="ln311">  if(darktable.control-&gt;accel_remap_path)</a>
<a name="ln312">  {</a>
<a name="ln313">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln314">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE);</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">static void cairo_destroy_from_pixbuf(guchar *pixels, gpointer data)</a>
<a name="ln321">{</a>
<a name="ln322">  cairo_destroy((cairo_t *)data);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">static void tree_insert_presets(GtkTreeStore *tree_model)</a>
<a name="ln326">{</a>
<a name="ln327">  GtkTreeIter iter, parent;</a>
<a name="ln328">  sqlite3_stmt *stmt;</a>
<a name="ln329">  gchar *last_module = NULL;</a>
<a name="ln330"> </a>
<a name="ln331">  // Create a GdkPixbuf with a cairo drawing.</a>
<a name="ln332">  // lock</a>
<a name="ln333">  cairo_surface_t *lock_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln334">                                                         DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln335">  cairo_t *lock_cr = cairo_create(lock_cst);</a>
<a name="ln336">  cairo_set_source_rgb(lock_cr, 0.7, 0.7, 0.7);</a>
<a name="ln337">  dtgtk_cairo_paint_lock(lock_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln338">  cairo_surface_flush(lock_cst);</a>
<a name="ln339">  guchar *data = cairo_image_surface_get_data(lock_cst);</a>
<a name="ln340">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln341">  GdkPixbuf *lock_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln342">                                                    DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln343">                                                    cairo_image_surface_get_stride(lock_cst),</a>
<a name="ln344">                                                    cairo_destroy_from_pixbuf, lock_cr);</a>
<a name="ln345"> </a>
<a name="ln346">  // check mark</a>
<a name="ln347">  cairo_surface_t *check_cst = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln348">                                                          DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln349">  cairo_t *check_cr = cairo_create(check_cst);</a>
<a name="ln350">  cairo_set_source_rgb(check_cr, 0.7, 0.7, 0.7);</a>
<a name="ln351">  dtgtk_cairo_paint_check_mark(check_cr, 0, 0, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE), 0, NULL);</a>
<a name="ln352">  cairo_surface_flush(check_cst);</a>
<a name="ln353">  data = cairo_image_surface_get_data(check_cst);</a>
<a name="ln354">  dt_draw_cairo_to_gdk_pixbuf(data, DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE));</a>
<a name="ln355">  GdkPixbuf *check_pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8,</a>
<a name="ln356">                                                     DT_PIXEL_APPLY_DPI(ICON_SIZE), DT_PIXEL_APPLY_DPI(ICON_SIZE),</a>
<a name="ln357">                                                     cairo_image_surface_get_stride(check_cst),</a>
<a name="ln358">                                                     cairo_destroy_from_pixbuf, check_cr);</a>
<a name="ln359"> </a>
<a name="ln360">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln361">                              &quot;SELECT rowid, name, operation, autoapply, model, maker, lens, iso_min, &quot;</a>
<a name="ln362">                              &quot;iso_max, exposure_min, exposure_max, aperture_min, aperture_max, &quot;</a>
<a name="ln363">                              &quot;focal_length_min, focal_length_max, writeprotect FROM data.presets ORDER BY &quot;</a>
<a name="ln364">                              &quot;operation, name&quot;,</a>
<a name="ln365">                              -1, &amp;stmt, NULL);</a>
<a name="ln366">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln367">  {</a>
<a name="ln368">    const gint rowid = sqlite3_column_int(stmt, 0);</a>
<a name="ln369">    const gchar *name = (gchar *)sqlite3_column_text(stmt, 1);</a>
<a name="ln370">    const gchar *operation = (gchar *)sqlite3_column_text(stmt, 2);</a>
<a name="ln371">    const gboolean autoapply = (sqlite3_column_int(stmt, 3) == 0 ? FALSE : TRUE);</a>
<a name="ln372">    const gchar *model = (gchar *)sqlite3_column_text(stmt, 4);</a>
<a name="ln373">    const gchar *maker = (gchar *)sqlite3_column_text(stmt, 5);</a>
<a name="ln374">    const gchar *lens = (gchar *)sqlite3_column_text(stmt, 6);</a>
<a name="ln375">    const float iso_min = sqlite3_column_double(stmt, 7);</a>
<a name="ln376">    const float iso_max = sqlite3_column_double(stmt, 8);</a>
<a name="ln377">    const float exposure_min = sqlite3_column_double(stmt, 9);</a>
<a name="ln378">    const float exposure_max = sqlite3_column_double(stmt, 10);</a>
<a name="ln379">    const float aperture_min = sqlite3_column_double(stmt, 11);</a>
<a name="ln380">    const float aperture_max = sqlite3_column_double(stmt, 12);</a>
<a name="ln381">    const int focal_length_min = sqlite3_column_double(stmt, 13);</a>
<a name="ln382">    const int focal_length_max = sqlite3_column_double(stmt, 14);</a>
<a name="ln383">    const gboolean writeprotect = (sqlite3_column_int(stmt, 15) == 0 ? FALSE : TRUE);</a>
<a name="ln384"> </a>
<a name="ln385">    gchar *iso = NULL, *exposure = NULL, *aperture = NULL, *focal_length = NULL;</a>
<a name="ln386">    int min, max;</a>
<a name="ln387"> </a>
<a name="ln388">    gchar *module = g_strdup(dt_iop_get_localized_name(operation));</a>
<a name="ln389">    if(module == NULL) module = g_strdup(dt_lib_get_localized_name(operation));</a>
<a name="ln390">    if(module == NULL) module = g_strdup(operation);</a>
<a name="ln391"> </a>
<a name="ln392">    if(iso_min == 0.0 &amp;&amp; iso_max == FLT_MAX)</a>
<a name="ln393">      iso = g_strdup(&quot;%&quot;);</a>
<a name="ln394">    else</a>
<a name="ln395">      iso = g_strdup_printf(&quot;%zu – %zu&quot;, (size_t)iso_min, (size_t)iso_max);</a>
<a name="ln396"> </a>
<a name="ln397">    min = 0, max = 0;</a>
<a name="ln398">    for(; min &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_min &gt; dt_gui_presets_exposure_value[min]; min++)</a>
<a name="ln399">      ;</a>
<a name="ln400">    for(; max &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; exposure_max &gt; dt_gui_presets_exposure_value[max]; max++)</a>
<a name="ln401">      ;</a>
<a name="ln402">    if(min == 0 &amp;&amp; max == dt_gui_presets_exposure_value_cnt - 1)</a>
<a name="ln403">      exposure = g_strdup(&quot;%&quot;);</a>
<a name="ln404">    else</a>
<a name="ln405">      exposure = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_exposure_value_str[min],</a>
<a name="ln406">                                 dt_gui_presets_exposure_value_str[max]);</a>
<a name="ln407"> </a>
<a name="ln408">    min = 0, max = 0;</a>
<a name="ln409">    for(; min &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_min &gt; dt_gui_presets_aperture_value[min]; min++)</a>
<a name="ln410">      ;</a>
<a name="ln411">    for(; max &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; aperture_max &gt; dt_gui_presets_aperture_value[max]; max++)</a>
<a name="ln412">      ;</a>
<a name="ln413">    if(min == 0 &amp;&amp; max == dt_gui_presets_aperture_value_cnt - 1)</a>
<a name="ln414">      aperture = g_strdup(&quot;%&quot;);</a>
<a name="ln415">    else</a>
<a name="ln416">      aperture = g_strdup_printf(&quot;%s – %s&quot;, dt_gui_presets_aperture_value_str[min],</a>
<a name="ln417">                                 dt_gui_presets_aperture_value_str[max]);</a>
<a name="ln418"> </a>
<a name="ln419">    if(focal_length_min == 0.0 &amp;&amp; focal_length_max == 1000.0)</a>
<a name="ln420">      focal_length = g_strdup(&quot;%&quot;);</a>
<a name="ln421">    else</a>
<a name="ln422">      focal_length = g_strdup_printf(&quot;%d – %d&quot;, focal_length_min, focal_length_max);</a>
<a name="ln423"> </a>
<a name="ln424">    if(g_strcmp0(last_module, operation) != 0)</a>
<a name="ln425">    {</a>
<a name="ln426">      gtk_tree_store_append(tree_model, &amp;iter, NULL);</a>
<a name="ln427">      gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, 0, P_OPERATION_COLUMN, &quot;&quot;, P_MODULE_COLUMN,</a>
<a name="ln428">                         _(module), P_EDITABLE_COLUMN, NULL, P_NAME_COLUMN, &quot;&quot;, P_MODEL_COLUMN, &quot;&quot;,</a>
<a name="ln429">                         P_MAKER_COLUMN, &quot;&quot;, P_LENS_COLUMN, &quot;&quot;, P_ISO_COLUMN, &quot;&quot;, P_EXPOSURE_COLUMN, &quot;&quot;,</a>
<a name="ln430">                         P_APERTURE_COLUMN, &quot;&quot;, P_FOCAL_LENGTH_COLUMN, &quot;&quot;, P_AUTOAPPLY_COLUMN, NULL, -1);</a>
<a name="ln431">      g_free(last_module);</a>
<a name="ln432">      last_module = g_strdup(operation);</a>
<a name="ln433">      parent = iter;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    gtk_tree_store_append(tree_model, &amp;iter, &amp;parent);</a>
<a name="ln437">    gtk_tree_store_set(tree_model, &amp;iter, P_ROWID_COLUMN, rowid, P_OPERATION_COLUMN, operation,</a>
<a name="ln438">                       P_MODULE_COLUMN, &quot;&quot;, P_EDITABLE_COLUMN, writeprotect ? lock_pixbuf : NULL,</a>
<a name="ln439">                       P_NAME_COLUMN, name, P_MODEL_COLUMN, model, P_MAKER_COLUMN, maker, P_LENS_COLUMN, lens,</a>
<a name="ln440">                       P_ISO_COLUMN, iso, P_EXPOSURE_COLUMN, exposure, P_APERTURE_COLUMN, aperture,</a>
<a name="ln441">                       P_FOCAL_LENGTH_COLUMN, focal_length, P_AUTOAPPLY_COLUMN,</a>
<a name="ln442">                       autoapply ? check_pixbuf : NULL, -1);</a>
<a name="ln443"> </a>
<a name="ln444">    g_free(focal_length);</a>
<a name="ln445">    g_free(aperture);</a>
<a name="ln446">    g_free(exposure);</a>
<a name="ln447">    g_free(iso);</a>
<a name="ln448">    g_free(module);</a>
<a name="ln449">  }</a>
<a name="ln450">  g_free(last_module);</a>
<a name="ln451">  sqlite3_finalize(stmt);</a>
<a name="ln452"> </a>
<a name="ln453">  g_object_unref(lock_pixbuf);</a>
<a name="ln454">  cairo_surface_destroy(lock_cst);</a>
<a name="ln455">  g_object_unref(check_pixbuf);</a>
<a name="ln456">  cairo_surface_destroy(check_cst);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">static void init_tab_presets(GtkWidget *book)</a>
<a name="ln460">{</a>
<a name="ln461">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln462">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln463">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln464">  GtkTreeStore *model = gtk_tree_store_new(</a>
<a name="ln465">      P_N_COLUMNS, G_TYPE_INT /*rowid*/, G_TYPE_STRING /*operation*/, G_TYPE_STRING /*module*/,</a>
<a name="ln466">      GDK_TYPE_PIXBUF /*editable*/, G_TYPE_STRING /*name*/, G_TYPE_STRING /*model*/, G_TYPE_STRING /*maker*/,</a>
<a name="ln467">      G_TYPE_STRING /*lens*/, G_TYPE_STRING /*iso*/, G_TYPE_STRING /*exposure*/, G_TYPE_STRING /*aperture*/,</a>
<a name="ln468">      G_TYPE_STRING /*focal length*/, GDK_TYPE_PIXBUF /*auto*/);</a>
<a name="ln469">  GtkCellRenderer *renderer;</a>
<a name="ln470">  GtkTreeViewColumn *column;</a>
<a name="ln471"> </a>
<a name="ln472">  // Adding the outer container</a>
<a name="ln473">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;presets&quot;)));</a>
<a name="ln474"> </a>
<a name="ln475">  tree_insert_presets(model);</a>
<a name="ln476"> </a>
<a name="ln477">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln478">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln479">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), P_MODULE_COLUMN, compare_rows_presets, NULL, NULL);</a>
<a name="ln480"> </a>
<a name="ln481">  // Setting up the cell renderers</a>
<a name="ln482">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln483">  column = gtk_tree_view_column_new_with_attributes(_(&quot;module&quot;), renderer, &quot;text&quot;, P_MODULE_COLUMN, NULL);</a>
<a name="ln484">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln485"> </a>
<a name="ln486">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln487">  column = gtk_tree_view_column_new_with_attributes(&quot;&quot;, renderer, &quot;pixbuf&quot;, P_EDITABLE_COLUMN, NULL);</a>
<a name="ln488">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln489"> </a>
<a name="ln490">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln491">  column = gtk_tree_view_column_new_with_attributes(_(&quot;name&quot;), renderer, &quot;text&quot;, P_NAME_COLUMN, NULL);</a>
<a name="ln492">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln493"> </a>
<a name="ln494">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln495">  column = gtk_tree_view_column_new_with_attributes(_(&quot;model&quot;), renderer, &quot;text&quot;, P_MODEL_COLUMN, NULL);</a>
<a name="ln496">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln497"> </a>
<a name="ln498">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln499">  column = gtk_tree_view_column_new_with_attributes(_(&quot;maker&quot;), renderer, &quot;text&quot;, P_MAKER_COLUMN, NULL);</a>
<a name="ln500">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln501"> </a>
<a name="ln502">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln503">  column = gtk_tree_view_column_new_with_attributes(_(&quot;lens&quot;), renderer, &quot;text&quot;, P_LENS_COLUMN, NULL);</a>
<a name="ln504">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln505"> </a>
<a name="ln506">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln507">  column = gtk_tree_view_column_new_with_attributes(_(&quot;ISO&quot;), renderer, &quot;text&quot;, P_ISO_COLUMN, NULL);</a>
<a name="ln508">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln509"> </a>
<a name="ln510">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln511">  column = gtk_tree_view_column_new_with_attributes(_(&quot;exposure&quot;), renderer, &quot;text&quot;, P_EXPOSURE_COLUMN, NULL);</a>
<a name="ln512">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln513"> </a>
<a name="ln514">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln515">  column = gtk_tree_view_column_new_with_attributes(_(&quot;aperture&quot;), renderer, &quot;text&quot;, P_APERTURE_COLUMN, NULL);</a>
<a name="ln516">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln517"> </a>
<a name="ln518">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln519">  column = gtk_tree_view_column_new_with_attributes(_(&quot;focal length&quot;), renderer, &quot;text&quot;,</a>
<a name="ln520">                                                    P_FOCAL_LENGTH_COLUMN, NULL);</a>
<a name="ln521">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln522"> </a>
<a name="ln523">  renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln524">  column = gtk_tree_view_column_new_with_attributes(_(&quot;auto&quot;), renderer, &quot;pixbuf&quot;, P_AUTOAPPLY_COLUMN, NULL);</a>
<a name="ln525">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln526"> </a>
<a name="ln527">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln528">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln529"> </a>
<a name="ln530">  // Adding the import/export buttons</a>
<a name="ln531">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln532"> </a>
<a name="ln533">  GtkWidget *button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln534">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln535">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_preset), (gpointer)model);</a>
<a name="ln536"> </a>
<a name="ln537">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln538"> </a>
<a name="ln539">  // Attaching treeview signals</a>
<a name="ln540"> </a>
<a name="ln541">  // row-activated either expands/collapses a row or activates editing</a>
<a name="ln542">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_presets), NULL);</a>
<a name="ln543"> </a>
<a name="ln544">  // A keypress may delete preset</a>
<a name="ln545">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press_presets), (gpointer)model);</a>
<a name="ln546"> </a>
<a name="ln547">  // Setting up the search functionality</a>
<a name="ln548">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), P_NAME_COLUMN);</a>
<a name="ln549">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln550"> </a>
<a name="ln551">  // Attaching the model to the treeview</a>
<a name="ln552">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln553"> </a>
<a name="ln554">  // Adding the treeview to its containers</a>
<a name="ln555">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln556">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln557"> </a>
<a name="ln558">  g_object_unref(G_OBJECT(model));</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">static void init_tab_accels(GtkWidget *book)</a>
<a name="ln562">{</a>
<a name="ln563">  GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln564">  GtkWidget *scroll = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln565">  GtkWidget *tree = gtk_tree_view_new();</a>
<a name="ln566">  GtkWidget *button;</a>
<a name="ln567">  GtkWidget *hbox;</a>
<a name="ln568">  GtkTreeStore *model = gtk_tree_store_new(A_N_COLUMNS, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);</a>
<a name="ln569">  GtkCellRenderer *renderer;</a>
<a name="ln570">  GtkTreeViewColumn *column;</a>
<a name="ln571"> </a>
<a name="ln572">  // Adding the outer container</a>
<a name="ln573">  gtk_notebook_append_page(GTK_NOTEBOOK(book), container, gtk_label_new(_(&quot;shortcuts&quot;)));</a>
<a name="ln574"> </a>
<a name="ln575">  // Building the accelerator tree</a>
<a name="ln576">  g_slist_foreach(darktable.control-&gt;accelerator_list, tree_insert_accel, (gpointer)model);</a>
<a name="ln577"> </a>
<a name="ln578">  // Setting a custom sort functions so expandable groups rise to the top</a>
<a name="ln579">  gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, GTK_SORT_ASCENDING);</a>
<a name="ln580">  gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model), A_TRANS_COLUMN, compare_rows_accels, NULL, NULL);</a>
<a name="ln581"> </a>
<a name="ln582">  // Setting up the cell renderers</a>
<a name="ln583">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln584">  column = gtk_tree_view_column_new_with_attributes(_(&quot;shortcut&quot;), renderer, &quot;text&quot;, A_TRANS_COLUMN, NULL);</a>
<a name="ln585">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln586"> </a>
<a name="ln587">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln588">  column = gtk_tree_view_column_new_with_attributes(_(&quot;binding&quot;), renderer, &quot;text&quot;, A_BINDING_COLUMN, NULL);</a>
<a name="ln589">  gtk_tree_view_append_column(GTK_TREE_VIEW(tree), column);</a>
<a name="ln590"> </a>
<a name="ln591">  // Attaching treeview signals</a>
<a name="ln592"> </a>
<a name="ln593">  // row-activated either expands/collapses a row or activates remapping</a>
<a name="ln594">  g_signal_connect(G_OBJECT(tree), &quot;row-activated&quot;, G_CALLBACK(tree_row_activated_accels), NULL);</a>
<a name="ln595"> </a>
<a name="ln596">  // A selection change will cancel a currently active remapping</a>
<a name="ln597">  g_signal_connect(G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(tree))), &quot;changed&quot;,</a>
<a name="ln598">                   G_CALLBACK(tree_selection_changed), NULL);</a>
<a name="ln599"> </a>
<a name="ln600">  // A keypress may remap an accel or delete one</a>
<a name="ln601">  g_signal_connect(G_OBJECT(tree), &quot;key-press-event&quot;, G_CALLBACK(tree_key_press), (gpointer)model);</a>
<a name="ln602"> </a>
<a name="ln603">  // Setting up the search functionality</a>
<a name="ln604">  gtk_tree_view_set_search_column(GTK_TREE_VIEW(tree), A_TRANS_COLUMN);</a>
<a name="ln605">  gtk_tree_view_set_search_equal_func(GTK_TREE_VIEW(tree), prefix_search, NULL, NULL);</a>
<a name="ln606">  gtk_tree_view_set_enable_search(GTK_TREE_VIEW(tree), TRUE);</a>
<a name="ln607"> </a>
<a name="ln608">  // Attaching the model to the treeview</a>
<a name="ln609">  gtk_tree_view_set_model(GTK_TREE_VIEW(tree), GTK_TREE_MODEL(model));</a>
<a name="ln610"> </a>
<a name="ln611">  // Adding the treeview to its containers</a>
<a name="ln612">  gtk_container_add(GTK_CONTAINER(scroll), tree);</a>
<a name="ln613">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroll), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln614">  gtk_box_pack_start(GTK_BOX(container), scroll, TRUE, TRUE, 0);</a>
<a name="ln615"> </a>
<a name="ln616">  hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);</a>
<a name="ln617"> </a>
<a name="ln618">  // Adding the restore defaults button</a>
<a name="ln619">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;default&quot;));</a>
<a name="ln620">  gtk_box_pack_end(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln621">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(restore_defaults), NULL);</a>
<a name="ln622">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln623"> </a>
<a name="ln624">  // Adding the import/export buttons</a>
<a name="ln625"> </a>
<a name="ln626">  button = gtk_button_new_with_label(C_(&quot;preferences&quot;, &quot;import&quot;));</a>
<a name="ln627">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln628">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)0);</a>
<a name="ln629">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(update_accels_model), (gpointer)model);</a>
<a name="ln630"> </a>
<a name="ln631">  button = gtk_button_new_with_label(_(&quot;export&quot;));</a>
<a name="ln632">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, TRUE, 0);</a>
<a name="ln633">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_export), (gpointer)1);</a>
<a name="ln634"> </a>
<a name="ln635">  gtk_box_pack_start(GTK_BOX(container), hbox, FALSE, FALSE, 0);</a>
<a name="ln636"> </a>
<a name="ln637">  g_object_unref(G_OBJECT(model));</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">static void tree_insert_accel(gpointer accel_struct, gpointer model_link)</a>
<a name="ln641">{</a>
<a name="ln642">  GtkTreeStore *model = (GtkTreeStore *)model_link;</a>
<a name="ln643">  dt_accel_t *accel = (dt_accel_t *)accel_struct;</a>
<a name="ln644">  GtkAccelKey key;</a>
<a name="ln645"> </a>
<a name="ln646">  // Getting the first significant parts of the paths</a>
<a name="ln647">  const char *accel_path = accel-&gt;path;</a>
<a name="ln648">  const char *translated_path = accel-&gt;translated_path;</a>
<a name="ln649"> </a>
<a name="ln650">  /* if prefixed lets forward pointer */</a>
<a name="ln651">  if(!strncmp(accel_path, &quot;&lt;Darktable&gt;&quot;, strlen(&quot;&lt;Darktable&gt;&quot;)))</a>
<a name="ln652">  {</a>
<a name="ln653">    accel_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln654">    translated_path += strlen(&quot;&lt;Darktable&gt;&quot;) + 1;</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  // Getting the accelerator keys</a>
<a name="ln658">  gtk_accel_map_lookup_entry(accel-&gt;path, &amp;key);</a>
<a name="ln659"> </a>
<a name="ln660">  /* lets recurse path */</a>
<a name="ln661">  tree_insert_rec(model, NULL, accel_path, translated_path, key.accel_key, key.accel_mods);</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">static void tree_insert_rec(GtkTreeStore *model, GtkTreeIter *parent, const gchar *accel_path,</a>
<a name="ln665">                            const gchar *translated_path, guint accel_key, GdkModifierType accel_mods)</a>
<a name="ln666">{</a>
<a name="ln667">  int i;</a>
<a name="ln668">  gboolean found = FALSE;</a>
<a name="ln669">  gchar *val_str;</a>
<a name="ln670">  GtkTreeIter iter;</a>
<a name="ln671"> </a>
<a name="ln672">  /* if we are on end of path lets bail out of recursive insert */</a>
<a name="ln673">  if(*accel_path == 0) return;</a>
<a name="ln674"> </a>
<a name="ln675">  /* check if we are on a leaf or a branch  */</a>
<a name="ln676">  if(!g_strrstr(accel_path, &quot;/&quot;))</a>
<a name="ln677">  {</a>
<a name="ln678">    /* we are on a leaf lets add */</a>
<a name="ln679">    gchar *name = gtk_accelerator_get_label(accel_key, accel_mods);</a>
<a name="ln680">    gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln681">    gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, accel_path, A_BINDING_COLUMN,</a>
<a name="ln682">                       g_dpgettext2(&quot;gtk30&quot;, &quot;keyboard label&quot;, name), A_TRANS_COLUMN, translated_path, -1);</a>
<a name="ln683">    g_free(name);</a>
<a name="ln684">  }</a>
<a name="ln685">  else</a>
<a name="ln686">  {</a>
<a name="ln687">    /* we are on a branch let's get the node name */</a>
<a name="ln688">    const gchar *end = g_strstr_len(accel_path, strlen(accel_path), &quot;/&quot;);</a>
<a name="ln689">    const gchar *trans_end = g_strstr_len(translated_path, strlen(translated_path), &quot;/&quot;);</a>
<a name="ln690">    gchar *node = g_strndup(accel_path, end - accel_path);</a>
<a name="ln691">    gchar *trans_node;</a>
<a name="ln692">    // safeguard against broken translations</a>
<a name="ln693">    if(trans_end)</a>
<a name="ln694">      trans_node = g_strndup(translated_path, trans_end - translated_path);</a>
<a name="ln695">    else</a>
<a name="ln696">    {</a>
<a name="ln697">      fprintf(stderr, &quot;error: translation mismatch: `%s' vs. `%s'\n&quot;, accel_path, translated_path);</a>
<a name="ln698">      trans_node = g_strdup(node);</a>
<a name="ln699">      translated_path = accel_path;</a>
<a name="ln700">    }</a>
<a name="ln701"> </a>
<a name="ln702">    /* search the tree if we already have a sibling with node name */</a>
<a name="ln703">    int siblings = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(model), parent);</a>
<a name="ln704">    for(i = 0; i &lt; siblings; i++)</a>
<a name="ln705">    {</a>
<a name="ln706">      gtk_tree_model_iter_nth_child(GTK_TREE_MODEL(model), &amp;iter, parent, i);</a>
<a name="ln707">      gtk_tree_model_get(GTK_TREE_MODEL(model), &amp;iter, A_ACCEL_COLUMN, &amp;val_str, -1);</a>
<a name="ln708"> </a>
<a name="ln709">      /* do we match current sibling */</a>
<a name="ln710">      if(!strcmp(val_str, node)) found = TRUE;</a>
<a name="ln711"> </a>
<a name="ln712">      g_free(val_str);</a>
<a name="ln713"> </a>
<a name="ln714">      /* if we found a matching node let's break out */</a>
<a name="ln715">      if(found) break;</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">    /* if not found let's add a branch */</a>
<a name="ln719">    if(!found)</a>
<a name="ln720">    {</a>
<a name="ln721">      gtk_tree_store_append(model, &amp;iter, parent);</a>
<a name="ln722">      gtk_tree_store_set(model, &amp;iter, A_ACCEL_COLUMN, node, A_BINDING_COLUMN, &quot;&quot;, A_TRANS_COLUMN, trans_node,</a>
<a name="ln723">                         -1);</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    /* recurse further down the path */</a>
<a name="ln727">    tree_insert_rec(model, &amp;iter, accel_path + strlen(node) + 1, translated_path + strlen(trans_node) + 1,</a>
<a name="ln728">                    accel_key, accel_mods);</a>
<a name="ln729"> </a>
<a name="ln730">    /* free up data */</a>
<a name="ln731">    g_free(node);</a>
<a name="ln732">    g_free(trans_node);</a>
<a name="ln733">  }</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">static void path_to_accel(GtkTreeModel *model, GtkTreePath *path, gchar *str, size_t str_len)</a>
<a name="ln737">{</a>
<a name="ln738">  gint depth;</a>
<a name="ln739">  gint *indices;</a>
<a name="ln740">  GtkTreeIter parent;</a>
<a name="ln741">  GtkTreeIter child;</a>
<a name="ln742">  gint i;</a>
<a name="ln743">  gchar *data_str;</a>
<a name="ln744"> </a>
<a name="ln745">  // Start out with the base &lt;Darktable&gt;</a>
<a name="ln746">  g_strlcpy(str, &quot;&lt;Darktable&gt;&quot;, str_len);</a>
<a name="ln747"> </a>
<a name="ln748">  // For each index in the path, append a '/' and that section of the path</a>
<a name="ln749">  depth = gtk_tree_path_get_depth(path);</a>
<a name="ln750">  indices = gtk_tree_path_get_indices(path);</a>
<a name="ln751">  for(i = 0; i &lt; depth; i++)</a>
<a name="ln752">  {</a>
<a name="ln753">    g_strlcat(str, &quot;/&quot;, str_len);</a>
<a name="ln754">    gtk_tree_model_iter_nth_child(model, &amp;child, i == 0 ? NULL : &amp;parent, indices[i]);</a>
<a name="ln755">    gtk_tree_model_get(model, &amp;child, A_ACCEL_COLUMN, &amp;data_str, -1);</a>
<a name="ln756">    g_strlcat(str, data_str, str_len);</a>
<a name="ln757">    g_free(data_str);</a>
<a name="ln758">    parent = child;</a>
<a name="ln759">  }</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">static void update_accels_model(gpointer widget, gpointer data)</a>
<a name="ln763">{</a>
<a name="ln764">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln765">  GtkTreeIter iter;</a>
<a name="ln766">  gchar path[256];</a>
<a name="ln767">  gchar *end;</a>
<a name="ln768">  gint i;</a>
<a name="ln769"> </a>
<a name="ln770">  g_strlcpy(path, &quot;&lt;Darktable&gt;&quot;, sizeof(path));</a>
<a name="ln771">  end = path + strlen(path);</a>
<a name="ln772"> </a>
<a name="ln773">  for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, NULL); i++)</a>
<a name="ln774">  {</a>
<a name="ln775">    gtk_tree_model_iter_nth_child(model, &amp;iter, NULL, i);</a>
<a name="ln776">    update_accels_model_rec(model, &amp;iter, path, sizeof(path));</a>
<a name="ln777">    *end = '\0'; // Trimming the string back to the base for the next iteration</a>
<a name="ln778">  }</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">static void update_accels_model_rec(GtkTreeModel *model, GtkTreeIter *parent, gchar *path, size_t path_len)</a>
<a name="ln782">{</a>
<a name="ln783">  GtkAccelKey key;</a>
<a name="ln784">  GtkTreeIter iter;</a>
<a name="ln785">  gchar *str_data;</a>
<a name="ln786">  gchar *end;</a>
<a name="ln787">  gint i;</a>
<a name="ln788"> </a>
<a name="ln789">  // First concatenating this part of the key</a>
<a name="ln790">  g_strlcat(path, &quot;/&quot;, path_len);</a>
<a name="ln791">  gtk_tree_model_get(model, parent, A_ACCEL_COLUMN, &amp;str_data, -1);</a>
<a name="ln792">  g_strlcat(path, str_data, path_len);</a>
<a name="ln793">  g_free(str_data);</a>
<a name="ln794"> </a>
<a name="ln795">  if(gtk_tree_model_iter_has_child(model, parent))</a>
<a name="ln796">  {</a>
<a name="ln797">    // Branch node, carry on with recursion</a>
<a name="ln798">    end = path + strlen(path);</a>
<a name="ln799"> </a>
<a name="ln800">    for(i = 0; i &lt; gtk_tree_model_iter_n_children(model, parent); i++)</a>
<a name="ln801">    {</a>
<a name="ln802">      gtk_tree_model_iter_nth_child(model, &amp;iter, parent, i);</a>
<a name="ln803">      update_accels_model_rec(model, &amp;iter, path, path_len);</a>
<a name="ln804">      *end = '\0';</a>
<a name="ln805">    }</a>
<a name="ln806">  }</a>
<a name="ln807">  else</a>
<a name="ln808">  {</a>
<a name="ln809">    // Leaf node, update the text</a>
<a name="ln810"> </a>
<a name="ln811">    gtk_accel_map_lookup_entry(path, &amp;key);</a>
<a name="ln812">    gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln813">    gtk_tree_store_set(GTK_TREE_STORE(model), parent, A_BINDING_COLUMN, name, -1);</a>
<a name="ln814">    g_free(name);</a>
<a name="ln815">  }</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">static void delete_matching_accels(gpointer current, gpointer mapped)</a>
<a name="ln819">{</a>
<a name="ln820">  const dt_accel_t *current_accel = (dt_accel_t *)current;</a>
<a name="ln821">  const dt_accel_t *mapped_accel = (dt_accel_t *)mapped;</a>
<a name="ln822">  GtkAccelKey current_key;</a>
<a name="ln823">  GtkAccelKey mapped_key;</a>
<a name="ln824"> </a>
<a name="ln825">  // Make sure we're not deleting the key we just remapped</a>
<a name="ln826">  if(!strcmp(current_accel-&gt;path, mapped_accel-&gt;path)) return;</a>
<a name="ln827"> </a>
<a name="ln828">  // Finding the relevant keyboard shortcuts</a>
<a name="ln829">  gtk_accel_map_lookup_entry(current_accel-&gt;path, &amp;current_key);</a>
<a name="ln830">  gtk_accel_map_lookup_entry(mapped_accel-&gt;path, &amp;mapped_key);</a>
<a name="ln831"> </a>
<a name="ln832">  if(current_key.accel_key == mapped_key.accel_key                 // Key code matches</a>
<a name="ln833">     &amp;&amp; current_key.accel_mods == mapped_key.accel_mods            // Key state matches</a>
<a name="ln834">     &amp;&amp; !(current_accel-&gt;local &amp;&amp; mapped_accel-&gt;local              // Not both local to</a>
<a name="ln835">          &amp;&amp; strcmp(current_accel-&gt;module, mapped_accel-&gt;module))</a>
<a name="ln836">     &amp;&amp; (current_accel-&gt;views &amp; mapped_accel-&gt;views) != 0) // diff mods</a>
<a name="ln837">    gtk_accel_map_change_entry(current_accel-&gt;path, 0, 0, TRUE);</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">static gint _accelcmp(gconstpointer a, gconstpointer b)</a>
<a name="ln841">{</a>
<a name="ln842">  return (gint)(strcmp(((dt_accel_t *)a)-&gt;path, ((dt_accel_t *)b)-&gt;path));</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">// TODO: remember which sections were collapsed/expanded and where the view was scrolled to and restore that</a>
<a name="ln846">// after editing is done</a>
<a name="ln847">//      Alternative: change edit_preset_response to not clear+refill the tree, but to update the single row</a>
<a name="ln848">//      which changed.</a>
<a name="ln849">static void tree_row_activated_presets(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln850">                                       gpointer data)</a>
<a name="ln851">{</a>
<a name="ln852">  GtkTreeIter iter;</a>
<a name="ln853">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln854"> </a>
<a name="ln855">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln856"> </a>
<a name="ln857">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln858">  {</a>
<a name="ln859">    // For branch nodes, toggle expansion on activation</a>
<a name="ln860">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln861">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln862">    else</a>
<a name="ln863">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln864">  }</a>
<a name="ln865">  else</a>
<a name="ln866">  {</a>
<a name="ln867">    // For leaf nodes, open editing window if the preset is not writeprotected</a>
<a name="ln868">    gint rowid;</a>
<a name="ln869">    gchar *name, *operation;</a>
<a name="ln870">    GdkPixbuf *editable;</a>
<a name="ln871">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_OPERATION_COLUMN,</a>
<a name="ln872">                       &amp;operation, P_EDITABLE_COLUMN, &amp;editable, -1);</a>
<a name="ln873">    if(editable == NULL)</a>
<a name="ln874">      edit_preset(tree, rowid, name, operation);</a>
<a name="ln875">    else</a>
<a name="ln876">      g_object_unref(editable);</a>
<a name="ln877">    g_free(name);</a>
<a name="ln878">    g_free(operation);</a>
<a name="ln879">  }</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">static void tree_row_activated_accels(GtkTreeView *tree, GtkTreePath *path, GtkTreeViewColumn *column,</a>
<a name="ln883">                                      gpointer data)</a>
<a name="ln884">{</a>
<a name="ln885">  GtkTreeIter iter;</a>
<a name="ln886">  GtkTreeModel *model = gtk_tree_view_get_model(tree);</a>
<a name="ln887"> </a>
<a name="ln888">  static gchar accel_path[256];</a>
<a name="ln889"> </a>
<a name="ln890">  gtk_tree_model_get_iter(model, &amp;iter, path);</a>
<a name="ln891"> </a>
<a name="ln892">  if(gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln893">  {</a>
<a name="ln894">    // For branch nodes, toggle expansion on activation</a>
<a name="ln895">    if(gtk_tree_view_row_expanded(tree, path))</a>
<a name="ln896">      gtk_tree_view_collapse_row(tree, path);</a>
<a name="ln897">    else</a>
<a name="ln898">      gtk_tree_view_expand_row(tree, path, FALSE);</a>
<a name="ln899">  }</a>
<a name="ln900">  else</a>
<a name="ln901">  {</a>
<a name="ln902">    // For leaf nodes, enter remapping mode</a>
<a name="ln903"> </a>
<a name="ln904">    // Assembling the full accelerator path</a>
<a name="ln905">    path_to_accel(model, path, accel_path, sizeof(accel_path));</a>
<a name="ln906"> </a>
<a name="ln907">    // Setting the notification text</a>
<a name="ln908">    gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, _(&quot;press key combination to remap...&quot;),</a>
<a name="ln909">                       -1);</a>
<a name="ln910"> </a>
<a name="ln911">    // Activating remapping</a>
<a name="ln912">    darktable.control-&gt;accel_remap_str = accel_path;</a>
<a name="ln913">    darktable.control-&gt;accel_remap_path = gtk_tree_path_copy(path);</a>
<a name="ln914">  }</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">static void tree_selection_changed(GtkTreeSelection *selection, gpointer data)</a>
<a name="ln918">{</a>
<a name="ln919">  GtkTreeModel *model;</a>
<a name="ln920">  GtkTreeIter iter;</a>
<a name="ln921"> </a>
<a name="ln922">  GtkAccelKey key;</a>
<a name="ln923"> </a>
<a name="ln924">  // If remapping is currently activated, it needs to be deactivated</a>
<a name="ln925">  if(!darktable.control-&gt;accel_remap_str) return;</a>
<a name="ln926"> </a>
<a name="ln927">  model = gtk_tree_view_get_model(gtk_tree_selection_get_tree_view(selection));</a>
<a name="ln928">  gtk_tree_model_get_iter(model, &amp;iter, darktable.control-&gt;accel_remap_path);</a>
<a name="ln929"> </a>
<a name="ln930">  // Restoring the A_BINDING_COLUMN text</a>
<a name="ln931">  gtk_accel_map_lookup_entry(darktable.control-&gt;accel_remap_str, &amp;key);</a>
<a name="ln932">  gchar *name = gtk_accelerator_get_label(key.accel_key, key.accel_mods);</a>
<a name="ln933">  gtk_tree_store_set(GTK_TREE_STORE(model), &amp;iter, A_BINDING_COLUMN, name, -1);</a>
<a name="ln934">  g_free(name);</a>
<a name="ln935"> </a>
<a name="ln936">  // Cleaning up the darktable.gui info</a>
<a name="ln937">  darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln938">  gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln939">  darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">static gboolean tree_key_press(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln943">{</a>
<a name="ln944">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln945">  GtkTreeIter iter;</a>
<a name="ln946">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln947">  GtkTreePath *path;</a>
<a name="ln948">  GSList *remapped;</a>
<a name="ln949">  dt_accel_t query;</a>
<a name="ln950"> </a>
<a name="ln951">  gchar accel[256];</a>
<a name="ln952">  gchar datadir[PATH_MAX] = { 0 };</a>
<a name="ln953">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln954"> </a>
<a name="ln955">  // We can just ignore mod key presses outright</a>
<a name="ln956">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln957"> </a>
<a name="ln958">  dt_loc_get_user_config_dir(datadir, sizeof(datadir));</a>
<a name="ln959">  snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, datadir);</a>
<a name="ln960"> </a>
<a name="ln961">  // Otherwise, determine whether we're in remap mode or not</a>
<a name="ln962">  if(darktable.control-&gt;accel_remap_str)</a>
<a name="ln963">  {</a>
<a name="ln964">    // First locate the accel list entry</a>
<a name="ln965">    g_strlcpy(query.path, darktable.control-&gt;accel_remap_str, sizeof(query.path));</a>
<a name="ln966">    remapped = g_slist_find_custom(darktable.control-&gt;accelerator_list, (gpointer)&amp;query, _accelcmp);</a>
<a name="ln967">    const dt_accel_t *accel_current = (dt_accel_t *)remapped-&gt;data;</a>
<a name="ln968"> </a>
<a name="ln969">    // let's search for conflicts</a>
<a name="ln970">    dt_accel_t *accel_conflict = NULL;</a>
<a name="ln971">    GSList *l = darktable.control-&gt;accelerator_list;</a>
<a name="ln972">    while (l)</a>
<a name="ln973">    {</a>
<a name="ln974">      dt_accel_t *a = (dt_accel_t *)l-&gt;data;</a>
<a name="ln975">      GtkAccelKey key;</a>
<a name="ln976">      if (a != accel_current &amp;&amp; gtk_accel_map_lookup_entry(a-&gt;path, &amp;key))</a>
<a name="ln977">      {</a>
<a name="ln978">        if (key.accel_key == gdk_keyval_to_lower(event-&gt;keyval) &amp;&amp;</a>
<a name="ln979">            key.accel_mods == (event-&gt;state &amp; KEY_STATE_MASK) &amp;&amp;</a>
<a name="ln980">            !(a-&gt;local &amp;&amp; accel_current-&gt;local &amp;&amp; strcmp(a-&gt;module, accel_current-&gt;module)) &amp;&amp;</a>
<a name="ln981">            (a-&gt;views &amp; accel_current-&gt;views) != 0)</a>
<a name="ln982">        {</a>
<a name="ln983">          accel_conflict = a;</a>
<a name="ln984">          break;</a>
<a name="ln985">        }</a>
<a name="ln986">      }</a>
<a name="ln987">      l = g_slist_next(l);</a>
<a name="ln988">    }</a>
<a name="ln989"> </a>
<a name="ln990">    if(!accel_conflict)</a>
<a name="ln991">    {</a>
<a name="ln992">      // no conflict</a>
<a name="ln993">      gtk_accel_map_change_entry(darktable.control-&gt;accel_remap_str, gdk_keyval_to_lower(event-&gt;keyval),</a>
<a name="ln994">                                 event-&gt;state &amp; KEY_STATE_MASK, TRUE);</a>
<a name="ln995">    }</a>
<a name="ln996">    else</a>
<a name="ln997">    {</a>
<a name="ln998">      // we ask for confirmation</a>
<a name="ln999">      GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1000">      gchar *accel_txt</a>
<a name="ln1001">          = gtk_accelerator_get_label(gdk_keyval_to_lower(event-&gt;keyval), event-&gt;state &amp; KEY_STATE_MASK);</a>
<a name="ln1002">      gchar txt[512] = { 0 };</a>
<a name="ln1003">      if(g_str_has_prefix(accel_conflict-&gt;translated_path, &quot;&lt;Darktable&gt;/&quot;))</a>
<a name="ln1004">        g_strlcpy(txt, accel_conflict-&gt;translated_path + 12, sizeof(txt));</a>
<a name="ln1005">      else</a>
<a name="ln1006">        g_strlcpy(txt, accel_conflict-&gt;translated_path, sizeof(txt));</a>
<a name="ln1007">      GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1008">          GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1009">          _(&quot;%s accel is already mapped to\n%s.\ndo you want to replace it ?&quot;), accel_txt, txt);</a>
<a name="ln1010">      g_free(accel_txt);</a>
<a name="ln1011">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1012">      dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1013">#endif</a>
<a name="ln1014"> </a>
<a name="ln1015">      gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;accel conflict&quot;));</a>
<a name="ln1016">      gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1017">      gtk_widget_destroy(dialog);</a>
<a name="ln1018">      if(res == GTK_RESPONSE_YES)</a>
<a name="ln1019">      {</a>
<a name="ln1020">        // Change the accel map entry</a>
<a name="ln1021">        if(gtk_accel_map_change_entry(darktable.control-&gt;accel_remap_str, gdk_keyval_to_lower(event-&gt;keyval),</a>
<a name="ln1022">                                      event-&gt;state &amp; KEY_STATE_MASK, TRUE))</a>
<a name="ln1023">        {</a>
<a name="ln1024">          // Then remove conflicts</a>
<a name="ln1025">          g_slist_foreach(darktable.control-&gt;accelerator_list, delete_matching_accels, (gpointer)(accel_current));</a>
<a name="ln1026">        }</a>
<a name="ln1027">      }</a>
<a name="ln1028">    }</a>
<a name="ln1029"> </a>
<a name="ln1030">    // Then update the text in the A_BINDING_COLUMN of each row</a>
<a name="ln1031">    update_accels_model(NULL, model);</a>
<a name="ln1032"> </a>
<a name="ln1033">    // Finally clear the remap state</a>
<a name="ln1034">    darktable.control-&gt;accel_remap_str = NULL;</a>
<a name="ln1035">    gtk_tree_path_free(darktable.control-&gt;accel_remap_path);</a>
<a name="ln1036">    darktable.control-&gt;accel_remap_path = NULL;</a>
<a name="ln1037"> </a>
<a name="ln1038">    // Save the changed keybindings</a>
<a name="ln1039">    gtk_accel_map_save(accelpath);</a>
<a name="ln1040"> </a>
<a name="ln1041">    return TRUE;</a>
<a name="ln1042">  }</a>
<a name="ln1043">  else if(event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln1044">  {</a>
<a name="ln1045">    // If a leaf node is selected, clear that accelerator</a>
<a name="ln1046"> </a>
<a name="ln1047">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln1048">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln1049">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1050">      return FALSE;</a>
<a name="ln1051"> </a>
<a name="ln1052">    // Otherwise, construct the proper accelerator path and delete its entry</a>
<a name="ln1053">    g_strlcpy(accel, &quot;&lt;Darktable&gt;&quot;, sizeof(accel));</a>
<a name="ln1054">    path = gtk_tree_model_get_path(model, &amp;iter);</a>
<a name="ln1055">    path_to_accel(model, path, accel, sizeof(accel));</a>
<a name="ln1056">    gtk_tree_path_free(path);</a>
<a name="ln1057"> </a>
<a name="ln1058">    gtk_accel_map_change_entry(accel, 0, 0, TRUE);</a>
<a name="ln1059">    update_accels_model(NULL, model);</a>
<a name="ln1060"> </a>
<a name="ln1061">    // Saving the changed bindings</a>
<a name="ln1062">    gtk_accel_map_save(accelpath);</a>
<a name="ln1063"> </a>
<a name="ln1064">    return TRUE;</a>
<a name="ln1065">  }</a>
<a name="ln1066">  else</a>
<a name="ln1067">  {</a>
<a name="ln1068">    return FALSE;</a>
<a name="ln1069">  }</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">static gboolean tree_key_press_presets(GtkWidget *widget, GdkEventKey *event, gpointer data)</a>
<a name="ln1073">{</a>
<a name="ln1074"> </a>
<a name="ln1075">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1076">  GtkTreeIter iter;</a>
<a name="ln1077">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));</a>
<a name="ln1078"> </a>
<a name="ln1079">  // We can just ignore mod key presses outright</a>
<a name="ln1080">  if(event-&gt;is_modifier) return FALSE;</a>
<a name="ln1081"> </a>
<a name="ln1082">  if(event-&gt;keyval == GDK_KEY_Delete || event-&gt;keyval == GDK_KEY_BackSpace)</a>
<a name="ln1083">  {</a>
<a name="ln1084">    // If a leaf node is selected, delete that preset</a>
<a name="ln1085"> </a>
<a name="ln1086">    // If nothing is selected, or branch node selected, just return</a>
<a name="ln1087">    if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln1088">       || gtk_tree_model_iter_has_child(model, &amp;iter))</a>
<a name="ln1089">      return FALSE;</a>
<a name="ln1090"> </a>
<a name="ln1091">    // For leaf nodes, open delete confirmation window if the preset is not writeprotected</a>
<a name="ln1092">    gint rowid;</a>
<a name="ln1093">    gchar *name;</a>
<a name="ln1094">    GdkPixbuf *editable;</a>
<a name="ln1095">    gtk_tree_model_get(model, &amp;iter, P_ROWID_COLUMN, &amp;rowid, P_NAME_COLUMN, &amp;name, P_EDITABLE_COLUMN,</a>
<a name="ln1096">                       &amp;editable, -1);</a>
<a name="ln1097">    if(editable == NULL)</a>
<a name="ln1098">    {</a>
<a name="ln1099">      sqlite3_stmt *stmt;</a>
<a name="ln1100"> </a>
<a name="ln1101">      GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1102">      GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(window), GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln1103">                                                 GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1104">                                                 _(&quot;do you really want to delete the preset `%s'?&quot;), name);</a>
<a name="ln1105">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1106">      dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1107">#endif</a>
<a name="ln1108">      gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;delete preset?&quot;));</a>
<a name="ln1109">      if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_YES)</a>
<a name="ln1110">      {</a>
<a name="ln1111">        // TODO: remove accel</a>
<a name="ln1112">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1113">                                    &quot;DELETE FROM data.presets WHERE rowid=?1 AND writeprotect=0&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln1114">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1115">        sqlite3_step(stmt);</a>
<a name="ln1116">        sqlite3_finalize(stmt);</a>
<a name="ln1117">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1118">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1119">        tree_insert_presets(tree_store);</a>
<a name="ln1120">      }</a>
<a name="ln1121">      gtk_widget_destroy(dialog);</a>
<a name="ln1122">    }</a>
<a name="ln1123">    else</a>
<a name="ln1124">      g_object_unref(editable);</a>
<a name="ln1125">    g_free(name);</a>
<a name="ln1126"> </a>
<a name="ln1127">    return TRUE;</a>
<a name="ln1128">  }</a>
<a name="ln1129">  else</a>
<a name="ln1130">  {</a>
<a name="ln1131">    return FALSE;</a>
<a name="ln1132">  }</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">static void import_export(GtkButton *button, gpointer data)</a>
<a name="ln1136">{</a>
<a name="ln1137">  GtkWidget *chooser;</a>
<a name="ln1138">  gchar confdir[PATH_MAX] = { 0 };</a>
<a name="ln1139">  gchar accelpath[PATH_MAX] = { 0 };</a>
<a name="ln1140"> </a>
<a name="ln1141">  if(data)</a>
<a name="ln1142">  {</a>
<a name="ln1143">    // Non-zero value indicates export</a>
<a name="ln1144">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to export&quot;), NULL, GTK_FILE_CHOOSER_ACTION_SAVE,</a>
<a name="ln1145">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_save&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1146">                                          NULL);</a>
<a name="ln1147">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1148">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1149">#endif</a>
<a name="ln1150">    gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(chooser), TRUE);</a>
<a name="ln1151">    gchar *exported_path = dt_conf_get_string(&quot;ui_last/exported_path&quot;);</a>
<a name="ln1152">    if(exported_path != NULL)</a>
<a name="ln1153">    {</a>
<a name="ln1154">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), exported_path);</a>
<a name="ln1155">      g_free(exported_path);</a>
<a name="ln1156">    }</a>
<a name="ln1157">    gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(chooser), &quot;keyboardrc&quot;);</a>
<a name="ln1158">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1159">    {</a>
<a name="ln1160">      gtk_accel_map_save(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1161">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1162">      dt_conf_set_string(&quot;ui_last/export_path&quot;, folder);</a>
<a name="ln1163">      g_free(folder);</a>
<a name="ln1164">    }</a>
<a name="ln1165">    gtk_widget_destroy(chooser);</a>
<a name="ln1166">  }</a>
<a name="ln1167">  else</a>
<a name="ln1168">  {</a>
<a name="ln1169">    // Zero value indicates import</a>
<a name="ln1170">    chooser = gtk_file_chooser_dialog_new(_(&quot;select file to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1171">                                          _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1172">                                          NULL);</a>
<a name="ln1173">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1174">    dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1175">#endif</a>
<a name="ln1176"> </a>
<a name="ln1177">    gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1178">    if(import_path != NULL)</a>
<a name="ln1179">    {</a>
<a name="ln1180">      gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1181">      g_free(import_path);</a>
<a name="ln1182">    }</a>
<a name="ln1183">    if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1184">    {</a>
<a name="ln1185">      if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1186">      {</a>
<a name="ln1187">        // Loading the file</a>
<a name="ln1188">        gtk_accel_map_load(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)));</a>
<a name="ln1189"> </a>
<a name="ln1190">        // Saving to the permanent keyboardrc</a>
<a name="ln1191">        dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1192">        snprintf(accelpath, sizeof(accelpath), &quot;%s/keyboardrc&quot;, confdir);</a>
<a name="ln1193">        gtk_accel_map_save(accelpath);</a>
<a name="ln1194"> </a>
<a name="ln1195">        gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1196">        dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1197">        g_free(folder);</a>
<a name="ln1198">      }</a>
<a name="ln1199">    }</a>
<a name="ln1200">    gtk_widget_destroy(chooser);</a>
<a name="ln1201">  }</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">static void restore_defaults(GtkButton *button, gpointer data)</a>
<a name="ln1205">{</a>
<a name="ln1206">  GList *ops;</a>
<a name="ln1207">  dt_iop_module_so_t *op;</a>
<a name="ln1208">  gchar accelpath[256];</a>
<a name="ln1209">  gchar dir[PATH_MAX] = { 0 };</a>
<a name="ln1210">  gchar path[PATH_MAX] = { 0 };</a>
<a name="ln1211"> </a>
<a name="ln1212">  GtkWidget *message</a>
<a name="ln1213">      = gtk_message_dialog_new(NULL, GTK_DIALOG_MODAL, GTK_MESSAGE_WARNING, GTK_BUTTONS_OK_CANCEL,</a>
<a name="ln1214">                               _(&quot;are you sure you want to restore the default keybindings?  this will &quot;</a>
<a name="ln1215">                                 &quot;erase any modifications you have made.&quot;));</a>
<a name="ln1216">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1217">  dt_osx_disallow_fullscreen(message);</a>
<a name="ln1218">#endif</a>
<a name="ln1219">  if(gtk_dialog_run(GTK_DIALOG(message)) == GTK_RESPONSE_OK)</a>
<a name="ln1220">  {</a>
<a name="ln1221">    // First load the default keybindings for immediate effect</a>
<a name="ln1222">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1223">    snprintf(path, sizeof(path), &quot;%s/keyboardrc_default&quot;, dir);</a>
<a name="ln1224">    gtk_accel_map_load(path);</a>
<a name="ln1225"> </a>
<a name="ln1226">    // Now deleting any iop show shortcuts</a>
<a name="ln1227">    ops = darktable.iop;</a>
<a name="ln1228">    while(ops)</a>
<a name="ln1229">    {</a>
<a name="ln1230">      op = (dt_iop_module_so_t *)ops-&gt;data;</a>
<a name="ln1231">      snprintf(accelpath, sizeof(accelpath), &quot;&lt;Darktable&gt;/darkroom/modules/%s/show&quot;, op-&gt;op);</a>
<a name="ln1232">      gtk_accel_map_change_entry(accelpath, 0, 0, TRUE);</a>
<a name="ln1233">      ops = g_list_next(ops);</a>
<a name="ln1234">    }</a>
<a name="ln1235"> </a>
<a name="ln1236">    // Then delete any changes to the user's keyboardrc so it gets reset</a>
<a name="ln1237">    // on next startup</a>
<a name="ln1238">    dt_loc_get_user_config_dir(dir, sizeof(dir));</a>
<a name="ln1239">    snprintf(path, sizeof(path), &quot;%s/keyboardrc&quot;, dir);</a>
<a name="ln1240"> </a>
<a name="ln1241">    GFile *gpath = g_file_new_for_path(path);</a>
<a name="ln1242">    g_file_delete(gpath, NULL, NULL);</a>
<a name="ln1243">    g_object_unref(gpath);</a>
<a name="ln1244">  }</a>
<a name="ln1245">  gtk_widget_destroy(message);</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">static void import_preset(GtkButton *button, gpointer data)</a>
<a name="ln1249">{</a>
<a name="ln1250">  GtkTreeModel *model = (GtkTreeModel *)data;</a>
<a name="ln1251">  GtkWidget *chooser;</a>
<a name="ln1252"> </a>
<a name="ln1253">  // Zero value indicates import</a>
<a name="ln1254">  chooser = gtk_file_chooser_dialog_new(_(&quot;select preset to import&quot;), NULL, GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln1255">                                        _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT,</a>
<a name="ln1256">                                        NULL);</a>
<a name="ln1257">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1258">  dt_osx_disallow_fullscreen(chooser);</a>
<a name="ln1259">#endif</a>
<a name="ln1260"> </a>
<a name="ln1261">  gchar *import_path = dt_conf_get_string(&quot;ui_last/import_path&quot;);</a>
<a name="ln1262">  if(import_path != NULL)</a>
<a name="ln1263">  {</a>
<a name="ln1264">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(chooser), import_path);</a>
<a name="ln1265">    g_free(import_path);</a>
<a name="ln1266">  }</a>
<a name="ln1267">  if(gtk_dialog_run(GTK_DIALOG(chooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1268">  {</a>
<a name="ln1269">    if(g_file_test(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser)), G_FILE_TEST_EXISTS))</a>
<a name="ln1270">    {</a>
<a name="ln1271">      if(dt_presets_import_from_file(gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(chooser))))</a>
<a name="ln1272">      {</a>
<a name="ln1273">        dt_control_log(_(&quot;failed to import preset&quot;));</a>
<a name="ln1274">      }</a>
<a name="ln1275">      else</a>
<a name="ln1276">      {</a>
<a name="ln1277">        GtkTreeStore *tree_store = GTK_TREE_STORE(model);</a>
<a name="ln1278">        gtk_tree_store_clear(tree_store);</a>
<a name="ln1279">        tree_insert_presets(tree_store);</a>
<a name="ln1280">      }</a>
<a name="ln1281"> </a>
<a name="ln1282">      gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(chooser));</a>
<a name="ln1283">      dt_conf_set_string(&quot;ui_last/import_path&quot;, folder);</a>
<a name="ln1284">      g_free(folder);</a>
<a name="ln1285">    }</a>
<a name="ln1286">  }</a>
<a name="ln1287">  gtk_widget_destroy(chooser);</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">static gboolean prefix_search(GtkTreeModel *model, gint column, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln1291">                              gpointer d)</a>
<a name="ln1292">{</a>
<a name="ln1293">  gchar *row_data;</a>
<a name="ln1294"> </a>
<a name="ln1295">  gtk_tree_model_get(model, iter, A_TRANS_COLUMN, &amp;row_data, -1);</a>
<a name="ln1296">  while(*key != '\0')</a>
<a name="ln1297">  {</a>
<a name="ln1298">    if(*row_data != *key) return TRUE;</a>
<a name="ln1299">    key++;</a>
<a name="ln1300">    row_data++;</a>
<a name="ln1301">  }</a>
<a name="ln1302">  return FALSE;</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">// Custom sort function for TreeModel entries for accels list</a>
<a name="ln1306">static gint compare_rows_accels(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1307">{</a>
<a name="ln1308">  gchar *a_text;</a>
<a name="ln1309">  gchar *b_text;</a>
<a name="ln1310"> </a>
<a name="ln1311">  // First prioritize branch nodes over leaves</a>
<a name="ln1312">  if(gtk_tree_model_iter_has_child(model, a) &amp;&amp; !gtk_tree_model_iter_has_child(model, b)) return -1;</a>
<a name="ln1313"> </a>
<a name="ln1314">  if(gtk_tree_model_iter_has_child(model, b) &amp;&amp; !gtk_tree_model_iter_has_child(model, a)) return 1;</a>
<a name="ln1315"> </a>
<a name="ln1316">  // Otherwise just return alphabetical order</a>
<a name="ln1317">  gtk_tree_model_get(model, a, A_TRANS_COLUMN, &amp;a_text, -1);</a>
<a name="ln1318">  gtk_tree_model_get(model, b, A_TRANS_COLUMN, &amp;b_text, -1);</a>
<a name="ln1319"> </a>
<a name="ln1320">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1321"> </a>
<a name="ln1322">  g_free(a_text);</a>
<a name="ln1323">  g_free(b_text);</a>
<a name="ln1324"> </a>
<a name="ln1325">  return res;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">// Custom sort function for TreeModel entries for presets list</a>
<a name="ln1329">static gint compare_rows_presets(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer data)</a>
<a name="ln1330">{</a>
<a name="ln1331">  gchar *a_text;</a>
<a name="ln1332">  gchar *b_text;</a>
<a name="ln1333"> </a>
<a name="ln1334">  gtk_tree_model_get(model, a, P_MODULE_COLUMN, &amp;a_text, -1);</a>
<a name="ln1335">  gtk_tree_model_get(model, b, P_MODULE_COLUMN, &amp;b_text, -1);</a>
<a name="ln1336">  if(*a_text == '\0' &amp;&amp; *b_text == '\0')</a>
<a name="ln1337">  {</a>
<a name="ln1338">    g_free(a_text);</a>
<a name="ln1339">    g_free(b_text);</a>
<a name="ln1340"> </a>
<a name="ln1341">    gtk_tree_model_get(model, a, P_NAME_COLUMN, &amp;a_text, -1);</a>
<a name="ln1342">    gtk_tree_model_get(model, b, P_NAME_COLUMN, &amp;b_text, -1);</a>
<a name="ln1343">  }</a>
<a name="ln1344"> </a>
<a name="ln1345">  const int res = strcasecmp(a_text, b_text);</a>
<a name="ln1346"> </a>
<a name="ln1347">  g_free(a_text);</a>
<a name="ln1348">  g_free(b_text);</a>
<a name="ln1349"> </a>
<a name="ln1350">  return res;</a>
<a name="ln1351">}</a>
<a name="ln1352"> </a>
<a name="ln1353">// FIXME: Mostly c&amp;p from gui/presets.c</a>
<a name="ln1354">static void check_buttons_activated(GtkCheckButton *button, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1355">{</a>
<a name="ln1356">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply))</a>
<a name="ln1357">     || gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)))</a>
<a name="ln1358">  {</a>
<a name="ln1359">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1360">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1361">    gtk_widget_show_all(GTK_WIDGET(g-&gt;details));</a>
<a name="ln1362">    gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1363">  }</a>
<a name="ln1364">  else</a>
<a name="ln1365">    gtk_widget_set_visible(GTK_WIDGET(g-&gt;details), FALSE);</a>
<a name="ln1366">}</a>
<a name="ln1367"> </a>
<a name="ln1368">static void edit_preset(GtkTreeView *tree, const gint rowid, const gchar *name, const gchar *module)</a>
<a name="ln1369">{</a>
<a name="ln1370">  GtkWidget *dialog;</a>
<a name="ln1371">  /* Create the widgets */</a>
<a name="ln1372">  char title[1024];</a>
<a name="ln1373">  snprintf(title, sizeof(title), _(&quot;edit `%s' for module `%s'&quot;), name, module);</a>
<a name="ln1374">  dialog = gtk_dialog_new_with_buttons(title, GTK_WINDOW(_preferences_dialog),</a>
<a name="ln1375">                                       GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL,</a>
<a name="ln1376">                                       _(&quot;_save&quot;), GTK_RESPONSE_YES,</a>
<a name="ln1377">                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln1378">                                       _(&quot;_ok&quot;), GTK_RESPONSE_OK, NULL);</a>
<a name="ln1379">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1380">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1381">#endif</a>
<a name="ln1382">  GtkContainer *content_area = GTK_CONTAINER(gtk_dialog_get_content_area(GTK_DIALOG(dialog)));</a>
<a name="ln1383">  GtkBox *box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln1384">  gtk_container_add(content_area, GTK_WIDGET(box));</a>
<a name="ln1385">  GtkWidget *label;</a>
<a name="ln1386"> </a>
<a name="ln1387">  dt_gui_presets_edit_dialog_t *g</a>
<a name="ln1388">      = (dt_gui_presets_edit_dialog_t *)malloc(sizeof(dt_gui_presets_edit_dialog_t));</a>
<a name="ln1389">  g-&gt;rowid = rowid;</a>
<a name="ln1390">  g-&gt;tree = tree;</a>
<a name="ln1391">  g-&gt;name = GTK_LABEL(gtk_label_new(name));</a>
<a name="ln1392">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;name), FALSE, FALSE, 0);</a>
<a name="ln1393"> </a>
<a name="ln1394">  g-&gt;description = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1395">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;description), FALSE, FALSE, 0);</a>
<a name="ln1396">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;description), _(&quot;description or further information&quot;));</a>
<a name="ln1397"> </a>
<a name="ln1398">  g-&gt;autoapply</a>
<a name="ln1399">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;auto apply this preset to matching images&quot;)));</a>
<a name="ln1400">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;autoapply), FALSE, FALSE, 0);</a>
<a name="ln1401">  g-&gt;filter</a>
<a name="ln1402">      = GTK_CHECK_BUTTON(gtk_check_button_new_with_label(_(&quot;only show this preset for matching images&quot;)));</a>
<a name="ln1403">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;filter),</a>
<a name="ln1404">                              _(&quot;be very careful with this option. this might be the last time you see your preset.&quot;));</a>
<a name="ln1405">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;filter), FALSE, FALSE, 0);</a>
<a name="ln1406">  g_signal_connect(G_OBJECT(g-&gt;autoapply), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1407">  g_signal_connect(G_OBJECT(g-&gt;filter), &quot;toggled&quot;, G_CALLBACK(check_buttons_activated), g);</a>
<a name="ln1408"> </a>
<a name="ln1409">  int line = 0;</a>
<a name="ln1410">  g-&gt;details = gtk_grid_new();</a>
<a name="ln1411">  gtk_grid_set_row_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln1412">  gtk_grid_set_column_spacing(GTK_GRID(g-&gt;details), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln1413">  gtk_box_pack_start(box, GTK_WIDGET(g-&gt;details), FALSE, FALSE, 0);</a>
<a name="ln1414"> </a>
<a name="ln1415">  // model, maker, lens</a>
<a name="ln1416">  g-&gt;model = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1417">  /* xgettext:no-c-format */</a>
<a name="ln1418">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;model), _(&quot;string to match model (use % as wildcard)&quot;));</a>
<a name="ln1419">  label = gtk_label_new(_(&quot;model&quot;));</a>
<a name="ln1420">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1421">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1422">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;model), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1423"> </a>
<a name="ln1424">  g-&gt;maker = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1425">  /* xgettext:no-c-format */</a>
<a name="ln1426">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;maker), _(&quot;string to match maker (use % as wildcard)&quot;));</a>
<a name="ln1427">  label = gtk_label_new(_(&quot;maker&quot;));</a>
<a name="ln1428">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1429">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1430">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;maker), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1431"> </a>
<a name="ln1432">  g-&gt;lens = GTK_ENTRY(gtk_entry_new());</a>
<a name="ln1433">  /* xgettext:no-c-format */</a>
<a name="ln1434">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;lens), _(&quot;string to match lens (use % as wildcard)&quot;));</a>
<a name="ln1435">  label = gtk_label_new(_(&quot;lens&quot;));</a>
<a name="ln1436">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1437">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1438">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;lens), label, GTK_POS_RIGHT, 2, 1);</a>
<a name="ln1439"> </a>
<a name="ln1440">  // iso</a>
<a name="ln1441">  label = gtk_label_new(_(&quot;ISO&quot;));</a>
<a name="ln1442">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1443">  g-&gt;iso_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1444">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_min), _(&quot;minimum ISO value&quot;));</a>
<a name="ln1445">  gtk_spin_button_set_digits(g-&gt;iso_min, 0);</a>
<a name="ln1446">  g-&gt;iso_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, FLT_MAX, 100));</a>
<a name="ln1447">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;iso_max), _(&quot;maximum ISO value&quot;));</a>
<a name="ln1448">  gtk_spin_button_set_digits(g-&gt;iso_max, 0);</a>
<a name="ln1449">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1450">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1451">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;iso_max), GTK_WIDGET(g-&gt;iso_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1452"> </a>
<a name="ln1453">  // exposure</a>
<a name="ln1454">  label = gtk_label_new(_(&quot;exposure&quot;));</a>
<a name="ln1455">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1456">  g-&gt;exposure_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1457">  g-&gt;exposure_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1458">  gtk_widget_set_tooltip_text(g-&gt;exposure_min, _(&quot;minimum exposure time&quot;));</a>
<a name="ln1459">  gtk_widget_set_tooltip_text(g-&gt;exposure_max, _(&quot;maximum exposure time&quot;));</a>
<a name="ln1460">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1461">    dt_bauhaus_combobox_add(g-&gt;exposure_min, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1462">  for(int k = 0; k &lt; dt_gui_presets_exposure_value_cnt; k++)</a>
<a name="ln1463">    dt_bauhaus_combobox_add(g-&gt;exposure_max, dt_gui_presets_exposure_value_str[k]);</a>
<a name="ln1464">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1465">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1466">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;exposure_max, g-&gt;exposure_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1467"> </a>
<a name="ln1468">  // aperture</a>
<a name="ln1469">  label = gtk_label_new(_(&quot;aperture&quot;));</a>
<a name="ln1470">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1471">  g-&gt;aperture_min = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1472">  g-&gt;aperture_max = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1473">  gtk_widget_set_tooltip_text(g-&gt;aperture_min, _(&quot;minimum aperture value&quot;));</a>
<a name="ln1474">  gtk_widget_set_tooltip_text(g-&gt;aperture_max, _(&quot;maximum aperture value&quot;));</a>
<a name="ln1475">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1476">    dt_bauhaus_combobox_add(g-&gt;aperture_min, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1477">  for(int k = 0; k &lt; dt_gui_presets_aperture_value_cnt; k++)</a>
<a name="ln1478">    dt_bauhaus_combobox_add(g-&gt;aperture_max, dt_gui_presets_aperture_value_str[k]);</a>
<a name="ln1479">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1480">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_min, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1481">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), g-&gt;aperture_max, g-&gt;aperture_min, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1482"> </a>
<a name="ln1483">  // focal length</a>
<a name="ln1484">  label = gtk_label_new(_(&quot;focal length&quot;));</a>
<a name="ln1485">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1486">  g-&gt;focal_length_min = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1487">  gtk_spin_button_set_digits(g-&gt;focal_length_min, 0);</a>
<a name="ln1488">  g-&gt;focal_length_max = GTK_SPIN_BUTTON(gtk_spin_button_new_with_range(0, 1000, 10));</a>
<a name="ln1489">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_min), _(&quot;minimum focal length&quot;));</a>
<a name="ln1490">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;focal_length_max), _(&quot;maximum focal length&quot;));</a>
<a name="ln1491">  gtk_spin_button_set_digits(g-&gt;focal_length_max, 0);</a>
<a name="ln1492">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line++, 1, 1);</a>
<a name="ln1493">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_min), label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1494">  gtk_grid_attach_next_to(GTK_GRID(g-&gt;details), GTK_WIDGET(g-&gt;focal_length_max), GTK_WIDGET(g-&gt;focal_length_min), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln1495">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_min), TRUE);</a>
<a name="ln1496">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;focal_length_max), TRUE);</a>
<a name="ln1497"> </a>
<a name="ln1498">  // raw/hdr/ldr</a>
<a name="ln1499">  label = gtk_label_new(_(&quot;format&quot;));</a>
<a name="ln1500">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln1501">  gtk_grid_attach(GTK_GRID(g-&gt;details), label, 0, line, 1, 1);</a>
<a name="ln1502"> </a>
<a name="ln1503">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1504">  {</a>
<a name="ln1505">    g-&gt;format_btn[i] = gtk_check_button_new_with_label(_(dt_gui_presets_format_value_str[i]));</a>
<a name="ln1506">    gtk_grid_attach(GTK_GRID(g-&gt;details), g-&gt;format_btn[i], 1, line + i, 2, 1);</a>
<a name="ln1507">  }</a>
<a name="ln1508"> </a>
<a name="ln1509">  gtk_widget_set_no_show_all(GTK_WIDGET(g-&gt;details), TRUE);</a>
<a name="ln1510"> </a>
<a name="ln1511">  sqlite3_stmt *stmt;</a>
<a name="ln1512">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1513">                              &quot;SELECT description, model, maker, lens, iso_min, iso_max, exposure_min, &quot;</a>
<a name="ln1514">                              &quot;exposure_max, aperture_min, aperture_max, focal_length_min, focal_length_max, &quot;</a>
<a name="ln1515">                              &quot;autoapply, filter, format FROM data.presets WHERE rowid = ?1&quot;,</a>
<a name="ln1516">                              -1, &amp;stmt, NULL);</a>
<a name="ln1517">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, rowid);</a>
<a name="ln1518">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1519">  {</a>
<a name="ln1520">    gtk_entry_set_text(g-&gt;description, (const char *)sqlite3_column_text(stmt, 0));</a>
<a name="ln1521">    gtk_entry_set_text(g-&gt;model, (const char *)sqlite3_column_text(stmt, 1));</a>
<a name="ln1522">    gtk_entry_set_text(g-&gt;maker, (const char *)sqlite3_column_text(stmt, 2));</a>
<a name="ln1523">    gtk_entry_set_text(g-&gt;lens, (const char *)sqlite3_column_text(stmt, 3));</a>
<a name="ln1524">    gtk_spin_button_set_value(g-&gt;iso_min, sqlite3_column_double(stmt, 4));</a>
<a name="ln1525">    gtk_spin_button_set_value(g-&gt;iso_max, sqlite3_column_double(stmt, 5));</a>
<a name="ln1526"> </a>
<a name="ln1527">    float val = sqlite3_column_double(stmt, 6);</a>
<a name="ln1528">    int k = 0;</a>
<a name="ln1529">    for(; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1530">      ;</a>
<a name="ln1531">    dt_bauhaus_combobox_set(g-&gt;exposure_min, k);</a>
<a name="ln1532">    val = sqlite3_column_double(stmt, 7);</a>
<a name="ln1533">    for(k = 0; k &lt; dt_gui_presets_exposure_value_cnt &amp;&amp; val &gt; dt_gui_presets_exposure_value[k]; k++)</a>
<a name="ln1534">      ;</a>
<a name="ln1535">    dt_bauhaus_combobox_set(g-&gt;exposure_max, k);</a>
<a name="ln1536">    val = sqlite3_column_double(stmt, 8);</a>
<a name="ln1537">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1538">      ;</a>
<a name="ln1539">    dt_bauhaus_combobox_set(g-&gt;aperture_min, k);</a>
<a name="ln1540">    val = sqlite3_column_double(stmt, 9);</a>
<a name="ln1541">    for(k = 0; k &lt; dt_gui_presets_aperture_value_cnt &amp;&amp; val &gt; dt_gui_presets_aperture_value[k]; k++)</a>
<a name="ln1542">      ;</a>
<a name="ln1543">    dt_bauhaus_combobox_set(g-&gt;aperture_max, k);</a>
<a name="ln1544">    gtk_spin_button_set_value(g-&gt;focal_length_min, sqlite3_column_double(stmt, 10));</a>
<a name="ln1545">    gtk_spin_button_set_value(g-&gt;focal_length_max, sqlite3_column_double(stmt, 11));</a>
<a name="ln1546">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply), sqlite3_column_int(stmt, 12));</a>
<a name="ln1547">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;filter), sqlite3_column_int(stmt, 13));</a>
<a name="ln1548">    const int format = sqlite3_column_int(stmt, 14);</a>
<a name="ln1549">    for(k = 0; k &lt; 3; k++)</a>
<a name="ln1550">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k]), format &amp; (dt_gui_presets_format_flag[k]));</a>
<a name="ln1551">  }</a>
<a name="ln1552">  sqlite3_finalize(stmt);</a>
<a name="ln1553"> </a>
<a name="ln1554">  g_signal_connect(dialog, &quot;response&quot;, G_CALLBACK(edit_preset_response), g);</a>
<a name="ln1555">  gtk_widget_show_all(dialog);</a>
<a name="ln1556">}</a>
<a name="ln1557"> </a>
<a name="ln1558">static void edit_preset_response(GtkDialog *dialog, gint response_id, dt_gui_presets_edit_dialog_t *g)</a>
<a name="ln1559">{</a>
<a name="ln1560">  // commit all the user input fields</a>
<a name="ln1561">  if(response_id == GTK_RESPONSE_OK)</a>
<a name="ln1562">  {</a>
<a name="ln1563">    sqlite3_stmt *stmt;</a>
<a name="ln1564">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1565">                                &quot;UPDATE data.presets SET description = ?1, model = ?2, maker = ?3, lens = ?4, &quot;</a>
<a name="ln1566">                                &quot;iso_min = ?5, iso_max = ?6, exposure_min = ?7, exposure_max = ?8, &quot;</a>
<a name="ln1567">                                &quot;aperture_min = ?9, aperture_max = ?10, focal_length_min = ?11, &quot;</a>
<a name="ln1568">                                &quot;focal_length_max = ?12, autoapply = ?13, filter = ?14, def = 0, format = ?15 &quot;</a>
<a name="ln1569">                                &quot;WHERE rowid = ?16&quot;,</a>
<a name="ln1570">                                -1, &amp;stmt, NULL);</a>
<a name="ln1571">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, gtk_entry_get_text(g-&gt;description), -1, SQLITE_TRANSIENT);</a>
<a name="ln1572">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, gtk_entry_get_text(g-&gt;model), -1, SQLITE_TRANSIENT);</a>
<a name="ln1573">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 3, gtk_entry_get_text(g-&gt;maker), -1, SQLITE_TRANSIENT);</a>
<a name="ln1574">    DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, gtk_entry_get_text(g-&gt;lens), -1, SQLITE_TRANSIENT);</a>
<a name="ln1575">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 5, gtk_spin_button_get_value(g-&gt;iso_min));</a>
<a name="ln1576">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 6, gtk_spin_button_get_value(g-&gt;iso_max));</a>
<a name="ln1577">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 7,</a>
<a name="ln1578">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_min)]);</a>
<a name="ln1579">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 8,</a>
<a name="ln1580">                                 dt_gui_presets_exposure_value[dt_bauhaus_combobox_get(g-&gt;exposure_max)]);</a>
<a name="ln1581">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 9,</a>
<a name="ln1582">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_min)]);</a>
<a name="ln1583">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 10,</a>
<a name="ln1584">                                 dt_gui_presets_aperture_value[dt_bauhaus_combobox_get(g-&gt;aperture_max)]);</a>
<a name="ln1585">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11, gtk_spin_button_get_value(g-&gt;focal_length_min));</a>
<a name="ln1586">    DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 12, gtk_spin_button_get_value(g-&gt;focal_length_max));</a>
<a name="ln1587">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 13, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;autoapply)));</a>
<a name="ln1588">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 14, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;filter)));</a>
<a name="ln1589">    int format = 0;</a>
<a name="ln1590">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1591">      format += gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(g-&gt;format_btn[k])) * dt_gui_presets_format_flag[k];</a>
<a name="ln1592">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 15, format);</a>
<a name="ln1593">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 16, g-&gt;rowid);</a>
<a name="ln1594">    sqlite3_step(stmt);</a>
<a name="ln1595">    sqlite3_finalize(stmt);</a>
<a name="ln1596">  }</a>
<a name="ln1597">  else if(response_id == GTK_RESPONSE_YES)</a>
<a name="ln1598">  {</a>
<a name="ln1599">    const gchar *name = gtk_label_get_text(g-&gt;name);</a>
<a name="ln1600"> </a>
<a name="ln1601">    // ask for destination directory</a>
<a name="ln1602"> </a>
<a name="ln1603">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1604">    GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1605">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1606">      GTK_RESPONSE_CANCEL, _(&quot;_select as output destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1607">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1608">    dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1609">#endif</a>
<a name="ln1610"> </a>
<a name="ln1611">    // save if accepted</a>
<a name="ln1612"> </a>
<a name="ln1613">    if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1614">    {</a>
<a name="ln1615">      char *filedir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1616">      dt_presets_save_to_file(g-&gt;rowid, name, filedir);</a>
<a name="ln1617">      dt_control_log(_(&quot;preset %s was successfully saved&quot;), name);</a>
<a name="ln1618">      g_free(filedir);</a>
<a name="ln1619">    }</a>
<a name="ln1620"> </a>
<a name="ln1621">    gtk_widget_destroy(GTK_WIDGET(filechooser));</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  GtkTreeStore *tree_store = GTK_TREE_STORE(gtk_tree_view_get_model(g-&gt;tree));</a>
<a name="ln1625">  gtk_tree_store_clear(tree_store);</a>
<a name="ln1626">  tree_insert_presets(tree_store);</a>
<a name="ln1627"> </a>
<a name="ln1628">  gtk_widget_destroy(GTK_WIDGET(dialog));</a>
<a name="ln1629">  free(g);</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1633">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1634">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1389"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1389, 1388.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
