
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2018 edgardo hoszowski.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln24">#include &quot;common/iop_order.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28">#include &quot;develop/pixelpipe.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;stdio.h&gt;</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#include &lt;string.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#define DT_IOP_ORDER_VERSION 4</a>
<a name="ln35"> </a>
<a name="ln36">#define DT_IOP_ORDER_INFO FALSE	// used while debugging</a>
<a name="ln37"> </a>
<a name="ln38">static void _ioppr_insert_iop_after(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_previous, const int dont_move);</a>
<a name="ln39">static void _ioppr_insert_iop_before(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_next, const int dont_move);</a>
<a name="ln40">static void _ioppr_move_iop_after(GList **_iop_order_list, const char *op_current, const char *op_prev, const int dont_move);</a>
<a name="ln41">static void _ioppr_move_iop_before(GList **_iop_order_list, const char *op_current, const char *op_next, const int dont_move);</a>
<a name="ln42"> </a>
<a name="ln43">// this routine rewrite the iop-order to have all them evenly spaced</a>
<a name="ln44">// into the list ensuring that we can insert safely at least 40 iop</a>
<a name="ln45">// between any two of them. Probably not the best fix, this is mostly</a>
<a name="ln46">// a workaround for current limitation and will avoid issues for the next</a>
<a name="ln47">// release.</a>
<a name="ln48">// ?? TODO: redo the whole pipe ordering</a>
<a name="ln49">static void _rewrite_order(GList *iop_order_list)</a>
<a name="ln50">{</a>
<a name="ln51">  GList *l = iop_order_list;</a>
<a name="ln52">  double order = 1.0;</a>
<a name="ln53">  while(l)</a>
<a name="ln54">  {</a>
<a name="ln55">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)l-&gt;data;</a>
<a name="ln56">    order_entry-&gt;iop_order = order;</a>
<a name="ln57">    order += 1.0;</a>
<a name="ln58">    l = g_list_next(l);</a>
<a name="ln59">  }</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">/* migrates *_iop_order_list from old_version to the next version (version + 1)</a>
<a name="ln63"> * limitations:</a>
<a name="ln64"> * - to move an existing module that is always enabled a new version must be created, otherwise</a>
<a name="ln65"> *   modules can be added/moved in the current version</a>
<a name="ln66"> * - a module can't be more than once on the same version</a>
<a name="ln67"> */</a>
<a name="ln68">static int _ioppr_legacy_iop_order_step(GList **_iop_order_list, GList *history_list, const int old_version, const int dont_move)</a>
<a name="ln69">{</a>
<a name="ln70">  int new_version = -1;</a>
<a name="ln71"> </a>
<a name="ln72">  // version 1 --&gt; 2</a>
<a name="ln73">  if(old_version == 1)</a>
<a name="ln74">  {</a>
<a name="ln75">    _ioppr_move_iop_after(_iop_order_list, &quot;colorin&quot;, &quot;demosaic&quot;, dont_move);</a>
<a name="ln76">    _ioppr_move_iop_before(_iop_order_list, &quot;colorout&quot;, &quot;clahe&quot;, dont_move);</a>
<a name="ln77">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;basicadj&quot;, &quot;colorin&quot;, dont_move);</a>
<a name="ln78">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;rgbcurve&quot;, &quot;levels&quot;, dont_move);</a>
<a name="ln79">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;lut3d&quot;, &quot;grain&quot;, dont_move);</a>
<a name="ln80">    _ioppr_insert_iop_before(_iop_order_list, history_list, &quot;rgblevels&quot;, &quot;rgbcurve&quot;, dont_move);</a>
<a name="ln81">    _ioppr_move_iop_before(_iop_order_list, &quot;dither&quot;, &quot;borders&quot;, dont_move);</a>
<a name="ln82">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;toneequal&quot;, &quot;clipping&quot;, dont_move);</a>
<a name="ln83"> </a>
<a name="ln84">    new_version = 2;</a>
<a name="ln85">  }</a>
<a name="ln86">  // version 2 --&gt; 3</a>
<a name="ln87">  else if(old_version == 2)</a>
<a name="ln88">  {</a>
<a name="ln89">    // GENERAL RULE FOR SIGNAL PROCESSING/RECONSTRUCTION</a>
<a name="ln90">    // pictures are formed through this path :</a>
<a name="ln91">    // scene/surfaces/shapes -&gt; atmosphere -&gt; lens -&gt; sensor -&gt; RAW file</a>
<a name="ln92">    // we then need to reconstruct/clean the signal the other way :</a>
<a name="ln93">    // RAW file -&gt; sensor denoise -&gt; lens profile / deblur -&gt; atmosphere dehaze -&gt; surfaces perspective correction</a>
<a name="ln94"> </a>
<a name="ln95">    // correct exposure in camera RGB space (otherwise, it's not really exposure)</a>
<a name="ln96">    _ioppr_move_iop_before(_iop_order_list, &quot;exposure&quot;, &quot;colorin&quot;, dont_move);</a>
<a name="ln97"> </a>
<a name="ln98">    // move local distorsions/pixel shifts after general distorsions</a>
<a name="ln99">    _ioppr_move_iop_before(_iop_order_list, &quot;retouch&quot;, &quot;exposure&quot;, dont_move);</a>
<a name="ln100">    _ioppr_move_iop_before(_iop_order_list, &quot;spots&quot;, &quot;retouch&quot;, dont_move);</a>
<a name="ln101">    _ioppr_move_iop_before(_iop_order_list, &quot;liquify&quot;, &quot;spots&quot;, dont_move);</a>
<a name="ln102"> </a>
<a name="ln103">    // move general perspective/distorsions module after lens</a>
<a name="ln104">    _ioppr_move_iop_before(_iop_order_list, &quot;clipping&quot;, &quot;liquify&quot;, dont_move);</a>
<a name="ln105">    _ioppr_move_iop_before(_iop_order_list, &quot;flip&quot;, &quot;clipping&quot;, dont_move);</a>
<a name="ln106">    _ioppr_move_iop_before(_iop_order_list, &quot;ashift&quot;, &quot;flip&quot;, dont_move);</a>
<a name="ln107"> </a>
<a name="ln108">    // dehaze</a>
<a name="ln109">    _ioppr_move_iop_before(_iop_order_list, &quot;hazeremoval&quot;, &quot;ashift&quot;, dont_move);</a>
<a name="ln110"> </a>
<a name="ln111">    // lens profiles need a pure sensor reading with no correction</a>
<a name="ln112">    _ioppr_move_iop_before(_iop_order_list, &quot;lens&quot;, &quot;hazeremoval&quot;, dont_move);</a>
<a name="ln113"> </a>
<a name="ln114">    // pixel scaling</a>
<a name="ln115">    _ioppr_move_iop_before(_iop_order_list, &quot;scalepixels&quot;, &quot;lens&quot;, dont_move);</a>
<a name="ln116">    _ioppr_move_iop_before(_iop_order_list, &quot;rotatepixels&quot;, &quot;scalepixels&quot;, dont_move);</a>
<a name="ln117"> </a>
<a name="ln118">    // move denoising before any deformation to avoid anisotropic noise creation</a>
<a name="ln119">    _ioppr_move_iop_before(_iop_order_list, &quot;bilateral&quot;, &quot;rotatepixels&quot;, dont_move);</a>
<a name="ln120">    _ioppr_move_iop_before(_iop_order_list, &quot;denoiseprofile&quot;, &quot;bilateral&quot;, dont_move);</a>
<a name="ln121">    _ioppr_move_iop_before(_iop_order_list, &quot;demosaic&quot;, &quot;denoiseprofile&quot;, dont_move);</a>
<a name="ln122"> </a>
<a name="ln123">    // move Lab denoising/reconstruction after input profile where signal is linear</a>
<a name="ln124">    // NB: denoising in non-linear spaces makes no sense</a>
<a name="ln125">    _ioppr_move_iop_before(_iop_order_list, &quot;colorin&quot;, &quot;nlmeans&quot;, dont_move);</a>
<a name="ln126">    _ioppr_move_iop_after(_iop_order_list, &quot;defringe&quot;, &quot;nlmeans&quot;, dont_move);</a>
<a name="ln127"> </a>
<a name="ln128">    // move frequency filters right after input profile - convolutions need L2 spaces</a>
<a name="ln129">    // to respect Parseval's theorem and avoid halos at edges</a>
<a name="ln130">    // NB: again, frequency filter in Lab make no sense</a>
<a name="ln131">    _ioppr_move_iop_after(_iop_order_list, &quot;atrous&quot;, &quot;defringe&quot;, dont_move);</a>
<a name="ln132">    _ioppr_move_iop_after(_iop_order_list, &quot;lowpass&quot;, &quot;atrous&quot;, dont_move);</a>
<a name="ln133">    _ioppr_move_iop_after(_iop_order_list, &quot;highpass&quot;, &quot;lowpass&quot;, dont_move);</a>
<a name="ln134">    _ioppr_move_iop_after(_iop_order_list, &quot;sharpen&quot;, &quot;highpass&quot;, dont_move);</a>
<a name="ln135"> </a>
<a name="ln136">    // color adjustments in scene-linear space : move right after colorin</a>
<a name="ln137">    _ioppr_move_iop_after(_iop_order_list, &quot;channelmixer&quot;, &quot;sharpen&quot;, dont_move);</a>
<a name="ln138">    _ioppr_move_iop_after(_iop_order_list, &quot;colorchecker&quot;, &quot;channelmixer&quot;, dont_move);</a>
<a name="ln139">    _ioppr_move_iop_after(_iop_order_list, &quot;colormapping&quot;, &quot;colorchecker&quot;, dont_move);</a>
<a name="ln140">    _ioppr_move_iop_after(_iop_order_list, &quot;colorbalance&quot;, &quot;colormapping&quot;, dont_move);</a>
<a name="ln141"> </a>
<a name="ln142">    _ioppr_move_iop_after(_iop_order_list, &quot;lut3d&quot;, &quot;colortransfer&quot;, dont_move);</a>
<a name="ln143">    _ioppr_move_iop_after(_iop_order_list, &quot;colortransfer&quot;, &quot;colorchecker&quot;, dont_move);</a>
<a name="ln144">    _ioppr_move_iop_after(_iop_order_list, &quot;basicadj&quot;, &quot;colorbalance&quot;, dont_move);</a>
<a name="ln145">    _ioppr_move_iop_after(_iop_order_list, &quot;rgbcurve&quot;, &quot;basicadj&quot;, dont_move);</a>
<a name="ln146">    _ioppr_move_iop_after(_iop_order_list, &quot;rgblevels&quot;, &quot;rgbcurve&quot;, dont_move);</a>
<a name="ln147">    _ioppr_move_iop_after(_iop_order_list, &quot;bloom&quot;, &quot;rgblevels&quot;, dont_move);</a>
<a name="ln148"> </a>
<a name="ln149">    // scene-linear to display-referred encoding</a>
<a name="ln150">    // !!! WALLÂ OF THE NON-LINEARITY !!! There is no coming back for colour ratios</a>
<a name="ln151">    _ioppr_move_iop_after(_iop_order_list, &quot;basecurve&quot;, &quot;bloom&quot;, dont_move);</a>
<a name="ln152">    _ioppr_move_iop_after(_iop_order_list, &quot;filmic&quot;, &quot;basecurve&quot;, dont_move);</a>
<a name="ln153">    _ioppr_move_iop_after(_iop_order_list, &quot;colisa&quot;, &quot;filmic&quot;, dont_move);</a>
<a name="ln154">    _ioppr_move_iop_after(_iop_order_list, &quot;tonecurve&quot;, &quot;colisa&quot;, dont_move);</a>
<a name="ln155">    _ioppr_move_iop_after(_iop_order_list, &quot;levels&quot;, &quot;tonecurve&quot;, dont_move);</a>
<a name="ln156"> </a>
<a name="ln157">    _ioppr_move_iop_after(_iop_order_list, &quot;shadhi&quot;, &quot;levels&quot;, dont_move);</a>
<a name="ln158"> </a>
<a name="ln159">    // recover local contrast after non-linear tone edits</a>
<a name="ln160">    _ioppr_move_iop_after(_iop_order_list, &quot;bilat&quot;, &quot;shadhi&quot;, dont_move);</a>
<a name="ln161"> </a>
<a name="ln162">    // display-referred colour edits</a>
<a name="ln163">    _ioppr_move_iop_after(_iop_order_list, &quot;colorcorrection&quot;, &quot;bilat&quot;, dont_move);</a>
<a name="ln164">    _ioppr_move_iop_after(_iop_order_list, &quot;colorzones&quot;, &quot;colorcorrection&quot;, dont_move);</a>
<a name="ln165">    _ioppr_move_iop_after(_iop_order_list, &quot;vibrance&quot;, &quot;colorzones&quot;, dont_move);</a>
<a name="ln166">    _ioppr_move_iop_after(_iop_order_list, &quot;velvia&quot;, &quot;vibrance&quot;, dont_move);</a>
<a name="ln167">    _ioppr_move_iop_after(_iop_order_list, &quot;colorize&quot;, &quot;velvia&quot;, dont_move);</a>
<a name="ln168">    _ioppr_move_iop_after(_iop_order_list, &quot;colorcontrast&quot;, &quot;colorize&quot;, dont_move);</a>
<a name="ln169"> </a>
<a name="ln170">    // fix clipping before going in colourout</a>
<a name="ln171">    _ioppr_move_iop_before(_iop_order_list, &quot;colorreconstruct&quot;, &quot;colorout&quot;, dont_move);</a>
<a name="ln172">    _ioppr_move_iop_before(_iop_order_list, &quot;vignette&quot;, &quot;colorreconstruct&quot;, dont_move);</a>
<a name="ln173"> </a>
<a name="ln174">    _ioppr_move_iop_before(_iop_order_list, &quot;dither&quot;, &quot;borders&quot;, dont_move);</a>
<a name="ln175"> </a>
<a name="ln176">    // new modules here</a>
<a name="ln177">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;filmicrgb&quot;, &quot;filmic&quot;, dont_move);</a>
<a name="ln178"> </a>
<a name="ln179">    new_version = 3;</a>
<a name="ln180">  }</a>
<a name="ln181">  else if(old_version == 3)</a>
<a name="ln182">  {</a>
<a name="ln183">    // version 4 is a rewrite of the iop-order of previous list. As it</a>
<a name="ln184">    // can be seen above some modules have very close iop-order values</a>
<a name="ln185">    // and does not have lot of room for insertion (multi-instance</a>
<a name="ln186">    // module and/or reordering).</a>
<a name="ln187"> </a>
<a name="ln188">    if(!dont_move) _rewrite_order(*_iop_order_list);</a>
<a name="ln189">    new_version = 4;</a>
<a name="ln190">  }</a>
<a name="ln191">  // each new version MUST be written as the following (_rewrite_order IS VERY important)</a>
<a name="ln192"> </a>
<a name="ln193">  // If a new module is to be added, it must be added in the current</a>
<a name="ln194">  // version (just above) and then a new version must be created with</a>
<a name="ln195">  // the following code to ensure modules are evenly spaced (leaving</a>
<a name="ln196">  // room for multi-instances and user's re-ordering):</a>
<a name="ln197">  /*</a>
<a name="ln198">  else if(old_version == &lt;N&gt;)</a>
<a name="ln199">  {</a>
<a name="ln200">    // reorder modules to ensure they are all evenly spaced</a>
<a name="ln201">    if(!dont_move) _rewrite_order(*_iop_order_list);</a>
<a name="ln202">    new_version = &lt;N+1&gt;;</a>
<a name="ln203">  }</a>
<a name="ln204">  */</a>
<a name="ln205"> </a>
<a name="ln206">  // If a module is to be reodered in the pipe, the following code</a>
<a name="ln207">  // must be used. A new version must be created to ensure modules are</a>
<a name="ln208">  // evenly spaced (leaving room for multi-instances and user's</a>
<a name="ln209">  // re-ordering):</a>
<a name="ln210">  /*</a>
<a name="ln211">  else if(old_version == &lt;N&gt;)</a>
<a name="ln212">  {</a>
<a name="ln213">    _ioppr_move_iop_[before|after](_iop_order_list, &quot;new_module&quot;, &quot;some_module&quot;, dont_move);</a>
<a name="ln214">    if(!dont_move) _rewrite_order(*_iop_order_list);</a>
<a name="ln215">    new_version = &lt;N+1&gt;;</a>
<a name="ln216">  }</a>
<a name="ln217">  */</a>
<a name="ln218"> </a>
<a name="ln219">  if(new_version &lt;= 0)</a>
<a name="ln220">    fprintf(stderr, &quot;[_ioppr_legacy_iop_order_step] missing step migrating from version %i\n&quot;, old_version);</a>
<a name="ln221"> </a>
<a name="ln222">  return new_version;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">// returns a list of dt_iop_order_rule_t</a>
<a name="ln226">// this do not have versions</a>
<a name="ln227">GList *dt_ioppr_get_iop_order_rules()</a>
<a name="ln228">{</a>
<a name="ln229">  GList *rules = NULL;</a>
<a name="ln230"> </a>
<a name="ln231">  const dt_iop_order_rule_t rule_entry[] = { { &quot;rawprepare&quot;, &quot;invert&quot; },</a>
<a name="ln232">                                                { &quot;invert&quot;, &quot;temperature&quot; },</a>
<a name="ln233">                                                { &quot;temperature&quot;, &quot;highlights&quot; },</a>
<a name="ln234">                                                { &quot;highlights&quot;, &quot;cacorrect&quot; },</a>
<a name="ln235">                                                { &quot;cacorrect&quot;, &quot;hotpixels&quot; },</a>
<a name="ln236">                                                { &quot;hotpixels&quot;, &quot;rawdenoise&quot; },</a>
<a name="ln237">                                                { &quot;rawdenoise&quot;, &quot;demosaic&quot; },</a>
<a name="ln238">                                                { &quot;demosaic&quot;, &quot;colorin&quot; },</a>
<a name="ln239">                                                { &quot;colorin&quot;, &quot;colorout&quot; },</a>
<a name="ln240">                                                { &quot;colorout&quot;, &quot;gamma&quot; },</a>
<a name="ln241">						/* clipping GUI broken if flip is done on top */</a>
<a name="ln242">                                                { &quot;flip&quot;, &quot;clipping&quot; },</a>
<a name="ln243">						/* clipping GUI broken if ashift is done on top */</a>
<a name="ln244">                                                { &quot;ashift&quot;, &quot;clipping&quot; },</a>
<a name="ln245">                                                { &quot;\0&quot;, &quot;\0&quot; } };</a>
<a name="ln246"> </a>
<a name="ln247">  int i = 0;</a>
<a name="ln248">  while(rule_entry[i].op_prev[0])</a>
<a name="ln249">  {</a>
<a name="ln250">    dt_iop_order_rule_t *rule = calloc(1, sizeof(dt_iop_order_rule_t));</a>
<a name="ln251"> </a>
<a name="ln252">    snprintf(rule-&gt;op_prev, sizeof(rule-&gt;op_prev), &quot;%s&quot;, rule_entry[i].op_prev);</a>
<a name="ln253">    snprintf(rule-&gt;op_next, sizeof(rule-&gt;op_next), &quot;%s&quot;, rule_entry[i].op_next);</a>
<a name="ln254"> </a>
<a name="ln255">    rules = g_list_append(rules, rule);</a>
<a name="ln256">    i++;</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  return rules;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">// first version of iop order, must never be modified</a>
<a name="ln263">// it returns a list with the default iop_order per module, starting at 1.0, increment by 1.0</a>
<a name="ln264">static GList *_ioppr_get_iop_order_v1()</a>
<a name="ln265">{</a>
<a name="ln266">  GList *iop_order_list = NULL;</a>
<a name="ln267"> </a>
<a name="ln268">  const dt_iop_order_entry_t prior_entry[] = { { 0.0, &quot;rawprepare&quot; },</a>
<a name="ln269">                                                  { 0.0, &quot;invert&quot; },</a>
<a name="ln270">                                                  { 0.0, &quot;temperature&quot; },</a>
<a name="ln271">                                                  { 0.0, &quot;highlights&quot; },</a>
<a name="ln272">                                                  { 0.0, &quot;cacorrect&quot; },</a>
<a name="ln273">                                                  { 0.0, &quot;hotpixels&quot; },</a>
<a name="ln274">                                                  { 0.0, &quot;rawdenoise&quot; },</a>
<a name="ln275">                                                  { 0.0, &quot;demosaic&quot; },</a>
<a name="ln276">                                                  { 0.0, &quot;mask_manager&quot; },</a>
<a name="ln277">                                                  { 0.0, &quot;denoiseprofile&quot; },</a>
<a name="ln278">                                                  { 0.0, &quot;tonemap&quot; },</a>
<a name="ln279">                                                  { 0.0, &quot;exposure&quot; },</a>
<a name="ln280">                                                  { 0.0, &quot;spots&quot; },</a>
<a name="ln281">                                                  { 0.0, &quot;retouch&quot; },</a>
<a name="ln282">                                                  { 0.0, &quot;lens&quot; },</a>
<a name="ln283">                                                  { 0.0, &quot;ashift&quot; },</a>
<a name="ln284">                                                  { 0.0, &quot;liquify&quot; },</a>
<a name="ln285">                                                  { 0.0, &quot;rotatepixels&quot; },</a>
<a name="ln286">                                                  { 0.0, &quot;scalepixels&quot; },</a>
<a name="ln287">                                                  { 0.0, &quot;flip&quot; },</a>
<a name="ln288">                                                  { 0.0, &quot;clipping&quot; },</a>
<a name="ln289">                                                  { 0.0, &quot;graduatednd&quot; },</a>
<a name="ln290">                                                  { 0.0, &quot;basecurve&quot; },</a>
<a name="ln291">                                                  { 0.0, &quot;bilateral&quot; },</a>
<a name="ln292">                                                  { 0.0, &quot;profile_gamma&quot; },</a>
<a name="ln293">                                                  { 0.0, &quot;hazeremoval&quot; },</a>
<a name="ln294">                                                  { 0.0, &quot;colorin&quot; },</a>
<a name="ln295">                                                  { 0.0, &quot;colorreconstruct&quot; },</a>
<a name="ln296">                                                  { 0.0, &quot;colorchecker&quot; },</a>
<a name="ln297">                                                  { 0.0, &quot;defringe&quot; },</a>
<a name="ln298">                                                  { 0.0, &quot;equalizer&quot; },</a>
<a name="ln299">                                                  { 0.0, &quot;vibrance&quot; },</a>
<a name="ln300">                                                  { 0.0, &quot;colorbalance&quot; },</a>
<a name="ln301">                                                  { 0.0, &quot;colorize&quot; },</a>
<a name="ln302">                                                  { 0.0, &quot;colortransfer&quot; },</a>
<a name="ln303">                                                  { 0.0, &quot;colormapping&quot; },</a>
<a name="ln304">                                                  { 0.0, &quot;bloom&quot; },</a>
<a name="ln305">                                                  { 0.0, &quot;nlmeans&quot; },</a>
<a name="ln306">                                                  { 0.0, &quot;globaltonemap&quot; },</a>
<a name="ln307">                                                  { 0.0, &quot;shadhi&quot; },</a>
<a name="ln308">                                                  { 0.0, &quot;atrous&quot; },</a>
<a name="ln309">                                                  { 0.0, &quot;bilat&quot; },</a>
<a name="ln310">                                                  { 0.0, &quot;colorzones&quot; },</a>
<a name="ln311">                                                  { 0.0, &quot;lowlight&quot; },</a>
<a name="ln312">                                                  { 0.0, &quot;monochrome&quot; },</a>
<a name="ln313">                                                  { 0.0, &quot;filmic&quot; },</a>
<a name="ln314">                                                  { 0.0, &quot;colisa&quot; },</a>
<a name="ln315">                                                  { 0.0, &quot;zonesystem&quot; },</a>
<a name="ln316">                                                  { 0.0, &quot;tonecurve&quot; },</a>
<a name="ln317">                                                  { 0.0, &quot;levels&quot; },</a>
<a name="ln318">                                                  { 0.0, &quot;relight&quot; },</a>
<a name="ln319">                                                  { 0.0, &quot;colorcorrection&quot; },</a>
<a name="ln320">                                                  { 0.0, &quot;sharpen&quot; },</a>
<a name="ln321">                                                  { 0.0, &quot;lowpass&quot; },</a>
<a name="ln322">                                                  { 0.0, &quot;highpass&quot; },</a>
<a name="ln323">                                                  { 0.0, &quot;grain&quot; },</a>
<a name="ln324">                                                  { 0.0, &quot;colorcontrast&quot; },</a>
<a name="ln325">                                                  { 0.0, &quot;colorout&quot; },</a>
<a name="ln326">                                                  { 0.0, &quot;channelmixer&quot; },</a>
<a name="ln327">                                                  { 0.0, &quot;soften&quot; },</a>
<a name="ln328">                                                  { 0.0, &quot;vignette&quot; },</a>
<a name="ln329">                                                  { 0.0, &quot;splittoning&quot; },</a>
<a name="ln330">                                                  { 0.0, &quot;velvia&quot; },</a>
<a name="ln331">                                                  { 0.0, &quot;clahe&quot; },</a>
<a name="ln332">                                                  { 0.0, &quot;finalscale&quot; },</a>
<a name="ln333">                                                  { 0.0, &quot;overexposed&quot; },</a>
<a name="ln334">                                                  { 0.0, &quot;rawoverexposed&quot; },</a>
<a name="ln335">                                                  { 0.0, &quot;borders&quot; },</a>
<a name="ln336">                                                  { 0.0, &quot;watermark&quot; },</a>
<a name="ln337">                                                  { 0.0, &quot;dither&quot; },</a>
<a name="ln338">                                                  { 0.0, &quot;gamma&quot; },</a>
<a name="ln339">                                                  { 0.0, &quot;\0&quot; }</a>
<a name="ln340">  };</a>
<a name="ln341"> </a>
<a name="ln342">  int i = 0;</a>
<a name="ln343">  while(prior_entry[i].operation[0] != '\0')</a>
<a name="ln344">  {</a>
<a name="ln345">    dt_iop_order_entry_t *order_entry = calloc(1, sizeof(dt_iop_order_entry_t));</a>
<a name="ln346"> </a>
<a name="ln347">    order_entry-&gt;iop_order = (double)(i + 1);</a>
<a name="ln348">    snprintf(order_entry-&gt;operation, sizeof(order_entry-&gt;operation), &quot;%s&quot;, prior_entry[i].operation);</a>
<a name="ln349"> </a>
<a name="ln350">    iop_order_list = g_list_append(iop_order_list, order_entry);</a>
<a name="ln351">    i++;</a>
<a name="ln352">  }</a>
<a name="ln353"> </a>
<a name="ln354">  return iop_order_list;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">// returns the first iop order entry that matches operation == op_name</a>
<a name="ln358">dt_iop_order_entry_t *dt_ioppr_get_iop_order_entry(GList *iop_order_list, const char *op_name)</a>
<a name="ln359">{</a>
<a name="ln360">  dt_iop_order_entry_t *iop_order_entry = NULL;</a>
<a name="ln361"> </a>
<a name="ln362">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln363">  while(iops_order)</a>
<a name="ln364">  {</a>
<a name="ln365">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln366"> </a>
<a name="ln367">    if(strcmp(order_entry-&gt;operation, op_name) == 0)</a>
<a name="ln368">    {</a>
<a name="ln369">      iop_order_entry = order_entry;</a>
<a name="ln370">      break;</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    iops_order = g_list_next(iops_order);</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  return iop_order_entry;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">// returns the iop_order associated with the iop order entry that matches operation == op_name</a>
<a name="ln380">double dt_ioppr_get_iop_order(GList *iop_order_list, const char *op_name)</a>
<a name="ln381">{</a>
<a name="ln382">  double iop_order = DBL_MAX;</a>
<a name="ln383">  const dt_iop_order_entry_t *order_entry = dt_ioppr_get_iop_order_entry(iop_order_list, op_name);</a>
<a name="ln384"> </a>
<a name="ln385">  if(order_entry)</a>
<a name="ln386">    iop_order = order_entry-&gt;iop_order;</a>
<a name="ln387"> </a>
<a name="ln388">  return iop_order;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">// insert op_new before op_next on *_iop_order_list</a>
<a name="ln392">// it sets the iop_order on op_new</a>
<a name="ln393">// if check_history == 1 it check that the generated iop_order do not exists on any module in history</a>
<a name="ln394">static void _ioppr_insert_iop_before(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_next, const int check_history)</a>
<a name="ln395">{</a>
<a name="ln396">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln397"> </a>
<a name="ln398">  // check that the new operation don't exists on the list</a>
<a name="ln399">  if(dt_ioppr_get_iop_order_entry(iop_order_list, op_new) == NULL)</a>
<a name="ln400">  {</a>
<a name="ln401">    // create a new iop order entry</a>
<a name="ln402">    dt_iop_order_entry_t *iop_order_new = (dt_iop_order_entry_t*)calloc(1, sizeof(dt_iop_order_entry_t));</a>
<a name="ln403">    snprintf(iop_order_new-&gt;operation, sizeof(iop_order_new-&gt;operation), &quot;%s&quot;, op_new);</a>
<a name="ln404"> </a>
<a name="ln405">    // search for the previous one</a>
<a name="ln406">    int position = 0;</a>
<a name="ln407">    int found = 0;</a>
<a name="ln408">    double iop_order_prev = DBL_MAX;</a>
<a name="ln409">    double iop_order_next = DBL_MAX;</a>
<a name="ln410">    GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln411">    while(iops_order)</a>
<a name="ln412">    {</a>
<a name="ln413">      dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln414">      if(strcmp(order_entry-&gt;operation, op_next) == 0)</a>
<a name="ln415">      {</a>
<a name="ln416">        iop_order_next = order_entry-&gt;iop_order;</a>
<a name="ln417">        found = 1;</a>
<a name="ln418">        break;</a>
<a name="ln419">      }</a>
<a name="ln420">      iop_order_prev = order_entry-&gt;iop_order;</a>
<a name="ln421">      position++;</a>
<a name="ln422"> </a>
<a name="ln423">      iops_order = g_list_next(iops_order);</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    // now we have to check if there's a module with iop_order between iop_order_prev and iop_order_next</a>
<a name="ln427">    if(found)</a>
<a name="ln428">    {</a>
<a name="ln429">      if(!check_history)</a>
<a name="ln430">      {</a>
<a name="ln431">        GList *history = g_list_first(history_list);</a>
<a name="ln432">        while(history)</a>
<a name="ln433">        {</a>
<a name="ln434">          dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln435"> </a>
<a name="ln436">          if(hist-&gt;iop_order &gt;= iop_order_prev &amp;&amp; hist-&gt;iop_order &lt;= iop_order_next)</a>
<a name="ln437">            iop_order_prev = hist-&gt;iop_order;</a>
<a name="ln438"> </a>
<a name="ln439">          history = g_list_next(history);</a>
<a name="ln440">        }</a>
<a name="ln441">      }</a>
<a name="ln442">    }</a>
<a name="ln443">    else</a>
<a name="ln444">      fprintf(stderr, &quot;[_ioppr_insert_iop_before] module %s don't exists on iop order list\n&quot;, op_next);</a>
<a name="ln445"> </a>
<a name="ln446">    if(found)</a>
<a name="ln447">    {</a>
<a name="ln448">      // set the iop_order</a>
<a name="ln449">      iop_order_new-&gt;iop_order = iop_order_prev + (iop_order_next - iop_order_prev) / 2.0;</a>
<a name="ln450">      if (DT_IOP_ORDER_INFO) fprintf(stderr,&quot;\n  _ioppr_insert_iop_before %16s: %14.11f [xmp:%8.4f], prev %14.11f, next %14.11f&quot;,op_new,iop_order_new-&gt;iop_order,iop_order_new-&gt;iop_order,iop_order_prev,iop_order_next);</a>
<a name="ln451"> </a>
<a name="ln452">      // insert it on the proper order</a>
<a name="ln453">      iop_order_list = g_list_insert(iop_order_list, iop_order_new, position);</a>
<a name="ln454">    }</a>
<a name="ln455">  }</a>
<a name="ln456">  else</a>
<a name="ln457">    fprintf(stderr, &quot;[_ioppr_insert_iop_before] module %s already exists on iop order list\n&quot;, op_new);</a>
<a name="ln458"> </a>
<a name="ln459">  *_iop_order_list = iop_order_list;</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">// insert op_new after op_prev on *_iop_order_list</a>
<a name="ln463">// it updates the iop_order on op_new</a>
<a name="ln464">// if check_history == 1 it check that the generated iop_order do not exists on any module in history</a>
<a name="ln465">static void _ioppr_insert_iop_after(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_prev, const int check_history)</a>
<a name="ln466">{</a>
<a name="ln467">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln468"> </a>
<a name="ln469">  // inserting after op_prev is the same as moving before the very next one after op_prev</a>
<a name="ln470">  dt_iop_order_entry_t *prior_next = NULL;</a>
<a name="ln471">  GList *iops_order = g_list_last(iop_order_list);</a>
<a name="ln472">  while(iops_order)</a>
<a name="ln473">  {</a>
<a name="ln474">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)iops_order-&gt;data;</a>
<a name="ln475">    if(strcmp(order_entry-&gt;operation, op_prev) == 0) break;</a>
<a name="ln476"> </a>
<a name="ln477">    prior_next = order_entry;</a>
<a name="ln478">    iops_order = g_list_previous(iops_order);</a>
<a name="ln479">  }</a>
<a name="ln480">  if(prior_next == NULL)</a>
<a name="ln481">  {</a>
<a name="ln482">    fprintf(</a>
<a name="ln483">        stderr,</a>
<a name="ln484">        &quot;[_ioppr_insert_iop_after] can't find module previous to %s while moving %s after it\n&quot;,</a>
<a name="ln485">        op_prev, op_new);</a>
<a name="ln486">  }</a>
<a name="ln487">  else</a>
<a name="ln488">    _ioppr_insert_iop_before(&amp;iop_order_list, history_list, op_new, prior_next-&gt;operation, check_history);</a>
<a name="ln489"> </a>
<a name="ln490">  *_iop_order_list = iop_order_list;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">// moves op_current before op_next by updating the iop_order</a>
<a name="ln494">// only if dont_move == FALSE</a>
<a name="ln495">static void _ioppr_move_iop_before(GList **_iop_order_list, const char *op_current, const char *op_next, const int dont_move)</a>
<a name="ln496">{</a>
<a name="ln497">  if(dont_move) return;</a>
<a name="ln498"> </a>
<a name="ln499">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln500"> </a>
<a name="ln501">  int position = 0;</a>
<a name="ln502">  int found = 0;</a>
<a name="ln503">  dt_iop_order_entry_t *iop_order_prev = NULL;</a>
<a name="ln504">  dt_iop_order_entry_t *iop_order_next = NULL;</a>
<a name="ln505">  dt_iop_order_entry_t *iop_order_current = NULL;</a>
<a name="ln506">  GList *iops_order_current = NULL;</a>
<a name="ln507"> </a>
<a name="ln508">  // search for the current one</a>
<a name="ln509">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln510">  while(iops_order)</a>
<a name="ln511">  {</a>
<a name="ln512">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln513">    if(strcmp(order_entry-&gt;operation, op_current) == 0)</a>
<a name="ln514">    {</a>
<a name="ln515">      iops_order_current = iops_order;</a>
<a name="ln516">      iop_order_current = order_entry;</a>
<a name="ln517">      found = 1;</a>
<a name="ln518">      break;</a>
<a name="ln519">    }</a>
<a name="ln520"> </a>
<a name="ln521">    iops_order = g_list_next(iops_order);</a>
<a name="ln522">  }</a>
<a name="ln523"> </a>
<a name="ln524">  if(found)</a>
<a name="ln525">  {</a>
<a name="ln526">    // remove it from the list</a>
<a name="ln527">    iop_order_list = g_list_remove_link(iop_order_list, iops_order_current);</a>
<a name="ln528">  }</a>
<a name="ln529">  else</a>
<a name="ln530">    fprintf(stderr, &quot;[_ioppr_move_iop_before] current module %s don't exists on iop order list\n&quot;, op_current);</a>
<a name="ln531"> </a>
<a name="ln532">  // search for the previous and next one</a>
<a name="ln533">  if(found)</a>
<a name="ln534">  {</a>
<a name="ln535">    found = 0;</a>
<a name="ln536">    iops_order = g_list_first(iop_order_list);</a>
<a name="ln537">    while(iops_order)</a>
<a name="ln538">    {</a>
<a name="ln539">      dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln540">      if(strcmp(order_entry-&gt;operation, op_next) == 0)</a>
<a name="ln541">      {</a>
<a name="ln542">        iop_order_next = order_entry;</a>
<a name="ln543">        found = 1;</a>
<a name="ln544">        break;</a>
<a name="ln545">      }</a>
<a name="ln546">      iop_order_prev = order_entry;</a>
<a name="ln547">      position++;</a>
<a name="ln548"> </a>
<a name="ln549">      iops_order = g_list_next(iops_order);</a>
<a name="ln550">    }</a>
<a name="ln551">  }</a>
<a name="ln552"> </a>
<a name="ln553">  if(found)</a>
<a name="ln554">  {</a>
<a name="ln555">    // set the iop_order</a>
<a name="ln556">    iop_order_current-&gt;iop_order = iop_order_prev-&gt;iop_order + (iop_order_next-&gt;iop_order - iop_order_prev-&gt;iop_order) / 2.0;</a>
<a name="ln557"> </a>
<a name="ln558">    // insert it on the proper order</a>
<a name="ln559">    iop_order_list = g_list_insert(iop_order_list, iop_order_current, position);</a>
<a name="ln560">    if (DT_IOP_ORDER_INFO) fprintf(stderr,&quot;\n  _ioppr_move_iop_before   %16s: %14.11f [xmp:%8.4f], prev %14.11f, next %14.11f&quot;,op_current,iop_order_current-&gt;iop_order,iop_order_current-&gt;iop_order,iop_order_prev-&gt;iop_order,iop_order_next-&gt;iop_order);</a>
<a name="ln561">  }</a>
<a name="ln562">  else</a>
<a name="ln563">    fprintf(stderr, &quot;[_ioppr_move_iop_before] next module %s don't exists on iop order list\n&quot;, op_next);</a>
<a name="ln564"> </a>
<a name="ln565">  *_iop_order_list = iop_order_list;</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">// moves op_current after op_prev by updating the iop_order</a>
<a name="ln569">// only if dont_move == FALSE</a>
<a name="ln570">static void _ioppr_move_iop_after(GList **_iop_order_list, const char *op_current, const char *op_prev, const int dont_move)</a>
<a name="ln571">{</a>
<a name="ln572">  if(dont_move) return;</a>
<a name="ln573"> </a>
<a name="ln574">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln575"> </a>
<a name="ln576">  // moving after op_prev is the same as moving before the very next one after op_prev</a>
<a name="ln577">  dt_iop_order_entry_t *prior_next = NULL;</a>
<a name="ln578">  GList *iops_order = g_list_last(iop_order_list);</a>
<a name="ln579">  while(iops_order)</a>
<a name="ln580">  {</a>
<a name="ln581">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)iops_order-&gt;data;</a>
<a name="ln582">    if(strcmp(order_entry-&gt;operation, op_prev) == 0) break;</a>
<a name="ln583"> </a>
<a name="ln584">    prior_next = order_entry;</a>
<a name="ln585">    iops_order = g_list_previous(iops_order);</a>
<a name="ln586">  }</a>
<a name="ln587">  if(prior_next == NULL)</a>
<a name="ln588">  {</a>
<a name="ln589">    fprintf(</a>
<a name="ln590">        stderr,</a>
<a name="ln591">        &quot;[_ioppr_move_iop_after] can't find module previous to %s while moving %s after it\n&quot;,</a>
<a name="ln592">        op_prev, op_current);</a>
<a name="ln593">  }</a>
<a name="ln594">  else</a>
<a name="ln595">    _ioppr_move_iop_before(&amp;iop_order_list, op_current, prior_next-&gt;operation, dont_move);</a>
<a name="ln596"> </a>
<a name="ln597">  *_iop_order_list = iop_order_list;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">// returns a list of dt_iop_order_entry_t</a>
<a name="ln601">// if *_version == 0 it returns the current version and updates *_version</a>
<a name="ln602">GList *dt_ioppr_get_iop_order_list(int *_version)</a>
<a name="ln603">{</a>
<a name="ln604">  GList *iop_order_list = _ioppr_get_iop_order_v1();</a>
<a name="ln605">  int old_version = 1;</a>
<a name="ln606">  const int version = ((_version == NULL) || (*_version == 0)) ? DT_IOP_ORDER_VERSION: *_version;</a>
<a name="ln607"> </a>
<a name="ln608">  while(old_version &lt; version &amp;&amp; old_version &gt; 0)</a>
<a name="ln609">  {</a>
<a name="ln610">    old_version = _ioppr_legacy_iop_order_step(&amp;iop_order_list, NULL, old_version, FALSE);</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  if(old_version != version)</a>
<a name="ln614">  {</a>
<a name="ln615">    fprintf(stderr, &quot;[dt_ioppr_get_iop_order_list] error building iop_order_list to version %i\n&quot;, version);</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  if(_version &amp;&amp; *_version == 0 &amp;&amp; old_version &gt; 0) *_version = old_version;</a>
<a name="ln619"> </a>
<a name="ln620">  return iop_order_list;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">// sets the iop_order on each module of *_iop_list</a>
<a name="ln624">// iop_order is set only for base modules, multi-instances will be flagged as unused with DBL_MAX</a>
<a name="ln625">// if a module do not exists on iop_order_list it is flagged as unused with DBL_MAX</a>
<a name="ln626">void dt_ioppr_set_default_iop_order(GList **_iop_list, GList *iop_order_list)</a>
<a name="ln627">{</a>
<a name="ln628">  if (DT_IOP_ORDER_INFO) fprintf(stderr,&quot;\n\ndt_ioppr_set_default_iop_order &quot;); // dt_iop_module_so_t in develop/imageop.h</a>
<a name="ln629">  GList *iop_list = *_iop_list;</a>
<a name="ln630"> </a>
<a name="ln631">  GList *modules = g_list_first(iop_list);</a>
<a name="ln632">  while(modules)</a>
<a name="ln633">  {</a>
<a name="ln634">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln635"> </a>
<a name="ln636">    if(mod-&gt;multi_priority == 0)</a>
<a name="ln637">    {</a>
<a name="ln638">      mod-&gt;iop_order = dt_ioppr_get_iop_order(iop_order_list, mod-&gt;op);</a>
<a name="ln639">    }</a>
<a name="ln640">    // muti-instances will be set by read history</a>
<a name="ln641">    else</a>
<a name="ln642">    {</a>
<a name="ln643">      mod-&gt;iop_order = DBL_MAX;</a>
<a name="ln644">    }</a>
<a name="ln645"> </a>
<a name="ln646">    if (DT_IOP_ORDER_INFO) fprintf(stderr,&quot;\n  db: %14.11f   xmp %8.4f   %16s&quot;,mod-&gt;iop_order,mod-&gt;iop_order,mod-&gt;op);</a>
<a name="ln647">    modules = g_list_next(modules);</a>
<a name="ln648">  }</a>
<a name="ln649">  // we need to set the right order</a>
<a name="ln650">  iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln651"> </a>
<a name="ln652">  *_iop_list = iop_list;</a>
<a name="ln653">    if (DT_IOP_ORDER_INFO) fprintf(stderr,&quot;\n&quot;);</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">// returns the first dt_dev_history_item_t on history_list where hist-&gt;module == mod</a>
<a name="ln657">static dt_dev_history_item_t *_ioppr_search_history_by_module(GList *history_list, dt_iop_module_t *mod)</a>
<a name="ln658">{</a>
<a name="ln659">  dt_dev_history_item_t *hist_entry = NULL;</a>
<a name="ln660"> </a>
<a name="ln661">  GList *history = g_list_first(history_list);</a>
<a name="ln662">  while(history)</a>
<a name="ln663">  {</a>
<a name="ln664">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln665"> </a>
<a name="ln666">    if(hist-&gt;module == mod)</a>
<a name="ln667">    {</a>
<a name="ln668">      hist_entry = hist;</a>
<a name="ln669">      break;</a>
<a name="ln670">    }</a>
<a name="ln671"> </a>
<a name="ln672">    history = g_list_next(history);</a>
<a name="ln673">  }</a>
<a name="ln674"> </a>
<a name="ln675">  return hist_entry;</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">// check if there's duplicate iop_order entries in iop_list</a>
<a name="ln679">// if so, updates the iop_order to be unique, but only if the module is disabled and not in history</a>
<a name="ln680">void dt_ioppr_check_duplicate_iop_order(GList **_iop_list, GList *history_list)</a>
<a name="ln681">{</a>
<a name="ln682">  GList *iop_list = *_iop_list;</a>
<a name="ln683">  dt_iop_module_t *mod_prev = NULL;</a>
<a name="ln684"> </a>
<a name="ln685">  // get the first module</a>
<a name="ln686">  GList *modules = g_list_first(iop_list);</a>
<a name="ln687">  if(modules)</a>
<a name="ln688">  {</a>
<a name="ln689">    mod_prev = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln690">    modules = g_list_next(modules);</a>
<a name="ln691">  }</a>
<a name="ln692">  // check for each module if iop_order is the same as the previous one</a>
<a name="ln693">  // if so, change it, but only if disabled and not in history</a>
<a name="ln694">  while(modules)</a>
<a name="ln695">  {</a>
<a name="ln696">    int reset_list = 0;</a>
<a name="ln697">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln698"> </a>
<a name="ln699">    if(mod-&gt;iop_order == mod_prev-&gt;iop_order &amp;&amp; mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln700">    {</a>
<a name="ln701">      int can_move = 0;</a>
<a name="ln702"> </a>
<a name="ln703">      if(!mod-&gt;enabled &amp;&amp; _ioppr_search_history_by_module(history_list, mod) == NULL)</a>
<a name="ln704">      {</a>
<a name="ln705">        can_move = 1;</a>
<a name="ln706"> </a>
<a name="ln707">        GList *modules1 = g_list_next(modules);</a>
<a name="ln708">        if(modules1)</a>
<a name="ln709">        {</a>
<a name="ln710">          dt_iop_module_t *mod_next = (dt_iop_module_t *)(modules1-&gt;data);</a>
<a name="ln711">          if(mod-&gt;iop_order != mod_next-&gt;iop_order)</a>
<a name="ln712">          {</a>
<a name="ln713">            mod-&gt;iop_order += (mod_next-&gt;iop_order - mod-&gt;iop_order) / 2.0;</a>
<a name="ln714">          }</a>
<a name="ln715">          else</a>
<a name="ln716">          {</a>
<a name="ln717">            dt_ioppr_check_duplicate_iop_order(&amp;modules, history_list);</a>
<a name="ln718">            reset_list = 1;</a>
<a name="ln719">          }</a>
<a name="ln720">        }</a>
<a name="ln721">        else</a>
<a name="ln722">        {</a>
<a name="ln723">          mod-&gt;iop_order += 1.0;</a>
<a name="ln724">        }</a>
<a name="ln725">      }</a>
<a name="ln726">      else if(!mod_prev-&gt;enabled &amp;&amp; _ioppr_search_history_by_module(history_list, mod_prev) == NULL)</a>
<a name="ln727">      {</a>
<a name="ln728">        can_move = 1;</a>
<a name="ln729"> </a>
<a name="ln730">        GList *modules1 = g_list_previous(modules);</a>
<a name="ln731">        if(modules1) modules1 = g_list_previous(modules1);</a>
<a name="ln732">        if(modules1)</a>
<a name="ln733">        {</a>
<a name="ln734">          dt_iop_module_t *mod_next = (dt_iop_module_t *)(modules1-&gt;data);</a>
<a name="ln735">          if(mod_prev-&gt;iop_order != mod_next-&gt;iop_order)</a>
<a name="ln736">          {</a>
<a name="ln737">            mod_prev-&gt;iop_order -= (mod_prev-&gt;iop_order - mod_next-&gt;iop_order) / 2.0;</a>
<a name="ln738">          }</a>
<a name="ln739">          else</a>
<a name="ln740">          {</a>
<a name="ln741">            can_move = 0;</a>
<a name="ln742">            fprintf(stderr, &quot;[dt_ioppr_check_duplicate_iop_order 1] modules %s %s(%f) and %s %s(%f) have the same iop_order\n&quot;,</a>
<a name="ln743">                mod_prev-&gt;op, mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln744">          }</a>
<a name="ln745">        }</a>
<a name="ln746">        else</a>
<a name="ln747">        {</a>
<a name="ln748">          mod_prev-&gt;iop_order -= 0.5;</a>
<a name="ln749">        }</a>
<a name="ln750">      }</a>
<a name="ln751"> </a>
<a name="ln752">      if(!can_move)</a>
<a name="ln753">      {</a>
<a name="ln754">        fprintf(stderr, &quot;[dt_ioppr_check_duplicate_iop_order] modules %s %s(%f) and %s %s(%f) have the same iop_order\n&quot;,</a>
<a name="ln755">            mod_prev-&gt;op, mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln756">      }</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    if(reset_list)</a>
<a name="ln760">    {</a>
<a name="ln761">      modules = g_list_first(iop_list);</a>
<a name="ln762">      if(modules)</a>
<a name="ln763">      {</a>
<a name="ln764">        mod_prev = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln765">        modules = g_list_next(modules);</a>
<a name="ln766">      }</a>
<a name="ln767">    }</a>
<a name="ln768">    else</a>
<a name="ln769">    {</a>
<a name="ln770">      mod_prev = mod;</a>
<a name="ln771">      modules = g_list_next(modules);</a>
<a name="ln772">    }</a>
<a name="ln773">  }</a>
<a name="ln774"> </a>
<a name="ln775">  *_iop_list = iop_list;</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778">// upgrades iop &amp; iop order to current version</a>
<a name="ln779">void dt_ioppr_legacy_iop_order(GList **_iop_list, GList **_iop_order_list, GList *history_list, const int _old_version)</a>
<a name="ln780">{</a>
<a name="ln781">  GList *iop_list = *_iop_list;</a>
<a name="ln782">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln783">  int dt_version = DT_IOP_ORDER_VERSION;</a>
<a name="ln784">  int old_version = _old_version;</a>
<a name="ln785"> </a>
<a name="ln786">  // we want to add any module created after this version of iop_order</a>
<a name="ln787">  // but we won't move existing modules so only add methods will be executed</a>
<a name="ln788">  while(old_version &lt; dt_version &amp;&amp; old_version &gt; 0)</a>
<a name="ln789">  {</a>
<a name="ln790">    old_version = _ioppr_legacy_iop_order_step(&amp;iop_order_list, history_list, old_version, TRUE);</a>
<a name="ln791">  }</a>
<a name="ln792"> </a>
<a name="ln793">  // now that we have a list of iop_order for version new_version but with all new modules</a>
<a name="ln794">  // we take care of the iop_order of new modules on iop list</a>
<a name="ln795">  GList *modules = g_list_first(iop_list);</a>
<a name="ln796">  while(modules)</a>
<a name="ln797">  {</a>
<a name="ln798">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln799"> </a>
<a name="ln800">    if(mod-&gt;multi_priority == 0 &amp;&amp; mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln801">    {</a>
<a name="ln802">      mod-&gt;iop_order = dt_ioppr_get_iop_order(iop_order_list, mod-&gt;op);</a>
<a name="ln803">      if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln804">        fprintf(stderr, &quot;[dt_ioppr_legacy_iop_order] can't find iop_order for module %s\n&quot;, mod-&gt;op);</a>
<a name="ln805">    }</a>
<a name="ln806"> </a>
<a name="ln807">    modules = g_list_next(modules);</a>
<a name="ln808">  }</a>
<a name="ln809">  // we need to set the right order</a>
<a name="ln810">  iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln811"> </a>
<a name="ln812">  // and check for duplicates</a>
<a name="ln813">  dt_ioppr_check_duplicate_iop_order(&amp;iop_list, history_list);</a>
<a name="ln814"> </a>
<a name="ln815">  *_iop_list = iop_list;</a>
<a name="ln816">  *_iop_order_list = iop_order_list;</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">// check if all so modules on iop_list have a iop_order defined in iop_order_list</a>
<a name="ln820">int dt_ioppr_check_so_iop_order(GList *iop_list, GList *iop_order_list)</a>
<a name="ln821">{</a>
<a name="ln822">  int iop_order_missing = 0;</a>
<a name="ln823"> </a>
<a name="ln824">  // check if all the modules have their iop_order assigned</a>
<a name="ln825">  GList *modules = g_list_first(iop_list);</a>
<a name="ln826">  while(modules)</a>
<a name="ln827">  {</a>
<a name="ln828">    dt_iop_module_so_t *mod = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln829"> </a>
<a name="ln830">    dt_iop_order_entry_t *entry = dt_ioppr_get_iop_order_entry(iop_order_list, mod-&gt;op);</a>
<a name="ln831">    if(entry == NULL)</a>
<a name="ln832">    {</a>
<a name="ln833">      iop_order_missing = 1;</a>
<a name="ln834">      fprintf(stderr, &quot;[dt_ioppr_check_so_iop_order] missing iop_order for module %s\n&quot;, mod-&gt;op);</a>
<a name="ln835">    }</a>
<a name="ln836">    modules = g_list_next(modules);</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  return iop_order_missing;</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">static void *_dup_iop_order_entry(const void *src, gpointer data)</a>
<a name="ln843">{</a>
<a name="ln844">  dt_iop_order_entry_t *scr_entry = (dt_iop_order_entry_t *)src;</a>
<a name="ln845">  dt_iop_order_entry_t *new_entry = malloc(sizeof(dt_iop_order_entry_t));</a>
<a name="ln846">  memcpy(new_entry, scr_entry, sizeof(dt_iop_order_entry_t));</a>
<a name="ln847">  return (void *)new_entry;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">// returns a duplicate of iop_order_list</a>
<a name="ln851">GList *dt_ioppr_iop_order_copy_deep(GList *iop_order_list)</a>
<a name="ln852">{</a>
<a name="ln853">  return (GList *)g_list_copy_deep(iop_order_list, _dup_iop_order_entry, NULL);</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">// helper to sort a GList of dt_iop_module_t by iop_order</a>
<a name="ln857">gint dt_sort_iop_by_order(gconstpointer a, gconstpointer b)</a>
<a name="ln858">{</a>
<a name="ln859">  const dt_iop_module_t *am = (const dt_iop_module_t *)a;</a>
<a name="ln860">  const dt_iop_module_t *bm = (const dt_iop_module_t *)b;</a>
<a name="ln861">  if(am-&gt;iop_order &gt; bm-&gt;iop_order) return 1;</a>
<a name="ln862">  if(am-&gt;iop_order &lt; bm-&gt;iop_order) return -1;</a>
<a name="ln863">  return 0;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">// if module can be placed before than module_next on the pipe</a>
<a name="ln867">// it returns the new iop_order</a>
<a name="ln868">// if it cannot be placed it returns -1.0</a>
<a name="ln869">// this assumes that the order is always positive</a>
<a name="ln870">double dt_ioppr_get_iop_order_before_iop(GList *iop_list, dt_iop_module_t *module, dt_iop_module_t *module_next,</a>
<a name="ln871">                                  const int validate_order, const int log_error)</a>
<a name="ln872">{</a>
<a name="ln873">  if((module-&gt;flags() &amp; IOP_FLAGS_FENCE) &amp;&amp; validate_order)</a>
<a name="ln874">  {</a>
<a name="ln875">    if(log_error)</a>
<a name="ln876">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] module %s(%f) is a fence, can't move it before %s %s(%f)\n&quot;,</a>
<a name="ln877">          module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln878">    return -1.0;</a>
<a name="ln879">  }</a>
<a name="ln880"> </a>
<a name="ln881">  double iop_order = -1.0;</a>
<a name="ln882"> </a>
<a name="ln883">  // module is before on the pipe</a>
<a name="ln884">  // move it up</a>
<a name="ln885">  if(module-&gt;iop_order &lt; module_next-&gt;iop_order)</a>
<a name="ln886">  {</a>
<a name="ln887">    // let's first search for module</a>
<a name="ln888">    GList *modules = g_list_first(iop_list);</a>
<a name="ln889">    while(modules)</a>
<a name="ln890">    {</a>
<a name="ln891">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln892">      if(mod == module) break;</a>
<a name="ln893">      modules = g_list_next(modules);</a>
<a name="ln894">    }</a>
<a name="ln895"> </a>
<a name="ln896">    // we found the module</a>
<a name="ln897">    if(modules)</a>
<a name="ln898">    {</a>
<a name="ln899">      dt_iop_module_t *mod1 = NULL;</a>
<a name="ln900">      dt_iop_module_t *mod2 = NULL;</a>
<a name="ln901"> </a>
<a name="ln902">      // now search for module_next and the one previous to that, so iop_order can be calculated</a>
<a name="ln903">      // also check the rules</a>
<a name="ln904">      modules = g_list_next(modules);</a>
<a name="ln905">      while(modules)</a>
<a name="ln906">      {</a>
<a name="ln907">        dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln908"> </a>
<a name="ln909">        // if we reach module_next everything is OK</a>
<a name="ln910">        if(mod == module_next)</a>
<a name="ln911">        {</a>
<a name="ln912">          mod2 = mod;</a>
<a name="ln913">          break;</a>
<a name="ln914">        }</a>
<a name="ln915"> </a>
<a name="ln916">        // check for rules</a>
<a name="ln917">        if(validate_order)</a>
<a name="ln918">        {</a>
<a name="ln919">          // check if module can be moved around this one</a>
<a name="ln920">          if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln921">          {</a>
<a name="ln922">            if(log_error)</a>
<a name="ln923">              fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't move %s %s(%f) pass %s %s(%f)\n&quot;,</a>
<a name="ln924">                  module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln925">            break;</a>
<a name="ln926">          }</a>
<a name="ln927"> </a>
<a name="ln928">          // is there a rule about swapping this two?</a>
<a name="ln929">          int rule_found = 0;</a>
<a name="ln930">          GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln931">          while(rules)</a>
<a name="ln932">          {</a>
<a name="ln933">            dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln934"> </a>
<a name="ln935">            if(strcmp(module-&gt;op, rule-&gt;op_prev) == 0 &amp;&amp; strcmp(mod-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln936">            {</a>
<a name="ln937">              if(log_error)</a>
<a name="ln938">                fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] found rule %s %s while moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln939">                        rule-&gt;op_prev, rule-&gt;op_next, module-&gt;op,  module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op,  module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln940">              rule_found = 1;</a>
<a name="ln941">              break;</a>
<a name="ln942">            }</a>
<a name="ln943"> </a>
<a name="ln944">            rules = g_list_next(rules);</a>
<a name="ln945">          }</a>
<a name="ln946">          if(rule_found) break;</a>
<a name="ln947">        }</a>
<a name="ln948"> </a>
<a name="ln949">        mod1 = mod;</a>
<a name="ln950">        modules = g_list_next(modules);</a>
<a name="ln951">      }</a>
<a name="ln952"> </a>
<a name="ln953">      // we reach the module_next module</a>
<a name="ln954">      if(mod2)</a>
<a name="ln955">      {</a>
<a name="ln956">        // this is already the previous module!</a>
<a name="ln957">        if(module == mod1)</a>
<a name="ln958">        {</a>
<a name="ln959">          if(log_error)</a>
<a name="ln960">            fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) is already previous to %s %s(%f)\n&quot;,</a>
<a name="ln961">                module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln962">        }</a>
<a name="ln963">        else if(mod1-&gt;iop_order == mod2-&gt;iop_order)</a>
<a name="ln964">        {</a>
<a name="ln965">          fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) and %s %s(%f) have the same iop_order\n&quot;,</a>
<a name="ln966">              mod1-&gt;op, mod1-&gt;multi_name, mod1-&gt;iop_order, mod2-&gt;op, mod2-&gt;multi_name, mod2-&gt;iop_order);</a>
<a name="ln967">        }</a>
<a name="ln968">        else</a>
<a name="ln969">        {</a>
<a name="ln970">          // calculate new iop_order</a>
<a name="ln971">          iop_order = mod1-&gt;iop_order + (mod2-&gt;iop_order - mod1-&gt;iop_order) / 2.0;</a>
<a name="ln972">          /* fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] 2-calculated new iop_order=%f for %s(%f) between %s(%f) and %s(%f)\n&quot;,</a>
<a name="ln973">                 iop_order, module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;iop_order, mod-&gt;op, mod-&gt;iop_order); */</a>
<a name="ln974">        }</a>
<a name="ln975">      }</a>
<a name="ln976">    }</a>
<a name="ln977">    else</a>
<a name="ln978">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't find module %s %s\n&quot;, module-&gt;op, module-&gt;multi_name);</a>
<a name="ln979">  }</a>
<a name="ln980">  // module is next on the pipe</a>
<a name="ln981">  // move it down</a>
<a name="ln982">  else if(module-&gt;iop_order &gt; module_next-&gt;iop_order)</a>
<a name="ln983">  {</a>
<a name="ln984">    // let's first search for module</a>
<a name="ln985">    GList *modules = g_list_last(iop_list);</a>
<a name="ln986">    while(modules)</a>
<a name="ln987">    {</a>
<a name="ln988">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln989">      if(mod == module) break;</a>
<a name="ln990">      modules = g_list_previous(modules);</a>
<a name="ln991">    }</a>
<a name="ln992"> </a>
<a name="ln993">    // we found the module</a>
<a name="ln994">    if(modules)</a>
<a name="ln995">    {</a>
<a name="ln996">      dt_iop_module_t *mod1 = NULL;</a>
<a name="ln997">      dt_iop_module_t *mod2 = NULL;</a>
<a name="ln998"> </a>
<a name="ln999">      // now search for module_next and the one next to that, so iop_order can be calculated</a>
<a name="ln1000">      // also check the rules</a>
<a name="ln1001">      modules = g_list_previous(modules);</a>
<a name="ln1002">      while(modules)</a>
<a name="ln1003">      {</a>
<a name="ln1004">        dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1005"> </a>
<a name="ln1006">        // we reach the module next to module_next, everything is OK</a>
<a name="ln1007">        if(mod2 != NULL)</a>
<a name="ln1008">        {</a>
<a name="ln1009">          mod1 = mod;</a>
<a name="ln1010">          break;</a>
<a name="ln1011">        }</a>
<a name="ln1012"> </a>
<a name="ln1013">        // check for rules</a>
<a name="ln1014">        if(validate_order)</a>
<a name="ln1015">        {</a>
<a name="ln1016">          // check if module can be moved around this one</a>
<a name="ln1017">          if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln1018">          {</a>
<a name="ln1019">            if(log_error)</a>
<a name="ln1020">              fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't move %s %s(%f) pass %s %s(%f)\n&quot;,</a>
<a name="ln1021">                  module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln1022">            break;</a>
<a name="ln1023">          }</a>
<a name="ln1024"> </a>
<a name="ln1025">          // is there a rule about swapping this two?</a>
<a name="ln1026">          int rule_found = 0;</a>
<a name="ln1027">          GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln1028">          while(rules)</a>
<a name="ln1029">          {</a>
<a name="ln1030">            dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln1031"> </a>
<a name="ln1032">            if(strcmp(mod-&gt;op, rule-&gt;op_prev) == 0 &amp;&amp; strcmp(module-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1033">            {</a>
<a name="ln1034">              if(log_error)</a>
<a name="ln1035">                fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] found rule %s %s while moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln1036">                        rule-&gt;op_prev, rule-&gt;op_next, module-&gt;op,  module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op,  module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln1037">              rule_found = 1;</a>
<a name="ln1038">              break;</a>
<a name="ln1039">            }</a>
<a name="ln1040"> </a>
<a name="ln1041">            rules = g_list_next(rules);</a>
<a name="ln1042">          }</a>
<a name="ln1043">          if(rule_found) break;</a>
<a name="ln1044">        }</a>
<a name="ln1045"> </a>
<a name="ln1046">        if(mod == module_next) mod2 = mod;</a>
<a name="ln1047">        modules = g_list_previous(modules);</a>
<a name="ln1048">      }</a>
<a name="ln1049"> </a>
<a name="ln1050">      // we reach the module_next module</a>
<a name="ln1051">      if(mod1)</a>
<a name="ln1052">      {</a>
<a name="ln1053">        // this is already the previous module!</a>
<a name="ln1054">        if(module == mod2)</a>
<a name="ln1055">        {</a>
<a name="ln1056">          if(log_error)</a>
<a name="ln1057">            fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) is already previous to %s %s(%f)\n&quot;,</a>
<a name="ln1058">                module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln1059">        }</a>
<a name="ln1060">        else if(mod1-&gt;iop_order == mod2-&gt;iop_order)</a>
<a name="ln1061">        {</a>
<a name="ln1062">          fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) and %s %s(%f) have the same iop_order\n&quot;,</a>
<a name="ln1063">              mod1-&gt;op, mod1-&gt;multi_name, mod1-&gt;iop_order, mod2-&gt;op, mod2-&gt;multi_name, mod2-&gt;iop_order);</a>
<a name="ln1064">        }</a>
<a name="ln1065">        else</a>
<a name="ln1066">        {</a>
<a name="ln1067">          // calculate new iop_order</a>
<a name="ln1068">          iop_order = mod1-&gt;iop_order + (mod2-&gt;iop_order - mod1-&gt;iop_order) / 2.0;</a>
<a name="ln1069">          /* fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] 2-calculated new iop_order=%f for %s(%f) between %s(%f) and %s(%f)\n&quot;,</a>
<a name="ln1070">                 iop_order, module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;iop_order, mod-&gt;op, mod-&gt;iop_order); */</a>
<a name="ln1071">        }</a>
<a name="ln1072">      }</a>
<a name="ln1073">    }</a>
<a name="ln1074">    else</a>
<a name="ln1075">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't find module %s %s\n&quot;, module-&gt;op, module-&gt;multi_name);</a>
<a name="ln1076">  }</a>
<a name="ln1077">  else</a>
<a name="ln1078">  {</a>
<a name="ln1079">    fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] modules %s %s(%f) and %s %s(%f) have the same iop_order\n&quot;,</a>
<a name="ln1080">        module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln1081">  }</a>
<a name="ln1082"> </a>
<a name="ln1083">  return iop_order;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">// if module can be placed after than module_prev on the pipe</a>
<a name="ln1087">// it returns the new iop_order</a>
<a name="ln1088">// if it cannot be placed it returns -1.0</a>
<a name="ln1089">// this assumes that the order is always positive</a>
<a name="ln1090">double dt_ioppr_get_iop_order_after_iop(GList *iop_list, dt_iop_module_t *module, dt_iop_module_t *module_prev,</a>
<a name="ln1091">                                 const int validate_order, const int log_error)</a>
<a name="ln1092">{</a>
<a name="ln1093">  double iop_order = -1.0;</a>
<a name="ln1094"> </a>
<a name="ln1095">  // moving after module_prev is the same as moving before the very next one after module_prev</a>
<a name="ln1096">  GList *modules = g_list_last(iop_list);</a>
<a name="ln1097">  dt_iop_module_t *module_next = NULL;</a>
<a name="ln1098">  while(modules)</a>
<a name="ln1099">  {</a>
<a name="ln1100">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1101">    if(mod == module_prev) break;</a>
<a name="ln1102"> </a>
<a name="ln1103">    module_next = mod;</a>
<a name="ln1104">    modules = g_list_previous(modules);</a>
<a name="ln1105">  }</a>
<a name="ln1106">  if(module_next == NULL)</a>
<a name="ln1107">  {</a>
<a name="ln1108">    fprintf(</a>
<a name="ln1109">        stderr,</a>
<a name="ln1110">        &quot;[dt_ioppr_get_iop_order_after_iop] can't find module previous to %s %s(%f) while moving %s %s(%f) after it\n&quot;,</a>
<a name="ln1111">        module_prev-&gt;op, module_prev-&gt;multi_name, module_prev-&gt;iop_order, module-&gt;op, module-&gt;multi_name,</a>
<a name="ln1112">        module-&gt;iop_order);</a>
<a name="ln1113">  }</a>
<a name="ln1114">  else</a>
<a name="ln1115">    iop_order = dt_ioppr_get_iop_order_before_iop(iop_list, module, module_next, validate_order, log_error);</a>
<a name="ln1116"> </a>
<a name="ln1117">  return iop_order;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">// changes the module-&gt;iop_order so it comes before in the pipe than module_next</a>
<a name="ln1121">// sort dev-&gt;iop to reflect the changes</a>
<a name="ln1122">// return 1 if iop_order is changed, 0 otherwise</a>
<a name="ln1123">int dt_ioppr_move_iop_before(GList **_iop_list, dt_iop_module_t *module, dt_iop_module_t *module_next,</a>
<a name="ln1124">                       const int validate_order, const int log_error)</a>
<a name="ln1125">{</a>
<a name="ln1126">  GList *iop_list = *_iop_list;</a>
<a name="ln1127">  int moved = 0;</a>
<a name="ln1128"> </a>
<a name="ln1129">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_before begin&quot;);</a>
<a name="ln1130"> </a>
<a name="ln1131">  const double iop_order = dt_ioppr_get_iop_order_before_iop(iop_list, module, module_next, validate_order, log_error);</a>
<a name="ln1132"> </a>
<a name="ln1133">  if(iop_order &gt;= 0.0)</a>
<a name="ln1134">  {</a>
<a name="ln1135">    module-&gt;iop_order = iop_order;</a>
<a name="ln1136">    iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln1137">    moved = 1;</a>
<a name="ln1138">  }</a>
<a name="ln1139">  else if(log_error)</a>
<a name="ln1140">    fprintf(stderr, &quot;[dt_ioppr_move_iop_before] module %s is already before %s\n&quot;, module-&gt;op, module_next-&gt;op);</a>
<a name="ln1141"> </a>
<a name="ln1142">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_before end&quot;);</a>
<a name="ln1143"> </a>
<a name="ln1144">  *_iop_list = iop_list;</a>
<a name="ln1145"> </a>
<a name="ln1146">  return moved;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149">// changes the module-&gt;iop_order so it comes after in the pipe than module_prev</a>
<a name="ln1150">// sort dev-&gt;iop to reflect the changes</a>
<a name="ln1151">// return 1 if iop_order is changed, 0 otherwise</a>
<a name="ln1152">int dt_ioppr_move_iop_after(GList **_iop_list, dt_iop_module_t *module, dt_iop_module_t *module_prev,</a>
<a name="ln1153">                      const int validate_order, const int log_error)</a>
<a name="ln1154">{</a>
<a name="ln1155">  GList *iop_list = *_iop_list;</a>
<a name="ln1156">  int moved = 0;</a>
<a name="ln1157"> </a>
<a name="ln1158">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_after begin&quot;);</a>
<a name="ln1159"> </a>
<a name="ln1160">  const double iop_order = dt_ioppr_get_iop_order_after_iop(iop_list, module, module_prev, validate_order, log_error);</a>
<a name="ln1161">  if(iop_order &gt;= 0.0)</a>
<a name="ln1162">  {</a>
<a name="ln1163">    module-&gt;iop_order = iop_order;</a>
<a name="ln1164">    iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln1165">    moved = 1;</a>
<a name="ln1166">  }</a>
<a name="ln1167">  else if(log_error)</a>
<a name="ln1168">    fprintf(stderr, &quot;[dt_ioppr_move_iop_after] module %s is already after %s\n&quot;, module-&gt;op, module_prev-&gt;op);</a>
<a name="ln1169"> </a>
<a name="ln1170">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_after end&quot;);</a>
<a name="ln1171"> </a>
<a name="ln1172">  *_iop_list = iop_list;</a>
<a name="ln1173"> </a>
<a name="ln1174">  return moved;</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">//--------------------------------------------------------------------</a>
<a name="ln1178">// from here just for debug</a>
<a name="ln1179">//--------------------------------------------------------------------</a>
<a name="ln1180">int dt_ioppr_check_db_integrity()</a>
<a name="ln1181">{</a>
<a name="ln1182">  int ret = 0;</a>
<a name="ln1183">  sqlite3_stmt *stmt;</a>
<a name="ln1184"> </a>
<a name="ln1185">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid, operation, module FROM main.history WHERE iop_order &lt;= 0 OR iop_order IS NULL&quot;,</a>
<a name="ln1186">                              -1, &amp;stmt, NULL);</a>
<a name="ln1187">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1188">  {</a>
<a name="ln1189">    ret = 1;</a>
<a name="ln1190">    fprintf(stderr, &quot;\nThere are unassigned iop_order in the history!!!\n\n&quot;);</a>
<a name="ln1191"> </a>
<a name="ln1192">    int count = 0;</a>
<a name="ln1193">    do</a>
<a name="ln1194">    {</a>
<a name="ln1195">      const int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1196">      const char *opname = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1197">      const int modversion = sqlite3_column_int(stmt, 2);</a>
<a name="ln1198"> </a>
<a name="ln1199">      fprintf(stderr, &quot;image: %i module: %s version: %i\n&quot;, imgid, (opname) ? opname: &quot;module is NULL&quot;, modversion);</a>
<a name="ln1200">    } while(sqlite3_step(stmt) == SQLITE_ROW &amp;&amp; count++ &lt; 20);</a>
<a name="ln1201">  }</a>
<a name="ln1202"> </a>
<a name="ln1203">  sqlite3_finalize(stmt);</a>
<a name="ln1204"> </a>
<a name="ln1205">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT styleid, operation FROM data.style_items WHERE iop_order &lt;= 0 OR iop_order IS NULL&quot;,</a>
<a name="ln1206">                              -1, &amp;stmt, NULL);</a>
<a name="ln1207">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln1208">  {</a>
<a name="ln1209">    ret = 1;</a>
<a name="ln1210">    fprintf(stderr, &quot;\nThere are unassigned iop_order in the styles!!!\n\n&quot;);</a>
<a name="ln1211"> </a>
<a name="ln1212">    int count = 0;</a>
<a name="ln1213">    do</a>
<a name="ln1214">    {</a>
<a name="ln1215">      const int styleid = sqlite3_column_int(stmt, 0);</a>
<a name="ln1216">      const char *opname = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln1217"> </a>
<a name="ln1218">      fprintf(stderr, &quot;style: %i module: %s\n&quot;, styleid, (opname) ? opname: &quot;module is NULL&quot;);</a>
<a name="ln1219">    } while(sqlite3_step(stmt) == SQLITE_ROW &amp;&amp; count++ &lt; 20);</a>
<a name="ln1220">  }</a>
<a name="ln1221"> </a>
<a name="ln1222">  sqlite3_finalize(stmt);</a>
<a name="ln1223"> </a>
<a name="ln1224">  return ret;</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227">void dt_ioppr_print_module_iop_order(GList *iop_list, const char *msg)</a>
<a name="ln1228">{</a>
<a name="ln1229">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1230">  while(modules)</a>
<a name="ln1231">  {</a>
<a name="ln1232">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1233"> </a>
<a name="ln1234">    fprintf(stderr, &quot;[%s] module %s %s multi_priority=%i, iop_order=%f\n&quot;, msg, mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod-&gt;iop_order);</a>
<a name="ln1235"> </a>
<a name="ln1236">    modules = g_list_next(modules);</a>
<a name="ln1237">  }</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">void dt_ioppr_print_history_iop_order(GList *history_list, const char *msg)</a>
<a name="ln1241">{</a>
<a name="ln1242">  GList *history = g_list_first(history_list);</a>
<a name="ln1243">  while(history)</a>
<a name="ln1244">  {</a>
<a name="ln1245">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln1246"> </a>
<a name="ln1247">    fprintf(stderr, &quot;[%s] module %s %s multi_priority=%i, iop_order=%f\n&quot;, msg, hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;multi_priority, hist-&gt;iop_order);</a>
<a name="ln1248"> </a>
<a name="ln1249">    history = g_list_next(history);</a>
<a name="ln1250">  }</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253">void dt_ioppr_print_iop_order(GList *iop_order_list, const char *msg)</a>
<a name="ln1254">{</a>
<a name="ln1255">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln1256">  while(iops_order)</a>
<a name="ln1257">  {</a>
<a name="ln1258">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln1259"> </a>
<a name="ln1260">    fprintf(stderr, &quot;[%s] operation %s iop_order=%f\n&quot;, msg, order_entry-&gt;operation, order_entry-&gt;iop_order);</a>
<a name="ln1261"> </a>
<a name="ln1262">    iops_order = g_list_next(iops_order);</a>
<a name="ln1263">  }</a>
<a name="ln1264">}</a>
<a name="ln1265"> </a>
<a name="ln1266">static GList *_get_fence_modules_list(GList *iop_list)</a>
<a name="ln1267">{</a>
<a name="ln1268">  GList *fences = NULL;</a>
<a name="ln1269">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1270">  while(modules)</a>
<a name="ln1271">  {</a>
<a name="ln1272">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1273"> </a>
<a name="ln1274">    if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln1275">    {</a>
<a name="ln1276">      fences = g_list_append(fences, mod);</a>
<a name="ln1277">    }</a>
<a name="ln1278"> </a>
<a name="ln1279">    modules = g_list_next(modules);</a>
<a name="ln1280">  }</a>
<a name="ln1281">  return fences;</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284">static void _ioppr_check_rules(GList *iop_list, const int imgid, const char *msg)</a>
<a name="ln1285">{</a>
<a name="ln1286">  GList *modules = NULL;</a>
<a name="ln1287"> </a>
<a name="ln1288">  // check for IOP_FLAGS_FENCE on each module</a>
<a name="ln1289">  // create a list of fences modules</a>
<a name="ln1290">  GList *fences = _get_fence_modules_list(iop_list);</a>
<a name="ln1291"> </a>
<a name="ln1292">  // check if each module is between the fences</a>
<a name="ln1293">  modules = g_list_first(iop_list);</a>
<a name="ln1294">  while(modules)</a>
<a name="ln1295">  {</a>
<a name="ln1296">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1297">    if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1298">    {</a>
<a name="ln1299">      modules = g_list_next(modules);</a>
<a name="ln1300">      continue;</a>
<a name="ln1301">    }</a>
<a name="ln1302"> </a>
<a name="ln1303">    dt_iop_module_t *fence_prev = NULL;</a>
<a name="ln1304">    dt_iop_module_t *fence_next = NULL;</a>
<a name="ln1305"> </a>
<a name="ln1306">    GList *mod_fences = g_list_first(fences);</a>
<a name="ln1307">    while(mod_fences)</a>
<a name="ln1308">    {</a>
<a name="ln1309">      dt_iop_module_t *mod_fence = (dt_iop_module_t *)mod_fences-&gt;data;</a>
<a name="ln1310"> </a>
<a name="ln1311">      // mod should be before this fence</a>
<a name="ln1312">      if(mod-&gt;iop_order &lt; mod_fence-&gt;iop_order)</a>
<a name="ln1313">      {</a>
<a name="ln1314">        if(fence_next == NULL)</a>
<a name="ln1315">          fence_next = mod_fence;</a>
<a name="ln1316">        else if(mod_fence-&gt;iop_order &lt; fence_next-&gt;iop_order)</a>
<a name="ln1317">          fence_next = mod_fence;</a>
<a name="ln1318">      }</a>
<a name="ln1319">      // mod should be after this fence</a>
<a name="ln1320">      else if(mod-&gt;iop_order &gt; mod_fence-&gt;iop_order)</a>
<a name="ln1321">      {</a>
<a name="ln1322">        if(fence_prev == NULL)</a>
<a name="ln1323">          fence_prev = mod_fence;</a>
<a name="ln1324">        else if(mod_fence-&gt;iop_order &gt; fence_prev-&gt;iop_order)</a>
<a name="ln1325">          fence_prev = mod_fence;</a>
<a name="ln1326">      }</a>
<a name="ln1327"> </a>
<a name="ln1328">      mod_fences = g_list_next(mod_fences);</a>
<a name="ln1329">    }</a>
<a name="ln1330"> </a>
<a name="ln1331">    // now check if mod is between the fences</a>
<a name="ln1332">    if(fence_next &amp;&amp; mod-&gt;iop_order &gt; fence_next-&gt;iop_order)</a>
<a name="ln1333">    {</a>
<a name="ln1334">      fprintf(stderr, &quot;[_ioppr_check_rules] found fence %s %s module %s %s(%f) is after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1335">              fence_next-&gt;op, fence_next-&gt;multi_name, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, fence_next-&gt;op,</a>
<a name="ln1336">              fence_next-&gt;multi_name, fence_next-&gt;iop_order, imgid, msg);</a>
<a name="ln1337">    }</a>
<a name="ln1338">    if(fence_prev &amp;&amp; mod-&gt;iop_order &lt; fence_prev-&gt;iop_order)</a>
<a name="ln1339">    {</a>
<a name="ln1340">      fprintf(stderr, &quot;[_ioppr_check_rules] found fence %s %s module %s %s(%f) is before %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1341">              fence_prev-&gt;op, fence_prev-&gt;multi_name, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, fence_prev-&gt;op,</a>
<a name="ln1342">              fence_prev-&gt;multi_name, fence_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1343">    }</a>
<a name="ln1344"> </a>
<a name="ln1345"> </a>
<a name="ln1346">    modules = g_list_next(modules);</a>
<a name="ln1347">  }</a>
<a name="ln1348"> </a>
<a name="ln1349">  // for each module check if it doesn't break a rule</a>
<a name="ln1350">  modules = g_list_first(iop_list);</a>
<a name="ln1351">  while(modules)</a>
<a name="ln1352">  {</a>
<a name="ln1353">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1354">    if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1355">    {</a>
<a name="ln1356">      modules = g_list_next(modules);</a>
<a name="ln1357">      continue;</a>
<a name="ln1358">    }</a>
<a name="ln1359"> </a>
<a name="ln1360">    // we have a module, now check each rule</a>
<a name="ln1361">    GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln1362">    while(rules)</a>
<a name="ln1363">    {</a>
<a name="ln1364">      dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln1365"> </a>
<a name="ln1366">      // mod must be before rule-&gt;op_next</a>
<a name="ln1367">      if(strcmp(mod-&gt;op, rule-&gt;op_prev) == 0)</a>
<a name="ln1368">      {</a>
<a name="ln1369">        // check if there's a rule-&gt;op_next module before mod</a>
<a name="ln1370">        GList *modules_prev = g_list_previous(modules);</a>
<a name="ln1371">        while(modules_prev)</a>
<a name="ln1372">        {</a>
<a name="ln1373">          dt_iop_module_t *mod_prev = (dt_iop_module_t *)modules_prev-&gt;data;</a>
<a name="ln1374"> </a>
<a name="ln1375">          if(strcmp(mod_prev-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1376">          {</a>
<a name="ln1377">            fprintf(stderr, &quot;[_ioppr_check_rules] found rule %s %s module %s %s(%f) is after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1378">                    rule-&gt;op_prev, rule-&gt;op_next, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_prev-&gt;op,</a>
<a name="ln1379">                    mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1380">          }</a>
<a name="ln1381"> </a>
<a name="ln1382">          modules_prev = g_list_previous(modules_prev);</a>
<a name="ln1383">        }</a>
<a name="ln1384">      }</a>
<a name="ln1385">      // mod must be after rule-&gt;op_prev</a>
<a name="ln1386">      else if(strcmp(mod-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1387">      {</a>
<a name="ln1388">        // check if there's a rule-&gt;op_prev module after mod</a>
<a name="ln1389">        GList *modules_next = g_list_next(modules);</a>
<a name="ln1390">        while(modules_next)</a>
<a name="ln1391">        {</a>
<a name="ln1392">          dt_iop_module_t *mod_next = (dt_iop_module_t *)modules_next-&gt;data;</a>
<a name="ln1393"> </a>
<a name="ln1394">          if(strcmp(mod_next-&gt;op, rule-&gt;op_prev) == 0)</a>
<a name="ln1395">          {</a>
<a name="ln1396">            fprintf(stderr, &quot;[_ioppr_check_rules] found rule %s %s module %s %s(%f) is before %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1397">                    rule-&gt;op_prev, rule-&gt;op_next, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_next-&gt;op,</a>
<a name="ln1398">                    mod_next-&gt;multi_name, mod_next-&gt;iop_order, imgid, msg);</a>
<a name="ln1399">          }</a>
<a name="ln1400"> </a>
<a name="ln1401">          modules_next = g_list_next(modules_next);</a>
<a name="ln1402">        }</a>
<a name="ln1403">      }</a>
<a name="ln1404"> </a>
<a name="ln1405">      rules = g_list_next(rules);</a>
<a name="ln1406">    }</a>
<a name="ln1407"> </a>
<a name="ln1408">    modules = g_list_next(modules);</a>
<a name="ln1409">  }</a>
<a name="ln1410"> </a>
<a name="ln1411">  if(fences) g_list_free(fences);</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414">int dt_ioppr_check_iop_order(dt_develop_t *dev, const int imgid, const char *msg)</a>
<a name="ln1415">{</a>
<a name="ln1416">  int iop_order_ok = 1;</a>
<a name="ln1417"> </a>
<a name="ln1418">  // check if gamma is the last iop</a>
<a name="ln1419">  {</a>
<a name="ln1420">    GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1421">    while(modules)</a>
<a name="ln1422">    {</a>
<a name="ln1423">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1424">      if(mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln1425">        break;</a>
<a name="ln1426"> </a>
<a name="ln1427">      modules = g_list_previous(dev-&gt;iop);</a>
<a name="ln1428">    }</a>
<a name="ln1429">    if(modules)</a>
<a name="ln1430">    {</a>
<a name="ln1431">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1432"> </a>
<a name="ln1433">      if(strcmp(mod-&gt;op, &quot;gamma&quot;) != 0)</a>
<a name="ln1434">      {</a>
<a name="ln1435">        iop_order_ok = 0;</a>
<a name="ln1436">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] gamma is not the last iop, last is %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1437">                mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1438">      }</a>
<a name="ln1439">    }</a>
<a name="ln1440">    else</a>
<a name="ln1441">    {</a>
<a name="ln1442">      // fprintf(stderr, &quot;[dt_ioppr_check_iop_order] dev-&gt;iop is empty image %i (%s)\n&quot;,imgid, msg);</a>
<a name="ln1443">    }</a>
<a name="ln1444">  }</a>
<a name="ln1445"> </a>
<a name="ln1446">  // some other chacks</a>
<a name="ln1447">  {</a>
<a name="ln1448">    GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1449">    while(modules)</a>
<a name="ln1450">    {</a>
<a name="ln1451">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1452">      if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1453">      {</a>
<a name="ln1454">        if(mod-&gt;enabled)</a>
<a name="ln1455">        {</a>
<a name="ln1456">          iop_order_ok = 0;</a>
<a name="ln1457">          fprintf(stderr, &quot;[dt_ioppr_check_iop_order] module not used but enabled!! %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1458">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1459">        }</a>
<a name="ln1460">        if(mod-&gt;multi_priority == 0)</a>
<a name="ln1461">        {</a>
<a name="ln1462">          iop_order_ok = 0;</a>
<a name="ln1463">          fprintf(stderr, &quot;[dt_ioppr_check_iop_order] base module set as not used %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1464">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1465">        }</a>
<a name="ln1466">      }</a>
<a name="ln1467"> </a>
<a name="ln1468">      modules = g_list_previous(dev-&gt;iop);</a>
<a name="ln1469">    }</a>
<a name="ln1470">  }</a>
<a name="ln1471"> </a>
<a name="ln1472">  // check if there's duplicate or out-of-order iop_order</a>
<a name="ln1473">  {</a>
<a name="ln1474">    dt_iop_module_t *mod_prev = NULL;</a>
<a name="ln1475">    GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln1476">    while(modules)</a>
<a name="ln1477">    {</a>
<a name="ln1478">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1479">      if(mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln1480">      {</a>
<a name="ln1481">        if(mod_prev)</a>
<a name="ln1482">        {</a>
<a name="ln1483">          if(mod-&gt;iop_order &lt; mod_prev-&gt;iop_order)</a>
<a name="ln1484">          {</a>
<a name="ln1485">            iop_order_ok = 0;</a>
<a name="ln1486">            fprintf(stderr,</a>
<a name="ln1487">                    &quot;[dt_ioppr_check_iop_order] module %s %s(%f) should be after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1488">                    mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_prev-&gt;op, mod_prev-&gt;multi_name,</a>
<a name="ln1489">                    mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1490">          }</a>
<a name="ln1491">          else if(mod-&gt;iop_order == mod_prev-&gt;iop_order)</a>
<a name="ln1492">          {</a>
<a name="ln1493">            iop_order_ok = 0;</a>
<a name="ln1494">            fprintf(</a>
<a name="ln1495">                stderr,</a>
<a name="ln1496">                &quot;[dt_ioppr_check_iop_order] module %s %s(%i)(%f) and %s %s(%i)(%f) have the same order image %i (%s)\n&quot;,</a>
<a name="ln1497">                mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod-&gt;iop_order, mod_prev-&gt;op,</a>
<a name="ln1498">                mod_prev-&gt;multi_name, mod_prev-&gt;multi_priority, mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1499">          }</a>
<a name="ln1500">        }</a>
<a name="ln1501">      }</a>
<a name="ln1502">      mod_prev = mod;</a>
<a name="ln1503">      modules = g_list_next(modules);</a>
<a name="ln1504">    }</a>
<a name="ln1505">  }</a>
<a name="ln1506"> </a>
<a name="ln1507">  _ioppr_check_rules(dev-&gt;iop, imgid, msg);</a>
<a name="ln1508"> </a>
<a name="ln1509">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln1510">  while(history)</a>
<a name="ln1511">  {</a>
<a name="ln1512">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln1513"> </a>
<a name="ln1514">    if(hist-&gt;iop_order == DBL_MAX)</a>
<a name="ln1515">    {</a>
<a name="ln1516">      if(hist-&gt;enabled)</a>
<a name="ln1517">      {</a>
<a name="ln1518">        iop_order_ok = 0;</a>
<a name="ln1519">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] history module not used but enabled!! %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1520">            hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;iop_order,imgid, msg);</a>
<a name="ln1521">      }</a>
<a name="ln1522">      if(hist-&gt;multi_priority == 0)</a>
<a name="ln1523">      {</a>
<a name="ln1524">        iop_order_ok = 0;</a>
<a name="ln1525">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] history base module set as not used %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1526">            hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;iop_order,imgid, msg);</a>
<a name="ln1527">      }</a>
<a name="ln1528">    }</a>
<a name="ln1529"> </a>
<a name="ln1530">    history = g_list_next(history);</a>
<a name="ln1531">  }</a>
<a name="ln1532"> </a>
<a name="ln1533">  return iop_order_ok;</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">//---------------------------------------------------------</a>
<a name="ln1537">// colorspace transforms</a>
<a name="ln1538">//---------------------------------------------------------</a>
<a name="ln1539"> </a>
<a name="ln1540">static void _transform_from_to_rgb_lab_lcms2(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1541">                                             const int height, const dt_colorspaces_color_profile_type_t type,</a>
<a name="ln1542">                                             const char *filename, const int intent, const int direction)</a>
<a name="ln1543">{</a>
<a name="ln1544">  const int ch = 4;</a>
<a name="ln1545">  cmsHTRANSFORM *xform = NULL;</a>
<a name="ln1546">  cmsHPROFILE *rgb_profile = NULL;</a>
<a name="ln1547">  cmsHPROFILE *lab_profile = NULL;</a>
<a name="ln1548"> </a>
<a name="ln1549">  if(type != DT_COLORSPACE_NONE)</a>
<a name="ln1550">  {</a>
<a name="ln1551">    const dt_colorspaces_color_profile_t *profile = dt_colorspaces_get_profile(type, filename, DT_PROFILE_DIRECTION_WORK);</a>
<a name="ln1552">    if(profile) rgb_profile = profile-&gt;profile;</a>
<a name="ln1553">  }</a>
<a name="ln1554">  else</a>
<a name="ln1555">    rgb_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LIN_REC2020, &quot;&quot;, DT_PROFILE_DIRECTION_WORK)-&gt;profile;</a>
<a name="ln1556">  if(rgb_profile)</a>
<a name="ln1557">  {</a>
<a name="ln1558">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(rgb_profile);</a>
<a name="ln1559">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1560">    {</a>
<a name="ln1561">        fprintf(stderr, &quot;working profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1562">                (char)(rgb_color_space&gt;&gt;24),</a>
<a name="ln1563">                (char)(rgb_color_space&gt;&gt;16),</a>
<a name="ln1564">                (char)(rgb_color_space&gt;&gt;8),</a>
<a name="ln1565">                (char)(rgb_color_space));</a>
<a name="ln1566">        rgb_profile = NULL;</a>
<a name="ln1567">    }</a>
<a name="ln1568">  }</a>
<a name="ln1569">  if(rgb_profile == NULL)</a>
<a name="ln1570">  {</a>
<a name="ln1571">    rgb_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LIN_REC2020, &quot;&quot;, DT_PROFILE_DIRECTION_WORK)-&gt;profile;</a>
<a name="ln1572">    fprintf(stderr, _(&quot;unsupported working profile %s has been replaced by Rec2020 RGB!\n&quot;), filename);</a>
<a name="ln1573">  }</a>
<a name="ln1574"> </a>
<a name="ln1575">  lab_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln1576"> </a>
<a name="ln1577">  cmsHPROFILE *input_profile = NULL;</a>
<a name="ln1578">  cmsHPROFILE *output_profile = NULL;</a>
<a name="ln1579">  cmsUInt32Number input_format = TYPE_RGBA_FLT;</a>
<a name="ln1580">  cmsUInt32Number output_format = TYPE_LabA_FLT;</a>
<a name="ln1581"> </a>
<a name="ln1582">  if(direction == 1) // rgb --&gt; lab</a>
<a name="ln1583">  {</a>
<a name="ln1584">    input_profile = rgb_profile;</a>
<a name="ln1585">    input_format = TYPE_RGBA_FLT;</a>
<a name="ln1586">    output_profile = lab_profile;</a>
<a name="ln1587">    output_format = TYPE_LabA_FLT;</a>
<a name="ln1588">  }</a>
<a name="ln1589">  else // lab --&gt;rgb</a>
<a name="ln1590">  {</a>
<a name="ln1591">    input_profile = lab_profile;</a>
<a name="ln1592">    input_format = TYPE_LabA_FLT;</a>
<a name="ln1593">    output_profile = rgb_profile;</a>
<a name="ln1594">    output_format = TYPE_RGBA_FLT;</a>
<a name="ln1595">  }</a>
<a name="ln1596"> </a>
<a name="ln1597">  xform = cmsCreateTransform(input_profile, input_format, output_profile, output_format, intent, 0);</a>
<a name="ln1598">  if(xform)</a>
<a name="ln1599">  {</a>
<a name="ln1600">#ifdef _OPENMP</a>
<a name="ln1601">#pragma omp parallel for default(none) \</a>
<a name="ln1602">    dt_omp_firstprivate(image_in, image_out, width, height, ch) \</a>
<a name="ln1603">    shared(xform) \</a>
<a name="ln1604">    schedule(static)</a>
<a name="ln1605">#endif</a>
<a name="ln1606">    for(int y = 0; y &lt; height; y++)</a>
<a name="ln1607">    {</a>
<a name="ln1608">      const float *const in = image_in + y * width * ch;</a>
<a name="ln1609">      float *const out = image_out + y * width * ch;</a>
<a name="ln1610"> </a>
<a name="ln1611">      cmsDoTransform(xform, in, out, width);</a>
<a name="ln1612">    }</a>
<a name="ln1613">  }</a>
<a name="ln1614">  else</a>
<a name="ln1615">    fprintf(stderr, &quot;[_transform_from_to_rgb_lab_lcms2] cannot create transform\n&quot;);</a>
<a name="ln1616"> </a>
<a name="ln1617">  if(xform) cmsDeleteTransform(xform);</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">static void _transform_rgb_to_rgb_lcms2(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1621">                                        const int height, const dt_colorspaces_color_profile_type_t type_from,</a>
<a name="ln1622">                                        const char *filename_from,</a>
<a name="ln1623">                                        const dt_colorspaces_color_profile_type_t type_to, const char *filename_to,</a>
<a name="ln1624">                                        const int intent)</a>
<a name="ln1625">{</a>
<a name="ln1626">  const int ch = 4;</a>
<a name="ln1627">  cmsHTRANSFORM *xform = NULL;</a>
<a name="ln1628">  cmsHPROFILE *from_rgb_profile = NULL;</a>
<a name="ln1629">  cmsHPROFILE *to_rgb_profile = NULL;</a>
<a name="ln1630"> </a>
<a name="ln1631">  if(type_from == DT_COLORSPACE_DISPLAY || type_to == DT_COLORSPACE_DISPLAY || type_from == DT_COLORSPACE_DISPLAY2</a>
<a name="ln1632">     || type_to == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1633">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1634"> </a>
<a name="ln1635">  if(type_from != DT_COLORSPACE_NONE)</a>
<a name="ln1636">  {</a>
<a name="ln1637">    const dt_colorspaces_color_profile_t *profile_from</a>
<a name="ln1638">        = dt_colorspaces_get_profile(type_from, filename_from, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1639">    if(profile_from) from_rgb_profile = profile_from-&gt;profile;</a>
<a name="ln1640">  }</a>
<a name="ln1641">  else</a>
<a name="ln1642">  {</a>
<a name="ln1643">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] invalid from profile\n&quot;);</a>
<a name="ln1644">  }</a>
<a name="ln1645"> </a>
<a name="ln1646">  if(type_to != DT_COLORSPACE_NONE)</a>
<a name="ln1647">  {</a>
<a name="ln1648">    const dt_colorspaces_color_profile_t *profile_to</a>
<a name="ln1649">        = dt_colorspaces_get_profile(type_to, filename_to, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1650">    if(profile_to) to_rgb_profile = profile_to-&gt;profile;</a>
<a name="ln1651">  }</a>
<a name="ln1652">  else</a>
<a name="ln1653">  {</a>
<a name="ln1654">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] invalid to profile\n&quot;);</a>
<a name="ln1655">  }</a>
<a name="ln1656"> </a>
<a name="ln1657">  if(from_rgb_profile)</a>
<a name="ln1658">  {</a>
<a name="ln1659">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(from_rgb_profile);</a>
<a name="ln1660">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1661">    {</a>
<a name="ln1662">      fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1663">              (char)(rgb_color_space &gt;&gt; 24), (char)(rgb_color_space &gt;&gt; 16), (char)(rgb_color_space &gt;&gt; 8),</a>
<a name="ln1664">              (char)(rgb_color_space));</a>
<a name="ln1665">      from_rgb_profile = NULL;</a>
<a name="ln1666">    }</a>
<a name="ln1667">  }</a>
<a name="ln1668">  if(to_rgb_profile)</a>
<a name="ln1669">  {</a>
<a name="ln1670">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(to_rgb_profile);</a>
<a name="ln1671">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1672">    {</a>
<a name="ln1673">      fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1674">              (char)(rgb_color_space &gt;&gt; 24), (char)(rgb_color_space &gt;&gt; 16), (char)(rgb_color_space &gt;&gt; 8),</a>
<a name="ln1675">              (char)(rgb_color_space));</a>
<a name="ln1676">      to_rgb_profile = NULL;</a>
<a name="ln1677">    }</a>
<a name="ln1678">  }</a>
<a name="ln1679"> </a>
<a name="ln1680">  cmsHPROFILE *input_profile = NULL;</a>
<a name="ln1681">  cmsHPROFILE *output_profile = NULL;</a>
<a name="ln1682">  cmsUInt32Number input_format = TYPE_RGBA_FLT;</a>
<a name="ln1683">  cmsUInt32Number output_format = TYPE_RGBA_FLT;</a>
<a name="ln1684"> </a>
<a name="ln1685">  input_profile = from_rgb_profile;</a>
<a name="ln1686">  input_format = TYPE_RGBA_FLT;</a>
<a name="ln1687">  output_profile = to_rgb_profile;</a>
<a name="ln1688">  output_format = TYPE_RGBA_FLT;</a>
<a name="ln1689"> </a>
<a name="ln1690">  if(input_profile &amp;&amp; output_profile)</a>
<a name="ln1691">    xform = cmsCreateTransform(input_profile, input_format, output_profile, output_format, intent, 0);</a>
<a name="ln1692"> </a>
<a name="ln1693">  if(type_from == DT_COLORSPACE_DISPLAY || type_to == DT_COLORSPACE_DISPLAY || type_from == DT_COLORSPACE_DISPLAY2</a>
<a name="ln1694">     || type_to == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln1695">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1696"> </a>
<a name="ln1697">  if(xform)</a>
<a name="ln1698">  {</a>
<a name="ln1699">#ifdef _OPENMP</a>
<a name="ln1700">#pragma omp parallel for default(none) \</a>
<a name="ln1701">    dt_omp_firstprivate(image_in, image_out, width, height, ch) \</a>
<a name="ln1702">    shared(xform) \</a>
<a name="ln1703">    schedule(static)</a>
<a name="ln1704">#endif</a>
<a name="ln1705">    for(int y = 0; y &lt; height; y++)</a>
<a name="ln1706">    {</a>
<a name="ln1707">      const float *const in = image_in + y * width * ch;</a>
<a name="ln1708">      float *const out = image_out + y * width * ch;</a>
<a name="ln1709"> </a>
<a name="ln1710">      cmsDoTransform(xform, in, out, width);</a>
<a name="ln1711">    }</a>
<a name="ln1712">  }</a>
<a name="ln1713">  else</a>
<a name="ln1714">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] cannot create transform\n&quot;);</a>
<a name="ln1715"> </a>
<a name="ln1716">  if(xform) cmsDeleteTransform(xform);</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">static void _transform_lcms2(struct dt_iop_module_t *self, const float *const image_in, float *const image_out,</a>
<a name="ln1720">                             const int width, const int height, const int cst_from, const int cst_to,</a>
<a name="ln1721">                             int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1722">{</a>
<a name="ln1723">  if(cst_from == cst_to)</a>
<a name="ln1724">  {</a>
<a name="ln1725">    *converted_cst = cst_to;</a>
<a name="ln1726">    return;</a>
<a name="ln1727">  }</a>
<a name="ln1728"> </a>
<a name="ln1729">  *converted_cst = cst_to;</a>
<a name="ln1730"> </a>
<a name="ln1731">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln1732">  {</a>
<a name="ln1733">    printf(&quot;[_transform_lcms2] transfoming from RGB to Lab (%s %s)\n&quot;, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln1734">    _transform_from_to_rgb_lab_lcms2(image_in, image_out, width, height, profile_info-&gt;type,</a>
<a name="ln1735">                                     profile_info-&gt;filename, profile_info-&gt;intent, 1);</a>
<a name="ln1736">  }</a>
<a name="ln1737">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln1738">  {</a>
<a name="ln1739">    printf(&quot;[_transform_lcms2] transfoming from Lab to RGB (%s %s)\n&quot;, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln1740">    _transform_from_to_rgb_lab_lcms2(image_in, image_out, width, height, profile_info-&gt;type,</a>
<a name="ln1741">                                     profile_info-&gt;filename, profile_info-&gt;intent, -1);</a>
<a name="ln1742">  }</a>
<a name="ln1743">  else</a>
<a name="ln1744">  {</a>
<a name="ln1745">    *converted_cst = cst_from;</a>
<a name="ln1746">    fprintf(stderr, &quot;[_transform_lcms2] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln1747">  }</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">static inline void _transform_lcms2_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1751">                                        const int height,</a>
<a name="ln1752">                                        const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln1753">                                        const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln1754">{</a>
<a name="ln1755">  _transform_rgb_to_rgb_lcms2(image_in, image_out, width, height, profile_info_from-&gt;type,</a>
<a name="ln1756">                              profile_info_from-&gt;filename, profile_info_to-&gt;type, profile_info_to-&gt;filename,</a>
<a name="ln1757">                              profile_info_to-&gt;intent);</a>
<a name="ln1758">}</a>
<a name="ln1759"> </a>
<a name="ln1760"> </a>
<a name="ln1761">#ifdef _OPENMP</a>
<a name="ln1762">#pragma omp declare simd</a>
<a name="ln1763">#endif</a>
<a name="ln1764">__DT_CLONE_TARGETS__</a>
<a name="ln1765">static inline float lerp_lut(const float *const lut, const float v, const int lutsize)</a>
<a name="ln1766">{</a>
<a name="ln1767">  // TODO: check if optimization is worthwhile!</a>
<a name="ln1768">  const float ft = CLAMPS(v * (lutsize - 1), 0, lutsize - 1);</a>
<a name="ln1769">  const int t = ft &lt; lutsize - 2 ? ft : lutsize - 2;</a>
<a name="ln1770">  const float f = ft - t;</a>
<a name="ln1771">  const float l1 = lut[t];</a>
<a name="ln1772">  const float l2 = lut[t + 1];</a>
<a name="ln1773">  return l1 * (1.0f - f) + l2 * f;</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776"> </a>
<a name="ln1777">#ifdef _OPENMP</a>
<a name="ln1778">#pragma omp declare simd</a>
<a name="ln1779">#endif</a>
<a name="ln1780">__DT_CLONE_TARGETS__</a>
<a name="ln1781">static inline void _apply_trc_in(const float *const restrict rgb_in, float *const restrict rgb_out, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1782">{</a>
<a name="ln1783">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1784">  {</a>
<a name="ln1785">    rgb_out[c] = (profile_info-&gt;lut_in[c][0] &gt;= 0.0f) ? ((rgb_in[c] &lt; 1.0f) ? lerp_lut(profile_info-&gt;lut_in[c], rgb_in[c], profile_info-&gt;lutsize)</a>
<a name="ln1786">                                                        : dt_iop_eval_exp(profile_info-&gt;unbounded_coeffs_in[c], rgb_in[c]))</a>
<a name="ln1787">                                                        : rgb_in[c];</a>
<a name="ln1788">  }</a>
<a name="ln1789">}</a>
<a name="ln1790"> </a>
<a name="ln1791">static inline void _apply_trc_out(const float *const rgb_in, float *rgb_out, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1792">{</a>
<a name="ln1793">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1794">  {</a>
<a name="ln1795">    rgb_out[c] = (profile_info-&gt;lut_out[c][0] &gt;= 0.0f) ? ((rgb_in[c] &lt; 1.0f) ? lerp_lut(profile_info-&gt;lut_out[c], rgb_in[c], profile_info-&gt;lutsize)</a>
<a name="ln1796">                                                        : dt_iop_eval_exp(profile_info-&gt;unbounded_coeffs_out[c], rgb_in[c]))</a>
<a name="ln1797">                                                        : rgb_in[c];</a>
<a name="ln1798">  }</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">static void _ioppr_linear_rgb_matrix_to_xyz(const float *const rgb, float *xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1802">{</a>
<a name="ln1803">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1804">  {</a>
<a name="ln1805">    xyz[c] = 0.0f;</a>
<a name="ln1806">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1807">    {</a>
<a name="ln1808">      xyz[c] += profile_info-&gt;matrix_in[3 * c + i] * rgb[i];</a>
<a name="ln1809">    }</a>
<a name="ln1810">  }</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">static void _ioppr_xyz_to_linear_rgb_matrix(const float *const xyz, float *rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1814">{</a>
<a name="ln1815">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1816">  {</a>
<a name="ln1817">    rgb[c] = 0.0f;</a>
<a name="ln1818">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1819">    {</a>
<a name="ln1820">      rgb[c] += profile_info-&gt;matrix_out[3 * c + i] * xyz[i];</a>
<a name="ln1821">    }</a>
<a name="ln1822">  }</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825">static void _apply_tonecurves(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1826">                              const int height, const float *const lutr, const float *const lutg,</a>
<a name="ln1827">                              const float *const lutb, const float *const unbounded_coeffsr,</a>
<a name="ln1828">                              const float *const unbounded_coeffsg, const float *const unbounded_coeffsb,</a>
<a name="ln1829">                              const int lutsize)</a>
<a name="ln1830">{</a>
<a name="ln1831">  const int ch = 4;</a>
<a name="ln1832">  const float *const lut[3] = { lutr, lutg, lutb };</a>
<a name="ln1833">  const float *const unbounded_coeffs[3] = { unbounded_coeffsr, unbounded_coeffsg, unbounded_coeffsb };</a>
<a name="ln1834">  const size_t stride = (size_t)ch * width * height;</a>
<a name="ln1835"> </a>
<a name="ln1836">  // do we have any lut to apply, or is this a linear profile?</a>
<a name="ln1837">  if((lut[0][0] &gt;= 0.0f) &amp;&amp; (lut[1][0] &gt;= 0.0f) &amp;&amp; (lut[2][0] &gt;= 0.0f))</a>
<a name="ln1838">  {</a>
<a name="ln1839">#ifdef _OPENMP</a>
<a name="ln1840">#pragma omp parallel for default(none) \</a>
<a name="ln1841">    dt_omp_firstprivate(stride, image_in, image_out, lut, lutsize, unbounded_coeffs, ch) \</a>
<a name="ln1842">    schedule(static)</a>
<a name="ln1843">#endif</a>
<a name="ln1844">    for(size_t k = 0; k &lt; stride; k += ch)</a>
<a name="ln1845">    {</a>
<a name="ln1846">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1847">      {</a>
<a name="ln1848">        image_out[k + c] = (image_in[k + c] &lt; 1.0f) ? lerp_lut(lut[c], image_in[k + c], lutsize)</a>
<a name="ln1849">                                                    : dt_iop_eval_exp(unbounded_coeffs[c], image_in[k + c]);</a>
<a name="ln1850">      }</a>
<a name="ln1851">    }</a>
<a name="ln1852">  }</a>
<a name="ln1853">  else if((lut[0][0] &gt;= 0.0f) || (lut[1][0] &gt;= 0.0f) || (lut[2][0] &gt;= 0.0f))</a>
<a name="ln1854">  {</a>
<a name="ln1855">#ifdef _OPENMP</a>
<a name="ln1856">#pragma omp parallel for default(none) \</a>
<a name="ln1857">    dt_omp_firstprivate(stride, image_in, image_out, lut, lutsize, unbounded_coeffs, ch) \</a>
<a name="ln1858">    schedule(static)</a>
<a name="ln1859">#endif</a>
<a name="ln1860">    for(size_t k = 0; k &lt; stride; k += ch)</a>
<a name="ln1861">    {</a>
<a name="ln1862">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1863">      {</a>
<a name="ln1864">        if(lut[c][0] &gt;= 0.0f)</a>
<a name="ln1865">        {</a>
<a name="ln1866">          image_out[k + c] = (image_in[k + c] &lt; 1.0f) ? lerp_lut(lut[c], image_in[k + c], lutsize)</a>
<a name="ln1867">                                                      : dt_iop_eval_exp(unbounded_coeffs[c], image_in[k + c]);</a>
<a name="ln1868">        }</a>
<a name="ln1869">      }</a>
<a name="ln1870">    }</a>
<a name="ln1871">  }</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">static void _transform_rgb_to_lab_matrix(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1875">                                         const int height,</a>
<a name="ln1876">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1877">{</a>
<a name="ln1878">  const int ch = 4;</a>
<a name="ln1879">  const size_t stride = (size_t)(width * height);</a>
<a name="ln1880"> </a>
<a name="ln1881">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln1882">  {</a>
<a name="ln1883">    _apply_tonecurves(image_in, image_out, width, height, profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1],</a>
<a name="ln1884">                      profile_info-&gt;lut_in[2], profile_info-&gt;unbounded_coeffs_in[0],</a>
<a name="ln1885">                      profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2],</a>
<a name="ln1886">                      profile_info-&gt;lutsize);</a>
<a name="ln1887"> </a>
<a name="ln1888">#ifdef _OPENMP</a>
<a name="ln1889">#pragma omp parallel for default(none) \</a>
<a name="ln1890">    dt_omp_firstprivate(image_out, profile_info, stride, ch) \</a>
<a name="ln1891">    schedule(static)</a>
<a name="ln1892">#endif</a>
<a name="ln1893">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1894">    {</a>
<a name="ln1895">      float *const in = image_out + y * ch;</a>
<a name="ln1896"> </a>
<a name="ln1897">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1898"> </a>
<a name="ln1899">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info);</a>
<a name="ln1900">      dt_XYZ_to_Lab(xyz, in);</a>
<a name="ln1901">    }</a>
<a name="ln1902">  }</a>
<a name="ln1903">  else</a>
<a name="ln1904">  {</a>
<a name="ln1905">#ifdef _OPENMP</a>
<a name="ln1906">#pragma omp parallel for default(none) \</a>
<a name="ln1907">    dt_omp_firstprivate(image_in, image_out, profile_info, stride, ch) \</a>
<a name="ln1908">    schedule(static)</a>
<a name="ln1909">#endif</a>
<a name="ln1910">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1911">    {</a>
<a name="ln1912">      const float *const in = image_in + y * ch;</a>
<a name="ln1913">      float *const out = image_out + y * ch;</a>
<a name="ln1914"> </a>
<a name="ln1915">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1916"> </a>
<a name="ln1917">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info);</a>
<a name="ln1918">      dt_XYZ_to_Lab(xyz, out);</a>
<a name="ln1919">    }</a>
<a name="ln1920">  }</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">static void _transform_lab_to_rgb_matrix(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1924">                                         const int height,</a>
<a name="ln1925">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1926">{</a>
<a name="ln1927">  const int ch = 4;</a>
<a name="ln1928">  const size_t stride = (size_t)width * height;</a>
<a name="ln1929"> </a>
<a name="ln1930">#ifdef _OPENMP</a>
<a name="ln1931">#pragma omp parallel for default(none) \</a>
<a name="ln1932">  dt_omp_firstprivate(image_in, image_out, stride, profile_info, ch) \</a>
<a name="ln1933">  schedule(static)</a>
<a name="ln1934">#endif</a>
<a name="ln1935">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1936">  {</a>
<a name="ln1937">    const float *const in = image_in + y * ch;</a>
<a name="ln1938">    float *const out = image_out + y * ch;</a>
<a name="ln1939"> </a>
<a name="ln1940">    float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1941"> </a>
<a name="ln1942">    dt_Lab_to_XYZ(in, xyz);</a>
<a name="ln1943">    _ioppr_xyz_to_linear_rgb_matrix(xyz, out, profile_info);</a>
<a name="ln1944">  }</a>
<a name="ln1945"> </a>
<a name="ln1946">  _apply_tonecurves(image_out, image_out, width, height, profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1],</a>
<a name="ln1947">                    profile_info-&gt;lut_out[2], profile_info-&gt;unbounded_coeffs_out[0],</a>
<a name="ln1948">                    profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2],</a>
<a name="ln1949">                    profile_info-&gt;lutsize);</a>
<a name="ln1950">}</a>
<a name="ln1951"> </a>
<a name="ln1952">static void _transform_matrix_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1953">                                  const int height, const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln1954">                                  const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln1955">{</a>
<a name="ln1956">  const int ch = 4;</a>
<a name="ln1957">  const size_t stride = (size_t)(width * height);</a>
<a name="ln1958"> </a>
<a name="ln1959">  if(profile_info_from-&gt;nonlinearlut)</a>
<a name="ln1960">  {</a>
<a name="ln1961">    _apply_tonecurves(image_in, image_out, width, height, profile_info_from-&gt;lut_in[0],</a>
<a name="ln1962">                      profile_info_from-&gt;lut_in[1], profile_info_from-&gt;lut_in[2],</a>
<a name="ln1963">                      profile_info_from-&gt;unbounded_coeffs_in[0], profile_info_from-&gt;unbounded_coeffs_in[1],</a>
<a name="ln1964">                      profile_info_from-&gt;unbounded_coeffs_in[2], profile_info_from-&gt;lutsize);</a>
<a name="ln1965"> </a>
<a name="ln1966">#ifdef _OPENMP</a>
<a name="ln1967">#pragma omp parallel for default(none) \</a>
<a name="ln1968">    dt_omp_firstprivate(stride, image_out, profile_info_from, profile_info_to, ch) \</a>
<a name="ln1969">    schedule(static)</a>
<a name="ln1970">#endif</a>
<a name="ln1971">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1972">    {</a>
<a name="ln1973">      float *const in = image_out + y * ch;</a>
<a name="ln1974"> </a>
<a name="ln1975">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1976"> </a>
<a name="ln1977">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info_from);</a>
<a name="ln1978">      _ioppr_xyz_to_linear_rgb_matrix(xyz, in, profile_info_to);</a>
<a name="ln1979">    }</a>
<a name="ln1980">  }</a>
<a name="ln1981">  else</a>
<a name="ln1982">  {</a>
<a name="ln1983">#ifdef _OPENMP</a>
<a name="ln1984">#pragma omp parallel for default(none) \</a>
<a name="ln1985">    dt_omp_firstprivate(stride, image_in, image_out, profile_info_from, profile_info_to, ch) \</a>
<a name="ln1986">    schedule(static)</a>
<a name="ln1987">#endif</a>
<a name="ln1988">    for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1989">    {</a>
<a name="ln1990">      const float *const in = image_in + y * ch;</a>
<a name="ln1991">      float *const out = image_out + y * ch;</a>
<a name="ln1992"> </a>
<a name="ln1993">      float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1994"> </a>
<a name="ln1995">      _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info_from);</a>
<a name="ln1996">      _ioppr_xyz_to_linear_rgb_matrix(xyz, out, profile_info_to);</a>
<a name="ln1997">    }</a>
<a name="ln1998">  }</a>
<a name="ln1999"> </a>
<a name="ln2000">  _apply_tonecurves(image_out, image_out, width, height, profile_info_to-&gt;lut_out[0], profile_info_to-&gt;lut_out[1],</a>
<a name="ln2001">                    profile_info_to-&gt;lut_out[2], profile_info_to-&gt;unbounded_coeffs_out[0],</a>
<a name="ln2002">                    profile_info_to-&gt;unbounded_coeffs_out[1], profile_info_to-&gt;unbounded_coeffs_out[2],</a>
<a name="ln2003">                    profile_info_to-&gt;lutsize);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">static int _init_unbounded_coeffs(float *lutr, float *lutg, float *lutb,</a>
<a name="ln2007">    float *unbounded_coeffsr, float *unbounded_coeffsg, float *unbounded_coeffsb, const int lutsize)</a>
<a name="ln2008">{</a>
<a name="ln2009">  int nonlinearlut = 0;</a>
<a name="ln2010">  float *lut[3] = { lutr, lutg, lutb };</a>
<a name="ln2011">  float *unbounded_coeffs[3] = { unbounded_coeffsr, unbounded_coeffsg, unbounded_coeffsb };</a>
<a name="ln2012"> </a>
<a name="ln2013">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln2014">  {</a>
<a name="ln2015">    // omit luts marked as linear (negative as marker)</a>
<a name="ln2016">    if(lut[k][0] &gt;= 0.0f)</a>
<a name="ln2017">    {</a>
<a name="ln2018">      const float x[4] = { 0.7f, 0.8f, 0.9f, 1.0f };</a>
<a name="ln2019">      const float y[4] = { lerp_lut(lut[k], x[0], lutsize), lerp_lut(lut[k], x[1], lutsize), lerp_lut(lut[k], x[2], lutsize),</a>
<a name="ln2020">                           lerp_lut(lut[k], x[3], lutsize) };</a>
<a name="ln2021">      dt_iop_estimate_exp(x, y, 4, unbounded_coeffs[k]);</a>
<a name="ln2022"> </a>
<a name="ln2023">      nonlinearlut++;</a>
<a name="ln2024">    }</a>
<a name="ln2025">    else</a>
<a name="ln2026">      unbounded_coeffs[k][0] = -1.0f;</a>
<a name="ln2027">  }</a>
<a name="ln2028"> </a>
<a name="ln2029">  return nonlinearlut;</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032">static void _transform_matrix(struct dt_iop_module_t *self, const float *const image_in, float *const image_out,</a>
<a name="ln2033">                              const int width, const int height, const int cst_from, const int cst_to,</a>
<a name="ln2034">                              int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2035">{</a>
<a name="ln2036">  if(cst_from == cst_to)</a>
<a name="ln2037">  {</a>
<a name="ln2038">    *converted_cst = cst_to;</a>
<a name="ln2039">    return;</a>
<a name="ln2040">  }</a>
<a name="ln2041"> </a>
<a name="ln2042">  *converted_cst = cst_to;</a>
<a name="ln2043"> </a>
<a name="ln2044">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2045">  {</a>
<a name="ln2046">    _transform_rgb_to_lab_matrix(image_in, image_out, width, height, profile_info);</a>
<a name="ln2047">  }</a>
<a name="ln2048">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2049">  {</a>
<a name="ln2050">    _transform_lab_to_rgb_matrix(image_in, image_out, width, height, profile_info);</a>
<a name="ln2051">  }</a>
<a name="ln2052">  else</a>
<a name="ln2053">  {</a>
<a name="ln2054">    *converted_cst = cst_from;</a>
<a name="ln2055">    fprintf(stderr, &quot;[_transform_matrix] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2056">  }</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">#define DT_IOPPR_LUT_SAMPLES 0x10000</a>
<a name="ln2060"> </a>
<a name="ln2061">void dt_ioppr_init_profile_info(dt_iop_order_iccprofile_info_t *profile_info, const int lutsize)</a>
<a name="ln2062">{</a>
<a name="ln2063">  profile_info-&gt;type = DT_COLORSPACE_NONE;</a>
<a name="ln2064">  profile_info-&gt;filename[0] = '\0';</a>
<a name="ln2065">  profile_info-&gt;intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln2066">  profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln2067">  profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln2068">  profile_info-&gt;unbounded_coeffs_in[0][0] = profile_info-&gt;unbounded_coeffs_in[1][0] = profile_info-&gt;unbounded_coeffs_in[2][0] = -1.0f;</a>
<a name="ln2069">  profile_info-&gt;unbounded_coeffs_out[0][0] = profile_info-&gt;unbounded_coeffs_out[1][0] = profile_info-&gt;unbounded_coeffs_out[2][0] = -1.0f;</a>
<a name="ln2070">  profile_info-&gt;nonlinearlut = 0;</a>
<a name="ln2071">  profile_info-&gt;grey = 0.f;</a>
<a name="ln2072">  profile_info-&gt;lutsize = (lutsize &gt; 0) ? lutsize: DT_IOPPR_LUT_SAMPLES;</a>
<a name="ln2073">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2074">  {</a>
<a name="ln2075">    profile_info-&gt;lut_in[i] = malloc(profile_info-&gt;lutsize * sizeof(float));</a>
<a name="ln2076">    profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln2077">    profile_info-&gt;lut_out[i] = malloc(profile_info-&gt;lutsize * sizeof(float));</a>
<a name="ln2078">    profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln2079">  }</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">#undef DT_IOPPR_LUT_SAMPLES</a>
<a name="ln2083"> </a>
<a name="ln2084">void dt_ioppr_cleanup_profile_info(dt_iop_order_iccprofile_info_t *profile_info)</a>
<a name="ln2085">{</a>
<a name="ln2086">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2087">  {</a>
<a name="ln2088">    if(profile_info-&gt;lut_in[i]) free(profile_info-&gt;lut_in[i]);</a>
<a name="ln2089">    if(profile_info-&gt;lut_out[i]) free(profile_info-&gt;lut_out[i]);</a>
<a name="ln2090">  }</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">/** generate the info for the profile (type, filename) if matrix can be retrieved from lcms2</a>
<a name="ln2094"> * it can be called multiple time between init and cleanup</a>
<a name="ln2095"> * return 0 if OK, non zero otherwise</a>
<a name="ln2096"> */</a>
<a name="ln2097">static int dt_ioppr_generate_profile_info(dt_iop_order_iccprofile_info_t *profile_info, const int type, const char *filename, const int intent)</a>
<a name="ln2098">{</a>
<a name="ln2099">  int err_code = 0;</a>
<a name="ln2100">  cmsHPROFILE *rgb_profile = NULL;</a>
<a name="ln2101"> </a>
<a name="ln2102">  profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln2103">  profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln2104">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2105">  {</a>
<a name="ln2106">    profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln2107">    profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln2108">  }</a>
<a name="ln2109"> </a>
<a name="ln2110">  profile_info-&gt;nonlinearlut = 0;</a>
<a name="ln2111">  profile_info-&gt;grey = 0.1842f;</a>
<a name="ln2112"> </a>
<a name="ln2113">  profile_info-&gt;type = type;</a>
<a name="ln2114">  g_strlcpy(profile_info-&gt;filename, filename, sizeof(profile_info-&gt;filename));</a>
<a name="ln2115">  profile_info-&gt;intent = intent;</a>
<a name="ln2116"> </a>
<a name="ln2117">  if(type == DT_COLORSPACE_DISPLAY || type == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln2118">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln2119"> </a>
<a name="ln2120">  const dt_colorspaces_color_profile_t *profile</a>
<a name="ln2121">      = dt_colorspaces_get_profile(type, filename, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln2122">  if(profile) rgb_profile = profile-&gt;profile;</a>
<a name="ln2123"> </a>
<a name="ln2124">  if(type == DT_COLORSPACE_DISPLAY || type == DT_COLORSPACE_DISPLAY2)</a>
<a name="ln2125">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln2126"> </a>
<a name="ln2127">  // we only allow rgb profiles</a>
<a name="ln2128">  if(rgb_profile)</a>
<a name="ln2129">  {</a>
<a name="ln2130">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(rgb_profile);</a>
<a name="ln2131">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln2132">    {</a>
<a name="ln2133">      fprintf(stderr, &quot;working profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln2134">              (char)(rgb_color_space&gt;&gt;24),</a>
<a name="ln2135">              (char)(rgb_color_space&gt;&gt;16),</a>
<a name="ln2136">              (char)(rgb_color_space&gt;&gt;8),</a>
<a name="ln2137">              (char)(rgb_color_space));</a>
<a name="ln2138">      rgb_profile = NULL;</a>
<a name="ln2139">    }</a>
<a name="ln2140">  }</a>
<a name="ln2141"> </a>
<a name="ln2142">  // get the matrix</a>
<a name="ln2143">  if(rgb_profile)</a>
<a name="ln2144">  {</a>
<a name="ln2145">    if(dt_colorspaces_get_matrix_from_input_profile(rgb_profile, profile_info-&gt;matrix_in,</a>
<a name="ln2146">        profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln2147">        profile_info-&gt;lutsize, profile_info-&gt;intent) ||</a>
<a name="ln2148">        dt_colorspaces_get_matrix_from_output_profile(rgb_profile, profile_info-&gt;matrix_out,</a>
<a name="ln2149">            profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln2150">            profile_info-&gt;lutsize, profile_info-&gt;intent))</a>
<a name="ln2151">    {</a>
<a name="ln2152">      profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln2153">      profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln2154">      for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2155">      {</a>
<a name="ln2156">        profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln2157">        profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln2158">      }</a>
<a name="ln2159">    }</a>
<a name="ln2160">    else if(isnan(profile_info-&gt;matrix_in[0]) || isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2161">    {</a>
<a name="ln2162">      profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln2163">      profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln2164">      for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2165">      {</a>
<a name="ln2166">        profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln2167">        profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln2168">      }</a>
<a name="ln2169">    }</a>
<a name="ln2170">  }</a>
<a name="ln2171"> </a>
<a name="ln2172">  // now try to initialize unbounded mode:</a>
<a name="ln2173">  // we do extrapolation for input values above 1.0f.</a>
<a name="ln2174">  // unfortunately we can only do this if we got the computation</a>
<a name="ln2175">  // in our hands, i.e. for the fast builtin-dt-matrix-profile path.</a>
<a name="ln2176">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2177">  {</a>
<a name="ln2178">    profile_info-&gt;nonlinearlut = _init_unbounded_coeffs(profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln2179">        profile_info-&gt;unbounded_coeffs_in[0], profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2], profile_info-&gt;lutsize);</a>
<a name="ln2180">    _init_unbounded_coeffs(profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln2181">        profile_info-&gt;unbounded_coeffs_out[0], profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2], profile_info-&gt;lutsize);</a>
<a name="ln2182">  }</a>
<a name="ln2183"> </a>
<a name="ln2184">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]) &amp;&amp; profile_info-&gt;nonlinearlut)</a>
<a name="ln2185">  {</a>
<a name="ln2186">    float rgb[3] = { 0.1842f, 0.1842f, 0.1842f };</a>
<a name="ln2187">    profile_info-&gt;grey = dt_ioppr_get_rgb_matrix_luminance(rgb, profile_info);</a>
<a name="ln2188">  }</a>
<a name="ln2189"> </a>
<a name="ln2190">  return err_code;</a>
<a name="ln2191">}</a>
<a name="ln2192"> </a>
<a name="ln2193">dt_iop_order_iccprofile_info_t *dt_ioppr_get_profile_info_from_list(struct dt_develop_t *dev, const int profile_type, const char *profile_filename)</a>
<a name="ln2194">{</a>
<a name="ln2195">  dt_iop_order_iccprofile_info_t *profile_info = NULL;</a>
<a name="ln2196"> </a>
<a name="ln2197">  GList *profiles = g_list_first(dev-&gt;allprofile_info);</a>
<a name="ln2198">  while(profiles)</a>
<a name="ln2199">  {</a>
<a name="ln2200">    dt_iop_order_iccprofile_info_t *prof = (dt_iop_order_iccprofile_info_t *)(profiles-&gt;data);</a>
<a name="ln2201">    if(prof-&gt;type == profile_type &amp;&amp; strcmp(prof-&gt;filename, profile_filename) == 0)</a>
<a name="ln2202">    {</a>
<a name="ln2203">      profile_info = prof;</a>
<a name="ln2204">      break;</a>
<a name="ln2205">    }</a>
<a name="ln2206">    profiles = g_list_next(profiles);</a>
<a name="ln2207">  }</a>
<a name="ln2208"> </a>
<a name="ln2209">  return profile_info;</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212">dt_iop_order_iccprofile_info_t *dt_ioppr_add_profile_info_to_list(struct dt_develop_t *dev, const int profile_type, const char *profile_filename, const int intent)</a>
<a name="ln2213">{</a>
<a name="ln2214">  dt_iop_order_iccprofile_info_t *profile_info = dt_ioppr_get_profile_info_from_list(dev, profile_type, profile_filename);</a>
<a name="ln2215">  if(profile_info == NULL)</a>
<a name="ln2216">  {</a>
<a name="ln2217">    profile_info = malloc(sizeof(dt_iop_order_iccprofile_info_t));</a>
<a name="ln2218">    dt_ioppr_init_profile_info(profile_info, 0);</a>
<a name="ln2219">    const int err = dt_ioppr_generate_profile_info(profile_info, profile_type, profile_filename, intent);</a>
<a name="ln2220">    if(err == 0)</a>
<a name="ln2221">    {</a>
<a name="ln2222">      dev-&gt;allprofile_info = g_list_append(dev-&gt;allprofile_info, profile_info);</a>
<a name="ln2223">    }</a>
<a name="ln2224">    else</a>
<a name="ln2225">    {</a>
<a name="ln2226">      free(profile_info);</a>
<a name="ln2227">      profile_info = NULL;</a>
<a name="ln2228">    }</a>
<a name="ln2229">  }</a>
<a name="ln2230">  return profile_info;</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233">dt_iop_order_iccprofile_info_t *dt_ioppr_get_iop_work_profile_info(struct dt_iop_module_t *module, GList *iop_list)</a>
<a name="ln2234">{</a>
<a name="ln2235">  dt_iop_order_iccprofile_info_t *profile = NULL;</a>
<a name="ln2236"> </a>
<a name="ln2237">  // first check if the module is between colorin and colorout</a>
<a name="ln2238">  gboolean in_between = FALSE;</a>
<a name="ln2239"> </a>
<a name="ln2240">  GList *modules = g_list_first(iop_list);</a>
<a name="ln2241">  while(modules)</a>
<a name="ln2242">  {</a>
<a name="ln2243">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2244"> </a>
<a name="ln2245">    // we reach the module, that's it</a>
<a name="ln2246">    if(strcmp(mod-&gt;op, module-&gt;op) == 0) break;</a>
<a name="ln2247"> </a>
<a name="ln2248">    // if we reach colorout means that the module is after it</a>
<a name="ln2249">    if(strcmp(mod-&gt;op, &quot;colorout&quot;) == 0)</a>
<a name="ln2250">    {</a>
<a name="ln2251">      in_between = FALSE;</a>
<a name="ln2252">      break;</a>
<a name="ln2253">    }</a>
<a name="ln2254"> </a>
<a name="ln2255">    // we reach colorin, so far we're good</a>
<a name="ln2256">    if(strcmp(mod-&gt;op, &quot;colorin&quot;) == 0)</a>
<a name="ln2257">    {</a>
<a name="ln2258">      in_between = TRUE;</a>
<a name="ln2259">      break;</a>
<a name="ln2260">    }</a>
<a name="ln2261"> </a>
<a name="ln2262">    modules = g_list_next(modules);</a>
<a name="ln2263">  }</a>
<a name="ln2264"> </a>
<a name="ln2265">  if(in_between)</a>
<a name="ln2266">  {</a>
<a name="ln2267">    dt_colorspaces_color_profile_type_t type = DT_COLORSPACE_NONE;</a>
<a name="ln2268">    char *filename = NULL;</a>
<a name="ln2269">    dt_develop_t *dev = module-&gt;dev;</a>
<a name="ln2270"> </a>
<a name="ln2271">    dt_ioppr_get_work_profile_type(dev, &amp;type, &amp;filename);</a>
<a name="ln2272">    if(filename) profile = dt_ioppr_add_profile_info_to_list(dev, type, filename, DT_INTENT_PERCEPTUAL);</a>
<a name="ln2273">  }</a>
<a name="ln2274"> </a>
<a name="ln2275">  return profile;</a>
<a name="ln2276">}</a>
<a name="ln2277"> </a>
<a name="ln2278">dt_iop_order_iccprofile_info_t *dt_ioppr_set_pipe_work_profile_info(struct dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe,</a>
<a name="ln2279">    const int type, const char *filename, const int intent)</a>
<a name="ln2280">{</a>
<a name="ln2281">  dt_iop_order_iccprofile_info_t *profile_info = dt_ioppr_add_profile_info_to_list(dev, type, filename, intent);</a>
<a name="ln2282"> </a>
<a name="ln2283">  if(profile_info == NULL || isnan(profile_info-&gt;matrix_in[0]) || isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2284">  {</a>
<a name="ln2285">    fprintf(stderr, &quot;[dt_ioppr_set_pipe_work_profile_info] unsupported working profile %i %s, it will be replaced with linear rec2020\n&quot;, type, filename);</a>
<a name="ln2286">    profile_info = dt_ioppr_add_profile_info_to_list(dev, DT_COLORSPACE_LIN_REC2020, &quot;&quot;, intent);</a>
<a name="ln2287">  }</a>
<a name="ln2288">  pipe-&gt;dsc.work_profile_info = profile_info;</a>
<a name="ln2289"> </a>
<a name="ln2290">  return profile_info;</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">dt_iop_order_iccprofile_info_t *dt_ioppr_get_histogram_profile_info(struct dt_develop_t *dev)</a>
<a name="ln2294">{</a>
<a name="ln2295">  dt_colorspaces_color_profile_type_t histogram_profile_type;</a>
<a name="ln2296">  char *histogram_profile_filename;</a>
<a name="ln2297">  dt_ioppr_get_histogram_profile_type(&amp;histogram_profile_type, &amp;histogram_profile_filename);</a>
<a name="ln2298">  return dt_ioppr_add_profile_info_to_list(dev, histogram_profile_type, histogram_profile_filename,</a>
<a name="ln2299">                                           DT_INTENT_PERCEPTUAL);</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">dt_iop_order_iccprofile_info_t *dt_ioppr_get_pipe_work_profile_info(struct dt_dev_pixelpipe_t *pipe)</a>
<a name="ln2303">{</a>
<a name="ln2304">  return pipe-&gt;dsc.work_profile_info;</a>
<a name="ln2305">}</a>
<a name="ln2306"> </a>
<a name="ln2307">// returns a pointer to the filename of the work profile instead of the actual string data</a>
<a name="ln2308">// pointer must not be stored</a>
<a name="ln2309">void dt_ioppr_get_work_profile_type(struct dt_develop_t *dev, int *profile_type, char **profile_filename)</a>
<a name="ln2310">{</a>
<a name="ln2311">  *profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln2312">  *profile_filename = NULL;</a>
<a name="ln2313"> </a>
<a name="ln2314">  // use introspection to get the params values</a>
<a name="ln2315">  dt_iop_module_so_t *colorin_so = NULL;</a>
<a name="ln2316">  dt_iop_module_t *colorin = NULL;</a>
<a name="ln2317">  GList *modules = g_list_first(darktable.iop);</a>
<a name="ln2318">  while(modules)</a>
<a name="ln2319">  {</a>
<a name="ln2320">    dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln2321">    if(!strcmp(module_so-&gt;op, &quot;colorin&quot;))</a>
<a name="ln2322">    {</a>
<a name="ln2323">      colorin_so = module_so;</a>
<a name="ln2324">      break;</a>
<a name="ln2325">    }</a>
<a name="ln2326">    modules = g_list_next(modules);</a>
<a name="ln2327">  }</a>
<a name="ln2328">  if(colorin_so &amp;&amp; colorin_so-&gt;get_p)</a>
<a name="ln2329">  {</a>
<a name="ln2330">    modules = g_list_first(dev-&gt;iop);</a>
<a name="ln2331">    while(modules)</a>
<a name="ln2332">    {</a>
<a name="ln2333">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2334">      if(!strcmp(module-&gt;op, &quot;colorin&quot;))</a>
<a name="ln2335">      {</a>
<a name="ln2336">        colorin = module;</a>
<a name="ln2337">        break;</a>
<a name="ln2338">      }</a>
<a name="ln2339">      modules = g_list_next(modules);</a>
<a name="ln2340">    }</a>
<a name="ln2341">  }</a>
<a name="ln2342">  if(colorin)</a>
<a name="ln2343">  {</a>
<a name="ln2344">    dt_colorspaces_color_profile_type_t *_type = colorin_so-&gt;get_p(colorin-&gt;params, &quot;type_work&quot;);</a>
<a name="ln2345">    char *_filename = colorin_so-&gt;get_p(colorin-&gt;params, &quot;filename_work&quot;);</a>
<a name="ln2346">    if(_type &amp;&amp; _filename)</a>
<a name="ln2347">    {</a>
<a name="ln2348">      *profile_type = *_type;</a>
<a name="ln2349">      *profile_filename = _filename;</a>
<a name="ln2350">    }</a>
<a name="ln2351">    else</a>
<a name="ln2352">      fprintf(stderr, &quot;[dt_ioppr_get_work_profile_type] can't get colorin parameters\n&quot;);</a>
<a name="ln2353">  }</a>
<a name="ln2354">  else</a>
<a name="ln2355">    fprintf(stderr, &quot;[dt_ioppr_get_work_profile_type] can't find colorin iop\n&quot;);</a>
<a name="ln2356">}</a>
<a name="ln2357"> </a>
<a name="ln2358">void dt_ioppr_get_export_profile_type(struct dt_develop_t *dev, int *profile_type, char **profile_filename)</a>
<a name="ln2359">{</a>
<a name="ln2360">  *profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln2361">  *profile_filename = NULL;</a>
<a name="ln2362"> </a>
<a name="ln2363">  // use introspection to get the params values</a>
<a name="ln2364">  dt_iop_module_so_t *colorout_so = NULL;</a>
<a name="ln2365">  dt_iop_module_t *colorout = NULL;</a>
<a name="ln2366">  GList *modules = g_list_last(darktable.iop);</a>
<a name="ln2367">  while(modules)</a>
<a name="ln2368">  {</a>
<a name="ln2369">    dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln2370">    if(!strcmp(module_so-&gt;op, &quot;colorout&quot;))</a>
<a name="ln2371">    {</a>
<a name="ln2372">      colorout_so = module_so;</a>
<a name="ln2373">      break;</a>
<a name="ln2374">    }</a>
<a name="ln2375">    modules = g_list_previous(modules);</a>
<a name="ln2376">  }</a>
<a name="ln2377">  if(colorout_so &amp;&amp; colorout_so-&gt;get_p)</a>
<a name="ln2378">  {</a>
<a name="ln2379">    modules = g_list_last(dev-&gt;iop);</a>
<a name="ln2380">    while(modules)</a>
<a name="ln2381">    {</a>
<a name="ln2382">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2383">      if(!strcmp(module-&gt;op, &quot;colorout&quot;))</a>
<a name="ln2384">      {</a>
<a name="ln2385">        colorout = module;</a>
<a name="ln2386">        break;</a>
<a name="ln2387">      }</a>
<a name="ln2388">      modules = g_list_previous(modules);</a>
<a name="ln2389">    }</a>
<a name="ln2390">  }</a>
<a name="ln2391">  if(colorout)</a>
<a name="ln2392">  {</a>
<a name="ln2393">    dt_colorspaces_color_profile_type_t *_type = colorout_so-&gt;get_p(colorout-&gt;params, &quot;type&quot;);</a>
<a name="ln2394">    char *_filename = colorout_so-&gt;get_p(colorout-&gt;params, &quot;filename&quot;);</a>
<a name="ln2395">    if(_type &amp;&amp; _filename)</a>
<a name="ln2396">    {</a>
<a name="ln2397">      *profile_type = *_type;</a>
<a name="ln2398">      *profile_filename = _filename;</a>
<a name="ln2399">    }</a>
<a name="ln2400">    else</a>
<a name="ln2401">      fprintf(stderr, &quot;[dt_ioppr_get_export_profile_type] can't get colorout parameters\n&quot;);</a>
<a name="ln2402">  }</a>
<a name="ln2403">  else</a>
<a name="ln2404">    fprintf(stderr, &quot;[dt_ioppr_get_export_profile_type] can't find colorout iop\n&quot;);</a>
<a name="ln2405">}</a>
<a name="ln2406"> </a>
<a name="ln2407">void dt_ioppr_get_histogram_profile_type(int *profile_type, char **profile_filename)</a>
<a name="ln2408">{</a>
<a name="ln2409">  const dt_colorspaces_color_mode_t mode = darktable.color_profiles-&gt;mode;</a>
<a name="ln2410"> </a>
<a name="ln2411">  // if in gamut check use soft proof</a>
<a name="ln2412">  if(mode != DT_PROFILE_NORMAL || darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_SOFTPROOF)</a>
<a name="ln2413">  {</a>
<a name="ln2414">    *profile_type = darktable.color_profiles-&gt;softproof_type;</a>
<a name="ln2415">    *profile_filename = darktable.color_profiles-&gt;softproof_filename;</a>
<a name="ln2416">  }</a>
<a name="ln2417">  else if(darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_WORK)</a>
<a name="ln2418">  {</a>
<a name="ln2419">    dt_ioppr_get_work_profile_type(darktable.develop, profile_type, profile_filename);</a>
<a name="ln2420">  }</a>
<a name="ln2421">  else if(darktable.color_profiles-&gt;histogram_type == DT_COLORSPACE_EXPORT)</a>
<a name="ln2422">  {</a>
<a name="ln2423">    dt_ioppr_get_export_profile_type(darktable.develop, profile_type, profile_filename);</a>
<a name="ln2424">  }</a>
<a name="ln2425">  else</a>
<a name="ln2426">  {</a>
<a name="ln2427">    *profile_type = darktable.color_profiles-&gt;histogram_type;</a>
<a name="ln2428">    *profile_filename = darktable.color_profiles-&gt;histogram_filename;</a>
<a name="ln2429">  }</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432"> </a>
<a name="ln2433">#ifdef _OPENMP</a>
<a name="ln2434">#pragma omp declare simd</a>
<a name="ln2435">#endif</a>
<a name="ln2436">inline float dt_ioppr_get_rgb_matrix_luminance(const float *const rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2437">{</a>
<a name="ln2438">  float luminance = 0.f;</a>
<a name="ln2439"> </a>
<a name="ln2440">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln2441">  {</a>
<a name="ln2442">    float linear_rgb[3] = { 0.f };</a>
<a name="ln2443"> </a>
<a name="ln2444">    _apply_trc_in(rgb, linear_rgb, profile_info);</a>
<a name="ln2445">    luminance = profile_info-&gt;matrix_in[3] * linear_rgb[0] + profile_info-&gt;matrix_in[4] * linear_rgb[1] + profile_info-&gt;matrix_in[5] * linear_rgb[2];</a>
<a name="ln2446">  }</a>
<a name="ln2447">  else</a>
<a name="ln2448">    luminance = profile_info-&gt;matrix_in[3] * rgb[0] + profile_info-&gt;matrix_in[4] * rgb[1] + profile_info-&gt;matrix_in[5] * rgb[2];</a>
<a name="ln2449"> </a>
<a name="ln2450">  return luminance;</a>
<a name="ln2451">}</a>
<a name="ln2452"> </a>
<a name="ln2453">void dt_ioppr_rgb_matrix_to_xyz(const float *const rgb, float *xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2454">{</a>
<a name="ln2455">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln2456">  {</a>
<a name="ln2457">    float linear_rgb[3];</a>
<a name="ln2458">    _apply_trc_in(rgb, linear_rgb, profile_info);</a>
<a name="ln2459">    _ioppr_linear_rgb_matrix_to_xyz(linear_rgb, xyz, profile_info);</a>
<a name="ln2460">  }</a>
<a name="ln2461">  else</a>
<a name="ln2462">    _ioppr_linear_rgb_matrix_to_xyz(rgb, xyz, profile_info);</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465">void dt_ioppr_lab_to_rgb_matrix(const float *const lab, float *rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2466">{</a>
<a name="ln2467">  float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln2468"> </a>
<a name="ln2469">  dt_Lab_to_XYZ(lab, xyz);</a>
<a name="ln2470"> </a>
<a name="ln2471">  _ioppr_xyz_to_linear_rgb_matrix(xyz, rgb, profile_info);</a>
<a name="ln2472"> </a>
<a name="ln2473">  if(profile_info-&gt;nonlinearlut) _apply_trc_out(rgb, rgb, profile_info);</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">void dt_ioppr_rgb_matrix_to_lab(const float *const rgb, float *lab, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2477">{</a>
<a name="ln2478">  float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln2479"> </a>
<a name="ln2480">  dt_ioppr_rgb_matrix_to_xyz(rgb, xyz, profile_info);</a>
<a name="ln2481"> </a>
<a name="ln2482">  dt_XYZ_to_Lab(xyz, lab);</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">float dt_ioppr_get_profile_info_middle_grey(const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2486">{</a>
<a name="ln2487">  return profile_info-&gt;grey;</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490">float dt_ioppr_compensate_middle_grey(const float x, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2491">{</a>
<a name="ln2492">  // we transform the curve nodes from the image colorspace to lab</a>
<a name="ln2493">  float lab[3] = { 0 };</a>
<a name="ln2494">  float rgb[3] = { 0 };</a>
<a name="ln2495"> </a>
<a name="ln2496">  rgb[0] = rgb[1] = rgb[2] = x;</a>
<a name="ln2497">  dt_ioppr_rgb_matrix_to_lab(rgb, lab, profile_info);</a>
<a name="ln2498">  return lab[0] * .01f;</a>
<a name="ln2499">}</a>
<a name="ln2500"> </a>
<a name="ln2501">float dt_ioppr_uncompensate_middle_grey(const float x, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2502">{</a>
<a name="ln2503">  // we transform the curve nodes from lab to the image colorspace</a>
<a name="ln2504">  float lab[3] = { 0 };</a>
<a name="ln2505">  float rgb[3] = { 0 };</a>
<a name="ln2506"> </a>
<a name="ln2507">  lab[0] = x * 100.f;</a>
<a name="ln2508">  dt_ioppr_lab_to_rgb_matrix(lab, rgb, profile_info);</a>
<a name="ln2509">  return rgb[0];</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">#if defined(__SSE2__x) // FIXME: this is slower than the C version</a>
<a name="ln2513">static __m128 _ioppr_linear_rgb_matrix_to_xyz_sse(const __m128 rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2514">{</a>
<a name="ln2515">/*  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2516">  {</a>
<a name="ln2517">    xyz[c] = 0.0f;</a>
<a name="ln2518">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2519">    {</a>
<a name="ln2520">      xyz[c] += profile_info-&gt;matrix_in[3 * c + i] * rgb[i];</a>
<a name="ln2521">    }</a>
<a name="ln2522">  }*/</a>
<a name="ln2523">  const __m128 m0 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[6], profile_info-&gt;matrix_in[3], profile_info-&gt;matrix_in[0]);</a>
<a name="ln2524">  const __m128 m1 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[7], profile_info-&gt;matrix_in[4], profile_info-&gt;matrix_in[1]);</a>
<a name="ln2525">  const __m128 m2 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[8], profile_info-&gt;matrix_in[5], profile_info-&gt;matrix_in[2]);</a>
<a name="ln2526"> </a>
<a name="ln2527">  __m128 xyz</a>
<a name="ln2528">      = _mm_add_ps(_mm_mul_ps(m0, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(0, 0, 0, 0))),</a>
<a name="ln2529">                   _mm_add_ps(_mm_mul_ps(m1, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(1, 1, 1, 1))),</a>
<a name="ln2530">                              _mm_mul_ps(m2, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(2, 2, 2, 2)))));</a>
<a name="ln2531">  return xyz;</a>
<a name="ln2532">}</a>
<a name="ln2533"> </a>
<a name="ln2534">static __m128 _ioppr_xyz_to_linear_rgb_matrix_sse(const __m128 xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2535">{</a>
<a name="ln2536">/*  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2537">  {</a>
<a name="ln2538">    rgb[c] = 0.0f;</a>
<a name="ln2539">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2540">    {</a>
<a name="ln2541">      rgb[c] += profile_info-&gt;matrix_out[3 * c + i] * xyz[i];</a>
<a name="ln2542">    }</a>
<a name="ln2543">  }*/</a>
<a name="ln2544">  const __m128 m0 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[6], profile_info-&gt;matrix_out[3], profile_info-&gt;matrix_out[0]);</a>
<a name="ln2545">  const __m128 m1 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[7], profile_info-&gt;matrix_out[4], profile_info-&gt;matrix_out[1]);</a>
<a name="ln2546">  const __m128 m2 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[8], profile_info-&gt;matrix_out[5], profile_info-&gt;matrix_out[2]);</a>
<a name="ln2547"> </a>
<a name="ln2548">  __m128 rgb</a>
<a name="ln2549">      = _mm_add_ps(_mm_mul_ps(m0, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(0, 0, 0, 0))),</a>
<a name="ln2550">                   _mm_add_ps(_mm_mul_ps(m1, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(1, 1, 1, 1))),</a>
<a name="ln2551">                              _mm_mul_ps(m2, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(2, 2, 2, 2)))));</a>
<a name="ln2552">  return rgb;</a>
<a name="ln2553">}</a>
<a name="ln2554"> </a>
<a name="ln2555">static void _transform_rgb_to_lab_matrix_sse(float *const image, const int width, const int height, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2556">{</a>
<a name="ln2557">  const int ch = 4;</a>
<a name="ln2558">  const size_t stride = (size_t)(width * height);</a>
<a name="ln2559"> </a>
<a name="ln2560">  _apply_tonecurves(image, width, height, profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln2561">      profile_info-&gt;unbounded_coeffs_in[0], profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2], profile_info-&gt;lutsize);</a>
<a name="ln2562"> </a>
<a name="ln2563">#ifdef _OPENMP</a>
<a name="ln2564">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2565">#endif</a>
<a name="ln2566">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2567">  {</a>
<a name="ln2568">    float *const in = image + y * ch;</a>
<a name="ln2569"> </a>
<a name="ln2570">    __m128 xyz = { 0.0f };</a>
<a name="ln2571">    __m128 rgb = _mm_load_ps(in);</a>
<a name="ln2572"> </a>
<a name="ln2573">    xyz = _ioppr_linear_rgb_matrix_to_xyz_sse(rgb, profile_info);</a>
<a name="ln2574"> </a>
<a name="ln2575">    rgb = dt_XYZ_to_Lab_sse2(xyz);</a>
<a name="ln2576">    const float a = in[3];</a>
<a name="ln2577">    _mm_stream_ps(in, rgb);</a>
<a name="ln2578">    in[3] = a;</a>
<a name="ln2579">  }</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582">static void _transform_lab_to_rgb_matrix_sse(float *const image, const int width, const int height, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2583">{</a>
<a name="ln2584">  const int ch = 4;</a>
<a name="ln2585">  const size_t stride = (size_t)width * height;</a>
<a name="ln2586"> </a>
<a name="ln2587">#ifdef _OPENMP</a>
<a name="ln2588">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2589">#endif</a>
<a name="ln2590">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2591">  {</a>
<a name="ln2592">    float *const in = image + y * ch;</a>
<a name="ln2593"> </a>
<a name="ln2594">    __m128 xyz = { 0.0f };</a>
<a name="ln2595">    __m128 lab = _mm_load_ps(in);</a>
<a name="ln2596"> </a>
<a name="ln2597">    xyz = dt_Lab_to_XYZ_sse2(lab);</a>
<a name="ln2598">    lab = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info);</a>
<a name="ln2599">    const float a = in[3];</a>
<a name="ln2600">    _mm_stream_ps(in, lab);</a>
<a name="ln2601">    in[3] = a;</a>
<a name="ln2602">  }</a>
<a name="ln2603"> </a>
<a name="ln2604">  _apply_tonecurves(image, width, height, profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln2605">      profile_info-&gt;unbounded_coeffs_out[0], profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2], profile_info-&gt;lutsize);</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608">// FIXME: this is slower than the C version</a>
<a name="ln2609">static void _transform_matrix_sse(struct dt_iop_module_t *self, float *const image, const int width, const int height,</a>
<a name="ln2610">    const int cst_from, const int cst_to, int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2611">{</a>
<a name="ln2612">  if(cst_from == cst_to)</a>
<a name="ln2613">  {</a>
<a name="ln2614">    *converted_cst = cst_to;</a>
<a name="ln2615">    return;</a>
<a name="ln2616">  }</a>
<a name="ln2617"> </a>
<a name="ln2618">  *converted_cst = cst_to;</a>
<a name="ln2619"> </a>
<a name="ln2620">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2621">  {</a>
<a name="ln2622">    _transform_rgb_to_lab_matrix_sse(image, width, height, profile_info);</a>
<a name="ln2623">  }</a>
<a name="ln2624">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2625">  {</a>
<a name="ln2626">    _transform_lab_to_rgb_matrix_sse(image, width, height, profile_info);</a>
<a name="ln2627">  }</a>
<a name="ln2628">  else</a>
<a name="ln2629">  {</a>
<a name="ln2630">    *converted_cst = cst_from;</a>
<a name="ln2631">    fprintf(stderr, &quot;[_transform_matrix_sse] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2632">  }</a>
<a name="ln2633">}</a>
<a name="ln2634"> </a>
<a name="ln2635">static void _transform_matrix_rgb_sse(float *const image, const int width, const int height,</a>
<a name="ln2636">                                      const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2637">                                      const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln2638">{</a>
<a name="ln2639">  const int ch = 4;</a>
<a name="ln2640">  const size_t stride = (size_t)(width * height);</a>
<a name="ln2641"> </a>
<a name="ln2642">  _apply_tonecurves(image, width, height, profile_info_from-&gt;lut_in[0], profile_info_from-&gt;lut_in[1],</a>
<a name="ln2643">                    profile_info_from-&gt;lut_in[2], profile_info_from-&gt;unbounded_coeffs_in[0],</a>
<a name="ln2644">                    profile_info_from-&gt;unbounded_coeffs_in[1], profile_info_from-&gt;unbounded_coeffs_in[2],</a>
<a name="ln2645">                    profile_info_from-&gt;lutsize);</a>
<a name="ln2646"> </a>
<a name="ln2647">#ifdef _OPENMP</a>
<a name="ln2648">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2649">#endif</a>
<a name="ln2650">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2651">  {</a>
<a name="ln2652">    float *const in = image + y * ch;</a>
<a name="ln2653"> </a>
<a name="ln2654">    __m128 xyz = { 0.0f };</a>
<a name="ln2655">    __m128 rgb = _mm_load_ps(in);</a>
<a name="ln2656"> </a>
<a name="ln2657">    xyz = _ioppr_linear_rgb_matrix_to_xyz_sse(rgb, profile_info_from);</a>
<a name="ln2658">    rgb = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info_to);</a>
<a name="ln2659"> </a>
<a name="ln2660">    const float a = in[3];</a>
<a name="ln2661">    _mm_stream_ps(in, rgb);</a>
<a name="ln2662">    in[3] = a;</a>
<a name="ln2663">  }</a>
<a name="ln2664"> </a>
<a name="ln2665">  _apply_tonecurves(image, width, height, profile_info_to-&gt;lut_out[0], profile_info_to-&gt;lut_out[1],</a>
<a name="ln2666">                    profile_info_to-&gt;lut_out[2], profile_info_to-&gt;unbounded_coeffs_out[0],</a>
<a name="ln2667">                    profile_info_to-&gt;unbounded_coeffs_out[1], profile_info_to-&gt;unbounded_coeffs_out[2],</a>
<a name="ln2668">                    profile_info_to-&gt;lutsize);</a>
<a name="ln2669">}</a>
<a name="ln2670">#endif</a>
<a name="ln2671"> </a>
<a name="ln2672">void dt_ioppr_transform_image_colorspace(struct dt_iop_module_t *self, const float *const image_in,</a>
<a name="ln2673">                                         float *const image_out, const int width, const int height,</a>
<a name="ln2674">                                         const int cst_from, const int cst_to, int *converted_cst,</a>
<a name="ln2675">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2676">{</a>
<a name="ln2677">  if(cst_from == cst_to)</a>
<a name="ln2678">  {</a>
<a name="ln2679">    *converted_cst = cst_to;</a>
<a name="ln2680">    return;</a>
<a name="ln2681">  }</a>
<a name="ln2682">  if(profile_info == NULL)</a>
<a name="ln2683">  {</a>
<a name="ln2684">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace] module %s must be between input color profile and output color profile\n&quot;, self-&gt;op);</a>
<a name="ln2685">    *converted_cst = cst_from;</a>
<a name="ln2686">    return;</a>
<a name="ln2687">  }</a>
<a name="ln2688">  if(profile_info-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2689">  {</a>
<a name="ln2690">    *converted_cst = cst_from;</a>
<a name="ln2691">    return;</a>
<a name="ln2692">  }</a>
<a name="ln2693"> </a>
<a name="ln2694">  dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2695">  if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2696"> </a>
<a name="ln2697">  // matrix should be never NAN, this is only to test it against lcms2!</a>
<a name="ln2698">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2699">  {</a>
<a name="ln2700">    // FIXME: sse is slower than the C version</a>
<a name="ln2701">    // if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln2702">    _transform_matrix(self, image_in, image_out, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2703">    /*</a>
<a name="ln2704">    #if defined(__SSE2__)</a>
<a name="ln2705">        else if(darktable.codepath.SSE2)</a>
<a name="ln2706">          _transform_matrix_sse(self, image, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2707">    #endif</a>
<a name="ln2708">        else</a>
<a name="ln2709">          dt_unreachable_codepath();</a>
<a name="ln2710">    */</a>
<a name="ln2711">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2712">    {</a>
<a name="ln2713">      dt_get_times(&amp;end_time);</a>
<a name="ln2714">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f CPU) [%s %s]\n&quot;,</a>
<a name="ln2715">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;,</a>
<a name="ln2716">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2717">    }</a>
<a name="ln2718">  }</a>
<a name="ln2719">  else</a>
<a name="ln2720">  {</a>
<a name="ln2721">    _transform_lcms2(self, image_in, image_out, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2722"> </a>
<a name="ln2723">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2724">    {</a>
<a name="ln2725">      dt_get_times(&amp;end_time);</a>
<a name="ln2726">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f lcms2) [%s %s]\n&quot;,</a>
<a name="ln2727">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;,</a>
<a name="ln2728">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2729">    }</a>
<a name="ln2730">  }</a>
<a name="ln2731"> </a>
<a name="ln2732">  if(*converted_cst == cst_from)</a>
<a name="ln2733">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2734">}</a>
<a name="ln2735"> </a>
<a name="ln2736">void dt_ioppr_transform_image_colorspace_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln2737">                                             const int height,</a>
<a name="ln2738">                                             const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2739">                                             const dt_iop_order_iccprofile_info_t *const profile_info_to,</a>
<a name="ln2740">                                             const char *message)</a>
<a name="ln2741">{</a>
<a name="ln2742">  if(profile_info_from-&gt;type == DT_COLORSPACE_NONE || profile_info_to-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2743">  {</a>
<a name="ln2744">    return;</a>
<a name="ln2745">  }</a>
<a name="ln2746">  if(profile_info_from-&gt;type == profile_info_to-&gt;type</a>
<a name="ln2747">     &amp;&amp; strcmp(profile_info_from-&gt;filename, profile_info_to-&gt;filename) == 0)</a>
<a name="ln2748">  {</a>
<a name="ln2749">    if(image_in != image_out)</a>
<a name="ln2750">      memcpy(image_out, image_in, width * height * 4 * sizeof(float));</a>
<a name="ln2751"> </a>
<a name="ln2752">    return;</a>
<a name="ln2753">  }</a>
<a name="ln2754"> </a>
<a name="ln2755">  dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2756">  if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2757"> </a>
<a name="ln2758">  if(!isnan(profile_info_from-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_from-&gt;matrix_out[0])</a>
<a name="ln2759">     &amp;&amp; !isnan(profile_info_to-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_to-&gt;matrix_out[0]))</a>
<a name="ln2760">  {</a>
<a name="ln2761">    // FIXME: sse is slower than the C version</a>
<a name="ln2762">    // if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln2763">    _transform_matrix_rgb(image_in, image_out, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2764">    /*</a>
<a name="ln2765">    #if defined(__SSE2__)</a>
<a name="ln2766">        else if(darktable.codepath.SSE2)</a>
<a name="ln2767">          _transform_matrix_rgb_sse(self, image, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2768">    #endif</a>
<a name="ln2769">        else</a>
<a name="ln2770">          dt_unreachable_codepath();</a>
<a name="ln2771">    */</a>
<a name="ln2772">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2773">    {</a>
<a name="ln2774">      dt_get_times(&amp;end_time);</a>
<a name="ln2775">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f CPU) [%s]\n&quot;,</a>
<a name="ln2776">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2777">    }</a>
<a name="ln2778">  }</a>
<a name="ln2779">  else</a>
<a name="ln2780">  {</a>
<a name="ln2781">    _transform_lcms2_rgb(image_in, image_out, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2782"> </a>
<a name="ln2783">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2784">    {</a>
<a name="ln2785">      dt_get_times(&amp;end_time);</a>
<a name="ln2786">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f lcms2) [%s]\n&quot;,</a>
<a name="ln2787">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2788">    }</a>
<a name="ln2789">  }</a>
<a name="ln2790">}</a>
<a name="ln2791"> </a>
<a name="ln2792">#ifdef HAVE_OPENCL</a>
<a name="ln2793">dt_colorspaces_cl_global_t *dt_colorspaces_init_cl_global()</a>
<a name="ln2794">{</a>
<a name="ln2795">  dt_colorspaces_cl_global_t *g = (dt_colorspaces_cl_global_t *)malloc(sizeof(dt_colorspaces_cl_global_t));</a>
<a name="ln2796"> </a>
<a name="ln2797">  const int program = 23; // colorspaces.cl, from programs.conf</a>
<a name="ln2798">  g-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix = dt_opencl_create_kernel(program, &quot;colorspaces_transform_lab_to_rgb_matrix&quot;);</a>
<a name="ln2799">  g-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab = dt_opencl_create_kernel(program, &quot;colorspaces_transform_rgb_matrix_to_lab&quot;);</a>
<a name="ln2800">  g-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb</a>
<a name="ln2801">      = dt_opencl_create_kernel(program, &quot;colorspaces_transform_rgb_matrix_to_rgb&quot;);</a>
<a name="ln2802">  return g;</a>
<a name="ln2803">}</a>
<a name="ln2804"> </a>
<a name="ln2805">void dt_colorspaces_free_cl_global(dt_colorspaces_cl_global_t *g)</a>
<a name="ln2806">{</a>
<a name="ln2807">  if(!g) return;</a>
<a name="ln2808"> </a>
<a name="ln2809">  // destroy kernels</a>
<a name="ln2810">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix);</a>
<a name="ln2811">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab);</a>
<a name="ln2812">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb);</a>
<a name="ln2813"> </a>
<a name="ln2814">  free(g);</a>
<a name="ln2815">}</a>
<a name="ln2816"> </a>
<a name="ln2817">void dt_ioppr_get_profile_info_cl(const dt_iop_order_iccprofile_info_t *const profile_info, dt_colorspaces_iccprofile_info_cl_t *profile_info_cl)</a>
<a name="ln2818">{</a>
<a name="ln2819">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln2820">  {</a>
<a name="ln2821">    profile_info_cl-&gt;matrix_in[i] = profile_info-&gt;matrix_in[i];</a>
<a name="ln2822">    profile_info_cl-&gt;matrix_out[i] = profile_info-&gt;matrix_out[i];</a>
<a name="ln2823">  }</a>
<a name="ln2824">  profile_info_cl-&gt;lutsize = profile_info-&gt;lutsize;</a>
<a name="ln2825">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2826">  {</a>
<a name="ln2827">    for(int j = 0; j &lt; 3; j++)</a>
<a name="ln2828">    {</a>
<a name="ln2829">      profile_info_cl-&gt;unbounded_coeffs_in[i][j] = profile_info-&gt;unbounded_coeffs_in[i][j];</a>
<a name="ln2830">      profile_info_cl-&gt;unbounded_coeffs_out[i][j] = profile_info-&gt;unbounded_coeffs_out[i][j];</a>
<a name="ln2831">    }</a>
<a name="ln2832">  }</a>
<a name="ln2833">  profile_info_cl-&gt;nonlinearlut = profile_info-&gt;nonlinearlut;</a>
<a name="ln2834">  profile_info_cl-&gt;grey = profile_info-&gt;grey;</a>
<a name="ln2835">}</a>
<a name="ln2836"> </a>
<a name="ln2837">cl_float *dt_ioppr_get_trc_cl(const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2838">{</a>
<a name="ln2839">  cl_float *trc = malloc(profile_info-&gt;lutsize * 6 * sizeof(cl_float));</a>
<a name="ln2840">  if(trc)</a>
<a name="ln2841">  {</a>
<a name="ln2842">    int x = 0;</a>
<a name="ln2843">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2844">      for(int y = 0; y &lt; profile_info-&gt;lutsize; y++, x++)</a>
<a name="ln2845">        trc[x] = profile_info-&gt;lut_in[c][y];</a>
<a name="ln2846">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2847">      for(int y = 0; y &lt; profile_info-&gt;lutsize; y++, x++)</a>
<a name="ln2848">        trc[x] = profile_info-&gt;lut_out[c][y];</a>
<a name="ln2849">  }</a>
<a name="ln2850">  return trc;</a>
<a name="ln2851">}</a>
<a name="ln2852"> </a>
<a name="ln2853">cl_int dt_ioppr_build_iccprofile_params_cl(const dt_iop_order_iccprofile_info_t *const profile_info,</a>
<a name="ln2854">                                           const int devid, dt_colorspaces_iccprofile_info_cl_t **_profile_info_cl,</a>
<a name="ln2855">                                           cl_float **_profile_lut_cl, cl_mem *_dev_profile_info,</a>
<a name="ln2856">                                           cl_mem *_dev_profile_lut)</a>
<a name="ln2857">{</a>
<a name="ln2858">  cl_int err = CL_SUCCESS;</a>
<a name="ln2859"> </a>
<a name="ln2860">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl = calloc(1, sizeof(dt_colorspaces_iccprofile_info_cl_t));</a>
<a name="ln2861">  cl_float *profile_lut_cl = NULL;</a>
<a name="ln2862">  cl_mem dev_profile_info = NULL;</a>
<a name="ln2863">  cl_mem dev_profile_lut = NULL;</a>
<a name="ln2864"> </a>
<a name="ln2865">  if(profile_info)</a>
<a name="ln2866">  {</a>
<a name="ln2867">    dt_ioppr_get_profile_info_cl(profile_info, profile_info_cl);</a>
<a name="ln2868">    profile_lut_cl = dt_ioppr_get_trc_cl(profile_info);</a>
<a name="ln2869"> </a>
<a name="ln2870">    dev_profile_info = dt_opencl_copy_host_to_device_constant(devid, sizeof(*profile_info_cl), profile_info_cl);</a>
<a name="ln2871">    if(dev_profile_info == NULL)</a>
<a name="ln2872">    {</a>
<a name="ln2873">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 5\n&quot;);</a>
<a name="ln2874">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2875">      goto cleanup;</a>
<a name="ln2876">    }</a>
<a name="ln2877"> </a>
<a name="ln2878">    dev_profile_lut = dt_opencl_copy_host_to_device(devid, profile_lut_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2879">    if(dev_profile_lut == NULL)</a>
<a name="ln2880">    {</a>
<a name="ln2881">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 6\n&quot;);</a>
<a name="ln2882">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2883">      goto cleanup;</a>
<a name="ln2884">    }</a>
<a name="ln2885">  }</a>
<a name="ln2886">  else</a>
<a name="ln2887">  {</a>
<a name="ln2888">    profile_lut_cl = malloc(1 * 6 * sizeof(cl_float));</a>
<a name="ln2889"> </a>
<a name="ln2890">    dev_profile_lut = dt_opencl_copy_host_to_device(devid, profile_lut_cl, 1, 1 * 6, sizeof(float));</a>
<a name="ln2891">    if(dev_profile_lut == NULL)</a>
<a name="ln2892">    {</a>
<a name="ln2893">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 6\n&quot;);</a>
<a name="ln2894">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2895">      goto cleanup;</a>
<a name="ln2896">    }</a>
<a name="ln2897">  }</a>
<a name="ln2898"> </a>
<a name="ln2899">cleanup:</a>
<a name="ln2900">  *_profile_info_cl = profile_info_cl;</a>
<a name="ln2901">  *_profile_lut_cl = profile_lut_cl;</a>
<a name="ln2902">  *_dev_profile_info = dev_profile_info;</a>
<a name="ln2903">  *_dev_profile_lut = dev_profile_lut;</a>
<a name="ln2904"> </a>
<a name="ln2905">  return err;</a>
<a name="ln2906">}</a>
<a name="ln2907"> </a>
<a name="ln2908">void dt_ioppr_free_iccprofile_params_cl(dt_colorspaces_iccprofile_info_cl_t **_profile_info_cl,</a>
<a name="ln2909">                                        cl_float **_profile_lut_cl, cl_mem *_dev_profile_info,</a>
<a name="ln2910">                                        cl_mem *_dev_profile_lut)</a>
<a name="ln2911">{</a>
<a name="ln2912">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl = *_profile_info_cl;</a>
<a name="ln2913">  cl_float *profile_lut_cl = *_profile_lut_cl;</a>
<a name="ln2914">  cl_mem dev_profile_info = *_dev_profile_info;</a>
<a name="ln2915">  cl_mem dev_profile_lut = *_dev_profile_lut;</a>
<a name="ln2916"> </a>
<a name="ln2917">  if(profile_info_cl) free(profile_info_cl);</a>
<a name="ln2918">  if(dev_profile_info) dt_opencl_release_mem_object(dev_profile_info);</a>
<a name="ln2919">  if(dev_profile_lut) dt_opencl_release_mem_object(dev_profile_lut);</a>
<a name="ln2920">  if(profile_lut_cl) free(profile_lut_cl);</a>
<a name="ln2921"> </a>
<a name="ln2922">  *_profile_info_cl = NULL;</a>
<a name="ln2923">  *_profile_lut_cl = NULL;</a>
<a name="ln2924">  *_dev_profile_info = NULL;</a>
<a name="ln2925">  *_dev_profile_lut = NULL;</a>
<a name="ln2926">}</a>
<a name="ln2927"> </a>
<a name="ln2928">int dt_ioppr_transform_image_colorspace_cl(struct dt_iop_module_t *self, const int devid, cl_mem dev_img_in,</a>
<a name="ln2929">                                           cl_mem dev_img_out, const int width, const int height,</a>
<a name="ln2930">                                           const int cst_from, const int cst_to, int *converted_cst,</a>
<a name="ln2931">                                           const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2932">{</a>
<a name="ln2933">  cl_int err = CL_SUCCESS;</a>
<a name="ln2934"> </a>
<a name="ln2935">  if(cst_from == cst_to)</a>
<a name="ln2936">  {</a>
<a name="ln2937">    *converted_cst = cst_to;</a>
<a name="ln2938">    return TRUE;</a>
<a name="ln2939">  }</a>
<a name="ln2940">  if(profile_info == NULL)</a>
<a name="ln2941">  {</a>
<a name="ln2942">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] module %s must be between input color profile and output color profile\n&quot;, self-&gt;op);</a>
<a name="ln2943">    *converted_cst = cst_from;</a>
<a name="ln2944">    return FALSE;</a>
<a name="ln2945">  }</a>
<a name="ln2946">  if(profile_info-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2947">  {</a>
<a name="ln2948">    *converted_cst = cst_from;</a>
<a name="ln2949">    return FALSE;</a>
<a name="ln2950">  }</a>
<a name="ln2951"> </a>
<a name="ln2952">  const int ch = 4;</a>
<a name="ln2953">  float *src_buffer = NULL;</a>
<a name="ln2954">  int in_place = (dev_img_in == dev_img_out);</a>
<a name="ln2955"> </a>
<a name="ln2956">  int kernel_transform = 0;</a>
<a name="ln2957">  cl_mem dev_tmp = NULL;</a>
<a name="ln2958">  cl_mem dev_profile_info = NULL;</a>
<a name="ln2959">  cl_mem dev_lut = NULL;</a>
<a name="ln2960">  dt_colorspaces_iccprofile_info_cl_t profile_info_cl;</a>
<a name="ln2961">  cl_float *lut_cl = NULL;</a>
<a name="ln2962"> </a>
<a name="ln2963">  *converted_cst = cst_from;</a>
<a name="ln2964"> </a>
<a name="ln2965">  // if we have a matrix use opencl</a>
<a name="ln2966">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2967">  {</a>
<a name="ln2968">    dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2969">    if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2970"> </a>
<a name="ln2971">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2972">    size_t region[] = { width, height, 1 };</a>
<a name="ln2973"> </a>
<a name="ln2974">    if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2975">    {</a>
<a name="ln2976">      kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab;</a>
<a name="ln2977">    }</a>
<a name="ln2978">    else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2979">    {</a>
<a name="ln2980">      kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix;</a>
<a name="ln2981">    }</a>
<a name="ln2982">    else</a>
<a name="ln2983">    {</a>
<a name="ln2984">      err = CL_INVALID_KERNEL;</a>
<a name="ln2985">      *converted_cst = cst_from;</a>
<a name="ln2986">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] invalid conversion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2987">      goto cleanup;</a>
<a name="ln2988">    }</a>
<a name="ln2989"> </a>
<a name="ln2990">    dt_ioppr_get_profile_info_cl(profile_info, &amp;profile_info_cl);</a>
<a name="ln2991">    lut_cl = dt_ioppr_get_trc_cl(profile_info);</a>
<a name="ln2992"> </a>
<a name="ln2993">    if(in_place)</a>
<a name="ln2994">    {</a>
<a name="ln2995">      dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2996">      if(dev_tmp == NULL)</a>
<a name="ln2997">      {</a>
<a name="ln2998">        fprintf(stderr,</a>
<a name="ln2999">                &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 4\n&quot;);</a>
<a name="ln3000">        err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3001">        goto cleanup;</a>
<a name="ln3002">      }</a>
<a name="ln3003"> </a>
<a name="ln3004">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_tmp, origin, origin, region);</a>
<a name="ln3005">      if(err != CL_SUCCESS)</a>
<a name="ln3006">      {</a>
<a name="ln3007">        fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln3008">        goto cleanup;</a>
<a name="ln3009">      }</a>
<a name="ln3010">    }</a>
<a name="ln3011">    else</a>
<a name="ln3012">    {</a>
<a name="ln3013">      dev_tmp = dev_img_in;</a>
<a name="ln3014">    }</a>
<a name="ln3015"> </a>
<a name="ln3016">    dev_profile_info = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_cl), &amp;profile_info_cl);</a>
<a name="ln3017">    if(dev_profile_info == NULL)</a>
<a name="ln3018">    {</a>
<a name="ln3019">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 5\n&quot;);</a>
<a name="ln3020">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3021">      goto cleanup;</a>
<a name="ln3022">    }</a>
<a name="ln3023">    dev_lut = dt_opencl_copy_host_to_device(devid, lut_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln3024">    if(dev_lut == NULL)</a>
<a name="ln3025">    {</a>
<a name="ln3026">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 6\n&quot;);</a>
<a name="ln3027">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3028">      goto cleanup;</a>
<a name="ln3029">    }</a>
<a name="ln3030"> </a>
<a name="ln3031">    size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3032"> </a>
<a name="ln3033">    dt_opencl_set_kernel_arg(devid, kernel_transform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3034">    dt_opencl_set_kernel_arg(devid, kernel_transform, 1, sizeof(cl_mem), (void *)&amp;dev_img_out);</a>
<a name="ln3035">    dt_opencl_set_kernel_arg(devid, kernel_transform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3036">    dt_opencl_set_kernel_arg(devid, kernel_transform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3037">    dt_opencl_set_kernel_arg(devid, kernel_transform, 4, sizeof(cl_mem), (void *)&amp;dev_profile_info);</a>
<a name="ln3038">    dt_opencl_set_kernel_arg(devid, kernel_transform, 5, sizeof(cl_mem), (void *)&amp;dev_lut);</a>
<a name="ln3039">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_transform, sizes);</a>
<a name="ln3040">    if(err != CL_SUCCESS)</a>
<a name="ln3041">    {</a>
<a name="ln3042">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error %i enqueue kernel for color transformation\n&quot;, err);</a>
<a name="ln3043">      goto cleanup;</a>
<a name="ln3044">    }</a>
<a name="ln3045"> </a>
<a name="ln3046">    *converted_cst = cst_to;</a>
<a name="ln3047"> </a>
<a name="ln3048">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln3049">    {</a>
<a name="ln3050">      dt_get_times(&amp;end_time);</a>
<a name="ln3051">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f GPU) [%s %s]\n&quot;,</a>
<a name="ln3052">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;,</a>
<a name="ln3053">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln3054">    }</a>
<a name="ln3055">  }</a>
<a name="ln3056">  else</a>
<a name="ln3057">  {</a>
<a name="ln3058">    // no matrix, call lcms2</a>
<a name="ln3059">    src_buffer = dt_alloc_align(64, width * height * ch * sizeof(float));</a>
<a name="ln3060">    if(src_buffer == NULL)</a>
<a name="ln3061">    {</a>
<a name="ln3062">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 1\n&quot;);</a>
<a name="ln3063">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3064">      goto cleanup;</a>
<a name="ln3065">    }</a>
<a name="ln3066"> </a>
<a name="ln3067">    err = dt_opencl_copy_device_to_host(devid, src_buffer, dev_img_in, width, height, ch * sizeof(float));</a>
<a name="ln3068">    if(err != CL_SUCCESS)</a>
<a name="ln3069">    {</a>
<a name="ln3070">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 2\n&quot;);</a>
<a name="ln3071">      goto cleanup;</a>
<a name="ln3072">    }</a>
<a name="ln3073"> </a>
<a name="ln3074">    // just call the CPU version for now</a>
<a name="ln3075">    dt_ioppr_transform_image_colorspace(self, src_buffer, src_buffer, width, height, cst_from, cst_to,</a>
<a name="ln3076">                                        converted_cst, profile_info);</a>
<a name="ln3077"> </a>
<a name="ln3078">    err = dt_opencl_write_host_to_device(devid, src_buffer, dev_img_out, width, height, ch * sizeof(float));</a>
<a name="ln3079">    if(err != CL_SUCCESS)</a>
<a name="ln3080">    {</a>
<a name="ln3081">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 3\n&quot;);</a>
<a name="ln3082">      goto cleanup;</a>
<a name="ln3083">    }</a>
<a name="ln3084">  }</a>
<a name="ln3085"> </a>
<a name="ln3086">cleanup:</a>
<a name="ln3087">  if(src_buffer) dt_free_align(src_buffer);</a>
<a name="ln3088">  if(dev_tmp &amp;&amp; in_place) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3089">  if(dev_profile_info) dt_opencl_release_mem_object(dev_profile_info);</a>
<a name="ln3090">  if(dev_lut) dt_opencl_release_mem_object(dev_lut);</a>
<a name="ln3091">  if(lut_cl) free(lut_cl);</a>
<a name="ln3092"> </a>
<a name="ln3093">  return (err == CL_SUCCESS) ? TRUE : FALSE;</a>
<a name="ln3094">}</a>
<a name="ln3095"> </a>
<a name="ln3096">int dt_ioppr_transform_image_colorspace_rgb_cl(const int devid, cl_mem dev_img_in, cl_mem dev_img_out,</a>
<a name="ln3097">                                               const int width, const int height,</a>
<a name="ln3098">                                               const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln3099">                                               const dt_iop_order_iccprofile_info_t *const profile_info_to,</a>
<a name="ln3100">                                               const char *message)</a>
<a name="ln3101">{</a>
<a name="ln3102">  cl_int err = CL_SUCCESS;</a>
<a name="ln3103"> </a>
<a name="ln3104">  if(profile_info_from-&gt;type == DT_COLORSPACE_NONE || profile_info_to-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln3105">  {</a>
<a name="ln3106">    return FALSE;</a>
<a name="ln3107">  }</a>
<a name="ln3108">  if(profile_info_from-&gt;type == profile_info_to-&gt;type</a>
<a name="ln3109">     &amp;&amp; strcmp(profile_info_from-&gt;filename, profile_info_to-&gt;filename) == 0)</a>
<a name="ln3110">  {</a>
<a name="ln3111">    if(dev_img_in != dev_img_out)</a>
<a name="ln3112">    {</a>
<a name="ln3113">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3114">      size_t region[] = { width, height, 1 };</a>
<a name="ln3115"> </a>
<a name="ln3116">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_img_out, origin, origin, region);</a>
<a name="ln3117">      if(err != CL_SUCCESS)</a>
<a name="ln3118">      {</a>
<a name="ln3119">        fprintf(stderr,</a>
<a name="ln3120">                &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln3121">        return FALSE;</a>
<a name="ln3122">      }</a>
<a name="ln3123">    }</a>
<a name="ln3124"> </a>
<a name="ln3125">    return TRUE;</a>
<a name="ln3126">  }</a>
<a name="ln3127"> </a>
<a name="ln3128">  const int ch = 4;</a>
<a name="ln3129">  float *src_buffer = NULL;</a>
<a name="ln3130">  int in_place = (dev_img_in == dev_img_out);</a>
<a name="ln3131"> </a>
<a name="ln3132">  int kernel_transform = 0;</a>
<a name="ln3133">  cl_mem dev_tmp = NULL;</a>
<a name="ln3134"> </a>
<a name="ln3135">  cl_mem dev_profile_info_from = NULL;</a>
<a name="ln3136">  cl_mem dev_lut_from = NULL;</a>
<a name="ln3137">  dt_colorspaces_iccprofile_info_cl_t profile_info_from_cl;</a>
<a name="ln3138">  cl_float *lut_from_cl = NULL;</a>
<a name="ln3139"> </a>
<a name="ln3140">  cl_mem dev_profile_info_to = NULL;</a>
<a name="ln3141">  cl_mem dev_lut_to = NULL;</a>
<a name="ln3142">  dt_colorspaces_iccprofile_info_cl_t profile_info_to_cl;</a>
<a name="ln3143">  cl_float *lut_to_cl = NULL;</a>
<a name="ln3144"> </a>
<a name="ln3145">  // if we have a matrix use opencl</a>
<a name="ln3146">  if(!isnan(profile_info_from-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_from-&gt;matrix_out[0])</a>
<a name="ln3147">     &amp;&amp; !isnan(profile_info_to-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_to-&gt;matrix_out[0]))</a>
<a name="ln3148">  {</a>
<a name="ln3149">    dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln3150">    if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln3151"> </a>
<a name="ln3152">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3153">    size_t region[] = { width, height, 1 };</a>
<a name="ln3154"> </a>
<a name="ln3155">    kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb;</a>
<a name="ln3156"> </a>
<a name="ln3157">    dt_ioppr_get_profile_info_cl(profile_info_from, &amp;profile_info_from_cl);</a>
<a name="ln3158">    lut_from_cl = dt_ioppr_get_trc_cl(profile_info_from);</a>
<a name="ln3159"> </a>
<a name="ln3160">    dt_ioppr_get_profile_info_cl(profile_info_to, &amp;profile_info_to_cl);</a>
<a name="ln3161">    lut_to_cl = dt_ioppr_get_trc_cl(profile_info_to);</a>
<a name="ln3162"> </a>
<a name="ln3163">    if(in_place)</a>
<a name="ln3164">    {</a>
<a name="ln3165">      dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln3166">      if(dev_tmp == NULL)</a>
<a name="ln3167">      {</a>
<a name="ln3168">        fprintf(</a>
<a name="ln3169">            stderr,</a>
<a name="ln3170">            &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 4\n&quot;);</a>
<a name="ln3171">        err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3172">        goto cleanup;</a>
<a name="ln3173">      }</a>
<a name="ln3174"> </a>
<a name="ln3175">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_tmp, origin, origin, region);</a>
<a name="ln3176">      if(err != CL_SUCCESS)</a>
<a name="ln3177">      {</a>
<a name="ln3178">        fprintf(stderr,</a>
<a name="ln3179">                &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln3180">        goto cleanup;</a>
<a name="ln3181">      }</a>
<a name="ln3182">    }</a>
<a name="ln3183">    else</a>
<a name="ln3184">    {</a>
<a name="ln3185">      dev_tmp = dev_img_in;</a>
<a name="ln3186">    }</a>
<a name="ln3187"> </a>
<a name="ln3188">    dev_profile_info_from</a>
<a name="ln3189">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_from_cl), &amp;profile_info_from_cl);</a>
<a name="ln3190">    if(dev_profile_info_from == NULL)</a>
<a name="ln3191">    {</a>
<a name="ln3192">      fprintf(stderr,</a>
<a name="ln3193">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 5\n&quot;);</a>
<a name="ln3194">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3195">      goto cleanup;</a>
<a name="ln3196">    }</a>
<a name="ln3197">    dev_lut_from = dt_opencl_copy_host_to_device(devid, lut_from_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln3198">    if(dev_lut_from == NULL)</a>
<a name="ln3199">    {</a>
<a name="ln3200">      fprintf(stderr,</a>
<a name="ln3201">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 6\n&quot;);</a>
<a name="ln3202">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3203">      goto cleanup;</a>
<a name="ln3204">    }</a>
<a name="ln3205"> </a>
<a name="ln3206">    dev_profile_info_to</a>
<a name="ln3207">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_to_cl), &amp;profile_info_to_cl);</a>
<a name="ln3208">    if(dev_profile_info_to == NULL)</a>
<a name="ln3209">    {</a>
<a name="ln3210">      fprintf(stderr,</a>
<a name="ln3211">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 7\n&quot;);</a>
<a name="ln3212">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3213">      goto cleanup;</a>
<a name="ln3214">    }</a>
<a name="ln3215">    dev_lut_to = dt_opencl_copy_host_to_device(devid, lut_to_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln3216">    if(dev_lut_to == NULL)</a>
<a name="ln3217">    {</a>
<a name="ln3218">      fprintf(stderr,</a>
<a name="ln3219">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 8\n&quot;);</a>
<a name="ln3220">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3221">      goto cleanup;</a>
<a name="ln3222">    }</a>
<a name="ln3223"> </a>
<a name="ln3224">    size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3225"> </a>
<a name="ln3226">    dt_opencl_set_kernel_arg(devid, kernel_transform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3227">    dt_opencl_set_kernel_arg(devid, kernel_transform, 1, sizeof(cl_mem), (void *)&amp;dev_img_out);</a>
<a name="ln3228">    dt_opencl_set_kernel_arg(devid, kernel_transform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3229">    dt_opencl_set_kernel_arg(devid, kernel_transform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3230">    dt_opencl_set_kernel_arg(devid, kernel_transform, 4, sizeof(cl_mem), (void *)&amp;dev_profile_info_from);</a>
<a name="ln3231">    dt_opencl_set_kernel_arg(devid, kernel_transform, 5, sizeof(cl_mem), (void *)&amp;dev_lut_from);</a>
<a name="ln3232">    dt_opencl_set_kernel_arg(devid, kernel_transform, 6, sizeof(cl_mem), (void *)&amp;dev_profile_info_to);</a>
<a name="ln3233">    dt_opencl_set_kernel_arg(devid, kernel_transform, 7, sizeof(cl_mem), (void *)&amp;dev_lut_to);</a>
<a name="ln3234">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_transform, sizes);</a>
<a name="ln3235">    if(err != CL_SUCCESS)</a>
<a name="ln3236">    {</a>
<a name="ln3237">      fprintf(stderr,</a>
<a name="ln3238">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error %i enqueue kernel for color transformation\n&quot;,</a>
<a name="ln3239">              err);</a>
<a name="ln3240">      goto cleanup;</a>
<a name="ln3241">    }</a>
<a name="ln3242"> </a>
<a name="ln3243">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln3244">    {</a>
<a name="ln3245">      dt_get_times(&amp;end_time);</a>
<a name="ln3246">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f GPU) [%s]\n&quot;,</a>
<a name="ln3247">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln3248">    }</a>
<a name="ln3249">  }</a>
<a name="ln3250">  else</a>
<a name="ln3251">  {</a>
<a name="ln3252">    // no matrix, call lcms2</a>
<a name="ln3253">    src_buffer = dt_alloc_align(64, width * height * ch * sizeof(float));</a>
<a name="ln3254">    if(src_buffer == NULL)</a>
<a name="ln3255">    {</a>
<a name="ln3256">      fprintf(stderr,</a>
<a name="ln3257">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 1\n&quot;);</a>
<a name="ln3258">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln3259">      goto cleanup;</a>
<a name="ln3260">    }</a>
<a name="ln3261"> </a>
<a name="ln3262">    err = dt_opencl_copy_device_to_host(devid, src_buffer, dev_img_in, width, height, ch * sizeof(float));</a>
<a name="ln3263">    if(err != CL_SUCCESS)</a>
<a name="ln3264">    {</a>
<a name="ln3265">      fprintf(stderr,</a>
<a name="ln3266">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 2\n&quot;);</a>
<a name="ln3267">      goto cleanup;</a>
<a name="ln3268">    }</a>
<a name="ln3269"> </a>
<a name="ln3270">    // just call the CPU version for now</a>
<a name="ln3271">    dt_ioppr_transform_image_colorspace_rgb(src_buffer, src_buffer, width, height, profile_info_from,</a>
<a name="ln3272">                                            profile_info_to, message);</a>
<a name="ln3273"> </a>
<a name="ln3274">    err = dt_opencl_write_host_to_device(devid, src_buffer, dev_img_out, width, height, ch * sizeof(float));</a>
<a name="ln3275">    if(err != CL_SUCCESS)</a>
<a name="ln3276">    {</a>
<a name="ln3277">      fprintf(stderr,</a>
<a name="ln3278">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 3\n&quot;);</a>
<a name="ln3279">      goto cleanup;</a>
<a name="ln3280">    }</a>
<a name="ln3281">  }</a>
<a name="ln3282"> </a>
<a name="ln3283">cleanup:</a>
<a name="ln3284">  if(src_buffer) dt_free_align(src_buffer);</a>
<a name="ln3285">  if(dev_tmp &amp;&amp; in_place) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3286"> </a>
<a name="ln3287">  if(dev_profile_info_from) dt_opencl_release_mem_object(dev_profile_info_from);</a>
<a name="ln3288">  if(dev_lut_from) dt_opencl_release_mem_object(dev_lut_from);</a>
<a name="ln3289">  if(lut_from_cl) free(lut_from_cl);</a>
<a name="ln3290"> </a>
<a name="ln3291">  if(dev_profile_info_to) dt_opencl_release_mem_object(dev_profile_info_to);</a>
<a name="ln3292">  if(dev_lut_to) dt_opencl_release_mem_object(dev_lut_to);</a>
<a name="ln3293">  if(lut_to_cl) free(lut_to_cl);</a>
<a name="ln3294"> </a>
<a name="ln3295">  return (err == CL_SUCCESS) ? TRUE : FALSE;</a>
<a name="ln3296">}</a>
<a name="ln3297">#endif</a>
<a name="ln3298"> </a>
<a name="ln3299">#undef DT_IOP_ORDER_INFO // used while debugging</a>

</code></pre>
<div class="balloon" rel="252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'rule'. Check lines: 252, 250.</p></div>
<div class="balloon" rel="347"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'order_entry'. Check lines: 347, 345.</p></div>
<div class="balloon" rel="403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'iop_order_new'. Check lines: 403, 402.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 846, 845.</p></div>
<div class="balloon" rel="1879"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="1957"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="2076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'profile_info->lut_in[i]'. Check lines: 2076, 2075.</p></div>
<div class="balloon" rel="2078"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'profile_info->lut_out[i]'. Check lines: 2078, 2077.</p></div>
<div class="balloon" rel="2063"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'profile_info' might take place. The potential null pointer is passed into 'dt_ioppr_init_profile_info' function. Inspect the first argument. Check lines: 2063, 2218, 2217.</p></div>
<div class="balloon" rel="2798"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 2798, 2795.</p></div>
<div class="balloon" rel="2821"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'profile_info_cl' might take place. The potential null pointer is passed into 'dt_ioppr_get_profile_info_cl' function. Inspect the second argument. Check lines: 2821, 2867, 2860.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
