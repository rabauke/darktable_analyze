
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2018 edgardo hoszowski.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln24">#include &quot;common/iop_order.h&quot;</a>
<a name="ln25">#include &quot;develop/imageop.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln27">#include &quot;develop/pixelpipe.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;stdio.h&gt;</a>
<a name="ln30">#include &lt;stdlib.h&gt;</a>
<a name="ln31">#include &lt;string.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#define DT_IOP_ORDER_VERSION 2</a>
<a name="ln34"> </a>
<a name="ln35">static void _ioppr_insert_iop_after(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_previous, const int dont_move);</a>
<a name="ln36">static void _ioppr_insert_iop_before(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_next, const int dont_move);</a>
<a name="ln37">static void _ioppr_move_iop_after(GList **_iop_order_list, const char *op_current, const char *op_prev, const int dont_move);</a>
<a name="ln38">static void _ioppr_move_iop_before(GList **_iop_order_list, const char *op_current, const char *op_next, const int dont_move);</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">/* migrates *_iop_order_list from old_version to the next version (version + 1)</a>
<a name="ln42"> * limitations:</a>
<a name="ln43"> * - to move an existing module that is always enabled a new version must be created, otherwise</a>
<a name="ln44"> *   modules can be added/moved in the current version</a>
<a name="ln45"> * - a module can't be more than once on the same version</a>
<a name="ln46"> */</a>
<a name="ln47">static int _ioppr_legacy_iop_order_step(GList **_iop_order_list, GList *history_list, const int old_version, const int dont_move)</a>
<a name="ln48">{</a>
<a name="ln49">  int new_version = -1;</a>
<a name="ln50">  </a>
<a name="ln51">  if(0) // I left this for now so I don't get the unused error, we'll add some modules soon and we'll remove it</a>
<a name="ln52">  {</a>
<a name="ln53">    _ioppr_insert_iop_before(_iop_order_list, history_list, &quot;dummy1&quot;, &quot;colorin&quot;, dont_move);</a>
<a name="ln54">  }</a>
<a name="ln55"> </a>
<a name="ln56">  // version 1 --&gt; 2</a>
<a name="ln57">  if(old_version == 1)</a>
<a name="ln58">  {</a>
<a name="ln59">    _ioppr_move_iop_after(_iop_order_list, &quot;colorin&quot;, &quot;demosaic&quot;, dont_move);</a>
<a name="ln60">    _ioppr_move_iop_before(_iop_order_list, &quot;colorout&quot;, &quot;clahe&quot;, dont_move);</a>
<a name="ln61">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;basicadj&quot;, &quot;colorin&quot;, dont_move);</a>
<a name="ln62">    _ioppr_insert_iop_after(_iop_order_list, history_list, &quot;rgbcurve&quot;, &quot;levels&quot;, dont_move);</a>
<a name="ln63"> </a>
<a name="ln64">    new_version = 2;</a>
<a name="ln65">  }</a>
<a name="ln66"> </a>
<a name="ln67">  if(new_version &lt;= 0)</a>
<a name="ln68">    fprintf(stderr, &quot;[_ioppr_legacy_iop_order_step] missing step migrating from version %i\n&quot;, old_version);</a>
<a name="ln69">  </a>
<a name="ln70">  return new_version;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">// returns a list of dt_iop_order_rule_t</a>
<a name="ln74">// this do not have versions</a>
<a name="ln75">GList *dt_ioppr_get_iop_order_rules()</a>
<a name="ln76">{</a>
<a name="ln77">  GList *rules = NULL;</a>
<a name="ln78"> </a>
<a name="ln79">  const dt_iop_order_rule_t rule_entry[] = { { &quot;rawprepare&quot;, &quot;invert&quot; },</a>
<a name="ln80">                                                { &quot;invert&quot;, &quot;temperature&quot; },</a>
<a name="ln81">                                                { &quot;temperature&quot;, &quot;highlights&quot; },</a>
<a name="ln82">                                                { &quot;highlights&quot;, &quot;cacorrect&quot; },</a>
<a name="ln83">                                                { &quot;cacorrect&quot;, &quot;hotpixels&quot; },</a>
<a name="ln84">                                                { &quot;hotpixels&quot;, &quot;rawdenoise&quot; },</a>
<a name="ln85">                                                { &quot;rawdenoise&quot;, &quot;demosaic&quot; },</a>
<a name="ln86">                                                { &quot;demosaic&quot;, &quot;colorin&quot; },</a>
<a name="ln87">                                                { &quot;colorin&quot;, &quot;colorout&quot; },</a>
<a name="ln88">                                                { &quot;colorout&quot;, &quot;gamma&quot; },</a>
<a name="ln89">                                                { &quot;\0&quot;, &quot;\0&quot; } };</a>
<a name="ln90"> </a>
<a name="ln91">  int i = 0;</a>
<a name="ln92">  while(rule_entry[i].op_prev[0])</a>
<a name="ln93">  {</a>
<a name="ln94">    dt_iop_order_rule_t *rule = calloc(1, sizeof(dt_iop_order_rule_t));</a>
<a name="ln95"> </a>
<a name="ln96">    snprintf(rule-&gt;op_prev, sizeof(rule-&gt;op_prev), &quot;%s&quot;, rule_entry[i].op_prev);</a>
<a name="ln97">    snprintf(rule-&gt;op_next, sizeof(rule-&gt;op_next), &quot;%s&quot;, rule_entry[i].op_next);</a>
<a name="ln98"> </a>
<a name="ln99">    rules = g_list_append(rules, rule);</a>
<a name="ln100">    i++;</a>
<a name="ln101">  }</a>
<a name="ln102"> </a>
<a name="ln103">  return rules;</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">// first version of iop order, must never be modified</a>
<a name="ln107">// it returns a list with the default iop_order per module, starting at 1.0, increment by 1.0</a>
<a name="ln108">static GList *_ioppr_get_iop_order_v1()</a>
<a name="ln109">{</a>
<a name="ln110">  GList *iop_order_list = NULL;</a>
<a name="ln111"> </a>
<a name="ln112">  const dt_iop_order_entry_t prior_entry[] = { { 0.0, &quot;rawprepare&quot; },</a>
<a name="ln113">                                                  { 0.0, &quot;invert&quot; },</a>
<a name="ln114">                                                  { 0.0, &quot;temperature&quot; },</a>
<a name="ln115">                                                  { 0.0, &quot;highlights&quot; },</a>
<a name="ln116">                                                  { 0.0, &quot;cacorrect&quot; },</a>
<a name="ln117">                                                  { 0.0, &quot;hotpixels&quot; },</a>
<a name="ln118">                                                  { 0.0, &quot;rawdenoise&quot; },</a>
<a name="ln119">                                                  { 0.0, &quot;demosaic&quot; },</a>
<a name="ln120">                                                  { 0.0, &quot;mask_manager&quot; },</a>
<a name="ln121">                                                  { 0.0, &quot;denoiseprofile&quot; },</a>
<a name="ln122">                                                  { 0.0, &quot;tonemap&quot; },</a>
<a name="ln123">                                                  { 0.0, &quot;exposure&quot; },</a>
<a name="ln124">                                                  { 0.0, &quot;spots&quot; },</a>
<a name="ln125">                                                  { 0.0, &quot;retouch&quot; },</a>
<a name="ln126">                                                  { 0.0, &quot;lens&quot; },</a>
<a name="ln127">                                                  { 0.0, &quot;ashift&quot; },</a>
<a name="ln128">                                                  { 0.0, &quot;liquify&quot; },</a>
<a name="ln129">                                                  { 0.0, &quot;rotatepixels&quot; },</a>
<a name="ln130">                                                  { 0.0, &quot;scalepixels&quot; },</a>
<a name="ln131">                                                  { 0.0, &quot;flip&quot; },</a>
<a name="ln132">                                                  { 0.0, &quot;clipping&quot; },</a>
<a name="ln133">                                                  { 0.0, &quot;graduatednd&quot; },</a>
<a name="ln134">                                                  { 0.0, &quot;basecurve&quot; },</a>
<a name="ln135">                                                  { 0.0, &quot;bilateral&quot; },</a>
<a name="ln136">                                                  { 0.0, &quot;profile_gamma&quot; },</a>
<a name="ln137">                                                  { 0.0, &quot;hazeremoval&quot; },</a>
<a name="ln138">                                                  { 0.0, &quot;colorin&quot; },</a>
<a name="ln139">                                                  { 0.0, &quot;colorreconstruct&quot; },</a>
<a name="ln140">                                                  { 0.0, &quot;colorchecker&quot; },</a>
<a name="ln141">                                                  { 0.0, &quot;defringe&quot; },</a>
<a name="ln142">                                                  { 0.0, &quot;equalizer&quot; },</a>
<a name="ln143">                                                  { 0.0, &quot;vibrance&quot; },</a>
<a name="ln144">                                                  { 0.0, &quot;colorbalance&quot; },</a>
<a name="ln145">                                                  { 0.0, &quot;colorize&quot; },</a>
<a name="ln146">                                                  { 0.0, &quot;colortransfer&quot; },</a>
<a name="ln147">                                                  { 0.0, &quot;colormapping&quot; },</a>
<a name="ln148">                                                  { 0.0, &quot;bloom&quot; },</a>
<a name="ln149">                                                  { 0.0, &quot;nlmeans&quot; },</a>
<a name="ln150">                                                  { 0.0, &quot;globaltonemap&quot; },</a>
<a name="ln151">                                                  { 0.0, &quot;shadhi&quot; },</a>
<a name="ln152">                                                  { 0.0, &quot;atrous&quot; },</a>
<a name="ln153">                                                  { 0.0, &quot;bilat&quot; },</a>
<a name="ln154">                                                  { 0.0, &quot;colorzones&quot; },</a>
<a name="ln155">                                                  { 0.0, &quot;lowlight&quot; },</a>
<a name="ln156">                                                  { 0.0, &quot;monochrome&quot; },</a>
<a name="ln157">                                                  { 0.0, &quot;filmic&quot; },</a>
<a name="ln158">                                                  { 0.0, &quot;colisa&quot; },</a>
<a name="ln159">                                                  { 0.0, &quot;zonesystem&quot; },</a>
<a name="ln160">                                                  { 0.0, &quot;tonecurve&quot; },</a>
<a name="ln161">                                                  { 0.0, &quot;levels&quot; },</a>
<a name="ln162">                                                  { 0.0, &quot;relight&quot; },</a>
<a name="ln163">                                                  { 0.0, &quot;colorcorrection&quot; },</a>
<a name="ln164">                                                  { 0.0, &quot;sharpen&quot; },</a>
<a name="ln165">                                                  { 0.0, &quot;lowpass&quot; },</a>
<a name="ln166">                                                  { 0.0, &quot;highpass&quot; },</a>
<a name="ln167">                                                  { 0.0, &quot;grain&quot; },</a>
<a name="ln168">                                                  { 0.0, &quot;colorcontrast&quot; },</a>
<a name="ln169">                                                  { 0.0, &quot;colorout&quot; },</a>
<a name="ln170">                                                  { 0.0, &quot;channelmixer&quot; },</a>
<a name="ln171">                                                  { 0.0, &quot;soften&quot; },</a>
<a name="ln172">                                                  { 0.0, &quot;vignette&quot; },</a>
<a name="ln173">                                                  { 0.0, &quot;splittoning&quot; },</a>
<a name="ln174">                                                  { 0.0, &quot;velvia&quot; },</a>
<a name="ln175">                                                  { 0.0, &quot;clahe&quot; },</a>
<a name="ln176">                                                  { 0.0, &quot;finalscale&quot; },</a>
<a name="ln177">                                                  { 0.0, &quot;overexposed&quot; },</a>
<a name="ln178">                                                  { 0.0, &quot;rawoverexposed&quot; },</a>
<a name="ln179">                                                  { 0.0, &quot;borders&quot; },</a>
<a name="ln180">                                                  { 0.0, &quot;watermark&quot; },</a>
<a name="ln181">                                                  { 0.0, &quot;dither&quot; },</a>
<a name="ln182">                                                  { 0.0, &quot;gamma&quot; },</a>
<a name="ln183">                                                  { 0.0, &quot;\0&quot; }</a>
<a name="ln184">  };</a>
<a name="ln185"> </a>
<a name="ln186">  int i = 0;</a>
<a name="ln187">  while(prior_entry[i].operation[0] != '\0')</a>
<a name="ln188">  {</a>
<a name="ln189">    dt_iop_order_entry_t *order_entry = calloc(1, sizeof(dt_iop_order_entry_t));</a>
<a name="ln190"> </a>
<a name="ln191">    order_entry-&gt;iop_order = (double)(i + 1);</a>
<a name="ln192">    snprintf(order_entry-&gt;operation, sizeof(order_entry-&gt;operation), &quot;%s&quot;, prior_entry[i].operation);</a>
<a name="ln193"> </a>
<a name="ln194">    iop_order_list = g_list_append(iop_order_list, order_entry);</a>
<a name="ln195">    i++;</a>
<a name="ln196">  }</a>
<a name="ln197"> </a>
<a name="ln198">  return iop_order_list;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">// returns the first iop order entry that matches operation == op_name</a>
<a name="ln202">dt_iop_order_entry_t *dt_ioppr_get_iop_order_entry(GList *iop_order_list, const char *op_name)</a>
<a name="ln203">{</a>
<a name="ln204">  dt_iop_order_entry_t *iop_order_entry = NULL;</a>
<a name="ln205">  </a>
<a name="ln206">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln207">  while(iops_order)</a>
<a name="ln208">  {</a>
<a name="ln209">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln210"> </a>
<a name="ln211">    if(strcmp(order_entry-&gt;operation, op_name) == 0)</a>
<a name="ln212">    {</a>
<a name="ln213">      iop_order_entry = order_entry;</a>
<a name="ln214">      break;</a>
<a name="ln215">    }</a>
<a name="ln216"> </a>
<a name="ln217">    iops_order = g_list_next(iops_order);</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  return iop_order_entry;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">// returns the iop_order asociated with the iop order entry that matches operation == op_name</a>
<a name="ln224">double dt_ioppr_get_iop_order(GList *iop_order_list, const char *op_name)</a>
<a name="ln225">{</a>
<a name="ln226">  double iop_order = DBL_MAX;</a>
<a name="ln227">  dt_iop_order_entry_t *order_entry = dt_ioppr_get_iop_order_entry(iop_order_list, op_name);</a>
<a name="ln228">  </a>
<a name="ln229">  if(order_entry)</a>
<a name="ln230">    iop_order = order_entry-&gt;iop_order;</a>
<a name="ln231"> </a>
<a name="ln232">  return iop_order;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">// insert op_new before op_next on *_iop_order_list</a>
<a name="ln236">// it sets the iop_order on op_new</a>
<a name="ln237">// if check_history == 1 it check that the generated iop_order do not exists on any module in history</a>
<a name="ln238">static void _ioppr_insert_iop_before(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_next, const int check_history)</a>
<a name="ln239">{</a>
<a name="ln240">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln241">  </a>
<a name="ln242">  // check that the new operation don't exists on the list</a>
<a name="ln243">  if(dt_ioppr_get_iop_order_entry(iop_order_list, op_new) == NULL)</a>
<a name="ln244">  {</a>
<a name="ln245">    // create a new iop order entry</a>
<a name="ln246">    dt_iop_order_entry_t *iop_order_new = (dt_iop_order_entry_t*)calloc(1, sizeof(dt_iop_order_entry_t));</a>
<a name="ln247">    snprintf(iop_order_new-&gt;operation, sizeof(iop_order_new-&gt;operation), &quot;%s&quot;, op_new);</a>
<a name="ln248">    </a>
<a name="ln249">    // search for the previous one</a>
<a name="ln250">    int position = 0;</a>
<a name="ln251">    int found = 0;</a>
<a name="ln252">    double iop_order_prev = DBL_MAX;</a>
<a name="ln253">    double iop_order_next = DBL_MAX;</a>
<a name="ln254">    GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln255">    while(iops_order)</a>
<a name="ln256">    {</a>
<a name="ln257">      dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln258">      if(strcmp(order_entry-&gt;operation, op_next) == 0)</a>
<a name="ln259">      {</a>
<a name="ln260">        iop_order_next = order_entry-&gt;iop_order;</a>
<a name="ln261">        found = 1;</a>
<a name="ln262">        break;</a>
<a name="ln263">      }</a>
<a name="ln264">      iop_order_prev = order_entry-&gt;iop_order;</a>
<a name="ln265">      position++;</a>
<a name="ln266">      </a>
<a name="ln267">      iops_order = g_list_next(iops_order);</a>
<a name="ln268">    }</a>
<a name="ln269">    </a>
<a name="ln270">    // now we have to check if there's a module with iop_order between iop_order_prev and iop_order_next</a>
<a name="ln271">    if(found)</a>
<a name="ln272">    {</a>
<a name="ln273">      if(!check_history)</a>
<a name="ln274">      {</a>
<a name="ln275">        GList *history = g_list_first(history_list);</a>
<a name="ln276">        while(history)</a>
<a name="ln277">        {</a>
<a name="ln278">          dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln279">          </a>
<a name="ln280">          if(hist-&gt;iop_order &gt;= iop_order_prev &amp;&amp; hist-&gt;iop_order &lt;= iop_order_next)</a>
<a name="ln281">            iop_order_prev = hist-&gt;iop_order;</a>
<a name="ln282">          </a>
<a name="ln283">          history = g_list_next(history);</a>
<a name="ln284">        }</a>
<a name="ln285">      }</a>
<a name="ln286">    }</a>
<a name="ln287">    else</a>
<a name="ln288">      fprintf(stderr, &quot;[_ioppr_insert_iop_before] module %s don't exists on iop order list\n&quot;, op_next);</a>
<a name="ln289">    </a>
<a name="ln290">    if(found)</a>
<a name="ln291">    {</a>
<a name="ln292">      // set the iop_order</a>
<a name="ln293">      iop_order_new-&gt;iop_order = iop_order_prev + (iop_order_next - iop_order_prev) / 2.0;</a>
<a name="ln294">      </a>
<a name="ln295">      // insert it on the proper order</a>
<a name="ln296">      iop_order_list = g_list_insert(iop_order_list, iop_order_new, position);</a>
<a name="ln297">    }</a>
<a name="ln298">  }</a>
<a name="ln299">  else</a>
<a name="ln300">    fprintf(stderr, &quot;[_ioppr_insert_iop_before] module %s already exists on iop order list\n&quot;, op_new);</a>
<a name="ln301"> </a>
<a name="ln302">  *_iop_order_list = iop_order_list;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">// insert op_new after op_prev on *_iop_order_list</a>
<a name="ln306">// it updates the iop_order on op_new</a>
<a name="ln307">// if check_history == 1 it check that the generated iop_order do not exists on any module in history</a>
<a name="ln308">static void _ioppr_insert_iop_after(GList **_iop_order_list, GList *history_list, const char *op_new, const char *op_prev, const int check_history)</a>
<a name="ln309">{</a>
<a name="ln310">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln311">  </a>
<a name="ln312">  // inserting after op_prev is the same as moving before the very next one after op_prev</a>
<a name="ln313">  dt_iop_order_entry_t *prior_next = NULL;</a>
<a name="ln314">  GList *iops_order = g_list_last(iop_order_list);</a>
<a name="ln315">  while(iops_order)</a>
<a name="ln316">  {</a>
<a name="ln317">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)iops_order-&gt;data;</a>
<a name="ln318">    if(strcmp(order_entry-&gt;operation, op_prev) == 0) break;</a>
<a name="ln319"> </a>
<a name="ln320">    prior_next = order_entry;</a>
<a name="ln321">    iops_order = g_list_previous(iops_order);</a>
<a name="ln322">  }</a>
<a name="ln323">  if(prior_next == NULL)</a>
<a name="ln324">  {</a>
<a name="ln325">    fprintf(</a>
<a name="ln326">        stderr,</a>
<a name="ln327">        &quot;[_ioppr_insert_iop_after] can't find module previous to %s while moving %s after it\n&quot;,</a>
<a name="ln328">        op_prev, op_new);</a>
<a name="ln329">  }</a>
<a name="ln330">  else</a>
<a name="ln331">    _ioppr_insert_iop_before(&amp;iop_order_list, history_list, op_new, prior_next-&gt;operation, check_history);</a>
<a name="ln332"> </a>
<a name="ln333">  *_iop_order_list = iop_order_list;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">// moves op_current before op_next by updating the iop_order</a>
<a name="ln337">// only if dont_move == FALSE</a>
<a name="ln338">static void _ioppr_move_iop_before(GList **_iop_order_list, const char *op_current, const char *op_next, const int dont_move)</a>
<a name="ln339">{</a>
<a name="ln340">  if(dont_move) return;</a>
<a name="ln341">  </a>
<a name="ln342">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln343">  </a>
<a name="ln344">  int position = 0;</a>
<a name="ln345">  int found = 0;</a>
<a name="ln346">  dt_iop_order_entry_t *iop_order_prev = NULL;</a>
<a name="ln347">  dt_iop_order_entry_t *iop_order_next = NULL;</a>
<a name="ln348">  dt_iop_order_entry_t *iop_order_current = NULL;</a>
<a name="ln349">  GList *iops_order_current = NULL;</a>
<a name="ln350">  </a>
<a name="ln351">  // search for the current one</a>
<a name="ln352">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln353">  while(iops_order)</a>
<a name="ln354">  {</a>
<a name="ln355">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln356">    if(strcmp(order_entry-&gt;operation, op_current) == 0)</a>
<a name="ln357">    {</a>
<a name="ln358">      iops_order_current = iops_order;</a>
<a name="ln359">      iop_order_current = order_entry;</a>
<a name="ln360">      found = 1;</a>
<a name="ln361">      break;</a>
<a name="ln362">    }</a>
<a name="ln363">    </a>
<a name="ln364">    iops_order = g_list_next(iops_order);</a>
<a name="ln365">  }</a>
<a name="ln366"> </a>
<a name="ln367">  if(found)</a>
<a name="ln368">  {</a>
<a name="ln369">    // remove it from the list</a>
<a name="ln370">    iop_order_list = g_list_remove_link(iop_order_list, iops_order_current);</a>
<a name="ln371">  }</a>
<a name="ln372">  else</a>
<a name="ln373">    fprintf(stderr, &quot;[_ioppr_move_iop_before] current module %s don't exists on iop order list\n&quot;, op_current);</a>
<a name="ln374"> </a>
<a name="ln375">  // search for the previous and next one</a>
<a name="ln376">  if(found)</a>
<a name="ln377">  {</a>
<a name="ln378">    found = 0;</a>
<a name="ln379">    iops_order = g_list_first(iop_order_list);</a>
<a name="ln380">    while(iops_order)</a>
<a name="ln381">    {</a>
<a name="ln382">      dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln383">      if(strcmp(order_entry-&gt;operation, op_next) == 0)</a>
<a name="ln384">      {</a>
<a name="ln385">        iop_order_next = order_entry;</a>
<a name="ln386">        found = 1;</a>
<a name="ln387">        break;</a>
<a name="ln388">      }</a>
<a name="ln389">      iop_order_prev = order_entry;</a>
<a name="ln390">      position++;</a>
<a name="ln391">      </a>
<a name="ln392">      iops_order = g_list_next(iops_order);</a>
<a name="ln393">    }</a>
<a name="ln394">  }</a>
<a name="ln395">  </a>
<a name="ln396">  if(found)</a>
<a name="ln397">  {</a>
<a name="ln398">    // set the iop_order</a>
<a name="ln399">    iop_order_current-&gt;iop_order = iop_order_prev-&gt;iop_order + (iop_order_next-&gt;iop_order - iop_order_prev-&gt;iop_order) / 2.0;</a>
<a name="ln400">    </a>
<a name="ln401">    // insert it on the proper order</a>
<a name="ln402">    iop_order_list = g_list_insert(iop_order_list, iop_order_current, position);</a>
<a name="ln403">  }</a>
<a name="ln404">  else</a>
<a name="ln405">    fprintf(stderr, &quot;[_ioppr_move_iop_before] next module %s don't exists on iop order list\n&quot;, op_next);</a>
<a name="ln406"> </a>
<a name="ln407">  *_iop_order_list = iop_order_list;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">// moves op_current after op_prev by updating the iop_order</a>
<a name="ln411">// only if dont_move == FALSE</a>
<a name="ln412">static void _ioppr_move_iop_after(GList **_iop_order_list, const char *op_current, const char *op_prev, const int dont_move)</a>
<a name="ln413">{</a>
<a name="ln414">  if(dont_move) return;</a>
<a name="ln415">  </a>
<a name="ln416">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln417">  </a>
<a name="ln418">  // moving after op_prev is the same as moving before the very next one after op_prev</a>
<a name="ln419">  dt_iop_order_entry_t *prior_next = NULL;</a>
<a name="ln420">  GList *iops_order = g_list_last(iop_order_list);</a>
<a name="ln421">  while(iops_order)</a>
<a name="ln422">  {</a>
<a name="ln423">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)iops_order-&gt;data;</a>
<a name="ln424">    if(strcmp(order_entry-&gt;operation, op_prev) == 0) break;</a>
<a name="ln425"> </a>
<a name="ln426">    prior_next = order_entry;</a>
<a name="ln427">    iops_order = g_list_previous(iops_order);</a>
<a name="ln428">  }</a>
<a name="ln429">  if(prior_next == NULL)</a>
<a name="ln430">  {</a>
<a name="ln431">    fprintf(</a>
<a name="ln432">        stderr,</a>
<a name="ln433">        &quot;[_ioppr_move_iop_after] can't find module previous to %s while moving %s after it\n&quot;,</a>
<a name="ln434">        op_prev, op_current);</a>
<a name="ln435">  }</a>
<a name="ln436">  else</a>
<a name="ln437">    _ioppr_move_iop_before(&amp;iop_order_list, op_current, prior_next-&gt;operation, dont_move);</a>
<a name="ln438"> </a>
<a name="ln439">  *_iop_order_list = iop_order_list;</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">// returns a list of dt_iop_order_entry_t</a>
<a name="ln443">// if *_version == 0 it returns the current version and updates *_version</a>
<a name="ln444">GList *dt_ioppr_get_iop_order_list(int *_version)</a>
<a name="ln445">{</a>
<a name="ln446">  GList *iop_order_list = _ioppr_get_iop_order_v1();</a>
<a name="ln447">  int old_version = 1;</a>
<a name="ln448">  const int version = ((_version == NULL) || (*_version == 0)) ? DT_IOP_ORDER_VERSION: *_version;</a>
<a name="ln449">  </a>
<a name="ln450">  while(old_version &lt; version &amp;&amp; old_version &gt; 0)</a>
<a name="ln451">  {</a>
<a name="ln452">    old_version = _ioppr_legacy_iop_order_step(&amp;iop_order_list, NULL, old_version, FALSE);</a>
<a name="ln453">  }</a>
<a name="ln454">  </a>
<a name="ln455">  if(old_version != version)</a>
<a name="ln456">  {</a>
<a name="ln457">    fprintf(stderr, &quot;[dt_ioppr_get_iop_order_list] error building iop_order_list to version %i\n&quot;, version);</a>
<a name="ln458">  }</a>
<a name="ln459">  </a>
<a name="ln460">  if(_version &amp;&amp; *_version == 0 &amp;&amp; old_version &gt; 0) *_version = old_version;</a>
<a name="ln461">  </a>
<a name="ln462">  return iop_order_list;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">// sets the iop_order on each module of *_iop_list</a>
<a name="ln466">// iop_order is set only for base modules, multi-instances will be flaged as unused with DBL_MAX</a>
<a name="ln467">// if a module do not exists on iop_order_list it is flaged as unused with DBL_MAX</a>
<a name="ln468">void dt_ioppr_set_default_iop_order(GList **_iop_list, GList *iop_order_list)</a>
<a name="ln469">{</a>
<a name="ln470">  GList *iop_list = *_iop_list;</a>
<a name="ln471">  </a>
<a name="ln472">  GList *modules = g_list_first(iop_list);</a>
<a name="ln473">  while(modules)</a>
<a name="ln474">  {</a>
<a name="ln475">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln476"> </a>
<a name="ln477">    if(mod-&gt;multi_priority == 0)</a>
<a name="ln478">    {</a>
<a name="ln479">      mod-&gt;iop_order = dt_ioppr_get_iop_order(iop_order_list, mod-&gt;op);</a>
<a name="ln480">    }</a>
<a name="ln481">    // muti-instances will be set by read history</a>
<a name="ln482">    else</a>
<a name="ln483">    {</a>
<a name="ln484">      mod-&gt;iop_order = DBL_MAX;</a>
<a name="ln485">    }</a>
<a name="ln486">    </a>
<a name="ln487">    modules = g_list_next(modules);</a>
<a name="ln488">  }</a>
<a name="ln489">  // we need to set the right order</a>
<a name="ln490">  iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln491"> </a>
<a name="ln492">  *_iop_list = iop_list;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">// returns the first dt_dev_history_item_t on history_list where hist-&gt;module == mod</a>
<a name="ln496">static dt_dev_history_item_t *_ioppr_search_history_by_module(GList *history_list, dt_iop_module_t *mod)</a>
<a name="ln497">{</a>
<a name="ln498">  dt_dev_history_item_t *hist_entry = NULL;</a>
<a name="ln499">  </a>
<a name="ln500">  GList *history = g_list_first(history_list);</a>
<a name="ln501">  while(history)</a>
<a name="ln502">  {</a>
<a name="ln503">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln504">    </a>
<a name="ln505">    if(hist-&gt;module == mod)</a>
<a name="ln506">    {</a>
<a name="ln507">      hist_entry = hist;</a>
<a name="ln508">      break;</a>
<a name="ln509">    }</a>
<a name="ln510">    </a>
<a name="ln511">    history = g_list_next(history);</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  return hist_entry;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">// check if there's duplicate iop_order entries in iop_list</a>
<a name="ln518">// if so, updates the iop_order to be unique, but only if the module is disabled and not in history</a>
<a name="ln519">void dt_ioppr_check_duplicate_iop_order(GList **_iop_list, GList *history_list)</a>
<a name="ln520">{</a>
<a name="ln521">  GList *iop_list = *_iop_list;</a>
<a name="ln522">  dt_iop_module_t *mod_prev = NULL;</a>
<a name="ln523">  </a>
<a name="ln524">  // get the first module</a>
<a name="ln525">  GList *modules = g_list_first(iop_list);</a>
<a name="ln526">  if(modules)</a>
<a name="ln527">  {</a>
<a name="ln528">    mod_prev = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln529">    modules = g_list_next(modules);</a>
<a name="ln530">  }</a>
<a name="ln531">  // check for each module if iop_order is the same as the previous one</a>
<a name="ln532">  // if so, change it, but only if disabled and not in history</a>
<a name="ln533">  while(modules)</a>
<a name="ln534">  {</a>
<a name="ln535">    int reset_list = 0;</a>
<a name="ln536">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln537"> </a>
<a name="ln538">    if(mod-&gt;iop_order == mod_prev-&gt;iop_order &amp;&amp; mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln539">    {</a>
<a name="ln540">      int can_move = 0;</a>
<a name="ln541">      </a>
<a name="ln542">      if(!mod-&gt;enabled &amp;&amp; _ioppr_search_history_by_module(history_list, mod) == NULL)</a>
<a name="ln543">      {</a>
<a name="ln544">        can_move = 1;</a>
<a name="ln545">        </a>
<a name="ln546">        GList *modules1 = g_list_next(modules);</a>
<a name="ln547">        if(modules1)</a>
<a name="ln548">        {</a>
<a name="ln549">          dt_iop_module_t *mod_next = (dt_iop_module_t *)(modules1-&gt;data);</a>
<a name="ln550">          if(mod-&gt;iop_order != mod_next-&gt;iop_order)</a>
<a name="ln551">          {</a>
<a name="ln552">            mod-&gt;iop_order += (mod_next-&gt;iop_order - mod-&gt;iop_order) / 2.0;</a>
<a name="ln553">          }</a>
<a name="ln554">          else</a>
<a name="ln555">          {</a>
<a name="ln556">            dt_ioppr_check_duplicate_iop_order(&amp;modules, history_list);</a>
<a name="ln557">            reset_list = 1;</a>
<a name="ln558">          }</a>
<a name="ln559">        }</a>
<a name="ln560">        else</a>
<a name="ln561">        {</a>
<a name="ln562">          mod-&gt;iop_order += 1.0;</a>
<a name="ln563">        }</a>
<a name="ln564">      }</a>
<a name="ln565">      else if(!mod_prev-&gt;enabled &amp;&amp; _ioppr_search_history_by_module(history_list, mod_prev) == NULL)</a>
<a name="ln566">      {</a>
<a name="ln567">        can_move = 1;</a>
<a name="ln568">        </a>
<a name="ln569">        GList *modules1 = g_list_previous(modules);</a>
<a name="ln570">        if(modules1) modules1 = g_list_previous(modules1);</a>
<a name="ln571">        if(modules1)</a>
<a name="ln572">        {</a>
<a name="ln573">          dt_iop_module_t *mod_next = (dt_iop_module_t *)(modules1-&gt;data);</a>
<a name="ln574">          if(mod_prev-&gt;iop_order != mod_next-&gt;iop_order)</a>
<a name="ln575">          {</a>
<a name="ln576">            mod_prev-&gt;iop_order -= (mod_prev-&gt;iop_order - mod_next-&gt;iop_order) / 2.0;</a>
<a name="ln577">          }</a>
<a name="ln578">          else</a>
<a name="ln579">          {</a>
<a name="ln580">            can_move = 0;</a>
<a name="ln581">            fprintf(stderr, &quot;[dt_ioppr_check_duplicate_iop_order 1] modules %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;, </a>
<a name="ln582">                mod_prev-&gt;op, mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln583">          }</a>
<a name="ln584">        }</a>
<a name="ln585">        else</a>
<a name="ln586">        {</a>
<a name="ln587">          mod_prev-&gt;iop_order -= 0.5;</a>
<a name="ln588">        }</a>
<a name="ln589">      }</a>
<a name="ln590"> </a>
<a name="ln591">      if(!can_move)</a>
<a name="ln592">      {</a>
<a name="ln593">        fprintf(stderr, &quot;[dt_ioppr_check_duplicate_iop_order] modules %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;, </a>
<a name="ln594">            mod_prev-&gt;op, mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln595">      }</a>
<a name="ln596">    }</a>
<a name="ln597">    </a>
<a name="ln598">    if(reset_list)</a>
<a name="ln599">    {</a>
<a name="ln600">      modules = g_list_first(iop_list);</a>
<a name="ln601">      if(modules)</a>
<a name="ln602">      {</a>
<a name="ln603">        mod_prev = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln604">        modules = g_list_next(modules);</a>
<a name="ln605">      }</a>
<a name="ln606">    }</a>
<a name="ln607">    else</a>
<a name="ln608">    {</a>
<a name="ln609">      mod_prev = mod;</a>
<a name="ln610">      modules = g_list_next(modules);</a>
<a name="ln611">    }</a>
<a name="ln612">  }</a>
<a name="ln613">  </a>
<a name="ln614">  *_iop_list = iop_list;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">// upgrades iop &amp; iop order to current version</a>
<a name="ln618">void dt_ioppr_legacy_iop_order(GList **_iop_list, GList **_iop_order_list, GList *history_list, const int _old_version)</a>
<a name="ln619">{</a>
<a name="ln620">  GList *iop_list = *_iop_list;</a>
<a name="ln621">  GList *iop_order_list = *_iop_order_list;</a>
<a name="ln622">  int dt_version = DT_IOP_ORDER_VERSION;</a>
<a name="ln623">  int old_version = _old_version;</a>
<a name="ln624">  </a>
<a name="ln625">  // we want to add any module created after this version of iop_order</a>
<a name="ln626">  // but we won't move existing modules so only add methods will be executed</a>
<a name="ln627">  while(old_version &lt; dt_version &amp;&amp; old_version &gt; 0)</a>
<a name="ln628">  {</a>
<a name="ln629">    old_version = _ioppr_legacy_iop_order_step(&amp;iop_order_list, history_list, old_version, TRUE);</a>
<a name="ln630">  }</a>
<a name="ln631">  </a>
<a name="ln632">  // now that we have a list of iop_order for version new_version but with all new modules</a>
<a name="ln633">  // we take care of the iop_order of new modules on iop list</a>
<a name="ln634">  GList *modules = g_list_first(iop_list);</a>
<a name="ln635">  while(modules)</a>
<a name="ln636">  {</a>
<a name="ln637">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln638"> </a>
<a name="ln639">    if(mod-&gt;multi_priority == 0 &amp;&amp; mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln640">    {</a>
<a name="ln641">      mod-&gt;iop_order = dt_ioppr_get_iop_order(iop_order_list, mod-&gt;op);</a>
<a name="ln642">      if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln643">        fprintf(stderr, &quot;[dt_ioppr_legacy_iop_order] can't find iop_order for module %s\n&quot;, mod-&gt;op);</a>
<a name="ln644">    }</a>
<a name="ln645">    </a>
<a name="ln646">    modules = g_list_next(modules);</a>
<a name="ln647">  }</a>
<a name="ln648">  // we need to set the right order</a>
<a name="ln649">  iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln650">  </a>
<a name="ln651">  // and check for duplicates</a>
<a name="ln652">  dt_ioppr_check_duplicate_iop_order(&amp;iop_list, history_list);</a>
<a name="ln653"> </a>
<a name="ln654">  *_iop_list = iop_list;</a>
<a name="ln655">  *_iop_order_list = iop_order_list;</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">// check if all so modules on iop_list have a iop_order defined in iop_order_list</a>
<a name="ln659">int dt_ioppr_check_so_iop_order(GList *iop_list, GList *iop_order_list)</a>
<a name="ln660">{</a>
<a name="ln661">  int iop_order_missing = 0;</a>
<a name="ln662"> </a>
<a name="ln663">  // check if all the modules have their iop_order assigned</a>
<a name="ln664">  GList *modules = g_list_first(iop_list);</a>
<a name="ln665">  while(modules)</a>
<a name="ln666">  {</a>
<a name="ln667">    dt_iop_module_so_t *mod = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln668">    </a>
<a name="ln669">    dt_iop_order_entry_t *entry = dt_ioppr_get_iop_order_entry(iop_order_list, mod-&gt;op);</a>
<a name="ln670">    if(entry == NULL)</a>
<a name="ln671">    {</a>
<a name="ln672">      iop_order_missing = 1;</a>
<a name="ln673">      fprintf(stderr, &quot;[dt_ioppr_check_so_iop_order] missing iop_order for module %s\n&quot;, mod-&gt;op);</a>
<a name="ln674">    }</a>
<a name="ln675">    modules = g_list_next(modules);</a>
<a name="ln676">  }</a>
<a name="ln677"> </a>
<a name="ln678">  return iop_order_missing;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">static void *_dup_iop_order_entry(const void *src, gpointer data)</a>
<a name="ln682">{</a>
<a name="ln683">  dt_iop_order_entry_t *scr_entry = (dt_iop_order_entry_t *)src;</a>
<a name="ln684">  dt_iop_order_entry_t *new_entry = malloc(sizeof(dt_iop_order_entry_t));</a>
<a name="ln685">  memcpy(new_entry, scr_entry, sizeof(dt_iop_order_entry_t));</a>
<a name="ln686">  return (void *)new_entry;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">// returns a duplicate of iop_order_list</a>
<a name="ln690">GList *dt_ioppr_iop_order_copy_deep(GList *iop_order_list)</a>
<a name="ln691">{</a>
<a name="ln692">  return (GList *)g_list_copy_deep(iop_order_list, _dup_iop_order_entry, NULL);</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">// helper to sort a GList of dt_iop_module_t by iop_order</a>
<a name="ln696">gint dt_sort_iop_by_order(gconstpointer a, gconstpointer b)</a>
<a name="ln697">{</a>
<a name="ln698">  const dt_iop_module_t *am = (const dt_iop_module_t *)a;</a>
<a name="ln699">  const dt_iop_module_t *bm = (const dt_iop_module_t *)b;</a>
<a name="ln700">  if(am-&gt;iop_order &gt; bm-&gt;iop_order) return 1;</a>
<a name="ln701">  if(am-&gt;iop_order &lt; bm-&gt;iop_order) return -1;</a>
<a name="ln702">  return 0;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">// if module can be placed before than module_next on the pipe</a>
<a name="ln706">// it returns the new iop_order</a>
<a name="ln707">// if it cannot be placed it returns -1.0</a>
<a name="ln708">// this assums that the order is always positive</a>
<a name="ln709">double dt_ioppr_get_iop_order_before_iop(GList *iop_list, dt_iop_module_t *module, dt_iop_module_t *module_next,</a>
<a name="ln710">                                  const int validate_order, const int log_error)</a>
<a name="ln711">{</a>
<a name="ln712">  if((module-&gt;flags() &amp; IOP_FLAGS_FENCE) &amp;&amp; validate_order)</a>
<a name="ln713">  {</a>
<a name="ln714">    if(log_error)</a>
<a name="ln715">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] module %s(%f) is a fence, can't move it before %s %s(%f)\n&quot;, </a>
<a name="ln716">          module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln717">    return -1.0;</a>
<a name="ln718">  }</a>
<a name="ln719">  </a>
<a name="ln720">  double iop_order = -1.0;</a>
<a name="ln721">  </a>
<a name="ln722">  // module is before on the pipe</a>
<a name="ln723">  // move it up</a>
<a name="ln724">  if(module-&gt;iop_order &lt; module_next-&gt;iop_order)</a>
<a name="ln725">  {</a>
<a name="ln726">    // let's first search for module</a>
<a name="ln727">    GList *modules = g_list_first(iop_list);</a>
<a name="ln728">    while(modules)</a>
<a name="ln729">    {</a>
<a name="ln730">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln731">      if(mod == module) break;</a>
<a name="ln732">      modules = g_list_next(modules);</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    // we found the module</a>
<a name="ln736">    if(modules)</a>
<a name="ln737">    {</a>
<a name="ln738">      dt_iop_module_t *mod1 = NULL;</a>
<a name="ln739">      dt_iop_module_t *mod2 = NULL;</a>
<a name="ln740"> </a>
<a name="ln741">      // now search for module_next and the one previous to that, so iop_order can be calculated</a>
<a name="ln742">      // also check the rules</a>
<a name="ln743">      modules = g_list_next(modules);</a>
<a name="ln744">      while(modules)</a>
<a name="ln745">      {</a>
<a name="ln746">        dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln747">        </a>
<a name="ln748">        // if we reach module_next everithing is OK</a>
<a name="ln749">        if(mod == module_next)</a>
<a name="ln750">        {</a>
<a name="ln751">          mod2 = mod;</a>
<a name="ln752">          break;</a>
<a name="ln753">        }</a>
<a name="ln754">        </a>
<a name="ln755">        // check for rules</a>
<a name="ln756">        if(validate_order)</a>
<a name="ln757">        {</a>
<a name="ln758">          // check if module can be moved around this one</a>
<a name="ln759">          if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln760">          {</a>
<a name="ln761">            if(log_error)</a>
<a name="ln762">              fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't move %s %s(%f) pass %s %s(%f)\n&quot;, </a>
<a name="ln763">                  module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln764">            break;</a>
<a name="ln765">          }</a>
<a name="ln766">          </a>
<a name="ln767">          // is there a rule about swapping this two?</a>
<a name="ln768">          int rule_found = 0;</a>
<a name="ln769">          GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln770">          while(rules)</a>
<a name="ln771">          {</a>
<a name="ln772">            dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln773"> </a>
<a name="ln774">            if(strcmp(module-&gt;op, rule-&gt;op_prev) == 0 &amp;&amp; strcmp(mod-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln775">            {</a>
<a name="ln776">              if(log_error)</a>
<a name="ln777">                fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] found rule %s %s while moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln778">                        rule-&gt;op_prev, rule-&gt;op_next, module-&gt;op,  module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op,  module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln779">              rule_found = 1;</a>
<a name="ln780">              break;</a>
<a name="ln781">            }</a>
<a name="ln782"> </a>
<a name="ln783">            rules = g_list_next(rules);</a>
<a name="ln784">          }</a>
<a name="ln785">          if(rule_found) break;</a>
<a name="ln786">        }</a>
<a name="ln787">        </a>
<a name="ln788">        mod1 = mod;</a>
<a name="ln789">        modules = g_list_next(modules);</a>
<a name="ln790">      }</a>
<a name="ln791">      </a>
<a name="ln792">      // we reach the module_next module</a>
<a name="ln793">      if(mod2)</a>
<a name="ln794">      {</a>
<a name="ln795">        // this is already the previous module!</a>
<a name="ln796">        if(module == mod1)</a>
<a name="ln797">        {</a>
<a name="ln798">          if(log_error)</a>
<a name="ln799">            fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) is already previous to %s %s(%f)\n&quot;, </a>
<a name="ln800">                module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln801">        }</a>
<a name="ln802">        else if(mod1-&gt;iop_order == mod2-&gt;iop_order)</a>
<a name="ln803">        {</a>
<a name="ln804">          fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;, </a>
<a name="ln805">              mod1-&gt;op, mod1-&gt;multi_name, mod1-&gt;iop_order, mod2-&gt;op, mod2-&gt;multi_name, mod2-&gt;iop_order);</a>
<a name="ln806">        }</a>
<a name="ln807">        else</a>
<a name="ln808">        {</a>
<a name="ln809">          // calculate new iop_order</a>
<a name="ln810">          iop_order = mod1-&gt;iop_order + (mod2-&gt;iop_order - mod1-&gt;iop_order) / 2.0;</a>
<a name="ln811">          /* fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] 2-calculated new iop_order=%f for %s(%f) between %s(%f) and %s(%f)\n&quot;,</a>
<a name="ln812">                 iop_order, module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;iop_order, mod-&gt;op, mod-&gt;iop_order); */</a>
<a name="ln813">        }</a>
<a name="ln814">      }</a>
<a name="ln815">    }</a>
<a name="ln816">    else</a>
<a name="ln817">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't find module %s %s\n&quot;, module-&gt;op, module-&gt;multi_name);</a>
<a name="ln818">  }</a>
<a name="ln819">  // module is next on the pipe</a>
<a name="ln820">  // move it down</a>
<a name="ln821">  else if(module-&gt;iop_order &gt; module_next-&gt;iop_order)</a>
<a name="ln822">  {</a>
<a name="ln823">    // let's first search for module</a>
<a name="ln824">    GList *modules = g_list_last(iop_list);</a>
<a name="ln825">    while(modules)</a>
<a name="ln826">    {</a>
<a name="ln827">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln828">      if(mod == module) break;</a>
<a name="ln829">      modules = g_list_previous(modules);</a>
<a name="ln830">    }</a>
<a name="ln831"> </a>
<a name="ln832">    // we found the module</a>
<a name="ln833">    if(modules)</a>
<a name="ln834">    {</a>
<a name="ln835">      dt_iop_module_t *mod1 = NULL;</a>
<a name="ln836">      dt_iop_module_t *mod2 = NULL;</a>
<a name="ln837"> </a>
<a name="ln838">      // now search for module_next and the one next to that, so iop_order can be calculated</a>
<a name="ln839">      // also check the rules</a>
<a name="ln840">      modules = g_list_previous(modules);</a>
<a name="ln841">      while(modules)</a>
<a name="ln842">      {</a>
<a name="ln843">        dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln844">        </a>
<a name="ln845">        // we reach the module next to module_next, everithing is OK</a>
<a name="ln846">        if(mod2 != NULL)</a>
<a name="ln847">        {</a>
<a name="ln848">          mod1 = mod;</a>
<a name="ln849">          break;</a>
<a name="ln850">        }</a>
<a name="ln851"> </a>
<a name="ln852">        // check for rules</a>
<a name="ln853">        if(validate_order)</a>
<a name="ln854">        {</a>
<a name="ln855">          // check if module can be moved around this one</a>
<a name="ln856">          if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln857">          {</a>
<a name="ln858">            if(log_error)</a>
<a name="ln859">              fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't move %s %s(%f) pass %s %s(%f)\n&quot;, </a>
<a name="ln860">                  module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order);</a>
<a name="ln861">            break;</a>
<a name="ln862">          }</a>
<a name="ln863">          </a>
<a name="ln864">          // is there a rule about swapping this two?</a>
<a name="ln865">          int rule_found = 0;</a>
<a name="ln866">          GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln867">          while(rules)</a>
<a name="ln868">          {</a>
<a name="ln869">            dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln870"> </a>
<a name="ln871">            if(strcmp(mod-&gt;op, rule-&gt;op_prev) == 0 &amp;&amp; strcmp(module-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln872">            {</a>
<a name="ln873">              if(log_error)</a>
<a name="ln874">                fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] found rule %s %s while moving %s %s(%f) before %s %s(%f)\n&quot;,</a>
<a name="ln875">                        rule-&gt;op_prev, rule-&gt;op_next, module-&gt;op,  module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op,  module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln876">              rule_found = 1;</a>
<a name="ln877">              break;</a>
<a name="ln878">            }</a>
<a name="ln879"> </a>
<a name="ln880">            rules = g_list_next(rules);</a>
<a name="ln881">          }</a>
<a name="ln882">          if(rule_found) break;</a>
<a name="ln883">        }</a>
<a name="ln884">        </a>
<a name="ln885">        if(mod == module_next) mod2 = mod;</a>
<a name="ln886">        modules = g_list_previous(modules);</a>
<a name="ln887">      }</a>
<a name="ln888">      </a>
<a name="ln889">      // we reach the module_next module</a>
<a name="ln890">      if(mod1)</a>
<a name="ln891">      {</a>
<a name="ln892">        // this is already the previous module!</a>
<a name="ln893">        if(module == mod2)</a>
<a name="ln894">        {</a>
<a name="ln895">          if(log_error)</a>
<a name="ln896">            fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) is already previous to %s %s(%f)\n&quot;, </a>
<a name="ln897">                module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln898">        }</a>
<a name="ln899">        else if(mod1-&gt;iop_order == mod2-&gt;iop_order)</a>
<a name="ln900">        {</a>
<a name="ln901">          fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;, </a>
<a name="ln902">              mod1-&gt;op, mod1-&gt;multi_name, mod1-&gt;iop_order, mod2-&gt;op, mod2-&gt;multi_name, mod2-&gt;iop_order);</a>
<a name="ln903">        }</a>
<a name="ln904">        else</a>
<a name="ln905">        {</a>
<a name="ln906">          // calculate new iop_order</a>
<a name="ln907">          iop_order = mod1-&gt;iop_order + (mod2-&gt;iop_order - mod1-&gt;iop_order) / 2.0;</a>
<a name="ln908">          /* fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] 2-calculated new iop_order=%f for %s(%f) between %s(%f) and %s(%f)\n&quot;,</a>
<a name="ln909">                 iop_order, module-&gt;op, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;iop_order, mod-&gt;op, mod-&gt;iop_order); */</a>
<a name="ln910">        }</a>
<a name="ln911">      }</a>
<a name="ln912">    }</a>
<a name="ln913">    else</a>
<a name="ln914">      fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] can't find module %s %s\n&quot;, module-&gt;op, module-&gt;multi_name);</a>
<a name="ln915">  }</a>
<a name="ln916">  else</a>
<a name="ln917">  {</a>
<a name="ln918">    fprintf(stderr, &quot;[dt_ioppr_get_iop_order_before_iop] modules %s %s(%f) and %s %s(%f) has the same iop_order\n&quot;, </a>
<a name="ln919">        module-&gt;op, module-&gt;multi_name, module-&gt;iop_order, module_next-&gt;op, module_next-&gt;multi_name, module_next-&gt;iop_order);</a>
<a name="ln920">  }</a>
<a name="ln921">  </a>
<a name="ln922">  return iop_order;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">// if module can be placed after than module_prev on the pipe</a>
<a name="ln926">// it returns the new iop_order</a>
<a name="ln927">// if it cannot be placed it returns -1.0</a>
<a name="ln928">// this assums that the order is always positive</a>
<a name="ln929">double dt_ioppr_get_iop_order_after_iop(GList *iop_list, dt_iop_module_t *module, dt_iop_module_t *module_prev,</a>
<a name="ln930">                                 const int validate_order, const int log_error)</a>
<a name="ln931">{</a>
<a name="ln932">  double iop_order = -1.0;</a>
<a name="ln933"> </a>
<a name="ln934">  // moving after module_prev is the same as moving before the very next one after module_prev</a>
<a name="ln935">  GList *modules = g_list_last(iop_list);</a>
<a name="ln936">  dt_iop_module_t *module_next = NULL;</a>
<a name="ln937">  while(modules)</a>
<a name="ln938">  {</a>
<a name="ln939">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln940">    if(mod == module_prev) break;</a>
<a name="ln941"> </a>
<a name="ln942">    module_next = mod;</a>
<a name="ln943">    modules = g_list_previous(modules);</a>
<a name="ln944">  }</a>
<a name="ln945">  if(module_next == NULL)</a>
<a name="ln946">  {</a>
<a name="ln947">    fprintf(</a>
<a name="ln948">        stderr,</a>
<a name="ln949">        &quot;[dt_ioppr_get_iop_order_after_iop] can't find module previous to %s %s(%f) while moving %s %s(%f) after it\n&quot;,</a>
<a name="ln950">        module_prev-&gt;op, module_prev-&gt;multi_name, module_prev-&gt;iop_order, module-&gt;op, module-&gt;multi_name,</a>
<a name="ln951">        module-&gt;iop_order);</a>
<a name="ln952">  }</a>
<a name="ln953">  else</a>
<a name="ln954">    iop_order = dt_ioppr_get_iop_order_before_iop(iop_list, module, module_next, validate_order, log_error);</a>
<a name="ln955"> </a>
<a name="ln956">  return iop_order;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">// changes the module-&gt;iop_order so it comes before in the pipe than module_next</a>
<a name="ln960">// sort dev-&gt;iop to reflect the changes</a>
<a name="ln961">// return 1 if iop_order is changed, 0 otherwise</a>
<a name="ln962">int dt_ioppr_move_iop_before(GList **_iop_list, dt_iop_module_t *module, dt_iop_module_t *module_next,</a>
<a name="ln963">                       const int validate_order, const int log_error)</a>
<a name="ln964">{</a>
<a name="ln965">  GList *iop_list = *_iop_list;</a>
<a name="ln966">  int moved = 0;</a>
<a name="ln967"> </a>
<a name="ln968">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_before begin&quot;);</a>
<a name="ln969"> </a>
<a name="ln970">  const double iop_order = dt_ioppr_get_iop_order_before_iop(iop_list, module, module_next, validate_order, log_error);</a>
<a name="ln971"> </a>
<a name="ln972">  if(iop_order &gt;= 0.0)</a>
<a name="ln973">  {</a>
<a name="ln974">    module-&gt;iop_order = iop_order;</a>
<a name="ln975">    iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln976">    moved = 1;</a>
<a name="ln977">  }</a>
<a name="ln978">  else if(log_error)</a>
<a name="ln979">    fprintf(stderr, &quot;[dt_ioppr_move_iop_before] module %s is already before %s\n&quot;, module-&gt;op, module_next-&gt;op);</a>
<a name="ln980"> </a>
<a name="ln981">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_before end&quot;);</a>
<a name="ln982"> </a>
<a name="ln983">  *_iop_list = iop_list;</a>
<a name="ln984">  </a>
<a name="ln985">  return moved;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">// changes the module-&gt;iop_order so it comes after in the pipe than module_prev</a>
<a name="ln989">// sort dev-&gt;iop to reflect the changes</a>
<a name="ln990">// return 1 if iop_order is changed, 0 otherwise</a>
<a name="ln991">int dt_ioppr_move_iop_after(GList **_iop_list, dt_iop_module_t *module, dt_iop_module_t *module_prev,</a>
<a name="ln992">                      const int validate_order, const int log_error)</a>
<a name="ln993">{</a>
<a name="ln994">  GList *iop_list = *_iop_list;</a>
<a name="ln995">  int moved = 0;</a>
<a name="ln996"> </a>
<a name="ln997">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_after begin&quot;);</a>
<a name="ln998"> </a>
<a name="ln999">  const double iop_order = dt_ioppr_get_iop_order_after_iop(iop_list, module, module_prev, validate_order, log_error);</a>
<a name="ln1000">  if(iop_order &gt;= 0.0)</a>
<a name="ln1001">  {</a>
<a name="ln1002">    module-&gt;iop_order = iop_order;</a>
<a name="ln1003">    iop_list = g_list_sort(iop_list, dt_sort_iop_by_order);</a>
<a name="ln1004">    moved = 1;</a>
<a name="ln1005">  }</a>
<a name="ln1006">  else if(log_error)</a>
<a name="ln1007">    fprintf(stderr, &quot;[dt_ioppr_move_iop_after] module %s is already after %s\n&quot;, module-&gt;op, module_prev-&gt;op);</a>
<a name="ln1008"> </a>
<a name="ln1009">  // dt_ioppr_check_iop_order(dev, &quot;dt_ioppr_move_iop_after end&quot;);</a>
<a name="ln1010"> </a>
<a name="ln1011">  *_iop_list = iop_list;</a>
<a name="ln1012">  </a>
<a name="ln1013">  return moved;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">//--------------------------------------------------------------------</a>
<a name="ln1017">// from here just for debug</a>
<a name="ln1018">//--------------------------------------------------------------------</a>
<a name="ln1019">void dt_ioppr_print_module_iop_order(GList *iop_list, const char *msg)</a>
<a name="ln1020">{</a>
<a name="ln1021">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1022">  while(modules)</a>
<a name="ln1023">  {</a>
<a name="ln1024">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1025">    </a>
<a name="ln1026">    fprintf(stderr, &quot;[%s] module %s %s multi_priority=%i, iop_order=%f\n&quot;, msg, mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod-&gt;iop_order);</a>
<a name="ln1027"> </a>
<a name="ln1028">    modules = g_list_next(modules);</a>
<a name="ln1029">  }</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">void dt_ioppr_print_history_iop_order(GList *history_list, const char *msg)</a>
<a name="ln1033">{</a>
<a name="ln1034">  GList *history = g_list_first(history_list);</a>
<a name="ln1035">  while(history)</a>
<a name="ln1036">  {</a>
<a name="ln1037">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln1038">    </a>
<a name="ln1039">    fprintf(stderr, &quot;[%s] module %s %s multi_priority=%i, iop_order=%f\n&quot;, msg, hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;multi_priority, hist-&gt;iop_order);</a>
<a name="ln1040"> </a>
<a name="ln1041">    history = g_list_next(history);</a>
<a name="ln1042">  }</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">void dt_ioppr_print_iop_order(GList *iop_order_list, const char *msg)</a>
<a name="ln1046">{</a>
<a name="ln1047">  GList *iops_order = g_list_first(iop_order_list);</a>
<a name="ln1048">  while(iops_order)</a>
<a name="ln1049">  {</a>
<a name="ln1050">    dt_iop_order_entry_t *order_entry = (dt_iop_order_entry_t *)(iops_order-&gt;data);</a>
<a name="ln1051">    </a>
<a name="ln1052">    fprintf(stderr, &quot;[%s] operation %s iop_order=%f\n&quot;, msg, order_entry-&gt;operation, order_entry-&gt;iop_order);</a>
<a name="ln1053"> </a>
<a name="ln1054">    iops_order = g_list_next(iops_order);</a>
<a name="ln1055">  }</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">static GList *_get_fence_modules_list(GList *iop_list)</a>
<a name="ln1059">{</a>
<a name="ln1060">  GList *fences = NULL;</a>
<a name="ln1061">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1062">  while(modules)</a>
<a name="ln1063">  {</a>
<a name="ln1064">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1065"> </a>
<a name="ln1066">    if(mod-&gt;flags() &amp; IOP_FLAGS_FENCE)</a>
<a name="ln1067">    {</a>
<a name="ln1068">      fences = g_list_append(fences, mod);</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    modules = g_list_next(modules);</a>
<a name="ln1072">  }</a>
<a name="ln1073">  return fences;</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">static void _ioppr_check_rules(GList *iop_list, const int imgid, const char *msg)</a>
<a name="ln1077">{</a>
<a name="ln1078">  GList *modules = NULL;</a>
<a name="ln1079"> </a>
<a name="ln1080">  // check for IOP_FLAGS_FENCE on each module</a>
<a name="ln1081">  // create a list of fences modules</a>
<a name="ln1082">  GList *fences = _get_fence_modules_list(iop_list);</a>
<a name="ln1083"> </a>
<a name="ln1084">  // check if each module is between the fences</a>
<a name="ln1085">  modules = g_list_first(iop_list);</a>
<a name="ln1086">  while(modules)</a>
<a name="ln1087">  {</a>
<a name="ln1088">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1089">    if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1090">    {</a>
<a name="ln1091">      modules = g_list_next(modules);</a>
<a name="ln1092">      continue;</a>
<a name="ln1093">    }</a>
<a name="ln1094"> </a>
<a name="ln1095">    dt_iop_module_t *fence_prev = NULL;</a>
<a name="ln1096">    dt_iop_module_t *fence_next = NULL;</a>
<a name="ln1097"> </a>
<a name="ln1098">    GList *mod_fences = g_list_first(fences);</a>
<a name="ln1099">    while(mod_fences)</a>
<a name="ln1100">    {</a>
<a name="ln1101">      dt_iop_module_t *mod_fence = (dt_iop_module_t *)mod_fences-&gt;data;</a>
<a name="ln1102"> </a>
<a name="ln1103">      // mod should be before this fence</a>
<a name="ln1104">      if(mod-&gt;iop_order &lt; mod_fence-&gt;iop_order)</a>
<a name="ln1105">      {</a>
<a name="ln1106">        if(fence_next == NULL)</a>
<a name="ln1107">          fence_next = mod_fence;</a>
<a name="ln1108">        else if(mod_fence-&gt;iop_order &lt; fence_next-&gt;iop_order)</a>
<a name="ln1109">          fence_next = mod_fence;</a>
<a name="ln1110">      }</a>
<a name="ln1111">      // mod should be after this fence</a>
<a name="ln1112">      else if(mod-&gt;iop_order &gt; mod_fence-&gt;iop_order)</a>
<a name="ln1113">      {</a>
<a name="ln1114">        if(fence_prev == NULL)</a>
<a name="ln1115">          fence_prev = mod_fence;</a>
<a name="ln1116">        else if(mod_fence-&gt;iop_order &gt; fence_prev-&gt;iop_order)</a>
<a name="ln1117">          fence_prev = mod_fence;</a>
<a name="ln1118">      }</a>
<a name="ln1119"> </a>
<a name="ln1120">      mod_fences = g_list_next(mod_fences);</a>
<a name="ln1121">    }</a>
<a name="ln1122"> </a>
<a name="ln1123">    // now check if mod is between the fences</a>
<a name="ln1124">    if(fence_next &amp;&amp; mod-&gt;iop_order &gt; fence_next-&gt;iop_order)</a>
<a name="ln1125">    {</a>
<a name="ln1126">      fprintf(stderr, &quot;[_ioppr_check_rules] found fence %s %s module %s %s(%f) is after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1127">              fence_next-&gt;op, fence_next-&gt;multi_name, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, fence_next-&gt;op,</a>
<a name="ln1128">              fence_next-&gt;multi_name, fence_next-&gt;iop_order, imgid, msg);</a>
<a name="ln1129">    }</a>
<a name="ln1130">    if(fence_prev &amp;&amp; mod-&gt;iop_order &lt; fence_prev-&gt;iop_order)</a>
<a name="ln1131">    {</a>
<a name="ln1132">      fprintf(stderr, &quot;[_ioppr_check_rules] found fence %s %s module %s %s(%f) is before %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1133">              fence_prev-&gt;op, fence_prev-&gt;multi_name, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, fence_prev-&gt;op,</a>
<a name="ln1134">              fence_prev-&gt;multi_name, fence_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1135">    }</a>
<a name="ln1136"> </a>
<a name="ln1137"> </a>
<a name="ln1138">    modules = g_list_next(modules);</a>
<a name="ln1139">  }</a>
<a name="ln1140"> </a>
<a name="ln1141">  // for each module check if it doesn't break a rule</a>
<a name="ln1142">  modules = g_list_first(iop_list);</a>
<a name="ln1143">  while(modules)</a>
<a name="ln1144">  {</a>
<a name="ln1145">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1146">    if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1147">    {</a>
<a name="ln1148">      modules = g_list_next(modules);</a>
<a name="ln1149">      continue;</a>
<a name="ln1150">    }</a>
<a name="ln1151"> </a>
<a name="ln1152">    // we have a module, now check each rule</a>
<a name="ln1153">    GList *rules = g_list_first(darktable.iop_order_rules);</a>
<a name="ln1154">    while(rules)</a>
<a name="ln1155">    {</a>
<a name="ln1156">      dt_iop_order_rule_t *rule = (dt_iop_order_rule_t *)rules-&gt;data;</a>
<a name="ln1157"> </a>
<a name="ln1158">      // mod must be before rule-&gt;op_next</a>
<a name="ln1159">      if(strcmp(mod-&gt;op, rule-&gt;op_prev) == 0)</a>
<a name="ln1160">      {</a>
<a name="ln1161">        // check if there's a rule-&gt;op_next module before mod</a>
<a name="ln1162">        GList *modules_prev = g_list_previous(modules);</a>
<a name="ln1163">        while(modules_prev)</a>
<a name="ln1164">        {</a>
<a name="ln1165">          dt_iop_module_t *mod_prev = (dt_iop_module_t *)modules_prev-&gt;data;</a>
<a name="ln1166"> </a>
<a name="ln1167">          if(strcmp(mod_prev-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1168">          {</a>
<a name="ln1169">            fprintf(stderr, &quot;[_ioppr_check_rules] found rule %s %s module %s %s(%f) is after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1170">                    rule-&gt;op_prev, rule-&gt;op_next, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_prev-&gt;op,</a>
<a name="ln1171">                    mod_prev-&gt;multi_name, mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1172">          }</a>
<a name="ln1173"> </a>
<a name="ln1174">          modules_prev = g_list_previous(modules_prev);</a>
<a name="ln1175">        }</a>
<a name="ln1176">      }</a>
<a name="ln1177">      // mod must be after rule-&gt;op_prev</a>
<a name="ln1178">      else if(strcmp(mod-&gt;op, rule-&gt;op_next) == 0)</a>
<a name="ln1179">      {</a>
<a name="ln1180">        // check if there's a rule-&gt;op_prev module after mod</a>
<a name="ln1181">        GList *modules_next = g_list_next(modules);</a>
<a name="ln1182">        while(modules_next)</a>
<a name="ln1183">        {</a>
<a name="ln1184">          dt_iop_module_t *mod_next = (dt_iop_module_t *)modules_next-&gt;data;</a>
<a name="ln1185"> </a>
<a name="ln1186">          if(strcmp(mod_next-&gt;op, rule-&gt;op_prev) == 0)</a>
<a name="ln1187">          {</a>
<a name="ln1188">            fprintf(stderr, &quot;[_ioppr_check_rules] found rule %s %s module %s %s(%f) is before %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1189">                    rule-&gt;op_prev, rule-&gt;op_next, mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_next-&gt;op,</a>
<a name="ln1190">                    mod_next-&gt;multi_name, mod_next-&gt;iop_order, imgid, msg);</a>
<a name="ln1191">          }</a>
<a name="ln1192"> </a>
<a name="ln1193">          modules_next = g_list_next(modules_next);</a>
<a name="ln1194">        }</a>
<a name="ln1195">      }</a>
<a name="ln1196"> </a>
<a name="ln1197">      rules = g_list_next(rules);</a>
<a name="ln1198">    }</a>
<a name="ln1199"> </a>
<a name="ln1200">    modules = g_list_next(modules);</a>
<a name="ln1201">  }</a>
<a name="ln1202"> </a>
<a name="ln1203">  if(fences) g_list_free(fences);</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">int dt_ioppr_check_iop_order(dt_develop_t *dev, const int imgid, const char *msg)</a>
<a name="ln1207">{</a>
<a name="ln1208">  int iop_order_ok = 1;</a>
<a name="ln1209"> </a>
<a name="ln1210">  // check if gamma is the last iop</a>
<a name="ln1211">  {</a>
<a name="ln1212">    GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1213">    while(modules)</a>
<a name="ln1214">    {</a>
<a name="ln1215">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1216">      if(mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln1217">        break;</a>
<a name="ln1218">      </a>
<a name="ln1219">      modules = g_list_previous(dev-&gt;iop);</a>
<a name="ln1220">    }</a>
<a name="ln1221">    if(modules)</a>
<a name="ln1222">    {</a>
<a name="ln1223">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1224"> </a>
<a name="ln1225">      if(strcmp(mod-&gt;op, &quot;gamma&quot;) != 0)</a>
<a name="ln1226">      {</a>
<a name="ln1227">        iop_order_ok = 0;</a>
<a name="ln1228">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] gamma is not the last iop, last is %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1229">                mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1230">      }</a>
<a name="ln1231">    }</a>
<a name="ln1232">    else</a>
<a name="ln1233">    {</a>
<a name="ln1234">      // fprintf(stderr, &quot;[dt_ioppr_check_iop_order] dev-&gt;iop is empty image %i (%s)\n&quot;,imgid, msg);</a>
<a name="ln1235">    }</a>
<a name="ln1236">  }</a>
<a name="ln1237"> </a>
<a name="ln1238">  // some other chacks</a>
<a name="ln1239">  {</a>
<a name="ln1240">    GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1241">    while(modules)</a>
<a name="ln1242">    {</a>
<a name="ln1243">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1244">      if(mod-&gt;iop_order == DBL_MAX)</a>
<a name="ln1245">      {</a>
<a name="ln1246">        if(mod-&gt;enabled)</a>
<a name="ln1247">        {</a>
<a name="ln1248">          iop_order_ok = 0;</a>
<a name="ln1249">          fprintf(stderr, &quot;[dt_ioppr_check_iop_order] module not used but enabled!! %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1250">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1251">        }</a>
<a name="ln1252">        if(mod-&gt;multi_priority == 0)</a>
<a name="ln1253">        {</a>
<a name="ln1254">          iop_order_ok = 0;</a>
<a name="ln1255">          fprintf(stderr, &quot;[dt_ioppr_check_iop_order] base module set as not used %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1256">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order,imgid, msg);</a>
<a name="ln1257">        }</a>
<a name="ln1258">      }</a>
<a name="ln1259">      </a>
<a name="ln1260">      modules = g_list_previous(dev-&gt;iop);</a>
<a name="ln1261">    }</a>
<a name="ln1262">  }</a>
<a name="ln1263"> </a>
<a name="ln1264">  // check if there's duplicate or out-of-order iop_order</a>
<a name="ln1265">  {</a>
<a name="ln1266">    dt_iop_module_t *mod_prev = NULL;</a>
<a name="ln1267">    GList *modules = g_list_first(dev-&gt;iop);</a>
<a name="ln1268">    while(modules)</a>
<a name="ln1269">    {</a>
<a name="ln1270">      dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln1271">      if(mod-&gt;iop_order != DBL_MAX)</a>
<a name="ln1272">      {</a>
<a name="ln1273">        if(mod_prev)</a>
<a name="ln1274">        {</a>
<a name="ln1275">          if(mod-&gt;iop_order &lt; mod_prev-&gt;iop_order)</a>
<a name="ln1276">          {</a>
<a name="ln1277">            iop_order_ok = 0;</a>
<a name="ln1278">            fprintf(stderr,</a>
<a name="ln1279">                    &quot;[dt_ioppr_check_iop_order] module %s %s(%f) should be after %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1280">                    mod-&gt;op, mod-&gt;multi_name, mod-&gt;iop_order, mod_prev-&gt;op, mod_prev-&gt;multi_name,</a>
<a name="ln1281">                    mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1282">          }</a>
<a name="ln1283">          else if(mod-&gt;iop_order == mod_prev-&gt;iop_order)</a>
<a name="ln1284">          {</a>
<a name="ln1285">            iop_order_ok = 0;</a>
<a name="ln1286">            fprintf(</a>
<a name="ln1287">                stderr,</a>
<a name="ln1288">                &quot;[dt_ioppr_check_iop_order] module %s %s(%i)(%f) and %s %s(%i)(%f) has the same order image %i (%s)\n&quot;,</a>
<a name="ln1289">                mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod-&gt;iop_order, mod_prev-&gt;op, </a>
<a name="ln1290">                mod_prev-&gt;multi_name, mod_prev-&gt;multi_priority, mod_prev-&gt;iop_order, imgid, msg);</a>
<a name="ln1291">          }</a>
<a name="ln1292">        }</a>
<a name="ln1293">      }</a>
<a name="ln1294">      mod_prev = mod;</a>
<a name="ln1295">      modules = g_list_next(modules);</a>
<a name="ln1296">    }</a>
<a name="ln1297">  }</a>
<a name="ln1298"> </a>
<a name="ln1299">  _ioppr_check_rules(dev-&gt;iop, imgid, msg);</a>
<a name="ln1300"> </a>
<a name="ln1301">  GList *history = g_list_first(dev-&gt;history);</a>
<a name="ln1302">  while(history)</a>
<a name="ln1303">  {</a>
<a name="ln1304">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln1305">    </a>
<a name="ln1306">    if(hist-&gt;iop_order == DBL_MAX)</a>
<a name="ln1307">    {</a>
<a name="ln1308">      if(hist-&gt;enabled)</a>
<a name="ln1309">      {</a>
<a name="ln1310">        iop_order_ok = 0;</a>
<a name="ln1311">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] history module not used but enabled!! %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1312">            hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;iop_order,imgid, msg);</a>
<a name="ln1313">      }</a>
<a name="ln1314">      if(hist-&gt;multi_priority == 0)</a>
<a name="ln1315">      {</a>
<a name="ln1316">        iop_order_ok = 0;</a>
<a name="ln1317">        fprintf(stderr, &quot;[dt_ioppr_check_iop_order] history base module set as not used %s %s(%f) image %i (%s)\n&quot;,</a>
<a name="ln1318">            hist-&gt;op_name, hist-&gt;multi_name, hist-&gt;iop_order,imgid, msg);</a>
<a name="ln1319">      }</a>
<a name="ln1320">    }</a>
<a name="ln1321"> </a>
<a name="ln1322">    history = g_list_next(history);</a>
<a name="ln1323">  }</a>
<a name="ln1324"> </a>
<a name="ln1325">  return iop_order_ok;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">//---------------------------------------------------------</a>
<a name="ln1329">// colorspace transforms</a>
<a name="ln1330">//---------------------------------------------------------</a>
<a name="ln1331"> </a>
<a name="ln1332">static void _transform_from_to_rgb_lab_lcms2(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1333">                                             const int height, const dt_colorspaces_color_profile_type_t type,</a>
<a name="ln1334">                                             const char *filename, const int intent, const int direction)</a>
<a name="ln1335">{</a>
<a name="ln1336">  const int ch = 4;</a>
<a name="ln1337">  cmsHTRANSFORM *xform = NULL;</a>
<a name="ln1338">  cmsHPROFILE *rgb_profile = NULL;</a>
<a name="ln1339">  cmsHPROFILE *lab_profile = NULL;</a>
<a name="ln1340">  </a>
<a name="ln1341">  if(type != DT_COLORSPACE_NONE)</a>
<a name="ln1342">  {</a>
<a name="ln1343">    const dt_colorspaces_color_profile_t *profile = dt_colorspaces_get_profile(type, filename, DT_PROFILE_DIRECTION_WORK);</a>
<a name="ln1344">    if(profile) rgb_profile = profile-&gt;profile;</a>
<a name="ln1345">  }</a>
<a name="ln1346">  else</a>
<a name="ln1347">    rgb_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LIN_REC2020, &quot;&quot;, DT_PROFILE_DIRECTION_WORK)-&gt;profile;</a>
<a name="ln1348">  if(rgb_profile)</a>
<a name="ln1349">  {</a>
<a name="ln1350">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(rgb_profile);</a>
<a name="ln1351">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1352">    {</a>
<a name="ln1353">        fprintf(stderr, &quot;working profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1354">                (char)(rgb_color_space&gt;&gt;24),</a>
<a name="ln1355">                (char)(rgb_color_space&gt;&gt;16),</a>
<a name="ln1356">                (char)(rgb_color_space&gt;&gt;8),</a>
<a name="ln1357">                (char)(rgb_color_space));</a>
<a name="ln1358">        rgb_profile = NULL;</a>
<a name="ln1359">    }</a>
<a name="ln1360">  }</a>
<a name="ln1361">  if(rgb_profile == NULL)</a>
<a name="ln1362">  {</a>
<a name="ln1363">    rgb_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LIN_REC2020, &quot;&quot;, DT_PROFILE_DIRECTION_WORK)-&gt;profile;</a>
<a name="ln1364">    fprintf(stderr, _(&quot;unsupported working profile %s has been replaced by Rec2020 RGB!\n&quot;), filename);</a>
<a name="ln1365">  }</a>
<a name="ln1366">  </a>
<a name="ln1367">  lab_profile = dt_colorspaces_get_profile(DT_COLORSPACE_LAB, &quot;&quot;, DT_PROFILE_DIRECTION_ANY)-&gt;profile;</a>
<a name="ln1368"> </a>
<a name="ln1369">  cmsHPROFILE *input_profile = NULL;</a>
<a name="ln1370">  cmsHPROFILE *output_profile = NULL;</a>
<a name="ln1371">  cmsUInt32Number input_format = TYPE_RGBA_FLT;</a>
<a name="ln1372">  cmsUInt32Number output_format = TYPE_LabA_FLT;</a>
<a name="ln1373">  </a>
<a name="ln1374">  if(direction == 1) // rgb --&gt; lab</a>
<a name="ln1375">  {</a>
<a name="ln1376">    input_profile = rgb_profile;</a>
<a name="ln1377">    input_format = TYPE_RGBA_FLT;</a>
<a name="ln1378">    output_profile = lab_profile;</a>
<a name="ln1379">    output_format = TYPE_LabA_FLT;</a>
<a name="ln1380">  }</a>
<a name="ln1381">  else // lab --&gt;rgb</a>
<a name="ln1382">  {</a>
<a name="ln1383">    input_profile = lab_profile;</a>
<a name="ln1384">    input_format = TYPE_LabA_FLT;</a>
<a name="ln1385">    output_profile = rgb_profile;</a>
<a name="ln1386">    output_format = TYPE_RGBA_FLT;</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  xform = cmsCreateTransform(input_profile, input_format, output_profile, output_format, intent, 0);</a>
<a name="ln1390">  if(xform)</a>
<a name="ln1391">  {</a>
<a name="ln1392">#ifdef _OPENMP</a>
<a name="ln1393">#pragma omp parallel for shared(xform) schedule(static) default(none)</a>
<a name="ln1394">#endif</a>
<a name="ln1395">    for(int y = 0; y &lt; height; y++)</a>
<a name="ln1396">    {</a>
<a name="ln1397">      const float *const in = image_in + y * width * ch;</a>
<a name="ln1398">      float *const out = image_out + y * width * ch;</a>
<a name="ln1399"> </a>
<a name="ln1400">      cmsDoTransform(xform, in, out, width);</a>
<a name="ln1401">    }</a>
<a name="ln1402">  }</a>
<a name="ln1403">  else</a>
<a name="ln1404">    fprintf(stderr, &quot;[_transform_from_to_rgb_lab_lcms2] cannot create transform\n&quot;);</a>
<a name="ln1405"> </a>
<a name="ln1406">  if(xform) cmsDeleteTransform(xform);</a>
<a name="ln1407">}</a>
<a name="ln1408"> </a>
<a name="ln1409">static void _transform_rgb_to_rgb_lcms2(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1410">                                        const int height, const dt_colorspaces_color_profile_type_t type_from,</a>
<a name="ln1411">                                        const char *filename_from,</a>
<a name="ln1412">                                        const dt_colorspaces_color_profile_type_t type_to, const char *filename_to,</a>
<a name="ln1413">                                        const int intent)</a>
<a name="ln1414">{</a>
<a name="ln1415">  const int ch = 4;</a>
<a name="ln1416">  cmsHTRANSFORM *xform = NULL;</a>
<a name="ln1417">  cmsHPROFILE *from_rgb_profile = NULL;</a>
<a name="ln1418">  cmsHPROFILE *to_rgb_profile = NULL;</a>
<a name="ln1419"> </a>
<a name="ln1420">  if(type_from == DT_COLORSPACE_DISPLAY || type_to == DT_COLORSPACE_DISPLAY)</a>
<a name="ln1421">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1422"> </a>
<a name="ln1423">  if(type_from != DT_COLORSPACE_NONE)</a>
<a name="ln1424">  {</a>
<a name="ln1425">    const dt_colorspaces_color_profile_t *profile_from</a>
<a name="ln1426">        = dt_colorspaces_get_profile(type_from, filename_from, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1427">    if(profile_from) from_rgb_profile = profile_from-&gt;profile;</a>
<a name="ln1428">  }</a>
<a name="ln1429">  else</a>
<a name="ln1430">  {</a>
<a name="ln1431">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] invalid from profile\n&quot;);</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  if(type_to != DT_COLORSPACE_NONE)</a>
<a name="ln1435">  {</a>
<a name="ln1436">    const dt_colorspaces_color_profile_t *profile_to</a>
<a name="ln1437">        = dt_colorspaces_get_profile(type_to, filename_to, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1438">    if(profile_to) to_rgb_profile = profile_to-&gt;profile;</a>
<a name="ln1439">  }</a>
<a name="ln1440">  else</a>
<a name="ln1441">  {</a>
<a name="ln1442">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] invalid to profile\n&quot;);</a>
<a name="ln1443">  }</a>
<a name="ln1444"> </a>
<a name="ln1445">  if(from_rgb_profile)</a>
<a name="ln1446">  {</a>
<a name="ln1447">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(from_rgb_profile);</a>
<a name="ln1448">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1449">    {</a>
<a name="ln1450">      fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1451">              (char)(rgb_color_space &gt;&gt; 24), (char)(rgb_color_space &gt;&gt; 16), (char)(rgb_color_space &gt;&gt; 8),</a>
<a name="ln1452">              (char)(rgb_color_space));</a>
<a name="ln1453">      from_rgb_profile = NULL;</a>
<a name="ln1454">    }</a>
<a name="ln1455">  }</a>
<a name="ln1456">  if(to_rgb_profile)</a>
<a name="ln1457">  {</a>
<a name="ln1458">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(to_rgb_profile);</a>
<a name="ln1459">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1460">    {</a>
<a name="ln1461">      fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1462">              (char)(rgb_color_space &gt;&gt; 24), (char)(rgb_color_space &gt;&gt; 16), (char)(rgb_color_space &gt;&gt; 8),</a>
<a name="ln1463">              (char)(rgb_color_space));</a>
<a name="ln1464">      to_rgb_profile = NULL;</a>
<a name="ln1465">    }</a>
<a name="ln1466">  }</a>
<a name="ln1467"> </a>
<a name="ln1468">  cmsHPROFILE *input_profile = NULL;</a>
<a name="ln1469">  cmsHPROFILE *output_profile = NULL;</a>
<a name="ln1470">  cmsUInt32Number input_format = TYPE_RGBA_FLT;</a>
<a name="ln1471">  cmsUInt32Number output_format = TYPE_RGBA_FLT;</a>
<a name="ln1472"> </a>
<a name="ln1473">  input_profile = from_rgb_profile;</a>
<a name="ln1474">  input_format = TYPE_RGBA_FLT;</a>
<a name="ln1475">  output_profile = to_rgb_profile;</a>
<a name="ln1476">  output_format = TYPE_RGBA_FLT;</a>
<a name="ln1477"> </a>
<a name="ln1478">  if(input_profile &amp;&amp; output_profile)</a>
<a name="ln1479">    xform = cmsCreateTransform(input_profile, input_format, output_profile, output_format, intent, 0);</a>
<a name="ln1480"> </a>
<a name="ln1481">  if(type_from == DT_COLORSPACE_DISPLAY || type_to == DT_COLORSPACE_DISPLAY)</a>
<a name="ln1482">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1483"> </a>
<a name="ln1484">  if(xform)</a>
<a name="ln1485">  {</a>
<a name="ln1486">#ifdef _OPENMP</a>
<a name="ln1487">#pragma omp parallel for shared(xform) schedule(static) default(none)</a>
<a name="ln1488">#endif</a>
<a name="ln1489">    for(int y = 0; y &lt; height; y++)</a>
<a name="ln1490">    {</a>
<a name="ln1491">      const float *const in = image_in + y * width * ch;</a>
<a name="ln1492">      float *const out = image_out + y * width * ch;</a>
<a name="ln1493"> </a>
<a name="ln1494">      cmsDoTransform(xform, in, out, width);</a>
<a name="ln1495">    }</a>
<a name="ln1496">  }</a>
<a name="ln1497">  else</a>
<a name="ln1498">    fprintf(stderr, &quot;[_transform_rgb_to_rgb_lcms2] cannot create transform\n&quot;);</a>
<a name="ln1499"> </a>
<a name="ln1500">  if(xform) cmsDeleteTransform(xform);</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">static void _transform_lcms2(struct dt_iop_module_t *self, const float *const image_in, float *const image_out,</a>
<a name="ln1504">                             const int width, const int height, const int cst_from, const int cst_to,</a>
<a name="ln1505">                             int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1506">{</a>
<a name="ln1507">  if(cst_from == cst_to)</a>
<a name="ln1508">  {</a>
<a name="ln1509">    *converted_cst = cst_to;</a>
<a name="ln1510">    return;</a>
<a name="ln1511">  }</a>
<a name="ln1512">  </a>
<a name="ln1513">  *converted_cst = cst_to;</a>
<a name="ln1514"> </a>
<a name="ln1515">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln1516">  {</a>
<a name="ln1517">    printf(&quot;[_transform_lcms2] transfoming from RGB to Lab (%s %s)\n&quot;, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln1518">    _transform_from_to_rgb_lab_lcms2(image_in, image_out, width, height, profile_info-&gt;type,</a>
<a name="ln1519">                                     profile_info-&gt;filename, profile_info-&gt;intent, 1);</a>
<a name="ln1520">  }</a>
<a name="ln1521">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln1522">  {</a>
<a name="ln1523">    printf(&quot;[_transform_lcms2] transfoming from Lab to RGB (%s %s)\n&quot;, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln1524">    _transform_from_to_rgb_lab_lcms2(image_in, image_out, width, height, profile_info-&gt;type,</a>
<a name="ln1525">                                     profile_info-&gt;filename, profile_info-&gt;intent, -1);</a>
<a name="ln1526">  }</a>
<a name="ln1527">  else</a>
<a name="ln1528">  {</a>
<a name="ln1529">    *converted_cst = cst_from;</a>
<a name="ln1530">    fprintf(stderr, &quot;[_transform_lcms2] invalid convertion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln1531">  }</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">static inline void _transform_lcms2_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1535">                                        const int height,</a>
<a name="ln1536">                                        const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln1537">                                        const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln1538">{</a>
<a name="ln1539">  _transform_rgb_to_rgb_lcms2(image_in, image_out, width, height, profile_info_from-&gt;type,</a>
<a name="ln1540">                              profile_info_from-&gt;filename, profile_info_to-&gt;type, profile_info_to-&gt;filename,</a>
<a name="ln1541">                              profile_info_to-&gt;intent);</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">static float lerp_lut(const float *const lut, const float v, const int lutsize)</a>
<a name="ln1545">{</a>
<a name="ln1546">  // TODO: check if optimization is worthwhile!</a>
<a name="ln1547">  const float ft = CLAMPS(v * (lutsize - 1), 0, lutsize - 1);</a>
<a name="ln1548">  const int t = ft &lt; lutsize - 2 ? ft : lutsize - 2;</a>
<a name="ln1549">  const float f = ft - t;</a>
<a name="ln1550">  const float l1 = lut[t];</a>
<a name="ln1551">  const float l2 = lut[t + 1];</a>
<a name="ln1552">  return l1 * (1.0f - f) + l2 * f;</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">static inline void _apply_trc_in(const float *const rgb_in, float *rgb_out, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1556">{</a>
<a name="ln1557">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1558">  {</a>
<a name="ln1559">    rgb_out[c] = (profile_info-&gt;lut_in[c][0] &gt;= 0.0f) ? ((rgb_in[c] &lt; 1.0f) ? lerp_lut(profile_info-&gt;lut_in[c], rgb_in[c], profile_info-&gt;lutsize)</a>
<a name="ln1560">                                                        : dt_iop_eval_exp(profile_info-&gt;unbounded_coeffs_in[c], rgb_in[c]))</a>
<a name="ln1561">                                                        : rgb_in[c];</a>
<a name="ln1562">  }</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">static inline void _apply_trc_out(const float *const rgb_in, float *rgb_out, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1566">{</a>
<a name="ln1567">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1568">  {</a>
<a name="ln1569">    rgb_out[c] = (profile_info-&gt;lut_out[c][0] &gt;= 0.0f) ? ((rgb_in[c] &lt; 1.0f) ? lerp_lut(profile_info-&gt;lut_out[c], rgb_in[c], profile_info-&gt;lutsize)</a>
<a name="ln1570">                                                        : dt_iop_eval_exp(profile_info-&gt;unbounded_coeffs_out[c], rgb_in[c]))</a>
<a name="ln1571">                                                        : rgb_in[c];</a>
<a name="ln1572">  }</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575">static void _ioppr_linear_rgb_matrix_to_xyz(const float *const rgb, float *xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1576">{</a>
<a name="ln1577">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1578">  {</a>
<a name="ln1579">    xyz[c] = 0.0f;</a>
<a name="ln1580">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1581">    {</a>
<a name="ln1582">      xyz[c] += profile_info-&gt;matrix_in[3 * c + i] * rgb[i];</a>
<a name="ln1583">    }</a>
<a name="ln1584">  }</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">static void _ioppr_xyz_to_linear_rgb_matrix(const float *const xyz, float *rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1588">{</a>
<a name="ln1589">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1590">  {</a>
<a name="ln1591">    rgb[c] = 0.0f;</a>
<a name="ln1592">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1593">    {</a>
<a name="ln1594">      rgb[c] += profile_info-&gt;matrix_out[3 * c + i] * xyz[i];</a>
<a name="ln1595">    }</a>
<a name="ln1596">  }</a>
<a name="ln1597">}</a>
<a name="ln1598"> </a>
<a name="ln1599">static void _apply_tonecurves(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1600">                              const int height, const float *const lutr, const float *const lutg,</a>
<a name="ln1601">                              const float *const lutb, const float *const unbounded_coeffsr,</a>
<a name="ln1602">                              const float *const unbounded_coeffsg, const float *const unbounded_coeffsb,</a>
<a name="ln1603">                              const int lutsize)</a>
<a name="ln1604">{</a>
<a name="ln1605">  const int ch = 4;</a>
<a name="ln1606">  const float *const lut[3] = { lutr, lutg, lutb };</a>
<a name="ln1607">  const float *const unbounded_coeffs[3] = { unbounded_coeffsr, unbounded_coeffsg, unbounded_coeffsb };</a>
<a name="ln1608">  const size_t stride = (size_t)ch * width * height;</a>
<a name="ln1609">  </a>
<a name="ln1610">  // do we have any lut to apply, or is this a linear profile?</a>
<a name="ln1611">  if((lut[0][0] &gt;= 0.0f) &amp;&amp; (lut[1][0] &gt;= 0.0f) &amp;&amp; (lut[2][0] &gt;= 0.0f))</a>
<a name="ln1612">  {</a>
<a name="ln1613">#ifdef _OPENMP</a>
<a name="ln1614">#pragma omp parallel for schedule(static) default(none)</a>
<a name="ln1615">#endif</a>
<a name="ln1616">    for(size_t k = 0; k &lt; stride; k += ch)</a>
<a name="ln1617">    {</a>
<a name="ln1618">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1619">      {</a>
<a name="ln1620">        image_out[k + c] = (image_in[k + c] &lt; 1.0f) ? lerp_lut(lut[c], image_in[k + c], lutsize)</a>
<a name="ln1621">                                                    : dt_iop_eval_exp(unbounded_coeffs[c], image_in[k + c]);</a>
<a name="ln1622">      }</a>
<a name="ln1623">    }</a>
<a name="ln1624">  }</a>
<a name="ln1625">  else if((lut[0][0] &gt;= 0.0f) || (lut[1][0] &gt;= 0.0f) || (lut[2][0] &gt;= 0.0f))</a>
<a name="ln1626">  {</a>
<a name="ln1627">#ifdef _OPENMP</a>
<a name="ln1628">#pragma omp parallel for schedule(static) default(none)</a>
<a name="ln1629">#endif</a>
<a name="ln1630">    for(size_t k = 0; k &lt; stride; k += ch)</a>
<a name="ln1631">    {</a>
<a name="ln1632">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1633">      {</a>
<a name="ln1634">        if(lut[c][0] &gt;= 0.0f)</a>
<a name="ln1635">        {</a>
<a name="ln1636">          image_out[k + c] = (image_in[k + c] &lt; 1.0f) ? lerp_lut(lut[c], image_in[k + c], lutsize)</a>
<a name="ln1637">                                                      : dt_iop_eval_exp(unbounded_coeffs[c], image_in[k + c]);</a>
<a name="ln1638">        }</a>
<a name="ln1639">      }</a>
<a name="ln1640">    }</a>
<a name="ln1641">  }</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">static void _transform_rgb_to_lab_matrix(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1645">                                         const int height,</a>
<a name="ln1646">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1647">{</a>
<a name="ln1648">  const int ch = 4;</a>
<a name="ln1649">  const size_t stride = (size_t)(width * height);</a>
<a name="ln1650"> </a>
<a name="ln1651">  _apply_tonecurves(image_in, image_out, width, height, profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1],</a>
<a name="ln1652">                    profile_info-&gt;lut_in[2], profile_info-&gt;unbounded_coeffs_in[0],</a>
<a name="ln1653">                    profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2],</a>
<a name="ln1654">                    profile_info-&gt;lutsize);</a>
<a name="ln1655"> </a>
<a name="ln1656">#ifdef _OPENMP</a>
<a name="ln1657">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln1658">#endif</a>
<a name="ln1659">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1660">  {</a>
<a name="ln1661">    float *const in = image_out + y * ch;</a>
<a name="ln1662"> </a>
<a name="ln1663">    float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1664"> </a>
<a name="ln1665">    _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info);</a>
<a name="ln1666">    dt_XYZ_to_Lab(xyz, in);</a>
<a name="ln1667">  }</a>
<a name="ln1668">}</a>
<a name="ln1669"> </a>
<a name="ln1670">static void _transform_lab_to_rgb_matrix(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1671">                                         const int height,</a>
<a name="ln1672">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1673">{</a>
<a name="ln1674">  const int ch = 4;</a>
<a name="ln1675">  const size_t stride = (size_t)width * height;</a>
<a name="ln1676"> </a>
<a name="ln1677">#ifdef _OPENMP</a>
<a name="ln1678">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln1679">#endif</a>
<a name="ln1680">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1681">  {</a>
<a name="ln1682">    const float *const in = image_in + y * ch;</a>
<a name="ln1683">    float *const out = image_out + y * ch;</a>
<a name="ln1684"> </a>
<a name="ln1685">    float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1686">    </a>
<a name="ln1687">    dt_Lab_to_XYZ(in, xyz);</a>
<a name="ln1688">    _ioppr_xyz_to_linear_rgb_matrix(xyz, out, profile_info);</a>
<a name="ln1689">  }</a>
<a name="ln1690"> </a>
<a name="ln1691">  _apply_tonecurves(image_out, image_out, width, height, profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1],</a>
<a name="ln1692">                    profile_info-&gt;lut_out[2], profile_info-&gt;unbounded_coeffs_out[0],</a>
<a name="ln1693">                    profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2],</a>
<a name="ln1694">                    profile_info-&gt;lutsize);</a>
<a name="ln1695">}</a>
<a name="ln1696"> </a>
<a name="ln1697">static void _transform_matrix_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln1698">                                  const int height, const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln1699">                                  const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln1700">{</a>
<a name="ln1701">  const int ch = 4;</a>
<a name="ln1702">  const size_t stride = (size_t)(width * height);</a>
<a name="ln1703"> </a>
<a name="ln1704">  _apply_tonecurves(image_in, image_out, width, height, profile_info_from-&gt;lut_in[0], profile_info_from-&gt;lut_in[1],</a>
<a name="ln1705">                    profile_info_from-&gt;lut_in[2], profile_info_from-&gt;unbounded_coeffs_in[0],</a>
<a name="ln1706">                    profile_info_from-&gt;unbounded_coeffs_in[1], profile_info_from-&gt;unbounded_coeffs_in[2],</a>
<a name="ln1707">                    profile_info_from-&gt;lutsize);</a>
<a name="ln1708"> </a>
<a name="ln1709">#ifdef _OPENMP</a>
<a name="ln1710">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln1711">#endif</a>
<a name="ln1712">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln1713">  {</a>
<a name="ln1714">    float *const in = image_out + y * ch;</a>
<a name="ln1715"> </a>
<a name="ln1716">    float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln1717"> </a>
<a name="ln1718">    _ioppr_linear_rgb_matrix_to_xyz(in, xyz, profile_info_from);</a>
<a name="ln1719">    _ioppr_xyz_to_linear_rgb_matrix(xyz, in, profile_info_to);</a>
<a name="ln1720">  }</a>
<a name="ln1721"> </a>
<a name="ln1722">  _apply_tonecurves(image_out, image_out, width, height, profile_info_to-&gt;lut_out[0], profile_info_to-&gt;lut_out[1],</a>
<a name="ln1723">                    profile_info_to-&gt;lut_out[2], profile_info_to-&gt;unbounded_coeffs_out[0],</a>
<a name="ln1724">                    profile_info_to-&gt;unbounded_coeffs_out[1], profile_info_to-&gt;unbounded_coeffs_out[2],</a>
<a name="ln1725">                    profile_info_to-&gt;lutsize);</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">static int _init_unbounded_coeffs(float *lutr, float *lutg, float *lutb, </a>
<a name="ln1729">    float *unbounded_coeffsr, float *unbounded_coeffsg, float *unbounded_coeffsb, const int lutsize)</a>
<a name="ln1730">{</a>
<a name="ln1731">  int nonlinearlut = 0;</a>
<a name="ln1732">  float *lut[3] = { lutr, lutg, lutb };</a>
<a name="ln1733">  float *unbounded_coeffs[3] = { unbounded_coeffsr, unbounded_coeffsg, unbounded_coeffsb };</a>
<a name="ln1734">  </a>
<a name="ln1735">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1736">  {</a>
<a name="ln1737">    // omit luts marked as linear (negative as marker)</a>
<a name="ln1738">    if(lut[k][0] &gt;= 0.0f)</a>
<a name="ln1739">    {</a>
<a name="ln1740">      const float x[4] = { 0.7f, 0.8f, 0.9f, 1.0f };</a>
<a name="ln1741">      const float y[4] = { lerp_lut(lut[k], x[0], lutsize), lerp_lut(lut[k], x[1], lutsize), lerp_lut(lut[k], x[2], lutsize),</a>
<a name="ln1742">                           lerp_lut(lut[k], x[3], lutsize) };</a>
<a name="ln1743">      dt_iop_estimate_exp(x, y, 4, unbounded_coeffs[k]);</a>
<a name="ln1744">      </a>
<a name="ln1745">      nonlinearlut++;</a>
<a name="ln1746">    }</a>
<a name="ln1747">    else</a>
<a name="ln1748">      unbounded_coeffs[k][0] = -1.0f;</a>
<a name="ln1749">  }</a>
<a name="ln1750">  </a>
<a name="ln1751">  return nonlinearlut;</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754">static void _transform_matrix(struct dt_iop_module_t *self, const float *const image_in, float *const image_out,</a>
<a name="ln1755">                              const int width, const int height, const int cst_from, const int cst_to,</a>
<a name="ln1756">                              int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln1757">{</a>
<a name="ln1758">  if(cst_from == cst_to)</a>
<a name="ln1759">  {</a>
<a name="ln1760">    *converted_cst = cst_to;</a>
<a name="ln1761">    return;</a>
<a name="ln1762">  }</a>
<a name="ln1763">  </a>
<a name="ln1764">  *converted_cst = cst_to;</a>
<a name="ln1765"> </a>
<a name="ln1766">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln1767">  {</a>
<a name="ln1768">    _transform_rgb_to_lab_matrix(image_in, image_out, width, height, profile_info);</a>
<a name="ln1769">  }</a>
<a name="ln1770">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln1771">  {</a>
<a name="ln1772">    _transform_lab_to_rgb_matrix(image_in, image_out, width, height, profile_info);</a>
<a name="ln1773">  }</a>
<a name="ln1774">  else</a>
<a name="ln1775">  {</a>
<a name="ln1776">    *converted_cst = cst_from;</a>
<a name="ln1777">    fprintf(stderr, &quot;[_transform_matrix] invalid convertion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln1778">  }</a>
<a name="ln1779">}</a>
<a name="ln1780"> </a>
<a name="ln1781">#define DT_IOPPR_LUT_SAMPLES 0x10000</a>
<a name="ln1782"> </a>
<a name="ln1783">void dt_ioppr_init_profile_info(dt_iop_order_iccprofile_info_t *profile_info, const int lutsize)</a>
<a name="ln1784">{</a>
<a name="ln1785">  profile_info-&gt;type = DT_COLORSPACE_NONE;</a>
<a name="ln1786">  profile_info-&gt;filename[0] = '\0';</a>
<a name="ln1787">  profile_info-&gt;intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1788">  profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1789">  profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1790">  profile_info-&gt;unbounded_coeffs_in[0][0] = profile_info-&gt;unbounded_coeffs_in[1][0] = profile_info-&gt;unbounded_coeffs_in[2][0] = -1.0f;</a>
<a name="ln1791">  profile_info-&gt;unbounded_coeffs_out[0][0] = profile_info-&gt;unbounded_coeffs_out[1][0] = profile_info-&gt;unbounded_coeffs_out[2][0] = -1.0f;</a>
<a name="ln1792">  profile_info-&gt;nonlinearlut = 0;</a>
<a name="ln1793">  profile_info-&gt;grey = 0.f;</a>
<a name="ln1794">  profile_info-&gt;lutsize = (lutsize &gt; 0) ? lutsize: DT_IOPPR_LUT_SAMPLES;</a>
<a name="ln1795">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1796">  {</a>
<a name="ln1797">    profile_info-&gt;lut_in[i] = malloc(profile_info-&gt;lutsize * sizeof(float));</a>
<a name="ln1798">    profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1799">    profile_info-&gt;lut_out[i] = malloc(profile_info-&gt;lutsize * sizeof(float));</a>
<a name="ln1800">    profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1801">  }</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">#undef DT_IOPPR_LUT_SAMPLES</a>
<a name="ln1805"> </a>
<a name="ln1806">void dt_ioppr_cleanup_profile_info(dt_iop_order_iccprofile_info_t *profile_info)</a>
<a name="ln1807">{</a>
<a name="ln1808">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1809">  {</a>
<a name="ln1810">    if(profile_info-&gt;lut_in[i]) free(profile_info-&gt;lut_in[i]);</a>
<a name="ln1811">    if(profile_info-&gt;lut_out[i]) free(profile_info-&gt;lut_out[i]);</a>
<a name="ln1812">  }</a>
<a name="ln1813">}</a>
<a name="ln1814"> </a>
<a name="ln1815">/** generate the info for the profile (type, filename) if matrix can be retrieved from lcms2</a>
<a name="ln1816"> * it can be called multiple time between init and cleanup</a>
<a name="ln1817"> * return 0 if OK, non zero otherwise</a>
<a name="ln1818"> */</a>
<a name="ln1819">static int dt_ioppr_generate_profile_info(dt_iop_order_iccprofile_info_t *profile_info, const int type, const char *filename, const int intent)</a>
<a name="ln1820">{</a>
<a name="ln1821">  int err_code = 0;</a>
<a name="ln1822">  cmsHPROFILE *rgb_profile = NULL;</a>
<a name="ln1823"> </a>
<a name="ln1824">  profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1825">  profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1826">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1827">  {</a>
<a name="ln1828">    profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1829">    profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1830">  }</a>
<a name="ln1831"> </a>
<a name="ln1832">  profile_info-&gt;nonlinearlut = 0;</a>
<a name="ln1833">  profile_info-&gt;grey = 0.1842f;</a>
<a name="ln1834">  </a>
<a name="ln1835">  profile_info-&gt;type = type;</a>
<a name="ln1836">  g_strlcpy(profile_info-&gt;filename, filename, sizeof(profile_info-&gt;filename));</a>
<a name="ln1837">  profile_info-&gt;intent = intent;</a>
<a name="ln1838"> </a>
<a name="ln1839">  if(type == DT_COLORSPACE_DISPLAY) pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1840"> </a>
<a name="ln1841">  const dt_colorspaces_color_profile_t *profile</a>
<a name="ln1842">      = dt_colorspaces_get_profile(type, filename, DT_PROFILE_DIRECTION_ANY);</a>
<a name="ln1843">  if(profile) rgb_profile = profile-&gt;profile;</a>
<a name="ln1844"> </a>
<a name="ln1845">  if(type == DT_COLORSPACE_DISPLAY) pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1846"> </a>
<a name="ln1847">  // we only allow rgb profiles</a>
<a name="ln1848">  if(rgb_profile)</a>
<a name="ln1849">  {</a>
<a name="ln1850">    cmsColorSpaceSignature rgb_color_space = cmsGetColorSpace(rgb_profile);</a>
<a name="ln1851">    if(rgb_color_space != cmsSigRgbData)</a>
<a name="ln1852">    {</a>
<a name="ln1853">      fprintf(stderr, &quot;working profile color space `%c%c%c%c' not supported\n&quot;,</a>
<a name="ln1854">              (char)(rgb_color_space&gt;&gt;24),</a>
<a name="ln1855">              (char)(rgb_color_space&gt;&gt;16),</a>
<a name="ln1856">              (char)(rgb_color_space&gt;&gt;8),</a>
<a name="ln1857">              (char)(rgb_color_space));</a>
<a name="ln1858">      rgb_profile = NULL;</a>
<a name="ln1859">    }</a>
<a name="ln1860">  }</a>
<a name="ln1861">  </a>
<a name="ln1862">  // get the matrix</a>
<a name="ln1863">  if(rgb_profile)</a>
<a name="ln1864">  {</a>
<a name="ln1865">    if(dt_colorspaces_get_matrix_from_input_profile(rgb_profile, profile_info-&gt;matrix_in, </a>
<a name="ln1866">        profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln1867">        profile_info-&gt;lutsize, profile_info-&gt;intent) ||</a>
<a name="ln1868">        dt_colorspaces_get_matrix_from_output_profile(rgb_profile, profile_info-&gt;matrix_out, </a>
<a name="ln1869">            profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln1870">            profile_info-&gt;lutsize, profile_info-&gt;intent))</a>
<a name="ln1871">    {</a>
<a name="ln1872">      profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1873">      profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1874">      for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1875">      {</a>
<a name="ln1876">        profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1877">        profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1878">      }</a>
<a name="ln1879">    }</a>
<a name="ln1880">    else if(isnan(profile_info-&gt;matrix_in[0]) || isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln1881">    {</a>
<a name="ln1882">      profile_info-&gt;matrix_in[0] = NAN;</a>
<a name="ln1883">      profile_info-&gt;matrix_out[0] = NAN;</a>
<a name="ln1884">      for(int i = 0; i &lt; 3; i++)</a>
<a name="ln1885">      {</a>
<a name="ln1886">        profile_info-&gt;lut_in[i][0] = -1.0f;</a>
<a name="ln1887">        profile_info-&gt;lut_out[i][0] = -1.0f;</a>
<a name="ln1888">      }</a>
<a name="ln1889">    }</a>
<a name="ln1890">  }</a>
<a name="ln1891"> </a>
<a name="ln1892">  // now try to initialize unbounded mode:</a>
<a name="ln1893">  // we do extrapolation for input values above 1.0f.</a>
<a name="ln1894">  // unfortunately we can only do this if we got the computation</a>
<a name="ln1895">  // in our hands, i.e. for the fast builtin-dt-matrix-profile path.</a>
<a name="ln1896">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln1897">  {</a>
<a name="ln1898">    profile_info-&gt;nonlinearlut = _init_unbounded_coeffs(profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2], </a>
<a name="ln1899">        profile_info-&gt;unbounded_coeffs_in[0], profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2], profile_info-&gt;lutsize);</a>
<a name="ln1900">    _init_unbounded_coeffs(profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2], </a>
<a name="ln1901">        profile_info-&gt;unbounded_coeffs_out[0], profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2], profile_info-&gt;lutsize);</a>
<a name="ln1902">  }</a>
<a name="ln1903">  </a>
<a name="ln1904">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]) &amp;&amp; profile_info-&gt;nonlinearlut)</a>
<a name="ln1905">  {</a>
<a name="ln1906">    float rgb[3] = { 0.1842f, 0.1842f, 0.1842f };</a>
<a name="ln1907">    profile_info-&gt;grey = dt_ioppr_get_rgb_matrix_luminance(rgb, profile_info);</a>
<a name="ln1908">  }</a>
<a name="ln1909">  </a>
<a name="ln1910">  return err_code;</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913">dt_iop_order_iccprofile_info_t *dt_ioppr_get_profile_info_from_list(struct dt_develop_t *dev, const int profile_type, const char *profile_filename)</a>
<a name="ln1914">{</a>
<a name="ln1915">  dt_iop_order_iccprofile_info_t *profile_info = NULL;</a>
<a name="ln1916">  </a>
<a name="ln1917">  GList *profiles = g_list_first(dev-&gt;allprofile_info);</a>
<a name="ln1918">  while(profiles)</a>
<a name="ln1919">  {</a>
<a name="ln1920">    dt_iop_order_iccprofile_info_t *prof = (dt_iop_order_iccprofile_info_t *)(profiles-&gt;data);</a>
<a name="ln1921">    if(prof-&gt;type == profile_type &amp;&amp; strcmp(prof-&gt;filename, profile_filename) == 0)</a>
<a name="ln1922">    {</a>
<a name="ln1923">      profile_info = prof;</a>
<a name="ln1924">      break;</a>
<a name="ln1925">    }</a>
<a name="ln1926">    profiles = g_list_next(profiles);</a>
<a name="ln1927">  }</a>
<a name="ln1928">  </a>
<a name="ln1929">  return profile_info;</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">dt_iop_order_iccprofile_info_t *dt_ioppr_add_profile_info_to_list(struct dt_develop_t *dev, const int profile_type, const char *profile_filename, const int intent)</a>
<a name="ln1933">{</a>
<a name="ln1934">  dt_iop_order_iccprofile_info_t *profile_info = dt_ioppr_get_profile_info_from_list(dev, profile_type, profile_filename);</a>
<a name="ln1935">  if(profile_info == NULL)</a>
<a name="ln1936">  {</a>
<a name="ln1937">    profile_info = malloc(sizeof(dt_iop_order_iccprofile_info_t));</a>
<a name="ln1938">    dt_ioppr_init_profile_info(profile_info, 0);</a>
<a name="ln1939">    const int err = dt_ioppr_generate_profile_info(profile_info, profile_type, profile_filename, intent);</a>
<a name="ln1940">    if(err == 0)</a>
<a name="ln1941">    {</a>
<a name="ln1942">      dev-&gt;allprofile_info = g_list_append(dev-&gt;allprofile_info, profile_info);</a>
<a name="ln1943">    }</a>
<a name="ln1944">    else</a>
<a name="ln1945">    {</a>
<a name="ln1946">      free(profile_info);</a>
<a name="ln1947">      profile_info = NULL;</a>
<a name="ln1948">    }</a>
<a name="ln1949">  }</a>
<a name="ln1950">  return profile_info;</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">dt_iop_order_iccprofile_info_t *dt_ioppr_get_iop_work_profile_info(struct dt_iop_module_t *module, GList *iop_list)</a>
<a name="ln1954">{</a>
<a name="ln1955">  dt_iop_order_iccprofile_info_t *profile = NULL;</a>
<a name="ln1956"> </a>
<a name="ln1957">  // first check if the module is between colorin and colorout</a>
<a name="ln1958">  gboolean in_between = FALSE;</a>
<a name="ln1959"> </a>
<a name="ln1960">  GList *modules = g_list_first(iop_list);</a>
<a name="ln1961">  while(modules)</a>
<a name="ln1962">  {</a>
<a name="ln1963">    dt_iop_module_t *mod = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1964"> </a>
<a name="ln1965">    // we reach the module, that's it</a>
<a name="ln1966">    if(strcmp(mod-&gt;op, module-&gt;op) == 0) break;</a>
<a name="ln1967"> </a>
<a name="ln1968">    // if we reach colorout means that the module is after it</a>
<a name="ln1969">    if(strcmp(mod-&gt;op, &quot;colorout&quot;) == 0)</a>
<a name="ln1970">    {</a>
<a name="ln1971">      in_between = FALSE;</a>
<a name="ln1972">      break;</a>
<a name="ln1973">    }</a>
<a name="ln1974"> </a>
<a name="ln1975">    // we reach colorin, so far we're good</a>
<a name="ln1976">    if(strcmp(mod-&gt;op, &quot;colorin&quot;) == 0)</a>
<a name="ln1977">    {</a>
<a name="ln1978">      in_between = TRUE;</a>
<a name="ln1979">      break;</a>
<a name="ln1980">    }</a>
<a name="ln1981"> </a>
<a name="ln1982">    modules = g_list_next(modules);</a>
<a name="ln1983">  }</a>
<a name="ln1984"> </a>
<a name="ln1985">  if(in_between)</a>
<a name="ln1986">  {</a>
<a name="ln1987">    dt_colorspaces_color_profile_type_t type = DT_COLORSPACE_NONE;</a>
<a name="ln1988">    char *filename = NULL;</a>
<a name="ln1989">    dt_develop_t *dev = module-&gt;dev;</a>
<a name="ln1990"> </a>
<a name="ln1991">    dt_ioppr_get_work_profile_type(dev, &amp;type, &amp;filename);</a>
<a name="ln1992">    if(filename) profile = dt_ioppr_add_profile_info_to_list(dev, type, filename, DT_INTENT_PERCEPTUAL);</a>
<a name="ln1993">  }</a>
<a name="ln1994"> </a>
<a name="ln1995">  return profile;</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">dt_iop_order_iccprofile_info_t *dt_ioppr_set_pipe_work_profile_info(struct dt_develop_t *dev, struct dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1999">    const int type, const char *filename, const int intent)</a>
<a name="ln2000">{</a>
<a name="ln2001">  dt_iop_order_iccprofile_info_t *profile_info = dt_ioppr_add_profile_info_to_list(dev, type, filename, intent);</a>
<a name="ln2002">  </a>
<a name="ln2003">  if(profile_info == NULL || isnan(profile_info-&gt;matrix_in[0]) || isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2004">  {</a>
<a name="ln2005">    fprintf(stderr, &quot;[dt_ioppr_set_pipe_work_profile_info] unsupported working profile %i %s, it will be replaced with linear rec2020\n&quot;, type, filename);</a>
<a name="ln2006">    profile_info = dt_ioppr_add_profile_info_to_list(dev, DT_COLORSPACE_LIN_REC2020, &quot;&quot;, intent);</a>
<a name="ln2007">  }</a>
<a name="ln2008">  pipe-&gt;dsc.work_profile_info = profile_info;</a>
<a name="ln2009">  </a>
<a name="ln2010">  return profile_info;</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013">dt_iop_order_iccprofile_info_t *dt_ioppr_get_pipe_work_profile_info(struct dt_dev_pixelpipe_t *pipe)</a>
<a name="ln2014">{</a>
<a name="ln2015">  return pipe-&gt;dsc.work_profile_info;</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018">// returns a pointer to the filename of the work profile instead of the actual string data</a>
<a name="ln2019">// pointer must not be stored</a>
<a name="ln2020">void dt_ioppr_get_work_profile_type(struct dt_develop_t *dev, int *profile_type, char **profile_filename)</a>
<a name="ln2021">{</a>
<a name="ln2022">  *profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln2023">  *profile_filename = NULL;</a>
<a name="ln2024">  </a>
<a name="ln2025">  // use introspection to get the params values</a>
<a name="ln2026">  dt_iop_module_so_t *colorin_so = NULL;</a>
<a name="ln2027">  dt_iop_module_t *colorin = NULL;</a>
<a name="ln2028">  GList *modules = g_list_first(darktable.iop);</a>
<a name="ln2029">  while(modules)</a>
<a name="ln2030">  {</a>
<a name="ln2031">    dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln2032">    if(!strcmp(module_so-&gt;op, &quot;colorin&quot;))</a>
<a name="ln2033">    {</a>
<a name="ln2034">      colorin_so = module_so;</a>
<a name="ln2035">      break;</a>
<a name="ln2036">    }</a>
<a name="ln2037">    modules = g_list_next(modules);</a>
<a name="ln2038">  }</a>
<a name="ln2039">  if(colorin_so &amp;&amp; colorin_so-&gt;get_p)</a>
<a name="ln2040">  {</a>
<a name="ln2041">    modules = g_list_first(dev-&gt;iop);</a>
<a name="ln2042">    while(modules)</a>
<a name="ln2043">    {</a>
<a name="ln2044">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2045">      if(!strcmp(module-&gt;op, &quot;colorin&quot;))</a>
<a name="ln2046">      {</a>
<a name="ln2047">        colorin = module;</a>
<a name="ln2048">        break;</a>
<a name="ln2049">      }</a>
<a name="ln2050">      modules = g_list_next(modules);</a>
<a name="ln2051">    }</a>
<a name="ln2052">  }</a>
<a name="ln2053">  if(colorin)</a>
<a name="ln2054">  {</a>
<a name="ln2055">    dt_colorspaces_color_profile_type_t *_type = colorin_so-&gt;get_p(colorin-&gt;params, &quot;type_work&quot;);</a>
<a name="ln2056">    char *_filename = colorin_so-&gt;get_p(colorin-&gt;params, &quot;filename_work&quot;);</a>
<a name="ln2057">    if(_type &amp;&amp; _filename)</a>
<a name="ln2058">    {</a>
<a name="ln2059">      *profile_type = *_type;</a>
<a name="ln2060">      *profile_filename = _filename;</a>
<a name="ln2061">    }</a>
<a name="ln2062">    else</a>
<a name="ln2063">      fprintf(stderr, &quot;[dt_ioppr_get_work_profile_type] can't get colorin parameters\n&quot;);</a>
<a name="ln2064">  }</a>
<a name="ln2065">  else</a>
<a name="ln2066">    fprintf(stderr, &quot;[dt_ioppr_get_work_profile_type] can't find colorin iop\n&quot;);</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">void dt_ioppr_get_export_profile_type(struct dt_develop_t *dev, int *profile_type, char **profile_filename)</a>
<a name="ln2070">{</a>
<a name="ln2071">  *profile_type = DT_COLORSPACE_NONE;</a>
<a name="ln2072">  *profile_filename = NULL;</a>
<a name="ln2073">  </a>
<a name="ln2074">  // use introspection to get the params values</a>
<a name="ln2075">  dt_iop_module_so_t *colorout_so = NULL;</a>
<a name="ln2076">  dt_iop_module_t *colorout = NULL;</a>
<a name="ln2077">  GList *modules = g_list_last(darktable.iop);</a>
<a name="ln2078">  while(modules)</a>
<a name="ln2079">  {</a>
<a name="ln2080">    dt_iop_module_so_t *module_so = (dt_iop_module_so_t *)(modules-&gt;data);</a>
<a name="ln2081">    if(!strcmp(module_so-&gt;op, &quot;colorout&quot;))</a>
<a name="ln2082">    {</a>
<a name="ln2083">      colorout_so = module_so;</a>
<a name="ln2084">      break;</a>
<a name="ln2085">    }</a>
<a name="ln2086">    modules = g_list_previous(modules);</a>
<a name="ln2087">  }</a>
<a name="ln2088">  if(colorout_so &amp;&amp; colorout_so-&gt;get_p)</a>
<a name="ln2089">  {</a>
<a name="ln2090">    modules = g_list_last(dev-&gt;iop);</a>
<a name="ln2091">    while(modules)</a>
<a name="ln2092">    {</a>
<a name="ln2093">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln2094">      if(!strcmp(module-&gt;op, &quot;colorout&quot;))</a>
<a name="ln2095">      {</a>
<a name="ln2096">        colorout = module;</a>
<a name="ln2097">        break;</a>
<a name="ln2098">      }</a>
<a name="ln2099">      modules = g_list_previous(modules);</a>
<a name="ln2100">    }</a>
<a name="ln2101">  }</a>
<a name="ln2102">  if(colorout)</a>
<a name="ln2103">  {</a>
<a name="ln2104">    dt_colorspaces_color_profile_type_t *_type = colorout_so-&gt;get_p(colorout-&gt;params, &quot;type&quot;);</a>
<a name="ln2105">    char *_filename = colorout_so-&gt;get_p(colorout-&gt;params, &quot;filename&quot;);</a>
<a name="ln2106">    if(_type &amp;&amp; _filename)</a>
<a name="ln2107">    {</a>
<a name="ln2108">      *profile_type = *_type;</a>
<a name="ln2109">      *profile_filename = _filename;</a>
<a name="ln2110">    }</a>
<a name="ln2111">    else</a>
<a name="ln2112">      fprintf(stderr, &quot;[dt_ioppr_get_export_profile_type] can't get colorout parameters\n&quot;);</a>
<a name="ln2113">  }</a>
<a name="ln2114">  else</a>
<a name="ln2115">    fprintf(stderr, &quot;[dt_ioppr_get_export_profile_type] can't find colorout iop\n&quot;);</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118">float dt_ioppr_get_rgb_matrix_luminance(const float *const rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2119">{</a>
<a name="ln2120">  float luminance = 0.f;</a>
<a name="ln2121">  </a>
<a name="ln2122">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln2123">  {</a>
<a name="ln2124">    float linear_rgb[3] = { 0.f };</a>
<a name="ln2125"> </a>
<a name="ln2126">    _apply_trc_in(rgb, linear_rgb, profile_info);</a>
<a name="ln2127">    luminance = profile_info-&gt;matrix_in[3] * linear_rgb[0] + profile_info-&gt;matrix_in[4] * linear_rgb[1] + profile_info-&gt;matrix_in[5] * linear_rgb[2];</a>
<a name="ln2128">  }</a>
<a name="ln2129">  else</a>
<a name="ln2130">    luminance = profile_info-&gt;matrix_in[3] * rgb[0] + profile_info-&gt;matrix_in[4] * rgb[1] + profile_info-&gt;matrix_in[5] * rgb[2];</a>
<a name="ln2131">  </a>
<a name="ln2132">  return luminance;</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135">void dt_ioppr_rgb_matrix_to_xyz(const float *const rgb, float *xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2136">{</a>
<a name="ln2137">  if(profile_info-&gt;nonlinearlut)</a>
<a name="ln2138">  {</a>
<a name="ln2139">    float linear_rgb[3];</a>
<a name="ln2140">    _apply_trc_in(rgb, linear_rgb, profile_info);</a>
<a name="ln2141">    _ioppr_linear_rgb_matrix_to_xyz(linear_rgb, xyz, profile_info);</a>
<a name="ln2142">  }</a>
<a name="ln2143">  else</a>
<a name="ln2144">    _ioppr_linear_rgb_matrix_to_xyz(rgb, xyz, profile_info);</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">void dt_ioppr_lab_to_rgb_matrix(const float *const lab, float *rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2148">{</a>
<a name="ln2149">  float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln2150">  </a>
<a name="ln2151">  dt_Lab_to_XYZ(lab, xyz);</a>
<a name="ln2152">  </a>
<a name="ln2153">  _ioppr_xyz_to_linear_rgb_matrix(xyz, rgb, profile_info);</a>
<a name="ln2154">  </a>
<a name="ln2155">  if(profile_info-&gt;nonlinearlut) _apply_trc_out(rgb, rgb, profile_info);</a>
<a name="ln2156">}</a>
<a name="ln2157"> </a>
<a name="ln2158">void dt_ioppr_rgb_matrix_to_lab(const float *const rgb, float *lab, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2159">{</a>
<a name="ln2160">  float xyz[3] = { 0.0f, 0.0f, 0.0f };</a>
<a name="ln2161"> </a>
<a name="ln2162">  dt_ioppr_rgb_matrix_to_xyz(rgb, xyz, profile_info);</a>
<a name="ln2163"> </a>
<a name="ln2164">  dt_XYZ_to_Lab(xyz, lab);</a>
<a name="ln2165">}</a>
<a name="ln2166"> </a>
<a name="ln2167">float dt_ioppr_get_profile_info_middle_grey(const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2168">{</a>
<a name="ln2169">  return profile_info-&gt;grey;</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">float dt_ioppr_compensate_middle_grey(const float x, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2173">{</a>
<a name="ln2174">  // we transform the curve nodes from the image colorspace to lab</a>
<a name="ln2175">  float lab[3] = { 0 };</a>
<a name="ln2176">  float rgb[3] = { 0 };</a>
<a name="ln2177"> </a>
<a name="ln2178">  rgb[0] = rgb[1] = rgb[2] = x;</a>
<a name="ln2179">  dt_ioppr_rgb_matrix_to_lab(rgb, lab, profile_info);</a>
<a name="ln2180">  return lab[0] * .01f;</a>
<a name="ln2181">}</a>
<a name="ln2182"> </a>
<a name="ln2183">float dt_ioppr_uncompensate_middle_grey(const float x, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2184">{</a>
<a name="ln2185">  // we transform the curve nodes from lab to the image colorspace</a>
<a name="ln2186">  float lab[3] = { 0 };</a>
<a name="ln2187">  float rgb[3] = { 0 };</a>
<a name="ln2188"> </a>
<a name="ln2189">  lab[0] = x * 100.f;</a>
<a name="ln2190">  dt_ioppr_lab_to_rgb_matrix(lab, rgb, profile_info);</a>
<a name="ln2191">  return rgb[0];</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194">#if defined(__SSE2__x) // FIXME: this is slower than the C version</a>
<a name="ln2195">static __m128 _ioppr_linear_rgb_matrix_to_xyz_sse(const __m128 rgb, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2196">{</a>
<a name="ln2197">/*  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2198">  {</a>
<a name="ln2199">    xyz[c] = 0.0f;</a>
<a name="ln2200">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2201">    {</a>
<a name="ln2202">      xyz[c] += profile_info-&gt;matrix_in[3 * c + i] * rgb[i];</a>
<a name="ln2203">    }</a>
<a name="ln2204">  }*/</a>
<a name="ln2205">  const __m128 m0 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[6], profile_info-&gt;matrix_in[3], profile_info-&gt;matrix_in[0]);</a>
<a name="ln2206">  const __m128 m1 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[7], profile_info-&gt;matrix_in[4], profile_info-&gt;matrix_in[1]);</a>
<a name="ln2207">  const __m128 m2 = _mm_set_ps(0.0f, profile_info-&gt;matrix_in[8], profile_info-&gt;matrix_in[5], profile_info-&gt;matrix_in[2]);</a>
<a name="ln2208"> </a>
<a name="ln2209">  __m128 xyz</a>
<a name="ln2210">      = _mm_add_ps(_mm_mul_ps(m0, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(0, 0, 0, 0))),</a>
<a name="ln2211">                   _mm_add_ps(_mm_mul_ps(m1, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(1, 1, 1, 1))),</a>
<a name="ln2212">                              _mm_mul_ps(m2, _mm_shuffle_ps(rgb, rgb, _MM_SHUFFLE(2, 2, 2, 2)))));</a>
<a name="ln2213">  return xyz;</a>
<a name="ln2214">}</a>
<a name="ln2215"> </a>
<a name="ln2216">static __m128 _ioppr_xyz_to_linear_rgb_matrix_sse(const __m128 xyz, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2217">{</a>
<a name="ln2218">/*  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2219">  {</a>
<a name="ln2220">    rgb[c] = 0.0f;</a>
<a name="ln2221">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2222">    {</a>
<a name="ln2223">      rgb[c] += profile_info-&gt;matrix_out[3 * c + i] * xyz[i];</a>
<a name="ln2224">    }</a>
<a name="ln2225">  }*/</a>
<a name="ln2226">  const __m128 m0 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[6], profile_info-&gt;matrix_out[3], profile_info-&gt;matrix_out[0]);</a>
<a name="ln2227">  const __m128 m1 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[7], profile_info-&gt;matrix_out[4], profile_info-&gt;matrix_out[1]);</a>
<a name="ln2228">  const __m128 m2 = _mm_set_ps(0.0f, profile_info-&gt;matrix_out[8], profile_info-&gt;matrix_out[5], profile_info-&gt;matrix_out[2]);</a>
<a name="ln2229"> </a>
<a name="ln2230">  __m128 rgb</a>
<a name="ln2231">      = _mm_add_ps(_mm_mul_ps(m0, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(0, 0, 0, 0))),</a>
<a name="ln2232">                   _mm_add_ps(_mm_mul_ps(m1, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(1, 1, 1, 1))),</a>
<a name="ln2233">                              _mm_mul_ps(m2, _mm_shuffle_ps(xyz, xyz, _MM_SHUFFLE(2, 2, 2, 2)))));</a>
<a name="ln2234">  return rgb;</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">static void _transform_rgb_to_lab_matrix_sse(float *const image, const int width, const int height, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2238">{</a>
<a name="ln2239">  const int ch = 4;</a>
<a name="ln2240">  const size_t stride = (size_t)(width * height);</a>
<a name="ln2241"> </a>
<a name="ln2242">  _apply_tonecurves(image, width, height, profile_info-&gt;lut_in[0], profile_info-&gt;lut_in[1], profile_info-&gt;lut_in[2],</a>
<a name="ln2243">      profile_info-&gt;unbounded_coeffs_in[0], profile_info-&gt;unbounded_coeffs_in[1], profile_info-&gt;unbounded_coeffs_in[2], profile_info-&gt;lutsize);</a>
<a name="ln2244">    </a>
<a name="ln2245">#ifdef _OPENMP</a>
<a name="ln2246">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2247">#endif</a>
<a name="ln2248">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2249">  {</a>
<a name="ln2250">    float *const in = image + y * ch;</a>
<a name="ln2251"> </a>
<a name="ln2252">    __m128 xyz = { 0.0f };</a>
<a name="ln2253">    __m128 rgb = _mm_load_ps(in);</a>
<a name="ln2254"> </a>
<a name="ln2255">    xyz = _ioppr_linear_rgb_matrix_to_xyz_sse(rgb, profile_info);</a>
<a name="ln2256"> </a>
<a name="ln2257">    rgb = dt_XYZ_to_Lab_sse2(xyz);</a>
<a name="ln2258">    const float a = in[3];</a>
<a name="ln2259">    _mm_stream_ps(in, rgb);</a>
<a name="ln2260">    in[3] = a;</a>
<a name="ln2261">  }</a>
<a name="ln2262">}</a>
<a name="ln2263"> </a>
<a name="ln2264">static void _transform_lab_to_rgb_matrix_sse(float *const image, const int width, const int height, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2265">{</a>
<a name="ln2266">  const int ch = 4;</a>
<a name="ln2267">  const size_t stride = (size_t)width * height;</a>
<a name="ln2268"> </a>
<a name="ln2269">#ifdef _OPENMP</a>
<a name="ln2270">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2271">#endif</a>
<a name="ln2272">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2273">  {</a>
<a name="ln2274">    float *const in = image + y * ch;</a>
<a name="ln2275"> </a>
<a name="ln2276">    __m128 xyz = { 0.0f };</a>
<a name="ln2277">    __m128 lab = _mm_load_ps(in);</a>
<a name="ln2278"> </a>
<a name="ln2279">    xyz = dt_Lab_to_XYZ_sse2(lab);</a>
<a name="ln2280">    lab = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info);</a>
<a name="ln2281">    const float a = in[3];</a>
<a name="ln2282">    _mm_stream_ps(in, lab);</a>
<a name="ln2283">    in[3] = a;</a>
<a name="ln2284">  }</a>
<a name="ln2285">  </a>
<a name="ln2286">  _apply_tonecurves(image, width, height, profile_info-&gt;lut_out[0], profile_info-&gt;lut_out[1], profile_info-&gt;lut_out[2],</a>
<a name="ln2287">      profile_info-&gt;unbounded_coeffs_out[0], profile_info-&gt;unbounded_coeffs_out[1], profile_info-&gt;unbounded_coeffs_out[2], profile_info-&gt;lutsize);</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">// FIXME: this is slower than the C version</a>
<a name="ln2291">static void _transform_matrix_sse(struct dt_iop_module_t *self, float *const image, const int width, const int height,</a>
<a name="ln2292">    const int cst_from, const int cst_to, int *converted_cst, const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2293">{</a>
<a name="ln2294">  if(cst_from == cst_to)</a>
<a name="ln2295">  {</a>
<a name="ln2296">    *converted_cst = cst_to;</a>
<a name="ln2297">    return;</a>
<a name="ln2298">  }</a>
<a name="ln2299"> </a>
<a name="ln2300">  *converted_cst = cst_to;</a>
<a name="ln2301"> </a>
<a name="ln2302">  if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2303">  {</a>
<a name="ln2304">    _transform_rgb_to_lab_matrix_sse(image, width, height, profile_info);</a>
<a name="ln2305">  }</a>
<a name="ln2306">  else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2307">  {</a>
<a name="ln2308">    _transform_lab_to_rgb_matrix_sse(image, width, height, profile_info);</a>
<a name="ln2309">  }</a>
<a name="ln2310">  else</a>
<a name="ln2311">  {</a>
<a name="ln2312">    *converted_cst = cst_from;</a>
<a name="ln2313">    fprintf(stderr, &quot;[_transform_matrix_sse] invalid convertion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2314">  }</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317">static void _transform_matrix_rgb_sse(float *const image, const int width, const int height,</a>
<a name="ln2318">                                      const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2319">                                      const dt_iop_order_iccprofile_info_t *const profile_info_to)</a>
<a name="ln2320">{</a>
<a name="ln2321">  const int ch = 4;</a>
<a name="ln2322">  const size_t stride = (size_t)(width * height);</a>
<a name="ln2323"> </a>
<a name="ln2324">  _apply_tonecurves(image, width, height, profile_info_from-&gt;lut_in[0], profile_info_from-&gt;lut_in[1],</a>
<a name="ln2325">                    profile_info_from-&gt;lut_in[2], profile_info_from-&gt;unbounded_coeffs_in[0],</a>
<a name="ln2326">                    profile_info_from-&gt;unbounded_coeffs_in[1], profile_info_from-&gt;unbounded_coeffs_in[2],</a>
<a name="ln2327">                    profile_info_from-&gt;lutsize);</a>
<a name="ln2328"> </a>
<a name="ln2329">#ifdef _OPENMP</a>
<a name="ln2330">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln2331">#endif</a>
<a name="ln2332">  for(size_t y = 0; y &lt; stride; y++)</a>
<a name="ln2333">  {</a>
<a name="ln2334">    float *const in = image + y * ch;</a>
<a name="ln2335"> </a>
<a name="ln2336">    __m128 xyz = { 0.0f };</a>
<a name="ln2337">    __m128 rgb = _mm_load_ps(in);</a>
<a name="ln2338"> </a>
<a name="ln2339">    xyz = _ioppr_linear_rgb_matrix_to_xyz_sse(rgb, profile_info_from);</a>
<a name="ln2340">    rgb = _ioppr_xyz_to_linear_rgb_matrix_sse(xyz, profile_info_to);</a>
<a name="ln2341"> </a>
<a name="ln2342">    const float a = in[3];</a>
<a name="ln2343">    _mm_stream_ps(in, rgb);</a>
<a name="ln2344">    in[3] = a;</a>
<a name="ln2345">  }</a>
<a name="ln2346"> </a>
<a name="ln2347">  _apply_tonecurves(image, width, height, profile_info_to-&gt;lut_out[0], profile_info_to-&gt;lut_out[1],</a>
<a name="ln2348">                    profile_info_to-&gt;lut_out[2], profile_info_to-&gt;unbounded_coeffs_out[0],</a>
<a name="ln2349">                    profile_info_to-&gt;unbounded_coeffs_out[1], profile_info_to-&gt;unbounded_coeffs_out[2],</a>
<a name="ln2350">                    profile_info_to-&gt;lutsize);</a>
<a name="ln2351">}</a>
<a name="ln2352">#endif</a>
<a name="ln2353"> </a>
<a name="ln2354">void dt_ioppr_transform_image_colorspace(struct dt_iop_module_t *self, const float *const image_in,</a>
<a name="ln2355">                                         float *const image_out, const int width, const int height,</a>
<a name="ln2356">                                         const int cst_from, const int cst_to, int *converted_cst,</a>
<a name="ln2357">                                         const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2358">{</a>
<a name="ln2359">  if(cst_from == cst_to)</a>
<a name="ln2360">  {</a>
<a name="ln2361">    *converted_cst = cst_to;</a>
<a name="ln2362">    return;</a>
<a name="ln2363">  }</a>
<a name="ln2364">  if(profile_info == NULL)</a>
<a name="ln2365">  {</a>
<a name="ln2366">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace] module %s must be between input color profile and output color profile\n&quot;, self-&gt;op);</a>
<a name="ln2367">    *converted_cst = cst_from;</a>
<a name="ln2368">    return;</a>
<a name="ln2369">  }</a>
<a name="ln2370">  if(profile_info-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2371">  {</a>
<a name="ln2372">    *converted_cst = cst_from;</a>
<a name="ln2373">    return;</a>
<a name="ln2374">  }</a>
<a name="ln2375"> </a>
<a name="ln2376">  dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2377">  if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2378">  </a>
<a name="ln2379">  // matrix should be never NAN, this is only to test it against lcms2!</a>
<a name="ln2380">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2381">  {</a>
<a name="ln2382">    // FIXME: sse is slower than the C version</a>
<a name="ln2383">    // if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln2384">    _transform_matrix(self, image_in, image_out, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2385">    /*</a>
<a name="ln2386">    #if defined(__SSE2__)</a>
<a name="ln2387">        else if(darktable.codepath.SSE2)</a>
<a name="ln2388">          _transform_matrix_sse(self, image, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2389">    #endif</a>
<a name="ln2390">        else</a>
<a name="ln2391">          dt_unreachable_codepath();</a>
<a name="ln2392">    */</a>
<a name="ln2393">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2394">    {</a>
<a name="ln2395">      dt_get_times(&amp;end_time);</a>
<a name="ln2396">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f CPU) [%s %s]\n&quot;, </a>
<a name="ln2397">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, </a>
<a name="ln2398">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2399">    }</a>
<a name="ln2400">  }</a>
<a name="ln2401">  else</a>
<a name="ln2402">  {</a>
<a name="ln2403">    _transform_lcms2(self, image_in, image_out, width, height, cst_from, cst_to, converted_cst, profile_info);</a>
<a name="ln2404"> </a>
<a name="ln2405">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2406">    {</a>
<a name="ln2407">      dt_get_times(&amp;end_time);</a>
<a name="ln2408">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f lcms2) [%s %s]\n&quot;, </a>
<a name="ln2409">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, </a>
<a name="ln2410">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2411">    }</a>
<a name="ln2412">  }</a>
<a name="ln2413">  </a>
<a name="ln2414">  if(*converted_cst == cst_from)</a>
<a name="ln2415">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace] invalid convertion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2416">}</a>
<a name="ln2417"> </a>
<a name="ln2418">void dt_ioppr_transform_image_colorspace_rgb(const float *const image_in, float *const image_out, const int width,</a>
<a name="ln2419">                                             const int height,</a>
<a name="ln2420">                                             const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2421">                                             const dt_iop_order_iccprofile_info_t *const profile_info_to,</a>
<a name="ln2422">                                             const char *message)</a>
<a name="ln2423">{</a>
<a name="ln2424">  if(profile_info_from-&gt;type == DT_COLORSPACE_NONE || profile_info_to-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2425">  {</a>
<a name="ln2426">    return;</a>
<a name="ln2427">  }</a>
<a name="ln2428">  if(profile_info_from-&gt;type == profile_info_to-&gt;type</a>
<a name="ln2429">     &amp;&amp; strcmp(profile_info_from-&gt;filename, profile_info_to-&gt;filename) == 0)</a>
<a name="ln2430">  {</a>
<a name="ln2431">    if(image_in != image_out)</a>
<a name="ln2432">      memcpy(image_out, image_in, width * height * 4 * sizeof(float));</a>
<a name="ln2433"> </a>
<a name="ln2434">    return;</a>
<a name="ln2435">  }</a>
<a name="ln2436"> </a>
<a name="ln2437">  dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2438">  if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2439"> </a>
<a name="ln2440">  if(!isnan(profile_info_from-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_from-&gt;matrix_out[0])</a>
<a name="ln2441">     &amp;&amp; !isnan(profile_info_to-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_to-&gt;matrix_out[0]))</a>
<a name="ln2442">  {</a>
<a name="ln2443">    // FIXME: sse is slower than the C version</a>
<a name="ln2444">    // if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln2445">    _transform_matrix_rgb(image_in, image_out, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2446">    /*</a>
<a name="ln2447">    #if defined(__SSE2__)</a>
<a name="ln2448">        else if(darktable.codepath.SSE2)</a>
<a name="ln2449">          _transform_matrix_rgb_sse(self, image, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2450">    #endif</a>
<a name="ln2451">        else</a>
<a name="ln2452">          dt_unreachable_codepath();</a>
<a name="ln2453">    */</a>
<a name="ln2454">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2455">    {</a>
<a name="ln2456">      dt_get_times(&amp;end_time);</a>
<a name="ln2457">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f CPU) [%s]\n&quot;,</a>
<a name="ln2458">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2459">    }</a>
<a name="ln2460">  }</a>
<a name="ln2461">  else</a>
<a name="ln2462">  {</a>
<a name="ln2463">    _transform_lcms2_rgb(image_in, image_out, width, height, profile_info_from, profile_info_to);</a>
<a name="ln2464"> </a>
<a name="ln2465">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2466">    {</a>
<a name="ln2467">      dt_get_times(&amp;end_time);</a>
<a name="ln2468">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f lcms2) [%s]\n&quot;,</a>
<a name="ln2469">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2470">    }</a>
<a name="ln2471">  }</a>
<a name="ln2472">}</a>
<a name="ln2473"> </a>
<a name="ln2474">#ifdef HAVE_OPENCL</a>
<a name="ln2475">dt_colorspaces_cl_global_t *dt_colorspaces_init_cl_global()</a>
<a name="ln2476">{</a>
<a name="ln2477">  dt_colorspaces_cl_global_t *g = (dt_colorspaces_cl_global_t *)malloc(sizeof(dt_colorspaces_cl_global_t));</a>
<a name="ln2478"> </a>
<a name="ln2479">  const int program = 23; // colorspaces.cl, from programs.conf</a>
<a name="ln2480">  g-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix = dt_opencl_create_kernel(program, &quot;colorspaces_transform_lab_to_rgb_matrix&quot;);</a>
<a name="ln2481">  g-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab = dt_opencl_create_kernel(program, &quot;colorspaces_transform_rgb_matrix_to_lab&quot;);</a>
<a name="ln2482">  g-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb</a>
<a name="ln2483">      = dt_opencl_create_kernel(program, &quot;colorspaces_transform_rgb_matrix_to_rgb&quot;);</a>
<a name="ln2484">  return g;</a>
<a name="ln2485">}</a>
<a name="ln2486"> </a>
<a name="ln2487">void dt_colorspaces_free_cl_global(dt_colorspaces_cl_global_t *g)</a>
<a name="ln2488">{</a>
<a name="ln2489">  if(!g) return;</a>
<a name="ln2490"> </a>
<a name="ln2491">  // destroy kernels</a>
<a name="ln2492">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix);</a>
<a name="ln2493">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab);</a>
<a name="ln2494">  dt_opencl_free_kernel(g-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb);</a>
<a name="ln2495"> </a>
<a name="ln2496">  free(g);</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499">void dt_ioppr_get_profile_info_cl(const dt_iop_order_iccprofile_info_t *const profile_info, dt_colorspaces_iccprofile_info_cl_t *profile_info_cl)</a>
<a name="ln2500">{</a>
<a name="ln2501">  for(int i = 0; i &lt; 9; i++)</a>
<a name="ln2502">  {</a>
<a name="ln2503">    profile_info_cl-&gt;matrix_in[i] = profile_info-&gt;matrix_in[i];</a>
<a name="ln2504">    profile_info_cl-&gt;matrix_out[i] = profile_info-&gt;matrix_out[i];</a>
<a name="ln2505">  }</a>
<a name="ln2506">  profile_info_cl-&gt;lutsize = profile_info-&gt;lutsize;</a>
<a name="ln2507">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln2508">  {</a>
<a name="ln2509">    for(int j = 0; j &lt; 3; j++)</a>
<a name="ln2510">    {</a>
<a name="ln2511">      profile_info_cl-&gt;unbounded_coeffs_in[i][j] = profile_info-&gt;unbounded_coeffs_in[i][j];</a>
<a name="ln2512">      profile_info_cl-&gt;unbounded_coeffs_out[i][j] = profile_info-&gt;unbounded_coeffs_out[i][j];</a>
<a name="ln2513">    }</a>
<a name="ln2514">  }</a>
<a name="ln2515">  profile_info_cl-&gt;nonlinearlut = profile_info-&gt;nonlinearlut;</a>
<a name="ln2516">  profile_info_cl-&gt;grey = profile_info-&gt;grey;</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519">cl_float *dt_ioppr_get_trc_cl(const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2520">{</a>
<a name="ln2521">  cl_float *trc = malloc(profile_info-&gt;lutsize * 6 * sizeof(cl_float));</a>
<a name="ln2522">  if(trc)</a>
<a name="ln2523">  {</a>
<a name="ln2524">    int x = 0;</a>
<a name="ln2525">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2526">      for(int y = 0; y &lt; profile_info-&gt;lutsize; y++, x++)</a>
<a name="ln2527">        trc[x] = profile_info-&gt;lut_in[c][y];</a>
<a name="ln2528">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2529">      for(int y = 0; y &lt; profile_info-&gt;lutsize; y++, x++)</a>
<a name="ln2530">        trc[x] = profile_info-&gt;lut_out[c][y];</a>
<a name="ln2531">  }</a>
<a name="ln2532">  return trc;</a>
<a name="ln2533">}</a>
<a name="ln2534"> </a>
<a name="ln2535">cl_int dt_ioppr_build_iccprofile_params_cl(const dt_iop_order_iccprofile_info_t *const profile_info,</a>
<a name="ln2536">                                           const int devid, dt_colorspaces_iccprofile_info_cl_t **_profile_info_cl,</a>
<a name="ln2537">                                           cl_float **_profile_lut_cl, cl_mem *_dev_profile_info,</a>
<a name="ln2538">                                           cl_mem *_dev_profile_lut)</a>
<a name="ln2539">{</a>
<a name="ln2540">  cl_int err = CL_SUCCESS;</a>
<a name="ln2541"> </a>
<a name="ln2542">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl = calloc(1, sizeof(dt_colorspaces_iccprofile_info_cl_t));</a>
<a name="ln2543">  cl_float *profile_lut_cl = NULL;</a>
<a name="ln2544">  cl_mem dev_profile_info = NULL;</a>
<a name="ln2545">  cl_mem dev_profile_lut = NULL;</a>
<a name="ln2546"> </a>
<a name="ln2547">  if(profile_info)</a>
<a name="ln2548">  {</a>
<a name="ln2549">    dt_ioppr_get_profile_info_cl(profile_info, profile_info_cl);</a>
<a name="ln2550">    profile_lut_cl = dt_ioppr_get_trc_cl(profile_info);</a>
<a name="ln2551"> </a>
<a name="ln2552">    dev_profile_info = dt_opencl_copy_host_to_device_constant(devid, sizeof(*profile_info_cl), profile_info_cl);</a>
<a name="ln2553">    if(dev_profile_info == NULL)</a>
<a name="ln2554">    {</a>
<a name="ln2555">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 5\n&quot;);</a>
<a name="ln2556">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2557">      goto cleanup;</a>
<a name="ln2558">    }</a>
<a name="ln2559"> </a>
<a name="ln2560">    dev_profile_lut = dt_opencl_copy_host_to_device(devid, profile_lut_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2561">    if(dev_profile_lut == NULL)</a>
<a name="ln2562">    {</a>
<a name="ln2563">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 6\n&quot;);</a>
<a name="ln2564">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2565">      goto cleanup;</a>
<a name="ln2566">    }</a>
<a name="ln2567">  }</a>
<a name="ln2568">  else</a>
<a name="ln2569">  {</a>
<a name="ln2570">    profile_lut_cl = malloc(1 * 6 * sizeof(cl_float));</a>
<a name="ln2571"> </a>
<a name="ln2572">    dev_profile_lut = dt_opencl_copy_host_to_device(devid, profile_lut_cl, 1, 1 * 6, sizeof(float));</a>
<a name="ln2573">    if(dev_profile_lut == NULL)</a>
<a name="ln2574">    {</a>
<a name="ln2575">      fprintf(stderr, &quot;[dt_ioppr_build_iccprofile_params_cl] error allocating memory 6\n&quot;);</a>
<a name="ln2576">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2577">      goto cleanup;</a>
<a name="ln2578">    }</a>
<a name="ln2579">  }</a>
<a name="ln2580"> </a>
<a name="ln2581">cleanup:</a>
<a name="ln2582">  *_profile_info_cl = profile_info_cl;</a>
<a name="ln2583">  *_profile_lut_cl = profile_lut_cl;</a>
<a name="ln2584">  *_dev_profile_info = dev_profile_info;</a>
<a name="ln2585">  *_dev_profile_lut = dev_profile_lut;</a>
<a name="ln2586"> </a>
<a name="ln2587">  return err;</a>
<a name="ln2588">}</a>
<a name="ln2589"> </a>
<a name="ln2590">void dt_ioppr_free_iccprofile_params_cl(dt_colorspaces_iccprofile_info_cl_t **_profile_info_cl,</a>
<a name="ln2591">                                        cl_float **_profile_lut_cl, cl_mem *_dev_profile_info,</a>
<a name="ln2592">                                        cl_mem *_dev_profile_lut)</a>
<a name="ln2593">{</a>
<a name="ln2594">  dt_colorspaces_iccprofile_info_cl_t *profile_info_cl = *_profile_info_cl;</a>
<a name="ln2595">  cl_float *profile_lut_cl = *_profile_lut_cl;</a>
<a name="ln2596">  cl_mem dev_profile_info = *_dev_profile_info;</a>
<a name="ln2597">  cl_mem dev_profile_lut = *_dev_profile_lut;</a>
<a name="ln2598"> </a>
<a name="ln2599">  if(profile_info_cl) free(profile_info_cl);</a>
<a name="ln2600">  if(dev_profile_info) dt_opencl_release_mem_object(dev_profile_info);</a>
<a name="ln2601">  if(dev_profile_lut) dt_opencl_release_mem_object(dev_profile_lut);</a>
<a name="ln2602">  if(profile_lut_cl) free(profile_lut_cl);</a>
<a name="ln2603"> </a>
<a name="ln2604">  *_profile_info_cl = NULL;</a>
<a name="ln2605">  *_profile_lut_cl = NULL;</a>
<a name="ln2606">  *_dev_profile_info = NULL;</a>
<a name="ln2607">  *_dev_profile_lut = NULL;</a>
<a name="ln2608">}</a>
<a name="ln2609"> </a>
<a name="ln2610">int dt_ioppr_transform_image_colorspace_cl(struct dt_iop_module_t *self, const int devid, cl_mem dev_img_in,</a>
<a name="ln2611">                                           cl_mem dev_img_out, const int width, const int height,</a>
<a name="ln2612">                                           const int cst_from, const int cst_to, int *converted_cst,</a>
<a name="ln2613">                                           const dt_iop_order_iccprofile_info_t *const profile_info)</a>
<a name="ln2614">{</a>
<a name="ln2615">  cl_int err = CL_SUCCESS;</a>
<a name="ln2616">  </a>
<a name="ln2617">  if(cst_from == cst_to)</a>
<a name="ln2618">  {</a>
<a name="ln2619">    *converted_cst = cst_to;</a>
<a name="ln2620">    return TRUE;</a>
<a name="ln2621">  }</a>
<a name="ln2622">  if(profile_info == NULL)</a>
<a name="ln2623">  {</a>
<a name="ln2624">    fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] module %s must be between input color profile and output color profile\n&quot;, self-&gt;op);</a>
<a name="ln2625">    *converted_cst = cst_from;</a>
<a name="ln2626">    return FALSE;</a>
<a name="ln2627">  }</a>
<a name="ln2628">  if(profile_info-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2629">  {</a>
<a name="ln2630">    *converted_cst = cst_from;</a>
<a name="ln2631">    return FALSE;</a>
<a name="ln2632">  }</a>
<a name="ln2633">  </a>
<a name="ln2634">  const int ch = 4;</a>
<a name="ln2635">  float *src_buffer = NULL;</a>
<a name="ln2636">  int in_place = (dev_img_in == dev_img_out);</a>
<a name="ln2637"> </a>
<a name="ln2638">  int kernel_transform = 0;</a>
<a name="ln2639">  cl_mem dev_tmp = NULL;</a>
<a name="ln2640">  cl_mem dev_profile_info = NULL;</a>
<a name="ln2641">  cl_mem dev_lut = NULL;</a>
<a name="ln2642">  dt_colorspaces_iccprofile_info_cl_t profile_info_cl;</a>
<a name="ln2643">  cl_float *lut_cl = NULL;</a>
<a name="ln2644">  </a>
<a name="ln2645">  *converted_cst = cst_from;</a>
<a name="ln2646"> </a>
<a name="ln2647">  // if we have a matrix use opencl</a>
<a name="ln2648">  if(!isnan(profile_info-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info-&gt;matrix_out[0]))</a>
<a name="ln2649">  {</a>
<a name="ln2650">    dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2651">    if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2652">    </a>
<a name="ln2653">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2654">    size_t region[] = { width, height, 1 };</a>
<a name="ln2655">    </a>
<a name="ln2656">    if(cst_from == iop_cs_rgb &amp;&amp; cst_to == iop_cs_Lab)</a>
<a name="ln2657">    {</a>
<a name="ln2658">      kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_rgb_matrix_to_lab;</a>
<a name="ln2659">    }</a>
<a name="ln2660">    else if(cst_from == iop_cs_Lab &amp;&amp; cst_to == iop_cs_rgb)</a>
<a name="ln2661">    {</a>
<a name="ln2662">      kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_lab_to_rgb_matrix;</a>
<a name="ln2663">    }</a>
<a name="ln2664">    else</a>
<a name="ln2665">    {</a>
<a name="ln2666">      err = CL_INVALID_KERNEL;</a>
<a name="ln2667">      *converted_cst = cst_from;</a>
<a name="ln2668">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] invalid convertion from %i to %i\n&quot;, cst_from, cst_to);</a>
<a name="ln2669">      goto cleanup;</a>
<a name="ln2670">    }</a>
<a name="ln2671">    </a>
<a name="ln2672">    dt_ioppr_get_profile_info_cl(profile_info, &amp;profile_info_cl);</a>
<a name="ln2673">    lut_cl = dt_ioppr_get_trc_cl(profile_info);</a>
<a name="ln2674"> </a>
<a name="ln2675">    if(in_place)</a>
<a name="ln2676">    {</a>
<a name="ln2677">      dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2678">      if(dev_tmp == NULL)</a>
<a name="ln2679">      {</a>
<a name="ln2680">        fprintf(stderr,</a>
<a name="ln2681">                &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 4\n&quot;);</a>
<a name="ln2682">        err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2683">        goto cleanup;</a>
<a name="ln2684">      }</a>
<a name="ln2685"> </a>
<a name="ln2686">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_tmp, origin, origin, region);</a>
<a name="ln2687">      if(err != CL_SUCCESS)</a>
<a name="ln2688">      {</a>
<a name="ln2689">        fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln2690">        goto cleanup;</a>
<a name="ln2691">      }</a>
<a name="ln2692">    }</a>
<a name="ln2693">    else</a>
<a name="ln2694">    {</a>
<a name="ln2695">      dev_tmp = dev_img_in;</a>
<a name="ln2696">    }</a>
<a name="ln2697"> </a>
<a name="ln2698">    dev_profile_info = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_cl), &amp;profile_info_cl);</a>
<a name="ln2699">    if(dev_profile_info == NULL)</a>
<a name="ln2700">    {</a>
<a name="ln2701">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 5\n&quot;);</a>
<a name="ln2702">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2703">      goto cleanup;</a>
<a name="ln2704">    }</a>
<a name="ln2705">    dev_lut = dt_opencl_copy_host_to_device(devid, lut_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2706">    if(dev_lut == NULL)</a>
<a name="ln2707">    {</a>
<a name="ln2708">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 6\n&quot;);</a>
<a name="ln2709">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2710">      goto cleanup;</a>
<a name="ln2711">    }</a>
<a name="ln2712">    </a>
<a name="ln2713">    size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln2714">    </a>
<a name="ln2715">    dt_opencl_set_kernel_arg(devid, kernel_transform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2716">    dt_opencl_set_kernel_arg(devid, kernel_transform, 1, sizeof(cl_mem), (void *)&amp;dev_img_out);</a>
<a name="ln2717">    dt_opencl_set_kernel_arg(devid, kernel_transform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2718">    dt_opencl_set_kernel_arg(devid, kernel_transform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2719">    dt_opencl_set_kernel_arg(devid, kernel_transform, 4, sizeof(cl_mem), (void *)&amp;dev_profile_info);</a>
<a name="ln2720">    dt_opencl_set_kernel_arg(devid, kernel_transform, 5, sizeof(cl_mem), (void *)&amp;dev_lut);</a>
<a name="ln2721">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_transform, sizes);</a>
<a name="ln2722">    if(err != CL_SUCCESS)</a>
<a name="ln2723">    {</a>
<a name="ln2724">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error %i enqueue kernel for color transformation\n&quot;, err);</a>
<a name="ln2725">      goto cleanup;</a>
<a name="ln2726">    }</a>
<a name="ln2727"> </a>
<a name="ln2728">    *converted_cst = cst_to;</a>
<a name="ln2729"> </a>
<a name="ln2730">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2731">    {</a>
<a name="ln2732">      dt_get_times(&amp;end_time);</a>
<a name="ln2733">      fprintf(stderr, &quot;image colorspace transform %s--&gt;%s took %.3f secs (%.3f GPU) [%s %s]\n&quot;, </a>
<a name="ln2734">          (cst_from == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, (cst_to == iop_cs_rgb) ? &quot;RGB&quot;: &quot;Lab&quot;, </a>
<a name="ln2735">          end_time.clock - start_time.clock, end_time.user - start_time.user, self-&gt;op, self-&gt;multi_name);</a>
<a name="ln2736">    }</a>
<a name="ln2737">  }</a>
<a name="ln2738">  else</a>
<a name="ln2739">  {</a>
<a name="ln2740">    // no matrix, call lcms2</a>
<a name="ln2741">    src_buffer = dt_alloc_align(64, width * height * ch * sizeof(float));</a>
<a name="ln2742">    if(src_buffer == NULL)</a>
<a name="ln2743">    {</a>
<a name="ln2744">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 1\n&quot;);</a>
<a name="ln2745">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2746">      goto cleanup;</a>
<a name="ln2747">    }</a>
<a name="ln2748"> </a>
<a name="ln2749">    err = dt_opencl_copy_device_to_host(devid, src_buffer, dev_img_in, width, height, ch * sizeof(float));</a>
<a name="ln2750">    if(err != CL_SUCCESS)</a>
<a name="ln2751">    {</a>
<a name="ln2752">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 2\n&quot;);</a>
<a name="ln2753">      goto cleanup;</a>
<a name="ln2754">    }</a>
<a name="ln2755">  </a>
<a name="ln2756">    // just call the CPU version for now</a>
<a name="ln2757">    dt_ioppr_transform_image_colorspace(self, src_buffer, src_buffer, width, height, cst_from, cst_to,</a>
<a name="ln2758">                                        converted_cst, profile_info);</a>
<a name="ln2759"> </a>
<a name="ln2760">    err = dt_opencl_write_host_to_device(devid, src_buffer, dev_img_out, width, height, ch * sizeof(float));</a>
<a name="ln2761">    if(err != CL_SUCCESS)</a>
<a name="ln2762">    {</a>
<a name="ln2763">      fprintf(stderr, &quot;[dt_ioppr_transform_image_colorspace_cl] error allocating memory for color transformation 3\n&quot;);</a>
<a name="ln2764">      goto cleanup;</a>
<a name="ln2765">    }</a>
<a name="ln2766">  }</a>
<a name="ln2767">  </a>
<a name="ln2768">cleanup:</a>
<a name="ln2769">  if(src_buffer) dt_free_align(src_buffer);</a>
<a name="ln2770">  if(dev_tmp &amp;&amp; in_place) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2771">  if(dev_profile_info) dt_opencl_release_mem_object(dev_profile_info);</a>
<a name="ln2772">  if(dev_lut) dt_opencl_release_mem_object(dev_lut);</a>
<a name="ln2773">  if(lut_cl) free(lut_cl);</a>
<a name="ln2774"> </a>
<a name="ln2775">  return (err == CL_SUCCESS) ? TRUE : FALSE;</a>
<a name="ln2776">}</a>
<a name="ln2777"> </a>
<a name="ln2778">int dt_ioppr_transform_image_colorspace_rgb_cl(const int devid, cl_mem dev_img_in, cl_mem dev_img_out,</a>
<a name="ln2779">                                               const int width, const int height,</a>
<a name="ln2780">                                               const dt_iop_order_iccprofile_info_t *const profile_info_from,</a>
<a name="ln2781">                                               const dt_iop_order_iccprofile_info_t *const profile_info_to,</a>
<a name="ln2782">                                               const char *message)</a>
<a name="ln2783">{</a>
<a name="ln2784">  cl_int err = CL_SUCCESS;</a>
<a name="ln2785"> </a>
<a name="ln2786">  if(profile_info_from-&gt;type == DT_COLORSPACE_NONE || profile_info_to-&gt;type == DT_COLORSPACE_NONE)</a>
<a name="ln2787">  {</a>
<a name="ln2788">    return FALSE;</a>
<a name="ln2789">  }</a>
<a name="ln2790">  if(profile_info_from-&gt;type == profile_info_to-&gt;type</a>
<a name="ln2791">     &amp;&amp; strcmp(profile_info_from-&gt;filename, profile_info_to-&gt;filename) == 0)</a>
<a name="ln2792">  {</a>
<a name="ln2793">    if(dev_img_in != dev_img_out)</a>
<a name="ln2794">    {</a>
<a name="ln2795">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2796">      size_t region[] = { width, height, 1 };</a>
<a name="ln2797">      </a>
<a name="ln2798">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_img_out, origin, origin, region);</a>
<a name="ln2799">      if(err != CL_SUCCESS)</a>
<a name="ln2800">      {</a>
<a name="ln2801">        fprintf(stderr,</a>
<a name="ln2802">                &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln2803">        return FALSE;</a>
<a name="ln2804">      }</a>
<a name="ln2805">    }</a>
<a name="ln2806">    </a>
<a name="ln2807">    return TRUE;</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  const int ch = 4;</a>
<a name="ln2811">  float *src_buffer = NULL;</a>
<a name="ln2812">  int in_place = (dev_img_in == dev_img_out);</a>
<a name="ln2813"> </a>
<a name="ln2814">  int kernel_transform = 0;</a>
<a name="ln2815">  cl_mem dev_tmp = NULL;</a>
<a name="ln2816"> </a>
<a name="ln2817">  cl_mem dev_profile_info_from = NULL;</a>
<a name="ln2818">  cl_mem dev_lut_from = NULL;</a>
<a name="ln2819">  dt_colorspaces_iccprofile_info_cl_t profile_info_from_cl;</a>
<a name="ln2820">  cl_float *lut_from_cl = NULL;</a>
<a name="ln2821"> </a>
<a name="ln2822">  cl_mem dev_profile_info_to = NULL;</a>
<a name="ln2823">  cl_mem dev_lut_to = NULL;</a>
<a name="ln2824">  dt_colorspaces_iccprofile_info_cl_t profile_info_to_cl;</a>
<a name="ln2825">  cl_float *lut_to_cl = NULL;</a>
<a name="ln2826"> </a>
<a name="ln2827">  // if we have a matrix use opencl</a>
<a name="ln2828">  if(!isnan(profile_info_from-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_from-&gt;matrix_out[0])</a>
<a name="ln2829">     &amp;&amp; !isnan(profile_info_to-&gt;matrix_in[0]) &amp;&amp; !isnan(profile_info_to-&gt;matrix_out[0]))</a>
<a name="ln2830">  {</a>
<a name="ln2831">    dt_times_t start_time = { 0 }, end_time = { 0 };</a>
<a name="ln2832">    if(darktable.unmuted &amp; DT_DEBUG_PERF) dt_get_times(&amp;start_time);</a>
<a name="ln2833"> </a>
<a name="ln2834">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2835">    size_t region[] = { width, height, 1 };</a>
<a name="ln2836"> </a>
<a name="ln2837">    kernel_transform = darktable.opencl-&gt;colorspaces-&gt;kernel_colorspaces_transform_rgb_matrix_to_rgb;</a>
<a name="ln2838"> </a>
<a name="ln2839">    dt_ioppr_get_profile_info_cl(profile_info_from, &amp;profile_info_from_cl);</a>
<a name="ln2840">    lut_from_cl = dt_ioppr_get_trc_cl(profile_info_from);</a>
<a name="ln2841"> </a>
<a name="ln2842">    dt_ioppr_get_profile_info_cl(profile_info_to, &amp;profile_info_to_cl);</a>
<a name="ln2843">    lut_to_cl = dt_ioppr_get_trc_cl(profile_info_to);</a>
<a name="ln2844"> </a>
<a name="ln2845">    if(in_place)</a>
<a name="ln2846">    {</a>
<a name="ln2847">      dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2848">      if(dev_tmp == NULL)</a>
<a name="ln2849">      {</a>
<a name="ln2850">        fprintf(</a>
<a name="ln2851">            stderr,</a>
<a name="ln2852">            &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 4\n&quot;);</a>
<a name="ln2853">        err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2854">        goto cleanup;</a>
<a name="ln2855">      }</a>
<a name="ln2856"> </a>
<a name="ln2857">      err = dt_opencl_enqueue_copy_image(devid, dev_img_in, dev_tmp, origin, origin, region);</a>
<a name="ln2858">      if(err != CL_SUCCESS)</a>
<a name="ln2859">      {</a>
<a name="ln2860">        fprintf(stderr,</a>
<a name="ln2861">                &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error on copy image for color transformation\n&quot;);</a>
<a name="ln2862">        goto cleanup;</a>
<a name="ln2863">      }</a>
<a name="ln2864">    }</a>
<a name="ln2865">    else</a>
<a name="ln2866">    {</a>
<a name="ln2867">      dev_tmp = dev_img_in;</a>
<a name="ln2868">    }</a>
<a name="ln2869"> </a>
<a name="ln2870">    dev_profile_info_from</a>
<a name="ln2871">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_from_cl), &amp;profile_info_from_cl);</a>
<a name="ln2872">    if(dev_profile_info_from == NULL)</a>
<a name="ln2873">    {</a>
<a name="ln2874">      fprintf(stderr,</a>
<a name="ln2875">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 5\n&quot;);</a>
<a name="ln2876">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2877">      goto cleanup;</a>
<a name="ln2878">    }</a>
<a name="ln2879">    dev_lut_from = dt_opencl_copy_host_to_device(devid, lut_from_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2880">    if(dev_lut_from == NULL)</a>
<a name="ln2881">    {</a>
<a name="ln2882">      fprintf(stderr,</a>
<a name="ln2883">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 6\n&quot;);</a>
<a name="ln2884">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2885">      goto cleanup;</a>
<a name="ln2886">    }</a>
<a name="ln2887"> </a>
<a name="ln2888">    dev_profile_info_to</a>
<a name="ln2889">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(profile_info_to_cl), &amp;profile_info_to_cl);</a>
<a name="ln2890">    if(dev_profile_info_to == NULL)</a>
<a name="ln2891">    {</a>
<a name="ln2892">      fprintf(stderr,</a>
<a name="ln2893">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 7\n&quot;);</a>
<a name="ln2894">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2895">      goto cleanup;</a>
<a name="ln2896">    }</a>
<a name="ln2897">    dev_lut_to = dt_opencl_copy_host_to_device(devid, lut_to_cl, 256, 256 * 6, sizeof(float));</a>
<a name="ln2898">    if(dev_lut_to == NULL)</a>
<a name="ln2899">    {</a>
<a name="ln2900">      fprintf(stderr,</a>
<a name="ln2901">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 8\n&quot;);</a>
<a name="ln2902">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2903">      goto cleanup;</a>
<a name="ln2904">    }</a>
<a name="ln2905"> </a>
<a name="ln2906">    size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln2907"> </a>
<a name="ln2908">    dt_opencl_set_kernel_arg(devid, kernel_transform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2909">    dt_opencl_set_kernel_arg(devid, kernel_transform, 1, sizeof(cl_mem), (void *)&amp;dev_img_out);</a>
<a name="ln2910">    dt_opencl_set_kernel_arg(devid, kernel_transform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2911">    dt_opencl_set_kernel_arg(devid, kernel_transform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2912">    dt_opencl_set_kernel_arg(devid, kernel_transform, 4, sizeof(cl_mem), (void *)&amp;dev_profile_info_from);</a>
<a name="ln2913">    dt_opencl_set_kernel_arg(devid, kernel_transform, 5, sizeof(cl_mem), (void *)&amp;dev_lut_from);</a>
<a name="ln2914">    dt_opencl_set_kernel_arg(devid, kernel_transform, 6, sizeof(cl_mem), (void *)&amp;dev_profile_info_to);</a>
<a name="ln2915">    dt_opencl_set_kernel_arg(devid, kernel_transform, 7, sizeof(cl_mem), (void *)&amp;dev_lut_to);</a>
<a name="ln2916">    err = dt_opencl_enqueue_kernel_2d(devid, kernel_transform, sizes);</a>
<a name="ln2917">    if(err != CL_SUCCESS)</a>
<a name="ln2918">    {</a>
<a name="ln2919">      fprintf(stderr,</a>
<a name="ln2920">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error %i enqueue kernel for color transformation\n&quot;,</a>
<a name="ln2921">              err);</a>
<a name="ln2922">      goto cleanup;</a>
<a name="ln2923">    }</a>
<a name="ln2924"> </a>
<a name="ln2925">    if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln2926">    {</a>
<a name="ln2927">      dt_get_times(&amp;end_time);</a>
<a name="ln2928">      fprintf(stderr, &quot;image colorspace transform RGB--&gt;RGB took %.3f secs (%.3f GPU) [%s]\n&quot;,</a>
<a name="ln2929">              end_time.clock - start_time.clock, end_time.user - start_time.user, (message) ? message : &quot;&quot;);</a>
<a name="ln2930">    }</a>
<a name="ln2931">  }</a>
<a name="ln2932">  else</a>
<a name="ln2933">  {</a>
<a name="ln2934">    // no matrix, call lcms2</a>
<a name="ln2935">    src_buffer = dt_alloc_align(64, width * height * ch * sizeof(float));</a>
<a name="ln2936">    if(src_buffer == NULL)</a>
<a name="ln2937">    {</a>
<a name="ln2938">      fprintf(stderr,</a>
<a name="ln2939">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 1\n&quot;);</a>
<a name="ln2940">      err = CL_MEM_OBJECT_ALLOCATION_FAILURE;</a>
<a name="ln2941">      goto cleanup;</a>
<a name="ln2942">    }</a>
<a name="ln2943"> </a>
<a name="ln2944">    err = dt_opencl_copy_device_to_host(devid, src_buffer, dev_img_in, width, height, ch * sizeof(float));</a>
<a name="ln2945">    if(err != CL_SUCCESS)</a>
<a name="ln2946">    {</a>
<a name="ln2947">      fprintf(stderr,</a>
<a name="ln2948">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 2\n&quot;);</a>
<a name="ln2949">      goto cleanup;</a>
<a name="ln2950">    }</a>
<a name="ln2951"> </a>
<a name="ln2952">    // just call the CPU version for now</a>
<a name="ln2953">    dt_ioppr_transform_image_colorspace_rgb(src_buffer, src_buffer, width, height, profile_info_from,</a>
<a name="ln2954">                                            profile_info_to, message);</a>
<a name="ln2955"> </a>
<a name="ln2956">    err = dt_opencl_write_host_to_device(devid, src_buffer, dev_img_out, width, height, ch * sizeof(float));</a>
<a name="ln2957">    if(err != CL_SUCCESS)</a>
<a name="ln2958">    {</a>
<a name="ln2959">      fprintf(stderr,</a>
<a name="ln2960">              &quot;[dt_ioppr_transform_image_colorspace_rgb_cl] error allocating memory for color transformation 3\n&quot;);</a>
<a name="ln2961">      goto cleanup;</a>
<a name="ln2962">    }</a>
<a name="ln2963">  }</a>
<a name="ln2964"> </a>
<a name="ln2965">cleanup:</a>
<a name="ln2966">  if(src_buffer) dt_free_align(src_buffer);</a>
<a name="ln2967">  if(dev_tmp &amp;&amp; in_place) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2968"> </a>
<a name="ln2969">  if(dev_profile_info_from) dt_opencl_release_mem_object(dev_profile_info_from);</a>
<a name="ln2970">  if(dev_lut_from) dt_opencl_release_mem_object(dev_lut_from);</a>
<a name="ln2971">  if(lut_from_cl) free(lut_from_cl);</a>
<a name="ln2972"> </a>
<a name="ln2973">  if(dev_profile_info_to) dt_opencl_release_mem_object(dev_profile_info_to);</a>
<a name="ln2974">  if(dev_lut_to) dt_opencl_release_mem_object(dev_lut_to);</a>
<a name="ln2975">  if(lut_to_cl) free(lut_to_cl);</a>
<a name="ln2976"> </a>
<a name="ln2977">  return (err == CL_SUCCESS) ? TRUE : FALSE;</a>
<a name="ln2978">}</a>
<a name="ln2979">#endif</a>

</code></pre>
<div class="balloon" rel="96"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'rule'. Check lines: 96, 94.</p></div>
<div class="balloon" rel="191"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'order_entry'. Check lines: 191, 189.</p></div>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'iop_order_new'. Check lines: 247, 246.</p></div>
<div class="balloon" rel="685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 685, 684.</p></div>
<div class="balloon" rel="1649"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="1702"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'width * height' operator to the 'size_t' type, not the result.</p></div>
<div class="balloon" rel="1798"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'profile_info->lut_in[i]'. Check lines: 1798, 1797.</p></div>
<div class="balloon" rel="1800"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'profile_info->lut_out[i]'. Check lines: 1800, 1799.</p></div>
<div class="balloon" rel="1785"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'profile_info' might take place. The potential null pointer is passed into 'dt_ioppr_init_profile_info' function. Inspect the first argument. Check lines: 1785, 1938, 1937.</p></div>
<div class="balloon" rel="2480"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 2480, 2477.</p></div>
<div class="balloon" rel="2503"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'profile_info_cl' might take place. The potential null pointer is passed into 'dt_ioppr_get_profile_info_cl' function. Inspect the second argument. Check lines: 2503, 2549, 2542.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
