
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011-2014 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/exif.h&quot;</a>
<a name="ln23">#include &quot;common/file_location.h&quot;</a>
<a name="ln24">#include &quot;common/grealpath.h&quot;</a>
<a name="ln25">#include &quot;common/image_cache.h&quot;</a>
<a name="ln26">#include &quot;common/imageio.h&quot;</a>
<a name="ln27">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln28">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln29">#include &quot;control/conf.h&quot;</a>
<a name="ln30">#include &quot;control/jobs.h&quot;</a>
<a name="ln31">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;assert.h&gt;</a>
<a name="ln34">#include &lt;errno.h&gt;</a>
<a name="ln35">#include &lt;fcntl.h&gt;</a>
<a name="ln36">#include &lt;glib.h&gt;</a>
<a name="ln37">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln38">#include &lt;limits.h&gt;</a>
<a name="ln39">#include &lt;stdio.h&gt;</a>
<a name="ln40">#include &lt;stdlib.h&gt;</a>
<a name="ln41">#include &lt;string.h&gt;</a>
<a name="ln42">#include &lt;strings.h&gt;</a>
<a name="ln43">#include &lt;unistd.h&gt;</a>
<a name="ln44">#if defined(__SSE__)</a>
<a name="ln45">#include &lt;xmmintrin.h&gt;</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48">#if !defined(_WIN32)</a>
<a name="ln49">#include &lt;sys/statvfs.h&gt;</a>
<a name="ln50">#else</a>
<a name="ln51">//statvfs does not exist in Windows, providing implementation</a>
<a name="ln52">#include &quot;win/statvfs.h&quot;</a>
<a name="ln53">#endif</a>
<a name="ln54"> </a>
<a name="ln55">#define DT_MIPMAP_CACHE_FILE_MAGIC 0xD71337</a>
<a name="ln56">#define DT_MIPMAP_CACHE_FILE_VERSION 23</a>
<a name="ln57">#define DT_MIPMAP_CACHE_DEFAULT_FILE_NAME &quot;mipmaps&quot;</a>
<a name="ln58"> </a>
<a name="ln59">typedef enum dt_mipmap_buffer_dsc_flags</a>
<a name="ln60">{</a>
<a name="ln61">  DT_MIPMAP_BUFFER_DSC_FLAG_NONE = 0,</a>
<a name="ln62">  DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE = 1 &lt;&lt; 0,</a>
<a name="ln63">  DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE = 1 &lt;&lt; 1</a>
<a name="ln64">} dt_mipmap_buffer_dsc_flags;</a>
<a name="ln65"> </a>
<a name="ln66">// the embedded Exif data to tag thumbnails as sRGB or AdobeRGB</a>
<a name="ln67">static const uint8_t dt_mipmap_cache_exif_data_srgb[] = {</a>
<a name="ln68">  0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69,</a>
<a name="ln69">  0x87, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,</a>
<a name="ln70">  0x01, 0xa0, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</a>
<a name="ln71">};</a>
<a name="ln72">static const uint8_t dt_mipmap_cache_exif_data_adobergb[] = {</a>
<a name="ln73">  0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69,</a>
<a name="ln74">  0x87, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,</a>
<a name="ln75">  0x01, 0xa0, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</a>
<a name="ln76">};</a>
<a name="ln77">static const int dt_mipmap_cache_exif_data_srgb_length</a>
<a name="ln78">                      = sizeof(dt_mipmap_cache_exif_data_srgb) / sizeof(*dt_mipmap_cache_exif_data_srgb);</a>
<a name="ln79">static const int dt_mipmap_cache_exif_data_adobergb_length</a>
<a name="ln80">                      = sizeof(dt_mipmap_cache_exif_data_adobergb) / sizeof(*dt_mipmap_cache_exif_data_adobergb);</a>
<a name="ln81"> </a>
<a name="ln82">struct dt_mipmap_buffer_dsc</a>
<a name="ln83">{</a>
<a name="ln84">  uint32_t width;</a>
<a name="ln85">  uint32_t height;</a>
<a name="ln86">  float iscale;</a>
<a name="ln87">  size_t size;</a>
<a name="ln88">  dt_mipmap_buffer_dsc_flags flags;</a>
<a name="ln89">  dt_colorspaces_color_profile_type_t color_space;</a>
<a name="ln90"> </a>
<a name="ln91">#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</a>
<a name="ln92">  // do not touch!</a>
<a name="ln93">  // must be the last element.</a>
<a name="ln94">  // must be no less than 16bytes</a>
<a name="ln95">  char redzone[16];</a>
<a name="ln96">#endif</a>
<a name="ln97"> </a>
<a name="ln98">  /* NB: sizeof must be a multiple of 4*sizeof(float) */</a>
<a name="ln99">} __attribute__((packed, aligned(64)));</a>
<a name="ln100"> </a>
<a name="ln101">#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</a>
<a name="ln102">static const size_t dt_mipmap_buffer_dsc_size __attribute__((unused))</a>
<a name="ln103">= sizeof(struct dt_mipmap_buffer_dsc) - sizeof(((struct dt_mipmap_buffer_dsc *)0)-&gt;redzone);</a>
<a name="ln104">#else</a>
<a name="ln105">static const size_t dt_mipmap_buffer_dsc_size __attribute__((unused)) = sizeof(struct dt_mipmap_buffer_dsc);</a>
<a name="ln106">#endif</a>
<a name="ln107"> </a>
<a name="ln108">// last resort mem alloc for dead images. sizeof(dt_mipmap_buffer_dsc) + dead image pixels (8x8)</a>
<a name="ln109">// Must be alignment to 4 * sizeof(float).</a>
<a name="ln110">static float dt_mipmap_cache_static_dead_image[sizeof(struct dt_mipmap_buffer_dsc) / sizeof(float) + 64 * 4]</a>
<a name="ln111">    __attribute__((aligned(64)));</a>
<a name="ln112"> </a>
<a name="ln113">static inline void dead_image_8(dt_mipmap_buffer_t *buf)</a>
<a name="ln114">{</a>
<a name="ln115">  if(!buf-&gt;buf) return;</a>
<a name="ln116">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln117">  dsc-&gt;width = dsc-&gt;height = 8;</a>
<a name="ln118">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln119">  dsc-&gt;color_space = DT_COLORSPACE_DISPLAY;</a>
<a name="ln120">  assert(dsc-&gt;size &gt; 64 * sizeof(uint32_t));</a>
<a name="ln121">  const uint32_t X = 0xffffffffu;</a>
<a name="ln122">  const uint32_t o = 0u;</a>
<a name="ln123">  const uint32_t image[]</a>
<a name="ln124">      = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,</a>
<a name="ln125">          o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln126">  memcpy(buf-&gt;buf, image, sizeof(uint32_t) * 64);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">static inline void dead_image_f(dt_mipmap_buffer_t *buf)</a>
<a name="ln130">{</a>
<a name="ln131">  if(!buf-&gt;buf) return;</a>
<a name="ln132">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln133">  dsc-&gt;width = dsc-&gt;height = 8;</a>
<a name="ln134">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln135">  dsc-&gt;color_space = DT_COLORSPACE_DISPLAY;</a>
<a name="ln136">  assert(dsc-&gt;size &gt; 64 * 4 * sizeof(float));</a>
<a name="ln137"> </a>
<a name="ln138">  if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln139">  {</a>
<a name="ln140">    const float X = 1.0f;</a>
<a name="ln141">    const float o = 0.0f;</a>
<a name="ln142"> </a>
<a name="ln143">    const float image[64 * 4]</a>
<a name="ln144">        = { o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o,</a>
<a name="ln145">            o, o, o, o, o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln146">            o, o, o, o, X, X, X, X, o, o, o, o, X, X, X, X, X, X, X, X, o, o, o, o, X, X, X, X, o, o, o, o,</a>
<a name="ln147">            o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o,</a>
<a name="ln148">            o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln149">            o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o,</a>
<a name="ln150">            o, o, o, o, o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln151">            o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln152"> </a>
<a name="ln153">    memcpy(buf-&gt;buf, image, sizeof(float) * 4 * 64);</a>
<a name="ln154">  }</a>
<a name="ln155">#if defined(__SSE__)</a>
<a name="ln156">  else if(darktable.codepath.SSE2)</a>
<a name="ln157">  {</a>
<a name="ln158">    const __m128 X = _mm_set1_ps(1.0f);</a>
<a name="ln159">    const __m128 o = _mm_set1_ps(0.0f);</a>
<a name="ln160">    const __m128 image[]</a>
<a name="ln161">        = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,</a>
<a name="ln162">            o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln163"> </a>
<a name="ln164">    memcpy(buf-&gt;buf, image, sizeof(__m128) * 64);</a>
<a name="ln165">  }</a>
<a name="ln166">#endif</a>
<a name="ln167">  else</a>
<a name="ln168">    dt_unreachable_codepath();</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">#ifndef NDEBUG</a>
<a name="ln172">static inline int32_t buffer_is_broken(dt_mipmap_buffer_t *buf)</a>
<a name="ln173">{</a>
<a name="ln174">  if(!buf-&gt;buf) return 0;</a>
<a name="ln175">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln176">  if(buf-&gt;width != dsc-&gt;width) return 1;</a>
<a name="ln177">  if(buf-&gt;height != dsc-&gt;height) return 2;</a>
<a name="ln178">  // somewhat loose bound:</a>
<a name="ln179">  if(buf-&gt;width * buf-&gt;height &gt; dsc-&gt;size) return 3;</a>
<a name="ln180">  return 0;</a>
<a name="ln181">}</a>
<a name="ln182">#endif</a>
<a name="ln183"> </a>
<a name="ln184">static inline uint32_t get_key(const uint32_t imgid, const dt_mipmap_size_t size)</a>
<a name="ln185">{</a>
<a name="ln186">  // imgid can't be &gt;= 2^28 (~250 million images)</a>
<a name="ln187">  return (((uint32_t)size) &lt;&lt; 28) | (imgid - 1);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static inline uint32_t get_imgid(const uint32_t key)</a>
<a name="ln191">{</a>
<a name="ln192">  return (key &amp; 0xfffffff) + 1;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">static inline dt_mipmap_size_t get_size(const uint32_t key)</a>
<a name="ln196">{</a>
<a name="ln197">  return (dt_mipmap_size_t)(key &gt;&gt; 28);</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">static int dt_mipmap_cache_get_filename(gchar *mipmapfilename, size_t size)</a>
<a name="ln201">{</a>
<a name="ln202">  int r = -1;</a>
<a name="ln203">  char *abspath = NULL;</a>
<a name="ln204"> </a>
<a name="ln205">  // Directory</a>
<a name="ln206">  char cachedir[PATH_MAX] = { 0 };</a>
<a name="ln207">  dt_loc_get_user_cache_dir(cachedir, sizeof(cachedir));</a>
<a name="ln208"> </a>
<a name="ln209">  // Build the mipmap filename</a>
<a name="ln210">  const gchar *dbfilename = dt_database_get_path(darktable.db);</a>
<a name="ln211">  if(!strcmp(dbfilename, &quot;:memory:&quot;))</a>
<a name="ln212">  {</a>
<a name="ln213">    mipmapfilename[0] = '\0';</a>
<a name="ln214">    r = 0;</a>
<a name="ln215">    goto exit;</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218">  abspath = g_realpath(dbfilename);</a>
<a name="ln219">  if(!abspath) abspath = g_strdup(dbfilename);</a>
<a name="ln220"> </a>
<a name="ln221">  GChecksum *chk = g_checksum_new(G_CHECKSUM_SHA1);</a>
<a name="ln222">  g_checksum_update(chk, (guchar *)abspath, strlen(abspath));</a>
<a name="ln223">  const gchar *filename = g_checksum_get_string(chk);</a>
<a name="ln224"> </a>
<a name="ln225">  if(!filename || filename[0] == '\0')</a>
<a name="ln226">    snprintf(mipmapfilename, size, &quot;%s/%s&quot;, cachedir, DT_MIPMAP_CACHE_DEFAULT_FILE_NAME);</a>
<a name="ln227">  else</a>
<a name="ln228">    snprintf(mipmapfilename, size, &quot;%s/%s-%s&quot;, cachedir, DT_MIPMAP_CACHE_DEFAULT_FILE_NAME, filename);</a>
<a name="ln229"> </a>
<a name="ln230">  g_checksum_free(chk);</a>
<a name="ln231">  r = 0;</a>
<a name="ln232"> </a>
<a name="ln233">exit:</a>
<a name="ln234">  g_free(abspath);</a>
<a name="ln235"> </a>
<a name="ln236">  return r;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">static void _init_f(dt_mipmap_buffer_t *mipmap_buf, float *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln240">                    const uint32_t imgid);</a>
<a name="ln241">static void _init_8(uint8_t *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln242">                    dt_colorspaces_color_profile_type_t *color_space, const uint32_t imgid,</a>
<a name="ln243">                    const dt_mipmap_size_t size);</a>
<a name="ln244"> </a>
<a name="ln245">// callback for the imageio core to allocate memory.</a>
<a name="ln246">// only needed for _F and _FULL buffers, as they change size</a>
<a name="ln247">// with the input image. will allocate img-&gt;width*img-&gt;height*img-&gt;bpp bytes.</a>
<a name="ln248">void *dt_mipmap_cache_alloc(dt_mipmap_buffer_t *buf, const dt_image_t *img)</a>
<a name="ln249">{</a>
<a name="ln250">  assert(buf-&gt;size == DT_MIPMAP_FULL);</a>
<a name="ln251"> </a>
<a name="ln252">  dt_cache_entry_t *entry = buf-&gt;cache_entry;</a>
<a name="ln253">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln254"> </a>
<a name="ln255">  const int wd = img-&gt;width;</a>
<a name="ln256">  const int ht = img-&gt;height;</a>
<a name="ln257"> </a>
<a name="ln258">  const size_t bpp = dt_iop_buffer_dsc_to_bpp(&amp;img-&gt;buf_dsc);</a>
<a name="ln259">  const size_t buffer_size = (size_t)wd * ht * bpp + sizeof(*dsc);</a>
<a name="ln260"> </a>
<a name="ln261">  // buf might have been alloc'ed before,</a>
<a name="ln262">  // so only check size and re-alloc if necessary:</a>
<a name="ln263">  if(!buf-&gt;buf || ((void *)dsc == (void *)dt_mipmap_cache_static_dead_image) || (entry-&gt;data_size &lt; buffer_size))</a>
<a name="ln264">  {</a>
<a name="ln265">    if((void *)dsc != (void *)dt_mipmap_cache_static_dead_image) dt_free_align(entry-&gt;data);</a>
<a name="ln266"> </a>
<a name="ln267">    entry-&gt;data_size = 0;</a>
<a name="ln268"> </a>
<a name="ln269">    entry-&gt;data = dt_alloc_align(64, buffer_size);</a>
<a name="ln270"> </a>
<a name="ln271">    if(!entry-&gt;data)</a>
<a name="ln272">    {</a>
<a name="ln273">      // return fallback: at least alloc size for a dead image:</a>
<a name="ln274">      entry-&gt;data = (void *)dt_mipmap_cache_static_dead_image;</a>
<a name="ln275"> </a>
<a name="ln276">      // allocator holds the pointer. but let imageio client know that allocation failed:</a>
<a name="ln277">      return NULL;</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">    entry-&gt;data_size = buffer_size;</a>
<a name="ln281"> </a>
<a name="ln282">    // set buffer size only if we're making it larger.</a>
<a name="ln283">    dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286">  dsc-&gt;size = buffer_size;</a>
<a name="ln287"> </a>
<a name="ln288">  dsc-&gt;width = wd;</a>
<a name="ln289">  dsc-&gt;height = ht;</a>
<a name="ln290">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln291">  dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln292">  dsc-&gt;flags = DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln293">  buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln294"> </a>
<a name="ln295">  // fprintf(stderr, &quot;full buffer allocating img %u %d x %d = %u bytes (%p)\n&quot;, img-&gt;id, img-&gt;width,</a>
<a name="ln296">  // img-&gt;height, buffer_size, *buf);</a>
<a name="ln297"> </a>
<a name="ln298">  assert(entry-&gt;data_size);</a>
<a name="ln299">  assert(dsc-&gt;size);</a>
<a name="ln300">  assert(dsc-&gt;size &lt;= entry-&gt;data_size);</a>
<a name="ln301"> </a>
<a name="ln302">  ASAN_POISON_MEMORY_REGION(entry-&gt;data, entry-&gt;data_size);</a>
<a name="ln303">  ASAN_UNPOISON_MEMORY_REGION(dsc + 1, buffer_size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln304"> </a>
<a name="ln305">  // return pointer to start of payload</a>
<a name="ln306">  return dsc + 1;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">// callback for the cache backend to initialize payload pointers</a>
<a name="ln310">void dt_mipmap_cache_allocate_dynamic(void *data, dt_cache_entry_t *entry)</a>
<a name="ln311">{</a>
<a name="ln312">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln313">  // for full image buffers</a>
<a name="ln314">  struct dt_mipmap_buffer_dsc *dsc = entry-&gt;data;</a>
<a name="ln315">  const dt_mipmap_size_t mip = get_size(entry-&gt;key);</a>
<a name="ln316"> </a>
<a name="ln317">  // alloc mere minimum for the header + broken image buffer:</a>
<a name="ln318">  if(!dsc)</a>
<a name="ln319">  {</a>
<a name="ln320">    if(mip == DT_MIPMAP_8)</a>
<a name="ln321">    {</a>
<a name="ln322">      int imgfw= 0, imgfh= 0;</a>
<a name="ln323">      // be sure that we have the right size values</a>
<a name="ln324">      dt_image_get_final_size(get_imgid(entry-&gt;key), &amp;imgfw, &amp;imgfh);</a>
<a name="ln325">      entry-&gt;data_size = sizeof(struct dt_mipmap_buffer_dsc) + (imgfw + 4) * (imgfh + 4) * 4;</a>
<a name="ln326">    }</a>
<a name="ln327">    else if(mip &lt;= DT_MIPMAP_F)</a>
<a name="ln328">    {</a>
<a name="ln329">      // these are fixed-size:</a>
<a name="ln330">      entry-&gt;data_size = cache-&gt;buffer_size[mip];</a>
<a name="ln331">    }</a>
<a name="ln332">    else</a>
<a name="ln333">    {</a>
<a name="ln334">      entry-&gt;data_size = sizeof(*dsc) + sizeof(float) * 4 * 64;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    entry-&gt;data = dt_alloc_align(64, entry-&gt;data_size);</a>
<a name="ln338"> </a>
<a name="ln339">    // fprintf(stderr, &quot;[mipmap cache] alloc dynamic for key %u %p\n&quot;, key, *buf);</a>
<a name="ln340">    if(!(entry-&gt;data))</a>
<a name="ln341">    {</a>
<a name="ln342">      fprintf(stderr, &quot;[mipmap cache] memory allocation failed!\n&quot;);</a>
<a name="ln343">      exit(1);</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">    dsc = entry-&gt;data;</a>
<a name="ln347"> </a>
<a name="ln348">    if(mip &lt;= DT_MIPMAP_F)</a>
<a name="ln349">    {</a>
<a name="ln350">      dsc-&gt;width = cache-&gt;max_width[mip];</a>
<a name="ln351">      dsc-&gt;height = cache-&gt;max_height[mip];</a>
<a name="ln352">      dsc-&gt;iscale = 1.0f;</a>
<a name="ln353">      dsc-&gt;size = entry-&gt;data_size;</a>
<a name="ln354">      dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln355">    }</a>
<a name="ln356">    else</a>
<a name="ln357">    {</a>
<a name="ln358">      dsc-&gt;width = 0;</a>
<a name="ln359">      dsc-&gt;height = 0;</a>
<a name="ln360">      dsc-&gt;iscale = 0.0f;</a>
<a name="ln361">      dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln362">      dsc-&gt;size = entry-&gt;data_size;</a>
<a name="ln363">    }</a>
<a name="ln364">  }</a>
<a name="ln365"> </a>
<a name="ln366">  assert(dsc-&gt;size &gt;= sizeof(*dsc));</a>
<a name="ln367"> </a>
<a name="ln368">  int loaded_from_disk = 0;</a>
<a name="ln369">  if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln370">  {</a>
<a name="ln371">    if(cache-&gt;cachedir[0] &amp;&amp; ((dt_conf_get_bool(&quot;cache_disk_backend&quot;) &amp;&amp; mip &lt; DT_MIPMAP_8)</a>
<a name="ln372">                              || (dt_conf_get_bool(&quot;cache_disk_backend_full&quot;) &amp;&amp; mip == DT_MIPMAP_8)))</a>
<a name="ln373">    {</a>
<a name="ln374">      // try and load from disk, if successful set flag</a>
<a name="ln375">      char filename[PATH_MAX] = {0};</a>
<a name="ln376">      snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, get_imgid(entry-&gt;key));</a>
<a name="ln377">      FILE *f = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln378">      if(f)</a>
<a name="ln379">      {</a>
<a name="ln380">        uint8_t *blob = 0;</a>
<a name="ln381">        fseek(f, 0, SEEK_END);</a>
<a name="ln382">        const long len = ftell(f);</a>
<a name="ln383">        if(len &lt;= 0) goto read_error; // coverity madness</a>
<a name="ln384">        blob = (uint8_t *)dt_alloc_align(64, len);</a>
<a name="ln385">        if(!blob) goto read_error;</a>
<a name="ln386">        fseek(f, 0, SEEK_SET);</a>
<a name="ln387">        const int rd = fread(blob, sizeof(uint8_t), len, f);</a>
<a name="ln388">        if(rd != len) goto read_error;</a>
<a name="ln389">        dt_colorspaces_color_profile_type_t color_space;</a>
<a name="ln390">        dt_imageio_jpeg_t jpg;</a>
<a name="ln391">        if(dt_imageio_jpeg_decompress_header(blob, len, &amp;jpg)</a>
<a name="ln392">           || (jpg.width &gt; cache-&gt;max_width[mip] || jpg.height &gt; cache-&gt;max_height[mip])</a>
<a name="ln393">           || ((color_space = dt_imageio_jpeg_read_color_space(&amp;jpg)) == DT_COLORSPACE_NONE) // pointless test to keep it in the if clause</a>
<a name="ln394">           || dt_imageio_jpeg_decompress(&amp;jpg, entry-&gt;data + sizeof(*dsc)))</a>
<a name="ln395">        {</a>
<a name="ln396">          fprintf(stderr, &quot;[mipmap_cache] failed to decompress thumbnail for image %d from `%s'!\n&quot;, get_imgid(entry-&gt;key), filename);</a>
<a name="ln397">          goto read_error;</a>
<a name="ln398">        }</a>
<a name="ln399">        dsc-&gt;width = jpg.width;</a>
<a name="ln400">        dsc-&gt;height = jpg.height;</a>
<a name="ln401">        dsc-&gt;iscale = 1.0f;</a>
<a name="ln402">        dsc-&gt;color_space = color_space;</a>
<a name="ln403">        loaded_from_disk = 1;</a>
<a name="ln404">        if(0)</a>
<a name="ln405">        {</a>
<a name="ln406">read_error:</a>
<a name="ln407">          g_unlink(filename);</a>
<a name="ln408">        }</a>
<a name="ln409">        dt_free_align(blob);</a>
<a name="ln410">        fclose(f);</a>
<a name="ln411">      }</a>
<a name="ln412">    }</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  if(!loaded_from_disk)</a>
<a name="ln416">    dsc-&gt;flags = DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln417">  else dsc-&gt;flags = 0;</a>
<a name="ln418"> </a>
<a name="ln419">  // cost is just flat one for the buffer, as the buffers might have different sizes,</a>
<a name="ln420">  // to make sure quota is meaningful.</a>
<a name="ln421">  if(mip &gt;= DT_MIPMAP_F)</a>
<a name="ln422">    entry-&gt;cost = 1;</a>
<a name="ln423">  else if(mip == DT_MIPMAP_8)</a>
<a name="ln424">    entry-&gt;cost = entry-&gt;data_size;</a>
<a name="ln425">  else</a>
<a name="ln426">    entry-&gt;cost = cache-&gt;buffer_size[mip];</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">static void dt_mipmap_cache_unlink_ondisk_thumbnail(void *data, uint32_t imgid, dt_mipmap_size_t mip)</a>
<a name="ln430">{</a>
<a name="ln431">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln432"> </a>
<a name="ln433">  // also remove jpg backing (always try to do that, in case user just temporarily switched it off,</a>
<a name="ln434">  // to avoid inconsistencies.</a>
<a name="ln435">  // if(dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln436">  if(cache-&gt;cachedir[0])</a>
<a name="ln437">  {</a>
<a name="ln438">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln439">    snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, imgid);</a>
<a name="ln440">    g_unlink(filename);</a>
<a name="ln441">  }</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">void dt_mipmap_cache_deallocate_dynamic(void *data, dt_cache_entry_t *entry)</a>
<a name="ln445">{</a>
<a name="ln446">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln447">  const dt_mipmap_size_t mip = get_size(entry-&gt;key);</a>
<a name="ln448">  if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln449">  {</a>
<a name="ln450">    struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln451">    // don't write skulls:</a>
<a name="ln452">    if(dsc-&gt;width &gt; 8 &amp;&amp; dsc-&gt;height &gt; 8)</a>
<a name="ln453">    {</a>
<a name="ln454">      if(dsc-&gt;flags &amp; DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE)</a>
<a name="ln455">      {</a>
<a name="ln456">        dt_mipmap_cache_unlink_ondisk_thumbnail(data, get_imgid(entry-&gt;key), mip);</a>
<a name="ln457">      }</a>
<a name="ln458">      else if(cache-&gt;cachedir[0] &amp;&amp; ((dt_conf_get_bool(&quot;cache_disk_backend&quot;) &amp;&amp; mip &lt; DT_MIPMAP_8)</a>
<a name="ln459">                                     || (dt_conf_get_bool(&quot;cache_disk_backend_full&quot;) &amp;&amp; mip == DT_MIPMAP_8)))</a>
<a name="ln460">      {</a>
<a name="ln461">        // serialize to disk</a>
<a name="ln462">        char filename[PATH_MAX] = {0};</a>
<a name="ln463">        snprintf(filename, sizeof(filename), &quot;%s.d/%d&quot;, cache-&gt;cachedir, mip);</a>
<a name="ln464">        const int mkd = g_mkdir_with_parents(filename, 0750);</a>
<a name="ln465">        if(!mkd)</a>
<a name="ln466">        {</a>
<a name="ln467">          snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, get_imgid(entry-&gt;key));</a>
<a name="ln468">          // Don't write existing files as both performance and quality (lossy jpg) suffer</a>
<a name="ln469">          FILE *f = NULL;</a>
<a name="ln470">          if (!g_file_test(filename, G_FILE_TEST_EXISTS) &amp;&amp; (f = g_fopen(filename, &quot;wb&quot;)))</a>
<a name="ln471">          {</a>
<a name="ln472">            // first check the disk isn't full</a>
<a name="ln473">            struct statvfs vfsbuf;</a>
<a name="ln474">            if (!statvfs(filename, &amp;vfsbuf))</a>
<a name="ln475">            {</a>
<a name="ln476">              const int64_t free_mb = ((vfsbuf.f_frsize * vfsbuf.f_bavail) &gt;&gt; 20);</a>
<a name="ln477">              if (free_mb &lt; 100)</a>
<a name="ln478">              {</a>
<a name="ln479">                fprintf(stderr, &quot;Aborting image write as only %&quot; PRId64 &quot; MB free to write %s\n&quot;, free_mb, filename);</a>
<a name="ln480">                goto write_error;</a>
<a name="ln481">              }</a>
<a name="ln482">            }</a>
<a name="ln483">            else</a>
<a name="ln484">            {</a>
<a name="ln485">              fprintf(stderr, &quot;Aborting image write since couldn't determine free space available to write %s\n&quot;, filename);</a>
<a name="ln486">              goto write_error;</a>
<a name="ln487">            }</a>
<a name="ln488"> </a>
<a name="ln489">            const int cache_quality = dt_conf_get_int(&quot;database_cache_quality&quot;);</a>
<a name="ln490">            const uint8_t *exif = NULL;</a>
<a name="ln491">            int exif_len = 0;</a>
<a name="ln492">            if(dsc-&gt;color_space == DT_COLORSPACE_SRGB)</a>
<a name="ln493">            {</a>
<a name="ln494">              exif = dt_mipmap_cache_exif_data_srgb;</a>
<a name="ln495">              exif_len = dt_mipmap_cache_exif_data_srgb_length;</a>
<a name="ln496">            }</a>
<a name="ln497">            else if(dsc-&gt;color_space == DT_COLORSPACE_ADOBERGB)</a>
<a name="ln498">            {</a>
<a name="ln499">              exif = dt_mipmap_cache_exif_data_adobergb;</a>
<a name="ln500">              exif_len = dt_mipmap_cache_exif_data_adobergb_length;</a>
<a name="ln501">            }</a>
<a name="ln502">            if(dt_imageio_jpeg_write(filename, entry-&gt;data + sizeof(*dsc), dsc-&gt;width, dsc-&gt;height, MIN(100, MAX(10, cache_quality)), exif, exif_len))</a>
<a name="ln503">            {</a>
<a name="ln504">write_error:</a>
<a name="ln505">              g_unlink(filename);</a>
<a name="ln506">            }</a>
<a name="ln507">          }</a>
<a name="ln508">          if(f) fclose(f);</a>
<a name="ln509">        }</a>
<a name="ln510">      }</a>
<a name="ln511">    }</a>
<a name="ln512">  }</a>
<a name="ln513">  dt_free_align(entry-&gt;data);</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">static uint32_t nearest_power_of_two(const uint32_t value)</a>
<a name="ln517">{</a>
<a name="ln518">  uint32_t rc = 1;</a>
<a name="ln519">  while(rc &lt; value) rc &lt;&lt;= 1;</a>
<a name="ln520">  return rc;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">void dt_mipmap_cache_init(dt_mipmap_cache_t *cache)</a>
<a name="ln524">{</a>
<a name="ln525">  dt_mipmap_cache_get_filename(cache-&gt;cachedir, sizeof(cache-&gt;cachedir));</a>
<a name="ln526">  // make sure static memory is initialized</a>
<a name="ln527">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)dt_mipmap_cache_static_dead_image;</a>
<a name="ln528">  dead_image_f((dt_mipmap_buffer_t *)(dsc + 1));</a>
<a name="ln529"> </a>
<a name="ln530">  // adjust numbers to be large enough to hold what mem limit suggests.</a>
<a name="ln531">  // we want at least 100MB, and consider 8G just still reasonable.</a>
<a name="ln532">  const int64_t cache_memory = dt_conf_get_int64(&quot;cache_memory&quot;);</a>
<a name="ln533">  const int worker_threads = dt_conf_get_int(&quot;worker_threads&quot;);</a>
<a name="ln534">  const size_t max_mem = CLAMPS(cache_memory, 100u &lt;&lt; 20, ((size_t)8) &lt;&lt; 30);</a>
<a name="ln535">  const uint32_t parallel = CLAMP(worker_threads, 1, 8);</a>
<a name="ln536"> </a>
<a name="ln537">  // Fixed sizes for the thumbnail mip levels, selected for coverage of most screen sizes</a>
<a name="ln538">  int32_t mipsizes[DT_MIPMAP_F][2] = {</a>
<a name="ln539">    { 180, 110 },             // mip0 - ~1/2 size previous one</a>
<a name="ln540">    { 360, 225 },             // mip1 - 1/2 size previous one</a>
<a name="ln541">    { 720, 450 },             // mip2 - 1/2 size previous one</a>
<a name="ln542">    { 1440, 900 },            // mip3 - covers 720p and 1366x768</a>
<a name="ln543">    { 1920, 1200 },           // mip4 - covers 1080p and 1600x1200</a>
<a name="ln544">    { 2560, 1600 },           // mip5 - covers 2560x1440</a>
<a name="ln545">    { 4096, 2560 },           // mip6 - covers 4K and UHD</a>
<a name="ln546">    { 5120, 3200 },           // mip7 - covers 5120x2880 panels</a>
<a name="ln547">    { 999999999, 999999999 }, // mip8 - used for full preview at full size</a>
<a name="ln548">  };</a>
<a name="ln549">  // Set mipf to mip2 size as at most the user will be using an 8K screen and</a>
<a name="ln550">  // have a preview that's ~4x smaller</a>
<a name="ln551">  cache-&gt;max_width[DT_MIPMAP_F] = mipsizes[DT_MIPMAP_2][0];</a>
<a name="ln552">  cache-&gt;max_height[DT_MIPMAP_F] = mipsizes[DT_MIPMAP_2][1];</a>
<a name="ln553">  for(int k = DT_MIPMAP_F-1; k &gt;= 0; k--)</a>
<a name="ln554">  {</a>
<a name="ln555">    cache-&gt;max_width[k]  = mipsizes[k][0];</a>
<a name="ln556">    cache-&gt;max_height[k] = mipsizes[k][1];</a>
<a name="ln557">  }</a>
<a name="ln558">    // header + buffer</a>
<a name="ln559">  for(int k = DT_MIPMAP_F-1; k &gt;= 0; k--)</a>
<a name="ln560">    cache-&gt;buffer_size[k] = sizeof(struct dt_mipmap_buffer_dsc)</a>
<a name="ln561">                                + cache-&gt;max_width[k] * cache-&gt;max_height[k] * 4;</a>
<a name="ln562"> </a>
<a name="ln563">  // clear stats:</a>
<a name="ln564">  cache-&gt;mip_thumbs.stats_requests = 0;</a>
<a name="ln565">  cache-&gt;mip_thumbs.stats_near_match = 0;</a>
<a name="ln566">  cache-&gt;mip_thumbs.stats_misses = 0;</a>
<a name="ln567">  cache-&gt;mip_thumbs.stats_fetches = 0;</a>
<a name="ln568">  cache-&gt;mip_thumbs.stats_standin = 0;</a>
<a name="ln569">  cache-&gt;mip_f.stats_requests = 0;</a>
<a name="ln570">  cache-&gt;mip_f.stats_near_match = 0;</a>
<a name="ln571">  cache-&gt;mip_f.stats_misses = 0;</a>
<a name="ln572">  cache-&gt;mip_f.stats_fetches = 0;</a>
<a name="ln573">  cache-&gt;mip_f.stats_standin = 0;</a>
<a name="ln574">  cache-&gt;mip_full.stats_requests = 0;</a>
<a name="ln575">  cache-&gt;mip_full.stats_near_match = 0;</a>
<a name="ln576">  cache-&gt;mip_full.stats_misses = 0;</a>
<a name="ln577">  cache-&gt;mip_full.stats_fetches = 0;</a>
<a name="ln578">  cache-&gt;mip_full.stats_standin = 0;</a>
<a name="ln579"> </a>
<a name="ln580">  dt_cache_init(&amp;cache-&gt;mip_thumbs.cache, 0, max_mem);</a>
<a name="ln581">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_thumbs.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln582">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_thumbs.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln583"> </a>
<a name="ln584">  const int full_entries</a>
<a name="ln585">      = MAX(2, parallel); // even with one thread you want two buffers. one for dr one for thumbs.</a>
<a name="ln586">  const int32_t max_mem_bufs = nearest_power_of_two(full_entries);</a>
<a name="ln587"> </a>
<a name="ln588">  // for this buffer, because it can be very busy during import</a>
<a name="ln589">  dt_cache_init(&amp;cache-&gt;mip_full.cache, 0, max_mem_bufs);</a>
<a name="ln590">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_full.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln591">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_full.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln592">  cache-&gt;buffer_size[DT_MIPMAP_FULL] = 0;</a>
<a name="ln593"> </a>
<a name="ln594">  // same for mipf:</a>
<a name="ln595">  dt_cache_init(&amp;cache-&gt;mip_f.cache, 0, max_mem_bufs);</a>
<a name="ln596">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_f.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln597">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_f.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln598">  cache-&gt;buffer_size[DT_MIPMAP_F] = sizeof(struct dt_mipmap_buffer_dsc)</a>
<a name="ln599">                                        + 4 * sizeof(float) * cache-&gt;max_width[DT_MIPMAP_F]</a>
<a name="ln600">                                          * cache-&gt;max_height[DT_MIPMAP_F];</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">void dt_mipmap_cache_cleanup(dt_mipmap_cache_t *cache)</a>
<a name="ln604">{</a>
<a name="ln605">  dt_cache_cleanup(&amp;cache-&gt;mip_thumbs.cache);</a>
<a name="ln606">  dt_cache_cleanup(&amp;cache-&gt;mip_full.cache);</a>
<a name="ln607">  dt_cache_cleanup(&amp;cache-&gt;mip_f.cache);</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">void dt_mipmap_cache_print(dt_mipmap_cache_t *cache)</a>
<a name="ln611">{</a>
<a name="ln612">  printf(&quot;[mipmap_cache] thumbs fill %.2f/%.2f MB (%.2f%%)\n&quot;,</a>
<a name="ln613">         cache-&gt;mip_thumbs.cache.cost / (1024.0 * 1024.0),</a>
<a name="ln614">         cache-&gt;mip_thumbs.cache.cost_quota / (1024.0 * 1024.0),</a>
<a name="ln615">         100.0f * (float)cache-&gt;mip_thumbs.cache.cost / (float)cache-&gt;mip_thumbs.cache.cost_quota);</a>
<a name="ln616">  printf(&quot;[mipmap_cache] float fill %d/%d slots (%.2f%%)\n&quot;,</a>
<a name="ln617">         (uint32_t)cache-&gt;mip_f.cache.cost, (uint32_t)cache-&gt;mip_f.cache.cost_quota,</a>
<a name="ln618">         100.0f * (float)cache-&gt;mip_f.cache.cost / (float)cache-&gt;mip_f.cache.cost_quota);</a>
<a name="ln619">  printf(&quot;[mipmap_cache] full  fill %d/%d slots (%.2f%%)\n&quot;,</a>
<a name="ln620">         (uint32_t)cache-&gt;mip_full.cache.cost, (uint32_t)cache-&gt;mip_full.cache.cost_quota,</a>
<a name="ln621">         100.0f * (float)cache-&gt;mip_full.cache.cost / (float)cache-&gt;mip_full.cache.cost_quota);</a>
<a name="ln622"> </a>
<a name="ln623">  uint64_t sum = 0;</a>
<a name="ln624">  uint64_t sum_fetches = 0;</a>
<a name="ln625">  uint64_t sum_standins = 0;</a>
<a name="ln626">  sum += cache-&gt;mip_thumbs.stats_requests;</a>
<a name="ln627">  sum_fetches += cache-&gt;mip_thumbs.stats_fetches;</a>
<a name="ln628">  sum_standins += cache-&gt;mip_thumbs.stats_standin;</a>
<a name="ln629">  sum += cache-&gt;mip_f.stats_requests;</a>
<a name="ln630">  sum_fetches += cache-&gt;mip_f.stats_fetches;</a>
<a name="ln631">  sum_standins += cache-&gt;mip_f.stats_standin;</a>
<a name="ln632">  sum += cache-&gt;mip_full.stats_requests;</a>
<a name="ln633">  sum_fetches += cache-&gt;mip_full.stats_fetches;</a>
<a name="ln634">  sum_standins += cache-&gt;mip_full.stats_standin;</a>
<a name="ln635">  printf(&quot;[mipmap_cache] level | near match | miss | stand-in | fetches | total rq\n&quot;);</a>
<a name="ln636">  printf(&quot;[mipmap_cache] thumb | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln637">         100.0 * cache-&gt;mip_thumbs.stats_near_match / (float)cache-&gt;mip_thumbs.stats_requests,</a>
<a name="ln638">         100.0 * cache-&gt;mip_thumbs.stats_misses / (float)cache-&gt;mip_thumbs.stats_requests,</a>
<a name="ln639">         100.0 * cache-&gt;mip_thumbs.stats_standin / (float)sum_standins,</a>
<a name="ln640">         100.0 * cache-&gt;mip_thumbs.stats_fetches / (float)sum_fetches,</a>
<a name="ln641">         100.0 * cache-&gt;mip_thumbs.stats_requests / (float)sum);</a>
<a name="ln642">  printf(&quot;[mipmap_cache] float | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln643">         100.0 * cache-&gt;mip_f.stats_near_match / (float)cache-&gt;mip_f.stats_requests,</a>
<a name="ln644">         100.0 * cache-&gt;mip_f.stats_misses / (float)cache-&gt;mip_f.stats_requests,</a>
<a name="ln645">         100.0 * cache-&gt;mip_f.stats_standin / (float)sum_standins,</a>
<a name="ln646">         100.0 * cache-&gt;mip_f.stats_fetches / (float)sum_fetches,</a>
<a name="ln647">         100.0 * cache-&gt;mip_f.stats_requests / (float)sum);</a>
<a name="ln648">  printf(&quot;[mipmap_cache] full  | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln649">         100.0 * cache-&gt;mip_full.stats_near_match / (float)cache-&gt;mip_full.stats_requests,</a>
<a name="ln650">         100.0 * cache-&gt;mip_full.stats_misses / (float)cache-&gt;mip_full.stats_requests,</a>
<a name="ln651">         100.0 * cache-&gt;mip_full.stats_standin / (float)sum_standins,</a>
<a name="ln652">         100.0 * cache-&gt;mip_full.stats_fetches / (float)sum_fetches,</a>
<a name="ln653">         100.0 * cache-&gt;mip_full.stats_requests / (float)sum);</a>
<a name="ln654">  printf(&quot;\n\n&quot;);</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">static gboolean _raise_signal_mipmap_updated(gpointer user_data)</a>
<a name="ln658">{</a>
<a name="ln659">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_MIPMAP_UPDATED);</a>
<a name="ln660">  return FALSE; // only call once</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">static dt_mipmap_cache_one_t *_get_cache(dt_mipmap_cache_t *cache, const dt_mipmap_size_t mip)</a>
<a name="ln664">{</a>
<a name="ln665">  switch(mip)</a>
<a name="ln666">  {</a>
<a name="ln667">    case DT_MIPMAP_FULL:</a>
<a name="ln668">      return &amp;cache-&gt;mip_full;</a>
<a name="ln669">    case DT_MIPMAP_F:</a>
<a name="ln670">      return &amp;cache-&gt;mip_f;</a>
<a name="ln671">    default:</a>
<a name="ln672">      return &amp;cache-&gt;mip_thumbs;</a>
<a name="ln673">  }</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">void dt_mipmap_cache_get_with_caller(</a>
<a name="ln677">    dt_mipmap_cache_t *cache,</a>
<a name="ln678">    dt_mipmap_buffer_t *buf,</a>
<a name="ln679">    const uint32_t imgid,</a>
<a name="ln680">    const dt_mipmap_size_t mip,</a>
<a name="ln681">    const dt_mipmap_get_flags_t flags,</a>
<a name="ln682">    const char mode,</a>
<a name="ln683">    const char *file,</a>
<a name="ln684">    int line)</a>
<a name="ln685">{</a>
<a name="ln686">  const uint32_t key = get_key(imgid, mip);</a>
<a name="ln687">  if(flags == DT_MIPMAP_TESTLOCK)</a>
<a name="ln688">  {</a>
<a name="ln689">    // simple case: only get and lock if it's there.</a>
<a name="ln690">    dt_cache_entry_t *entry = dt_cache_testget(&amp;_get_cache(cache, mip)-&gt;cache, key, mode);</a>
<a name="ln691">    buf-&gt;cache_entry = entry;</a>
<a name="ln692">    if(entry)</a>
<a name="ln693">    {</a>
<a name="ln694">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln695">      struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln696">      buf-&gt;width = dsc-&gt;width;</a>
<a name="ln697">      buf-&gt;height = dsc-&gt;height;</a>
<a name="ln698">      buf-&gt;iscale = dsc-&gt;iscale;</a>
<a name="ln699">      buf-&gt;color_space = dsc-&gt;color_space;</a>
<a name="ln700">      buf-&gt;imgid = imgid;</a>
<a name="ln701">      buf-&gt;size = mip;</a>
<a name="ln702"> </a>
<a name="ln703">      // skip to next 8-byte alignment, for sse buffers.</a>
<a name="ln704">      buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln705"> </a>
<a name="ln706">      ASAN_UNPOISON_MEMORY_REGION(buf-&gt;buf, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln707">    }</a>
<a name="ln708">    else</a>
<a name="ln709">    {</a>
<a name="ln710">      // set to NULL if failed.</a>
<a name="ln711">      buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln712">      buf-&gt;iscale = 0.0f;</a>
<a name="ln713">      buf-&gt;imgid = 0;</a>
<a name="ln714">      buf-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln715">      buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln716">      buf-&gt;buf = NULL;</a>
<a name="ln717">    }</a>
<a name="ln718">  }</a>
<a name="ln719">  else if(flags == DT_MIPMAP_PREFETCH)</a>
<a name="ln720">  {</a>
<a name="ln721">    // and opposite: prefetch without locking</a>
<a name="ln722">    if(mip &gt; DT_MIPMAP_FULL || (int)mip &lt; DT_MIPMAP_0)</a>
<a name="ln723">      return; // remove the (int) once we no longer have to support gcc &lt; 4.8 :/</a>
<a name="ln724">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, dt_image_load_job_create(imgid, mip));</a>
<a name="ln725">  }</a>
<a name="ln726">  else if(flags == DT_MIPMAP_PREFETCH_DISK)</a>
<a name="ln727">  {</a>
<a name="ln728">    // only prefetch if the disk cache exists:</a>
<a name="ln729">    if(!cache-&gt;cachedir[0]) return;</a>
<a name="ln730">    if(mip &gt; DT_MIPMAP_FULL || (int)mip &lt; DT_MIPMAP_0)</a>
<a name="ln731">      return; // remove the (int) once we no longer have to support gcc &lt; 4.8 :/</a>
<a name="ln732">    char filename[PATH_MAX] = {0};</a>
<a name="ln733">    snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, key);</a>
<a name="ln734">    // don't attempt to load if disk cache doesn't exist</a>
<a name="ln735">    if(!g_file_test(filename, G_FILE_TEST_EXISTS)) return;</a>
<a name="ln736">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, dt_image_load_job_create(imgid, mip));</a>
<a name="ln737">  }</a>
<a name="ln738">  else if(flags == DT_MIPMAP_BLOCKING)</a>
<a name="ln739">  {</a>
<a name="ln740">    // simple case: blocking get</a>
<a name="ln741">    dt_cache_entry_t *entry =  dt_cache_get_with_caller(&amp;_get_cache(cache, mip)-&gt;cache, key, mode, file, line);</a>
<a name="ln742"> </a>
<a name="ln743">    ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln744"> </a>
<a name="ln745">    struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln746">    buf-&gt;cache_entry = entry;</a>
<a name="ln747"> </a>
<a name="ln748">    int mipmap_generated = 0;</a>
<a name="ln749">    if(dsc-&gt;flags &amp; DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE)</a>
<a name="ln750">    {</a>
<a name="ln751">      mipmap_generated = 1;</a>
<a name="ln752"> </a>
<a name="ln753">      __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_fetches), 1);</a>
<a name="ln754">      // fprintf(stderr, &quot;[mipmap cache get] now initializing buffer for img %u mip %d!\n&quot;, imgid, mip);</a>
<a name="ln755">      // we're write locked here, as requested by the alloc callback.</a>
<a name="ln756">      // now fill it with data:</a>
<a name="ln757">      if(mip == DT_MIPMAP_FULL)</a>
<a name="ln758">      {</a>
<a name="ln759">        // load the image:</a>
<a name="ln760">        // make sure we access the r/w lock as shortly as possible!</a>
<a name="ln761">        dt_image_t buffered_image;</a>
<a name="ln762">        const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln763">        buffered_image = *cimg;</a>
<a name="ln764">        // dt_image_t *img = dt_image_cache_write_get(darktable.image_cache, cimg);</a>
<a name="ln765">        // dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln766">        dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln767"> </a>
<a name="ln768">        char filename[PATH_MAX] = { 0 };</a>
<a name="ln769">        gboolean from_cache = TRUE;</a>
<a name="ln770">        dt_image_full_path(buffered_image.id, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln771"> </a>
<a name="ln772">        buf-&gt;imgid = imgid;</a>
<a name="ln773">        buf-&gt;size = mip;</a>
<a name="ln774">        buf-&gt;buf = 0;</a>
<a name="ln775">        buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln776">        buf-&gt;iscale = 0.0f;</a>
<a name="ln777">        buf-&gt;color_space = DT_COLORSPACE_NONE; // TODO: does the full buffer need to know this?</a>
<a name="ln778">        dt_imageio_retval_t ret = dt_imageio_open(&amp;buffered_image, filename, buf); // TODO: color_space?</a>
<a name="ln779">        // might have been reallocated:</a>
<a name="ln780">        ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln781">        dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;cache_entry-&gt;data;</a>
<a name="ln782">        if(ret != DT_IMAGEIO_OK)</a>
<a name="ln783">        {</a>
<a name="ln784">          // fprintf(stderr, &quot;[mipmap read get] error loading image: %d\n&quot;, ret);</a>
<a name="ln785">          //</a>
<a name="ln786">          // we can only return a zero dimension buffer if the buffer has been allocated.</a>
<a name="ln787">          // in case dsc couldn't be allocated and points to the static buffer, it contains</a>
<a name="ln788">          // a dead image already.</a>
<a name="ln789">          if((void *)dsc != (void *)dt_mipmap_cache_static_dead_image)</a>
<a name="ln790">          {</a>
<a name="ln791">            dsc-&gt;width = dsc-&gt;height = 0;</a>
<a name="ln792">            buf-&gt;iscale = 0.0f;</a>
<a name="ln793">            dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln794">          }</a>
<a name="ln795">        }</a>
<a name="ln796">        else</a>
<a name="ln797">        {</a>
<a name="ln798">          // swap back new image data:</a>
<a name="ln799">          dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln800">          *img = buffered_image;</a>
<a name="ln801">          // fprintf(stderr, &quot;[mipmap read get] initializing full buffer img %u with %u %u -&gt; %d %d (%p)\n&quot;,</a>
<a name="ln802">          // imgid, data[0], data[1], img-&gt;width, img-&gt;height, data);</a>
<a name="ln803">          // don't write xmp for this (we only changed db stuff):</a>
<a name="ln804">          dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln805">        }</a>
<a name="ln806">      }</a>
<a name="ln807">      else if(mip == DT_MIPMAP_F)</a>
<a name="ln808">      {</a>
<a name="ln809">        ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln810">        _init_f(buf, (float *)(dsc + 1), &amp;dsc-&gt;width, &amp;dsc-&gt;height, &amp;dsc-&gt;iscale, imgid);</a>
<a name="ln811">      }</a>
<a name="ln812">      else</a>
<a name="ln813">      {</a>
<a name="ln814">        // 8-bit thumbs</a>
<a name="ln815">        ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln816">        _init_8((uint8_t *)(dsc + 1), &amp;dsc-&gt;width, &amp;dsc-&gt;height, &amp;dsc-&gt;iscale, &amp;buf-&gt;color_space, imgid, mip);</a>
<a name="ln817">      }</a>
<a name="ln818">      dsc-&gt;color_space = buf-&gt;color_space;</a>
<a name="ln819">      dsc-&gt;flags &amp;= ~DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln820">    }</a>
<a name="ln821"> </a>
<a name="ln822">    // image cache is leaving the write lock in place in case the image has been newly allocated.</a>
<a name="ln823">    // this leads to a slight increase in thread contention, so we opt for dropping the write lock</a>
<a name="ln824">    // and acquiring a read lock immediately after. since this opens a small window for other threads</a>
<a name="ln825">    // to get in between, we need to take some care to re-init cache entries and dsc.</a>
<a name="ln826">    // note that concurrencykit has rw locks that can be demoted from w-&gt;r without losing the lock in between.</a>
<a name="ln827">    if(mode == 'r')</a>
<a name="ln828">    {</a>
<a name="ln829">      entry-&gt;_lock_demoting = 1;</a>
<a name="ln830">      // drop the write lock</a>
<a name="ln831">      dt_cache_release(&amp;_get_cache(cache, mip)-&gt;cache, entry);</a>
<a name="ln832">      // get a read lock</a>
<a name="ln833">      buf-&gt;cache_entry = entry = dt_cache_get(&amp;_get_cache(cache, mip)-&gt;cache, key, mode);</a>
<a name="ln834">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln835">      entry-&gt;_lock_demoting = 0;</a>
<a name="ln836">      dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;cache_entry-&gt;data;</a>
<a name="ln837">    }</a>
<a name="ln838"> </a>
<a name="ln839">#ifdef _DEBUG</a>
<a name="ln840">    const pthread_t writer = dt_pthread_rwlock_get_writer(&amp;(buf-&gt;cache_entry-&gt;lock));</a>
<a name="ln841">    if(mode == 'w')</a>
<a name="ln842">    {</a>
<a name="ln843">      assert(pthread_equal(writer, pthread_self()));</a>
<a name="ln844">    }</a>
<a name="ln845">    else</a>
<a name="ln846">    {</a>
<a name="ln847">      assert(!pthread_equal(writer, pthread_self()));</a>
<a name="ln848">    }</a>
<a name="ln849">#endif</a>
<a name="ln850"> </a>
<a name="ln851">    if(mipmap_generated)</a>
<a name="ln852">    {</a>
<a name="ln853">      /* raise signal that mipmaps has been flushed to cache */</a>
<a name="ln854">      g_idle_add(_raise_signal_mipmap_updated, 0);</a>
<a name="ln855">    }</a>
<a name="ln856"> </a>
<a name="ln857">    buf-&gt;width = dsc-&gt;width;</a>
<a name="ln858">    buf-&gt;height = dsc-&gt;height;</a>
<a name="ln859">    buf-&gt;iscale = dsc-&gt;iscale;</a>
<a name="ln860">    buf-&gt;color_space = dsc-&gt;color_space;</a>
<a name="ln861">    buf-&gt;imgid = imgid;</a>
<a name="ln862">    buf-&gt;size = mip;</a>
<a name="ln863"> </a>
<a name="ln864">    ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln865">    buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln866"> </a>
<a name="ln867">    if(dsc-&gt;width == 0 || dsc-&gt;height == 0)</a>
<a name="ln868">    {</a>
<a name="ln869">      // fprintf(stderr, &quot;[mipmap cache get] got a zero-sized image for img %u mip %d!\n&quot;, imgid, mip);</a>
<a name="ln870">      if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln871">        dead_image_8(buf);</a>
<a name="ln872">      else if(mip == DT_MIPMAP_F)</a>
<a name="ln873">        dead_image_f(buf);</a>
<a name="ln874">      else</a>
<a name="ln875">        buf-&gt;buf = NULL; // full images with NULL buffer have to be handled, indicates `missing image', but still return locked slot</a>
<a name="ln876">    }</a>
<a name="ln877">  }</a>
<a name="ln878">  else if(flags == DT_MIPMAP_BEST_EFFORT)</a>
<a name="ln879">  {</a>
<a name="ln880">    __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_requests), 1);</a>
<a name="ln881">    // best-effort, might also return NULL.</a>
<a name="ln882">    // never decrease mip level for float buffer or full image:</a>
<a name="ln883">    dt_mipmap_size_t min_mip = (mip &gt;= DT_MIPMAP_F) ? mip : DT_MIPMAP_0;</a>
<a name="ln884">    for(int k = mip; k &gt;= min_mip &amp;&amp; k &gt;= 0; k--)</a>
<a name="ln885">    {</a>
<a name="ln886">      // already loaded?</a>
<a name="ln887">      dt_mipmap_cache_get(cache, buf, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln888">      if(buf-&gt;buf &amp;&amp; buf-&gt;width &gt; 0 &amp;&amp; buf-&gt;height &gt; 0)</a>
<a name="ln889">      {</a>
<a name="ln890">        if(mip != k) __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_standin), 1);</a>
<a name="ln891">        return;</a>
<a name="ln892">      }</a>
<a name="ln893">      // didn't succeed the first time? prefetch for later!</a>
<a name="ln894">      if(mip == k)</a>
<a name="ln895">      {</a>
<a name="ln896">        __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_near_match), 1);</a>
<a name="ln897">        dt_mipmap_cache_get(cache, buf, imgid, mip, DT_MIPMAP_PREFETCH, 'r');</a>
<a name="ln898">      }</a>
<a name="ln899">    }</a>
<a name="ln900">    // couldn't find a smaller thumb, try larger ones only now (these will be slightly slower due to cairo rescaling):</a>
<a name="ln901">    dt_mipmap_size_t max_mip = (mip &gt;= DT_MIPMAP_F) ? mip : DT_MIPMAP_F-1;</a>
<a name="ln902">    for(int k = mip+1; k &lt;= max_mip; k++)</a>
<a name="ln903">    {</a>
<a name="ln904">      // already loaded?</a>
<a name="ln905">      dt_mipmap_cache_get(cache, buf, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln906">      if(buf-&gt;buf &amp;&amp; buf-&gt;width &gt; 0 &amp;&amp; buf-&gt;height &gt; 0)</a>
<a name="ln907">      {</a>
<a name="ln908">        __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_standin), 1);</a>
<a name="ln909">        return;</a>
<a name="ln910">      }</a>
<a name="ln911">    }</a>
<a name="ln912">    __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_misses), 1);</a>
<a name="ln913">    // in case we don't even have a disk cache for our requested thumbnail,</a>
<a name="ln914">    // prefetch at least mip0, in case we have that in the disk caches:</a>
<a name="ln915">    if(cache-&gt;cachedir[0])</a>
<a name="ln916">    {</a>
<a name="ln917">      char filename[PATH_MAX] = {0};</a>
<a name="ln918">      snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, key);</a>
<a name="ln919">      if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln920">        dt_mipmap_cache_get(cache, 0, imgid, DT_MIPMAP_0, DT_MIPMAP_PREFETCH_DISK, 0);</a>
<a name="ln921">    }</a>
<a name="ln922">    // nothing found :(</a>
<a name="ln923">    buf-&gt;buf = NULL;</a>
<a name="ln924">    buf-&gt;imgid = 0;</a>
<a name="ln925">    buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln926">    buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln927">    buf-&gt;iscale = 0.0f;</a>
<a name="ln928">    buf-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln929">  }</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">void dt_mipmap_cache_write_get_with_caller(dt_mipmap_cache_t *cache, dt_mipmap_buffer_t *buf, const uint32_t imgid, const int mip, const char *file, int line)</a>
<a name="ln933">{</a>
<a name="ln934">  dt_mipmap_cache_get_with_caller(cache, buf, imgid, mip, DT_MIPMAP_BLOCKING, 'w', file, line);</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">void dt_mipmap_cache_release_with_caller(dt_mipmap_cache_t *cache, dt_mipmap_buffer_t *buf, const char *file,</a>
<a name="ln938">                                         int line)</a>
<a name="ln939">{</a>
<a name="ln940">  if(buf-&gt;size == DT_MIPMAP_NONE) return;</a>
<a name="ln941">  assert(buf-&gt;imgid &gt; 0);</a>
<a name="ln942">  // assert(buf-&gt;size &gt;= DT_MIPMAP_0); // breaks gcc-4.6/4.7 build</a>
<a name="ln943">  assert(buf-&gt;size &lt; DT_MIPMAP_NONE);</a>
<a name="ln944">  assert(buf-&gt;cache_entry);</a>
<a name="ln945">  dt_cache_release_with_caller(&amp;_get_cache(cache, buf-&gt;size)-&gt;cache, buf-&gt;cache_entry, file, line);</a>
<a name="ln946">  buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln947">  buf-&gt;buf = NULL;</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">// return the closest mipmap size</a>
<a name="ln952">dt_mipmap_size_t dt_mipmap_cache_get_matching_size(const dt_mipmap_cache_t *cache, const int32_t width,</a>
<a name="ln953">                                                   const int32_t height)</a>
<a name="ln954">{</a>
<a name="ln955">  const double ppd = (darktable.gui != NULL) ? darktable.gui-&gt;ppd : 1.0;</a>
<a name="ln956"> </a>
<a name="ln957">  // find `best' match to width and height.</a>
<a name="ln958">  int32_t error = 0x7fffffff;</a>
<a name="ln959">  dt_mipmap_size_t best = DT_MIPMAP_NONE;</a>
<a name="ln960">  for(int k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln961">  {</a>
<a name="ln962">    // find closest l1 norm:</a>
<a name="ln963">    int32_t new_error = cache-&gt;max_width[k] + cache-&gt;max_height[k] - width * ppd - height * ppd;</a>
<a name="ln964">    // and allow the first one to be larger in pixel size to override the smaller mip</a>
<a name="ln965">    if(abs(new_error) &lt; abs(error) || (error &lt; 0 &amp;&amp; new_error &gt; 0))</a>
<a name="ln966">    {</a>
<a name="ln967">      best = k;</a>
<a name="ln968">      error = new_error;</a>
<a name="ln969">    }</a>
<a name="ln970">  }</a>
<a name="ln971">  return best;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">void dt_mipmap_cache_remove(dt_mipmap_cache_t *cache, const uint32_t imgid)</a>
<a name="ln975">{</a>
<a name="ln976">  // get rid of all ldr thumbnails:</a>
<a name="ln977"> </a>
<a name="ln978">  for(dt_mipmap_size_t k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln979">  {</a>
<a name="ln980">    const uint32_t key = get_key(imgid, k);</a>
<a name="ln981">    dt_cache_entry_t *entry = dt_cache_testget(&amp;_get_cache(cache, k)-&gt;cache, key, 'w');</a>
<a name="ln982">    if(entry)</a>
<a name="ln983">    {</a>
<a name="ln984">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln985">      struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln986">      dsc-&gt;flags |= DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE;</a>
<a name="ln987">      dt_cache_release(&amp;_get_cache(cache, k)-&gt;cache, entry);</a>
<a name="ln988"> </a>
<a name="ln989">      // due to DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE, removes thumbnail from disc</a>
<a name="ln990">      dt_cache_remove(&amp;_get_cache(cache, k)-&gt;cache, key);</a>
<a name="ln991">    }</a>
<a name="ln992">    else</a>
<a name="ln993">    {</a>
<a name="ln994">      // ugly, but avoids alloc'ing thumb if it is not there.</a>
<a name="ln995">      dt_mipmap_cache_unlink_ondisk_thumbnail((&amp;_get_cache(cache, k)-&gt;cache)-&gt;cleanup_data, imgid, k);</a>
<a name="ln996">    }</a>
<a name="ln997">  }</a>
<a name="ln998">}</a>
<a name="ln999">void dt_mipmap_cache_evict_at_size(dt_mipmap_cache_t *cache, const uint32_t imgid, dt_mipmap_size_t mip)</a>
<a name="ln1000">{</a>
<a name="ln1001">  const uint32_t key = get_key(imgid, mip);</a>
<a name="ln1002">  // write thumbnail to disc if not existing there</a>
<a name="ln1003">  dt_cache_remove(&amp;_get_cache(cache, mip)-&gt;cache, key);</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">void dt_mimap_cache_evict(dt_mipmap_cache_t *cache, const uint32_t imgid)</a>
<a name="ln1007">{</a>
<a name="ln1008">  for(dt_mipmap_size_t k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln1009">  {</a>
<a name="ln1010">    const uint32_t key = get_key(imgid, k);</a>
<a name="ln1011"> </a>
<a name="ln1012">    // write thumbnail to disc if not existing there</a>
<a name="ln1013">    dt_cache_remove(&amp;_get_cache(cache, k)-&gt;cache, key);</a>
<a name="ln1014">  }</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">static void _init_f(dt_mipmap_buffer_t *mipmap_buf, float *out, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln1018">                    const uint32_t imgid)</a>
<a name="ln1019">{</a>
<a name="ln1020">  const uint32_t wd = *width, ht = *height;</a>
<a name="ln1021"> </a>
<a name="ln1022">  /* do not even try to process file if it isn't available */</a>
<a name="ln1023">  char filename[PATH_MAX] = { 0 };</a>
<a name="ln1024">  gboolean from_cache = TRUE;</a>
<a name="ln1025">  dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1026">  if(!*filename || !g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1027">  {</a>
<a name="ln1028">    *width = *height = 0;</a>
<a name="ln1029">    *iscale = 0.0f;</a>
<a name="ln1030">    return;</a>
<a name="ln1031">  }</a>
<a name="ln1032"> </a>
<a name="ln1033">  dt_mipmap_buffer_t buf;</a>
<a name="ln1034">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln1035"> </a>
<a name="ln1036">  // lock image after we have the buffer, we might need to lock the image struct for</a>
<a name="ln1037">  // writing during raw loading, to write to width/height.</a>
<a name="ln1038">  const dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1039"> </a>
<a name="ln1040">  dt_iop_roi_t roi_in, roi_out;</a>
<a name="ln1041">  roi_in.x = roi_in.y = 0;</a>
<a name="ln1042">  roi_in.width = image-&gt;width;</a>
<a name="ln1043">  roi_in.height = image-&gt;height;</a>
<a name="ln1044">  roi_in.scale = 1.0f;</a>
<a name="ln1045"> </a>
<a name="ln1046">  roi_out.x = roi_out.y = 0;</a>
<a name="ln1047"> </a>
<a name="ln1048">  // now let's figure out the scaling...</a>
<a name="ln1049"> </a>
<a name="ln1050">  // MIP_F is 4 channels, and we do not demosaic here</a>
<a name="ln1051">  const float coeff = (image-&gt;buf_dsc.filters) ? 2.0f : 1.0f;</a>
<a name="ln1052"> </a>
<a name="ln1053">  roi_out.scale = fminf((coeff * (float)wd) / (float)image-&gt;width, (coeff * (float)ht) / (float)image-&gt;height);</a>
<a name="ln1054">  roi_out.width = roi_out.scale * roi_in.width;</a>
<a name="ln1055">  roi_out.height = roi_out.scale * roi_in.height;</a>
<a name="ln1056"> </a>
<a name="ln1057">  if(!buf.buf)</a>
<a name="ln1058">  {</a>
<a name="ln1059">    dt_control_log(_(&quot;image `%s' is not available!&quot;), image-&gt;filename);</a>
<a name="ln1060">    dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1061">    *width = *height = 0;</a>
<a name="ln1062">    *iscale = 0.0f;</a>
<a name="ln1063">    return;</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066">  assert(!buffer_is_broken(&amp;buf));</a>
<a name="ln1067"> </a>
<a name="ln1068">  mipmap_buf-&gt;color_space = DT_COLORSPACE_NONE; // TODO: do we need that information in this buffer?</a>
<a name="ln1069"> </a>
<a name="ln1070">  if(image-&gt;buf_dsc.filters)</a>
<a name="ln1071">  {</a>
<a name="ln1072">    if(image-&gt;buf_dsc.filters != 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_FLOAT)</a>
<a name="ln1073">    {</a>
<a name="ln1074">      dt_iop_clip_and_zoom_mosaic_half_size_f((float *const)out, (const float *const)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1075">                                              roi_out.width, roi_in.width, image-&gt;buf_dsc.filters);</a>
<a name="ln1076">    }</a>
<a name="ln1077">    else if(image-&gt;buf_dsc.filters != 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_UINT16)</a>
<a name="ln1078">    {</a>
<a name="ln1079">      dt_iop_clip_and_zoom_mosaic_half_size((uint16_t * const)out, (const uint16_t *)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1080">                                            roi_out.width, roi_in.width, image-&gt;buf_dsc.filters);</a>
<a name="ln1081">    }</a>
<a name="ln1082">    else if(image-&gt;buf_dsc.filters == 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_UINT16)</a>
<a name="ln1083">    {</a>
<a name="ln1084">      dt_iop_clip_and_zoom_mosaic_third_size_xtrans((uint16_t * const)out, (const uint16_t *)buf.buf, &amp;roi_out,</a>
<a name="ln1085">                                                    &amp;roi_in, roi_out.width, roi_in.width, image-&gt;buf_dsc.xtrans);</a>
<a name="ln1086">    }</a>
<a name="ln1087">    else if(image-&gt;buf_dsc.filters == 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_FLOAT)</a>
<a name="ln1088">    {</a>
<a name="ln1089">      dt_iop_clip_and_zoom_mosaic_third_size_xtrans_f(out, (const float *)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1090">                                                      roi_out.width, roi_in.width, image-&gt;buf_dsc.xtrans);</a>
<a name="ln1091">    }</a>
<a name="ln1092">    else</a>
<a name="ln1093">    {</a>
<a name="ln1094">      dt_unreachable_codepath();</a>
<a name="ln1095">    }</a>
<a name="ln1096">  }</a>
<a name="ln1097">  else</a>
<a name="ln1098">  {</a>
<a name="ln1099">    // downsample</a>
<a name="ln1100">    dt_iop_clip_and_zoom(out, (const float *)buf.buf, &amp;roi_out, &amp;roi_in, roi_out.width, roi_in.width);</a>
<a name="ln1101">  }</a>
<a name="ln1102"> </a>
<a name="ln1103">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1104"> </a>
<a name="ln1105">  *width = roi_out.width;</a>
<a name="ln1106">  *height = roi_out.height;</a>
<a name="ln1107">  *iscale = (float)image-&gt;width / (float)roi_out.width;</a>
<a name="ln1108"> </a>
<a name="ln1109">  dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112"> </a>
<a name="ln1113">// dummy functions for `export' to mipmap buffers:</a>
<a name="ln1114">typedef struct _dummy_data_t</a>
<a name="ln1115">{</a>
<a name="ln1116">  dt_imageio_module_data_t head;</a>
<a name="ln1117">  uint8_t *buf;</a>
<a name="ln1118">} _dummy_data_t;</a>
<a name="ln1119"> </a>
<a name="ln1120">static int _levels(dt_imageio_module_data_t *data)</a>
<a name="ln1121">{</a>
<a name="ln1122">  return IMAGEIO_RGB | IMAGEIO_INT8;</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">static int _bpp(dt_imageio_module_data_t *data)</a>
<a name="ln1126">{</a>
<a name="ln1127">  return 8;</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">static int _write_image(dt_imageio_module_data_t *data, const char *filename, const void *in,</a>
<a name="ln1131">                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln1132">                        void *exif, int exif_len, int imgid, int num, int total, dt_dev_pixelpipe_t *pipe)</a>
<a name="ln1133">{</a>
<a name="ln1134">  _dummy_data_t *d = (_dummy_data_t *)data;</a>
<a name="ln1135">  memcpy(d-&gt;buf, in, data-&gt;width * data-&gt;height * sizeof(uint32_t));</a>
<a name="ln1136">  return 0;</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139">static void _init_8(uint8_t *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln1140">                    dt_colorspaces_color_profile_type_t *color_space, const uint32_t imgid,</a>
<a name="ln1141">                    const dt_mipmap_size_t size)</a>
<a name="ln1142">{</a>
<a name="ln1143">  *iscale = 1.0f;</a>
<a name="ln1144">  const uint32_t wd = *width, ht = *height;</a>
<a name="ln1145">  char filename[PATH_MAX] = { 0 };</a>
<a name="ln1146">  gboolean from_cache = TRUE;</a>
<a name="ln1147"> </a>
<a name="ln1148">  /* do not even try to process file if it isn't available */</a>
<a name="ln1149">  dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1150">  if(!*filename || !g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1151">  {</a>
<a name="ln1152">    *width = *height = 0;</a>
<a name="ln1153">    *iscale = 0.0f;</a>
<a name="ln1154">    *color_space = DT_COLORSPACE_NONE;</a>
<a name="ln1155">    return;</a>
<a name="ln1156">  }</a>
<a name="ln1157"> </a>
<a name="ln1158">  const int altered = dt_image_altered(imgid);</a>
<a name="ln1159">  int res = 1;</a>
<a name="ln1160"> </a>
<a name="ln1161">  const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1162">  // the orientation for this camera is not read correctly from exiv2, so we need</a>
<a name="ln1163">  // to go the full path (as the thumbnail will be flipped the wrong way round)</a>
<a name="ln1164">  const int incompatible = !strncmp(cimg-&gt;exif_maker, &quot;Phase One&quot;, 9);</a>
<a name="ln1165">  dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1166"> </a>
<a name="ln1167">  if(!altered &amp;&amp; !dt_conf_get_bool(&quot;never_use_embedded_thumb&quot;) &amp;&amp; !incompatible)</a>
<a name="ln1168">  {</a>
<a name="ln1169">    const dt_image_orientation_t orientation = dt_image_get_orientation(imgid);</a>
<a name="ln1170"> </a>
<a name="ln1171">    // try to load the embedded thumbnail in raw</a>
<a name="ln1172">    from_cache = TRUE;</a>
<a name="ln1173">    memset(filename, 0, sizeof(filename));</a>
<a name="ln1174">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1175"> </a>
<a name="ln1176">    const char *c = filename + strlen(filename);</a>
<a name="ln1177">    while(*c != '.' &amp;&amp; c &gt; filename) c--;</a>
<a name="ln1178">    if(!strcasecmp(c, &quot;.jpg&quot;))</a>
<a name="ln1179">    {</a>
<a name="ln1180">      // try to load jpg</a>
<a name="ln1181">      dt_imageio_jpeg_t jpg;</a>
<a name="ln1182">      if(!dt_imageio_jpeg_read_header(filename, &amp;jpg))</a>
<a name="ln1183">      {</a>
<a name="ln1184">        uint8_t *tmp = (uint8_t *)malloc(sizeof(uint8_t) * jpg.width * jpg.height * 4);</a>
<a name="ln1185">        *color_space = dt_imageio_jpeg_read_color_space(&amp;jpg);</a>
<a name="ln1186">        if(!dt_imageio_jpeg_read(&amp;jpg, tmp))</a>
<a name="ln1187">        {</a>
<a name="ln1188">          // scale to fit</a>
<a name="ln1189">          dt_iop_flip_and_zoom_8(tmp, jpg.width, jpg.height, buf, wd, ht, orientation, width, height);</a>
<a name="ln1190">          res = 0;</a>
<a name="ln1191">        }</a>
<a name="ln1192">        free(tmp);</a>
<a name="ln1193">      }</a>
<a name="ln1194">    }</a>
<a name="ln1195">    else</a>
<a name="ln1196">    {</a>
<a name="ln1197">      uint8_t *tmp = 0;</a>
<a name="ln1198">      int32_t thumb_width, thumb_height;</a>
<a name="ln1199">      res = dt_imageio_large_thumbnail(filename, &amp;tmp, &amp;thumb_width, &amp;thumb_height, color_space);</a>
<a name="ln1200">      if(!res)</a>
<a name="ln1201">      {</a>
<a name="ln1202">        // if the thumbnail is not large enough, we compute one</a>
<a name="ln1203">        const dt_image_t *img2 = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1204">        const int imgwd = img2-&gt;width;</a>
<a name="ln1205">        const int imght = img2-&gt;height;</a>
<a name="ln1206">        dt_image_cache_read_release(darktable.image_cache, img2);</a>
<a name="ln1207">        if(thumb_width &lt; wd &amp;&amp; thumb_height &lt; ht &amp;&amp; thumb_width &lt; imgwd - 4 &amp;&amp; thumb_height &lt; imght - 4)</a>
<a name="ln1208">        {</a>
<a name="ln1209">          res = 1;</a>
<a name="ln1210">        }</a>
<a name="ln1211">        else</a>
<a name="ln1212">        {</a>
<a name="ln1213">          // scale to fit</a>
<a name="ln1214">          dt_iop_flip_and_zoom_8(tmp, thumb_width, thumb_height, buf, wd, ht, orientation, width, height);</a>
<a name="ln1215">        }</a>
<a name="ln1216">        dt_free_align(tmp);</a>
<a name="ln1217">      }</a>
<a name="ln1218">    }</a>
<a name="ln1219">  }</a>
<a name="ln1220"> </a>
<a name="ln1221">  if(res)</a>
<a name="ln1222">  {</a>
<a name="ln1223">    //try to generate mip from larger mip</a>
<a name="ln1224">    for(dt_mipmap_size_t k = size + 1; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln1225">    {</a>
<a name="ln1226">      dt_mipmap_buffer_t tmp;</a>
<a name="ln1227">      dt_mipmap_cache_get(darktable.mipmap_cache, &amp;tmp, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln1228">      if(tmp.buf == NULL)</a>
<a name="ln1229">        continue;</a>
<a name="ln1230">      dt_print(DT_DEBUG_CACHE, &quot;[_init_8] generate mip %d for %s from level %d\n&quot;, size, filename, k);</a>
<a name="ln1231">      *color_space = tmp.color_space;</a>
<a name="ln1232">      // downsample</a>
<a name="ln1233">      dt_iop_flip_and_zoom_8(tmp.buf, tmp.width, tmp.height, buf, wd, ht, ORIENTATION_NONE, width, height);</a>
<a name="ln1234"> </a>
<a name="ln1235">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;tmp);</a>
<a name="ln1236">      res = 0;</a>
<a name="ln1237">      break;</a>
<a name="ln1238">    }</a>
<a name="ln1239">  }</a>
<a name="ln1240"> </a>
<a name="ln1241">  if(res)</a>
<a name="ln1242">  {</a>
<a name="ln1243">    // try the real thing: rawspeed + pixelpipe</a>
<a name="ln1244">    dt_imageio_module_format_t format;</a>
<a name="ln1245">    _dummy_data_t dat;</a>
<a name="ln1246">    format.bpp = _bpp;</a>
<a name="ln1247">    format.write_image = _write_image;</a>
<a name="ln1248">    format.levels = _levels;</a>
<a name="ln1249">    dat.head.max_width = wd;</a>
<a name="ln1250">    dat.head.max_height = ht;</a>
<a name="ln1251">    dat.buf = buf;</a>
<a name="ln1252">    // export with flags: ignore exif (don't load from disk), don't swap byte order, don't do hq processing,</a>
<a name="ln1253">    // no upscaling and signal we want thumbnail export</a>
<a name="ln1254">    res = dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;format, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE,</a>
<a name="ln1255">                                       FALSE, TRUE, NULL, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln1256">                                       1, 1, NULL);</a>
<a name="ln1257">    if(!res)</a>
<a name="ln1258">    {</a>
<a name="ln1259">      // might be smaller, or have a different aspect than what we got as input.</a>
<a name="ln1260">      *width = dat.head.width;</a>
<a name="ln1261">      *height = dat.head.height;</a>
<a name="ln1262">      *iscale = 1.0f;</a>
<a name="ln1263">      *color_space = dt_mipmap_cache_get_colorspace();</a>
<a name="ln1264">    }</a>
<a name="ln1265">  }</a>
<a name="ln1266"> </a>
<a name="ln1267">  // fprintf(stderr, &quot;[mipmap init 8] export image %u finished (sizes %d %d =&gt; %d %d)!\n&quot;, imgid, wd, ht,</a>
<a name="ln1268">  // dat.head.width, dat.head.height);</a>
<a name="ln1269"> </a>
<a name="ln1270">  // any errors?</a>
<a name="ln1271">  if(res)</a>
<a name="ln1272">  {</a>
<a name="ln1273">    // fprintf(stderr, &quot;[mipmap_cache] could not process thumbnail!\n&quot;);</a>
<a name="ln1274">    *width = *height = 0;</a>
<a name="ln1275">    *iscale = 0.0f;</a>
<a name="ln1276">    *color_space = DT_COLORSPACE_NONE;</a>
<a name="ln1277">    return;</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  // TODO: various speed optimizations:</a>
<a name="ln1281">  // TODO: also init all smaller mips!</a>
<a name="ln1282">  // TODO: use mipf, but:</a>
<a name="ln1283">  // TODO: if output is cropped, don't use mipf!</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">dt_colorspaces_color_profile_type_t dt_mipmap_cache_get_colorspace()</a>
<a name="ln1287">{</a>
<a name="ln1288">  if(dt_conf_get_bool(&quot;cache_color_managed&quot;))</a>
<a name="ln1289">    return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1290">  return DT_COLORSPACE_DISPLAY;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">void dt_mipmap_cache_copy_thumbnails(const dt_mipmap_cache_t *cache, const uint32_t dst_imgid, const uint32_t src_imgid)</a>
<a name="ln1294">{</a>
<a name="ln1295">  if(cache-&gt;cachedir[0] &amp;&amp; dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln1296">  {</a>
<a name="ln1297">    for(dt_mipmap_size_t mip = DT_MIPMAP_0; mip &lt; DT_MIPMAP_F; mip++)</a>
<a name="ln1298">    {</a>
<a name="ln1299">      // try and load from disk, if successful set flag</a>
<a name="ln1300">      char srcpath[PATH_MAX] = {0};</a>
<a name="ln1301">      char dstpath[PATH_MAX] = {0};</a>
<a name="ln1302">      snprintf(srcpath, sizeof(srcpath), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, src_imgid);</a>
<a name="ln1303">      snprintf(dstpath, sizeof(dstpath), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, dst_imgid);</a>
<a name="ln1304">      GFile *src = g_file_new_for_path(srcpath);</a>
<a name="ln1305">      GFile *dst = g_file_new_for_path(dstpath);</a>
<a name="ln1306">      GError *gerror = NULL;</a>
<a name="ln1307">      g_file_copy(src, dst, G_FILE_COPY_NONE, NULL, NULL, NULL, &amp;gerror);</a>
<a name="ln1308">      // ignore errors, we tried what we could.</a>
<a name="ln1309">      g_object_unref(dst);</a>
<a name="ln1310">      g_object_unref(src);</a>
<a name="ln1311">      g_clear_error(&amp;gerror);</a>
<a name="ln1312">    }</a>
<a name="ln1313">  }</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1317">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1318">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="722"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (int) mip < DT_MIPMAP_0.</p></div>
<div class="balloon" rel="730"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (int) mip < DT_MIPMAP_0.</p></div>
<div class="balloon" rel="884"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: k >= 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
