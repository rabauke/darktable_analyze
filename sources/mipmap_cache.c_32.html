
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011-2014 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/exif.h&quot;</a>
<a name="ln23">#include &quot;common/grealpath.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/imageio.h&quot;</a>
<a name="ln26">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln27">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln28">#include &quot;control/conf.h&quot;</a>
<a name="ln29">#include &quot;control/jobs.h&quot;</a>
<a name="ln30">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;assert.h&gt;</a>
<a name="ln33">#include &lt;errno.h&gt;</a>
<a name="ln34">#include &lt;fcntl.h&gt;</a>
<a name="ln35">#include &lt;glib.h&gt;</a>
<a name="ln36">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln37">#include &lt;limits.h&gt;</a>
<a name="ln38">#include &lt;stdio.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;string.h&gt;</a>
<a name="ln41">#include &lt;unistd.h&gt;</a>
<a name="ln42">#if defined(__SSE__)</a>
<a name="ln43">#include &lt;xmmintrin.h&gt;</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">#if !defined(_WIN32)</a>
<a name="ln47">#include &lt;sys/statvfs.h&gt;</a>
<a name="ln48">#else</a>
<a name="ln49">//statvfs does not exist in Windows, providing implementation</a>
<a name="ln50">#include &quot;win/statvfs.h&quot;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">#define DT_MIPMAP_CACHE_FILE_MAGIC 0xD71337</a>
<a name="ln54">#define DT_MIPMAP_CACHE_FILE_VERSION 23</a>
<a name="ln55">#define DT_MIPMAP_CACHE_DEFAULT_FILE_NAME &quot;mipmaps&quot;</a>
<a name="ln56"> </a>
<a name="ln57">typedef enum dt_mipmap_buffer_dsc_flags</a>
<a name="ln58">{</a>
<a name="ln59">  DT_MIPMAP_BUFFER_DSC_FLAG_NONE = 0,</a>
<a name="ln60">  DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE = 1 &lt;&lt; 0,</a>
<a name="ln61">  DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE = 1 &lt;&lt; 1</a>
<a name="ln62">} dt_mipmap_buffer_dsc_flags;</a>
<a name="ln63"> </a>
<a name="ln64">// the embedded Exif data to tag thumbnails as sRGB or AdobeRGB</a>
<a name="ln65">static const uint8_t dt_mipmap_cache_exif_data_srgb[] = {</a>
<a name="ln66">  0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69,</a>
<a name="ln67">  0x87, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,</a>
<a name="ln68">  0x01, 0xa0, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</a>
<a name="ln69">};</a>
<a name="ln70">static const uint8_t dt_mipmap_cache_exif_data_adobergb[] = {</a>
<a name="ln71">  0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x69,</a>
<a name="ln72">  0x87, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,</a>
<a name="ln73">  0x01, 0xa0, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</a>
<a name="ln74">};</a>
<a name="ln75">static const int dt_mipmap_cache_exif_data_srgb_length</a>
<a name="ln76">                      = sizeof(dt_mipmap_cache_exif_data_srgb) / sizeof(*dt_mipmap_cache_exif_data_srgb);</a>
<a name="ln77">static const int dt_mipmap_cache_exif_data_adobergb_length</a>
<a name="ln78">                      = sizeof(dt_mipmap_cache_exif_data_adobergb) / sizeof(*dt_mipmap_cache_exif_data_adobergb);</a>
<a name="ln79"> </a>
<a name="ln80">struct dt_mipmap_buffer_dsc</a>
<a name="ln81">{</a>
<a name="ln82">  uint32_t width;</a>
<a name="ln83">  uint32_t height;</a>
<a name="ln84">  float iscale;</a>
<a name="ln85">  size_t size;</a>
<a name="ln86">  dt_mipmap_buffer_dsc_flags flags;</a>
<a name="ln87">  dt_colorspaces_color_profile_type_t color_space;</a>
<a name="ln88"> </a>
<a name="ln89">#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</a>
<a name="ln90">  // do not touch!</a>
<a name="ln91">  // must be the last element.</a>
<a name="ln92">  // must be no less than 16bytes</a>
<a name="ln93">  char redzone[16];</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96">  /* NB: sizeof must be a multiple of 4*sizeof(float) */</a>
<a name="ln97">} __attribute__((packed, aligned(16)));</a>
<a name="ln98"> </a>
<a name="ln99">#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)</a>
<a name="ln100">static const size_t dt_mipmap_buffer_dsc_size __attribute__((unused))</a>
<a name="ln101">= sizeof(struct dt_mipmap_buffer_dsc) - sizeof(((struct dt_mipmap_buffer_dsc *)0)-&gt;redzone);</a>
<a name="ln102">#else</a>
<a name="ln103">static const size_t dt_mipmap_buffer_dsc_size __attribute__((unused)) = sizeof(struct dt_mipmap_buffer_dsc);</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">// last resort mem alloc for dead images. sizeof(dt_mipmap_buffer_dsc) + dead image pixels (8x8)</a>
<a name="ln107">// Must be alignment to 4 * sizeof(float).</a>
<a name="ln108">static float dt_mipmap_cache_static_dead_image[sizeof(struct dt_mipmap_buffer_dsc) / sizeof(float) + 64 * 4]</a>
<a name="ln109">    __attribute__((aligned(16)));</a>
<a name="ln110"> </a>
<a name="ln111">static inline void dead_image_8(dt_mipmap_buffer_t *buf)</a>
<a name="ln112">{</a>
<a name="ln113">  if(!buf-&gt;buf) return;</a>
<a name="ln114">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln115">  dsc-&gt;width = dsc-&gt;height = 8;</a>
<a name="ln116">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln117">  dsc-&gt;color_space = DT_COLORSPACE_DISPLAY;</a>
<a name="ln118">  assert(dsc-&gt;size &gt; 64 * sizeof(uint32_t));</a>
<a name="ln119">  const uint32_t X = 0xffffffffu;</a>
<a name="ln120">  const uint32_t o = 0u;</a>
<a name="ln121">  const uint32_t image[]</a>
<a name="ln122">      = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,</a>
<a name="ln123">          o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln124">  memcpy(buf-&gt;buf, image, sizeof(uint32_t) * 64);</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static inline void dead_image_f(dt_mipmap_buffer_t *buf)</a>
<a name="ln128">{</a>
<a name="ln129">  if(!buf-&gt;buf) return;</a>
<a name="ln130">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln131">  dsc-&gt;width = dsc-&gt;height = 8;</a>
<a name="ln132">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln133">  dsc-&gt;color_space = DT_COLORSPACE_DISPLAY;</a>
<a name="ln134">  assert(dsc-&gt;size &gt; 64 * 4 * sizeof(float));</a>
<a name="ln135"> </a>
<a name="ln136">  if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln137">  {</a>
<a name="ln138">    const float X = 1.0f;</a>
<a name="ln139">    const float o = 0.0f;</a>
<a name="ln140"> </a>
<a name="ln141">    const float image[64 * 4]</a>
<a name="ln142">        = { o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o,</a>
<a name="ln143">            o, o, o, o, o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln144">            o, o, o, o, X, X, X, X, o, o, o, o, X, X, X, X, X, X, X, X, o, o, o, o, X, X, X, X, o, o, o, o,</a>
<a name="ln145">            o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o,</a>
<a name="ln146">            o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln147">            o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o,</a>
<a name="ln148">            o, o, o, o, o, o, o, o, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, X, o, o, o, o, o, o, o, o,</a>
<a name="ln149">            o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln150"> </a>
<a name="ln151">    memcpy(buf-&gt;buf, image, sizeof(float) * 4 * 64);</a>
<a name="ln152">  }</a>
<a name="ln153">#if defined(__SSE__)</a>
<a name="ln154">  else if(darktable.codepath.SSE2)</a>
<a name="ln155">  {</a>
<a name="ln156">    const __m128 X = _mm_set1_ps(1.0f);</a>
<a name="ln157">    const __m128 o = _mm_set1_ps(0.0f);</a>
<a name="ln158">    const __m128 image[]</a>
<a name="ln159">        = { o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, X, o, X, X, o, X, o, o, X, X, X, X, X, X, o,</a>
<a name="ln160">            o, o, X, o, o, X, o, o, o, o, o, o, o, o, o, o, o, o, X, X, X, X, o, o, o, o, o, o, o, o, o, o };</a>
<a name="ln161"> </a>
<a name="ln162">    memcpy(buf-&gt;buf, image, sizeof(__m128) * 64);</a>
<a name="ln163">  }</a>
<a name="ln164">#endif</a>
<a name="ln165">  else</a>
<a name="ln166">    dt_unreachable_codepath();</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">#ifndef NDEBUG</a>
<a name="ln170">static inline int32_t buffer_is_broken(dt_mipmap_buffer_t *buf)</a>
<a name="ln171">{</a>
<a name="ln172">  if(!buf-&gt;buf) return 0;</a>
<a name="ln173">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;buf - 1;</a>
<a name="ln174">  if(buf-&gt;width != dsc-&gt;width) return 1;</a>
<a name="ln175">  if(buf-&gt;height != dsc-&gt;height) return 2;</a>
<a name="ln176">  // somewhat loose bound:</a>
<a name="ln177">  if(buf-&gt;width * buf-&gt;height &gt; dsc-&gt;size) return 3;</a>
<a name="ln178">  return 0;</a>
<a name="ln179">}</a>
<a name="ln180">#endif</a>
<a name="ln181"> </a>
<a name="ln182">static inline uint32_t get_key(const uint32_t imgid, const dt_mipmap_size_t size)</a>
<a name="ln183">{</a>
<a name="ln184">  // imgid can't be &gt;= 2^28 (~250 million images)</a>
<a name="ln185">  return (((uint32_t)size) &lt;&lt; 28) | (imgid - 1);</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static inline uint32_t get_imgid(const uint32_t key)</a>
<a name="ln189">{</a>
<a name="ln190">  return (key &amp; 0xfffffff) + 1;</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">static inline dt_mipmap_size_t get_size(const uint32_t key)</a>
<a name="ln194">{</a>
<a name="ln195">  return (dt_mipmap_size_t)(key &gt;&gt; 28);</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">static int dt_mipmap_cache_get_filename(gchar *mipmapfilename, size_t size)</a>
<a name="ln199">{</a>
<a name="ln200">  int r = -1;</a>
<a name="ln201">  char *abspath = NULL;</a>
<a name="ln202"> </a>
<a name="ln203">  // Directory</a>
<a name="ln204">  char cachedir[PATH_MAX] = { 0 };</a>
<a name="ln205">  dt_loc_get_user_cache_dir(cachedir, sizeof(cachedir));</a>
<a name="ln206"> </a>
<a name="ln207">  // Build the mipmap filename</a>
<a name="ln208">  const gchar *dbfilename = dt_database_get_path(darktable.db);</a>
<a name="ln209">  if(!strcmp(dbfilename, &quot;:memory:&quot;))</a>
<a name="ln210">  {</a>
<a name="ln211">    mipmapfilename[0] = '\0';</a>
<a name="ln212">    r = 0;</a>
<a name="ln213">    goto exit;</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  abspath = g_realpath(dbfilename);</a>
<a name="ln217">  if(!abspath) abspath = g_strdup(dbfilename);</a>
<a name="ln218"> </a>
<a name="ln219">  GChecksum *chk = g_checksum_new(G_CHECKSUM_SHA1);</a>
<a name="ln220">  g_checksum_update(chk, (guchar *)abspath, strlen(abspath));</a>
<a name="ln221">  const gchar *filename = g_checksum_get_string(chk);</a>
<a name="ln222"> </a>
<a name="ln223">  if(!filename || filename[0] == '\0')</a>
<a name="ln224">    snprintf(mipmapfilename, size, &quot;%s/%s&quot;, cachedir, DT_MIPMAP_CACHE_DEFAULT_FILE_NAME);</a>
<a name="ln225">  else</a>
<a name="ln226">    snprintf(mipmapfilename, size, &quot;%s/%s-%s&quot;, cachedir, DT_MIPMAP_CACHE_DEFAULT_FILE_NAME, filename);</a>
<a name="ln227"> </a>
<a name="ln228">  g_checksum_free(chk);</a>
<a name="ln229">  r = 0;</a>
<a name="ln230"> </a>
<a name="ln231">exit:</a>
<a name="ln232">  g_free(abspath);</a>
<a name="ln233"> </a>
<a name="ln234">  return r;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static void _init_f(dt_mipmap_buffer_t *mipmap_buf, float *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln238">                    const uint32_t imgid);</a>
<a name="ln239">static void _init_8(uint8_t *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln240">                    dt_colorspaces_color_profile_type_t *color_space, const uint32_t imgid,</a>
<a name="ln241">                    const dt_mipmap_size_t size);</a>
<a name="ln242"> </a>
<a name="ln243">// callback for the imageio core to allocate memory.</a>
<a name="ln244">// only needed for _F and _FULL buffers, as they change size</a>
<a name="ln245">// with the input image. will allocate img-&gt;width*img-&gt;height*img-&gt;bpp bytes.</a>
<a name="ln246">void *dt_mipmap_cache_alloc(dt_mipmap_buffer_t *buf, const dt_image_t *img)</a>
<a name="ln247">{</a>
<a name="ln248">  assert(buf-&gt;size == DT_MIPMAP_FULL);</a>
<a name="ln249"> </a>
<a name="ln250">  dt_cache_entry_t *entry = buf-&gt;cache_entry;</a>
<a name="ln251">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln252"> </a>
<a name="ln253">  const int wd = img-&gt;width;</a>
<a name="ln254">  const int ht = img-&gt;height;</a>
<a name="ln255"> </a>
<a name="ln256">  const size_t bpp = dt_iop_buffer_dsc_to_bpp(&amp;img-&gt;buf_dsc);</a>
<a name="ln257">  const size_t buffer_size = (size_t)wd * ht * bpp + sizeof(*dsc);</a>
<a name="ln258"> </a>
<a name="ln259">  // buf might have been alloc'ed before,</a>
<a name="ln260">  // so only check size and re-alloc if necessary:</a>
<a name="ln261">  if(!buf-&gt;buf || ((void *)dsc == (void *)dt_mipmap_cache_static_dead_image) || (entry-&gt;data_size &lt; buffer_size))</a>
<a name="ln262">  {</a>
<a name="ln263">    if((void *)dsc != (void *)dt_mipmap_cache_static_dead_image) dt_free_align(entry-&gt;data);</a>
<a name="ln264"> </a>
<a name="ln265">    entry-&gt;data_size = 0;</a>
<a name="ln266"> </a>
<a name="ln267">    entry-&gt;data = dt_alloc_align(64, buffer_size);</a>
<a name="ln268"> </a>
<a name="ln269">    if(!entry-&gt;data)</a>
<a name="ln270">    {</a>
<a name="ln271">      // return fallback: at least alloc size for a dead image:</a>
<a name="ln272">      entry-&gt;data = (void *)dt_mipmap_cache_static_dead_image;</a>
<a name="ln273"> </a>
<a name="ln274">      // allocator holds the pointer. but let imageio client know that allocation failed:</a>
<a name="ln275">      return NULL;</a>
<a name="ln276">    }</a>
<a name="ln277"> </a>
<a name="ln278">    entry-&gt;data_size = buffer_size;</a>
<a name="ln279"> </a>
<a name="ln280">    // set buffer size only if we're making it larger.</a>
<a name="ln281">    dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  dsc-&gt;size = buffer_size;</a>
<a name="ln285"> </a>
<a name="ln286">  dsc-&gt;width = wd;</a>
<a name="ln287">  dsc-&gt;height = ht;</a>
<a name="ln288">  dsc-&gt;iscale = 1.0f;</a>
<a name="ln289">  dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln290">  dsc-&gt;flags = DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln291">  buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln292"> </a>
<a name="ln293">  // fprintf(stderr, &quot;full buffer allocating img %u %d x %d = %u bytes (%p)\n&quot;, img-&gt;id, img-&gt;width,</a>
<a name="ln294">  // img-&gt;height, buffer_size, *buf);</a>
<a name="ln295"> </a>
<a name="ln296">  assert(entry-&gt;data_size);</a>
<a name="ln297">  assert(dsc-&gt;size);</a>
<a name="ln298">  assert(dsc-&gt;size &lt;= entry-&gt;data_size);</a>
<a name="ln299"> </a>
<a name="ln300">  ASAN_POISON_MEMORY_REGION(entry-&gt;data, entry-&gt;data_size);</a>
<a name="ln301">  ASAN_UNPOISON_MEMORY_REGION(dsc + 1, buffer_size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln302"> </a>
<a name="ln303">  // return pointer to start of payload</a>
<a name="ln304">  return dsc + 1;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">// callback for the cache backend to initialize payload pointers</a>
<a name="ln308">void dt_mipmap_cache_allocate_dynamic(void *data, dt_cache_entry_t *entry)</a>
<a name="ln309">{</a>
<a name="ln310">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln311">  // for full image buffers</a>
<a name="ln312">  struct dt_mipmap_buffer_dsc *dsc = entry-&gt;data;</a>
<a name="ln313">  const dt_mipmap_size_t mip = get_size(entry-&gt;key);</a>
<a name="ln314"> </a>
<a name="ln315">  // alloc mere minimum for the header + broken image buffer:</a>
<a name="ln316">  if(!dsc)</a>
<a name="ln317">  {</a>
<a name="ln318">    if(mip == DT_MIPMAP_8)</a>
<a name="ln319">    {</a>
<a name="ln320">      // we first need to get the final output size of our image</a>
<a name="ln321">      // let's create a dummy pipe for that</a>
<a name="ln322">      const uint32_t imgid = get_imgid(entry-&gt;key);</a>
<a name="ln323">      const dt_image_t *img2 = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln324">      dt_image_t imgtmp = *img2;</a>
<a name="ln325">      dt_image_cache_read_release(darktable.image_cache, img2);</a>
<a name="ln326">      dt_develop_t dev;</a>
<a name="ln327">      dt_dev_init(&amp;dev, 0);</a>
<a name="ln328">      dt_dev_load_image(&amp;dev, imgid);</a>
<a name="ln329">      dt_dev_pixelpipe_t pipe;</a>
<a name="ln330">      const int res = dt_dev_pixelpipe_init_dummy(&amp;pipe, imgtmp.width, imgtmp.height);</a>
<a name="ln331">      if(res)</a>
<a name="ln332">      {</a>
<a name="ln333">        // set mem pointer to 0, won't be used.</a>
<a name="ln334">        dt_dev_pixelpipe_set_input(&amp;pipe, &amp;dev, NULL, imgtmp.width, imgtmp.height, 1.0f);</a>
<a name="ln335">        dt_dev_pixelpipe_create_nodes(&amp;pipe, &amp;dev);</a>
<a name="ln336">        dt_dev_pixelpipe_synch_all(&amp;pipe, &amp;dev);</a>
<a name="ln337">        dt_dev_pixelpipe_get_dimensions(&amp;pipe, &amp;dev, pipe.iwidth, pipe.iheight, &amp;pipe.processed_width,</a>
<a name="ln338">                                        &amp;pipe.processed_height);</a>
<a name="ln339">        dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln340">        entry-&gt;data_size = sizeof(struct dt_mipmap_buffer_dsc) + pipe.processed_width * pipe.processed_height * 4;</a>
<a name="ln341">      }</a>
<a name="ln342">      else</a>
<a name="ln343">      {</a>
<a name="ln344">        // for some raison pipeline didn't succeed, let's allocate huge memory</a>
<a name="ln345">        entry-&gt;data_size = cache-&gt;buffer_size[mip];</a>
<a name="ln346">      }</a>
<a name="ln347">      dt_dev_cleanup(&amp;dev);</a>
<a name="ln348">    }</a>
<a name="ln349">    else if(mip &lt;= DT_MIPMAP_F)</a>
<a name="ln350">    {</a>
<a name="ln351">      // these are fixed-size:</a>
<a name="ln352">      entry-&gt;data_size = cache-&gt;buffer_size[mip];</a>
<a name="ln353">    }</a>
<a name="ln354">    else</a>
<a name="ln355">    {</a>
<a name="ln356">      entry-&gt;data_size = sizeof(*dsc) + sizeof(float) * 4 * 64;</a>
<a name="ln357">    }</a>
<a name="ln358"> </a>
<a name="ln359">    entry-&gt;data = dt_alloc_align(64, entry-&gt;data_size);</a>
<a name="ln360"> </a>
<a name="ln361">    // fprintf(stderr, &quot;[mipmap cache] alloc dynamic for key %u %p\n&quot;, key, *buf);</a>
<a name="ln362">    if(!(entry-&gt;data))</a>
<a name="ln363">    {</a>
<a name="ln364">      fprintf(stderr, &quot;[mipmap cache] memory allocation failed!\n&quot;);</a>
<a name="ln365">      exit(1);</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    dsc = entry-&gt;data;</a>
<a name="ln369"> </a>
<a name="ln370">    if(mip &lt;= DT_MIPMAP_F)</a>
<a name="ln371">    {</a>
<a name="ln372">      dsc-&gt;width = cache-&gt;max_width[mip];</a>
<a name="ln373">      dsc-&gt;height = cache-&gt;max_height[mip];</a>
<a name="ln374">      dsc-&gt;iscale = 1.0f;</a>
<a name="ln375">      dsc-&gt;size = entry-&gt;data_size;</a>
<a name="ln376">      dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln377">    }</a>
<a name="ln378">    else</a>
<a name="ln379">    {</a>
<a name="ln380">      dsc-&gt;width = 0;</a>
<a name="ln381">      dsc-&gt;height = 0;</a>
<a name="ln382">      dsc-&gt;iscale = 0.0f;</a>
<a name="ln383">      dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln384">      dsc-&gt;size = entry-&gt;data_size;</a>
<a name="ln385">    }</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  assert(dsc-&gt;size &gt;= sizeof(*dsc));</a>
<a name="ln389"> </a>
<a name="ln390">  int loaded_from_disk = 0;</a>
<a name="ln391">  if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln392">  {</a>
<a name="ln393">    if(cache-&gt;cachedir[0] &amp;&amp; ((dt_conf_get_bool(&quot;cache_disk_backend&quot;) &amp;&amp; mip &lt; DT_MIPMAP_8)</a>
<a name="ln394">                              || (dt_conf_get_bool(&quot;cache_disk_backend_full&quot;) &amp;&amp; mip == DT_MIPMAP_8)))</a>
<a name="ln395">    {</a>
<a name="ln396">      // try and load from disk, if successful set flag</a>
<a name="ln397">      char filename[PATH_MAX] = {0};</a>
<a name="ln398">      snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, get_imgid(entry-&gt;key));</a>
<a name="ln399">      FILE *f = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln400">      if(f)</a>
<a name="ln401">      {</a>
<a name="ln402">        long len = 0;</a>
<a name="ln403">        uint8_t *blob = 0;</a>
<a name="ln404">        fseek(f, 0, SEEK_END);</a>
<a name="ln405">        len = ftell(f);</a>
<a name="ln406">        if(len &lt;= 0) goto read_error; // coverity madness</a>
<a name="ln407">        blob = (uint8_t *)malloc(len);</a>
<a name="ln408">        if(!blob) goto read_error;</a>
<a name="ln409">        fseek(f, 0, SEEK_SET);</a>
<a name="ln410">        int rd = fread(blob, sizeof(uint8_t), len, f);</a>
<a name="ln411">        if(rd != len) goto read_error;</a>
<a name="ln412">        dt_colorspaces_color_profile_type_t color_space;</a>
<a name="ln413">        dt_imageio_jpeg_t jpg;</a>
<a name="ln414">        if(dt_imageio_jpeg_decompress_header(blob, len, &amp;jpg)</a>
<a name="ln415">           || (jpg.width &gt; cache-&gt;max_width[mip] || jpg.height &gt; cache-&gt;max_height[mip])</a>
<a name="ln416">           || ((color_space = dt_imageio_jpeg_read_color_space(&amp;jpg)) == DT_COLORSPACE_NONE) // pointless test to keep it in the if clause</a>
<a name="ln417">           || dt_imageio_jpeg_decompress(&amp;jpg, entry-&gt;data + sizeof(*dsc)))</a>
<a name="ln418">        {</a>
<a name="ln419">          fprintf(stderr, &quot;[mipmap_cache] failed to decompress thumbnail for image %d from `%s'!\n&quot;, get_imgid(entry-&gt;key), filename);</a>
<a name="ln420">          goto read_error;</a>
<a name="ln421">        }</a>
<a name="ln422">        dsc-&gt;width = jpg.width;</a>
<a name="ln423">        dsc-&gt;height = jpg.height;</a>
<a name="ln424">        dsc-&gt;iscale = 1.0f;</a>
<a name="ln425">        dsc-&gt;color_space = color_space;</a>
<a name="ln426">        loaded_from_disk = 1;</a>
<a name="ln427">        if(0)</a>
<a name="ln428">        {</a>
<a name="ln429">read_error:</a>
<a name="ln430">          g_unlink(filename);</a>
<a name="ln431">        }</a>
<a name="ln432">        free(blob);</a>
<a name="ln433">        fclose(f);</a>
<a name="ln434">      }</a>
<a name="ln435">    }</a>
<a name="ln436">  }</a>
<a name="ln437"> </a>
<a name="ln438">  if(!loaded_from_disk)</a>
<a name="ln439">    dsc-&gt;flags = DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln440">  else dsc-&gt;flags = 0;</a>
<a name="ln441"> </a>
<a name="ln442">  // cost is just flat one for the buffer, as the buffers might have different sizes,</a>
<a name="ln443">  // to make sure quota is meaningful.</a>
<a name="ln444">  if(mip &gt;= DT_MIPMAP_F) entry-&gt;cost = 1;</a>
<a name="ln445">  else entry-&gt;cost = cache-&gt;buffer_size[mip];</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">static void dt_mipmap_cache_unlink_ondisk_thumbnail(void *data, uint32_t imgid, dt_mipmap_size_t mip)</a>
<a name="ln449">{</a>
<a name="ln450">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln451"> </a>
<a name="ln452">  // also remove jpg backing (always try to do that, in case user just temporarily switched it off,</a>
<a name="ln453">  // to avoid inconsistencies.</a>
<a name="ln454">  // if(dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln455">  if(cache-&gt;cachedir[0])</a>
<a name="ln456">  {</a>
<a name="ln457">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln458">    snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, imgid);</a>
<a name="ln459">    g_unlink(filename);</a>
<a name="ln460">  }</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">void dt_mipmap_cache_deallocate_dynamic(void *data, dt_cache_entry_t *entry)</a>
<a name="ln464">{</a>
<a name="ln465">  dt_mipmap_cache_t *cache = (dt_mipmap_cache_t *)data;</a>
<a name="ln466">  const dt_mipmap_size_t mip = get_size(entry-&gt;key);</a>
<a name="ln467">  if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln468">  {</a>
<a name="ln469">    struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln470">    // don't write skulls:</a>
<a name="ln471">    if(dsc-&gt;width &gt; 8 &amp;&amp; dsc-&gt;height &gt; 8)</a>
<a name="ln472">    {</a>
<a name="ln473">      if(dsc-&gt;flags &amp; DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE)</a>
<a name="ln474">      {</a>
<a name="ln475">        dt_mipmap_cache_unlink_ondisk_thumbnail(data, get_imgid(entry-&gt;key), mip);</a>
<a name="ln476">      }</a>
<a name="ln477">      else if(cache-&gt;cachedir[0] &amp;&amp; ((dt_conf_get_bool(&quot;cache_disk_backend&quot;) &amp;&amp; mip &lt; DT_MIPMAP_8)</a>
<a name="ln478">                                     || (dt_conf_get_bool(&quot;cache_disk_backend_full&quot;) &amp;&amp; mip == DT_MIPMAP_8)))</a>
<a name="ln479">      {</a>
<a name="ln480">        // serialize to disk</a>
<a name="ln481">        char filename[PATH_MAX] = {0};</a>
<a name="ln482">        snprintf(filename, sizeof(filename), &quot;%s.d/%d&quot;, cache-&gt;cachedir, mip);</a>
<a name="ln483">        int mkd = g_mkdir_with_parents(filename, 0750);</a>
<a name="ln484">        if(!mkd)</a>
<a name="ln485">        {</a>
<a name="ln486">          snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, get_imgid(entry-&gt;key));</a>
<a name="ln487">          // Don't write existing files as both performance and quality (lossy jpg) suffer</a>
<a name="ln488">          FILE *f = NULL;</a>
<a name="ln489">          if (!g_file_test(filename, G_FILE_TEST_EXISTS) &amp;&amp; (f = g_fopen(filename, &quot;wb&quot;)))</a>
<a name="ln490">          {</a>
<a name="ln491">            // first check the disk isn't full</a>
<a name="ln492">            struct statvfs vfsbuf;</a>
<a name="ln493">            if (!statvfs(filename, &amp;vfsbuf))</a>
<a name="ln494">            {</a>
<a name="ln495">              int64_t free_mb = ((vfsbuf.f_frsize * vfsbuf.f_bavail) &gt;&gt; 20);</a>
<a name="ln496">              if (free_mb &lt; 100)</a>
<a name="ln497">              {</a>
<a name="ln498">                fprintf(stderr, &quot;Aborting image write as only %&quot; PRId64 &quot; MB free to write %s\n&quot;, free_mb, filename);</a>
<a name="ln499">                goto write_error;</a>
<a name="ln500">              }</a>
<a name="ln501">            }</a>
<a name="ln502">            else</a>
<a name="ln503">            {</a>
<a name="ln504">              fprintf(stderr, &quot;Aborting image write since couldn't determine free space available to write %s\n&quot;, filename);</a>
<a name="ln505">              goto write_error;</a>
<a name="ln506">            }</a>
<a name="ln507"> </a>
<a name="ln508">            const int cache_quality = dt_conf_get_int(&quot;database_cache_quality&quot;);</a>
<a name="ln509">            const uint8_t *exif = NULL;</a>
<a name="ln510">            int exif_len = 0;</a>
<a name="ln511">            if(dsc-&gt;color_space == DT_COLORSPACE_SRGB)</a>
<a name="ln512">            {</a>
<a name="ln513">              exif = dt_mipmap_cache_exif_data_srgb;</a>
<a name="ln514">              exif_len = dt_mipmap_cache_exif_data_srgb_length;</a>
<a name="ln515">            }</a>
<a name="ln516">            else if(dsc-&gt;color_space == DT_COLORSPACE_ADOBERGB)</a>
<a name="ln517">            {</a>
<a name="ln518">              exif = dt_mipmap_cache_exif_data_adobergb;</a>
<a name="ln519">              exif_len = dt_mipmap_cache_exif_data_adobergb_length;</a>
<a name="ln520">            }</a>
<a name="ln521">            if(dt_imageio_jpeg_write(filename, entry-&gt;data + sizeof(*dsc), dsc-&gt;width, dsc-&gt;height, MIN(100, MAX(10, cache_quality)), exif, exif_len))</a>
<a name="ln522">            {</a>
<a name="ln523">write_error:</a>
<a name="ln524">              g_unlink(filename);</a>
<a name="ln525">            }</a>
<a name="ln526">          }</a>
<a name="ln527">          if(f) fclose(f);</a>
<a name="ln528">        }</a>
<a name="ln529">      }</a>
<a name="ln530">    }</a>
<a name="ln531">  }</a>
<a name="ln532">  dt_free_align(entry-&gt;data);</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">static uint32_t nearest_power_of_two(const uint32_t value)</a>
<a name="ln536">{</a>
<a name="ln537">  uint32_t rc = 1;</a>
<a name="ln538">  while(rc &lt; value) rc &lt;&lt;= 1;</a>
<a name="ln539">  return rc;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">void dt_mipmap_cache_init(dt_mipmap_cache_t *cache)</a>
<a name="ln543">{</a>
<a name="ln544">  dt_mipmap_cache_get_filename(cache-&gt;cachedir, sizeof(cache-&gt;cachedir));</a>
<a name="ln545">  // make sure static memory is initialized</a>
<a name="ln546">  struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)dt_mipmap_cache_static_dead_image;</a>
<a name="ln547">  dead_image_f((dt_mipmap_buffer_t *)(dsc + 1));</a>
<a name="ln548"> </a>
<a name="ln549">  // adjust numbers to be large enough to hold what mem limit suggests.</a>
<a name="ln550">  // we want at least 100MB, and consider 8G just still reasonable.</a>
<a name="ln551">  int64_t cache_memory = dt_conf_get_int64(&quot;cache_memory&quot;);</a>
<a name="ln552">  int worker_threads = dt_conf_get_int(&quot;worker_threads&quot;);</a>
<a name="ln553">  size_t max_mem = CLAMPS(cache_memory, 100u &lt;&lt; 20, ((size_t)8) &lt;&lt; 30);</a>
<a name="ln554">  const uint32_t parallel = CLAMP(worker_threads, 1, 8);</a>
<a name="ln555"> </a>
<a name="ln556">  // Fixed sizes for the thumbnail mip levels, selected for coverage of most screen sizes</a>
<a name="ln557">  int32_t mipsizes[DT_MIPMAP_F][2] = {</a>
<a name="ln558">    { 180, 110 },             // mip0 - ~1/2 size previous one</a>
<a name="ln559">    { 360, 225 },             // mip1 - 1/2 size previous one</a>
<a name="ln560">    { 720, 450 },             // mip2 - 1/2 size previous one</a>
<a name="ln561">    { 1440, 900 },            // mip3 - covers 720p and 1366x768</a>
<a name="ln562">    { 1920, 1200 },           // mip4 - covers 1080p and 1600x1200</a>
<a name="ln563">    { 2560, 1600 },           // mip5 - covers 2560x1440</a>
<a name="ln564">    { 4096, 2560 },           // mip6 - covers 4K and UHD</a>
<a name="ln565">    { 5120, 3200 },           // mip7 - covers 5120x2880 panels</a>
<a name="ln566">    { 999999999, 999999999 }, // mip8 - used for full preview at full size</a>
<a name="ln567">  };</a>
<a name="ln568">  // Set mipf to mip2 size as at most the user will be using an 8K screen and</a>
<a name="ln569">  // have a preview that's ~4x smaller</a>
<a name="ln570">  cache-&gt;max_width[DT_MIPMAP_F] = mipsizes[DT_MIPMAP_2][0];</a>
<a name="ln571">  cache-&gt;max_height[DT_MIPMAP_F] = mipsizes[DT_MIPMAP_2][1];</a>
<a name="ln572">  for(int k = DT_MIPMAP_F-1; k &gt;= 0; k--)</a>
<a name="ln573">  {</a>
<a name="ln574">    cache-&gt;max_width[k]  = mipsizes[k][0];</a>
<a name="ln575">    cache-&gt;max_height[k] = mipsizes[k][1];</a>
<a name="ln576">  }</a>
<a name="ln577">    // header + buffer</a>
<a name="ln578">  for(int k = DT_MIPMAP_F-1; k &gt;= 0; k--)</a>
<a name="ln579">    cache-&gt;buffer_size[k] = sizeof(struct dt_mipmap_buffer_dsc)</a>
<a name="ln580">                                + cache-&gt;max_width[k] * cache-&gt;max_height[k] * 4;</a>
<a name="ln581"> </a>
<a name="ln582">  // clear stats:</a>
<a name="ln583">  cache-&gt;mip_thumbs.stats_requests = 0;</a>
<a name="ln584">  cache-&gt;mip_thumbs.stats_near_match = 0;</a>
<a name="ln585">  cache-&gt;mip_thumbs.stats_misses = 0;</a>
<a name="ln586">  cache-&gt;mip_thumbs.stats_fetches = 0;</a>
<a name="ln587">  cache-&gt;mip_thumbs.stats_standin = 0;</a>
<a name="ln588">  cache-&gt;mip_f.stats_requests = 0;</a>
<a name="ln589">  cache-&gt;mip_f.stats_near_match = 0;</a>
<a name="ln590">  cache-&gt;mip_f.stats_misses = 0;</a>
<a name="ln591">  cache-&gt;mip_f.stats_fetches = 0;</a>
<a name="ln592">  cache-&gt;mip_f.stats_standin = 0;</a>
<a name="ln593">  cache-&gt;mip_full.stats_requests = 0;</a>
<a name="ln594">  cache-&gt;mip_full.stats_near_match = 0;</a>
<a name="ln595">  cache-&gt;mip_full.stats_misses = 0;</a>
<a name="ln596">  cache-&gt;mip_full.stats_fetches = 0;</a>
<a name="ln597">  cache-&gt;mip_full.stats_standin = 0;</a>
<a name="ln598"> </a>
<a name="ln599">  dt_cache_init(&amp;cache-&gt;mip_thumbs.cache, 0, max_mem);</a>
<a name="ln600">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_thumbs.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln601">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_thumbs.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln602"> </a>
<a name="ln603">  const int full_entries</a>
<a name="ln604">      = MAX(2, parallel); // even with one thread you want two buffers. one for dr one for thumbs.</a>
<a name="ln605">  int32_t max_mem_bufs = nearest_power_of_two(full_entries);</a>
<a name="ln606"> </a>
<a name="ln607">  // for this buffer, because it can be very busy during import</a>
<a name="ln608">  dt_cache_init(&amp;cache-&gt;mip_full.cache, 0, max_mem_bufs);</a>
<a name="ln609">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_full.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln610">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_full.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln611">  cache-&gt;buffer_size[DT_MIPMAP_FULL] = 0;</a>
<a name="ln612"> </a>
<a name="ln613">  // same for mipf:</a>
<a name="ln614">  dt_cache_init(&amp;cache-&gt;mip_f.cache, 0, max_mem_bufs);</a>
<a name="ln615">  dt_cache_set_allocate_callback(&amp;cache-&gt;mip_f.cache, dt_mipmap_cache_allocate_dynamic, cache);</a>
<a name="ln616">  dt_cache_set_cleanup_callback(&amp;cache-&gt;mip_f.cache, dt_mipmap_cache_deallocate_dynamic, cache);</a>
<a name="ln617">  cache-&gt;buffer_size[DT_MIPMAP_F] = sizeof(struct dt_mipmap_buffer_dsc)</a>
<a name="ln618">                                        + 4 * sizeof(float) * cache-&gt;max_width[DT_MIPMAP_F]</a>
<a name="ln619">                                          * cache-&gt;max_height[DT_MIPMAP_F];</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">void dt_mipmap_cache_cleanup(dt_mipmap_cache_t *cache)</a>
<a name="ln623">{</a>
<a name="ln624">  dt_cache_cleanup(&amp;cache-&gt;mip_thumbs.cache);</a>
<a name="ln625">  dt_cache_cleanup(&amp;cache-&gt;mip_full.cache);</a>
<a name="ln626">  dt_cache_cleanup(&amp;cache-&gt;mip_f.cache);</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">void dt_mipmap_cache_print(dt_mipmap_cache_t *cache)</a>
<a name="ln630">{</a>
<a name="ln631">  printf(&quot;[mipmap_cache] thumbs fill %.2f/%.2f MB (%.2f%%)\n&quot;,</a>
<a name="ln632">         cache-&gt;mip_thumbs.cache.cost / (1024.0 * 1024.0),</a>
<a name="ln633">         cache-&gt;mip_thumbs.cache.cost_quota / (1024.0 * 1024.0),</a>
<a name="ln634">         100.0f * (float)cache-&gt;mip_thumbs.cache.cost / (float)cache-&gt;mip_thumbs.cache.cost_quota);</a>
<a name="ln635">  printf(&quot;[mipmap_cache] float fill %d/%d slots (%.2f%%)\n&quot;,</a>
<a name="ln636">         (uint32_t)cache-&gt;mip_f.cache.cost, (uint32_t)cache-&gt;mip_f.cache.cost_quota,</a>
<a name="ln637">         100.0f * (float)cache-&gt;mip_f.cache.cost / (float)cache-&gt;mip_f.cache.cost_quota);</a>
<a name="ln638">  printf(&quot;[mipmap_cache] full  fill %d/%d slots (%.2f%%)\n&quot;,</a>
<a name="ln639">         (uint32_t)cache-&gt;mip_full.cache.cost, (uint32_t)cache-&gt;mip_full.cache.cost_quota,</a>
<a name="ln640">         100.0f * (float)cache-&gt;mip_full.cache.cost / (float)cache-&gt;mip_full.cache.cost_quota);</a>
<a name="ln641"> </a>
<a name="ln642">  uint64_t sum = 0;</a>
<a name="ln643">  uint64_t sum_fetches = 0;</a>
<a name="ln644">  uint64_t sum_standins = 0;</a>
<a name="ln645">  sum += cache-&gt;mip_thumbs.stats_requests;</a>
<a name="ln646">  sum_fetches += cache-&gt;mip_thumbs.stats_fetches;</a>
<a name="ln647">  sum_standins += cache-&gt;mip_thumbs.stats_standin;</a>
<a name="ln648">  sum += cache-&gt;mip_f.stats_requests;</a>
<a name="ln649">  sum_fetches += cache-&gt;mip_f.stats_fetches;</a>
<a name="ln650">  sum_standins += cache-&gt;mip_f.stats_standin;</a>
<a name="ln651">  sum += cache-&gt;mip_full.stats_requests;</a>
<a name="ln652">  sum_fetches += cache-&gt;mip_full.stats_fetches;</a>
<a name="ln653">  sum_standins += cache-&gt;mip_full.stats_standin;</a>
<a name="ln654">  printf(&quot;[mipmap_cache] level | near match | miss | stand-in | fetches | total rq\n&quot;);</a>
<a name="ln655">  printf(&quot;[mipmap_cache] thumb | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln656">         100.0 * cache-&gt;mip_thumbs.stats_near_match / (float)cache-&gt;mip_thumbs.stats_requests,</a>
<a name="ln657">         100.0 * cache-&gt;mip_thumbs.stats_misses / (float)cache-&gt;mip_thumbs.stats_requests,</a>
<a name="ln658">         100.0 * cache-&gt;mip_thumbs.stats_standin / (float)sum_standins,</a>
<a name="ln659">         100.0 * cache-&gt;mip_thumbs.stats_fetches / (float)sum_fetches,</a>
<a name="ln660">         100.0 * cache-&gt;mip_thumbs.stats_requests / (float)sum);</a>
<a name="ln661">  printf(&quot;[mipmap_cache] float | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln662">         100.0 * cache-&gt;mip_f.stats_near_match / (float)cache-&gt;mip_f.stats_requests,</a>
<a name="ln663">         100.0 * cache-&gt;mip_f.stats_misses / (float)cache-&gt;mip_f.stats_requests,</a>
<a name="ln664">         100.0 * cache-&gt;mip_f.stats_standin / (float)sum_standins,</a>
<a name="ln665">         100.0 * cache-&gt;mip_f.stats_fetches / (float)sum_fetches,</a>
<a name="ln666">         100.0 * cache-&gt;mip_f.stats_requests / (float)sum);</a>
<a name="ln667">  printf(&quot;[mipmap_cache] full  | %6.2f%% | %6.2f%% | %6.2f%%  | %6.2f%% | %6.2f%%\n&quot;,</a>
<a name="ln668">         100.0 * cache-&gt;mip_full.stats_near_match / (float)cache-&gt;mip_full.stats_requests,</a>
<a name="ln669">         100.0 * cache-&gt;mip_full.stats_misses / (float)cache-&gt;mip_full.stats_requests,</a>
<a name="ln670">         100.0 * cache-&gt;mip_full.stats_standin / (float)sum_standins,</a>
<a name="ln671">         100.0 * cache-&gt;mip_full.stats_fetches / (float)sum_fetches,</a>
<a name="ln672">         100.0 * cache-&gt;mip_full.stats_requests / (float)sum);</a>
<a name="ln673">  printf(&quot;\n\n&quot;);</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">static gboolean _raise_signal_mipmap_updated(gpointer user_data)</a>
<a name="ln677">{</a>
<a name="ln678">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_MIPMAP_UPDATED);</a>
<a name="ln679">  return FALSE; // only call once</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">static dt_mipmap_cache_one_t *_get_cache(dt_mipmap_cache_t *cache, const dt_mipmap_size_t mip)</a>
<a name="ln683">{</a>
<a name="ln684">  switch(mip)</a>
<a name="ln685">  {</a>
<a name="ln686">    case DT_MIPMAP_FULL:</a>
<a name="ln687">      return &amp;cache-&gt;mip_full;</a>
<a name="ln688">    case DT_MIPMAP_F:</a>
<a name="ln689">      return &amp;cache-&gt;mip_f;</a>
<a name="ln690">    default:</a>
<a name="ln691">      return &amp;cache-&gt;mip_thumbs;</a>
<a name="ln692">  }</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">void dt_mipmap_cache_get_with_caller(</a>
<a name="ln696">    dt_mipmap_cache_t *cache,</a>
<a name="ln697">    dt_mipmap_buffer_t *buf,</a>
<a name="ln698">    const uint32_t imgid,</a>
<a name="ln699">    const dt_mipmap_size_t mip,</a>
<a name="ln700">    const dt_mipmap_get_flags_t flags,</a>
<a name="ln701">    const char mode,</a>
<a name="ln702">    const char *file,</a>
<a name="ln703">    int line)</a>
<a name="ln704">{</a>
<a name="ln705">  const uint32_t key = get_key(imgid, mip);</a>
<a name="ln706">  if(flags == DT_MIPMAP_TESTLOCK)</a>
<a name="ln707">  {</a>
<a name="ln708">    // simple case: only get and lock if it's there.</a>
<a name="ln709">    dt_cache_entry_t *entry = dt_cache_testget(&amp;_get_cache(cache, mip)-&gt;cache, key, mode);</a>
<a name="ln710">    buf-&gt;cache_entry = entry;</a>
<a name="ln711">    if(entry)</a>
<a name="ln712">    {</a>
<a name="ln713">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln714">      struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln715">      buf-&gt;width = dsc-&gt;width;</a>
<a name="ln716">      buf-&gt;height = dsc-&gt;height;</a>
<a name="ln717">      buf-&gt;iscale = dsc-&gt;iscale;</a>
<a name="ln718">      buf-&gt;color_space = dsc-&gt;color_space;</a>
<a name="ln719">      buf-&gt;imgid = imgid;</a>
<a name="ln720">      buf-&gt;size = mip;</a>
<a name="ln721"> </a>
<a name="ln722">      // skip to next 8-byte alignment, for sse buffers.</a>
<a name="ln723">      buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln724"> </a>
<a name="ln725">      ASAN_UNPOISON_MEMORY_REGION(buf-&gt;buf, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln726">    }</a>
<a name="ln727">    else</a>
<a name="ln728">    {</a>
<a name="ln729">      // set to NULL if failed.</a>
<a name="ln730">      buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln731">      buf-&gt;iscale = 0.0f;</a>
<a name="ln732">      buf-&gt;imgid = 0;</a>
<a name="ln733">      buf-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln734">      buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln735">      buf-&gt;buf = NULL;</a>
<a name="ln736">    }</a>
<a name="ln737">  }</a>
<a name="ln738">  else if(flags == DT_MIPMAP_PREFETCH)</a>
<a name="ln739">  {</a>
<a name="ln740">    // and opposite: prefetch without locking</a>
<a name="ln741">    if(mip &gt; DT_MIPMAP_FULL || (int)mip &lt; DT_MIPMAP_0)</a>
<a name="ln742">      return; // remove the (int) once we no longer have to support gcc &lt; 4.8 :/</a>
<a name="ln743">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, dt_image_load_job_create(imgid, mip));</a>
<a name="ln744">  }</a>
<a name="ln745">  else if(flags == DT_MIPMAP_PREFETCH_DISK)</a>
<a name="ln746">  {</a>
<a name="ln747">    // only prefetch if the disk cache exists:</a>
<a name="ln748">    if(!cache-&gt;cachedir[0]) return;</a>
<a name="ln749">    if(mip &gt; DT_MIPMAP_FULL || (int)mip &lt; DT_MIPMAP_0)</a>
<a name="ln750">      return; // remove the (int) once we no longer have to support gcc &lt; 4.8 :/</a>
<a name="ln751">    char filename[PATH_MAX] = {0};</a>
<a name="ln752">    snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, key);</a>
<a name="ln753">    // don't attempt to load if disk cache doesn't exist</a>
<a name="ln754">    if(!g_file_test(filename, G_FILE_TEST_EXISTS)) return;</a>
<a name="ln755">    dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, dt_image_load_job_create(imgid, mip));</a>
<a name="ln756">  }</a>
<a name="ln757">  else if(flags == DT_MIPMAP_BLOCKING)</a>
<a name="ln758">  {</a>
<a name="ln759">    // simple case: blocking get</a>
<a name="ln760">    dt_cache_entry_t *entry =  dt_cache_get_with_caller(&amp;_get_cache(cache, mip)-&gt;cache, key, mode, file, line);</a>
<a name="ln761"> </a>
<a name="ln762">    ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln763"> </a>
<a name="ln764">    struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln765">    buf-&gt;cache_entry = entry;</a>
<a name="ln766"> </a>
<a name="ln767">    int mipmap_generated = 0;</a>
<a name="ln768">    if(dsc-&gt;flags &amp; DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE)</a>
<a name="ln769">    {</a>
<a name="ln770">      mipmap_generated = 1;</a>
<a name="ln771"> </a>
<a name="ln772">      __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_fetches), 1);</a>
<a name="ln773">      // fprintf(stderr, &quot;[mipmap cache get] now initializing buffer for img %u mip %d!\n&quot;, imgid, mip);</a>
<a name="ln774">      // we're write locked here, as requested by the alloc callback.</a>
<a name="ln775">      // now fill it with data:</a>
<a name="ln776">      if(mip == DT_MIPMAP_FULL)</a>
<a name="ln777">      {</a>
<a name="ln778">        // load the image:</a>
<a name="ln779">        // make sure we access the r/w lock as shortly as possible!</a>
<a name="ln780">        dt_image_t buffered_image;</a>
<a name="ln781">        const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln782">        buffered_image = *cimg;</a>
<a name="ln783">        // dt_image_t *img = dt_image_cache_write_get(darktable.image_cache, cimg);</a>
<a name="ln784">        // dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln785">        dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln786"> </a>
<a name="ln787">        char filename[PATH_MAX] = { 0 };</a>
<a name="ln788">        gboolean from_cache = TRUE;</a>
<a name="ln789">        dt_image_full_path(buffered_image.id, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln790"> </a>
<a name="ln791">        buf-&gt;imgid = imgid;</a>
<a name="ln792">        buf-&gt;size = mip;</a>
<a name="ln793">        buf-&gt;buf = 0;</a>
<a name="ln794">        buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln795">        buf-&gt;iscale = 0.0f;</a>
<a name="ln796">        buf-&gt;color_space = DT_COLORSPACE_NONE; // TODO: does the full buffer need to know this?</a>
<a name="ln797">        dt_imageio_retval_t ret = dt_imageio_open(&amp;buffered_image, filename, buf); // TODO: color_space?</a>
<a name="ln798">        // might have been reallocated:</a>
<a name="ln799">        ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln800">        dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;cache_entry-&gt;data;</a>
<a name="ln801">        if(ret != DT_IMAGEIO_OK)</a>
<a name="ln802">        {</a>
<a name="ln803">          // fprintf(stderr, &quot;[mipmap read get] error loading image: %d\n&quot;, ret);</a>
<a name="ln804">          //</a>
<a name="ln805">          // we can only return a zero dimension buffer if the buffer has been allocated.</a>
<a name="ln806">          // in case dsc couldn't be allocated and points to the static buffer, it contains</a>
<a name="ln807">          // a dead image already.</a>
<a name="ln808">          if((void *)dsc != (void *)dt_mipmap_cache_static_dead_image)</a>
<a name="ln809">          {</a>
<a name="ln810">            dsc-&gt;width = dsc-&gt;height = 0;</a>
<a name="ln811">            buf-&gt;iscale = 0.0f;</a>
<a name="ln812">            dsc-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln813">          }</a>
<a name="ln814">        }</a>
<a name="ln815">        else</a>
<a name="ln816">        {</a>
<a name="ln817">          // swap back new image data:</a>
<a name="ln818">          dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'w');</a>
<a name="ln819">          *img = buffered_image;</a>
<a name="ln820">          // fprintf(stderr, &quot;[mipmap read get] initializing full buffer img %u with %u %u -&gt; %d %d (%p)\n&quot;,</a>
<a name="ln821">          // imgid, data[0], data[1], img-&gt;width, img-&gt;height, data);</a>
<a name="ln822">          // don't write xmp for this (we only changed db stuff):</a>
<a name="ln823">          dt_image_cache_write_release(darktable.image_cache, img, DT_IMAGE_CACHE_RELAXED);</a>
<a name="ln824">        }</a>
<a name="ln825">      }</a>
<a name="ln826">      else if(mip == DT_MIPMAP_F)</a>
<a name="ln827">      {</a>
<a name="ln828">        ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln829">        _init_f(buf, (float *)(dsc + 1), &amp;dsc-&gt;width, &amp;dsc-&gt;height, &amp;dsc-&gt;iscale, imgid);</a>
<a name="ln830">      }</a>
<a name="ln831">      else</a>
<a name="ln832">      {</a>
<a name="ln833">        // 8-bit thumbs</a>
<a name="ln834">        ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln835">        _init_8((uint8_t *)(dsc + 1), &amp;dsc-&gt;width, &amp;dsc-&gt;height, &amp;dsc-&gt;iscale, &amp;buf-&gt;color_space, imgid, mip);</a>
<a name="ln836">      }</a>
<a name="ln837">      dsc-&gt;color_space = buf-&gt;color_space;</a>
<a name="ln838">      dsc-&gt;flags &amp;= ~DT_MIPMAP_BUFFER_DSC_FLAG_GENERATE;</a>
<a name="ln839">    }</a>
<a name="ln840"> </a>
<a name="ln841">    // image cache is leaving the write lock in place in case the image has been newly allocated.</a>
<a name="ln842">    // this leads to a slight increase in thread contention, so we opt for dropping the write lock</a>
<a name="ln843">    // and acquiring a read lock immediately after. since this opens a small window for other threads</a>
<a name="ln844">    // to get in between, we need to take some care to re-init cache entries and dsc.</a>
<a name="ln845">    // note that concurrencykit has rw locks that can be demoted from w-&gt;r without losing the lock in between.</a>
<a name="ln846">    if(mode == 'r')</a>
<a name="ln847">    {</a>
<a name="ln848">      entry-&gt;_lock_demoting = 1;</a>
<a name="ln849">      // drop the write lock</a>
<a name="ln850">      dt_cache_release(&amp;_get_cache(cache, mip)-&gt;cache, entry);</a>
<a name="ln851">      // get a read lock</a>
<a name="ln852">      buf-&gt;cache_entry = entry = dt_cache_get(&amp;_get_cache(cache, mip)-&gt;cache, key, mode);</a>
<a name="ln853">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln854">      entry-&gt;_lock_demoting = 0;</a>
<a name="ln855">      dsc = (struct dt_mipmap_buffer_dsc *)buf-&gt;cache_entry-&gt;data;</a>
<a name="ln856">    }</a>
<a name="ln857"> </a>
<a name="ln858">#ifdef _DEBUG</a>
<a name="ln859">    const pthread_t writer = dt_pthread_rwlock_get_writer(&amp;(buf-&gt;cache_entry-&gt;lock));</a>
<a name="ln860">    if(mode == 'w')</a>
<a name="ln861">    {</a>
<a name="ln862">      assert(pthread_equal(writer, pthread_self()));</a>
<a name="ln863">    }</a>
<a name="ln864">    else</a>
<a name="ln865">    {</a>
<a name="ln866">      assert(!pthread_equal(writer, pthread_self()));</a>
<a name="ln867">    }</a>
<a name="ln868">#endif</a>
<a name="ln869"> </a>
<a name="ln870">    if(mipmap_generated)</a>
<a name="ln871">    {</a>
<a name="ln872">      /* raise signal that mipmaps has been flushed to cache */</a>
<a name="ln873">      g_idle_add(_raise_signal_mipmap_updated, 0);</a>
<a name="ln874">    }</a>
<a name="ln875"> </a>
<a name="ln876">    buf-&gt;width = dsc-&gt;width;</a>
<a name="ln877">    buf-&gt;height = dsc-&gt;height;</a>
<a name="ln878">    buf-&gt;iscale = dsc-&gt;iscale;</a>
<a name="ln879">    buf-&gt;color_space = dsc-&gt;color_space;</a>
<a name="ln880">    buf-&gt;imgid = imgid;</a>
<a name="ln881">    buf-&gt;size = mip;</a>
<a name="ln882"> </a>
<a name="ln883">    ASAN_UNPOISON_MEMORY_REGION(dsc + 1, dsc-&gt;size - sizeof(struct dt_mipmap_buffer_dsc));</a>
<a name="ln884">    buf-&gt;buf = (uint8_t *)(dsc + 1);</a>
<a name="ln885"> </a>
<a name="ln886">    if(dsc-&gt;width == 0 || dsc-&gt;height == 0)</a>
<a name="ln887">    {</a>
<a name="ln888">      // fprintf(stderr, &quot;[mipmap cache get] got a zero-sized image for img %u mip %d!\n&quot;, imgid, mip);</a>
<a name="ln889">      if(mip &lt; DT_MIPMAP_F)</a>
<a name="ln890">        dead_image_8(buf);</a>
<a name="ln891">      else if(mip == DT_MIPMAP_F)</a>
<a name="ln892">        dead_image_f(buf);</a>
<a name="ln893">      else</a>
<a name="ln894">        buf-&gt;buf = NULL; // full images with NULL buffer have to be handled, indicates `missing image', but still return locked slot</a>
<a name="ln895">    }</a>
<a name="ln896">  }</a>
<a name="ln897">  else if(flags == DT_MIPMAP_BEST_EFFORT)</a>
<a name="ln898">  {</a>
<a name="ln899">    __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_requests), 1);</a>
<a name="ln900">    // best-effort, might also return NULL.</a>
<a name="ln901">    // never decrease mip level for float buffer or full image:</a>
<a name="ln902">    dt_mipmap_size_t min_mip = (mip &gt;= DT_MIPMAP_F) ? mip : DT_MIPMAP_0;</a>
<a name="ln903">    for(int k = mip; k &gt;= min_mip &amp;&amp; k &gt;= 0; k--)</a>
<a name="ln904">    {</a>
<a name="ln905">      // already loaded?</a>
<a name="ln906">      dt_mipmap_cache_get(cache, buf, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln907">      if(buf-&gt;buf &amp;&amp; buf-&gt;width &gt; 0 &amp;&amp; buf-&gt;height &gt; 0)</a>
<a name="ln908">      {</a>
<a name="ln909">        if(mip != k) __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_standin), 1);</a>
<a name="ln910">        return;</a>
<a name="ln911">      }</a>
<a name="ln912">      // didn't succeed the first time? prefetch for later!</a>
<a name="ln913">      if(mip == k)</a>
<a name="ln914">      {</a>
<a name="ln915">        __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_near_match), 1);</a>
<a name="ln916">        dt_mipmap_cache_get(cache, buf, imgid, mip, DT_MIPMAP_PREFETCH, 'r');</a>
<a name="ln917">      }</a>
<a name="ln918">    }</a>
<a name="ln919">    // couldn't find a smaller thumb, try larger ones only now (these will be slightly slower due to cairo rescaling):</a>
<a name="ln920">    dt_mipmap_size_t max_mip = (mip &gt;= DT_MIPMAP_F) ? mip : DT_MIPMAP_F-1;</a>
<a name="ln921">    for(int k = mip+1; k &lt;= max_mip; k++)</a>
<a name="ln922">    {</a>
<a name="ln923">      // already loaded?</a>
<a name="ln924">      dt_mipmap_cache_get(cache, buf, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln925">      if(buf-&gt;buf &amp;&amp; buf-&gt;width &gt; 0 &amp;&amp; buf-&gt;height &gt; 0)</a>
<a name="ln926">      {</a>
<a name="ln927">        __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_standin), 1);</a>
<a name="ln928">        return;</a>
<a name="ln929">      }</a>
<a name="ln930">    }</a>
<a name="ln931">    __sync_fetch_and_add(&amp;(_get_cache(cache, mip)-&gt;stats_misses), 1);</a>
<a name="ln932">    // in case we don't even have a disk cache for our requested thumbnail,</a>
<a name="ln933">    // prefetch at least mip0, in case we have that in the disk caches:</a>
<a name="ln934">    if(cache-&gt;cachedir[0])</a>
<a name="ln935">    {</a>
<a name="ln936">      char filename[PATH_MAX] = {0};</a>
<a name="ln937">      snprintf(filename, sizeof(filename), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, key);</a>
<a name="ln938">      if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln939">        dt_mipmap_cache_get(cache, 0, imgid, DT_MIPMAP_0, DT_MIPMAP_PREFETCH_DISK, 0);</a>
<a name="ln940">    }</a>
<a name="ln941">    // nothing found :(</a>
<a name="ln942">    buf-&gt;buf = NULL;</a>
<a name="ln943">    buf-&gt;imgid = 0;</a>
<a name="ln944">    buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln945">    buf-&gt;width = buf-&gt;height = 0;</a>
<a name="ln946">    buf-&gt;iscale = 0.0f;</a>
<a name="ln947">    buf-&gt;color_space = DT_COLORSPACE_NONE;</a>
<a name="ln948">  }</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">void dt_mipmap_cache_write_get_with_caller(dt_mipmap_cache_t *cache, dt_mipmap_buffer_t *buf, const uint32_t imgid, const int mip, const char *file, int line)</a>
<a name="ln952">{</a>
<a name="ln953">  dt_mipmap_cache_get_with_caller(cache, buf, imgid, mip, DT_MIPMAP_BLOCKING, 'w', file, line);</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">void dt_mipmap_cache_release_with_caller(dt_mipmap_cache_t *cache, dt_mipmap_buffer_t *buf, const char *file,</a>
<a name="ln957">                                         int line)</a>
<a name="ln958">{</a>
<a name="ln959">  if(buf-&gt;size == DT_MIPMAP_NONE) return;</a>
<a name="ln960">  assert(buf-&gt;imgid &gt; 0);</a>
<a name="ln961">  // assert(buf-&gt;size &gt;= DT_MIPMAP_0); // breaks gcc-4.6/4.7 build</a>
<a name="ln962">  assert(buf-&gt;size &lt; DT_MIPMAP_NONE);</a>
<a name="ln963">  assert(buf-&gt;cache_entry);</a>
<a name="ln964">  dt_cache_release_with_caller(&amp;_get_cache(cache, buf-&gt;size)-&gt;cache, buf-&gt;cache_entry, file, line);</a>
<a name="ln965">  buf-&gt;size = DT_MIPMAP_NONE;</a>
<a name="ln966">  buf-&gt;buf = NULL;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">// return the closest mipmap size</a>
<a name="ln971">dt_mipmap_size_t dt_mipmap_cache_get_matching_size(const dt_mipmap_cache_t *cache, const int32_t width,</a>
<a name="ln972">                                                   const int32_t height)</a>
<a name="ln973">{</a>
<a name="ln974">  const double ppd = (darktable.gui != NULL) ? darktable.gui-&gt;ppd : 1.0;</a>
<a name="ln975"> </a>
<a name="ln976">  // find `best' match to width and height.</a>
<a name="ln977">  int32_t error = 0x7fffffff;</a>
<a name="ln978">  dt_mipmap_size_t best = DT_MIPMAP_NONE;</a>
<a name="ln979">  for(int k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln980">  {</a>
<a name="ln981">    // find closest l1 norm:</a>
<a name="ln982">    int32_t new_error = cache-&gt;max_width[k] + cache-&gt;max_height[k] - width * ppd - height * ppd;</a>
<a name="ln983">    // and allow the first one to be larger in pixel size to override the smaller mip</a>
<a name="ln984">    if(abs(new_error) &lt; abs(error) || (error &lt; 0 &amp;&amp; new_error &gt; 0))</a>
<a name="ln985">    {</a>
<a name="ln986">      best = k;</a>
<a name="ln987">      error = new_error;</a>
<a name="ln988">    }</a>
<a name="ln989">  }</a>
<a name="ln990">  return best;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">void dt_mipmap_cache_remove(dt_mipmap_cache_t *cache, const uint32_t imgid)</a>
<a name="ln994">{</a>
<a name="ln995">  // get rid of all ldr thumbnails:</a>
<a name="ln996"> </a>
<a name="ln997">  for(dt_mipmap_size_t k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln998">  {</a>
<a name="ln999">    const uint32_t key = get_key(imgid, k);</a>
<a name="ln1000">    dt_cache_entry_t *entry = dt_cache_testget(&amp;_get_cache(cache, k)-&gt;cache, key, 'w');</a>
<a name="ln1001">    if(entry)</a>
<a name="ln1002">    {</a>
<a name="ln1003">      ASAN_UNPOISON_MEMORY_REGION(entry-&gt;data, dt_mipmap_buffer_dsc_size);</a>
<a name="ln1004">      struct dt_mipmap_buffer_dsc *dsc = (struct dt_mipmap_buffer_dsc *)entry-&gt;data;</a>
<a name="ln1005">      dsc-&gt;flags |= DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE;</a>
<a name="ln1006">      dt_cache_release(&amp;_get_cache(cache, k)-&gt;cache, entry);</a>
<a name="ln1007"> </a>
<a name="ln1008">      // due to DT_MIPMAP_BUFFER_DSC_FLAG_INVALIDATE, removes thumbnail from disc</a>
<a name="ln1009">      dt_cache_remove(&amp;_get_cache(cache, k)-&gt;cache, key);</a>
<a name="ln1010">    }</a>
<a name="ln1011">    else</a>
<a name="ln1012">    {</a>
<a name="ln1013">      // ugly, but avoids alloc'ing thumb if it is not there.</a>
<a name="ln1014">      dt_mipmap_cache_unlink_ondisk_thumbnail((&amp;_get_cache(cache, k)-&gt;cache)-&gt;cleanup_data, imgid, k);</a>
<a name="ln1015">    }</a>
<a name="ln1016">  }</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">void dt_mimap_cache_evict(dt_mipmap_cache_t *cache, const uint32_t imgid)</a>
<a name="ln1020">{</a>
<a name="ln1021">  for(dt_mipmap_size_t k = DT_MIPMAP_0; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln1022">  {</a>
<a name="ln1023">    const uint32_t key = get_key(imgid, k);</a>
<a name="ln1024"> </a>
<a name="ln1025">    // write thumbnail to disc if not existing there</a>
<a name="ln1026">    dt_cache_remove(&amp;_get_cache(cache, k)-&gt;cache, key);</a>
<a name="ln1027">  }</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">static void _init_f(dt_mipmap_buffer_t *mipmap_buf, float *out, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln1031">                    const uint32_t imgid)</a>
<a name="ln1032">{</a>
<a name="ln1033">  const uint32_t wd = *width, ht = *height;</a>
<a name="ln1034"> </a>
<a name="ln1035">  /* do not even try to process file if it isn't available */</a>
<a name="ln1036">  char filename[PATH_MAX] = { 0 };</a>
<a name="ln1037">  gboolean from_cache = TRUE;</a>
<a name="ln1038">  dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1039">  if(!*filename || !g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1040">  {</a>
<a name="ln1041">    *width = *height = 0;</a>
<a name="ln1042">    *iscale = 0.0f;</a>
<a name="ln1043">    return;</a>
<a name="ln1044">  }</a>
<a name="ln1045"> </a>
<a name="ln1046">  dt_mipmap_buffer_t buf;</a>
<a name="ln1047">  dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln1048"> </a>
<a name="ln1049">  // lock image after we have the buffer, we might need to lock the image struct for</a>
<a name="ln1050">  // writing during raw loading, to write to width/height.</a>
<a name="ln1051">  const dt_image_t *image = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1052"> </a>
<a name="ln1053">  dt_iop_roi_t roi_in, roi_out;</a>
<a name="ln1054">  roi_in.x = roi_in.y = 0;</a>
<a name="ln1055">  roi_in.width = image-&gt;width;</a>
<a name="ln1056">  roi_in.height = image-&gt;height;</a>
<a name="ln1057">  roi_in.scale = 1.0f;</a>
<a name="ln1058"> </a>
<a name="ln1059">  roi_out.x = roi_out.y = 0;</a>
<a name="ln1060"> </a>
<a name="ln1061">  // now let's figure out the scaling...</a>
<a name="ln1062"> </a>
<a name="ln1063">  // MIP_F is 4 channels, and we do not demosaic here</a>
<a name="ln1064">  const float coeff = (image-&gt;buf_dsc.filters) ? 2.0f : 1.0f;</a>
<a name="ln1065"> </a>
<a name="ln1066">  roi_out.scale = fminf((coeff * (float)wd) / (float)image-&gt;width, (coeff * (float)ht) / (float)image-&gt;height);</a>
<a name="ln1067">  roi_out.width = roi_out.scale * roi_in.width;</a>
<a name="ln1068">  roi_out.height = roi_out.scale * roi_in.height;</a>
<a name="ln1069"> </a>
<a name="ln1070">  if(!buf.buf)</a>
<a name="ln1071">  {</a>
<a name="ln1072">    dt_control_log(_(&quot;image `%s' is not available!&quot;), image-&gt;filename);</a>
<a name="ln1073">    dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1074">    *width = *height = 0;</a>
<a name="ln1075">    *iscale = 0.0f;</a>
<a name="ln1076">    return;</a>
<a name="ln1077">  }</a>
<a name="ln1078"> </a>
<a name="ln1079">  assert(!buffer_is_broken(&amp;buf));</a>
<a name="ln1080"> </a>
<a name="ln1081">  mipmap_buf-&gt;color_space = DT_COLORSPACE_NONE; // TODO: do we need that information in this buffer?</a>
<a name="ln1082"> </a>
<a name="ln1083">  if(image-&gt;buf_dsc.filters)</a>
<a name="ln1084">  {</a>
<a name="ln1085">    if(image-&gt;buf_dsc.filters != 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_FLOAT)</a>
<a name="ln1086">    {</a>
<a name="ln1087">      dt_iop_clip_and_zoom_mosaic_half_size_f((float *const)out, (const float *const)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1088">                                              roi_out.width, roi_in.width, image-&gt;buf_dsc.filters);</a>
<a name="ln1089">    }</a>
<a name="ln1090">    else if(image-&gt;buf_dsc.filters != 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_UINT16)</a>
<a name="ln1091">    {</a>
<a name="ln1092">      dt_iop_clip_and_zoom_mosaic_half_size((uint16_t * const)out, (const uint16_t *)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1093">                                            roi_out.width, roi_in.width, image-&gt;buf_dsc.filters);</a>
<a name="ln1094">    }</a>
<a name="ln1095">    else if(image-&gt;buf_dsc.filters == 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_UINT16)</a>
<a name="ln1096">    {</a>
<a name="ln1097">      dt_iop_clip_and_zoom_mosaic_third_size_xtrans((uint16_t * const)out, (const uint16_t *)buf.buf, &amp;roi_out,</a>
<a name="ln1098">                                                    &amp;roi_in, roi_out.width, roi_in.width, image-&gt;buf_dsc.xtrans);</a>
<a name="ln1099">    }</a>
<a name="ln1100">    else if(image-&gt;buf_dsc.filters == 9u &amp;&amp; image-&gt;buf_dsc.datatype == TYPE_FLOAT)</a>
<a name="ln1101">    {</a>
<a name="ln1102">      dt_iop_clip_and_zoom_mosaic_third_size_xtrans_f(out, (const float *)buf.buf, &amp;roi_out, &amp;roi_in,</a>
<a name="ln1103">                                                      roi_out.width, roi_in.width, image-&gt;buf_dsc.xtrans);</a>
<a name="ln1104">    }</a>
<a name="ln1105">    else</a>
<a name="ln1106">    {</a>
<a name="ln1107">      dt_unreachable_codepath();</a>
<a name="ln1108">    }</a>
<a name="ln1109">  }</a>
<a name="ln1110">  else</a>
<a name="ln1111">  {</a>
<a name="ln1112">    // downsample</a>
<a name="ln1113">    dt_iop_clip_and_zoom(out, (const float *)buf.buf, &amp;roi_out, &amp;roi_in, roi_out.width, roi_in.width);</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln1117"> </a>
<a name="ln1118">  *width = roi_out.width;</a>
<a name="ln1119">  *height = roi_out.height;</a>
<a name="ln1120">  *iscale = (float)image-&gt;width / (float)roi_out.width;</a>
<a name="ln1121"> </a>
<a name="ln1122">  dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">// dummy functions for `export' to mipmap buffers:</a>
<a name="ln1127">typedef struct _dummy_data_t</a>
<a name="ln1128">{</a>
<a name="ln1129">  dt_imageio_module_data_t head;</a>
<a name="ln1130">  uint8_t *buf;</a>
<a name="ln1131">} _dummy_data_t;</a>
<a name="ln1132"> </a>
<a name="ln1133">static int _levels(dt_imageio_module_data_t *data)</a>
<a name="ln1134">{</a>
<a name="ln1135">  return IMAGEIO_RGB | IMAGEIO_INT8;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">static int _bpp(dt_imageio_module_data_t *data)</a>
<a name="ln1139">{</a>
<a name="ln1140">  return 8;</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">static int _write_image(dt_imageio_module_data_t *data, const char *filename, const void *in,</a>
<a name="ln1144">                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln1145">                        void *exif, int exif_len, int imgid, int num, int total, dt_dev_pixelpipe_t *pipe)</a>
<a name="ln1146">{</a>
<a name="ln1147">  _dummy_data_t *d = (_dummy_data_t *)data;</a>
<a name="ln1148">  memcpy(d-&gt;buf, in, data-&gt;width * data-&gt;height * sizeof(uint32_t));</a>
<a name="ln1149">  return 0;</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">static void _init_8(uint8_t *buf, uint32_t *width, uint32_t *height, float *iscale,</a>
<a name="ln1153">                    dt_colorspaces_color_profile_type_t *color_space, const uint32_t imgid,</a>
<a name="ln1154">                    const dt_mipmap_size_t size)</a>
<a name="ln1155">{</a>
<a name="ln1156">  *iscale = 1.0f;</a>
<a name="ln1157">  const uint32_t wd = *width, ht = *height;</a>
<a name="ln1158">  char filename[PATH_MAX] = { 0 };</a>
<a name="ln1159">  gboolean from_cache = TRUE;</a>
<a name="ln1160"> </a>
<a name="ln1161">  /* do not even try to process file if it isn't available */</a>
<a name="ln1162">  dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1163">  if(!*filename || !g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln1164">  {</a>
<a name="ln1165">    *width = *height = 0;</a>
<a name="ln1166">    *iscale = 0.0f;</a>
<a name="ln1167">    *color_space = DT_COLORSPACE_NONE;</a>
<a name="ln1168">    return;</a>
<a name="ln1169">  }</a>
<a name="ln1170"> </a>
<a name="ln1171">  const int altered = dt_image_altered(imgid);</a>
<a name="ln1172">  int res = 1;</a>
<a name="ln1173"> </a>
<a name="ln1174">  const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1175">  // the orientation for this camera is not read correctly from exiv2, so we need</a>
<a name="ln1176">  // to go the full path (as the thumbnail will be flipped the wrong way round)</a>
<a name="ln1177">  const int incompatible = !strncmp(cimg-&gt;exif_maker, &quot;Phase One&quot;, 9);</a>
<a name="ln1178">  dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1179"> </a>
<a name="ln1180">  if(!altered &amp;&amp; !dt_conf_get_bool(&quot;never_use_embedded_thumb&quot;) &amp;&amp; !incompatible)</a>
<a name="ln1181">  {</a>
<a name="ln1182">    const dt_image_orientation_t orientation = dt_image_get_orientation(imgid);</a>
<a name="ln1183"> </a>
<a name="ln1184">    // try to load the embedded thumbnail in raw</a>
<a name="ln1185">    from_cache = TRUE;</a>
<a name="ln1186">    memset(filename, 0, sizeof(filename));</a>
<a name="ln1187">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln1188"> </a>
<a name="ln1189">    const char *c = filename + strlen(filename);</a>
<a name="ln1190">    while(*c != '.' &amp;&amp; c &gt; filename) c--;</a>
<a name="ln1191">    if(!strcasecmp(c, &quot;.jpg&quot;))</a>
<a name="ln1192">    {</a>
<a name="ln1193">      // try to load jpg</a>
<a name="ln1194">      dt_imageio_jpeg_t jpg;</a>
<a name="ln1195">      if(!dt_imageio_jpeg_read_header(filename, &amp;jpg))</a>
<a name="ln1196">      {</a>
<a name="ln1197">        uint8_t *tmp = (uint8_t *)malloc(sizeof(uint8_t) * jpg.width * jpg.height * 4);</a>
<a name="ln1198">        *color_space = dt_imageio_jpeg_read_color_space(&amp;jpg);</a>
<a name="ln1199">        if(!dt_imageio_jpeg_read(&amp;jpg, tmp))</a>
<a name="ln1200">        {</a>
<a name="ln1201">          // scale to fit</a>
<a name="ln1202">          dt_iop_flip_and_zoom_8(tmp, jpg.width, jpg.height, buf, wd, ht, orientation, width, height);</a>
<a name="ln1203">          res = 0;</a>
<a name="ln1204">        }</a>
<a name="ln1205">        free(tmp);</a>
<a name="ln1206">      }</a>
<a name="ln1207">    }</a>
<a name="ln1208">    else</a>
<a name="ln1209">    {</a>
<a name="ln1210">      uint8_t *tmp = 0;</a>
<a name="ln1211">      int32_t thumb_width, thumb_height;</a>
<a name="ln1212">      res = dt_imageio_large_thumbnail(filename, &amp;tmp, &amp;thumb_width, &amp;thumb_height, color_space);</a>
<a name="ln1213">      if(!res)</a>
<a name="ln1214">      {</a>
<a name="ln1215">        // scale to fit</a>
<a name="ln1216">        dt_iop_flip_and_zoom_8(tmp, thumb_width, thumb_height, buf, wd, ht, orientation, width, height);</a>
<a name="ln1217">        free(tmp);</a>
<a name="ln1218">      }</a>
<a name="ln1219">    }</a>
<a name="ln1220">  }</a>
<a name="ln1221"> </a>
<a name="ln1222">  if(res)</a>
<a name="ln1223">  {</a>
<a name="ln1224">    //try to generate mip from larger mip</a>
<a name="ln1225">    for(dt_mipmap_size_t k = size + 1; k &lt; DT_MIPMAP_F; k++)</a>
<a name="ln1226">    {</a>
<a name="ln1227">      dt_mipmap_buffer_t tmp;</a>
<a name="ln1228">      dt_mipmap_cache_get(darktable.mipmap_cache, &amp;tmp, imgid, k, DT_MIPMAP_TESTLOCK, 'r');</a>
<a name="ln1229">      if(tmp.buf == NULL)</a>
<a name="ln1230">        continue;</a>
<a name="ln1231">      dt_print(DT_DEBUG_CACHE, &quot;[_init_8] generate mip %d for %s from level %d\n&quot;, size, filename, k);</a>
<a name="ln1232">      *color_space = tmp.color_space;</a>
<a name="ln1233">      // downsample</a>
<a name="ln1234">      dt_iop_flip_and_zoom_8(tmp.buf, tmp.width, tmp.height, buf, wd, ht, ORIENTATION_NONE, width, height);</a>
<a name="ln1235"> </a>
<a name="ln1236">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;tmp);</a>
<a name="ln1237">      res = 0;</a>
<a name="ln1238">      break;</a>
<a name="ln1239">    }</a>
<a name="ln1240">  }</a>
<a name="ln1241"> </a>
<a name="ln1242">  if(res)</a>
<a name="ln1243">  {</a>
<a name="ln1244">    // try the real thing: rawspeed + pixelpipe</a>
<a name="ln1245">    dt_imageio_module_format_t format;</a>
<a name="ln1246">    _dummy_data_t dat;</a>
<a name="ln1247">    format.bpp = _bpp;</a>
<a name="ln1248">    format.write_image = _write_image;</a>
<a name="ln1249">    format.levels = _levels;</a>
<a name="ln1250">    dat.head.max_width = wd;</a>
<a name="ln1251">    dat.head.max_height = ht;</a>
<a name="ln1252">    dat.buf = buf;</a>
<a name="ln1253">    // export with flags: ignore exif (don't load from disk), don't swap byte order, don't do hq processing,</a>
<a name="ln1254">    // no upscaling and signal we want thumbnail export</a>
<a name="ln1255">    res = dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;format, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE,</a>
<a name="ln1256">                                       FALSE, TRUE, NULL, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln1257">                                       1, 1);</a>
<a name="ln1258">    if(!res)</a>
<a name="ln1259">    {</a>
<a name="ln1260">      // might be smaller, or have a different aspect than what we got as input.</a>
<a name="ln1261">      *width = dat.head.width;</a>
<a name="ln1262">      *height = dat.head.height;</a>
<a name="ln1263">      *iscale = 1.0f;</a>
<a name="ln1264">      *color_space = dt_mipmap_cache_get_colorspace();</a>
<a name="ln1265">    }</a>
<a name="ln1266">  }</a>
<a name="ln1267"> </a>
<a name="ln1268">  // fprintf(stderr, &quot;[mipmap init 8] export image %u finished (sizes %d %d =&gt; %d %d)!\n&quot;, imgid, wd, ht,</a>
<a name="ln1269">  // dat.head.width, dat.head.height);</a>
<a name="ln1270"> </a>
<a name="ln1271">  // any errors?</a>
<a name="ln1272">  if(res)</a>
<a name="ln1273">  {</a>
<a name="ln1274">    // fprintf(stderr, &quot;[mipmap_cache] could not process thumbnail!\n&quot;);</a>
<a name="ln1275">    *width = *height = 0;</a>
<a name="ln1276">    *iscale = 0.0f;</a>
<a name="ln1277">    *color_space = DT_COLORSPACE_NONE;</a>
<a name="ln1278">    return;</a>
<a name="ln1279">  }</a>
<a name="ln1280"> </a>
<a name="ln1281">  // TODO: various speed optimizations:</a>
<a name="ln1282">  // TODO: also init all smaller mips!</a>
<a name="ln1283">  // TODO: use mipf, but:</a>
<a name="ln1284">  // TODO: if output is cropped, don't use mipf!</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">dt_colorspaces_color_profile_type_t dt_mipmap_cache_get_colorspace()</a>
<a name="ln1288">{</a>
<a name="ln1289">  if(dt_conf_get_bool(&quot;cache_color_managed&quot;))</a>
<a name="ln1290">    return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln1291">  return DT_COLORSPACE_DISPLAY;</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">void dt_mipmap_cache_copy_thumbnails(const dt_mipmap_cache_t *cache, const uint32_t dst_imgid, const uint32_t src_imgid)</a>
<a name="ln1295">{</a>
<a name="ln1296">  if(cache-&gt;cachedir[0] &amp;&amp; dt_conf_get_bool(&quot;cache_disk_backend&quot;))</a>
<a name="ln1297">  {</a>
<a name="ln1298">    for(dt_mipmap_size_t mip = DT_MIPMAP_0; mip &lt; DT_MIPMAP_F; mip++)</a>
<a name="ln1299">    {</a>
<a name="ln1300">      // try and load from disk, if successful set flag</a>
<a name="ln1301">      char srcpath[PATH_MAX] = {0};</a>
<a name="ln1302">      char dstpath[PATH_MAX] = {0};</a>
<a name="ln1303">      snprintf(srcpath, sizeof(srcpath), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, src_imgid);</a>
<a name="ln1304">      snprintf(dstpath, sizeof(dstpath), &quot;%s.d/%d/%d.jpg&quot;, cache-&gt;cachedir, mip, dst_imgid);</a>
<a name="ln1305">      GFile *src = g_file_new_for_path(srcpath);</a>
<a name="ln1306">      GFile *dst = g_file_new_for_path(dstpath);</a>
<a name="ln1307">      GError *gerror = NULL;</a>
<a name="ln1308">      g_file_copy(src, dst, G_FILE_COPY_NONE, NULL, NULL, NULL, &amp;gerror);</a>
<a name="ln1309">      // ignore errors, we tried what we could.</a>
<a name="ln1310">      g_object_unref(dst);</a>
<a name="ln1311">      g_object_unref(src);</a>
<a name="ln1312">      g_clear_error(&amp;gerror);</a>
<a name="ln1313">    }</a>
<a name="ln1314">  }</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1318">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1319">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="741"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (int) mip < DT_MIPMAP_0.</p></div>
<div class="balloon" rel="749"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: (int) mip < DT_MIPMAP_0.</p></div>
<div class="balloon" rel="903"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: k >= 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
