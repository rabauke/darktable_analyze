
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2013 johannes hanika.</a>
<a name="ln4">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln5">    it under the terms of the GNU General Public License as published by</a>
<a name="ln6">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln7">    (at your option) any later version.</a>
<a name="ln8"> </a>
<a name="ln9">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln10">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln11">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln12">    GNU General Public License for more details.</a>
<a name="ln13"> </a>
<a name="ln14">    You should have received a copy of the GNU General Public License</a>
<a name="ln15">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#pragma once</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;common/image_cache.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">typedef struct dt_focus_cluster_t</a>
<a name="ln23">{</a>
<a name="ln24">  int64_t n;</a>
<a name="ln25">  float x, y, x2, y2;</a>
<a name="ln26">  float thrs;</a>
<a name="ln27">} dt_focus_cluster_t;</a>
<a name="ln28"> </a>
<a name="ln29">#define gbuf(BUF, A, B) ((BUF)[4 * (width * ((B)) + ((A))) + ch])</a>
<a name="ln30">#define FOCUS_THRS 10</a>
<a name="ln31">#define CHANNEL 1</a>
<a name="ln32"> </a>
<a name="ln33">static inline uint8_t _to_uint8(int i)</a>
<a name="ln34">{</a>
<a name="ln35">  return (uint8_t)CLAMP(i + 127, 0, 255);</a>
<a name="ln36">}</a>
<a name="ln37">static inline int _from_uint8(uint8_t i)</a>
<a name="ln38">{</a>
<a name="ln39">  return i - 127;</a>
<a name="ln40">}</a>
<a name="ln41">static inline void _dt_focus_cdf22_wtf(uint8_t *buf, const int l, const int width, const int height)</a>
<a name="ln42">{</a>
<a name="ln43">  const int ch = CHANNEL;</a>
<a name="ln44"> </a>
<a name="ln45">  const int step = 1 &lt;&lt; l;</a>
<a name="ln46">  const int st = step / 2;</a>
<a name="ln47"> </a>
<a name="ln48">#ifdef _OPENMP</a>
<a name="ln49">#pragma omp parallel for default(none) shared(buf) schedule(static)</a>
<a name="ln50">#endif</a>
<a name="ln51">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln52">  {</a>
<a name="ln53">    // rows</a>
<a name="ln54">    // predict, get detail</a>
<a name="ln55">    int i = st;</a>
<a name="ln56">    for(; i &lt; width - st; i += step) /*for(ch=0; ch&lt;3; ch++)*/</a>
<a name="ln57">      gbuf(buf, i, j)</a>
<a name="ln58">          = _to_uint8((int)gbuf(buf, i, j) - ((int)gbuf(buf, i - st, j) + (int)gbuf(buf, i + st, j)) / 2);</a>
<a name="ln59">    if(i &lt; width) /*for(ch=0; ch&lt;3; ch++)*/</a>
<a name="ln60">      gbuf(buf, i, j) = _to_uint8(gbuf(buf, i, j) - gbuf(buf, i - st, j));</a>
<a name="ln61">    // update coarse</a>
<a name="ln62">    /*for(ch=0; ch&lt;3; ch++)*/ gbuf(buf, 0, j) += _from_uint8(gbuf(buf, st, j)) / 2;</a>
<a name="ln63">    for(i = step; i &lt; width - st; i += step) /*for(ch=0; ch&lt;3; ch++)*/</a>
<a name="ln64">      gbuf(buf, i, j) += (_from_uint8(gbuf(buf, i - st, j)) + _from_uint8(gbuf(buf, i + st, j))) / 4;</a>
<a name="ln65">    if(i &lt; width) /*for(ch=0; ch&lt;3; ch++)*/</a>
<a name="ln66">      gbuf(buf, i, j) += _from_uint8(gbuf(buf, i - st, j)) / 2;</a>
<a name="ln67">  }</a>
<a name="ln68">#ifdef _OPENMP</a>
<a name="ln69">#pragma omp parallel for default(none) shared(buf) schedule(static)</a>
<a name="ln70">#endif</a>
<a name="ln71">  for(int i = 0; i &lt; width; i++)</a>
<a name="ln72">  {</a>
<a name="ln73">    // cols</a>
<a name="ln74">    int j = st;</a>
<a name="ln75">    // predict, get detail</a>
<a name="ln76">    for(; j &lt; height - st; j += step) /*for(ch=0; ch&lt;3; ch++)*/</a>
<a name="ln77">      gbuf(buf, i, j)</a>
<a name="ln78">          = _to_uint8((int)gbuf(buf, i, j) - ((int)gbuf(buf, i, j - st) + (int)gbuf(buf, i, j + st)) / 2);</a>
<a name="ln79">    if(j &lt; height) /*for(int ch=0; ch&lt;3; ch++)*/</a>
<a name="ln80">      gbuf(buf, i, j) = _to_uint8((int)gbuf(buf, i, j) - (int)gbuf(buf, i, j - st));</a>
<a name="ln81">    // update</a>
<a name="ln82">    /*for(ch=0; ch&lt;3; ch++)*/ gbuf(buf, i, 0) += _from_uint8(gbuf(buf, i, st)) / 2;</a>
<a name="ln83">    for(j = step; j &lt; height - st; j += step) /*for(ch=0; ch&lt;3; ch++)*/</a>
<a name="ln84">      gbuf(buf, i, j) += (_from_uint8(gbuf(buf, i, j - st)) + _from_uint8(gbuf(buf, i, j + st))) / 4;</a>
<a name="ln85">    if(j &lt; height) /*for(int ch=0; ch&lt;3; ch++)*/</a>
<a name="ln86">      gbuf(buf, i, j) += _from_uint8(gbuf(buf, i, j - st)) / 2;</a>
<a name="ln87">  }</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">static void _dt_focus_update(dt_focus_cluster_t *f, int frows, int fcols, int i, int j, int wd, int ht,</a>
<a name="ln91">                             int diff)</a>
<a name="ln92">{</a>
<a name="ln93">  const int32_t thrs = FOCUS_THRS;</a>
<a name="ln94">  if(diff &gt; thrs)</a>
<a name="ln95">  {</a>
<a name="ln96">    int fx = i / (float)wd * fcols;</a>
<a name="ln97">    int fy = j / (float)ht * frows;</a>
<a name="ln98">    int fi = fcols * fy + fx;</a>
<a name="ln99">#ifdef _OPENMP</a>
<a name="ln100">#pragma omp atomic</a>
<a name="ln101">#endif</a>
<a name="ln102">    f[fi].x += i;</a>
<a name="ln103">#ifdef _OPENMP</a>
<a name="ln104">#pragma omp atomic</a>
<a name="ln105">#endif</a>
<a name="ln106">    f[fi].y += j;</a>
<a name="ln107">#ifdef _OPENMP</a>
<a name="ln108">#pragma omp atomic</a>
<a name="ln109">#endif</a>
<a name="ln110">    f[fi].x2 += (float)i * i;</a>
<a name="ln111">#ifdef _OPENMP</a>
<a name="ln112">#pragma omp atomic</a>
<a name="ln113">#endif</a>
<a name="ln114">    f[fi].y2 += (float)j * j;</a>
<a name="ln115">#ifdef _OPENMP</a>
<a name="ln116">#pragma omp atomic</a>
<a name="ln117">#endif</a>
<a name="ln118">    f[fi].n++;</a>
<a name="ln119">#ifdef _OPENMP</a>
<a name="ln120">#pragma omp atomic</a>
<a name="ln121">#endif</a>
<a name="ln122">    f[fi].thrs += diff;</a>
<a name="ln123">  }</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">// read 8-bit buffer and create focus clusters from it</a>
<a name="ln128">static void dt_focus_create_clusters(dt_focus_cluster_t *focus, int frows, int fcols, uint8_t *buffer,</a>
<a name="ln129">                                     int buffer_width, int buffer_height)</a>
<a name="ln130">{</a>
<a name="ln131">  // mark in-focus pixels:</a>
<a name="ln132">  const int wd = buffer_width;</a>
<a name="ln133">  const int ht = buffer_height;</a>
<a name="ln134">  const int fs = frows * fcols;</a>
<a name="ln135">  // two-stage cdf 2/2 wavelet transform, use HH1 and HH2 to detect very sharp and sharp spots:</a>
<a name="ln136">  // pretend we already did the first step (coarse will stay in place, maybe even where the pre-demosaic</a>
<a name="ln137">  // sample was at)</a>
<a name="ln138">  _dt_focus_cdf22_wtf(buffer, 2, wd, ht);</a>
<a name="ln139">  // go through HH1 and detect sharp clusters:</a>
<a name="ln140">  memset(focus, 0, sizeof(dt_focus_cluster_t) * fcols * frows);</a>
<a name="ln141">#ifdef _OPENMP</a>
<a name="ln142">#pragma omp parallel for schedule(static) default(shared)</a>
<a name="ln143">#endif</a>
<a name="ln144">  for(int j = 0; j &lt; ht - 1; j += 4)</a>
<a name="ln145">    for(int i = 0; i &lt; wd - 1; i += 4)</a>
<a name="ln146">    {</a>
<a name="ln147">      _dt_focus_update(focus, frows, fcols, i, j, wd, ht,</a>
<a name="ln148">                       abs(_from_uint8(buffer[4 * ((j + 2) * wd + i) + CHANNEL])));</a>
<a name="ln149">      _dt_focus_update(focus, frows, fcols, i, j, wd, ht,</a>
<a name="ln150">                       abs(_from_uint8(buffer[4 * (j * wd + i + 2) + CHANNEL])));</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">#if 1 // second pass, HH2</a>
<a name="ln154">  int num_clusters = 0;</a>
<a name="ln155">  for(int k = 0; k &lt; fs; k++)</a>
<a name="ln156">    if(focus[k].n * 4 &gt; wd * ht / (float)fs * 0.01f) num_clusters++;</a>
<a name="ln157">  if(num_clusters &lt; 1)</a>
<a name="ln158">  {</a>
<a name="ln159">    memset(focus, 0, sizeof(dt_focus_cluster_t) * fs);</a>
<a name="ln160">    _dt_focus_cdf22_wtf(buffer, 3, wd, ht);</a>
<a name="ln161">#ifdef _OPENMP</a>
<a name="ln162">#pragma omp parallel for schedule(static) default(shared)</a>
<a name="ln163">#endif</a>
<a name="ln164">    for(int j = 0; j &lt; ht - 1; j += 8)</a>
<a name="ln165">    {</a>
<a name="ln166">      for(int i = 0; i &lt; wd - 1; i += 8)</a>
<a name="ln167">      {</a>
<a name="ln168">        _dt_focus_update(focus, frows, fcols, i, j, wd, ht,</a>
<a name="ln169">                         1.5 * abs(_from_uint8(buffer[4 * ((j + 4) * wd + i) + CHANNEL])));</a>
<a name="ln170">        _dt_focus_update(focus, frows, fcols, i, j, wd, ht,</a>
<a name="ln171">                         1.5 * abs(_from_uint8(buffer[4 * (j * wd + i + 4) + CHANNEL])));</a>
<a name="ln172">      }</a>
<a name="ln173">    }</a>
<a name="ln174">    num_clusters = 0;</a>
<a name="ln175">    for(int k = 0; k &lt; fs; k++)</a>
<a name="ln176">    {</a>
<a name="ln177">      if(focus[k].n * 6.0f &gt; wd * ht / (float)fs * 0.01f)</a>
<a name="ln178">      {</a>
<a name="ln179">        focus[k].n *= -1;</a>
<a name="ln180">        num_clusters++;</a>
<a name="ln181">      }</a>
<a name="ln182">    }</a>
<a name="ln183">  }</a>
<a name="ln184">#endif</a>
<a name="ln185">#undef CHANNEL</a>
<a name="ln186"> </a>
<a name="ln187">#if 0 // simple high pass filter, doesn't work on slighty unsharp/high iso images</a>
<a name="ln188">  memset(focus, 0, sizeof(dt_focus_cluster_t)*fs);</a>
<a name="ln189">#ifdef _OPENMP</a>
<a name="ln190">#pragma omp parallel for schedule(static) default(shared)</a>
<a name="ln191">#endif</a>
<a name="ln192">  for(int j=1;j&lt;ht-1;j++)</a>
<a name="ln193">  {</a>
<a name="ln194">    int index = 4*j*wd+4;</a>
<a name="ln195">    for(int i=1;i&lt;wd-1;i++)</a>
<a name="ln196">    {</a>
<a name="ln197">      int32_t diff = 4*buffer[index+1]</a>
<a name="ln198">        - buffer[index-4+1]</a>
<a name="ln199">        - buffer[index+4+1]</a>
<a name="ln200">        - buffer[index-4*wd+1]</a>
<a name="ln201">        - buffer[index+4*wd+1];</a>
<a name="ln202">      _dt_focus_update(focus, frows, fcols, i, j, wd, ht, abs(diff));</a>
<a name="ln203">      index += 4;</a>
<a name="ln204">    }</a>
<a name="ln205">  }</a>
<a name="ln206">#endif</a>
<a name="ln207">  // normalize data in clusters:</a>
<a name="ln208">  for(int k = 0; k &lt; fs; k++)</a>
<a name="ln209">  {</a>
<a name="ln210">    focus[k].thrs /= fabsf((float)focus[k].n);</a>
<a name="ln211">    focus[k].x /= fabsf((float)focus[k].n);</a>
<a name="ln212">    focus[k].x2 /= fabsf((float)focus[k].n);</a>
<a name="ln213">    focus[k].y /= fabsf((float)focus[k].n);</a>
<a name="ln214">    focus[k].y2 /= fabsf((float)focus[k].n);</a>
<a name="ln215">  }</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">static void dt_focus_draw_clusters(cairo_t *cr, int width, int height, int imgid, int buffer_width,</a>
<a name="ln219">                                   int buffer_height, dt_focus_cluster_t *focus, int frows, int fcols)</a>
<a name="ln220">{</a>
<a name="ln221">  const int fs = frows * fcols;</a>
<a name="ln222">  cairo_save(cr);</a>
<a name="ln223">  cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln224"> </a>
<a name="ln225">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln226">  dt_image_t image = *img;</a>
<a name="ln227">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln228"> </a>
<a name="ln229">  // FIXME: get those from rawprepare IOP somehow !!!</a>
<a name="ln230">  int wd = buffer_width + image.crop_x, ht = buffer_height + image.crop_y;</a>
<a name="ln231"> </a>
<a name="ln232">  // array with cluster positions</a>
<a name="ln233">  float *pos = malloc(fs * 6 * sizeof(float));</a>
<a name="ln234">  float *offx = pos + fs * 2, *offy = pos + fs * 4;</a>
<a name="ln235">  for(int k = 0; k &lt; fs; k++)</a>
<a name="ln236">  {</a>
<a name="ln237">    const float stddevx = sqrtf(focus[k].x2 - focus[k].x * focus[k].x);</a>
<a name="ln238">    const float stddevy = sqrtf(focus[k].y2 - focus[k].y * focus[k].y);</a>
<a name="ln239"> </a>
<a name="ln240">    // FIXME: get those from rawprepare IOP somehow !!!</a>
<a name="ln241">    float x = focus[k].x + image.crop_x, y = focus[k].y + image.crop_y;</a>
<a name="ln242"> </a>
<a name="ln243">    pos[2 * k + 0] = x;</a>
<a name="ln244">    pos[2 * k + 1] = y;</a>
<a name="ln245">    offx[2 * k + 0] = x + stddevx;</a>
<a name="ln246">    offx[2 * k + 1] = y;</a>
<a name="ln247">    offy[2 * k + 0] = x;</a>
<a name="ln248">    offy[2 * k + 1] = y + stddevy;</a>
<a name="ln249">  }</a>
<a name="ln250"> </a>
<a name="ln251">  // could use dt_image_altered() here, but it ignores flip module</a>
<a name="ln252">  {</a>
<a name="ln253">    dt_develop_t dev;</a>
<a name="ln254">    dt_dev_init(&amp;dev, 0);</a>
<a name="ln255">    dt_dev_load_image(&amp;dev, imgid);</a>
<a name="ln256">    dt_dev_pixelpipe_t pipe;</a>
<a name="ln257">    int res = dt_dev_pixelpipe_init_dummy(&amp;pipe, wd, ht);</a>
<a name="ln258">    if(res)</a>
<a name="ln259">    {</a>
<a name="ln260">      // set mem pointer to 0, won't be used.</a>
<a name="ln261">      dt_dev_pixelpipe_set_input(&amp;pipe, &amp;dev, NULL, wd, ht, 1.0f);</a>
<a name="ln262">      dt_dev_pixelpipe_create_nodes(&amp;pipe, &amp;dev);</a>
<a name="ln263">      dt_dev_pixelpipe_synch_all(&amp;pipe, &amp;dev);</a>
<a name="ln264">      dt_dev_pixelpipe_get_dimensions(&amp;pipe, &amp;dev, pipe.iwidth, pipe.iheight, &amp;pipe.processed_width,</a>
<a name="ln265">                                      &amp;pipe.processed_height);</a>
<a name="ln266">      dt_dev_distort_transform_plus(&amp;dev, &amp;pipe, 0, 99999, pos, fs * 3);</a>
<a name="ln267">      dt_dev_pixelpipe_cleanup(&amp;pipe);</a>
<a name="ln268">      wd = pipe.processed_width;</a>
<a name="ln269">      ht = pipe.processed_height;</a>
<a name="ln270">    }</a>
<a name="ln271">    dt_dev_cleanup(&amp;dev);</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln275">  const float scale = fminf((width-2*tb) / (float)wd, (height-2*tb) / (float)ht);</a>
<a name="ln276">  cairo_scale(cr, scale, scale);</a>
<a name="ln277"> </a>
<a name="ln278">  cairo_translate(cr, -wd / 2.0f, -ht / 2.0f);</a>
<a name="ln279"> </a>
<a name="ln280">  cairo_rectangle(cr, 0, 0, wd, ht);</a>
<a name="ln281">  cairo_clip(cr);</a>
<a name="ln282"> </a>
<a name="ln283">  double dashes[] = { 3 };</a>
<a name="ln284">  int ndash = sizeof(dashes) / sizeof(dashes[0]);</a>
<a name="ln285">  double offset = 0.0f;</a>
<a name="ln286">  cairo_set_dash(cr, dashes, ndash, offset);</a>
<a name="ln287"> </a>
<a name="ln288">  // draw clustered focus regions</a>
<a name="ln289">  for(int k = 0; k &lt; fs; k++)</a>
<a name="ln290">  {</a>
<a name="ln291">    const float intens = (focus[k].thrs - FOCUS_THRS) / FOCUS_THRS;</a>
<a name="ln292">    const float col = fminf(1.0f, intens);</a>
<a name="ln293">    int draw = 0;</a>
<a name="ln294">    if(focus[k].n * 4.0f &gt; buffer_width * buffer_height / (float)fs * 0.01f)</a>
<a name="ln295">      draw = 1;</a>
<a name="ln296">    else if(-focus[k].n * 6.0f &gt; buffer_width * buffer_height / (float)fs * 0.01f)</a>
<a name="ln297">      draw = 2;</a>
<a name="ln298">    if(draw)</a>
<a name="ln299">    {</a>
<a name="ln300">      for(int i = 0; i &lt; 2; i++)</a>
<a name="ln301">      {</a>
<a name="ln302">        if(i)</a>
<a name="ln303">        {</a>
<a name="ln304">          if(draw == 2)</a>
<a name="ln305">            cairo_set_source_rgb(cr, .1f, .1f, col);</a>
<a name="ln306">          else</a>
<a name="ln307">            cairo_set_source_rgb(cr, col, .1f, .1f);</a>
<a name="ln308">          cairo_set_dash(cr, dashes, ndash, dashes[0]);</a>
<a name="ln309">        }</a>
<a name="ln310">        else</a>
<a name="ln311">        {</a>
<a name="ln312">          cairo_set_source_rgb(cr, .1f, .1f, .1f);</a>
<a name="ln313">          cairo_set_dash(cr, dashes, ndash, 0);</a>
<a name="ln314">        }</a>
<a name="ln315">        cairo_move_to(cr, offx[2 * k + 0], offx[2 * k + 1]);</a>
<a name="ln316">        cairo_curve_to(cr, -pos[2 * k + 0] + offx[2 * k + 0] + offy[2 * k + 0],</a>
<a name="ln317">                       -pos[2 * k + 1] + offx[2 * k + 1] + offy[2 * k + 1],</a>
<a name="ln318">                       -pos[2 * k + 0] + offx[2 * k + 0] + offy[2 * k + 0],</a>
<a name="ln319">                       -pos[2 * k + 1] + offx[2 * k + 1] + offy[2 * k + 1], offy[2 * k + 0], offy[2 * k + 1]);</a>
<a name="ln320">        cairo_curve_to(cr, pos[2 * k + 0] - offx[2 * k + 0] + offy[2 * k + 0],</a>
<a name="ln321">                       pos[2 * k + 1] - offx[2 * k + 1] + offy[2 * k + 1],</a>
<a name="ln322">                       pos[2 * k + 0] - offx[2 * k + 0] + offy[2 * k + 0],</a>
<a name="ln323">                       pos[2 * k + 1] - offx[2 * k + 1] + offy[2 * k + 1],</a>
<a name="ln324">                       2 * pos[2 * k + 0] - offx[2 * k + 0], 2 * pos[2 * k + 1] - offx[2 * k + 1]);</a>
<a name="ln325">        cairo_curve_to(cr, 3 * pos[2 * k + 0] - offx[2 * k + 0] - offy[2 * k + 0],</a>
<a name="ln326">                       3 * pos[2 * k + 1] - offx[2 * k + 1] - offy[2 * k + 1],</a>
<a name="ln327">                       3 * pos[2 * k + 0] - offx[2 * k + 0] - offy[2 * k + 0],</a>
<a name="ln328">                       3 * pos[2 * k + 1] - offx[2 * k + 1] - offy[2 * k + 1],</a>
<a name="ln329">                       2 * pos[2 * k + 0] - offy[2 * k + 0], 2 * pos[2 * k + 1] - offy[2 * k + 1]);</a>
<a name="ln330">        cairo_curve_to(cr, pos[2 * k + 0] + offx[2 * k + 0] - offy[2 * k + 0],</a>
<a name="ln331">                       pos[2 * k + 1] + offx[2 * k + 1] - offy[2 * k + 1],</a>
<a name="ln332">                       pos[2 * k + 0] + offx[2 * k + 0] - offy[2 * k + 0],</a>
<a name="ln333">                       pos[2 * k + 1] + offx[2 * k + 1] - offy[2 * k + 1], offx[2 * k + 0], offx[2 * k + 1]);</a>
<a name="ln334"> </a>
<a name="ln335">        cairo_save(cr);</a>
<a name="ln336">        cairo_scale(cr, 1. / scale, 1. / scale);</a>
<a name="ln337">        cairo_set_line_width(cr, 2.0f);</a>
<a name="ln338">        cairo_stroke(cr);</a>
<a name="ln339">        cairo_restore(cr);</a>
<a name="ln340">      }</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343">  cairo_restore(cr);</a>
<a name="ln344">  free(pos);</a>
<a name="ln345">}</a>
<a name="ln346">#undef CHANNEL</a>
<a name="ln347">#undef gbuf</a>
<a name="ln348">#undef FOCUS_THRS</a>
<a name="ln349"> </a>
<a name="ln350">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln351">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln352">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="234"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'pos' pointer in the 'pos + fs * 2' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 234, 233.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
