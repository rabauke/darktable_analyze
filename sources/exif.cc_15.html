
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   This file is part of darktable,</a>
<a name="ln3">   copyright (c) 2009--2013 johannes hanika.</a>
<a name="ln4">   copyright (c) 2011 henrik andersson.</a>
<a name="ln5">   copyright (c) 2012-2017 tobias ellinghaus.</a>
<a name="ln6"> </a>
<a name="ln7">   darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">   it under the terms of the GNU General Public License as published by</a>
<a name="ln9">   the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">   (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">   darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">   GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">   You should have received a copy of the GNU General Public License</a>
<a name="ln18">   along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#define __STDC_FORMAT_MACROS</a>
<a name="ln22"> </a>
<a name="ln23">extern &quot;C&quot; {</a>
<a name="ln24">#ifdef HAVE_CONFIG_H</a>
<a name="ln25">#include &quot;config.h&quot;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;glib.h&gt;</a>
<a name="ln29">#include &lt;sqlite3.h&gt;</a>
<a name="ln30">#include &lt;sys/stat.h&gt;</a>
<a name="ln31">#include &lt;sys/types.h&gt;</a>
<a name="ln32">#include &lt;time.h&gt;</a>
<a name="ln33">#include &lt;unistd.h&gt;</a>
<a name="ln34">#include &lt;zlib.h&gt;</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;cassert&gt;</a>
<a name="ln38">#include &lt;cmath&gt;</a>
<a name="ln39">#include &lt;fstream&gt;</a>
<a name="ln40">#include &lt;iostream&gt;</a>
<a name="ln41">#include &lt;sstream&gt;</a>
<a name="ln42">#include &lt;string&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;exiv2/exiv2.hpp&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#if defined(_WIN32) &amp;&amp; defined(EXV_UNICODE_PATH)</a>
<a name="ln47">  #define WIDEN(s) pugi::as_wide(s)</a>
<a name="ln48">#else</a>
<a name="ln49">  #define WIDEN(s) (s)</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;pugixml.hpp&gt;</a>
<a name="ln53"> </a>
<a name="ln54">using namespace std;</a>
<a name="ln55"> </a>
<a name="ln56">extern &quot;C&quot; {</a>
<a name="ln57">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln58">#include &quot;common/darktable.h&quot;</a>
<a name="ln59">#include &quot;common/debug.h&quot;</a>
<a name="ln60">#include &quot;common/exif.h&quot;</a>
<a name="ln61">#include &quot;common/image_cache.h&quot;</a>
<a name="ln62">#include &quot;common/imageio.h&quot;</a>
<a name="ln63">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln64">#include &quot;common/metadata.h&quot;</a>
<a name="ln65">#include &quot;common/tags.h&quot;</a>
<a name="ln66">#include &quot;common/iop_order.h&quot;</a>
<a name="ln67">#include &quot;control/conf.h&quot;</a>
<a name="ln68">#include &quot;develop/imageop.h&quot;</a>
<a name="ln69">#include &quot;develop/blend.h&quot;</a>
<a name="ln70">#include &quot;develop/masks.h&quot;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">// exiv2's readMetadata is not thread safe in 0.26. so we lock it. since readMetadata might throw an exception we</a>
<a name="ln74">// wrap it into some c++ magic to make sure we unlock in all cases. well, actually not magic but basic raii.</a>
<a name="ln75">// FIXME: check again once we rely on 0.27</a>
<a name="ln76">class Lock</a>
<a name="ln77">{</a>
<a name="ln78">public:</a>
<a name="ln79">  Lock() { dt_pthread_mutex_lock(&amp;darktable.exiv2_threadsafe); }</a>
<a name="ln80">  ~Lock() { dt_pthread_mutex_unlock(&amp;darktable.exiv2_threadsafe); }</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">#define read_metadata_threadsafe(image)                       \</a>
<a name="ln84">{                                                             \</a>
<a name="ln85">  Lock lock;                                                  \</a>
<a name="ln86">  image-&gt;readMetadata();                                      \</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">static void _exif_import_tags(dt_image_t *img, Exiv2::XmpData::iterator &amp;pos);</a>
<a name="ln90"> </a>
<a name="ln91">// this array should contain all XmpBag and XmpSeq keys used by dt</a>
<a name="ln92">const char *dt_xmp_keys[]</a>
<a name="ln93">    = { &quot;Xmp.dc.subject&quot;, &quot;Xmp.lr.hierarchicalSubject&quot;, &quot;Xmp.darktable.colorlabels&quot;, &quot;Xmp.darktable.history&quot;,</a>
<a name="ln94">        &quot;Xmp.darktable.history_modversion&quot;, &quot;Xmp.darktable.history_enabled&quot;, &quot;Xmp.darktable.history_end&quot;, &quot;Xmp.darktable.iop_order_version&quot;,</a>
<a name="ln95">        &quot;Xmp.darktable.history_operation&quot;, &quot;Xmp.darktable.history_params&quot;, &quot;Xmp.darktable.blendop_params&quot;,</a>
<a name="ln96">        &quot;Xmp.darktable.blendop_version&quot;, &quot;Xmp.darktable.multi_priority&quot;, &quot;Xmp.darktable.multi_name&quot;, &quot;Xmp.darktable.iop_order&quot;,</a>
<a name="ln97">        &quot;Xmp.darktable.xmp_version&quot;, &quot;Xmp.darktable.raw_params&quot;, &quot;Xmp.darktable.auto_presets_applied&quot;,</a>
<a name="ln98">        &quot;Xmp.darktable.mask_id&quot;, &quot;Xmp.darktable.mask_type&quot;, &quot;Xmp.darktable.mask_name&quot;,</a>
<a name="ln99">        &quot;Xmp.darktable.masks_history&quot;, &quot;Xmp.darktable.mask_num&quot;, &quot;Xmp.darktable.mask_points&quot;,</a>
<a name="ln100">        &quot;Xmp.darktable.mask_version&quot;, &quot;Xmp.darktable.mask&quot;, &quot;Xmp.darktable.mask_nb&quot;, &quot;Xmp.darktable.mask_src&quot;,</a>
<a name="ln101">        &quot;Xmp.dc.creator&quot;, &quot;Xmp.dc.publisher&quot;, &quot;Xmp.dc.title&quot;, &quot;Xmp.dc.description&quot;, &quot;Xmp.dc.rights&quot;,</a>
<a name="ln102">        &quot;Xmp.xmpMM.DerivedFrom&quot; };</a>
<a name="ln103"> </a>
<a name="ln104">static const guint dt_xmp_keys_n = G_N_ELEMENTS(dt_xmp_keys); // the number of XmpBag XmpSeq keys that dt uses</a>
<a name="ln105"> </a>
<a name="ln106">// inspired by ufraw_exiv2.cc:</a>
<a name="ln107"> </a>
<a name="ln108">static void dt_strlcpy_to_utf8(char *dest, size_t dest_max, Exiv2::ExifData::const_iterator &amp;pos,</a>
<a name="ln109">                               Exiv2::ExifData &amp;exifData)</a>
<a name="ln110">{</a>
<a name="ln111">  std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln112"> </a>
<a name="ln113">  char *s = g_locale_to_utf8(str.c_str(), str.length(), NULL, NULL, NULL);</a>
<a name="ln114">  if(s != NULL)</a>
<a name="ln115">  {</a>
<a name="ln116">    g_strlcpy(dest, s, dest_max);</a>
<a name="ln117">    g_free(s);</a>
<a name="ln118">  }</a>
<a name="ln119">  else</a>
<a name="ln120">  {</a>
<a name="ln121">    g_strlcpy(dest, str.c_str(), dest_max);</a>
<a name="ln122">  }</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">// function to remove known dt keys and subtrees from xmpdata, so not to append them twice</a>
<a name="ln126">// this should work because dt first reads all known keys</a>
<a name="ln127">static void dt_remove_known_keys(Exiv2::XmpData &amp;xmp)</a>
<a name="ln128">{</a>
<a name="ln129">  xmp.sortByKey();</a>
<a name="ln130">  for(unsigned int i = 0; i &lt; dt_xmp_keys_n; i++)</a>
<a name="ln131">  {</a>
<a name="ln132">    Exiv2::XmpData::iterator pos = xmp.findKey(Exiv2::XmpKey(dt_xmp_keys[i]));</a>
<a name="ln133"> </a>
<a name="ln134">    while(pos != xmp.end())</a>
<a name="ln135">    {</a>
<a name="ln136">      std::string key = pos-&gt;key();</a>
<a name="ln137">      const char *ckey = key.c_str();</a>
<a name="ln138">      size_t len = key.size();</a>
<a name="ln139">      // stop iterating once the key no longer matches what we are trying to delete. this assumes sorted input</a>
<a name="ln140">      if(!(g_str_has_prefix(ckey, dt_xmp_keys[i]) &amp;&amp; (ckey[len] == '[' || ckey[len] == '\0')))</a>
<a name="ln141">        break;</a>
<a name="ln142">      pos = xmp.erase(pos);</a>
<a name="ln143">    }</a>
<a name="ln144">  }</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">static void dt_remove_exif_keys(Exiv2::ExifData &amp;exif, const char *keys[], unsigned int n_keys)</a>
<a name="ln148">{</a>
<a name="ln149">  for(unsigned int i = 0; i &lt; n_keys; i++)</a>
<a name="ln150">  {</a>
<a name="ln151">    try</a>
<a name="ln152">    {</a>
<a name="ln153">      Exiv2::ExifData::iterator pos;</a>
<a name="ln154">      while((pos = exif.findKey(Exiv2::ExifKey(keys[i]))) != exif.end())</a>
<a name="ln155">        exif.erase(pos);</a>
<a name="ln156">    }</a>
<a name="ln157">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln158">    {</a>
<a name="ln159">      // the only exception we may get is &quot;invalid&quot; tag, which is not</a>
<a name="ln160">      // important enough to either stop the function, or even display</a>
<a name="ln161">      // a message (it's probably the tag is not implemented in the</a>
<a name="ln162">      // exiv2 version used)</a>
<a name="ln163">    }</a>
<a name="ln164">  }</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">static void dt_remove_xmp_keys(Exiv2::XmpData &amp;xmp, const char *keys[], unsigned int n_keys)</a>
<a name="ln168">{</a>
<a name="ln169">  for(unsigned int i = 0; i &lt; n_keys; i++)</a>
<a name="ln170">  {</a>
<a name="ln171">    try</a>
<a name="ln172">    {</a>
<a name="ln173">      Exiv2::XmpData::iterator pos;</a>
<a name="ln174">      while((pos = xmp.findKey(Exiv2::XmpKey(keys[i]))) != xmp.end())</a>
<a name="ln175">        xmp.erase(pos);</a>
<a name="ln176">    }</a>
<a name="ln177">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln178">    {</a>
<a name="ln179">      // the only exception we may get is &quot;invalid&quot; tag, which is not</a>
<a name="ln180">      // important enough to either stop the function, or even display</a>
<a name="ln181">      // a message (it's probably the tag is not implemented in the</a>
<a name="ln182">      // exiv2 version used)</a>
<a name="ln183">    }</a>
<a name="ln184">  }</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">static bool dt_exif_read_xmp_tag(Exiv2::XmpData &amp;xmpData, Exiv2::XmpData::iterator *pos, string key)</a>
<a name="ln188">{</a>
<a name="ln189">  try</a>
<a name="ln190">  {</a>
<a name="ln191">    return (*pos = xmpData.findKey(Exiv2::XmpKey(key))) != xmpData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln192">  }</a>
<a name="ln193">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln194">  {</a>
<a name="ln195">    std::string s(e.what());</a>
<a name="ln196">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln197">    return false;</a>
<a name="ln198">  }</a>
<a name="ln199">}</a>
<a name="ln200">#define FIND_XMP_TAG(key) dt_exif_read_xmp_tag(xmpData, &amp;pos, key)</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">// FIXME: according to http://www.exiv2.org/doc/classExiv2_1_1Metadatum.html#63c2b87249ba96679c29e01218169124</a>
<a name="ln204">// there is no need to pass xmpData</a>
<a name="ln205">// version = -1 -&gt; version ignored</a>
<a name="ln206">static bool dt_exif_read_xmp_data(dt_image_t *img, Exiv2::XmpData &amp;xmpData, int version,</a>
<a name="ln207">                                  bool use_default_rating)</a>
<a name="ln208">{</a>
<a name="ln209">  try</a>
<a name="ln210">  {</a>
<a name="ln211">    Exiv2::XmpData::iterator pos;</a>
<a name="ln212"> </a>
<a name="ln213">    // older darktable version did not write this data correctly:</a>
<a name="ln214">    // the reasoning behind strdup'ing all the strings before passing it to sqlite3 is, that</a>
<a name="ln215">    // they are somehow corrupt after the call to sqlite3_prepare_v2() -- don't ask me</a>
<a name="ln216">    // why for they don't get passed to that function.</a>
<a name="ln217">    if(version == -1 || version &gt; 0)</a>
<a name="ln218">    {</a>
<a name="ln219">      if(FIND_XMP_TAG(&quot;Xmp.dc.rights&quot;))</a>
<a name="ln220">      {</a>
<a name="ln221">        // rights</a>
<a name="ln222">        char *rights = strdup(pos-&gt;toString().c_str());</a>
<a name="ln223">        char *adr = rights;</a>
<a name="ln224">        if(strncmp(rights, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln225">        {</a>
<a name="ln226">          rights = strchr(rights, ' ');</a>
<a name="ln227">          if(rights != NULL) rights++;</a>
<a name="ln228">        }</a>
<a name="ln229">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, rights);</a>
<a name="ln230">        free(adr);</a>
<a name="ln231">      }</a>
<a name="ln232">      if(FIND_XMP_TAG(&quot;Xmp.dc.description&quot;))</a>
<a name="ln233">      {</a>
<a name="ln234">        // description</a>
<a name="ln235">        char *description = strdup(pos-&gt;toString().c_str());</a>
<a name="ln236">        char *adr = description;</a>
<a name="ln237">        if(strncmp(description, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln238">        {</a>
<a name="ln239">          description = strchr(description, ' ');</a>
<a name="ln240">          if(description != NULL) description++;</a>
<a name="ln241">        }</a>
<a name="ln242">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, description);</a>
<a name="ln243">        free(adr);</a>
<a name="ln244">      }</a>
<a name="ln245">      if(FIND_XMP_TAG(&quot;Xmp.dc.title&quot;))</a>
<a name="ln246">      {</a>
<a name="ln247">        // title</a>
<a name="ln248">        char *title = strdup(pos-&gt;toString().c_str());</a>
<a name="ln249">        char *adr = title;</a>
<a name="ln250">        if(strncmp(title, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln251">        {</a>
<a name="ln252">          title = strchr(title, ' ');</a>
<a name="ln253">          if(title != NULL) title++;</a>
<a name="ln254">        }</a>
<a name="ln255">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.title&quot;, title);</a>
<a name="ln256">        free(adr);</a>
<a name="ln257">      }</a>
<a name="ln258">      if(FIND_XMP_TAG(&quot;Xmp.dc.creator&quot;))</a>
<a name="ln259">      {</a>
<a name="ln260">        // creator</a>
<a name="ln261">        char *creator = strdup(pos-&gt;toString().c_str());</a>
<a name="ln262">        char *adr = creator;</a>
<a name="ln263">        if(strncmp(creator, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln264">        {</a>
<a name="ln265">          creator = strchr(creator, ' ');</a>
<a name="ln266">          if(creator != NULL) creator++;</a>
<a name="ln267">        }</a>
<a name="ln268">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, creator);</a>
<a name="ln269">        free(adr);</a>
<a name="ln270">      }</a>
<a name="ln271">      if(FIND_XMP_TAG(&quot;Xmp.dc.publisher&quot;))</a>
<a name="ln272">      {</a>
<a name="ln273">        // publisher</a>
<a name="ln274">        char *publisher = strdup(pos-&gt;toString().c_str());</a>
<a name="ln275">        char *adr = publisher;</a>
<a name="ln276">        if(strncmp(publisher, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln277">        {</a>
<a name="ln278">          publisher = strchr(publisher, ' ');</a>
<a name="ln279">          if(publisher != NULL) publisher++;</a>
<a name="ln280">        }</a>
<a name="ln281">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.publisher&quot;, publisher);</a>
<a name="ln282">        free(adr);</a>
<a name="ln283">      }</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">    if(FIND_XMP_TAG(&quot;Xmp.xmp.Rating&quot;))</a>
<a name="ln287">    {</a>
<a name="ln288">      int stars = pos-&gt;toLong();</a>
<a name="ln289">      if(use_default_rating &amp;&amp; stars == 0) stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln290"> </a>
<a name="ln291">      stars = (stars == -1) ? 6 : stars;</a>
<a name="ln292">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">    if(FIND_XMP_TAG(&quot;Xmp.xmp.Label&quot;))</a>
<a name="ln296">    {</a>
<a name="ln297">      std::string label = pos-&gt;toString();</a>
<a name="ln298">      if(label == &quot;Red&quot;) // Is it really called like that in XMP files?</a>
<a name="ln299">        dt_colorlabels_set_label(img-&gt;id, 0);</a>
<a name="ln300">      else if(label == &quot;Yellow&quot;) // Is it really called like that in XMP files?</a>
<a name="ln301">        dt_colorlabels_set_label(img-&gt;id, 1);</a>
<a name="ln302">      else if(label == &quot;Green&quot;)</a>
<a name="ln303">        dt_colorlabels_set_label(img-&gt;id, 2);</a>
<a name="ln304">      else if(label == &quot;Blue&quot;) // Is it really called like that in XMP files?</a>
<a name="ln305">        dt_colorlabels_set_label(img-&gt;id, 3);</a>
<a name="ln306">      else if(label == &quot;Purple&quot;) // Is it really called like that in XMP files?</a>
<a name="ln307">        dt_colorlabels_set_label(img-&gt;id, 4);</a>
<a name="ln308">    }</a>
<a name="ln309">    if(FIND_XMP_TAG(&quot;Xmp.darktable.colorlabels&quot;))</a>
<a name="ln310">    {</a>
<a name="ln311">      // TODO: store these in dc:subject or xmp:Label?</a>
<a name="ln312">      // color labels</a>
<a name="ln313">      const int cnt = pos-&gt;count();</a>
<a name="ln314">      dt_colorlabels_remove_labels(img-&gt;id);</a>
<a name="ln315">      for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln316">      {</a>
<a name="ln317">        dt_colorlabels_set_label(img-&gt;id, pos-&gt;toLong(i));</a>
<a name="ln318">      }</a>
<a name="ln319">    }</a>
<a name="ln320"> </a>
<a name="ln321">    if(FIND_XMP_TAG(&quot;Xmp.lr.hierarchicalSubject&quot;))</a>
<a name="ln322">      _exif_import_tags(img, pos);</a>
<a name="ln323">    else if(FIND_XMP_TAG(&quot;Xmp.dc.subject&quot;))</a>
<a name="ln324">      _exif_import_tags(img, pos);</a>
<a name="ln325"> </a>
<a name="ln326">    /* read gps location */</a>
<a name="ln327">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSLatitude&quot;))</a>
<a name="ln328">    {</a>
<a name="ln329">      img-&gt;geoloc.latitude = dt_util_gps_string_to_number(pos-&gt;toString().c_str());</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSLongitude&quot;))</a>
<a name="ln333">    {</a>
<a name="ln334">      img-&gt;geoloc.longitude = dt_util_gps_string_to_number(pos-&gt;toString().c_str());</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSAltitude&quot;))</a>
<a name="ln338">    {</a>
<a name="ln339">      Exiv2::XmpData::const_iterator ref = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.exif.GPSAltitudeRef&quot;));</a>
<a name="ln340">      if(ref != xmpData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln341">      {</a>
<a name="ln342">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln343">        const char *sign = sign_str.c_str();</a>
<a name="ln344">        double elevation = 0.0;</a>
<a name="ln345">        if(dt_util_gps_elevation_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second, sign[0], &amp;elevation))</a>
<a name="ln346">          img-&gt;geoloc.elevation = elevation;</a>
<a name="ln347">      }</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">    /* read lens type from Xmp.exifEX.LensModel */</a>
<a name="ln351">    if(FIND_XMP_TAG(&quot;Xmp.exifEX.LensModel&quot;))</a>
<a name="ln352">    {</a>
<a name="ln353">      // lens model</a>
<a name="ln354">      char *lens = strdup(pos-&gt;toString().c_str());</a>
<a name="ln355">      char *adr =  lens;</a>
<a name="ln356">      if(strncmp(lens, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln357">      {</a>
<a name="ln358">        lens = strchr(lens, ' ');</a>
<a name="ln359">        if(lens != NULL) lens++;</a>
<a name="ln360">      }</a>
<a name="ln361">      // no need to do any Unicode&lt;-&gt;locale conversion, the field is specified as ASCII</a>
<a name="ln362">      g_strlcpy(img-&gt;exif_lens, lens, sizeof(img-&gt;exif_lens));</a>
<a name="ln363">      free(adr);</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    /* read timestamp from Xmp.exif.DateTimeOriginal */</a>
<a name="ln367">    if(FIND_XMP_TAG(&quot;Xmp.exif.DateTimeOriginal&quot;))</a>
<a name="ln368">    {</a>
<a name="ln369">      char *datetime = strdup(pos-&gt;toString().c_str());</a>
<a name="ln370"> </a>
<a name="ln371">      /*</a>
<a name="ln372">       * exiftool (but apparently not evix2) convert</a>
<a name="ln373">       * e.g. &quot;2017:10:23 12:34:56&quot; to &quot;2017-10-23T12:34:54&quot; (ISO)</a>
<a name="ln374">       * revert this to the format expected by exif and darktable</a>
<a name="ln375">       */</a>
<a name="ln376"> </a>
<a name="ln377">      // replace 'T' by ' ' (space)</a>
<a name="ln378">      char *c ;</a>
<a name="ln379">      while ( ( c = strchr(datetime,'T') ) != NULL )</a>
<a name="ln380">      {</a>
<a name="ln381">	*c = ' ';</a>
<a name="ln382">      }</a>
<a name="ln383">      // replace '-' by ':'</a>
<a name="ln384">      while ( ( c = strchr(datetime,'-')) != NULL ) {</a>
<a name="ln385">	*c = ':';</a>
<a name="ln386">      }</a>
<a name="ln387"> </a>
<a name="ln388">      g_strlcpy(img-&gt;exif_datetime_taken, datetime, sizeof(img-&gt;exif_datetime_taken));</a>
<a name="ln389">      free(datetime);</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">    return true;</a>
<a name="ln393">  }</a>
<a name="ln394">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln395">  {</a>
<a name="ln396">    std::string s(e.what());</a>
<a name="ln397">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln398">    return false;</a>
<a name="ln399">  }</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">static bool dt_exif_read_iptc_tag(Exiv2::IptcData &amp;iptcData, Exiv2::IptcData::const_iterator *pos, string key)</a>
<a name="ln403">{</a>
<a name="ln404">  try</a>
<a name="ln405">  {</a>
<a name="ln406">    return (*pos = iptcData.findKey(Exiv2::IptcKey(key))) != iptcData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln407">  }</a>
<a name="ln408">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln409">  {</a>
<a name="ln410">    std::string s(e.what());</a>
<a name="ln411">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln412">    return false;</a>
<a name="ln413">  }</a>
<a name="ln414">}</a>
<a name="ln415">#define FIND_IPTC_TAG(key) dt_exif_read_iptc_tag(iptcData, &amp;pos, key)</a>
<a name="ln416"> </a>
<a name="ln417"> </a>
<a name="ln418">// FIXME: according to http://www.exiv2.org/doc/classExiv2_1_1Metadatum.html#63c2b87249ba96679c29e01218169124</a>
<a name="ln419">// there is no need to pass iptcData</a>
<a name="ln420">static bool dt_exif_read_iptc_data(dt_image_t *img, Exiv2::IptcData &amp;iptcData)</a>
<a name="ln421">{</a>
<a name="ln422">  try</a>
<a name="ln423">  {</a>
<a name="ln424">    Exiv2::IptcData::const_iterator pos;</a>
<a name="ln425">    iptcData.sortByKey(); // this helps to quickly find all Iptc.Application2.Keywords</a>
<a name="ln426"> </a>
<a name="ln427">    if((pos = iptcData.findKey(Exiv2::IptcKey(&quot;Iptc.Application2.Keywords&quot;))) != iptcData.end())</a>
<a name="ln428">    {</a>
<a name="ln429">      while(pos != iptcData.end())</a>
<a name="ln430">      {</a>
<a name="ln431">        std::string key = pos-&gt;key();</a>
<a name="ln432">        if(g_strcmp0(key.c_str(), &quot;Iptc.Application2.Keywords&quot;)) break;</a>
<a name="ln433">        std::string str = pos-&gt;print();</a>
<a name="ln434">        char *tag = dt_util_foo_to_utf8(str.c_str());</a>
<a name="ln435">        guint tagid = 0;</a>
<a name="ln436">        dt_tag_new(tag, &amp;tagid);</a>
<a name="ln437">        dt_tag_attach(tagid, img-&gt;id);</a>
<a name="ln438">        g_free(tag);</a>
<a name="ln439">        ++pos;</a>
<a name="ln440">      }</a>
<a name="ln441">    }</a>
<a name="ln442">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Caption&quot;))</a>
<a name="ln443">    {</a>
<a name="ln444">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln445">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, str.c_str());</a>
<a name="ln446">    }</a>
<a name="ln447">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Copyright&quot;))</a>
<a name="ln448">    {</a>
<a name="ln449">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln450">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str.c_str());</a>
<a name="ln451">    }</a>
<a name="ln452">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Writer&quot;))</a>
<a name="ln453">    {</a>
<a name="ln454">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln455">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln456">    }</a>
<a name="ln457">    else if(FIND_IPTC_TAG(&quot;Iptc.Application2.Contact&quot;))</a>
<a name="ln458">    {</a>
<a name="ln459">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln460">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">    return true;</a>
<a name="ln464">  }</a>
<a name="ln465">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln466">  {</a>
<a name="ln467">    std::string s(e.what());</a>
<a name="ln468">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln469">    return false;</a>
<a name="ln470">  }</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">static bool dt_exif_read_exif_tag(Exiv2::ExifData &amp;exifData, Exiv2::ExifData::const_iterator *pos, string key)</a>
<a name="ln474">{</a>
<a name="ln475">  try</a>
<a name="ln476">  {</a>
<a name="ln477">    return (*pos = exifData.findKey(Exiv2::ExifKey(key))) != exifData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln478">  }</a>
<a name="ln479">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln480">  {</a>
<a name="ln481">    std::string s(e.what());</a>
<a name="ln482">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln483">    return false;</a>
<a name="ln484">  }</a>
<a name="ln485">}</a>
<a name="ln486">#define FIND_EXIF_TAG(key) dt_exif_read_exif_tag(exifData, &amp;pos, key)</a>
<a name="ln487"> </a>
<a name="ln488">static void _find_datetime_taken(Exiv2::ExifData &amp;exifData, Exiv2::ExifData::const_iterator pos,</a>
<a name="ln489">                                 char *exif_datetime_taken)</a>
<a name="ln490">{</a>
<a name="ln491">  if(FIND_EXIF_TAG(&quot;Exif.Image.DateTimeOriginal&quot;))</a>
<a name="ln492">  {</a>
<a name="ln493">    dt_strlcpy_to_utf8(exif_datetime_taken, 20, pos, exifData);</a>
<a name="ln494">  }</a>
<a name="ln495">  else if(FIND_EXIF_TAG(&quot;Exif.Photo.DateTimeOriginal&quot;))</a>
<a name="ln496">  {</a>
<a name="ln497">    dt_strlcpy_to_utf8(exif_datetime_taken, 20, pos, exifData);</a>
<a name="ln498">  }</a>
<a name="ln499">  else</a>
<a name="ln500">  {</a>
<a name="ln501">    *exif_datetime_taken = '\0';</a>
<a name="ln502">  }</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">static bool dt_exif_read_exif_data(dt_image_t *img, Exiv2::ExifData &amp;exifData)</a>
<a name="ln506">{</a>
<a name="ln507">  try</a>
<a name="ln508">  {</a>
<a name="ln509">    /* List of tag names taken from exiv2's printSummary() in actions.cpp */</a>
<a name="ln510">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln511"> </a>
<a name="ln512">    // look for maker &amp; model first so we can use that info later</a>
<a name="ln513">    if(FIND_EXIF_TAG(&quot;Exif.Image.Make&quot;))</a>
<a name="ln514">    {</a>
<a name="ln515">      dt_strlcpy_to_utf8(img-&gt;exif_maker, sizeof(img-&gt;exif_maker), pos, exifData);</a>
<a name="ln516">    }</a>
<a name="ln517">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Make&quot;))</a>
<a name="ln518">    {</a>
<a name="ln519">      dt_strlcpy_to_utf8(img-&gt;exif_maker, sizeof(img-&gt;exif_maker), pos, exifData);</a>
<a name="ln520">    }</a>
<a name="ln521"> </a>
<a name="ln522">    for(char *c = img-&gt;exif_maker + sizeof(img-&gt;exif_maker) - 1; c &gt; img-&gt;exif_maker; c--)</a>
<a name="ln523">      if(*c != ' ' &amp;&amp; *c != '\0')</a>
<a name="ln524">      {</a>
<a name="ln525">        *(c + 1) = '\0';</a>
<a name="ln526">        break;</a>
<a name="ln527">      }</a>
<a name="ln528"> </a>
<a name="ln529">    if(FIND_EXIF_TAG(&quot;Exif.Image.Model&quot;))</a>
<a name="ln530">    {</a>
<a name="ln531">      dt_strlcpy_to_utf8(img-&gt;exif_model, sizeof(img-&gt;exif_model), pos, exifData);</a>
<a name="ln532">    }</a>
<a name="ln533">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Model&quot;))</a>
<a name="ln534">    {</a>
<a name="ln535">      dt_strlcpy_to_utf8(img-&gt;exif_model, sizeof(img-&gt;exif_model), pos, exifData);</a>
<a name="ln536">    }</a>
<a name="ln537"> </a>
<a name="ln538">    for(char *c = img-&gt;exif_model + sizeof(img-&gt;exif_model) - 1; c &gt; img-&gt;exif_model; c--)</a>
<a name="ln539">      if(*c != ' ' &amp;&amp; *c != '\0')</a>
<a name="ln540">      {</a>
<a name="ln541">        *(c + 1) = '\0';</a>
<a name="ln542">        break;</a>
<a name="ln543">      }</a>
<a name="ln544"> </a>
<a name="ln545">    // Make sure we copy the exif make and model to the correct place if needed</a>
<a name="ln546">    dt_image_refresh_makermodel(img);</a>
<a name="ln547"> </a>
<a name="ln548">    /* Read shutter time */</a>
<a name="ln549">    if(FIND_EXIF_TAG(&quot;Exif.Photo.ExposureTime&quot;))</a>
<a name="ln550">    {</a>
<a name="ln551">      // dt_strlcpy_to_utf8(uf-&gt;conf-&gt;shutterText, max_name, pos, exifData);</a>
<a name="ln552">      img-&gt;exif_exposure = pos-&gt;toFloat();</a>
<a name="ln553">    }</a>
<a name="ln554">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.ShutterSpeedValue&quot;))</a>
<a name="ln555">    {</a>
<a name="ln556">      // uf_strlcpy_to_utf8(uf-&gt;conf-&gt;shutterText, max_name, pos, exifData);</a>
<a name="ln557">      img-&gt;exif_exposure = 1.0 / pos-&gt;toFloat();</a>
<a name="ln558">    }</a>
<a name="ln559">    /* Read aperture */</a>
<a name="ln560">    if(FIND_EXIF_TAG(&quot;Exif.Photo.FNumber&quot;))</a>
<a name="ln561">    {</a>
<a name="ln562">      img-&gt;exif_aperture = pos-&gt;toFloat();</a>
<a name="ln563">    }</a>
<a name="ln564">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.ApertureValue&quot;))</a>
<a name="ln565">    {</a>
<a name="ln566">      img-&gt;exif_aperture = pos-&gt;toFloat();</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    /* Read ISO speed - Nikon happens to return a pair for Lo and Hi modes */</a>
<a name="ln570">    if((pos = Exiv2::isoSpeed(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln571">    {</a>
<a name="ln572">      // if standard exif iso tag, use the old way of interpreting the return value to be more regression-save</a>
<a name="ln573">      if(strcmp(pos-&gt;key().c_str(), &quot;Exif.Photo.ISOSpeedRatings&quot;) == 0)</a>
<a name="ln574">      {</a>
<a name="ln575">        int isofield = pos-&gt;count() &gt; 1 ? 1 : 0;</a>
<a name="ln576">        img-&gt;exif_iso = pos-&gt;toFloat(isofield);</a>
<a name="ln577">      }</a>
<a name="ln578">      else</a>
<a name="ln579">      {</a>
<a name="ln580">        std::string str = pos-&gt;print();</a>
<a name="ln581">        img-&gt;exif_iso = (float)std::atof(str.c_str());</a>
<a name="ln582">      }</a>
<a name="ln583">    }</a>
<a name="ln584">    // some newer cameras support iso settings that exceed the 16 bit of exif's ISOSpeedRatings</a>
<a name="ln585">    if(img-&gt;exif_iso == 65535 || img-&gt;exif_iso == 0)</a>
<a name="ln586">    {</a>
<a name="ln587">      if(FIND_EXIF_TAG(&quot;Exif.PentaxDng.ISO&quot;) || FIND_EXIF_TAG(&quot;Exif.Pentax.ISO&quot;))</a>
<a name="ln588">      {</a>
<a name="ln589">        std::string str = pos-&gt;print();</a>
<a name="ln590">        img-&gt;exif_iso = (float)std::atof(str.c_str());</a>
<a name="ln591">      }</a>
<a name="ln592">      else if((!g_strcmp0(img-&gt;exif_maker, &quot;SONY&quot;) || !g_strcmp0(img-&gt;exif_maker, &quot;Canon&quot;))</a>
<a name="ln593">        &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Photo.RecommendedExposureIndex&quot;))</a>
<a name="ln594">      {</a>
<a name="ln595">        img-&gt;exif_iso = pos-&gt;toFloat();</a>
<a name="ln596">      }</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    /* Read focal length  */</a>
<a name="ln600">    if((pos = Exiv2::focalLength(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln601">    {</a>
<a name="ln602">      // This works around a bug in exiv2 the developers refuse to fix</a>
<a name="ln603">      // For details see http://dev.exiv2.org/issues/1083</a>
<a name="ln604">      if (pos-&gt;key() == &quot;Exif.Canon.FocalLength&quot; &amp;&amp; pos-&gt;count() == 4)</a>
<a name="ln605">        img-&gt;exif_focal_length = pos-&gt;toFloat(1);</a>
<a name="ln606">      else</a>
<a name="ln607">        img-&gt;exif_focal_length = pos-&gt;toFloat();</a>
<a name="ln608">    }</a>
<a name="ln609"> </a>
<a name="ln610">    /* Read focal length in 35mm if available and try to calculate crop factor */</a>
<a name="ln611">    if(FIND_EXIF_TAG(&quot;Exif.Photo.FocalLengthIn35mmFilm&quot;))</a>
<a name="ln612">    {</a>
<a name="ln613">      const float focal_length_35mm = pos-&gt;toFloat();</a>
<a name="ln614">      if(focal_length_35mm &gt; 0.0f &amp;&amp; img-&gt;exif_focal_length &gt; 0.0f)</a>
<a name="ln615">        img-&gt;exif_crop = focal_length_35mm / img-&gt;exif_focal_length;</a>
<a name="ln616">      else</a>
<a name="ln617">        img-&gt;exif_crop = 1.0f;</a>
<a name="ln618">    }</a>
<a name="ln619"> </a>
<a name="ln620">    if(FIND_EXIF_TAG(&quot;Exif.NikonLd2.FocusDistance&quot;))</a>
<a name="ln621">    {</a>
<a name="ln622">      float value = pos-&gt;toFloat();</a>
<a name="ln623">      img-&gt;exif_focus_distance = (0.01 * pow(10, value / 40));</a>
<a name="ln624">    }</a>
<a name="ln625">    else if(FIND_EXIF_TAG(&quot;Exif.NikonLd3.FocusDistance&quot;))</a>
<a name="ln626">    {</a>
<a name="ln627">      float value = pos-&gt;toFloat();</a>
<a name="ln628">      img-&gt;exif_focus_distance = (0.01 * pow(10, value / 40));</a>
<a name="ln629">    }</a>
<a name="ln630">    else if(FIND_EXIF_TAG(&quot;Exif.OlympusFi.FocusDistance&quot;))</a>
<a name="ln631">    {</a>
<a name="ln632">      /* the distance is stored as a rational (fraction). according to</a>
<a name="ln633">       * http://www.dpreview.com/forums/thread/1173960?page=4</a>
<a name="ln634">       * some Olympus cameras have a wrong denominator of 10 in there while the nominator is always in mm.</a>
<a name="ln635">       * thus we ignore the denominator</a>
<a name="ln636">       * and divide with 1000.</a>
<a name="ln637">       * &quot;I've checked a number of E-1 and E-300 images, and I agree that the FocusDistance looks like it is</a>
<a name="ln638">       * in mm for the E-1. However,</a>
<a name="ln639">       * it looks more like cm for the E-300.</a>
<a name="ln640">       * For both cameras, this value is stored as a rational. With the E-1, the denominator is always 1,</a>
<a name="ln641">       * while for the E-300 it is 10.</a>
<a name="ln642">       * Therefore, it looks like the numerator in both cases is in mm (which makes a bit of sense, in an odd</a>
<a name="ln643">       * sort of way). So I think</a>
<a name="ln644">       * what I will do in ExifTool is to take the numerator and divide by 1000 to display the focus distance</a>
<a name="ln645">       * in meters.&quot;</a>
<a name="ln646">       *   -- Boardhead, dpreview forums in 2005</a>
<a name="ln647">       */</a>
<a name="ln648">      int nominator = pos-&gt;toRational(0).first;</a>
<a name="ln649">      img-&gt;exif_focus_distance = fmax(0.0, (0.001 * nominator));</a>
<a name="ln650">    }</a>
<a name="ln651">    else if(EXIV2_MAKE_VERSION(0,25,0) &lt;= Exiv2::versionNumber() &amp;&amp; FIND_EXIF_TAG(&quot;Exif.CanonFi.FocusDistanceUpper&quot;))</a>
<a name="ln652">    {</a>
<a name="ln653">      const float FocusDistanceUpper = pos-&gt;toFloat();</a>
<a name="ln654">      if(FocusDistanceUpper &lt;= 0.0f || (int)FocusDistanceUpper &gt;= 0xffff)</a>
<a name="ln655">      {</a>
<a name="ln656">        img-&gt;exif_focus_distance = 0.0f;</a>
<a name="ln657">      }</a>
<a name="ln658">      else</a>
<a name="ln659">      {</a>
<a name="ln660">        img-&gt;exif_focus_distance = FocusDistanceUpper / 100.0;</a>
<a name="ln661">        if(FIND_EXIF_TAG(&quot;Exif.CanonFi.FocusDistanceLower&quot;))</a>
<a name="ln662">        {</a>
<a name="ln663">          const float FocusDistanceLower = pos-&gt;toFloat();</a>
<a name="ln664">          if(FocusDistanceLower &gt; 0.0f &amp;&amp; (int)FocusDistanceLower &lt; 0xffff)</a>
<a name="ln665">          {</a>
<a name="ln666">            img-&gt;exif_focus_distance += FocusDistanceLower / 100.0;</a>
<a name="ln667">            img-&gt;exif_focus_distance /= 2.0;</a>
<a name="ln668">          }</a>
<a name="ln669">        }</a>
<a name="ln670">      }</a>
<a name="ln671">    }</a>
<a name="ln672">    else if(FIND_EXIF_TAG(&quot;Exif.CanonSi.SubjectDistance&quot;))</a>
<a name="ln673">    {</a>
<a name="ln674">      img-&gt;exif_focus_distance = pos-&gt;toFloat() / 100.0;</a>
<a name="ln675">    }</a>
<a name="ln676">    else if((pos = Exiv2::subjectDistance(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln677">    {</a>
<a name="ln678">      img-&gt;exif_focus_distance = pos-&gt;toFloat();</a>
<a name="ln679">    }</a>
<a name="ln680">    /** read image orientation */</a>
<a name="ln681">    if(FIND_EXIF_TAG(&quot;Exif.Image.Orientation&quot;))</a>
<a name="ln682">    {</a>
<a name="ln683">      img-&gt;orientation = dt_image_orientation_to_flip_bits(pos-&gt;toLong());</a>
<a name="ln684">    }</a>
<a name="ln685">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Orientation&quot;))</a>
<a name="ln686">    {</a>
<a name="ln687">      img-&gt;orientation = dt_image_orientation_to_flip_bits(pos-&gt;toLong());</a>
<a name="ln688">    }</a>
<a name="ln689"> </a>
<a name="ln690">    /* read gps location */</a>
<a name="ln691">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSLatitude&quot;))</a>
<a name="ln692">    {</a>
<a name="ln693">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSLatitudeRef&quot;));</a>
<a name="ln694">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln695">      {</a>
<a name="ln696">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln697">        const char *sign = sign_str.c_str();</a>
<a name="ln698">        double latitude = 0.0;</a>
<a name="ln699">        if(dt_util_gps_rationale_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second,</a>
<a name="ln700">                                           pos-&gt;toRational(1).first, pos-&gt;toRational(1).second,</a>
<a name="ln701">                                           pos-&gt;toRational(2).first, pos-&gt;toRational(2).second, sign[0], &amp;latitude))</a>
<a name="ln702">          img-&gt;geoloc.latitude = latitude;</a>
<a name="ln703">      }</a>
<a name="ln704">    }</a>
<a name="ln705"> </a>
<a name="ln706">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSLongitude&quot;))</a>
<a name="ln707">    {</a>
<a name="ln708">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSLongitudeRef&quot;));</a>
<a name="ln709">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln710">      {</a>
<a name="ln711">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln712">        const char *sign = sign_str.c_str();</a>
<a name="ln713">        double longitude = 0.0;</a>
<a name="ln714">        if(dt_util_gps_rationale_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second,</a>
<a name="ln715">                                           pos-&gt;toRational(1).first, pos-&gt;toRational(1).second,</a>
<a name="ln716">                                           pos-&gt;toRational(2).first, pos-&gt;toRational(2).second, sign[0], &amp;longitude))</a>
<a name="ln717">          img-&gt;geoloc.longitude = longitude;</a>
<a name="ln718">      }</a>
<a name="ln719">    }</a>
<a name="ln720"> </a>
<a name="ln721">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSAltitude&quot;))</a>
<a name="ln722">    {</a>
<a name="ln723">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSAltitudeRef&quot;));</a>
<a name="ln724">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln725">      {</a>
<a name="ln726">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln727">        const char *sign = sign_str.c_str();</a>
<a name="ln728">        double elevation = 0.0;</a>
<a name="ln729">        if(dt_util_gps_elevation_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second, sign[0], &amp;elevation))</a>
<a name="ln730">          img-&gt;geoloc.elevation = elevation;</a>
<a name="ln731">      }</a>
<a name="ln732">    }</a>
<a name="ln733"> </a>
<a name="ln734">    /* Read lens name */</a>
<a name="ln735">    if((FIND_EXIF_TAG(&quot;Exif.CanonCs.LensType&quot;) &amp;&amp; pos-&gt;print(&amp;exifData) != &quot;(0)&quot;</a>
<a name="ln736">        &amp;&amp; pos-&gt;print(&amp;exifData) != &quot;(65535)&quot;)</a>
<a name="ln737">       || FIND_EXIF_TAG(&quot;Exif.Canon.0x0095&quot;))</a>
<a name="ln738">    {</a>
<a name="ln739">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln740">    }</a>
<a name="ln741">    else if(EXIV2_MAKE_VERSION(0,25,0) &lt;= Exiv2::versionNumber() &amp;&amp; FIND_EXIF_TAG(&quot;Exif.PentaxDng.LensType&quot;))</a>
<a name="ln742">    {</a>
<a name="ln743">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln744">    }</a>
<a name="ln745">    else if(FIND_EXIF_TAG(&quot;Exif.Panasonic.LensType&quot;))</a>
<a name="ln746">    {</a>
<a name="ln747">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln748">    }</a>
<a name="ln749">    else if(FIND_EXIF_TAG(&quot;Exif.OlympusEq.LensType&quot;))</a>
<a name="ln750">    {</a>
<a name="ln751">      /* For every Olympus camera Exif.OlympusEq.LensType is present. */</a>
<a name="ln752">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln753"> </a>
<a name="ln754">      /* We have to check if Exif.OlympusEq.LensType has been translated by</a>
<a name="ln755">       * exiv2. If it hasn't, fall back to Exif.OlympusEq.LensModel. */</a>
<a name="ln756">      std::string lens(img-&gt;exif_lens);</a>
<a name="ln757">      if(std::string::npos == lens.find_first_not_of(&quot; 1234567890&quot;))</a>
<a name="ln758">      {</a>
<a name="ln759">        /* Exif.OlympusEq.LensType contains only digits and spaces.</a>
<a name="ln760">         * This means that exiv2 couldn't convert it to human readable</a>
<a name="ln761">         * form. */</a>
<a name="ln762">        if(FIND_EXIF_TAG(&quot;Exif.OlympusEq.LensModel&quot;))</a>
<a name="ln763">        {</a>
<a name="ln764">          dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln765">        }</a>
<a name="ln766">        /* Just in case Exif.OlympusEq.LensModel hasn't been found */</a>
<a name="ln767">        else if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln768">        {</a>
<a name="ln769">          dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln770">        }</a>
<a name="ln771">        fprintf(stderr, &quot;[exif] Warning: lens \&quot;%s\&quot; unknown as \&quot;%s\&quot;\n&quot;, img-&gt;exif_lens, lens.c_str());</a>
<a name="ln772">      }</a>
<a name="ln773">    }</a>
<a name="ln774">    else if((pos = Exiv2::lensName(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln775">    {</a>
<a name="ln776">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln777">    }</a>
<a name="ln778">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln779">    {</a>
<a name="ln780">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln781">    }</a>
<a name="ln782"> </a>
<a name="ln783">#if 0</a>
<a name="ln784">    /* Read flash mode */</a>
<a name="ln785">    if ( (pos=exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.Flash&quot;)))</a>
<a name="ln786">         != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln787">    {</a>
<a name="ln788">      uf_strlcpy_to_utf8(uf-&gt;conf-&gt;flashText, max_name, pos, exifData);</a>
<a name="ln789">    }</a>
<a name="ln790">    /* Read White Balance Setting */</a>
<a name="ln791">    if ( (pos=exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.WhiteBalance&quot;)))</a>
<a name="ln792">         != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln793">    {</a>
<a name="ln794">      uf_strlcpy_to_utf8(uf-&gt;conf-&gt;whiteBalanceText, max_name, pos, exifData);</a>
<a name="ln795">    }</a>
<a name="ln796">#endif</a>
<a name="ln797"> </a>
<a name="ln798">    _find_datetime_taken(exifData, pos, img-&gt;exif_datetime_taken);</a>
<a name="ln799"> </a>
<a name="ln800">    if(FIND_EXIF_TAG(&quot;Exif.Image.Artist&quot;))</a>
<a name="ln801">    {</a>
<a name="ln802">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln803">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln804">    }</a>
<a name="ln805">    else if(FIND_EXIF_TAG(&quot;Exif.Canon.OwnerName&quot;))</a>
<a name="ln806">    {</a>
<a name="ln807">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln808">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln809">    }</a>
<a name="ln810"> </a>
<a name="ln811">    // FIXME: Should the UserComment go into the description? Or do we need an extra field for this?</a>
<a name="ln812">    if(FIND_EXIF_TAG(&quot;Exif.Photo.UserComment&quot;))</a>
<a name="ln813">    {</a>
<a name="ln814">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln815">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, str.c_str());</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    if(FIND_EXIF_TAG(&quot;Exif.Image.Copyright&quot;))</a>
<a name="ln819">    {</a>
<a name="ln820">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln821">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str.c_str());</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    if(FIND_EXIF_TAG(&quot;Exif.Image.Rating&quot;))</a>
<a name="ln825">    {</a>
<a name="ln826">      int stars = pos-&gt;toLong();</a>
<a name="ln827">      if(stars == 0)</a>
<a name="ln828">      {</a>
<a name="ln829">        stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln830">      }</a>
<a name="ln831">      else</a>
<a name="ln832">      {</a>
<a name="ln833">        stars = (stars == -1) ? 6 : stars;</a>
<a name="ln834">      }</a>
<a name="ln835">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln836">    }</a>
<a name="ln837">    else if(FIND_EXIF_TAG(&quot;Exif.Image.RatingPercent&quot;))</a>
<a name="ln838">    {</a>
<a name="ln839">      int stars = pos-&gt;toLong() * 5. / 100;</a>
<a name="ln840">      if(stars == 0)</a>
<a name="ln841">      {</a>
<a name="ln842">        stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln843">      }</a>
<a name="ln844">      else</a>
<a name="ln845">      {</a>
<a name="ln846">        stars = (stars == -1) ? 6 : stars;</a>
<a name="ln847">      }</a>
<a name="ln848">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln849">    }</a>
<a name="ln850"> </a>
<a name="ln851">    // read embedded color matrix as used in DNGs</a>
<a name="ln852">    {</a>
<a name="ln853">      int is_1_65 = -1, is_2_65 = -1; // -1: not found, 0: some random type, 1: D65</a>
<a name="ln854">      if(FIND_EXIF_TAG(&quot;Exif.Image.CalibrationIlluminant1&quot;))</a>
<a name="ln855">      {</a>
<a name="ln856">        is_1_65 = (pos-&gt;toLong() == 21) ? 1 : 0;</a>
<a name="ln857">      }</a>
<a name="ln858">      if(FIND_EXIF_TAG(&quot;Exif.Image.CalibrationIlluminant2&quot;))</a>
<a name="ln859">      {</a>
<a name="ln860">        is_2_65 = (pos-&gt;toLong() == 21) ? 1 : 0;</a>
<a name="ln861">      }</a>
<a name="ln862"> </a>
<a name="ln863">      // use the d65 (type == 21) matrix if we found it, otherwise use whatever we got</a>
<a name="ln864">      Exiv2::ExifData::const_iterator cm1_pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Image.ColorMatrix1&quot;));</a>
<a name="ln865">      Exiv2::ExifData::const_iterator cm2_pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Image.ColorMatrix2&quot;));</a>
<a name="ln866">      if(is_1_65 == 1 &amp;&amp; cm1_pos != exifData.end() &amp;&amp; cm1_pos-&gt;count() == 9 &amp;&amp; cm1_pos-&gt;size())</a>
<a name="ln867">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm1_pos-&gt;toFloat(i);</a>
<a name="ln868">      else if(is_2_65 == 1 &amp;&amp; cm2_pos != exifData.end() &amp;&amp; cm2_pos-&gt;count() == 9 &amp;&amp; cm2_pos-&gt;size())</a>
<a name="ln869">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm2_pos-&gt;toFloat(i);</a>
<a name="ln870">      else if(cm1_pos != exifData.end() &amp;&amp; cm1_pos-&gt;count() == 9 &amp;&amp; cm1_pos-&gt;size())</a>
<a name="ln871">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm1_pos-&gt;toFloat(i);</a>
<a name="ln872">      else if(cm2_pos != exifData.end() &amp;&amp; cm2_pos-&gt;count() == 9 &amp;&amp; cm2_pos-&gt;size())</a>
<a name="ln873">        for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = cm2_pos-&gt;toFloat(i);</a>
<a name="ln874">    }</a>
<a name="ln875"> </a>
<a name="ln876">    // some files have the colorspace explicitly set. try to read that.</a>
<a name="ln877">    // is_ldr -&gt; none</a>
<a name="ln878">    // 0x01   -&gt; sRGB</a>
<a name="ln879">    // 0x02   -&gt; AdobeRGB</a>
<a name="ln880">    // 0xffff -&gt; Uncalibrated</a>
<a name="ln881">    //          + Exif.Iop.InteroperabilityIndex of 'R03' -&gt; AdobeRGB</a>
<a name="ln882">    //          + Exif.Iop.InteroperabilityIndex of 'R98' -&gt; sRGB</a>
<a name="ln883">    if(dt_image_is_ldr(img) &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Photo.ColorSpace&quot;))</a>
<a name="ln884">    {</a>
<a name="ln885">      int colorspace = pos-&gt;toLong();</a>
<a name="ln886">      if(colorspace == 0x01)</a>
<a name="ln887">        img-&gt;colorspace = DT_IMAGE_COLORSPACE_SRGB;</a>
<a name="ln888">      else if(colorspace == 0x02)</a>
<a name="ln889">        img-&gt;colorspace = DT_IMAGE_COLORSPACE_ADOBE_RGB;</a>
<a name="ln890">      else if(colorspace == 0xffff)</a>
<a name="ln891">      {</a>
<a name="ln892">        if(FIND_EXIF_TAG(&quot;Exif.Iop.InteroperabilityIndex&quot;))</a>
<a name="ln893">        {</a>
<a name="ln894">          std::string interop_index = pos-&gt;toString();</a>
<a name="ln895">          if(interop_index == &quot;R03&quot;)</a>
<a name="ln896">            img-&gt;colorspace = DT_IMAGE_COLORSPACE_ADOBE_RGB;</a>
<a name="ln897">          else if(interop_index == &quot;R98&quot;)</a>
<a name="ln898">            img-&gt;colorspace = DT_IMAGE_COLORSPACE_SRGB;</a>
<a name="ln899">        }</a>
<a name="ln900">      }</a>
<a name="ln901">    }</a>
<a name="ln902"> </a>
<a name="ln903">#if EXIV2_MINOR_VERSION &lt; 23</a>
<a name="ln904">    // workaround for an exiv2 bug writing random garbage into exif_lens for this camera:</a>
<a name="ln905">    // http://dev.exiv2.org/issues/779</a>
<a name="ln906">    if(!strcmp(img-&gt;exif_model, &quot;DMC-GH2&quot;)) snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;(unknown)&quot;);</a>
<a name="ln907">#endif</a>
<a name="ln908"> </a>
<a name="ln909">    // Improve lens detection for Sony SAL lenses.</a>
<a name="ln910">    if(FIND_EXIF_TAG(&quot;Exif.Sony2.LensID&quot;) &amp;&amp; pos-&gt;toLong() != 65535 &amp;&amp; pos-&gt;print().find('|') == std::string::npos)</a>
<a name="ln911">    {</a>
<a name="ln912">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln913">    }</a>
<a name="ln914">    // Workaround for an issue on newer Sony NEX cams.</a>
<a name="ln915">    // The default EXIF field is not used by Sony to store lens data</a>
<a name="ln916">    // http://dev.exiv2.org/issues/883</a>
<a name="ln917">    // http://darktable.org/redmine/issues/8813</a>
<a name="ln918">    // FIXME: This is still a workaround</a>
<a name="ln919">    else if((!strncmp(img-&gt;exif_model, &quot;NEX&quot;, 3)) || (!strncmp(img-&gt;exif_model, &quot;ILCE&quot;, 4)))</a>
<a name="ln920">    {</a>
<a name="ln921">      snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;(unknown)&quot;);</a>
<a name="ln922">      if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln923">      {</a>
<a name="ln924">        std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln925">        snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;%s&quot;, str.c_str());</a>
<a name="ln926">      }</a>
<a name="ln927">    };</a>
<a name="ln928"> </a>
<a name="ln929">    img-&gt;exif_inited = 1;</a>
<a name="ln930">    return true;</a>
<a name="ln931">  }</a>
<a name="ln932">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln933">  {</a>
<a name="ln934">    std::string s(e.what());</a>
<a name="ln935">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln936">    return false;</a>
<a name="ln937">  }</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">static void dt_exif_apply_global_overwrites(dt_image_t *img)</a>
<a name="ln941">{</a>
<a name="ln942">  if(dt_conf_get_bool(&quot;ui_last/import_apply_metadata&quot;) == TRUE)</a>
<a name="ln943">  {</a>
<a name="ln944">    char *str;</a>
<a name="ln945"> </a>
<a name="ln946">    str = dt_conf_get_string(&quot;ui_last/import_last_creator&quot;);</a>
<a name="ln947">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str);</a>
<a name="ln948">    g_free(str);</a>
<a name="ln949"> </a>
<a name="ln950">    str = dt_conf_get_string(&quot;ui_last/import_last_rights&quot;);</a>
<a name="ln951">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str);</a>
<a name="ln952">    g_free(str);</a>
<a name="ln953"> </a>
<a name="ln954">    str = dt_conf_get_string(&quot;ui_last/import_last_publisher&quot;);</a>
<a name="ln955">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.publisher&quot;, str);</a>
<a name="ln956">    g_free(str);</a>
<a name="ln957"> </a>
<a name="ln958">    str = dt_conf_get_string(&quot;ui_last/import_last_tags&quot;);</a>
<a name="ln959">    if(str != NULL &amp;&amp; str[0] != '\0') dt_tag_attach_string_list(str, img-&gt;id);</a>
<a name="ln960">    g_free(str);</a>
<a name="ln961">  }</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">// TODO: can this blob also contain xmp and iptc data?</a>
<a name="ln965">int dt_exif_read_from_blob(dt_image_t *img, uint8_t *blob, const int size)</a>
<a name="ln966">{</a>
<a name="ln967">  try</a>
<a name="ln968">  {</a>
<a name="ln969">    Exiv2::ExifData exifData;</a>
<a name="ln970">    Exiv2::ExifParser::decode(exifData, blob, size);</a>
<a name="ln971">    bool res = dt_exif_read_exif_data(img, exifData);</a>
<a name="ln972">    dt_exif_apply_global_overwrites(img);</a>
<a name="ln973">    return res ? 0 : 1;</a>
<a name="ln974">  }</a>
<a name="ln975">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln976">  {</a>
<a name="ln977">    std::string s(e.what());</a>
<a name="ln978">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln979">    return 1;</a>
<a name="ln980">  }</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983">/**</a>
<a name="ln984"> * Get the largest possible thumbnail from the image</a>
<a name="ln985"> */</a>
<a name="ln986">int dt_exif_get_thumbnail(const char *path, uint8_t **buffer, size_t *size, char **mime_type)</a>
<a name="ln987">{</a>
<a name="ln988">  try</a>
<a name="ln989">  {</a>
<a name="ln990">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln991">    assert(image.get() != 0);</a>
<a name="ln992">    read_metadata_threadsafe(image);</a>
<a name="ln993"> </a>
<a name="ln994">    // Get a list of preview images available in the image. The list is sorted</a>
<a name="ln995">    // by the preview image pixel size, starting with the smallest preview.</a>
<a name="ln996">    Exiv2::PreviewManager loader(*image);</a>
<a name="ln997">    Exiv2::PreviewPropertiesList list = loader.getPreviewProperties();</a>
<a name="ln998">    if(list.empty())</a>
<a name="ln999">    {</a>
<a name="ln1000">      dt_print(DT_DEBUG_LIGHTTABLE, &quot;[exiv2] couldn't find thumbnail for %s&quot;, path);</a>
<a name="ln1001">      return 1;</a>
<a name="ln1002">    }</a>
<a name="ln1003"> </a>
<a name="ln1004">    // Select the largest one</a>
<a name="ln1005">    // FIXME: We could probably select a smaller thumbnail to match the mip size</a>
<a name="ln1006">    //        we actually want to create. Is it really much faster though?</a>
<a name="ln1007">    Exiv2::PreviewProperties selected = list.back();</a>
<a name="ln1008"> </a>
<a name="ln1009">    // Get the selected preview image</a>
<a name="ln1010">    Exiv2::PreviewImage preview = loader.getPreviewImage(selected);</a>
<a name="ln1011">    const unsigned  char *tmp = preview.pData();</a>
<a name="ln1012">    size_t _size = preview.size();</a>
<a name="ln1013"> </a>
<a name="ln1014">    *size = _size;</a>
<a name="ln1015">    *mime_type = strdup(preview.mimeType().c_str());</a>
<a name="ln1016">    *buffer = (uint8_t *)malloc(_size);</a>
<a name="ln1017">    if(!*buffer) {</a>
<a name="ln1018">      std::cerr &lt;&lt; &quot;[exiv2] couldn't allocate memory for thumbnail for &quot; &lt;&lt; path &lt;&lt; std::endl;</a>
<a name="ln1019">      return 1;</a>
<a name="ln1020">    }</a>
<a name="ln1021">    //std::cerr &lt;&lt; &quot;[exiv2] &quot;&lt;&lt; path &lt;&lt; &quot;: found thumbnail &quot;&lt;&lt; preview.width() &lt;&lt; &quot;x&quot; &lt;&lt; preview.height() &lt;&lt; std::endl;</a>
<a name="ln1022">    memcpy(*buffer, tmp, _size);</a>
<a name="ln1023"> </a>
<a name="ln1024">    return 0;</a>
<a name="ln1025">  }</a>
<a name="ln1026">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1027">  {</a>
<a name="ln1028">    std::string s(e.what());</a>
<a name="ln1029">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1030">    return 1;</a>
<a name="ln1031">  }</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">/** read the metadata of an image.</a>
<a name="ln1035"> * XMP data trumps IPTC data trumps EXIF data</a>
<a name="ln1036"> */</a>
<a name="ln1037">int dt_exif_read(dt_image_t *img, const char *path)</a>
<a name="ln1038">{</a>
<a name="ln1039">  // at least set datetime taken to something useful in case there is no exif data in this file (pfm, png,</a>
<a name="ln1040">  // ...)</a>
<a name="ln1041">  struct stat statbuf;</a>
<a name="ln1042"> </a>
<a name="ln1043">  if(!stat(path, &amp;statbuf))</a>
<a name="ln1044">  {</a>
<a name="ln1045">    struct tm result;</a>
<a name="ln1046">    strftime(img-&gt;exif_datetime_taken, 20, &quot;%Y:%m:%d %H:%M:%S&quot;, localtime_r(&amp;statbuf.st_mtime, &amp;result));</a>
<a name="ln1047">  }</a>
<a name="ln1048"> </a>
<a name="ln1049">  try</a>
<a name="ln1050">  {</a>
<a name="ln1051">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1052">    assert(image.get() != 0);</a>
<a name="ln1053">    read_metadata_threadsafe(image);</a>
<a name="ln1054">    bool res = true;</a>
<a name="ln1055"> </a>
<a name="ln1056">    // EXIF metadata</a>
<a name="ln1057">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln1058">    if(!exifData.empty())</a>
<a name="ln1059">      res = dt_exif_read_exif_data(img, exifData);</a>
<a name="ln1060">    else</a>
<a name="ln1061">      img-&gt;exif_inited = 1;</a>
<a name="ln1062"> </a>
<a name="ln1063">    // these get overwritten by IPTC and XMP. is that how it should work?</a>
<a name="ln1064">    dt_exif_apply_global_overwrites(img);</a>
<a name="ln1065"> </a>
<a name="ln1066">    // IPTC metadata.</a>
<a name="ln1067">    Exiv2::IptcData &amp;iptcData = image-&gt;iptcData();</a>
<a name="ln1068">    if(!iptcData.empty()) res = dt_exif_read_iptc_data(img, iptcData) &amp;&amp; res;</a>
<a name="ln1069"> </a>
<a name="ln1070">    // XMP metadata</a>
<a name="ln1071">    Exiv2::XmpData &amp;xmpData = image-&gt;xmpData();</a>
<a name="ln1072">    if(!xmpData.empty()) res = dt_exif_read_xmp_data(img, xmpData, -1, true) &amp;&amp; res;</a>
<a name="ln1073"> </a>
<a name="ln1074">    // Initialize size - don't wait for full raw to be loaded to get this</a>
<a name="ln1075">    // information. If use_embedded_thumbnail is set, it will take a</a>
<a name="ln1076">    // change in development history to have this information</a>
<a name="ln1077">    img-&gt;height = image-&gt;pixelHeight();</a>
<a name="ln1078">    img-&gt;width = image-&gt;pixelWidth();</a>
<a name="ln1079"> </a>
<a name="ln1080">    return res ? 0 : 1;</a>
<a name="ln1081">  }</a>
<a name="ln1082">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1083">  {</a>
<a name="ln1084">    std::string s(e.what());</a>
<a name="ln1085">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1086">    return 1;</a>
<a name="ln1087">  }</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">int dt_exif_write_blob(uint8_t *blob, uint32_t size, const char *path, const int compressed)</a>
<a name="ln1091">{</a>
<a name="ln1092">  try</a>
<a name="ln1093">  {</a>
<a name="ln1094">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1095">    assert(image.get() != 0);</a>
<a name="ln1096">    read_metadata_threadsafe(image);</a>
<a name="ln1097">    Exiv2::ExifData &amp;imgExifData = image-&gt;exifData();</a>
<a name="ln1098">    Exiv2::ExifData blobExifData;</a>
<a name="ln1099">    Exiv2::ExifParser::decode(blobExifData, blob + 6, size);</a>
<a name="ln1100">    Exiv2::ExifData::const_iterator end = blobExifData.end();</a>
<a name="ln1101">    Exiv2::ExifData::iterator it;</a>
<a name="ln1102">    for(Exiv2::ExifData::const_iterator i = blobExifData.begin(); i != end; ++i)</a>
<a name="ln1103">    {</a>
<a name="ln1104">      // add() does not override! we need to delete existing key first.</a>
<a name="ln1105">      Exiv2::ExifKey key(i-&gt;key());</a>
<a name="ln1106">      if((it = imgExifData.findKey(key)) != imgExifData.end()) imgExifData.erase(it);</a>
<a name="ln1107"> </a>
<a name="ln1108">      imgExifData.add(Exiv2::ExifKey(i-&gt;key()), &amp;i-&gt;value());</a>
<a name="ln1109">    }</a>
<a name="ln1110"> </a>
<a name="ln1111">    {</a>
<a name="ln1112">      // Remove thumbnail</a>
<a name="ln1113">      static const char *keys[] = {</a>
<a name="ln1114">        &quot;Exif.Thumbnail.Compression&quot;,</a>
<a name="ln1115">        &quot;Exif.Thumbnail.XResolution&quot;,</a>
<a name="ln1116">        &quot;Exif.Thumbnail.YResolution&quot;,</a>
<a name="ln1117">        &quot;Exif.Thumbnail.ResolutionUnit&quot;,</a>
<a name="ln1118">        &quot;Exif.Thumbnail.JPEGInterchangeFormat&quot;,</a>
<a name="ln1119">        &quot;Exif.Thumbnail.JPEGInterchangeFormatLength&quot;</a>
<a name="ln1120">      };</a>
<a name="ln1121">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1122">      dt_remove_exif_keys(imgExifData, keys, n_keys);</a>
<a name="ln1123">    }</a>
<a name="ln1124"> </a>
<a name="ln1125">    // only compressed images may set PixelXDimension and PixelYDimension</a>
<a name="ln1126">    if(!compressed)</a>
<a name="ln1127">    {</a>
<a name="ln1128">      static const char *keys[] = {</a>
<a name="ln1129">        &quot;Exif.Photo.PixelXDimension&quot;,</a>
<a name="ln1130">        &quot;Exif.Photo.PixelYDimension&quot;</a>
<a name="ln1131">      };</a>
<a name="ln1132">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1133">      dt_remove_exif_keys(imgExifData, keys, n_keys);</a>
<a name="ln1134">    }</a>
<a name="ln1135"> </a>
<a name="ln1136">    imgExifData.sortByTag();</a>
<a name="ln1137">    image-&gt;writeMetadata();</a>
<a name="ln1138">  }</a>
<a name="ln1139">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1140">  {</a>
<a name="ln1141">    std::string s(e.what());</a>
<a name="ln1142">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1143">    return 0;</a>
<a name="ln1144">  }</a>
<a name="ln1145">  return 1;</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">int dt_exif_read_blob(uint8_t **buf, const char *path, const int imgid, const int sRGB, const int out_width,</a>
<a name="ln1149">                      const int out_height, const int dng_mode)</a>
<a name="ln1150">{</a>
<a name="ln1151">  *buf = NULL;</a>
<a name="ln1152">  try</a>
<a name="ln1153">  {</a>
<a name="ln1154">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1155">    assert(image.get() != 0);</a>
<a name="ln1156">    read_metadata_threadsafe(image);</a>
<a name="ln1157">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln1158"> </a>
<a name="ln1159">    // get rid of thumbnails</a>
<a name="ln1160">    Exiv2::ExifThumb(exifData).erase();</a>
<a name="ln1161"> </a>
<a name="ln1162">    // ufraw-style exif stripping:</a>
<a name="ln1163">    Exiv2::ExifData::iterator pos;</a>
<a name="ln1164">    {</a>
<a name="ln1165">    /* Delete original TIFF data, which is irrelevant*/</a>
<a name="ln1166">      static const char *keys[] = {</a>
<a name="ln1167">        &quot;Exif.Image.ImageWidth&quot;,</a>
<a name="ln1168">        &quot;Exif.Image.ImageLength&quot;,</a>
<a name="ln1169">        &quot;Exif.Image.BitsPerSample&quot;,</a>
<a name="ln1170">        &quot;Exif.Image.Compression&quot;,</a>
<a name="ln1171">        &quot;Exif.Image.PhotometricInterpretation&quot;,</a>
<a name="ln1172">        &quot;Exif.Image.FillOrder&quot;,</a>
<a name="ln1173">        &quot;Exif.Image.SamplesPerPixel&quot;,</a>
<a name="ln1174">        &quot;Exif.Image.StripOffsets&quot;,</a>
<a name="ln1175">        &quot;Exif.Image.RowsPerStrip&quot;,</a>
<a name="ln1176">        &quot;Exif.Image.StripByteCounts&quot;,</a>
<a name="ln1177">        &quot;Exif.Image.PlanarConfiguration&quot;,</a>
<a name="ln1178">        &quot;Exif.Image.DNGVersion&quot;,</a>
<a name="ln1179">        &quot;Exif.Image.DNGBackwardVersion&quot;</a>
<a name="ln1180">      };</a>
<a name="ln1181">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1182">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1183">    }</a>
<a name="ln1184"> </a>
<a name="ln1185">    if(!dng_mode)</a>
<a name="ln1186">    {</a>
<a name="ln1187">      /* Delete various MakerNote fields only applicable to the raw file */</a>
<a name="ln1188"> </a>
<a name="ln1189">      exifData[&quot;Exif.Image.Orientation&quot;] = uint16_t(1);</a>
<a name="ln1190"> </a>
<a name="ln1191">      {</a>
<a name="ln1192">        static const char *keys[] = {</a>
<a name="ln1193">          // Embedded color profile info</a>
<a name="ln1194">          &quot;Exif.Image.BaselineExposureOffset&quot;,</a>
<a name="ln1195">          &quot;Exif.Image.CalibrationIlluminant1&quot;,</a>
<a name="ln1196">          &quot;Exif.Image.CalibrationIlluminant2&quot;,</a>
<a name="ln1197">          &quot;Exif.Image.ColorMatrix1&quot;,</a>
<a name="ln1198">          &quot;Exif.Image.ColorMatrix2&quot;,</a>
<a name="ln1199">          &quot;Exif.Image.DefaultBlackRender&quot;,</a>
<a name="ln1200">          &quot;Exif.Image.ForwardMatrix1&quot;,</a>
<a name="ln1201">          &quot;Exif.Image.ForwardMatrix2&quot;,</a>
<a name="ln1202">          &quot;Exif.Image.ProfileCalibrationSignature&quot;,</a>
<a name="ln1203">          &quot;Exif.Image.ProfileCopyright&quot;,</a>
<a name="ln1204">          &quot;Exif.Image.ProfileEmbedPolicy&quot;,</a>
<a name="ln1205">          &quot;Exif.Image.ProfileHueSatMapData1&quot;,</a>
<a name="ln1206">          &quot;Exif.Image.ProfileHueSatMapData2&quot;,</a>
<a name="ln1207">          &quot;Exif.Image.ProfileHueSatMapDims&quot;,</a>
<a name="ln1208">          &quot;Exif.Image.ProfileHueSatMapEncoding&quot;,</a>
<a name="ln1209">          &quot;Exif.Image.ProfileLookTableData&quot;,</a>
<a name="ln1210">          &quot;Exif.Image.ProfileLookTableDims&quot;,</a>
<a name="ln1211">          &quot;Exif.Image.ProfileLookTableEncoding&quot;,</a>
<a name="ln1212">          &quot;Exif.Image.ProfileName&quot;,</a>
<a name="ln1213">          &quot;Exif.Image.ProfileToneCurve&quot;,</a>
<a name="ln1214">          &quot;Exif.Image.ReductionMatrix1&quot;,</a>
<a name="ln1215">          &quot;Exif.Image.ReductionMatrix2&quot;,</a>
<a name="ln1216"> </a>
<a name="ln1217">          // Canon color space info</a>
<a name="ln1218">          &quot;Exif.Canon.ColorSpace&quot;,</a>
<a name="ln1219">          &quot;Exif.Canon.ColorData&quot;,</a>
<a name="ln1220"> </a>
<a name="ln1221">          // Nikon thumbnail data</a>
<a name="ln1222">          &quot;Exif.Nikon3.Preview&quot;,</a>
<a name="ln1223">          &quot;Exif.NikonPreview.JPEGInterchangeFormat&quot;,</a>
<a name="ln1224"> </a>
<a name="ln1225">          // DNG private data</a>
<a name="ln1226">          &quot;Exif.Image.DNGPrivateData&quot;,</a>
<a name="ln1227"> </a>
<a name="ln1228">          // Pentax thumbnail data</a>
<a name="ln1229">          &quot;Exif.Pentax.PreviewResolution&quot;,</a>
<a name="ln1230">          &quot;Exif.Pentax.PreviewLength&quot;,</a>
<a name="ln1231">          &quot;Exif.Pentax.PreviewOffset&quot;,</a>
<a name="ln1232">          &quot;Exif.PentaxDng.PreviewResolution&quot;,</a>
<a name="ln1233">          &quot;Exif.PentaxDng.PreviewLength&quot;,</a>
<a name="ln1234">          &quot;Exif.PentaxDng.PreviewOffset&quot;,</a>
<a name="ln1235">          // Pentax color info</a>
<a name="ln1236">          &quot;Exif.PentaxDng.ColorInfo&quot;,</a>
<a name="ln1237"> </a>
<a name="ln1238">          // Minolta thumbnail data</a>
<a name="ln1239">          &quot;Exif.Minolta.Thumbnail&quot;,</a>
<a name="ln1240">          &quot;Exif.Minolta.ThumbnailOffset&quot;,</a>
<a name="ln1241">          &quot;Exif.Minolta.ThumbnailLength&quot;,</a>
<a name="ln1242"> </a>
<a name="ln1243">          // Sony thumbnail data</a>
<a name="ln1244">          &quot;Exif.SonyMinolta.ThumbnailOffset&quot;,</a>
<a name="ln1245">          &quot;Exif.SonyMinolta.ThumbnailLength&quot;,</a>
<a name="ln1246"> </a>
<a name="ln1247">          // Olympus thumbnail data</a>
<a name="ln1248">          &quot;Exif.Olympus.Thumbnail&quot;,</a>
<a name="ln1249">          &quot;Exif.Olympus.ThumbnailOffset&quot;,</a>
<a name="ln1250">          &quot;Exif.Olympus.ThumbnailLength&quot;</a>
<a name="ln1251">        };</a>
<a name="ln1252">        static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1253">        dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1254">      }</a>
<a name="ln1255"> </a>
<a name="ln1256">      // remove subimage* trees, related to thumbnails or HDR usually</a>
<a name="ln1257">      for(Exiv2::ExifData::iterator i = exifData.begin(); i != exifData.end();)</a>
<a name="ln1258">      {</a>
<a name="ln1259">        static const std::string needle = &quot;Exif.SubImage&quot;;</a>
<a name="ln1260">        if(i-&gt;key().compare(0, needle.length(), needle) == 0)</a>
<a name="ln1261">          i = exifData.erase(i);</a>
<a name="ln1262">        else</a>
<a name="ln1263">          ++i;</a>
<a name="ln1264">      }</a>
<a name="ln1265"> </a>
<a name="ln1266">#if EXIV2_MINOR_VERSION &gt;= 23</a>
<a name="ln1267">      {</a>
<a name="ln1268">        // Exiv2 versions older than 0.23 drop all EXIF if the code below is executed</a>
<a name="ln1269">        // Samsung makernote cleanup, the entries below have no relevance for exported images</a>
<a name="ln1270">        static const char *keys[] = {</a>
<a name="ln1271">          &quot;Exif.Samsung2.SensorAreas&quot;,</a>
<a name="ln1272">          &quot;Exif.Samsung2.ColorSpace&quot;,</a>
<a name="ln1273">          &quot;Exif.Samsung2.EncryptionKey&quot;,</a>
<a name="ln1274">          &quot;Exif.Samsung2.WB_RGGBLevelsUncorrected&quot;,</a>
<a name="ln1275">          &quot;Exif.Samsung2.WB_RGGBLevelsAuto&quot;,</a>
<a name="ln1276">          &quot;Exif.Samsung2.WB_RGGBLevelsIlluminator1&quot;,</a>
<a name="ln1277">          &quot;Exif.Samsung2.WB_RGGBLevelsIlluminator2&quot;,</a>
<a name="ln1278">          &quot;Exif.Samsung2.WB_RGGBLevelsBlack&quot;,</a>
<a name="ln1279">          &quot;Exif.Samsung2.ColorMatrix&quot;,</a>
<a name="ln1280">          &quot;Exif.Samsung2.ColorMatrixSRGB&quot;,</a>
<a name="ln1281">          &quot;Exif.Samsung2.ColorMatrixAdobeRGB&quot;,</a>
<a name="ln1282">          &quot;Exif.Samsung2.ToneCurve1&quot;,</a>
<a name="ln1283">          &quot;Exif.Samsung2.ToneCurve2&quot;,</a>
<a name="ln1284">          &quot;Exif.Samsung2.ToneCurve3&quot;,</a>
<a name="ln1285">          &quot;Exif.Samsung2.ToneCurve4&quot;</a>
<a name="ln1286">        };</a>
<a name="ln1287">        static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1288">        dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1289">      }</a>
<a name="ln1290">#endif</a>
<a name="ln1291"> </a>
<a name="ln1292">      /* Write appropriate color space tag if using sRGB output */</a>
<a name="ln1293">      if(sRGB)</a>
<a name="ln1294">        exifData[&quot;Exif.Photo.ColorSpace&quot;] = uint16_t(1); /* sRGB */</a>
<a name="ln1295">      else</a>
<a name="ln1296">        exifData[&quot;Exif.Photo.ColorSpace&quot;] = uint16_t(0xFFFF); /* Uncalibrated */</a>
<a name="ln1297">    }</a>
<a name="ln1298"> </a>
<a name="ln1299">    /* Replace RAW dimension with output dimensions (for example after crop/scale, or orientation for dng</a>
<a name="ln1300">     * mode) */</a>
<a name="ln1301">    if(out_width &gt; 0) exifData[&quot;Exif.Photo.PixelXDimension&quot;] = (uint32_t)out_width;</a>
<a name="ln1302">    if(out_height &gt; 0) exifData[&quot;Exif.Photo.PixelYDimension&quot;] = (uint32_t)out_height;</a>
<a name="ln1303"> </a>
<a name="ln1304">    int resolution = dt_conf_get_int(&quot;metadata/resolution&quot;);</a>
<a name="ln1305">    if(resolution &gt; 0)</a>
<a name="ln1306">    {</a>
<a name="ln1307">      exifData[&quot;Exif.Image.XResolution&quot;] = Exiv2::Rational(resolution, 1);</a>
<a name="ln1308">      exifData[&quot;Exif.Image.YResolution&quot;] = Exiv2::Rational(resolution, 1);</a>
<a name="ln1309">      exifData[&quot;Exif.Image.ResolutionUnit&quot;] = uint16_t(2); /* inches */</a>
<a name="ln1310">    }</a>
<a name="ln1311">    else</a>
<a name="ln1312">    {</a>
<a name="ln1313">      static const char *keys[] = {</a>
<a name="ln1314">        &quot;Exif.Image.XResolution&quot;,</a>
<a name="ln1315">        &quot;Exif.Image.YResolution&quot;,</a>
<a name="ln1316">        &quot;Exif.Image.ResolutionUnit&quot;</a>
<a name="ln1317">      };</a>
<a name="ln1318">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1319">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1320">    }</a>
<a name="ln1321"> </a>
<a name="ln1322">    exifData[&quot;Exif.Image.Software&quot;] = darktable_package_string;</a>
<a name="ln1323"> </a>
<a name="ln1324">    // TODO: find a nice place for the missing metadata (tags, publisher, colorlabels?). Additionally find out</a>
<a name="ln1325">    // how to embed XMP data.</a>
<a name="ln1326">    //       And shall we add a description of the history stack to Exif.Image.ImageHistory?</a>
<a name="ln1327">    if(imgid &gt;= 0)</a>
<a name="ln1328">    {</a>
<a name="ln1329">      /* Delete metadata taken from the original file if it's fileds we manage in dt, too */</a>
<a name="ln1330">      static const char * keys[] = {</a>
<a name="ln1331">        &quot;Exif.Image.Artist&quot;,</a>
<a name="ln1332">        &quot;Exif.Image.ImageDescription&quot;,</a>
<a name="ln1333">        &quot;Exif.Photo.UserComment&quot;,</a>
<a name="ln1334">        &quot;Exif.Image.Copyright&quot;,</a>
<a name="ln1335">        &quot;Exif.Image.Rating&quot;,</a>
<a name="ln1336">        &quot;Exif.Image.RatingPercent&quot;,</a>
<a name="ln1337">        &quot;Exif.GPSInfo.GPSVersionID&quot;,</a>
<a name="ln1338">        &quot;Exif.GPSInfo.GPSLongitudeRef&quot;,</a>
<a name="ln1339">        &quot;Exif.GPSInfo.GPSLatitudeRef&quot;,</a>
<a name="ln1340">        &quot;Exif.GPSInfo.GPSLongitude&quot;,</a>
<a name="ln1341">        &quot;Exif.GPSInfo.GPSLatitude&quot;,</a>
<a name="ln1342">        &quot;Exif.GPSInfo.GPSAltitudeRef&quot;,</a>
<a name="ln1343">        &quot;Exif.GPSInfo.GPSAltitude&quot;</a>
<a name="ln1344">      };</a>
<a name="ln1345">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1346">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1347"> </a>
<a name="ln1348">      GList *res = dt_metadata_get(imgid, &quot;Xmp.dc.creator&quot;, NULL);</a>
<a name="ln1349">      if(res != NULL)</a>
<a name="ln1350">      {</a>
<a name="ln1351">        exifData[&quot;Exif.Image.Artist&quot;] = (char *)res-&gt;data;</a>
<a name="ln1352">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1353">      }</a>
<a name="ln1354"> </a>
<a name="ln1355">      res = dt_metadata_get(imgid, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln1356">      if(res != NULL)</a>
<a name="ln1357">      {</a>
<a name="ln1358">        char *desc = (char *)res-&gt;data;</a>
<a name="ln1359">        if(g_str_is_ascii(desc))</a>
<a name="ln1360">          exifData[&quot;Exif.Image.ImageDescription&quot;] = desc;</a>
<a name="ln1361">        else</a>
<a name="ln1362">          exifData[&quot;Exif.Photo.UserComment&quot;] = desc;</a>
<a name="ln1363">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1364">      }</a>
<a name="ln1365"> </a>
<a name="ln1366">      res = dt_metadata_get(imgid, &quot;Xmp.dc.rights&quot;, NULL);</a>
<a name="ln1367">      if(res != NULL)</a>
<a name="ln1368">      {</a>
<a name="ln1369">        exifData[&quot;Exif.Image.Copyright&quot;] = (char *)res-&gt;data;</a>
<a name="ln1370">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1371">      }</a>
<a name="ln1372"> </a>
<a name="ln1373">      res = dt_metadata_get(imgid, &quot;Xmp.xmp.Rating&quot;, NULL);</a>
<a name="ln1374">      if(res != NULL)</a>
<a name="ln1375">      {</a>
<a name="ln1376">        int rating = GPOINTER_TO_INT(res-&gt;data) + 1;</a>
<a name="ln1377">        exifData[&quot;Exif.Image.Rating&quot;] = rating;</a>
<a name="ln1378">        exifData[&quot;Exif.Image.RatingPercent&quot;] = int(rating / 5. * 100.);</a>
<a name="ln1379">        g_list_free(res);</a>
<a name="ln1380">      }</a>
<a name="ln1381"> </a>
<a name="ln1382">      // GPS data</a>
<a name="ln1383">      const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1384">      if(!std::isnan(cimg-&gt;geoloc.longitude) &amp;&amp; !std::isnan(cimg-&gt;geoloc.latitude))</a>
<a name="ln1385">      {</a>
<a name="ln1386">        exifData[&quot;Exif.GPSInfo.GPSVersionID&quot;] = &quot;02 02 00 00&quot;;</a>
<a name="ln1387">        exifData[&quot;Exif.GPSInfo.GPSLongitudeRef&quot;] = (cimg-&gt;geoloc.longitude &lt; 0) ? &quot;W&quot; : &quot;E&quot;;</a>
<a name="ln1388">        exifData[&quot;Exif.GPSInfo.GPSLatitudeRef&quot;] = (cimg-&gt;geoloc.latitude &lt; 0) ? &quot;S&quot; : &quot;N&quot;;</a>
<a name="ln1389"> </a>
<a name="ln1390">        long long_deg = (int)floor(fabs(cimg-&gt;geoloc.longitude));</a>
<a name="ln1391">        long lat_deg = (int)floor(fabs(cimg-&gt;geoloc.latitude));</a>
<a name="ln1392">        long long_min = (int)floor((fabs(cimg-&gt;geoloc.longitude) - floor(fabs(cimg-&gt;geoloc.longitude))) * 60000000);</a>
<a name="ln1393">        long lat_min = (int)floor((fabs(cimg-&gt;geoloc.latitude) - floor(fabs(cimg-&gt;geoloc.latitude))) * 60000000);</a>
<a name="ln1394">        gchar *long_str = g_strdup_printf(&quot;%ld/1 %ld/1000000 0/1&quot;, long_deg, long_min);</a>
<a name="ln1395">        gchar *lat_str = g_strdup_printf(&quot;%ld/1 %ld/1000000 0/1&quot;, lat_deg, lat_min);</a>
<a name="ln1396">        exifData[&quot;Exif.GPSInfo.GPSLongitude&quot;] = long_str;</a>
<a name="ln1397">        exifData[&quot;Exif.GPSInfo.GPSLatitude&quot;] = lat_str;</a>
<a name="ln1398">        g_free(long_str);</a>
<a name="ln1399">        g_free(lat_str);</a>
<a name="ln1400">      }</a>
<a name="ln1401">      if(!std::isnan(cimg-&gt;geoloc.elevation))</a>
<a name="ln1402">      {</a>
<a name="ln1403">        exifData[&quot;Exif.GPSInfo.GPSVersionID&quot;] = &quot;02 02 00 00&quot;;</a>
<a name="ln1404">        exifData[&quot;Exif.GPSInfo.GPSAltitudeRef&quot;] = (cimg-&gt;geoloc.elevation &lt; 0) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln1405"> </a>
<a name="ln1406">        long ele_dm = (int)floor(fabs(10.0 * cimg-&gt;geoloc.elevation));</a>
<a name="ln1407">        gchar *ele_str = g_strdup_printf(&quot;%ld/10&quot;, ele_dm);</a>
<a name="ln1408">        exifData[&quot;Exif.GPSInfo.GPSAltitude&quot;] = ele_str;</a>
<a name="ln1409">        g_free(ele_str);</a>
<a name="ln1410">      }</a>
<a name="ln1411"> </a>
<a name="ln1412">      // According to the Exif specs DateTime is to be set to the last modification time while</a>
<a name="ln1413">      // DateTimeOriginal is to be kept.</a>
<a name="ln1414">      // For us &quot;keeping&quot; it means to write out what we have in DB to support people adding a time offset in</a>
<a name="ln1415">      // the geotagging module.</a>
<a name="ln1416">      gchar new_datetime[20];</a>
<a name="ln1417">      dt_gettime(new_datetime, sizeof(new_datetime));</a>
<a name="ln1418">      exifData[&quot;Exif.Image.DateTime&quot;] = new_datetime;</a>
<a name="ln1419">      exifData[&quot;Exif.Image.DateTimeOriginal&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1420">      exifData[&quot;Exif.Photo.DateTimeOriginal&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1421">      // FIXME: What about DateTimeDigitized? we currently update it, too, which might not be what is expected</a>
<a name="ln1422">      // for scanned images</a>
<a name="ln1423">      exifData[&quot;Exif.Photo.DateTimeDigitized&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1424"> </a>
<a name="ln1425">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1426">    }</a>
<a name="ln1427"> </a>
<a name="ln1428">    Exiv2::Blob blob;</a>
<a name="ln1429">    Exiv2::ExifParser::encode(blob, Exiv2::bigEndian, exifData);</a>
<a name="ln1430">    const int length = blob.size();</a>
<a name="ln1431">    *buf = (uint8_t *)malloc(length+6);</a>
<a name="ln1432">    if (!*buf)</a>
<a name="ln1433">    {</a>
<a name="ln1434">      return 0;</a>
<a name="ln1435">    }</a>
<a name="ln1436">    memcpy(*buf, &quot;Exif\000\000&quot;, 6);</a>
<a name="ln1437">    memcpy(*buf + 6, &amp;(blob[0]), length);</a>
<a name="ln1438">    return length + 6;</a>
<a name="ln1439">  }</a>
<a name="ln1440">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1441">  {</a>
<a name="ln1442">    // std::cerr.rdbuf(savecerr);</a>
<a name="ln1443">    std::string s(e.what());</a>
<a name="ln1444">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1445">    free(*buf);</a>
<a name="ln1446">    *buf = NULL;</a>
<a name="ln1447">    return 0;</a>
<a name="ln1448">  }</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">// encode binary blob into text:</a>
<a name="ln1452">char *dt_exif_xmp_encode(const unsigned char *input, const int len, int *output_len)</a>
<a name="ln1453">{</a>
<a name="ln1454">#define COMPRESS_THRESHOLD 100</a>
<a name="ln1455"> </a>
<a name="ln1456">  gboolean do_compress = FALSE;</a>
<a name="ln1457"> </a>
<a name="ln1458">  // if input data field exceeds a certain size we compress it and convert to base64;</a>
<a name="ln1459">  // main reason for compression: make more xmp data fit into 64k segment within</a>
<a name="ln1460">  // JPEG output files.</a>
<a name="ln1461">  char *config = dt_conf_get_string(&quot;compress_xmp_tags&quot;);</a>
<a name="ln1462">  if(config)</a>
<a name="ln1463">  {</a>
<a name="ln1464">    if(!strcmp(config, &quot;always&quot;))</a>
<a name="ln1465">      do_compress = TRUE;</a>
<a name="ln1466">    else if((len &gt; COMPRESS_THRESHOLD) &amp;&amp; !strcmp(config, &quot;only large entries&quot;))</a>
<a name="ln1467">      do_compress = TRUE;</a>
<a name="ln1468">    else</a>
<a name="ln1469">      do_compress = FALSE;</a>
<a name="ln1470">    g_free(config);</a>
<a name="ln1471">  }</a>
<a name="ln1472"> </a>
<a name="ln1473">  return dt_exif_xmp_encode_internal(input, len, output_len, do_compress);</a>
<a name="ln1474"> </a>
<a name="ln1475">#undef COMPRESS_THRESHOLD</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478">char *dt_exif_xmp_encode_internal(const unsigned char *input, const int len, int *output_len, gboolean do_compress)</a>
<a name="ln1479">{</a>
<a name="ln1480">  char *output = NULL;</a>
<a name="ln1481"> </a>
<a name="ln1482">  if(do_compress)</a>
<a name="ln1483">  {</a>
<a name="ln1484">    int result;</a>
<a name="ln1485">    uLongf destLen = compressBound(len);</a>
<a name="ln1486">    unsigned char *buffer1 = (unsigned char *)malloc(destLen);</a>
<a name="ln1487"> </a>
<a name="ln1488">    result = compress(buffer1, &amp;destLen, input, len);</a>
<a name="ln1489"> </a>
<a name="ln1490">    if(result != Z_OK)</a>
<a name="ln1491">    {</a>
<a name="ln1492">      free(buffer1);</a>
<a name="ln1493">      return NULL;</a>
<a name="ln1494">    }</a>
<a name="ln1495"> </a>
<a name="ln1496">    // we store the compression factor</a>
<a name="ln1497">    const int factor = MIN(len / destLen + 1, 99);</a>
<a name="ln1498"> </a>
<a name="ln1499">    char *buffer2 = (char *)g_base64_encode(buffer1, destLen);</a>
<a name="ln1500">    free(buffer1);</a>
<a name="ln1501">    if(!buffer2) return NULL;</a>
<a name="ln1502"> </a>
<a name="ln1503">    int outlen = strlen(buffer2) + 5; // leading &quot;gz&quot; + compression factor + base64 string + trailing '\0'</a>
<a name="ln1504">    output = (char *)malloc(outlen);</a>
<a name="ln1505">    if(!output)</a>
<a name="ln1506">    {</a>
<a name="ln1507">      g_free(buffer2);</a>
<a name="ln1508">      return NULL;</a>
<a name="ln1509">    }</a>
<a name="ln1510"> </a>
<a name="ln1511">    output[0] = 'g';</a>
<a name="ln1512">    output[1] = 'z';</a>
<a name="ln1513">    output[2] = factor / 10 + '0';</a>
<a name="ln1514">    output[3] = factor % 10 + '0';</a>
<a name="ln1515">    g_strlcpy(output + 4, buffer2, outlen);</a>
<a name="ln1516">    g_free(buffer2);</a>
<a name="ln1517"> </a>
<a name="ln1518">    if(output_len) *output_len = outlen;</a>
<a name="ln1519">  }</a>
<a name="ln1520">  else</a>
<a name="ln1521">  {</a>
<a name="ln1522">    const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };</a>
<a name="ln1523"> </a>
<a name="ln1524">    output = (char *)malloc(2 * len + 1);</a>
<a name="ln1525">    if(!output) return NULL;</a>
<a name="ln1526"> </a>
<a name="ln1527">    if(output_len) *output_len = 2 * len + 1;</a>
<a name="ln1528"> </a>
<a name="ln1529">    for(int i = 0; i &lt; len; i++)</a>
<a name="ln1530">    {</a>
<a name="ln1531">      const int hi = input[i] &gt;&gt; 4;</a>
<a name="ln1532">      const int lo = input[i] &amp; 15;</a>
<a name="ln1533">      output[2 * i] = hex[hi];</a>
<a name="ln1534">      output[2 * i + 1] = hex[lo];</a>
<a name="ln1535">    }</a>
<a name="ln1536">    output[2 * len] = '\0';</a>
<a name="ln1537">  }</a>
<a name="ln1538"> </a>
<a name="ln1539">  return output;</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542">// and back to binary</a>
<a name="ln1543">unsigned char *dt_exif_xmp_decode(const char *input, const int len, int *output_len)</a>
<a name="ln1544">{</a>
<a name="ln1545">  unsigned char *output = NULL;</a>
<a name="ln1546"> </a>
<a name="ln1547">  // check if data is in compressed format</a>
<a name="ln1548">  if(!strncmp(input, &quot;gz&quot;, 2))</a>
<a name="ln1549">  {</a>
<a name="ln1550">    // we have compressed data in base64 representation with leading &quot;gz&quot;</a>
<a name="ln1551"> </a>
<a name="ln1552">    // get stored compression factor so we know the needed buffer size for uncompress</a>
<a name="ln1553">    const float factor = 10 * (input[2] - '0') + (input[3] - '0');</a>
<a name="ln1554"> </a>
<a name="ln1555">    // get a rw copy of input buffer omitting leading &quot;gz&quot; and compression factor</a>
<a name="ln1556">    unsigned char *buffer = (unsigned char *)strdup(input + 4);</a>
<a name="ln1557">    if(!buffer) return NULL;</a>
<a name="ln1558"> </a>
<a name="ln1559">    // decode from base64 to compressed binary</a>
<a name="ln1560">    gsize compressed_size;</a>
<a name="ln1561">    g_base64_decode_inplace((char *)buffer, &amp;compressed_size);</a>
<a name="ln1562"> </a>
<a name="ln1563">    // do the actual uncompress step</a>
<a name="ln1564">    int result = Z_BUF_ERROR;</a>
<a name="ln1565">    uLongf bufLen = factor * compressed_size;</a>
<a name="ln1566">    uLongf destLen;</a>
<a name="ln1567"> </a>
<a name="ln1568">    // we know the actual compression factor but if that fails we re-try with</a>
<a name="ln1569">    // increasing buffer sizes, eg. we don't know (unlikely) factors &gt; 99</a>
<a name="ln1570">    do</a>
<a name="ln1571">    {</a>
<a name="ln1572">      if(output) free(output);</a>
<a name="ln1573">      output = (unsigned char *)malloc(bufLen);</a>
<a name="ln1574">      if(!output) break;</a>
<a name="ln1575"> </a>
<a name="ln1576">      destLen = bufLen;</a>
<a name="ln1577"> </a>
<a name="ln1578">      result = uncompress(output, &amp;destLen, buffer, compressed_size);</a>
<a name="ln1579"> </a>
<a name="ln1580">      bufLen *= 2;</a>
<a name="ln1581"> </a>
<a name="ln1582">    } while(result == Z_BUF_ERROR);</a>
<a name="ln1583"> </a>
<a name="ln1584"> </a>
<a name="ln1585">    free(buffer);</a>
<a name="ln1586"> </a>
<a name="ln1587">    if(result != Z_OK)</a>
<a name="ln1588">    {</a>
<a name="ln1589">      if(output) free(output);</a>
<a name="ln1590">      return NULL;</a>
<a name="ln1591">    }</a>
<a name="ln1592"> </a>
<a name="ln1593">    if(output_len) *output_len = destLen;</a>
<a name="ln1594">  }</a>
<a name="ln1595">  else</a>
<a name="ln1596">  {</a>
<a name="ln1597">// we have uncompressed data in hexadecimal ascii representation</a>
<a name="ln1598"> </a>
<a name="ln1599">// ascii table:</a>
<a name="ln1600">// 48- 57 0-9</a>
<a name="ln1601">// 97-102 a-f</a>
<a name="ln1602">#define TO_BINARY(a) (a &gt; 57 ? a - 97 + 10 : a - 48)</a>
<a name="ln1603"> </a>
<a name="ln1604">    // make sure that we don't find any unexpected characters indicating corrupted data</a>
<a name="ln1605">    if(strspn(input, &quot;0123456789abcdef&quot;) != strlen(input)) return NULL;</a>
<a name="ln1606"> </a>
<a name="ln1607">    output = (unsigned char *)malloc(len / 2);</a>
<a name="ln1608">    if(!output) return NULL;</a>
<a name="ln1609"> </a>
<a name="ln1610">    if(output_len) *output_len = len / 2;</a>
<a name="ln1611"> </a>
<a name="ln1612">    for(int i = 0; i &lt; len / 2; i++)</a>
<a name="ln1613">    {</a>
<a name="ln1614">      const int hi = TO_BINARY(input[2 * i]);</a>
<a name="ln1615">      const int lo = TO_BINARY(input[2 * i + 1]);</a>
<a name="ln1616">      output[i] = (hi &lt;&lt; 4) | lo;</a>
<a name="ln1617">    }</a>
<a name="ln1618">#undef TO_BINARY</a>
<a name="ln1619">  }</a>
<a name="ln1620"> </a>
<a name="ln1621">  return output;</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">static void _exif_import_tags(dt_image_t *img, Exiv2::XmpData::iterator &amp;pos)</a>
<a name="ln1625">{</a>
<a name="ln1626">  // tags in array</a>
<a name="ln1627">  const int cnt = pos-&gt;count();</a>
<a name="ln1628"> </a>
<a name="ln1629">  sqlite3_stmt *stmt_sel_id, *stmt_ins_tags, *stmt_ins_tagged;</a>
<a name="ln1630">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM data.tags WHERE name = ?1&quot;, -1,</a>
<a name="ln1631">                              &amp;stmt_sel_id, NULL);</a>
<a name="ln1632">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;INSERT INTO data.tags (id, name) VALUES (NULL, ?1)&quot;,</a>
<a name="ln1633">                              -1, &amp;stmt_ins_tags, NULL);</a>
<a name="ln1634">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1635">                              &quot;INSERT INTO main.tagged_images (tagid, imgid) VALUES (?1, ?2)&quot;, -1,</a>
<a name="ln1636">                              &amp;stmt_ins_tagged, NULL);</a>
<a name="ln1637">  for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln1638">  {</a>
<a name="ln1639">    char tagbuf[1024];</a>
<a name="ln1640">    std::string pos_str = pos-&gt;toString(i);</a>
<a name="ln1641">    g_strlcpy(tagbuf, pos_str.c_str(), sizeof(tagbuf));</a>
<a name="ln1642">    int tagid = -1;</a>
<a name="ln1643">    char *tag = tagbuf;</a>
<a name="ln1644">    while(tag)</a>
<a name="ln1645">    {</a>
<a name="ln1646">      char *next_tag = strstr(tag, &quot;,&quot;);</a>
<a name="ln1647">      if(next_tag) *(next_tag++) = 0;</a>
<a name="ln1648">      // check if tag is available, get its id:</a>
<a name="ln1649">      for(int k = 0; k &lt; 2; k++)</a>
<a name="ln1650">      {</a>
<a name="ln1651">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt_sel_id, 1, tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1652">        if(sqlite3_step(stmt_sel_id) == SQLITE_ROW) tagid = sqlite3_column_int(stmt_sel_id, 0);</a>
<a name="ln1653">        sqlite3_reset(stmt_sel_id);</a>
<a name="ln1654">        sqlite3_clear_bindings(stmt_sel_id);</a>
<a name="ln1655"> </a>
<a name="ln1656">        if(tagid &gt; 0) break;</a>
<a name="ln1657"> </a>
<a name="ln1658">        fprintf(stderr, &quot;[xmp_import] creating tag: %s\n&quot;, tag);</a>
<a name="ln1659">        // create this tag (increment id, leave icon empty), retry.</a>
<a name="ln1660">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt_ins_tags, 1, tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1661">        sqlite3_step(stmt_ins_tags);</a>
<a name="ln1662">        sqlite3_reset(stmt_ins_tags);</a>
<a name="ln1663">        sqlite3_clear_bindings(stmt_ins_tags);</a>
<a name="ln1664">      }</a>
<a name="ln1665">      // associate image and tag.</a>
<a name="ln1666">      DT_DEBUG_SQLITE3_BIND_INT(stmt_ins_tagged, 1, tagid);</a>
<a name="ln1667">      DT_DEBUG_SQLITE3_BIND_INT(stmt_ins_tagged, 2, img-&gt;id);</a>
<a name="ln1668">      sqlite3_step(stmt_ins_tagged);</a>
<a name="ln1669">      sqlite3_reset(stmt_ins_tagged);</a>
<a name="ln1670">      sqlite3_clear_bindings(stmt_ins_tagged);</a>
<a name="ln1671"> </a>
<a name="ln1672">      tag = next_tag;</a>
<a name="ln1673">    }</a>
<a name="ln1674">  }</a>
<a name="ln1675">  sqlite3_finalize(stmt_sel_id);</a>
<a name="ln1676">  sqlite3_finalize(stmt_ins_tags);</a>
<a name="ln1677">  sqlite3_finalize(stmt_ins_tagged);</a>
<a name="ln1678"> </a>
<a name="ln1679">  // update used_tags</a>
<a name="ln1680">  dt_tag_update_used_tags();</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">typedef struct history_entry_t</a>
<a name="ln1684">{</a>
<a name="ln1685">  char *operation;</a>
<a name="ln1686">  gboolean enabled;</a>
<a name="ln1687">  int modversion;</a>
<a name="ln1688">  unsigned char *params;</a>
<a name="ln1689">  int params_len;</a>
<a name="ln1690">  char *multi_name;</a>
<a name="ln1691">  int multi_priority;</a>
<a name="ln1692">  int blendop_version;</a>
<a name="ln1693">  unsigned char *blendop_params;</a>
<a name="ln1694">  int blendop_params_len;</a>
<a name="ln1695">  int num;</a>
<a name="ln1696">  double iop_order;</a>
<a name="ln1697"> </a>
<a name="ln1698">  // sanity checking</a>
<a name="ln1699">  gboolean have_operation, have_params, have_modversion;</a>
<a name="ln1700">} history_entry_t;</a>
<a name="ln1701"> </a>
<a name="ln1702">// used for a hash table that maps mask_id to the mask data</a>
<a name="ln1703">typedef struct mask_entry_t</a>
<a name="ln1704">{</a>
<a name="ln1705">  int mask_id;</a>
<a name="ln1706">  int mask_type;</a>
<a name="ln1707">  char *mask_name;</a>
<a name="ln1708">  int mask_version;</a>
<a name="ln1709">  unsigned char *mask_points;</a>
<a name="ln1710">  int mask_points_len;</a>
<a name="ln1711">  int mask_nb;</a>
<a name="ln1712">  unsigned char *mask_src;</a>
<a name="ln1713">  int mask_src_len;</a>
<a name="ln1714">  gboolean already_added;</a>
<a name="ln1715">  int mask_num;</a>
<a name="ln1716">  int version;</a>
<a name="ln1717">} mask_entry_t;</a>
<a name="ln1718"> </a>
<a name="ln1719">static void print_history_entry(history_entry_t *entry) __attribute__((unused));</a>
<a name="ln1720">static void print_history_entry(history_entry_t *entry)</a>
<a name="ln1721">{</a>
<a name="ln1722">  if(!entry || !entry-&gt;operation)</a>
<a name="ln1723">  {</a>
<a name="ln1724">    std::cout &lt;&lt; &quot;malformed entry&quot; &lt;&lt; std::endl;</a>
<a name="ln1725">    return;</a>
<a name="ln1726">  }</a>
<a name="ln1727"> </a>
<a name="ln1728">  std::cout &lt;&lt; entry-&gt;operation &lt;&lt; std::endl;</a>
<a name="ln1729">  std::cout &lt;&lt; &quot;  modversion      :&quot; &lt;&lt;  entry-&gt;modversion                                    &lt;&lt; std::endl;</a>
<a name="ln1730">  std::cout &lt;&lt; &quot;  enabled         :&quot; &lt;&lt;  entry-&gt;enabled                                       &lt;&lt; std::endl;</a>
<a name="ln1731">  std::cout &lt;&lt; &quot;  params          :&quot; &lt;&lt; (entry-&gt;params ? &quot;&lt;found&gt;&quot; : &quot;&lt;missing&gt;&quot;)             &lt;&lt; std::endl;</a>
<a name="ln1732">  std::cout &lt;&lt; &quot;  multi_name      :&quot; &lt;&lt; (entry-&gt;multi_name ? entry-&gt;multi_name : &quot;&lt;missing&gt;&quot;) &lt;&lt; std::endl;</a>
<a name="ln1733">  std::cout &lt;&lt; &quot;  multi_priority  :&quot; &lt;&lt;  entry-&gt;multi_priority                                &lt;&lt; std::endl;</a>
<a name="ln1734">  std::cout &lt;&lt; &quot;  iop_order       :&quot; &lt;&lt; entry-&gt;iop_order                                      &lt;&lt; std::endl;</a>
<a name="ln1735">  std::cout &lt;&lt; &quot;  blendop_version :&quot; &lt;&lt;  entry-&gt;blendop_version                               &lt;&lt; std::endl;</a>
<a name="ln1736">  std::cout &lt;&lt; &quot;  blendop_params  :&quot; &lt;&lt; (entry-&gt;blendop_params ? &quot;&lt;found&gt;&quot; : &quot;&lt;missing&gt;&quot;)     &lt;&lt; std::endl;</a>
<a name="ln1737">  std::cout &lt;&lt; std::endl;</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">static void free_history_entry(gpointer data)</a>
<a name="ln1741">{</a>
<a name="ln1742">  history_entry_t *entry = (history_entry_t *)data;</a>
<a name="ln1743">  g_free(entry-&gt;operation);</a>
<a name="ln1744">  g_free(entry-&gt;multi_name);</a>
<a name="ln1745">  free(entry-&gt;params);</a>
<a name="ln1746">  free(entry-&gt;blendop_params);</a>
<a name="ln1747">  free(entry);</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">// we have to use pugixml as the old format could contain empty rdf:li elements in the multi_name array</a>
<a name="ln1751">// which causes problems when accessing it with libexiv2 :(</a>
<a name="ln1752">// superold is a flag indicating that data is wrapped in &lt;rdf:Bag&gt; instead of &lt;rdf:Seq&gt;.</a>
<a name="ln1753">static GList *read_history_v1(const std::string &amp;xmpPacket, const char *filename, const int superold)</a>
<a name="ln1754">{</a>
<a name="ln1755">  GList *history_entries = NULL;</a>
<a name="ln1756"> </a>
<a name="ln1757">  pugi::xml_document doc;</a>
<a name="ln1758">#if defined(PUGIXML_VERSION) &amp;&amp; PUGIXML_VERSION &gt;= 150</a>
<a name="ln1759">  pugi::xml_parse_result result = doc.load_string(xmpPacket.c_str());</a>
<a name="ln1760">#else</a>
<a name="ln1761">  pugi::xml_parse_result result = doc.load(xmpPacket.c_str());</a>
<a name="ln1762">#endif</a>
<a name="ln1763"> </a>
<a name="ln1764">  if(!result)</a>
<a name="ln1765">  {</a>
<a name="ln1766">    std::cerr &lt;&lt; &quot;XML '&quot; &lt;&lt; filename &lt;&lt; &quot;' parsed with errors&quot; &lt;&lt; std::endl;</a>
<a name="ln1767">    std::cerr &lt;&lt; &quot;Error description: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;</a>
<a name="ln1768">    std::cerr &lt;&lt; &quot;Error offset: &quot; &lt;&lt; result.offset &lt;&lt; std::endl;</a>
<a name="ln1769">    return NULL;</a>
<a name="ln1770">  }</a>
<a name="ln1771"> </a>
<a name="ln1772">  // get the old elements</a>
<a name="ln1773">  // select_single_node() is deprecated and just kept for old versions shipped in some distributions</a>
<a name="ln1774">#if defined(PUGIXML_VERSION) &amp;&amp; PUGIXML_VERSION &gt;= 150</a>
<a name="ln1775">  pugi::xpath_node modversion      = superold ?</a>
<a name="ln1776">    doc.select_node(&quot;//darktable:history_modversion/rdf:Bag&quot;):</a>
<a name="ln1777">    doc.select_node(&quot;//darktable:history_modversion/rdf:Seq&quot;);</a>
<a name="ln1778">  pugi::xpath_node enabled         = superold ?</a>
<a name="ln1779">    doc.select_node(&quot;//darktable:history_enabled/rdf:Bag&quot;):</a>
<a name="ln1780">    doc.select_node(&quot;//darktable:history_enabled/rdf:Seq&quot;);</a>
<a name="ln1781">  pugi::xpath_node operation       = superold ?</a>
<a name="ln1782">    doc.select_node(&quot;//darktable:history_operation/rdf:Bag&quot;):</a>
<a name="ln1783">    doc.select_node(&quot;//darktable:history_operation/rdf:Seq&quot;);</a>
<a name="ln1784">  pugi::xpath_node params          = superold ?</a>
<a name="ln1785">    doc.select_node(&quot;//darktable:history_params/rdf:Bag&quot;):</a>
<a name="ln1786">    doc.select_node(&quot;//darktable:history_params/rdf:Seq&quot;);</a>
<a name="ln1787">  pugi::xpath_node blendop_params  = superold ?</a>
<a name="ln1788">    doc.select_node(&quot;//darktable:blendop_params/rdf:Bag&quot;):</a>
<a name="ln1789">    doc.select_node(&quot;//darktable:blendop_params/rdf:Seq&quot;);</a>
<a name="ln1790">  pugi::xpath_node blendop_version = superold ?</a>
<a name="ln1791">    doc.select_node(&quot;//darktable:blendop_version/rdf:Bag&quot;):</a>
<a name="ln1792">    doc.select_node(&quot;//darktable:blendop_version/rdf:Seq&quot;);</a>
<a name="ln1793">  pugi::xpath_node multi_priority  = superold ?</a>
<a name="ln1794">    doc.select_node(&quot;//darktable:multi_priority/rdf:Bag&quot;):</a>
<a name="ln1795">    doc.select_node(&quot;//darktable:multi_priority/rdf:Seq&quot;);</a>
<a name="ln1796">  pugi::xpath_node multi_name      = superold ?</a>
<a name="ln1797">    doc.select_node(&quot;//darktable:multi_name/rdf:Bag&quot;):</a>
<a name="ln1798">    doc.select_node(&quot;//darktable:multi_name/rdf:Bag&quot;);</a>
<a name="ln1799">#else</a>
<a name="ln1800">  pugi::xpath_node modversion      = superold ?</a>
<a name="ln1801">    doc.select_single_node(&quot;//darktable:history_modversion/rdf:Bag&quot;):</a>
<a name="ln1802">    doc.select_single_node(&quot;//darktable:history_modversion/rdf:Seq&quot;);</a>
<a name="ln1803">  pugi::xpath_node enabled         = superold ?</a>
<a name="ln1804">    doc.select_single_node(&quot;//darktable:history_enabled/rdf:Bag&quot;):</a>
<a name="ln1805">    doc.select_single_node(&quot;//darktable:history_enabled/rdf:Seq&quot;);</a>
<a name="ln1806">  pugi::xpath_node operation       = superold ?</a>
<a name="ln1807">    doc.select_single_node(&quot;//darktable:history_operation/rdf:Bag&quot;):</a>
<a name="ln1808">    doc.select_single_node(&quot;//darktable:history_operation/rdf:Seq&quot;);</a>
<a name="ln1809">  pugi::xpath_node params          = superold ?</a>
<a name="ln1810">    doc.select_single_node(&quot;//darktable:history_params/rdf:Bag&quot;):</a>
<a name="ln1811">    doc.select_single_node(&quot;//darktable:history_params/rdf:Seq&quot;);</a>
<a name="ln1812">  pugi::xpath_node blendop_params  = superold ?</a>
<a name="ln1813">    doc.select_single_node(&quot;//darktable:blendop_params/rdf:Bag&quot;):</a>
<a name="ln1814">    doc.select_single_node(&quot;//darktable:blendop_params/rdf:Seq&quot;);</a>
<a name="ln1815">  pugi::xpath_node blendop_version = superold ?</a>
<a name="ln1816">    doc.select_single_node(&quot;//darktable:blendop_version/rdf:Bag&quot;):</a>
<a name="ln1817">    doc.select_single_node(&quot;//darktable:blendop_version/rdf:Seq&quot;);</a>
<a name="ln1818">  pugi::xpath_node multi_priority  = superold ?</a>
<a name="ln1819">    doc.select_single_node(&quot;//darktable:multi_priority/rdf:Bag&quot;):</a>
<a name="ln1820">    doc.select_single_node(&quot;//darktable:multi_priority/rdf:Seq&quot;);</a>
<a name="ln1821">  pugi::xpath_node multi_name      = superold ?</a>
<a name="ln1822">    doc.select_single_node(&quot;//darktable:multi_name/rdf:Bag&quot;):</a>
<a name="ln1823">    doc.select_single_node(&quot;//darktable:multi_name/rdf:Bag&quot;);</a>
<a name="ln1824">#endif</a>
<a name="ln1825"> </a>
<a name="ln1826">  // fill the list of history entries. we are iterating over history_operation as we know that it's there.</a>
<a name="ln1827">  // the other iters are taken care of manually.</a>
<a name="ln1828">  auto modversion_iter = modversion.node().children().begin();</a>
<a name="ln1829">  auto enabled_iter = enabled.node().children().begin();</a>
<a name="ln1830">  auto params_iter = params.node().children().begin();</a>
<a name="ln1831">  auto blendop_params_iter = blendop_params.node().children().begin();</a>
<a name="ln1832">  auto blendop_version_iter = blendop_version.node().children().begin();</a>
<a name="ln1833">  auto multi_priority_iter = multi_priority.node().children().begin();</a>
<a name="ln1834">  auto multi_name_iter = multi_name.node().children().begin();</a>
<a name="ln1835"> </a>
<a name="ln1836">  for(pugi::xml_node operation_iter: operation.node().children())</a>
<a name="ln1837">  {</a>
<a name="ln1838">    history_entry_t *current_entry = (history_entry_t *)calloc(1, sizeof(history_entry_t));</a>
<a name="ln1839">    current_entry-&gt;blendop_version = 1; // default version in case it's not specified</a>
<a name="ln1840">    history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln1841"> </a>
<a name="ln1842">    current_entry-&gt;operation = g_strdup(operation_iter.child_value());</a>
<a name="ln1843"> </a>
<a name="ln1844">    current_entry-&gt;enabled = g_strcmp0(enabled_iter-&gt;child_value(), &quot;0&quot;) != 0;</a>
<a name="ln1845"> </a>
<a name="ln1846">    current_entry-&gt;modversion = atoi(modversion_iter-&gt;child_value());</a>
<a name="ln1847"> </a>
<a name="ln1848">    current_entry-&gt;params = dt_exif_xmp_decode(params_iter-&gt;child_value(), strlen(params_iter-&gt;child_value()),</a>
<a name="ln1849">                                               &amp;current_entry-&gt;params_len);</a>
<a name="ln1850"> </a>
<a name="ln1851">    if(multi_name &amp;&amp; multi_name_iter != multi_name.node().children().end())</a>
<a name="ln1852">    {</a>
<a name="ln1853">      current_entry-&gt;multi_name = g_strdup(multi_name_iter-&gt;child_value());</a>
<a name="ln1854">      multi_name_iter++;</a>
<a name="ln1855">    }</a>
<a name="ln1856"> </a>
<a name="ln1857">    if(multi_priority &amp;&amp; multi_priority_iter != multi_priority.node().children().end())</a>
<a name="ln1858">    {</a>
<a name="ln1859">      current_entry-&gt;multi_priority = atoi(multi_priority_iter-&gt;child_value());</a>
<a name="ln1860">      multi_priority_iter++;</a>
<a name="ln1861">    }</a>
<a name="ln1862"> </a>
<a name="ln1863">    if(blendop_version &amp;&amp; blendop_version_iter != blendop_version.node().children().end())</a>
<a name="ln1864">    {</a>
<a name="ln1865">      current_entry-&gt;blendop_version = atoi(blendop_version_iter-&gt;child_value());</a>
<a name="ln1866">      blendop_version_iter++;</a>
<a name="ln1867">    }</a>
<a name="ln1868"> </a>
<a name="ln1869">    if(blendop_params &amp;&amp; blendop_params_iter != blendop_params.node().children().end())</a>
<a name="ln1870">    {</a>
<a name="ln1871">      current_entry-&gt;blendop_params = dt_exif_xmp_decode(blendop_params_iter-&gt;child_value(),</a>
<a name="ln1872">                                                         strlen(blendop_params_iter-&gt;child_value()),</a>
<a name="ln1873">                                                         &amp;current_entry-&gt;blendop_params_len);</a>
<a name="ln1874">      blendop_params_iter++;</a>
<a name="ln1875">    }</a>
<a name="ln1876"> </a>
<a name="ln1877">    current_entry-&gt;iop_order = -1.0;</a>
<a name="ln1878"> </a>
<a name="ln1879">    modversion_iter++;</a>
<a name="ln1880">    enabled_iter++;</a>
<a name="ln1881">    params_iter++;</a>
<a name="ln1882">  }</a>
<a name="ln1883"> </a>
<a name="ln1884">  return history_entries;</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">static GList *read_history_v2(Exiv2::XmpData &amp;xmpData, const char *filename)</a>
<a name="ln1888">{</a>
<a name="ln1889">  GList *history_entries = NULL;</a>
<a name="ln1890">  history_entry_t *current_entry = NULL;</a>
<a name="ln1891"> </a>
<a name="ln1892">  for(auto history = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.history&quot;)); history != xmpData.end(); history++)</a>
<a name="ln1893">  {</a>
<a name="ln1894">    // TODO: support human readable params via introspection with something like this:</a>
<a name="ln1895">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:name = width</a>
<a name="ln1896">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:value = 23</a>
<a name="ln1897"> </a>
<a name="ln1898">    char *key = g_strdup(history-&gt;key().c_str());</a>
<a name="ln1899">    char *key_iter = key;</a>
<a name="ln1900">    if(g_str_has_prefix(key, &quot;Xmp.darktable.history[&quot;))</a>
<a name="ln1901">    {</a>
<a name="ln1902">      key_iter += strlen(&quot;Xmp.darktable.history[&quot;);</a>
<a name="ln1903">      errno = 0;</a>
<a name="ln1904">      unsigned int n = strtol(key_iter, &amp;key_iter, 10);</a>
<a name="ln1905">      if(errno)</a>
<a name="ln1906">      {</a>
<a name="ln1907">        std::cerr &lt;&lt; &quot;error reading history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1908">        g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln1909">        g_free(key);</a>
<a name="ln1910">        return NULL;</a>
<a name="ln1911">      }</a>
<a name="ln1912"> </a>
<a name="ln1913">      // skip everything that isn't part of the actual array</a>
<a name="ln1914">      if(*(key_iter++) != ']')</a>
<a name="ln1915">      {</a>
<a name="ln1916">        std::cerr &lt;&lt; &quot;error reading history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln1917">        g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln1918">        g_free(key);</a>
<a name="ln1919">        return NULL;</a>
<a name="ln1920">      }</a>
<a name="ln1921">      if(*(key_iter++) != '/') goto skip;</a>
<a name="ln1922">      if(*key_iter == '?') key_iter++;</a>
<a name="ln1923"> </a>
<a name="ln1924">      // make sure we are filling in the details of the correct entry</a>
<a name="ln1925">      unsigned int length = g_list_length(history_entries);</a>
<a name="ln1926">      if(n &gt; length)</a>
<a name="ln1927">      {</a>
<a name="ln1928">        current_entry = (history_entry_t *)calloc(1, sizeof(history_entry_t));</a>
<a name="ln1929">        current_entry-&gt;blendop_version = 1; // default version in case it's not specified</a>
<a name="ln1930">        current_entry-&gt;iop_order = -1.0;</a>
<a name="ln1931">        history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln1932">      }</a>
<a name="ln1933">      else if(n &lt; length)</a>
<a name="ln1934">      {</a>
<a name="ln1935">        // AFAICT this can't happen with regular exiv2 parsed XMP data, but better safe than sorry.</a>
<a name="ln1936">        // it can happen though when constructing things in a unusual order and then passing it to us without</a>
<a name="ln1937">        // serializing it in between</a>
<a name="ln1938">        current_entry = (history_entry_t *)g_list_nth_data(history_entries, n - 1); // XMP starts counting at 1!</a>
<a name="ln1939">      }</a>
<a name="ln1940"> </a>
<a name="ln1941">      // go on reading things into current_entry</a>
<a name="ln1942">      if(g_str_has_prefix(key_iter, &quot;darktable:operation&quot;))</a>
<a name="ln1943">      {</a>
<a name="ln1944">        current_entry-&gt;have_operation = TRUE;</a>
<a name="ln1945">        current_entry-&gt;operation = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln1946">      }</a>
<a name="ln1947">      else if(g_str_has_prefix(key_iter, &quot;darktable:num&quot;))</a>
<a name="ln1948">      {</a>
<a name="ln1949">        current_entry-&gt;num = history-&gt;value().toLong();</a>
<a name="ln1950">      }</a>
<a name="ln1951">      else if(g_str_has_prefix(key_iter, &quot;darktable:enabled&quot;))</a>
<a name="ln1952">      {</a>
<a name="ln1953">        current_entry-&gt;enabled = history-&gt;value().toLong() == 1;</a>
<a name="ln1954">      }</a>
<a name="ln1955">      else if(g_str_has_prefix(key_iter, &quot;darktable:modversion&quot;))</a>
<a name="ln1956">      {</a>
<a name="ln1957">        current_entry-&gt;have_modversion = TRUE;</a>
<a name="ln1958">        current_entry-&gt;modversion = history-&gt;value().toLong();</a>
<a name="ln1959">      }</a>
<a name="ln1960">      else if(g_str_has_prefix(key_iter, &quot;darktable:params&quot;))</a>
<a name="ln1961">      {</a>
<a name="ln1962">        current_entry-&gt;have_params = TRUE;</a>
<a name="ln1963">        current_entry-&gt;params = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(),</a>
<a name="ln1964">                                                   &amp;current_entry-&gt;params_len);</a>
<a name="ln1965">      }</a>
<a name="ln1966">      else if(g_str_has_prefix(key_iter, &quot;darktable:multi_name&quot;))</a>
<a name="ln1967">      {</a>
<a name="ln1968">        current_entry-&gt;multi_name = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln1969">      }</a>
<a name="ln1970">      else if(g_str_has_prefix(key_iter, &quot;darktable:multi_priority&quot;))</a>
<a name="ln1971">      {</a>
<a name="ln1972">        current_entry-&gt;multi_priority = history-&gt;value().toLong();</a>
<a name="ln1973">      }</a>
<a name="ln1974">      else if(g_str_has_prefix(key_iter, &quot;darktable:iop_order&quot;))</a>
<a name="ln1975">      {</a>
<a name="ln1976">        current_entry-&gt;iop_order = history-&gt;value().toFloat();</a>
<a name="ln1977">      }</a>
<a name="ln1978">      else if(g_str_has_prefix(key_iter, &quot;darktable:blendop_version&quot;))</a>
<a name="ln1979">      {</a>
<a name="ln1980">        current_entry-&gt;blendop_version = history-&gt;value().toLong();</a>
<a name="ln1981">      }</a>
<a name="ln1982">      else if(g_str_has_prefix(key_iter, &quot;darktable:blendop_params&quot;))</a>
<a name="ln1983">      {</a>
<a name="ln1984">        current_entry-&gt;blendop_params = dt_exif_xmp_decode(history-&gt;value().toString().c_str(),</a>
<a name="ln1985">                                                           history-&gt;value().size(),</a>
<a name="ln1986">                                                           &amp;current_entry-&gt;blendop_params_len);</a>
<a name="ln1987">      }</a>
<a name="ln1988">    }</a>
<a name="ln1989">skip:</a>
<a name="ln1990">    g_free(key);</a>
<a name="ln1991">  }</a>
<a name="ln1992"> </a>
<a name="ln1993">  // a final sanity check</a>
<a name="ln1994">  for(GList *iter = history_entries; iter; iter = g_list_next(iter))</a>
<a name="ln1995">  {</a>
<a name="ln1996">    history_entry_t *entry = (history_entry_t *)iter-&gt;data;</a>
<a name="ln1997">    if(!(entry-&gt;have_operation &amp;&amp; entry-&gt;have_params &amp;&amp; entry-&gt;have_modversion))</a>
<a name="ln1998">    {</a>
<a name="ln1999">      std::cerr &lt;&lt; &quot;[exif] error: reading history from '&quot; &lt;&lt; filename &lt;&lt; &quot;' failed due to missing tags&quot; &lt;&lt; std::endl;</a>
<a name="ln2000">      g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2001">      history_entries = NULL;</a>
<a name="ln2002">      break;</a>
<a name="ln2003">    }</a>
<a name="ln2004">  }</a>
<a name="ln2005"> </a>
<a name="ln2006">  return history_entries;</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">void free_mask_entry(gpointer data)</a>
<a name="ln2010">{</a>
<a name="ln2011">  mask_entry_t *entry = (mask_entry_t *)data;</a>
<a name="ln2012">  g_free(entry-&gt;mask_name);</a>
<a name="ln2013">  free(entry-&gt;mask_points);</a>
<a name="ln2014">  free(entry-&gt;mask_src);</a>
<a name="ln2015">  free(entry);</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018">static GHashTable *read_masks(Exiv2::XmpData &amp;xmpData, const char *filename, const int version)</a>
<a name="ln2019">{</a>
<a name="ln2020">  GHashTable *mask_entries = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, free_mask_entry);</a>
<a name="ln2021"> </a>
<a name="ln2022">  // TODO: turn that into something like Xmp.darktable.history!</a>
<a name="ln2023">  Exiv2::XmpData::iterator mask;</a>
<a name="ln2024">  Exiv2::XmpData::iterator mask_name;</a>
<a name="ln2025">  Exiv2::XmpData::iterator mask_type;</a>
<a name="ln2026">  Exiv2::XmpData::iterator mask_version;</a>
<a name="ln2027">  Exiv2::XmpData::iterator mask_id;</a>
<a name="ln2028">  Exiv2::XmpData::iterator mask_nb;</a>
<a name="ln2029">  Exiv2::XmpData::iterator mask_src;</a>
<a name="ln2030">  if((mask = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask&quot;))) != xmpData.end()</a>
<a name="ln2031">    &amp;&amp; (mask_src = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_src&quot;))) != xmpData.end()</a>
<a name="ln2032">    &amp;&amp; (mask_name = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_name&quot;))) != xmpData.end()</a>
<a name="ln2033">    &amp;&amp; (mask_type = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_type&quot;))) != xmpData.end()</a>
<a name="ln2034">    &amp;&amp; (mask_version = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_version&quot;))) != xmpData.end()</a>
<a name="ln2035">    &amp;&amp; (mask_id = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_id&quot;))) != xmpData.end()</a>
<a name="ln2036">    &amp;&amp; (mask_nb = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_nb&quot;))) != xmpData.end())</a>
<a name="ln2037">  {</a>
<a name="ln2038">    const int cnt = mask-&gt;count();</a>
<a name="ln2039">    if(cnt == mask_src-&gt;count() &amp;&amp; cnt == mask_name-&gt;count() &amp;&amp; cnt == mask_type-&gt;count()</a>
<a name="ln2040">      &amp;&amp; cnt == mask_version-&gt;count() &amp;&amp; cnt == mask_id-&gt;count() &amp;&amp; cnt == mask_nb-&gt;count())</a>
<a name="ln2041">    {</a>
<a name="ln2042">      for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln2043">      {</a>
<a name="ln2044">        mask_entry_t *entry = (mask_entry_t *)calloc(1, sizeof(mask_entry_t));</a>
<a name="ln2045"> </a>
<a name="ln2046">        entry-&gt;version = version;</a>
<a name="ln2047">        entry-&gt;mask_id = mask_id-&gt;toLong(i);</a>
<a name="ln2048">        entry-&gt;mask_type = mask_type-&gt;toLong(i);</a>
<a name="ln2049">        std::string mask_name_str = mask_name-&gt;toString(i);</a>
<a name="ln2050">        if(mask_name_str.c_str() != NULL)</a>
<a name="ln2051">          entry-&gt;mask_name = g_strdup(mask_name_str.c_str());</a>
<a name="ln2052">        else</a>
<a name="ln2053">          entry-&gt;mask_name = g_strdup(&quot;form&quot;);</a>
<a name="ln2054"> </a>
<a name="ln2055">        entry-&gt;mask_version = mask_version-&gt;toLong(i);</a>
<a name="ln2056"> </a>
<a name="ln2057">        std::string mask_str = mask-&gt;toString(i);</a>
<a name="ln2058">        const char *mask_c = mask_str.c_str();</a>
<a name="ln2059">        const size_t mask_c_len = strlen(mask_c);</a>
<a name="ln2060">        entry-&gt;mask_points = dt_exif_xmp_decode(mask_c, mask_c_len, &amp;entry-&gt;mask_points_len);</a>
<a name="ln2061"> </a>
<a name="ln2062">        entry-&gt;mask_nb = mask_nb-&gt;toLong(i);</a>
<a name="ln2063"> </a>
<a name="ln2064">        std::string mask_src_str = mask_src-&gt;toString(i);</a>
<a name="ln2065">        const char *mask_src_c = mask_src_str.c_str();</a>
<a name="ln2066">        const size_t mask_src_c_len = strlen(mask_src_c);</a>
<a name="ln2067">        entry-&gt;mask_src = dt_exif_xmp_decode(mask_src_c, mask_src_c_len, &amp;entry-&gt;mask_src_len);</a>
<a name="ln2068"> </a>
<a name="ln2069">        g_hash_table_insert(mask_entries, &amp;entry-&gt;mask_id, (gpointer)entry);</a>
<a name="ln2070">      }</a>
<a name="ln2071">    }</a>
<a name="ln2072">  }</a>
<a name="ln2073"> </a>
<a name="ln2074">  return mask_entries;</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">static GList *read_masks_v3(Exiv2::XmpData &amp;xmpData, const char *filename, const int version)</a>
<a name="ln2078">{</a>
<a name="ln2079">  GList *history_entries = NULL;</a>
<a name="ln2080">  mask_entry_t *current_entry = NULL;</a>
<a name="ln2081"> </a>
<a name="ln2082">  for(auto history = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.masks_history&quot;)); history != xmpData.end(); history++)</a>
<a name="ln2083">  {</a>
<a name="ln2084">    // TODO: support human readable params via introspection with something like this:</a>
<a name="ln2085">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:name = width</a>
<a name="ln2086">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:value = 23</a>
<a name="ln2087"> </a>
<a name="ln2088">    char *key = g_strdup(history-&gt;key().c_str());</a>
<a name="ln2089">    char *key_iter = key;</a>
<a name="ln2090">    if(g_str_has_prefix(key, &quot;Xmp.darktable.masks_history[&quot;))</a>
<a name="ln2091">    {</a>
<a name="ln2092">      key_iter += strlen(&quot;Xmp.darktable.masks_history[&quot;);</a>
<a name="ln2093">      errno = 0;</a>
<a name="ln2094">      unsigned int n = strtol(key_iter, &amp;key_iter, 10);</a>
<a name="ln2095">      if(errno)</a>
<a name="ln2096">      {</a>
<a name="ln2097">        std::cerr &lt;&lt; &quot;error reading masks history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2098">        g_list_free_full(history_entries, free_mask_entry);</a>
<a name="ln2099">        g_free(key);</a>
<a name="ln2100">        return NULL;</a>
<a name="ln2101">      }</a>
<a name="ln2102"> </a>
<a name="ln2103">      // skip everything that isn't part of the actual array</a>
<a name="ln2104">      if(*(key_iter++) != ']')</a>
<a name="ln2105">      {</a>
<a name="ln2106">        std::cerr &lt;&lt; &quot;error reading masks history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2107">        g_list_free_full(history_entries, free_mask_entry);</a>
<a name="ln2108">        g_free(key);</a>
<a name="ln2109">        return NULL;</a>
<a name="ln2110">      }</a>
<a name="ln2111">      if(*(key_iter++) != '/') goto skip;</a>
<a name="ln2112">      if(*key_iter == '?') key_iter++;</a>
<a name="ln2113"> </a>
<a name="ln2114">      // make sure we are filling in the details of the correct entry</a>
<a name="ln2115">      unsigned int length = g_list_length(history_entries);</a>
<a name="ln2116">      if(n &gt; length)</a>
<a name="ln2117">      {</a>
<a name="ln2118">        current_entry = (mask_entry_t *)calloc(1, sizeof(mask_entry_t));</a>
<a name="ln2119">        current_entry-&gt;version = version;</a>
<a name="ln2120">        history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln2121">      }</a>
<a name="ln2122">      else if(n &lt; length)</a>
<a name="ln2123">      {</a>
<a name="ln2124">        // AFAICT this can't happen with regular exiv2 parsed XMP data, but better safe than sorry.</a>
<a name="ln2125">        // it can happen though when constructing things in a unusual order and then passing it to us without</a>
<a name="ln2126">        // serializing it in between</a>
<a name="ln2127">        current_entry = (mask_entry_t *)g_list_nth_data(history_entries, n - 1); // XMP starts counting at 1!</a>
<a name="ln2128">      }</a>
<a name="ln2129"> </a>
<a name="ln2130">      // go on reading things into current_entry</a>
<a name="ln2131">      if(g_str_has_prefix(key_iter, &quot;darktable:mask_num&quot;))</a>
<a name="ln2132">      {</a>
<a name="ln2133">        current_entry-&gt;mask_num = history-&gt;value().toLong();</a>
<a name="ln2134">      }</a>
<a name="ln2135">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_id&quot;))</a>
<a name="ln2136">      {</a>
<a name="ln2137">        current_entry-&gt;mask_id = history-&gt;value().toLong();</a>
<a name="ln2138">      }</a>
<a name="ln2139">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_type&quot;))</a>
<a name="ln2140">      {</a>
<a name="ln2141">        current_entry-&gt;mask_type = history-&gt;value().toLong();</a>
<a name="ln2142">      }</a>
<a name="ln2143">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_name&quot;))</a>
<a name="ln2144">      {</a>
<a name="ln2145">        current_entry-&gt;mask_name = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln2146">      }</a>
<a name="ln2147">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_version&quot;))</a>
<a name="ln2148">      {</a>
<a name="ln2149">        current_entry-&gt;mask_version = history-&gt;value().toLong();</a>
<a name="ln2150">      }</a>
<a name="ln2151">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_points&quot;))</a>
<a name="ln2152">      {</a>
<a name="ln2153">        current_entry-&gt;mask_points = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(), &amp;current_entry-&gt;mask_points_len);</a>
<a name="ln2154">      }</a>
<a name="ln2155">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_nb&quot;))</a>
<a name="ln2156">      {</a>
<a name="ln2157">        current_entry-&gt;mask_nb = history-&gt;value().toLong();</a>
<a name="ln2158">      }</a>
<a name="ln2159">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_src&quot;))</a>
<a name="ln2160">      {</a>
<a name="ln2161">        current_entry-&gt;mask_src = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(), &amp;current_entry-&gt;mask_src_len);</a>
<a name="ln2162">      }</a>
<a name="ln2163"> </a>
<a name="ln2164">    }</a>
<a name="ln2165">skip:</a>
<a name="ln2166">    g_free(key);</a>
<a name="ln2167">  }</a>
<a name="ln2168"> </a>
<a name="ln2169">  return history_entries;</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">static void add_mask_entry_to_db(int imgid, mask_entry_t *entry)</a>
<a name="ln2173">{</a>
<a name="ln2174">  // add the mask entry only once</a>
<a name="ln2175">  if(entry-&gt;already_added)</a>
<a name="ln2176">    return;</a>
<a name="ln2177">  entry-&gt;already_added = TRUE;</a>
<a name="ln2178"> </a>
<a name="ln2179">  const int mask_num = 0;</a>
<a name="ln2180"> </a>
<a name="ln2181">  sqlite3_stmt *stmt;</a>
<a name="ln2182">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2183">    dt_database_get(darktable.db),</a>
<a name="ln2184">                              &quot;INSERT INTO main.masks_history (imgid, num, formid, form, name, version, points, points_count, source) &quot;</a>
<a name="ln2185">                              &quot;VALUES (?1, ?9, ?2, ?3, ?4, ?5, ?6, ?7, ?8)&quot;,</a>
<a name="ln2186">                              -1, &amp;stmt, NULL);</a>
<a name="ln2187">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2188">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, entry-&gt;mask_id);</a>
<a name="ln2189">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, entry-&gt;mask_type);</a>
<a name="ln2190">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, entry-&gt;mask_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2191">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 5, entry-&gt;mask_version);</a>
<a name="ln2192">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 6, entry-&gt;mask_points, entry-&gt;mask_points_len, SQLITE_TRANSIENT);</a>
<a name="ln2193">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 7, entry-&gt;mask_nb);</a>
<a name="ln2194">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 8, entry-&gt;mask_src, entry-&gt;mask_src_len, SQLITE_TRANSIENT);</a>
<a name="ln2195">  if(entry-&gt;version &lt; 3)</a>
<a name="ln2196">  {</a>
<a name="ln2197">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, mask_num);</a>
<a name="ln2198">  }</a>
<a name="ln2199">  else</a>
<a name="ln2200">  {</a>
<a name="ln2201">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, entry-&gt;mask_num);</a>
<a name="ln2202">  }</a>
<a name="ln2203">  sqlite3_step(stmt);</a>
<a name="ln2204">  sqlite3_finalize(stmt);</a>
<a name="ln2205">}</a>
<a name="ln2206"> </a>
<a name="ln2207">static void add_non_clone_mask_entries_to_db(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln2208">{</a>
<a name="ln2209">  int imgid = *(int *)user_data;</a>
<a name="ln2210">  mask_entry_t *entry = (mask_entry_t *)value;</a>
<a name="ln2211">  if(!(entry-&gt;mask_type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))) add_mask_entry_to_db(imgid, entry);</a>
<a name="ln2212">}</a>
<a name="ln2213"> </a>
<a name="ln2214">static void add_mask_entries_to_db(int imgid, GHashTable *mask_entries, int mask_id)</a>
<a name="ln2215">{</a>
<a name="ln2216">  if(mask_id &lt;= 0) return;</a>
<a name="ln2217"> </a>
<a name="ln2218">  // look for mask_id in the hash table</a>
<a name="ln2219">  mask_entry_t *entry = (mask_entry_t *)g_hash_table_lookup(mask_entries, &amp;mask_id);</a>
<a name="ln2220"> </a>
<a name="ln2221">  if(!entry) return;</a>
<a name="ln2222"> </a>
<a name="ln2223">  // if it's a group: recurse into the children first</a>
<a name="ln2224">  if(entry-&gt;mask_type &amp; DT_MASKS_GROUP)</a>
<a name="ln2225">  {</a>
<a name="ln2226">    dt_masks_point_group_t *group = (dt_masks_point_group_t *)entry-&gt;mask_points;</a>
<a name="ln2227">    if((int)(entry-&gt;mask_nb * sizeof(dt_masks_point_group_t)) != entry-&gt;mask_points_len)</a>
<a name="ln2228">    {</a>
<a name="ln2229">      fprintf(stderr, &quot;[masks] error loading masks from xmp file, bad binary blob size.\n&quot;);</a>
<a name="ln2230">      return;</a>
<a name="ln2231">    }</a>
<a name="ln2232">    for(int i = 0; i &lt; entry-&gt;mask_nb; i++)</a>
<a name="ln2233">      add_mask_entries_to_db(imgid, mask_entries, group[i].formid);</a>
<a name="ln2234">  }</a>
<a name="ln2235"> </a>
<a name="ln2236">  add_mask_entry_to_db(imgid, entry);</a>
<a name="ln2237">}</a>
<a name="ln2238"> </a>
<a name="ln2239">static int history_v1_to_v3(const int imgid)</a>
<a name="ln2240">{</a>
<a name="ln2241">  int all_ok = 1;</a>
<a name="ln2242">  sqlite3_stmt *stmt;</a>
<a name="ln2243">  sqlite3_stmt *sel_stmt;</a>
<a name="ln2244"> </a>
<a name="ln2245">  // get iop order up to this version</a>
<a name="ln2246">  int iop_order_version = 1;</a>
<a name="ln2247">  GList *iop_order_v1 = dt_ioppr_get_iop_order_list(&amp;iop_order_version);</a>
<a name="ln2248"> </a>
<a name="ln2249">  // set the iop_order version</a>
<a name="ln2250">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2251">                              &quot;UPDATE main.images SET iop_order_version = 1 WHERE id = ?1&quot;, -1,</a>
<a name="ln2252">                              &amp;stmt, NULL);</a>
<a name="ln2253">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2254"> </a>
<a name="ln2255">  if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2256">  {</a>
<a name="ln2257">    fprintf(stderr, &quot;[exif] error updating iop_order_version for image %d\n&quot;, imgid);</a>
<a name="ln2258">    fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2259">    all_ok = FALSE;</a>
<a name="ln2260">    sqlite3_finalize(stmt);</a>
<a name="ln2261">    goto end;</a>
<a name="ln2262">  }</a>
<a name="ln2263">  sqlite3_finalize(stmt);</a>
<a name="ln2264"> </a>
<a name="ln2265">  // create the order of the pipe</a>
<a name="ln2266">  // iop_order is by default the module priority</a>
<a name="ln2267">  // if there's multi-instances we add the multi_priority</a>
<a name="ln2268">  // multi_priority is in reverse order in this version,</a>
<a name="ln2269">  // so we assume that is always less than 1000 and reverse it</a>
<a name="ln2270">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2271">                              &quot;SELECT num, multi_priority, operation FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2272">                              &amp;sel_stmt, NULL);</a>
<a name="ln2273">  DT_DEBUG_SQLITE3_BIND_INT(sel_stmt, 1, imgid);</a>
<a name="ln2274">  while(sqlite3_step(sel_stmt) == SQLITE_ROW)</a>
<a name="ln2275">  {</a>
<a name="ln2276">    const int num = sqlite3_column_int(sel_stmt, 0);</a>
<a name="ln2277">    const int multi_priority = sqlite3_column_int(sel_stmt, 1);</a>
<a name="ln2278">    const char *op_name = (const char *)sqlite3_column_text(sel_stmt, 2);</a>
<a name="ln2279"> </a>
<a name="ln2280">    // search for the priority for this operation</a>
<a name="ln2281">    dt_iop_order_entry_t *prior_v1 = dt_ioppr_get_iop_order_entry(iop_order_v1, op_name);</a>
<a name="ln2282"> </a>
<a name="ln2283">    if(prior_v1)</a>
<a name="ln2284">    {</a>
<a name="ln2285">      int multi_priority_max = -1;</a>
<a name="ln2286">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2287">                                  &quot;SELECT MAX(multi_priority) FROM main.history WHERE imgid = ?1 AND operation = ?2&quot;, -1,</a>
<a name="ln2288">                                  &amp;stmt, NULL);</a>
<a name="ln2289">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2290">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2291">      if(sqlite3_step(stmt) == SQLITE_ROW) multi_priority_max = sqlite3_column_int(stmt, 0);</a>
<a name="ln2292">      sqlite3_finalize(stmt);</a>
<a name="ln2293">      if(multi_priority_max &gt;= 0)</a>
<a name="ln2294">      {</a>
<a name="ln2295">        const float iop_order = ((float)(multi_priority_max + 1 - multi_priority) / 1000.0) + prior_v1-&gt;iop_order;</a>
<a name="ln2296"> </a>
<a name="ln2297">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2298">                                    &quot;UPDATE main.history SET iop_order = ?2 WHERE imgid = ?1 AND num = ?3&quot;, -1,</a>
<a name="ln2299">                                    &amp;stmt, NULL);</a>
<a name="ln2300">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2301">        DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 2, iop_order);</a>
<a name="ln2302">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, num);</a>
<a name="ln2303"> </a>
<a name="ln2304">        if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2305">        {</a>
<a name="ln2306">          fprintf(stderr, &quot;[exif] error updating pipe order in history for image %d\n&quot;, imgid);</a>
<a name="ln2307">          fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2308">          all_ok = FALSE;</a>
<a name="ln2309">          sqlite3_finalize(stmt);</a>
<a name="ln2310">          sqlite3_finalize(sel_stmt);</a>
<a name="ln2311">          goto end;</a>
<a name="ln2312">        }</a>
<a name="ln2313">        sqlite3_finalize(stmt);</a>
<a name="ln2314">      }</a>
<a name="ln2315">      else</a>
<a name="ln2316">        fprintf(stderr, &quot;[exif] error reading max multi_priority on module %s for image %d\n&quot;, op_name, imgid);</a>
<a name="ln2317">    }</a>
<a name="ln2318">    else</a>
<a name="ln2319">      fprintf(stderr, &quot;[exif] can't find default priority on module %s for image %d\n&quot;, op_name, imgid);</a>
<a name="ln2320">  }</a>
<a name="ln2321">  sqlite3_finalize(sel_stmt);</a>
<a name="ln2322"> </a>
<a name="ln2323">end:</a>
<a name="ln2324">  g_list_free_full(iop_order_v1, free);</a>
<a name="ln2325"> </a>
<a name="ln2326">  return all_ok;</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">// need a write lock on *img (non-const) to write stars (and soon color labels).</a>
<a name="ln2330">int dt_exif_xmp_read(dt_image_t *img, const char *filename, const int history_only)</a>
<a name="ln2331">{</a>
<a name="ln2332">  // exclude pfm to avoid stupid errors on the console</a>
<a name="ln2333">  const char *c = filename + strlen(filename) - 4;</a>
<a name="ln2334">  if(c &gt;= filename &amp;&amp; !strcmp(c, &quot;.pfm&quot;)) return 1;</a>
<a name="ln2335">  try</a>
<a name="ln2336">  {</a>
<a name="ln2337">    // read xmp sidecar</a>
<a name="ln2338">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln2339">    assert(image.get() != 0);</a>
<a name="ln2340">    read_metadata_threadsafe(image);</a>
<a name="ln2341">    Exiv2::XmpData &amp;xmpData = image-&gt;xmpData();</a>
<a name="ln2342"> </a>
<a name="ln2343">    sqlite3_stmt *stmt;</a>
<a name="ln2344"> </a>
<a name="ln2345">    Exiv2::XmpData::iterator pos;</a>
<a name="ln2346"> </a>
<a name="ln2347">    int version = 0;</a>
<a name="ln2348">    int iop_order_version = 0;</a>
<a name="ln2349">    int num_masks = 0;</a>
<a name="ln2350">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.xmp_version&quot;))) != xmpData.end())</a>
<a name="ln2351">      version = pos-&gt;toLong();</a>
<a name="ln2352"> </a>
<a name="ln2353">    if(!history_only)</a>
<a name="ln2354">    {</a>
<a name="ln2355">      // otherwise we ignore title, description, ... from non-dt xmp files :(</a>
<a name="ln2356">      size_t ns_pos = image-&gt;xmpPacket().find(&quot;xmlns:darktable=\&quot;http://darktable.sf.net/\&quot;&quot;);</a>
<a name="ln2357">      bool is_a_dt_xmp = (ns_pos != std::string::npos);</a>
<a name="ln2358">      dt_exif_read_xmp_data(img, xmpData, is_a_dt_xmp ? version : -1, false);</a>
<a name="ln2359">    }</a>
<a name="ln2360"> </a>
<a name="ln2361"> </a>
<a name="ln2362">    // convert legacy flip bits (will not be written anymore, convert to flip history item here):</a>
<a name="ln2363">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.raw_params&quot;))) != xmpData.end())</a>
<a name="ln2364">    {</a>
<a name="ln2365">      union {</a>
<a name="ln2366">          int32_t in;</a>
<a name="ln2367">          dt_image_raw_parameters_t out;</a>
<a name="ln2368">      } raw_params;</a>
<a name="ln2369">      raw_params.in = pos-&gt;toLong();</a>
<a name="ln2370">      int32_t user_flip = raw_params.out.user_flip;</a>
<a name="ln2371">      img-&gt;legacy_flip.user_flip = user_flip;</a>
<a name="ln2372">      img-&gt;legacy_flip.legacy = 0;</a>
<a name="ln2373">    }</a>
<a name="ln2374"> </a>
<a name="ln2375">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.auto_presets_applied&quot;))) != xmpData.end())</a>
<a name="ln2376">    {</a>
<a name="ln2377">      int32_t i = pos-&gt;toLong();</a>
<a name="ln2378">      // set or clear bit in image struct</a>
<a name="ln2379">      if(i == 1) img-&gt;flags |= DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2380">      if(i == 0) img-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2381">      // in any case, this is no legacy image.</a>
<a name="ln2382">      img-&gt;flags |= DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln2383">    }</a>
<a name="ln2384">    else</a>
<a name="ln2385">    {</a>
<a name="ln2386">      // not found means 0 (old xmp)</a>
<a name="ln2387">      img-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2388">      // so we are legacy (thus have to clear the no-legacy flag)</a>
<a name="ln2389">      img-&gt;flags &amp;= ~DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln2390">    }</a>
<a name="ln2391">    // when we are reading the xmp data it doesn't make sense to flag the image as removed</a>
<a name="ln2392">    img-&gt;flags &amp;= ~DT_IMAGE_REMOVE;</a>
<a name="ln2393"> </a>
<a name="ln2394">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.iop_order_version&quot;))) != xmpData.end())</a>
<a name="ln2395">    {</a>
<a name="ln2396">      iop_order_version = pos-&gt;toLong();</a>
<a name="ln2397">    }</a>
<a name="ln2398"> </a>
<a name="ln2399"> </a>
<a name="ln2400">    // masks</a>
<a name="ln2401">    GHashTable *mask_entries = NULL;</a>
<a name="ln2402">    GList *mask_entries_v3 = NULL;</a>
<a name="ln2403"> </a>
<a name="ln2404">    // clean all old masks for this image</a>
<a name="ln2405">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2406">                                &amp;stmt, NULL);</a>
<a name="ln2407">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2408">    sqlite3_step(stmt);</a>
<a name="ln2409">    sqlite3_finalize(stmt);</a>
<a name="ln2410"> </a>
<a name="ln2411">    // read the masks from the file first so we can add them to the db while reading history entries</a>
<a name="ln2412">    if(version &lt; 3)</a>
<a name="ln2413">      mask_entries = read_masks(xmpData, filename, version);</a>
<a name="ln2414">    else</a>
<a name="ln2415">      mask_entries_v3 = read_masks_v3(xmpData, filename, version);</a>
<a name="ln2416"> </a>
<a name="ln2417">    // now add all masks that are not used for cloning. keeping them might be useful.</a>
<a name="ln2418">    // TODO: make this configurable? or remove it altogether?</a>
<a name="ln2419">    sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2420">    if(version &lt; 3)</a>
<a name="ln2421">    {</a>
<a name="ln2422">      g_hash_table_foreach(mask_entries, add_non_clone_mask_entries_to_db, &amp;img-&gt;id);</a>
<a name="ln2423">    }</a>
<a name="ln2424">    else</a>
<a name="ln2425">    {</a>
<a name="ln2426">      GList *m_entries = g_list_first(mask_entries_v3);</a>
<a name="ln2427">      while(m_entries)</a>
<a name="ln2428">      {</a>
<a name="ln2429">        mask_entry_t *mask_entry = (mask_entry_t *)m_entries-&gt;data;</a>
<a name="ln2430"> </a>
<a name="ln2431">        add_mask_entry_to_db(img-&gt;id, mask_entry);</a>
<a name="ln2432"> </a>
<a name="ln2433">        m_entries = g_list_next(m_entries);</a>
<a name="ln2434">      }</a>
<a name="ln2435">    }</a>
<a name="ln2436">    sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln2437"> </a>
<a name="ln2438">    // history</a>
<a name="ln2439">    int num = 0;</a>
<a name="ln2440">    gboolean all_ok = TRUE;</a>
<a name="ln2441">    GList *history_entries = NULL;</a>
<a name="ln2442"> </a>
<a name="ln2443">    if(version &lt; 2)</a>
<a name="ln2444">    {</a>
<a name="ln2445">      std::string &amp;xmpPacket = image-&gt;xmpPacket();</a>
<a name="ln2446">      history_entries = read_history_v1(xmpPacket, filename, 0);</a>
<a name="ln2447">      if(!history_entries) // didn't work? try super old version with rdf:Bag</a>
<a name="ln2448">        history_entries = read_history_v1(xmpPacket, filename, 1);</a>
<a name="ln2449">    }</a>
<a name="ln2450">    else if(version == 2 || version == 3)</a>
<a name="ln2451">      history_entries = read_history_v2(xmpData, filename);</a>
<a name="ln2452">    else</a>
<a name="ln2453">    {</a>
<a name="ln2454">      std::cerr &lt;&lt; &quot;error: Xmp schema version &quot; &lt;&lt; version &lt;&lt; &quot; in &quot; &lt;&lt; filename &lt;&lt; &quot; not supported&quot; &lt;&lt; std::endl;</a>
<a name="ln2455">      g_hash_table_destroy(mask_entries);</a>
<a name="ln2456">      return 1;</a>
<a name="ln2457">    }</a>
<a name="ln2458"> </a>
<a name="ln2459">    sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2460"> </a>
<a name="ln2461">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2462">                                &amp;stmt, NULL);</a>
<a name="ln2463">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2464">    if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2465">    {</a>
<a name="ln2466">      fprintf(stderr, &quot;[exif] error deleting history for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2467">      fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2468">      all_ok = FALSE;</a>
<a name="ln2469">      goto end;</a>
<a name="ln2470">    }</a>
<a name="ln2471">    sqlite3_finalize(stmt);</a>
<a name="ln2472"> </a>
<a name="ln2473">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2474">                                &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln2475">                                &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln2476">                                &quot;VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln2477"> </a>
<a name="ln2478">    for(GList *iter = history_entries; iter; iter = g_list_next(iter))</a>
<a name="ln2479">    {</a>
<a name="ln2480">      history_entry_t *entry = (history_entry_t *)iter-&gt;data;</a>
<a name="ln2481">//       print_history_entry(entry);</a>
<a name="ln2482"> </a>
<a name="ln2483">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2484">      if(version &lt; 3)</a>
<a name="ln2485">      {</a>
<a name="ln2486">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln2487">      }</a>
<a name="ln2488">      else</a>
<a name="ln2489">      {</a>
<a name="ln2490">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, entry-&gt;num);</a>
<a name="ln2491">      }</a>
<a name="ln2492">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, entry-&gt;modversion);</a>
<a name="ln2493">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, entry-&gt;operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln2494">      DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 5, entry-&gt;params, entry-&gt;params_len, SQLITE_TRANSIENT);</a>
<a name="ln2495">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 6, entry-&gt;enabled);</a>
<a name="ln2496">      if(entry-&gt;blendop_params)</a>
<a name="ln2497">      {</a>
<a name="ln2498">        DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 7, entry-&gt;blendop_params, entry-&gt;blendop_params_len, SQLITE_TRANSIENT);</a>
<a name="ln2499"> </a>
<a name="ln2500">        if(version &lt; 3)</a>
<a name="ln2501">        {</a>
<a name="ln2502">          // check what mask entries belong to this iop and add them to the db</a>
<a name="ln2503">          const dt_develop_blend_params_t *blendop_params = (dt_develop_blend_params_t *)entry-&gt;blendop_params;</a>
<a name="ln2504">          add_mask_entries_to_db(img-&gt;id, mask_entries, blendop_params-&gt;mask_id);</a>
<a name="ln2505">        }</a>
<a name="ln2506">      }</a>
<a name="ln2507">      else</a>
<a name="ln2508">      {</a>
<a name="ln2509">        sqlite3_bind_null(stmt, 7);</a>
<a name="ln2510">      }</a>
<a name="ln2511">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 8, entry-&gt;blendop_version);</a>
<a name="ln2512">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, entry-&gt;multi_priority);</a>
<a name="ln2513">      if(entry-&gt;multi_name)</a>
<a name="ln2514">      {</a>
<a name="ln2515">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, entry-&gt;multi_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2516">      }</a>
<a name="ln2517">      else</a>
<a name="ln2518">      {</a>
<a name="ln2519">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, &quot;&quot;, -1, SQLITE_TRANSIENT); // &quot;&quot; instead of &quot; &quot; should be fine now</a>
<a name="ln2520">      }</a>
<a name="ln2521">      DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11, entry-&gt;iop_order);</a>
<a name="ln2522"> </a>
<a name="ln2523">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2524">      {</a>
<a name="ln2525">        fprintf(stderr, &quot;[exif] error adding history entry for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2526">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2527">        all_ok = FALSE;</a>
<a name="ln2528">        goto end;</a>
<a name="ln2529">      }</a>
<a name="ln2530">      sqlite3_reset(stmt);</a>
<a name="ln2531">      sqlite3_clear_bindings(stmt);</a>
<a name="ln2532"> </a>
<a name="ln2533">      num++;</a>
<a name="ln2534">    }</a>
<a name="ln2535">    sqlite3_finalize(stmt);</a>
<a name="ln2536"> </a>
<a name="ln2537">    // if masks have been readed create a mask manager entry in history</a>
<a name="ln2538">    if(version &lt; 3)</a>
<a name="ln2539">    {</a>
<a name="ln2540">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT COUNT(*) FROM main.masks_history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2541">                                  &amp;stmt, NULL);</a>
<a name="ln2542">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2543">      if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2544">        num_masks = sqlite3_column_int(stmt, 0);</a>
<a name="ln2545">      sqlite3_finalize(stmt);</a>
<a name="ln2546"> </a>
<a name="ln2547">      if(num_masks &gt; 0)</a>
<a name="ln2548">      {</a>
<a name="ln2549">        // make room for mask_manager entry</a>
<a name="ln2550">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.history SET num = num + 1 WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2551">                                    &amp;stmt, NULL);</a>
<a name="ln2552">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2553">        sqlite3_step(stmt);</a>
<a name="ln2554">        sqlite3_finalize(stmt);</a>
<a name="ln2555"> </a>
<a name="ln2556">        // insert mask_manager entry</a>
<a name="ln2557">        int iop_order_version1 = 1;</a>
<a name="ln2558">        GList *iop_order_list = dt_ioppr_get_iop_order_list(&amp;iop_order_version1);</a>
<a name="ln2559">        const float iop_order_mask_manager = dt_ioppr_get_iop_order(iop_order_list, &quot;mask_manager&quot;);</a>
<a name="ln2560">        g_list_free_full(iop_order_list, free);</a>
<a name="ln2561"> </a>
<a name="ln2562">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2563">                                    &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln2564">                                    &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln2565">                                    &quot;VALUES (?1, 0, 1, 'mask_manager', NULL, 0, NULL, 0, 0, '', ?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln2566">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2567">        DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 2, iop_order_mask_manager);</a>
<a name="ln2568">        if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2569">        {</a>
<a name="ln2570">          fprintf(stderr, &quot;[exif] error adding mask history entry for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2571">          fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2572">          all_ok = FALSE;</a>
<a name="ln2573">          goto end;</a>
<a name="ln2574">        }</a>
<a name="ln2575">        sqlite3_finalize(stmt);</a>
<a name="ln2576"> </a>
<a name="ln2577">        num++;</a>
<a name="ln2578">      }</a>
<a name="ln2579">    }</a>
<a name="ln2580"> </a>
<a name="ln2581">    // we shouldn't change history_end when no history was read!</a>
<a name="ln2582">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.history_end&quot;))) != xmpData.end() &amp;&amp; num &gt; 0)</a>
<a name="ln2583">    {</a>
<a name="ln2584">      int history_end = MIN(pos-&gt;toLong(), num);</a>
<a name="ln2585">      if(num_masks &gt; 0) history_end++;</a>
<a name="ln2586">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2587">                                  &quot;UPDATE main.images SET history_end = ?1 WHERE id = ?2&quot;, -1,</a>
<a name="ln2588">                                  &amp;stmt, NULL);</a>
<a name="ln2589">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, history_end);</a>
<a name="ln2590">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, img-&gt;id);</a>
<a name="ln2591">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2592">      {</a>
<a name="ln2593">        fprintf(stderr, &quot;[exif] error writing history_end for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2594">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2595">        all_ok = FALSE;</a>
<a name="ln2596">        goto end;</a>
<a name="ln2597">      }</a>
<a name="ln2598">    }</a>
<a name="ln2599">    else</a>
<a name="ln2600">    {</a>
<a name="ln2601">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2602">                                  &quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) &quot;</a>
<a name="ln2603">                                  &quot;FROM main.history WHERE imgid = ?1) WHERE id = ?1&quot;, -1,</a>
<a name="ln2604">                                  &amp;stmt, NULL);</a>
<a name="ln2605">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2606">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2607">      {</a>
<a name="ln2608">        fprintf(stderr, &quot;[exif] error writing history_end for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2609">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2610">        all_ok = FALSE;</a>
<a name="ln2611">        goto end;</a>
<a name="ln2612">      }</a>
<a name="ln2613">    }</a>
<a name="ln2614"> </a>
<a name="ln2615">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2616">                                &quot;UPDATE main.images SET iop_order_version = ?1 WHERE id = ?2&quot;, -1,</a>
<a name="ln2617">                                &amp;stmt, NULL);</a>
<a name="ln2618">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, iop_order_version);</a>
<a name="ln2619">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, img-&gt;id);</a>
<a name="ln2620">    if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2621">    {</a>
<a name="ln2622">      fprintf(stderr, &quot;[exif] error writing iop_order_version for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2623">      fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2624">      all_ok = FALSE;</a>
<a name="ln2625">      goto end;</a>
<a name="ln2626">    }</a>
<a name="ln2627"> </a>
<a name="ln2628">end:</a>
<a name="ln2629">    sqlite3_finalize(stmt);</a>
<a name="ln2630"> </a>
<a name="ln2631">    g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2632">    g_list_free_full(mask_entries_v3, free_mask_entry);</a>
<a name="ln2633">    if(mask_entries) g_hash_table_destroy(mask_entries);</a>
<a name="ln2634"> </a>
<a name="ln2635">    if(all_ok)</a>
<a name="ln2636">    {</a>
<a name="ln2637">      if(version &lt; 3)</a>
<a name="ln2638">      {</a>
<a name="ln2639">        all_ok = history_v1_to_v3(img-&gt;id);</a>
<a name="ln2640">      }</a>
<a name="ln2641">    }</a>
<a name="ln2642"> </a>
<a name="ln2643">    if(all_ok)</a>
<a name="ln2644">    {</a>
<a name="ln2645">      sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln2646">    }</a>
<a name="ln2647">    else</a>
<a name="ln2648">    {</a>
<a name="ln2649">      std::cerr &lt;&lt; &quot;[exif] error reading history from '&quot; &lt;&lt; filename &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;</a>
<a name="ln2650">      sqlite3_exec(dt_database_get(darktable.db), &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2651">      return 1;</a>
<a name="ln2652">    }</a>
<a name="ln2653"> </a>
<a name="ln2654">  }</a>
<a name="ln2655">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2656">  {</a>
<a name="ln2657">    // actually nobody's interested in that if the file doesn't exist:</a>
<a name="ln2658">    // std::string s(e.what());</a>
<a name="ln2659">    // std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln2660">    return 1;</a>
<a name="ln2661">  }</a>
<a name="ln2662">  return 0;</a>
<a name="ln2663">}</a>
<a name="ln2664"> </a>
<a name="ln2665">// helper to create an xmp data thing. throws exiv2 exceptions if stuff goes wrong.</a>
<a name="ln2666">static void dt_exif_xmp_read_data(Exiv2::XmpData &amp;xmpData, const int imgid)</a>
<a name="ln2667">{</a>
<a name="ln2668">  const int xmp_version = 3;</a>
<a name="ln2669">  int stars = 1, raw_params = 0, history_end = -1;</a>
<a name="ln2670">  int iop_order_version = 0;</a>
<a name="ln2671">  double longitude = NAN, latitude = NAN, altitude = NAN;</a>
<a name="ln2672">  gchar *filename = NULL;</a>
<a name="ln2673">  gchar *datetime_taken = NULL;</a>
<a name="ln2674"> </a>
<a name="ln2675">  // get stars and raw params from db</a>
<a name="ln2676">  sqlite3_stmt *stmt;</a>
<a name="ln2677">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT filename, flags, raw_parameters, &quot;</a>
<a name="ln2678">                                                             &quot;longitude, latitude, altitude, history_end, iop_order_version, datetime_taken &quot;</a>
<a name="ln2679">                                                             &quot;FROM main.images WHERE id = ?1&quot;,</a>
<a name="ln2680">                              -1, &amp;stmt, NULL);</a>
<a name="ln2681">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2682">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2683">  {</a>
<a name="ln2684">    filename = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln2685">    stars = sqlite3_column_int(stmt, 1);</a>
<a name="ln2686">    raw_params = sqlite3_column_int(stmt, 2);</a>
<a name="ln2687">    if(sqlite3_column_type(stmt, 3) == SQLITE_FLOAT) longitude = sqlite3_column_double(stmt, 3);</a>
<a name="ln2688">    if(sqlite3_column_type(stmt, 4) == SQLITE_FLOAT) latitude = sqlite3_column_double(stmt, 4);</a>
<a name="ln2689">    if(sqlite3_column_type(stmt, 5) == SQLITE_FLOAT) altitude = sqlite3_column_double(stmt, 5);</a>
<a name="ln2690">    history_end = sqlite3_column_int(stmt, 6);</a>
<a name="ln2691">    iop_order_version = sqlite3_column_int(stmt, 7);</a>
<a name="ln2692">    datetime_taken = (gchar *)sqlite3_column_text(stmt, 8);</a>
<a name="ln2693">  }</a>
<a name="ln2694"> </a>
<a name="ln2695">  // Store datetime_taken as DateTimeOriginal to take into account the user's selected date/time</a>
<a name="ln2696">  xmpData[&quot;Xmp.exif.DateTimeOriginal&quot;] = datetime_taken;</a>
<a name="ln2697"> </a>
<a name="ln2698">  // We have to erase the old ratings first as exiv2 seems to not change it otherwise.</a>
<a name="ln2699">  Exiv2::XmpData::iterator pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.xmp.Rating&quot;));</a>
<a name="ln2700">  if(pos != xmpData.end()) xmpData.erase(pos);</a>
<a name="ln2701">  xmpData[&quot;Xmp.xmp.Rating&quot;] = ((stars &amp; 0x7) == 6) ? -1 : (stars &amp; 0x7); // rejected image = -1, others = 0..5</a>
<a name="ln2702"> </a>
<a name="ln2703">  // The original file name</a>
<a name="ln2704">  if(filename) xmpData[&quot;Xmp.xmpMM.DerivedFrom&quot;] = filename;</a>
<a name="ln2705"> </a>
<a name="ln2706">  // GPS data</a>
<a name="ln2707">  if(!std::isnan(longitude) &amp;&amp; !std::isnan(latitude))</a>
<a name="ln2708">  {</a>
<a name="ln2709">    char long_dir = 'E', lat_dir = 'N';</a>
<a name="ln2710">    if(longitude &lt; 0) long_dir = 'W';</a>
<a name="ln2711">    if(latitude &lt; 0) lat_dir = 'S';</a>
<a name="ln2712"> </a>
<a name="ln2713">    longitude = fabs(longitude);</a>
<a name="ln2714">    latitude = fabs(latitude);</a>
<a name="ln2715"> </a>
<a name="ln2716">    int long_deg = (int)floor(longitude);</a>
<a name="ln2717">    int lat_deg = (int)floor(latitude);</a>
<a name="ln2718">    double long_min = (longitude - (double)long_deg) * 60.0;</a>
<a name="ln2719">    double lat_min = (latitude - (double)lat_deg) * 60.0;</a>
<a name="ln2720"> </a>
<a name="ln2721">    char *str = (char *)g_malloc(G_ASCII_DTOSTR_BUF_SIZE);</a>
<a name="ln2722"> </a>
<a name="ln2723">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%08f&quot;, long_min);</a>
<a name="ln2724">    gchar *long_str = g_strdup_printf(&quot;%d,%s%c&quot;, long_deg, str, long_dir);</a>
<a name="ln2725">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%08f&quot;, lat_min);</a>
<a name="ln2726">    gchar *lat_str = g_strdup_printf(&quot;%d,%s%c&quot;, lat_deg, str, lat_dir);</a>
<a name="ln2727"> </a>
<a name="ln2728">    xmpData[&quot;Xmp.exif.GPSVersionID&quot;] = &quot;2.2.0.0&quot;;</a>
<a name="ln2729">    xmpData[&quot;Xmp.exif.GPSLongitude&quot;] = long_str;</a>
<a name="ln2730">    xmpData[&quot;Xmp.exif.GPSLatitude&quot;] = lat_str;</a>
<a name="ln2731">    g_free(long_str);</a>
<a name="ln2732">    g_free(lat_str);</a>
<a name="ln2733">    g_free(str);</a>
<a name="ln2734">  }</a>
<a name="ln2735">  if(!std::isnan(altitude))</a>
<a name="ln2736">  {</a>
<a name="ln2737">    xmpData[&quot;Xmp.exif.GPSAltitudeRef&quot;] = (altitude &lt; 0) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln2738"> </a>
<a name="ln2739">    long ele_dm = (int)floor(fabs(10.0 * altitude));</a>
<a name="ln2740">    gchar *ele_str = g_strdup_printf(&quot;%ld/10&quot;, ele_dm);</a>
<a name="ln2741">    xmpData[&quot;Xmp.exif.GPSAltitude&quot;] = ele_str;</a>
<a name="ln2742">    g_free(ele_str);</a>
<a name="ln2743">  }</a>
<a name="ln2744">  sqlite3_finalize(stmt);</a>
<a name="ln2745"> </a>
<a name="ln2746">  // the meta data</a>
<a name="ln2747">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT key, value FROM main.meta_data WHERE id = ?1&quot;,</a>
<a name="ln2748">                              -1, &amp;stmt, NULL);</a>
<a name="ln2749">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2750">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2751">  {</a>
<a name="ln2752">    int key = sqlite3_column_int(stmt, 0);</a>
<a name="ln2753">    switch(key)</a>
<a name="ln2754">    {</a>
<a name="ln2755">      case DT_METADATA_XMP_DC_CREATOR:</a>
<a name="ln2756">        xmpData[&quot;Xmp.dc.creator&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2757">        break;</a>
<a name="ln2758">      case DT_METADATA_XMP_DC_PUBLISHER:</a>
<a name="ln2759">        xmpData[&quot;Xmp.dc.publisher&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2760">        break;</a>
<a name="ln2761">      case DT_METADATA_XMP_DC_TITLE:</a>
<a name="ln2762">        xmpData[&quot;Xmp.dc.title&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2763">        break;</a>
<a name="ln2764">      case DT_METADATA_XMP_DC_DESCRIPTION:</a>
<a name="ln2765">        xmpData[&quot;Xmp.dc.description&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2766">        break;</a>
<a name="ln2767">      case DT_METADATA_XMP_DC_RIGHTS:</a>
<a name="ln2768">        xmpData[&quot;Xmp.dc.rights&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln2769">        break;</a>
<a name="ln2770">    }</a>
<a name="ln2771">  }</a>
<a name="ln2772">  sqlite3_finalize(stmt);</a>
<a name="ln2773"> </a>
<a name="ln2774">  xmpData[&quot;Xmp.darktable.xmp_version&quot;] = xmp_version;</a>
<a name="ln2775">  xmpData[&quot;Xmp.darktable.raw_params&quot;] = raw_params;</a>
<a name="ln2776"> </a>
<a name="ln2777">  if(stars &amp; DT_IMAGE_AUTO_PRESETS_APPLIED)</a>
<a name="ln2778">    xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 1;</a>
<a name="ln2779">  else</a>
<a name="ln2780">    xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 0;</a>
<a name="ln2781"> </a>
<a name="ln2782">  // get tags from db, store in dublin core</a>
<a name="ln2783">  std::unique_ptr&lt;Exiv2::Value&gt; v1(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln2784"> </a>
<a name="ln2785">  std::unique_ptr&lt;Exiv2::Value&gt; v2(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln2786"> </a>
<a name="ln2787">  GList *tags = dt_tag_get_list(imgid);</a>
<a name="ln2788">  while(tags)</a>
<a name="ln2789">  {</a>
<a name="ln2790">    v1-&gt;read((char *)tags-&gt;data);</a>
<a name="ln2791">    tags = g_list_next(tags);</a>
<a name="ln2792">  }</a>
<a name="ln2793"> </a>
<a name="ln2794">  GList *hierarchical = dt_tag_get_hierarchical(imgid);</a>
<a name="ln2795">  while(hierarchical)</a>
<a name="ln2796">  {</a>
<a name="ln2797">    v2-&gt;read((char *)hierarchical-&gt;data);</a>
<a name="ln2798">    hierarchical = g_list_next(hierarchical);</a>
<a name="ln2799">  }</a>
<a name="ln2800"> </a>
<a name="ln2801">  if(v1-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.dc.subject&quot;), v1.get());</a>
<a name="ln2802">  if(v2-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.lr.hierarchicalSubject&quot;), v2.get());</a>
<a name="ln2803">  /* TODO: Add tags to IPTC namespace as well */</a>
<a name="ln2804"> </a>
<a name="ln2805">  // color labels</a>
<a name="ln2806">  char val[2048];</a>
<a name="ln2807">  std::unique_ptr&lt;Exiv2::Value&gt; v(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln2808"> </a>
<a name="ln2809">  /* Already initialized v = Exiv2::Value::create(Exiv2::xmpSeq); // or xmpBag or xmpAlt.*/</a>
<a name="ln2810">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT color FROM main.color_labels WHERE imgid=?1&quot;,</a>
<a name="ln2811">                              -1, &amp;stmt, NULL);</a>
<a name="ln2812">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2813">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2814">  {</a>
<a name="ln2815">    snprintf(val, sizeof(val), &quot;%d&quot;, sqlite3_column_int(stmt, 0));</a>
<a name="ln2816">    v-&gt;read(val);</a>
<a name="ln2817">  }</a>
<a name="ln2818">  sqlite3_finalize(stmt);</a>
<a name="ln2819">  if(v-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.colorlabels&quot;), v.get());</a>
<a name="ln2820"> </a>
<a name="ln2821">  // masks:</a>
<a name="ln2822">  char key[1024];</a>
<a name="ln2823">  int num = 1;</a>
<a name="ln2824"> </a>
<a name="ln2825">  // masks history:</a>
<a name="ln2826">  num = 1;</a>
<a name="ln2827"> </a>
<a name="ln2828">  // create an array:</a>
<a name="ln2829">  Exiv2::XmpTextValue tvm(&quot;&quot;);</a>
<a name="ln2830">  tvm.setXmpArrayType(Exiv2::XmpValue::xaSeq);</a>
<a name="ln2831">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.masks_history&quot;), &amp;tvm);</a>
<a name="ln2832"> </a>
<a name="ln2833">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2834">      dt_database_get(darktable.db),</a>
<a name="ln2835">      &quot;SELECT imgid, formid, form, name, version, points, points_count, source, num FROM main.masks_history WHERE imgid = ?1 ORDER BY num&quot;,</a>
<a name="ln2836">      -1, &amp;stmt, NULL);</a>
<a name="ln2837">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2838">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2839">  {</a>
<a name="ln2840">    int32_t mask_num = sqlite3_column_int(stmt, 8);</a>
<a name="ln2841">    int32_t mask_id = sqlite3_column_int(stmt, 1);</a>
<a name="ln2842">    int32_t mask_type = sqlite3_column_int(stmt, 2);</a>
<a name="ln2843">    const char *mask_name = (const char *)sqlite3_column_text(stmt, 3);</a>
<a name="ln2844">    int32_t mask_version = sqlite3_column_int(stmt, 4);</a>
<a name="ln2845">    int32_t len = sqlite3_column_bytes(stmt, 5);</a>
<a name="ln2846">    char *mask_d = dt_exif_xmp_encode((const unsigned char *)sqlite3_column_blob(stmt, 5), len, NULL);</a>
<a name="ln2847">    int32_t mask_nb = sqlite3_column_int(stmt, 6);</a>
<a name="ln2848">    len = sqlite3_column_bytes(stmt, 7);</a>
<a name="ln2849">    char *mask_src = dt_exif_xmp_encode((const unsigned char *)sqlite3_column_blob(stmt, 7), len, NULL);</a>
<a name="ln2850"> </a>
<a name="ln2851">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_num&quot;, num);</a>
<a name="ln2852">    xmpData[key] = mask_num;</a>
<a name="ln2853">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_id&quot;, num);</a>
<a name="ln2854">    xmpData[key] = mask_id;</a>
<a name="ln2855">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_type&quot;, num);</a>
<a name="ln2856">    xmpData[key] = mask_type;</a>
<a name="ln2857">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_name&quot;, num);</a>
<a name="ln2858">    xmpData[key] = mask_name;</a>
<a name="ln2859">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_version&quot;, num);</a>
<a name="ln2860">    xmpData[key] = mask_version;</a>
<a name="ln2861">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_points&quot;, num);</a>
<a name="ln2862">    xmpData[key] = mask_d;</a>
<a name="ln2863">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_nb&quot;, num);</a>
<a name="ln2864">    xmpData[key] = mask_nb;</a>
<a name="ln2865">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_src&quot;, num);</a>
<a name="ln2866">    xmpData[key] = mask_src;</a>
<a name="ln2867"> </a>
<a name="ln2868">    free(mask_d);</a>
<a name="ln2869">    free(mask_src);</a>
<a name="ln2870"> </a>
<a name="ln2871">    num++;</a>
<a name="ln2872">  }</a>
<a name="ln2873">  sqlite3_finalize(stmt);</a>
<a name="ln2874"> </a>
<a name="ln2875"> </a>
<a name="ln2876">  // history stack:</a>
<a name="ln2877">  num = 1;</a>
<a name="ln2878"> </a>
<a name="ln2879">  // create an array:</a>
<a name="ln2880">  Exiv2::XmpTextValue tv(&quot;&quot;);</a>
<a name="ln2881">  tv.setXmpArrayType(Exiv2::XmpValue::xaSeq);</a>
<a name="ln2882">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.history&quot;), &amp;tv);</a>
<a name="ln2883"> </a>
<a name="ln2884">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2885">      dt_database_get(darktable.db),</a>
<a name="ln2886">      &quot;SELECT module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln2887">      &quot;blendop_version, multi_priority, multi_name, num, iop_order FROM main.history WHERE imgid = ?1 ORDER BY num&quot;,</a>
<a name="ln2888">      -1, &amp;stmt, NULL);</a>
<a name="ln2889">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2890">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2891">  {</a>
<a name="ln2892">    int32_t modversion = sqlite3_column_int(stmt, 0);</a>
<a name="ln2893">    const char *operation = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln2894">    int32_t params_len = sqlite3_column_bytes(stmt, 2);</a>
<a name="ln2895">    const void *params_blob = sqlite3_column_blob(stmt, 2);</a>
<a name="ln2896">    int32_t enabled = sqlite3_column_int(stmt, 3);</a>
<a name="ln2897">    const void *blendop_blob = sqlite3_column_blob(stmt, 4);</a>
<a name="ln2898">    int32_t blendop_params_len = sqlite3_column_bytes(stmt, 4);</a>
<a name="ln2899">    int32_t blendop_version = sqlite3_column_int(stmt, 5);</a>
<a name="ln2900">    int32_t multi_priority = sqlite3_column_int(stmt, 6);</a>
<a name="ln2901">    const char *multi_name = (const char *)sqlite3_column_text(stmt, 7);</a>
<a name="ln2902">    int32_t hist_num = sqlite3_column_int(stmt, 8);</a>
<a name="ln2903">    double iop_order = sqlite3_column_double(stmt, 9);</a>
<a name="ln2904"> </a>
<a name="ln2905">    if(!operation) continue; // no op is fatal.</a>
<a name="ln2906"> </a>
<a name="ln2907">    char *params = dt_exif_xmp_encode((const unsigned char *)params_blob, params_len, NULL);</a>
<a name="ln2908"> </a>
<a name="ln2909">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:num&quot;, num);</a>
<a name="ln2910">    xmpData[key] = hist_num;</a>
<a name="ln2911">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:operation&quot;, num);</a>
<a name="ln2912">    xmpData[key] = operation;</a>
<a name="ln2913">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:enabled&quot;, num);</a>
<a name="ln2914">    xmpData[key] = enabled;</a>
<a name="ln2915">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:modversion&quot;, num);</a>
<a name="ln2916">    xmpData[key] = modversion;</a>
<a name="ln2917">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:params&quot;, num);</a>
<a name="ln2918">    xmpData[key] = params;</a>
<a name="ln2919">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:multi_name&quot;, num);</a>
<a name="ln2920">    xmpData[key] = multi_name ? multi_name : &quot;&quot;;</a>
<a name="ln2921">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:multi_priority&quot;, num);</a>
<a name="ln2922">    xmpData[key] = multi_priority;</a>
<a name="ln2923">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:iop_order&quot;, num);</a>
<a name="ln2924">    xmpData[key] = iop_order;</a>
<a name="ln2925">    if(blendop_blob)</a>
<a name="ln2926">    {</a>
<a name="ln2927">      // this shouldn't fail in general, but reading is robust enough to allow it,</a>
<a name="ln2928">      // and flipping images from LT will result in this being left out</a>
<a name="ln2929">      char *blendop_params = dt_exif_xmp_encode((const unsigned char *)blendop_blob, blendop_params_len, NULL);</a>
<a name="ln2930">      snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:blendop_version&quot;, num);</a>
<a name="ln2931">      xmpData[key] = blendop_version;</a>
<a name="ln2932">      snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:blendop_params&quot;, num);</a>
<a name="ln2933">      xmpData[key] = blendop_params;</a>
<a name="ln2934">      free(blendop_params);</a>
<a name="ln2935">    }</a>
<a name="ln2936"> </a>
<a name="ln2937">    free(params);</a>
<a name="ln2938"> </a>
<a name="ln2939">    num++;</a>
<a name="ln2940">  }</a>
<a name="ln2941"> </a>
<a name="ln2942">  if(history_end == -1) history_end = num - 1;</a>
<a name="ln2943">  else history_end = MIN(history_end, num - 1); // safeguard for some old buggy libraries</a>
<a name="ln2944">  xmpData[&quot;Xmp.darktable.history_end&quot;] = history_end;</a>
<a name="ln2945">  xmpData[&quot;Xmp.darktable.iop_order_version&quot;] = iop_order_version;</a>
<a name="ln2946"> </a>
<a name="ln2947">  sqlite3_finalize(stmt);</a>
<a name="ln2948">  g_list_free_full(tags, g_free);</a>
<a name="ln2949">  g_list_free_full(hierarchical, g_free);</a>
<a name="ln2950">}</a>
<a name="ln2951"> </a>
<a name="ln2952">#if EXIV2_VERSION &gt;= EXIV2_MAKE_VERSION(0,27,0)</a>
<a name="ln2953">#define ERROR_CODE(a) (static_cast&lt;Exiv2::ErrorCode&gt;((a)))</a>
<a name="ln2954">#else</a>
<a name="ln2955">#define ERROR_CODE(a) (a)</a>
<a name="ln2956">#endif</a>
<a name="ln2957"> </a>
<a name="ln2958">char *dt_exif_xmp_read_string(const int imgid)</a>
<a name="ln2959">{</a>
<a name="ln2960">  try</a>
<a name="ln2961">  {</a>
<a name="ln2962">    char input_filename[PATH_MAX] = { 0 };</a>
<a name="ln2963">    gboolean from_cache = FALSE;</a>
<a name="ln2964">    dt_image_full_path(imgid, input_filename, sizeof(input_filename), &amp;from_cache);</a>
<a name="ln2965"> </a>
<a name="ln2966">    // first take over the data from the source image</a>
<a name="ln2967">    Exiv2::XmpData xmpData;</a>
<a name="ln2968">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln2969">    {</a>
<a name="ln2970">      std::string xmpPacket;</a>
<a name="ln2971"> </a>
<a name="ln2972">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln2973">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln2974">      Exiv2::XmpParser::decode(xmpData, xmpPacket);</a>
<a name="ln2975">      // because XmpSeq or XmpBag are added to the list, we first have</a>
<a name="ln2976">      // to remove these so that we don't end up with a string of duplicates</a>
<a name="ln2977">      dt_remove_known_keys(xmpData);</a>
<a name="ln2978">    }</a>
<a name="ln2979"> </a>
<a name="ln2980">    // now add whatever we have in the sidecar XMP. this overwrites stuff from the source image</a>
<a name="ln2981">    dt_image_path_append_version(imgid, input_filename, sizeof(input_filename));</a>
<a name="ln2982">    g_strlcat(input_filename, &quot;.xmp&quot;, sizeof(input_filename));</a>
<a name="ln2983">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln2984">    {</a>
<a name="ln2985">      Exiv2::XmpData sidecarXmpData;</a>
<a name="ln2986">      std::string xmpPacket;</a>
<a name="ln2987"> </a>
<a name="ln2988">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln2989">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln2990">      Exiv2::XmpParser::decode(sidecarXmpData, xmpPacket);</a>
<a name="ln2991"> </a>
<a name="ln2992">      for(Exiv2::XmpData::const_iterator it = sidecarXmpData.begin(); it != sidecarXmpData.end(); ++it)</a>
<a name="ln2993">        xmpData.add(*it);</a>
<a name="ln2994">    }</a>
<a name="ln2995"> </a>
<a name="ln2996">    dt_remove_known_keys(xmpData); // is this needed?</a>
<a name="ln2997"> </a>
<a name="ln2998">    // last but not least attach what we have in DB to the XMP. in theory that should be</a>
<a name="ln2999">    // the same as what we just copied over from the sidecar file, but you never know ...</a>
<a name="ln3000">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln3001"> </a>
<a name="ln3002">    // serialize the xmp data and output the xmp packet</a>
<a name="ln3003">    std::string xmpPacket;</a>
<a name="ln3004">    if(Exiv2::XmpParser::encode(xmpPacket, xmpData,</a>
<a name="ln3005">      Exiv2::XmpParser::useCompactFormat | Exiv2::XmpParser::omitPacketWrapper) != 0)</a>
<a name="ln3006">    {</a>
<a name="ln3007">      throw Exiv2::Error(ERROR_CODE(1), &quot;[xmp_write] failed to serialize xmp data&quot;);</a>
<a name="ln3008">    }</a>
<a name="ln3009">    return g_strdup(xmpPacket.c_str());</a>
<a name="ln3010">  }</a>
<a name="ln3011">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3012">  {</a>
<a name="ln3013">    std::cerr &lt;&lt; &quot;[xmp_read_blob] caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3014">    return NULL;</a>
<a name="ln3015">  }</a>
<a name="ln3016">}</a>
<a name="ln3017"> </a>
<a name="ln3018">int dt_exif_xmp_attach(const int imgid, const char *filename)</a>
<a name="ln3019">{</a>
<a name="ln3020">  try</a>
<a name="ln3021">  {</a>
<a name="ln3022">    char input_filename[PATH_MAX] = { 0 };</a>
<a name="ln3023">    gboolean from_cache = TRUE;</a>
<a name="ln3024">    dt_image_full_path(imgid, input_filename, sizeof(input_filename), &amp;from_cache);</a>
<a name="ln3025"> </a>
<a name="ln3026">    std::unique_ptr&lt;Exiv2::Image&gt; img(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln3027">    // unfortunately it seems we have to read the metadata, to not erase the exif (which we just wrote).</a>
<a name="ln3028">    // will make export slightly slower, oh well.</a>
<a name="ln3029">    // img-&gt;clearXmpPacket();</a>
<a name="ln3030">    read_metadata_threadsafe(img);</a>
<a name="ln3031"> </a>
<a name="ln3032">    try</a>
<a name="ln3033">    {</a>
<a name="ln3034">      // initialize XMP and IPTC data with the one from the original file</a>
<a name="ln3035">      std::unique_ptr&lt;Exiv2::Image&gt; input_image(Exiv2::ImageFactory::open(WIDEN(input_filename)));</a>
<a name="ln3036">      if(input_image.get() != 0)</a>
<a name="ln3037">      {</a>
<a name="ln3038">        read_metadata_threadsafe(input_image);</a>
<a name="ln3039">        img-&gt;setIptcData(input_image-&gt;iptcData());</a>
<a name="ln3040">        img-&gt;setXmpData(input_image-&gt;xmpData());</a>
<a name="ln3041">      }</a>
<a name="ln3042">    }</a>
<a name="ln3043">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3044">    {</a>
<a name="ln3045">      std::cerr &lt;&lt; &quot;[xmp_attach] &quot; &lt;&lt; input_filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3046">    }</a>
<a name="ln3047"> </a>
<a name="ln3048">    Exiv2::XmpData &amp;xmpData = img-&gt;xmpData();</a>
<a name="ln3049"> </a>
<a name="ln3050">    // now add whatever we have in the sidecar XMP. this overwrites stuff from the source image</a>
<a name="ln3051">    dt_image_path_append_version(imgid, input_filename, sizeof(input_filename));</a>
<a name="ln3052">    g_strlcat(input_filename, &quot;.xmp&quot;, sizeof(input_filename));</a>
<a name="ln3053">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln3054">    {</a>
<a name="ln3055">      Exiv2::XmpData sidecarXmpData;</a>
<a name="ln3056">      std::string xmpPacket;</a>
<a name="ln3057"> </a>
<a name="ln3058">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln3059">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln3060">      Exiv2::XmpParser::decode(sidecarXmpData, xmpPacket);</a>
<a name="ln3061"> </a>
<a name="ln3062">      for(Exiv2::XmpData::const_iterator it = sidecarXmpData.begin(); it != sidecarXmpData.end(); ++it)</a>
<a name="ln3063">        xmpData.add(*it);</a>
<a name="ln3064">    }</a>
<a name="ln3065"> </a>
<a name="ln3066">    dt_remove_known_keys(xmpData); // is this needed?</a>
<a name="ln3067"> </a>
<a name="ln3068">    {</a>
<a name="ln3069">      // We also want to make sure to not have some tags that might</a>
<a name="ln3070">      // have come in from XMP files created by digikam or similar</a>
<a name="ln3071">      static const char *keys[] = {</a>
<a name="ln3072">        &quot;Xmp.tiff.Orientation&quot;</a>
<a name="ln3073">      };</a>
<a name="ln3074">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln3075">      dt_remove_xmp_keys(xmpData, keys, n_keys);</a>
<a name="ln3076">    }</a>
<a name="ln3077"> </a>
<a name="ln3078">    // last but not least attach what we have in DB to the XMP. in theory that should be</a>
<a name="ln3079">    // the same as what we just copied over from the sidecar file, but you never know ...</a>
<a name="ln3080">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln3081"> </a>
<a name="ln3082">    img-&gt;writeMetadata();</a>
<a name="ln3083">    return 0;</a>
<a name="ln3084">  }</a>
<a name="ln3085">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3086">  {</a>
<a name="ln3087">    std::cerr &lt;&lt; &quot;[xmp_attach] &quot; &lt;&lt; filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3088">    return -1;</a>
<a name="ln3089">  }</a>
<a name="ln3090">}</a>
<a name="ln3091"> </a>
<a name="ln3092">// write xmp sidecar file:</a>
<a name="ln3093">int dt_exif_xmp_write(const int imgid, const char *filename)</a>
<a name="ln3094">{</a>
<a name="ln3095">  // refuse to write sidecar for non-existent image:</a>
<a name="ln3096">  char imgfname[PATH_MAX] = { 0 };</a>
<a name="ln3097">  gboolean from_cache = TRUE;</a>
<a name="ln3098"> </a>
<a name="ln3099">  dt_image_full_path(imgid, imgfname, sizeof(imgfname), &amp;from_cache);</a>
<a name="ln3100">  if(!g_file_test(imgfname, G_FILE_TEST_IS_REGULAR)) return 1;</a>
<a name="ln3101"> </a>
<a name="ln3102">  try</a>
<a name="ln3103">  {</a>
<a name="ln3104">    Exiv2::XmpData xmpData;</a>
<a name="ln3105">    std::string xmpPacket;</a>
<a name="ln3106">    char *checksum_old = NULL;</a>
<a name="ln3107">    if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln3108">    {</a>
<a name="ln3109">      // we want to avoid writing the sidecar file if it didn't change to avoid issues when using the same images</a>
<a name="ln3110">      // from different computers. sample use case: images on NAS, several computers using them NOT AT THE SAME TIME and</a>
<a name="ln3111">      // the xmp crawler is used to find changed sidecars.</a>
<a name="ln3112">      FILE *fd = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln3113">      if(fd)</a>
<a name="ln3114">      {</a>
<a name="ln3115">        fseek(fd, 0, SEEK_END);</a>
<a name="ln3116">        size_t end = ftell(fd);</a>
<a name="ln3117">        rewind(fd);</a>
<a name="ln3118">        unsigned char *content = (unsigned char *)malloc(end * sizeof(char));</a>
<a name="ln3119">        if(content)</a>
<a name="ln3120">        {</a>
<a name="ln3121">          if(fread(content, sizeof(unsigned char), end, fd) == end)</a>
<a name="ln3122">            checksum_old = g_compute_checksum_for_data(G_CHECKSUM_MD5, content, end);</a>
<a name="ln3123">          free(content);</a>
<a name="ln3124">        }</a>
<a name="ln3125">        fclose(fd);</a>
<a name="ln3126">      }</a>
<a name="ln3127"> </a>
<a name="ln3128">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(filename));</a>
<a name="ln3129">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln3130">      Exiv2::XmpParser::decode(xmpData, xmpPacket);</a>
<a name="ln3131">      // because XmpSeq or XmpBag are added to the list, we first have</a>
<a name="ln3132">      // to remove these so that we don't end up with a string of duplicates</a>
<a name="ln3133">      dt_remove_known_keys(xmpData);</a>
<a name="ln3134">    }</a>
<a name="ln3135"> </a>
<a name="ln3136">    // initialize xmp data:</a>
<a name="ln3137">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln3138"> </a>
<a name="ln3139">    // serialize the xmp data and output the xmp packet</a>
<a name="ln3140">    if(Exiv2::XmpParser::encode(xmpPacket, xmpData,</a>
<a name="ln3141">       Exiv2::XmpParser::useCompactFormat | Exiv2::XmpParser::omitPacketWrapper) != 0)</a>
<a name="ln3142">    {</a>
<a name="ln3143">      throw Exiv2::Error(ERROR_CODE(1), &quot;[xmp_write] failed to serialize xmp data&quot;);</a>
<a name="ln3144">    }</a>
<a name="ln3145"> </a>
<a name="ln3146">    // hash the new data and compare it to the old hash (if applicable)</a>
<a name="ln3147">    const char *xml_header = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;</a>
<a name="ln3148">    gboolean write_sidecar = TRUE;</a>
<a name="ln3149">    if(checksum_old)</a>
<a name="ln3150">    {</a>
<a name="ln3151">      GChecksum *checksum = g_checksum_new(G_CHECKSUM_MD5);</a>
<a name="ln3152">      if(checksum)</a>
<a name="ln3153">      {</a>
<a name="ln3154">        g_checksum_update(checksum, (unsigned char*)xml_header, -1);</a>
<a name="ln3155">        g_checksum_update(checksum, (unsigned char*)xmpPacket.c_str(), -1);</a>
<a name="ln3156">        const char *checksum_new = g_checksum_get_string(checksum);</a>
<a name="ln3157">        write_sidecar = g_strcmp0(checksum_old, checksum_new) != 0;</a>
<a name="ln3158">        g_checksum_free(checksum);</a>
<a name="ln3159">      }</a>
<a name="ln3160">      g_free(checksum_old);</a>
<a name="ln3161">    }</a>
<a name="ln3162"> </a>
<a name="ln3163">    if(write_sidecar)</a>
<a name="ln3164">    {</a>
<a name="ln3165">      // using std::ofstream isn't possible here -- on Windows it doesn't support Unicode filenames with mingw</a>
<a name="ln3166">      FILE *fout = g_fopen(filename, &quot;wb&quot;);</a>
<a name="ln3167">      if(fout)</a>
<a name="ln3168">      {</a>
<a name="ln3169">        fprintf(fout, &quot;%s&quot;, xml_header);</a>
<a name="ln3170">        fprintf(fout, &quot;%s&quot;, xmpPacket.c_str());</a>
<a name="ln3171">        fclose(fout);</a>
<a name="ln3172">      }</a>
<a name="ln3173">    }</a>
<a name="ln3174"> </a>
<a name="ln3175">    return 0;</a>
<a name="ln3176">  }</a>
<a name="ln3177">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3178">  {</a>
<a name="ln3179">    std::cerr &lt;&lt; &quot;[xmp_write] &quot; &lt;&lt; filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3180">    return -1;</a>
<a name="ln3181">  }</a>
<a name="ln3182">}</a>
<a name="ln3183"> </a>
<a name="ln3184">dt_colorspaces_color_profile_type_t dt_exif_get_color_space(const uint8_t *data, size_t size)</a>
<a name="ln3185">{</a>
<a name="ln3186">  try</a>
<a name="ln3187">  {</a>
<a name="ln3188">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln3189">    Exiv2::ExifData exifData;</a>
<a name="ln3190">    Exiv2::ExifParser::decode(exifData, data, size);</a>
<a name="ln3191"> </a>
<a name="ln3192">    // 0x01   -&gt; sRGB</a>
<a name="ln3193">    // 0x02   -&gt; AdobeRGB</a>
<a name="ln3194">    // 0xffff -&gt; Uncalibrated</a>
<a name="ln3195">    //          + Exif.Iop.InteroperabilityIndex of 'R03' -&gt; AdobeRGB</a>
<a name="ln3196">    //          + Exif.Iop.InteroperabilityIndex of 'R98' -&gt; sRGB</a>
<a name="ln3197">    if((pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.ColorSpace&quot;))) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln3198">    {</a>
<a name="ln3199">      int colorspace = pos-&gt;toLong();</a>
<a name="ln3200">      if(colorspace == 0x01)</a>
<a name="ln3201">        return DT_COLORSPACE_SRGB;</a>
<a name="ln3202">      else if(colorspace == 0x02)</a>
<a name="ln3203">        return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln3204">      else if(colorspace == 0xffff)</a>
<a name="ln3205">      {</a>
<a name="ln3206">        if((pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Iop.InteroperabilityIndex&quot;))) != exifData.end()</a>
<a name="ln3207">          &amp;&amp; pos-&gt;size())</a>
<a name="ln3208">        {</a>
<a name="ln3209">          std::string interop_index = pos-&gt;toString();</a>
<a name="ln3210">          if(interop_index == &quot;R03&quot;)</a>
<a name="ln3211">            return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln3212">          else if(interop_index == &quot;R98&quot;)</a>
<a name="ln3213">            return DT_COLORSPACE_SRGB;</a>
<a name="ln3214">        }</a>
<a name="ln3215">      }</a>
<a name="ln3216">    }</a>
<a name="ln3217"> </a>
<a name="ln3218">    return DT_COLORSPACE_DISPLAY; // nothing embedded</a>
<a name="ln3219">  }</a>
<a name="ln3220">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3221">  {</a>
<a name="ln3222">    std::string s(e.what());</a>
<a name="ln3223">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln3224">    return DT_COLORSPACE_DISPLAY;</a>
<a name="ln3225">  }</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228">gboolean dt_exif_get_datetime_taken(const uint8_t *data, size_t size, time_t *datetime_taken)</a>
<a name="ln3229">{</a>
<a name="ln3230">  try</a>
<a name="ln3231">  {</a>
<a name="ln3232">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln3233">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(data, size));</a>
<a name="ln3234">    read_metadata_threadsafe(image);</a>
<a name="ln3235">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln3236"> </a>
<a name="ln3237">    char exif_datetime_taken[20];</a>
<a name="ln3238">    _find_datetime_taken(exifData, pos, exif_datetime_taken);</a>
<a name="ln3239"> </a>
<a name="ln3240">    if(*exif_datetime_taken)</a>
<a name="ln3241">    {</a>
<a name="ln3242">      struct tm exif_tm= {0};</a>
<a name="ln3243">      if(sscanf(exif_datetime_taken,&quot;%d:%d:%d %d:%d:%d&quot;,</a>
<a name="ln3244">        &amp;exif_tm.tm_year,</a>
<a name="ln3245">        &amp;exif_tm.tm_mon,</a>
<a name="ln3246">        &amp;exif_tm.tm_mday,</a>
<a name="ln3247">        &amp;exif_tm.tm_hour,</a>
<a name="ln3248">        &amp;exif_tm.tm_min,</a>
<a name="ln3249">        &amp;exif_tm.tm_sec) == 6)</a>
<a name="ln3250">      {</a>
<a name="ln3251">        exif_tm.tm_year -= 1900;</a>
<a name="ln3252">        exif_tm.tm_mon--;</a>
<a name="ln3253">        *datetime_taken = mktime(&amp;exif_tm);</a>
<a name="ln3254">        return TRUE;</a>
<a name="ln3255">      }</a>
<a name="ln3256">    }</a>
<a name="ln3257"> </a>
<a name="ln3258">    return FALSE;</a>
<a name="ln3259">  }</a>
<a name="ln3260">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3261">  {</a>
<a name="ln3262">    std::string s(e.what());</a>
<a name="ln3263">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln3264">    return FALSE;</a>
<a name="ln3265">  }</a>
<a name="ln3266">}</a>
<a name="ln3267"> </a>
<a name="ln3268">static void dt_exif_log_handler(int log_level, const char *message)</a>
<a name="ln3269">{</a>
<a name="ln3270">  if(log_level &gt;= Exiv2::LogMsg::level())</a>
<a name="ln3271">  {</a>
<a name="ln3272">    // We don't seem to need \n in the format string as exiv2 includes it</a>
<a name="ln3273">    // in the messages themselves</a>
<a name="ln3274">    dt_print(DT_DEBUG_CAMERA_SUPPORT, &quot;[exiv2] %s&quot;, message);</a>
<a name="ln3275">  }</a>
<a name="ln3276">}</a>
<a name="ln3277"> </a>
<a name="ln3278">void dt_exif_init()</a>
<a name="ln3279">{</a>
<a name="ln3280">  // preface the exiv2 messages with &quot;[exiv2] &quot;</a>
<a name="ln3281">  Exiv2::LogMsg::setHandler(&amp;dt_exif_log_handler);</a>
<a name="ln3282"> </a>
<a name="ln3283">  Exiv2::XmpParser::initialize();</a>
<a name="ln3284">  // this has to stay with the old url (namespace already propagated outside dt)</a>
<a name="ln3285">  Exiv2::XmpProperties::registerNs(&quot;http://darktable.sf.net/&quot;, &quot;darktable&quot;);</a>
<a name="ln3286">  Exiv2::XmpProperties::registerNs(&quot;http://ns.adobe.com/lightroom/1.0/&quot;, &quot;lr&quot;);</a>
<a name="ln3287">  Exiv2::XmpProperties::registerNs(&quot;http://cipa.jp/exif/1.0/&quot;, &quot;exifEX&quot;);</a>
<a name="ln3288">}</a>
<a name="ln3289"> </a>
<a name="ln3290">void dt_exif_cleanup()</a>
<a name="ln3291">{</a>
<a name="ln3292">  Exiv2::XmpParser::terminate();</a>
<a name="ln3293">}</a>
<a name="ln3294"> </a>
<a name="ln3295">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3296">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3297">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 224, 222.</p></div>
<div class="balloon" rel="237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 237, 235.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 250, 248.</p></div>
<div class="balloon" rel="263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 263, 261.</p></div>
<div class="balloon" rel="276"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 276, 274.</p></div>
<div class="balloon" rel="356"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 356, 354.</p></div>
<div class="balloon" rel="379"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strchr' function. Inspect the first argument. Check lines: 379, 369.</p></div>
<div class="balloon" rel="1488"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'compress' function. Inspect the first argument. Check lines: 1488, 1486.</p></div>
<div class="balloon" rel="1573"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'output' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value.</p></div>
<div class="balloon" rel="1839"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 1839, 1838.</p></div>
<div class="balloon" rel="1925"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_length' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1929"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 1929, 1928.</p></div>
<div class="balloon" rel="2046"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'. Check lines: 2046, 2044.</p></div>
<div class="balloon" rel="2050"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'mask_name_str.c_str() != __null' is always true.</p></div>
<div class="balloon" rel="2115"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_length' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2119"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 2119, 2118.</p></div>
<div class="balloon" rel="2948"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="3238"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized iterator 'pos' used. Consider checking the second actual argument of the '_find_datetime_taken' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
