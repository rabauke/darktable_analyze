
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   This file is part of darktable,</a>
<a name="ln3">   copyright (c) 2009--2013 johannes hanika.</a>
<a name="ln4">   copyright (c) 2011 henrik andersson.</a>
<a name="ln5">   copyright (c) 2012-2017 tobias ellinghaus.</a>
<a name="ln6"> </a>
<a name="ln7">   darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">   it under the terms of the GNU General Public License as published by</a>
<a name="ln9">   the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">   (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">   darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">   GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">   You should have received a copy of the GNU General Public License</a>
<a name="ln18">   along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#define __STDC_FORMAT_MACROS</a>
<a name="ln22"> </a>
<a name="ln23">extern &quot;C&quot; {</a>
<a name="ln24">#ifdef HAVE_CONFIG_H</a>
<a name="ln25">#include &quot;config.h&quot;</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;glib.h&gt;</a>
<a name="ln29">#include &lt;sqlite3.h&gt;</a>
<a name="ln30">#include &lt;sys/stat.h&gt;</a>
<a name="ln31">#include &lt;sys/types.h&gt;</a>
<a name="ln32">#include &lt;time.h&gt;</a>
<a name="ln33">#include &lt;unistd.h&gt;</a>
<a name="ln34">#include &lt;zlib.h&gt;</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;cassert&gt;</a>
<a name="ln38">#include &lt;cmath&gt;</a>
<a name="ln39">#include &lt;fstream&gt;</a>
<a name="ln40">#include &lt;iostream&gt;</a>
<a name="ln41">#include &lt;sstream&gt;</a>
<a name="ln42">#include &lt;string&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &lt;exiv2/exiv2.hpp&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#if defined(_WIN32) &amp;&amp; defined(EXV_UNICODE_PATH)</a>
<a name="ln47">  #define WIDEN(s) pugi::as_wide(s)</a>
<a name="ln48">#else</a>
<a name="ln49">  #define WIDEN(s) (s)</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;pugixml.hpp&gt;</a>
<a name="ln53"> </a>
<a name="ln54">using namespace std;</a>
<a name="ln55"> </a>
<a name="ln56">extern &quot;C&quot; {</a>
<a name="ln57">#include &quot;common/colorlabels.h&quot;</a>
<a name="ln58">#include &quot;common/darktable.h&quot;</a>
<a name="ln59">#include &quot;common/debug.h&quot;</a>
<a name="ln60">#include &quot;common/image_cache.h&quot;</a>
<a name="ln61">#include &quot;common/imageio.h&quot;</a>
<a name="ln62">#include &quot;common/exif.h&quot;</a>
<a name="ln63">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln64">#include &quot;common/metadata.h&quot;</a>
<a name="ln65">#include &quot;common/tags.h&quot;</a>
<a name="ln66">#include &quot;common/iop_order.h&quot;</a>
<a name="ln67">#include &quot;common/variables.h&quot;</a>
<a name="ln68">#include &quot;control/conf.h&quot;</a>
<a name="ln69">#include &quot;develop/imageop.h&quot;</a>
<a name="ln70">#include &quot;develop/blend.h&quot;</a>
<a name="ln71">#include &quot;develop/masks.h&quot;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">#include &quot;external/adobe_coeff.c&quot;</a>
<a name="ln75"> </a>
<a name="ln76">// exiv2's readMetadata is not thread safe in 0.26. so we lock it. since readMetadata might throw an exception we</a>
<a name="ln77">// wrap it into some c++ magic to make sure we unlock in all cases. well, actually not magic but basic raii.</a>
<a name="ln78">// FIXME: check again once we rely on 0.27</a>
<a name="ln79">class Lock</a>
<a name="ln80">{</a>
<a name="ln81">public:</a>
<a name="ln82">  Lock() { dt_pthread_mutex_lock(&amp;darktable.exiv2_threadsafe); }</a>
<a name="ln83">  ~Lock() { dt_pthread_mutex_unlock(&amp;darktable.exiv2_threadsafe); }</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86">#define read_metadata_threadsafe(image)                       \</a>
<a name="ln87">{                                                             \</a>
<a name="ln88">  Lock lock;                                                  \</a>
<a name="ln89">  image-&gt;readMetadata();                                      \</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">static void _exif_import_tags(dt_image_t *img, Exiv2::XmpData::iterator &amp;pos);</a>
<a name="ln93"> </a>
<a name="ln94">// this array should contain all XmpBag and XmpSeq keys used by dt</a>
<a name="ln95">const char *dt_xmp_keys[]</a>
<a name="ln96">    = { &quot;Xmp.dc.subject&quot;, &quot;Xmp.lr.hierarchicalSubject&quot;, &quot;Xmp.darktable.colorlabels&quot;, &quot;Xmp.darktable.history&quot;,</a>
<a name="ln97">        &quot;Xmp.darktable.history_modversion&quot;, &quot;Xmp.darktable.history_enabled&quot;, &quot;Xmp.darktable.history_end&quot;, &quot;Xmp.darktable.iop_order_version&quot;,</a>
<a name="ln98">        &quot;Xmp.darktable.history_operation&quot;, &quot;Xmp.darktable.history_params&quot;, &quot;Xmp.darktable.blendop_params&quot;,</a>
<a name="ln99">        &quot;Xmp.darktable.blendop_version&quot;, &quot;Xmp.darktable.multi_priority&quot;, &quot;Xmp.darktable.multi_name&quot;, &quot;Xmp.darktable.iop_order&quot;,</a>
<a name="ln100">        &quot;Xmp.darktable.xmp_version&quot;, &quot;Xmp.darktable.raw_params&quot;, &quot;Xmp.darktable.auto_presets_applied&quot;,</a>
<a name="ln101">        &quot;Xmp.darktable.mask_id&quot;, &quot;Xmp.darktable.mask_type&quot;, &quot;Xmp.darktable.mask_name&quot;,</a>
<a name="ln102">        &quot;Xmp.darktable.masks_history&quot;, &quot;Xmp.darktable.mask_num&quot;, &quot;Xmp.darktable.mask_points&quot;,</a>
<a name="ln103">        &quot;Xmp.darktable.mask_version&quot;, &quot;Xmp.darktable.mask&quot;, &quot;Xmp.darktable.mask_nb&quot;, &quot;Xmp.darktable.mask_src&quot;,</a>
<a name="ln104">        &quot;Xmp.dc.creator&quot;, &quot;Xmp.dc.publisher&quot;, &quot;Xmp.dc.title&quot;, &quot;Xmp.dc.description&quot;, &quot;Xmp.dc.rights&quot;,</a>
<a name="ln105">        &quot;Xmp.xmpMM.DerivedFrom&quot; };</a>
<a name="ln106"> </a>
<a name="ln107">static const guint dt_xmp_keys_n = G_N_ELEMENTS(dt_xmp_keys); // the number of XmpBag XmpSeq keys that dt uses</a>
<a name="ln108"> </a>
<a name="ln109">// inspired by ufraw_exiv2.cc:</a>
<a name="ln110"> </a>
<a name="ln111">static void dt_strlcpy_to_utf8(char *dest, size_t dest_max, Exiv2::ExifData::const_iterator &amp;pos,</a>
<a name="ln112">                               Exiv2::ExifData &amp;exifData)</a>
<a name="ln113">{</a>
<a name="ln114">  std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln115"> </a>
<a name="ln116">  char *s = g_locale_to_utf8(str.c_str(), str.length(), NULL, NULL, NULL);</a>
<a name="ln117">  if(s != NULL)</a>
<a name="ln118">  {</a>
<a name="ln119">    g_strlcpy(dest, s, dest_max);</a>
<a name="ln120">    g_free(s);</a>
<a name="ln121">  }</a>
<a name="ln122">  else</a>
<a name="ln123">  {</a>
<a name="ln124">    g_strlcpy(dest, str.c_str(), dest_max);</a>
<a name="ln125">  }</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">// function to remove known dt keys and subtrees from xmpdata, so not to append them twice</a>
<a name="ln129">// this should work because dt first reads all known keys</a>
<a name="ln130">static void dt_remove_known_keys(Exiv2::XmpData &amp;xmp)</a>
<a name="ln131">{</a>
<a name="ln132">  xmp.sortByKey();</a>
<a name="ln133">  for(unsigned int i = 0; i &lt; dt_xmp_keys_n; i++)</a>
<a name="ln134">  {</a>
<a name="ln135">    Exiv2::XmpData::iterator pos = xmp.findKey(Exiv2::XmpKey(dt_xmp_keys[i]));</a>
<a name="ln136"> </a>
<a name="ln137">    while(pos != xmp.end())</a>
<a name="ln138">    {</a>
<a name="ln139">      std::string key = pos-&gt;key();</a>
<a name="ln140">      const char *ckey = key.c_str();</a>
<a name="ln141">      size_t len = key.size();</a>
<a name="ln142">      // stop iterating once the key no longer matches what we are trying to delete. this assumes sorted input</a>
<a name="ln143">      if(!(g_str_has_prefix(ckey, dt_xmp_keys[i]) &amp;&amp; (ckey[len] == '[' || ckey[len] == '\0')))</a>
<a name="ln144">        break;</a>
<a name="ln145">      pos = xmp.erase(pos);</a>
<a name="ln146">    }</a>
<a name="ln147">  }</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static void dt_remove_exif_keys(Exiv2::ExifData &amp;exif, const char *keys[], unsigned int n_keys)</a>
<a name="ln151">{</a>
<a name="ln152">  for(unsigned int i = 0; i &lt; n_keys; i++)</a>
<a name="ln153">  {</a>
<a name="ln154">    try</a>
<a name="ln155">    {</a>
<a name="ln156">      Exiv2::ExifData::iterator pos;</a>
<a name="ln157">      while((pos = exif.findKey(Exiv2::ExifKey(keys[i]))) != exif.end())</a>
<a name="ln158">        exif.erase(pos);</a>
<a name="ln159">    }</a>
<a name="ln160">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln161">    {</a>
<a name="ln162">      // the only exception we may get is &quot;invalid&quot; tag, which is not</a>
<a name="ln163">      // important enough to either stop the function, or even display</a>
<a name="ln164">      // a message (it's probably the tag is not implemented in the</a>
<a name="ln165">      // exiv2 version used)</a>
<a name="ln166">    }</a>
<a name="ln167">  }</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">static void dt_remove_xmp_keys(Exiv2::XmpData &amp;xmp, const char *keys[], unsigned int n_keys)</a>
<a name="ln171">{</a>
<a name="ln172">  for(unsigned int i = 0; i &lt; n_keys; i++)</a>
<a name="ln173">  {</a>
<a name="ln174">    try</a>
<a name="ln175">    {</a>
<a name="ln176">      Exiv2::XmpData::iterator pos;</a>
<a name="ln177">      while((pos = xmp.findKey(Exiv2::XmpKey(keys[i]))) != xmp.end())</a>
<a name="ln178">        xmp.erase(pos);</a>
<a name="ln179">    }</a>
<a name="ln180">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln181">    {</a>
<a name="ln182">      // the only exception we may get is &quot;invalid&quot; tag, which is not</a>
<a name="ln183">      // important enough to either stop the function, or even display</a>
<a name="ln184">      // a message (it's probably the tag is not implemented in the</a>
<a name="ln185">      // exiv2 version used)</a>
<a name="ln186">    }</a>
<a name="ln187">  }</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static bool dt_exif_read_xmp_tag(Exiv2::XmpData &amp;xmpData, Exiv2::XmpData::iterator *pos, string key)</a>
<a name="ln191">{</a>
<a name="ln192">  try</a>
<a name="ln193">  {</a>
<a name="ln194">    return (*pos = xmpData.findKey(Exiv2::XmpKey(key))) != xmpData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln195">  }</a>
<a name="ln196">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln197">  {</a>
<a name="ln198">    std::string s(e.what());</a>
<a name="ln199">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln200">    return false;</a>
<a name="ln201">  }</a>
<a name="ln202">}</a>
<a name="ln203">#define FIND_XMP_TAG(key) dt_exif_read_xmp_tag(xmpData, &amp;pos, key)</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">// FIXME: according to http://www.exiv2.org/doc/classExiv2_1_1Metadatum.html#63c2b87249ba96679c29e01218169124</a>
<a name="ln207">// there is no need to pass xmpData</a>
<a name="ln208">// version = -1 -&gt; version ignored</a>
<a name="ln209">static bool dt_exif_read_xmp_data(dt_image_t *img, Exiv2::XmpData &amp;xmpData, int version,</a>
<a name="ln210">                                  bool use_default_rating)</a>
<a name="ln211">{</a>
<a name="ln212">  try</a>
<a name="ln213">  {</a>
<a name="ln214">    Exiv2::XmpData::iterator pos;</a>
<a name="ln215"> </a>
<a name="ln216">    // older darktable version did not write this data correctly:</a>
<a name="ln217">    // the reasoning behind strdup'ing all the strings before passing it to sqlite3 is, that</a>
<a name="ln218">    // they are somehow corrupt after the call to sqlite3_prepare_v2() -- don't ask me</a>
<a name="ln219">    // why for they don't get passed to that function.</a>
<a name="ln220">    if(version == -1 || version &gt; 0)</a>
<a name="ln221">    {</a>
<a name="ln222">      if(FIND_XMP_TAG(&quot;Xmp.dc.rights&quot;))</a>
<a name="ln223">      {</a>
<a name="ln224">        // rights</a>
<a name="ln225">        char *rights = strdup(pos-&gt;toString().c_str());</a>
<a name="ln226">        char *adr = rights;</a>
<a name="ln227">        if(strncmp(rights, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln228">        {</a>
<a name="ln229">          rights = strchr(rights, ' ');</a>
<a name="ln230">          if(rights != NULL) rights++;</a>
<a name="ln231">        }</a>
<a name="ln232">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, rights);</a>
<a name="ln233">        free(adr);</a>
<a name="ln234">      }</a>
<a name="ln235">      if(FIND_XMP_TAG(&quot;Xmp.dc.description&quot;))</a>
<a name="ln236">      {</a>
<a name="ln237">        // description</a>
<a name="ln238">        char *description = strdup(pos-&gt;toString().c_str());</a>
<a name="ln239">        char *adr = description;</a>
<a name="ln240">        if(strncmp(description, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln241">        {</a>
<a name="ln242">          description = strchr(description, ' ');</a>
<a name="ln243">          if(description != NULL) description++;</a>
<a name="ln244">        }</a>
<a name="ln245">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, description);</a>
<a name="ln246">        free(adr);</a>
<a name="ln247">      }</a>
<a name="ln248">      if(FIND_XMP_TAG(&quot;Xmp.dc.title&quot;))</a>
<a name="ln249">      {</a>
<a name="ln250">        // title</a>
<a name="ln251">        char *title = strdup(pos-&gt;toString().c_str());</a>
<a name="ln252">        char *adr = title;</a>
<a name="ln253">        if(strncmp(title, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln254">        {</a>
<a name="ln255">          title = strchr(title, ' ');</a>
<a name="ln256">          if(title != NULL) title++;</a>
<a name="ln257">        }</a>
<a name="ln258">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.title&quot;, title);</a>
<a name="ln259">        free(adr);</a>
<a name="ln260">      }</a>
<a name="ln261">      if(FIND_XMP_TAG(&quot;Xmp.dc.creator&quot;))</a>
<a name="ln262">      {</a>
<a name="ln263">        // creator</a>
<a name="ln264">        char *creator = strdup(pos-&gt;toString().c_str());</a>
<a name="ln265">        char *adr = creator;</a>
<a name="ln266">        if(strncmp(creator, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln267">        {</a>
<a name="ln268">          creator = strchr(creator, ' ');</a>
<a name="ln269">          if(creator != NULL) creator++;</a>
<a name="ln270">        }</a>
<a name="ln271">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, creator);</a>
<a name="ln272">        free(adr);</a>
<a name="ln273">      }</a>
<a name="ln274">      if(FIND_XMP_TAG(&quot;Xmp.dc.publisher&quot;))</a>
<a name="ln275">      {</a>
<a name="ln276">        // publisher</a>
<a name="ln277">        char *publisher = strdup(pos-&gt;toString().c_str());</a>
<a name="ln278">        char *adr = publisher;</a>
<a name="ln279">        if(strncmp(publisher, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln280">        {</a>
<a name="ln281">          publisher = strchr(publisher, ' ');</a>
<a name="ln282">          if(publisher != NULL) publisher++;</a>
<a name="ln283">        }</a>
<a name="ln284">        dt_metadata_set(img-&gt;id, &quot;Xmp.dc.publisher&quot;, publisher);</a>
<a name="ln285">        free(adr);</a>
<a name="ln286">      }</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">    if(FIND_XMP_TAG(&quot;Xmp.xmp.Rating&quot;))</a>
<a name="ln290">    {</a>
<a name="ln291">      int stars = pos-&gt;toLong();</a>
<a name="ln292">      if(use_default_rating &amp;&amp; stars == 0) stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln293"> </a>
<a name="ln294">      stars = (stars == -1) ? 6 : stars;</a>
<a name="ln295">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln296">    }</a>
<a name="ln297"> </a>
<a name="ln298">    if(FIND_XMP_TAG(&quot;Xmp.xmp.Label&quot;))</a>
<a name="ln299">    {</a>
<a name="ln300">      std::string label = pos-&gt;toString();</a>
<a name="ln301">      if(label == &quot;Red&quot;) // Is it really called like that in XMP files?</a>
<a name="ln302">        dt_colorlabels_set_label(img-&gt;id, 0);</a>
<a name="ln303">      else if(label == &quot;Yellow&quot;) // Is it really called like that in XMP files?</a>
<a name="ln304">        dt_colorlabels_set_label(img-&gt;id, 1);</a>
<a name="ln305">      else if(label == &quot;Green&quot;)</a>
<a name="ln306">        dt_colorlabels_set_label(img-&gt;id, 2);</a>
<a name="ln307">      else if(label == &quot;Blue&quot;) // Is it really called like that in XMP files?</a>
<a name="ln308">        dt_colorlabels_set_label(img-&gt;id, 3);</a>
<a name="ln309">      else if(label == &quot;Purple&quot;) // Is it really called like that in XMP files?</a>
<a name="ln310">        dt_colorlabels_set_label(img-&gt;id, 4);</a>
<a name="ln311">    }</a>
<a name="ln312">    if(FIND_XMP_TAG(&quot;Xmp.darktable.colorlabels&quot;))</a>
<a name="ln313">    {</a>
<a name="ln314">      // TODO: store these in dc:subject or xmp:Label?</a>
<a name="ln315">      // color labels</a>
<a name="ln316">      const int cnt = pos-&gt;count();</a>
<a name="ln317">      dt_colorlabels_remove_labels(img-&gt;id);</a>
<a name="ln318">      for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln319">      {</a>
<a name="ln320">        dt_colorlabels_set_label(img-&gt;id, pos-&gt;toLong(i));</a>
<a name="ln321">      }</a>
<a name="ln322">    }</a>
<a name="ln323"> </a>
<a name="ln324">    if(FIND_XMP_TAG(&quot;Xmp.lr.hierarchicalSubject&quot;))</a>
<a name="ln325">      _exif_import_tags(img, pos);</a>
<a name="ln326">    else if(FIND_XMP_TAG(&quot;Xmp.dc.subject&quot;))</a>
<a name="ln327">      _exif_import_tags(img, pos);</a>
<a name="ln328"> </a>
<a name="ln329">    /* read gps location */</a>
<a name="ln330">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSLatitude&quot;))</a>
<a name="ln331">    {</a>
<a name="ln332">      img-&gt;geoloc.latitude = dt_util_gps_string_to_number(pos-&gt;toString().c_str());</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSLongitude&quot;))</a>
<a name="ln336">    {</a>
<a name="ln337">      img-&gt;geoloc.longitude = dt_util_gps_string_to_number(pos-&gt;toString().c_str());</a>
<a name="ln338">    }</a>
<a name="ln339"> </a>
<a name="ln340">    if(FIND_XMP_TAG(&quot;Xmp.exif.GPSAltitude&quot;))</a>
<a name="ln341">    {</a>
<a name="ln342">      Exiv2::XmpData::const_iterator ref = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.exif.GPSAltitudeRef&quot;));</a>
<a name="ln343">      if(ref != xmpData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln344">      {</a>
<a name="ln345">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln346">        const char *sign = sign_str.c_str();</a>
<a name="ln347">        double elevation = 0.0;</a>
<a name="ln348">        if(dt_util_gps_elevation_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second, sign[0], &amp;elevation))</a>
<a name="ln349">          img-&gt;geoloc.elevation = elevation;</a>
<a name="ln350">      }</a>
<a name="ln351">    }</a>
<a name="ln352"> </a>
<a name="ln353">    /* read lens type from Xmp.exifEX.LensModel */</a>
<a name="ln354">    if(FIND_XMP_TAG(&quot;Xmp.exifEX.LensModel&quot;))</a>
<a name="ln355">    {</a>
<a name="ln356">      // lens model</a>
<a name="ln357">      char *lens = strdup(pos-&gt;toString().c_str());</a>
<a name="ln358">      char *adr =  lens;</a>
<a name="ln359">      if(strncmp(lens, &quot;lang=&quot;, 5) == 0)</a>
<a name="ln360">      {</a>
<a name="ln361">        lens = strchr(lens, ' ');</a>
<a name="ln362">        if(lens != NULL) lens++;</a>
<a name="ln363">      }</a>
<a name="ln364">      // no need to do any Unicode&lt;-&gt;locale conversion, the field is specified as ASCII</a>
<a name="ln365">      g_strlcpy(img-&gt;exif_lens, lens, sizeof(img-&gt;exif_lens));</a>
<a name="ln366">      free(adr);</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">    /* read timestamp from Xmp.exif.DateTimeOriginal */</a>
<a name="ln370">    if(FIND_XMP_TAG(&quot;Xmp.exif.DateTimeOriginal&quot;))</a>
<a name="ln371">    {</a>
<a name="ln372">      char *datetime = strdup(pos-&gt;toString().c_str());</a>
<a name="ln373"> </a>
<a name="ln374">      /*</a>
<a name="ln375">       * exiftool (but apparently not evix2) convert</a>
<a name="ln376">       * e.g. &quot;2017:10:23 12:34:56&quot; to &quot;2017-10-23T12:34:54&quot; (ISO)</a>
<a name="ln377">       * revert this to the format expected by exif and darktable</a>
<a name="ln378">       */</a>
<a name="ln379"> </a>
<a name="ln380">      // replace 'T' by ' ' (space)</a>
<a name="ln381">      char *c ;</a>
<a name="ln382">      while ( ( c = strchr(datetime,'T') ) != NULL )</a>
<a name="ln383">      {</a>
<a name="ln384">	*c = ' ';</a>
<a name="ln385">      }</a>
<a name="ln386">      // replace '-' by ':'</a>
<a name="ln387">      while ( ( c = strchr(datetime,'-')) != NULL ) {</a>
<a name="ln388">	*c = ':';</a>
<a name="ln389">      }</a>
<a name="ln390"> </a>
<a name="ln391">      g_strlcpy(img-&gt;exif_datetime_taken, datetime, sizeof(img-&gt;exif_datetime_taken));</a>
<a name="ln392">      free(datetime);</a>
<a name="ln393">    }</a>
<a name="ln394"> </a>
<a name="ln395">    return true;</a>
<a name="ln396">  }</a>
<a name="ln397">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln398">  {</a>
<a name="ln399">    std::string s(e.what());</a>
<a name="ln400">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln401">    return false;</a>
<a name="ln402">  }</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">static bool dt_exif_read_iptc_tag(Exiv2::IptcData &amp;iptcData, Exiv2::IptcData::const_iterator *pos, string key)</a>
<a name="ln406">{</a>
<a name="ln407">  try</a>
<a name="ln408">  {</a>
<a name="ln409">    return (*pos = iptcData.findKey(Exiv2::IptcKey(key))) != iptcData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln410">  }</a>
<a name="ln411">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln412">  {</a>
<a name="ln413">    std::string s(e.what());</a>
<a name="ln414">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln415">    return false;</a>
<a name="ln416">  }</a>
<a name="ln417">}</a>
<a name="ln418">#define FIND_IPTC_TAG(key) dt_exif_read_iptc_tag(iptcData, &amp;pos, key)</a>
<a name="ln419"> </a>
<a name="ln420"> </a>
<a name="ln421">// FIXME: according to http://www.exiv2.org/doc/classExiv2_1_1Metadatum.html#63c2b87249ba96679c29e01218169124</a>
<a name="ln422">// there is no need to pass iptcData</a>
<a name="ln423">static bool dt_exif_read_iptc_data(dt_image_t *img, Exiv2::IptcData &amp;iptcData)</a>
<a name="ln424">{</a>
<a name="ln425">  try</a>
<a name="ln426">  {</a>
<a name="ln427">    Exiv2::IptcData::const_iterator pos;</a>
<a name="ln428">    iptcData.sortByKey(); // this helps to quickly find all Iptc.Application2.Keywords</a>
<a name="ln429"> </a>
<a name="ln430">    if((pos = iptcData.findKey(Exiv2::IptcKey(&quot;Iptc.Application2.Keywords&quot;))) != iptcData.end())</a>
<a name="ln431">    {</a>
<a name="ln432">      while(pos != iptcData.end())</a>
<a name="ln433">      {</a>
<a name="ln434">        std::string key = pos-&gt;key();</a>
<a name="ln435">        if(g_strcmp0(key.c_str(), &quot;Iptc.Application2.Keywords&quot;)) break;</a>
<a name="ln436">        std::string str = pos-&gt;print();</a>
<a name="ln437">        char *tag = dt_util_foo_to_utf8(str.c_str());</a>
<a name="ln438">        guint tagid = 0;</a>
<a name="ln439">        dt_tag_new(tag, &amp;tagid);</a>
<a name="ln440">        dt_tag_attach_from_gui(tagid, img-&gt;id);</a>
<a name="ln441">        g_free(tag);</a>
<a name="ln442">        ++pos;</a>
<a name="ln443">      }</a>
<a name="ln444">    }</a>
<a name="ln445">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Caption&quot;))</a>
<a name="ln446">    {</a>
<a name="ln447">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln448">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, str.c_str());</a>
<a name="ln449">    }</a>
<a name="ln450">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Copyright&quot;))</a>
<a name="ln451">    {</a>
<a name="ln452">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln453">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str.c_str());</a>
<a name="ln454">    }</a>
<a name="ln455">    if(FIND_IPTC_TAG(&quot;Iptc.Application2.Writer&quot;))</a>
<a name="ln456">    {</a>
<a name="ln457">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln458">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln459">    }</a>
<a name="ln460">    else if(FIND_IPTC_TAG(&quot;Iptc.Application2.Contact&quot;))</a>
<a name="ln461">    {</a>
<a name="ln462">      std::string str = pos-&gt;print(/*&amp;iptcData*/);</a>
<a name="ln463">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln464">    }</a>
<a name="ln465"> </a>
<a name="ln466">    return true;</a>
<a name="ln467">  }</a>
<a name="ln468">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln469">  {</a>
<a name="ln470">    std::string s(e.what());</a>
<a name="ln471">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln472">    return false;</a>
<a name="ln473">  }</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">// Support DefaultUserCrop, what is the safe exif tag?</a>
<a name="ln477">// Magic-nr taken from dng specs, the specs also say it has 4 floats (top,left,bottom,right</a>
<a name="ln478">// We only take them if a) we find a value != the default *and* b) data are plausible</a>
<a name="ln479">static bool dt_check_usercrop(Exiv2::ExifData &amp;exifData, dt_image_t *img)</a>
<a name="ln480">{</a>
<a name="ln481">  Exiv2::ExifData::const_iterator pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.SubImage1.0xc7b5&quot;));</a>
<a name="ln482">  if(pos != exifData.end() &amp;&amp; pos-&gt;count() == 4 &amp;&amp; pos-&gt;size())</a>
<a name="ln483">  {</a>
<a name="ln484">    float crop[4];</a>
<a name="ln485">    for(int i = 0; i &lt; 4; i++) crop[i] = pos-&gt;toFloat(i);</a>
<a name="ln486">    if (((crop[0]&gt;0)||(crop[1]&gt;0)||(crop[2]&lt;1)||(crop[3]&lt;1))&amp;&amp;(crop[2]-crop[0]&gt;0.05f)&amp;&amp;(crop[3]-crop[1]&gt;0.05f))</a>
<a name="ln487">    {</a>
<a name="ln488">      for (int i=0; i&lt;4; i++) img-&gt;usercrop[i] = crop[i];</a>
<a name="ln489">      return TRUE;</a>
<a name="ln490">    }</a>
<a name="ln491">  }</a>
<a name="ln492">  return FALSE;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">void dt_img_check_usercrop(dt_image_t *img, const char *filename)</a>
<a name="ln496">{</a>
<a name="ln497">  try</a>
<a name="ln498">  {</a>
<a name="ln499">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln500">    assert(image.get() != 0);</a>
<a name="ln501">    read_metadata_threadsafe(image);</a>
<a name="ln502">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln503">    if(!exifData.empty()) dt_check_usercrop(exifData, img);</a>
<a name="ln504">    return;</a>
<a name="ln505">  }</a>
<a name="ln506">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln507">  {</a>
<a name="ln508">    std::string s(e.what());</a>
<a name="ln509">    std::cerr &lt;&lt; &quot;[exiv2] reading DefaultUserCrop&quot; &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln510">    return;</a>
<a name="ln511">  }</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">static bool dt_exif_read_exif_tag(Exiv2::ExifData &amp;exifData, Exiv2::ExifData::const_iterator *pos, string key)</a>
<a name="ln515">{</a>
<a name="ln516">  try</a>
<a name="ln517">  {</a>
<a name="ln518">    return (*pos = exifData.findKey(Exiv2::ExifKey(key))) != exifData.end() &amp;&amp; (*pos)-&gt;size();</a>
<a name="ln519">  }</a>
<a name="ln520">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln521">  {</a>
<a name="ln522">    std::string s(e.what());</a>
<a name="ln523">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln524">    return false;</a>
<a name="ln525">  }</a>
<a name="ln526">}</a>
<a name="ln527">#define FIND_EXIF_TAG(key) dt_exif_read_exif_tag(exifData, &amp;pos, key)</a>
<a name="ln528"> </a>
<a name="ln529">static void _find_datetime_taken(Exiv2::ExifData &amp;exifData, Exiv2::ExifData::const_iterator pos,</a>
<a name="ln530">                                 char *exif_datetime_taken)</a>
<a name="ln531">{</a>
<a name="ln532">  if(FIND_EXIF_TAG(&quot;Exif.Image.DateTimeOriginal&quot;))</a>
<a name="ln533">  {</a>
<a name="ln534">    dt_strlcpy_to_utf8(exif_datetime_taken, 20, pos, exifData);</a>
<a name="ln535">  }</a>
<a name="ln536">  else if(FIND_EXIF_TAG(&quot;Exif.Photo.DateTimeOriginal&quot;))</a>
<a name="ln537">  {</a>
<a name="ln538">    dt_strlcpy_to_utf8(exif_datetime_taken, 20, pos, exifData);</a>
<a name="ln539">  }</a>
<a name="ln540">  else</a>
<a name="ln541">  {</a>
<a name="ln542">    *exif_datetime_taken = '\0';</a>
<a name="ln543">  }</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">static void mat3mul(float *dst, const float *const m1, const float *const m2)</a>
<a name="ln547">{</a>
<a name="ln548">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln549">  {</a>
<a name="ln550">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln551">    {</a>
<a name="ln552">      float x = 0.0f;</a>
<a name="ln553">      for(int j = 0; j &lt; 3; j++) x += m1[3 * k + j] * m2[3 * j + i];</a>
<a name="ln554">      dst[3 * k + i] = x;</a>
<a name="ln555">    }</a>
<a name="ln556">  }</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">static bool dt_exif_read_exif_data(dt_image_t *img, Exiv2::ExifData &amp;exifData)</a>
<a name="ln560">{</a>
<a name="ln561">  try</a>
<a name="ln562">  {</a>
<a name="ln563">    /* List of tag names taken from exiv2's printSummary() in actions.cpp */</a>
<a name="ln564">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln565"> </a>
<a name="ln566">    // look for maker &amp; model first so we can use that info later</a>
<a name="ln567">    if(FIND_EXIF_TAG(&quot;Exif.Image.Make&quot;))</a>
<a name="ln568">    {</a>
<a name="ln569">      dt_strlcpy_to_utf8(img-&gt;exif_maker, sizeof(img-&gt;exif_maker), pos, exifData);</a>
<a name="ln570">    }</a>
<a name="ln571">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Make&quot;))</a>
<a name="ln572">    {</a>
<a name="ln573">      dt_strlcpy_to_utf8(img-&gt;exif_maker, sizeof(img-&gt;exif_maker), pos, exifData);</a>
<a name="ln574">    }</a>
<a name="ln575"> </a>
<a name="ln576">    for(char *c = img-&gt;exif_maker + sizeof(img-&gt;exif_maker) - 1; c &gt; img-&gt;exif_maker; c--)</a>
<a name="ln577">      if(*c != ' ' &amp;&amp; *c != '\0')</a>
<a name="ln578">      {</a>
<a name="ln579">        *(c + 1) = '\0';</a>
<a name="ln580">        break;</a>
<a name="ln581">      }</a>
<a name="ln582"> </a>
<a name="ln583">    if(FIND_EXIF_TAG(&quot;Exif.Image.Model&quot;))</a>
<a name="ln584">    {</a>
<a name="ln585">      dt_strlcpy_to_utf8(img-&gt;exif_model, sizeof(img-&gt;exif_model), pos, exifData);</a>
<a name="ln586">    }</a>
<a name="ln587">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Model&quot;))</a>
<a name="ln588">    {</a>
<a name="ln589">      dt_strlcpy_to_utf8(img-&gt;exif_model, sizeof(img-&gt;exif_model), pos, exifData);</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">    for(char *c = img-&gt;exif_model + sizeof(img-&gt;exif_model) - 1; c &gt; img-&gt;exif_model; c--)</a>
<a name="ln593">      if(*c != ' ' &amp;&amp; *c != '\0')</a>
<a name="ln594">      {</a>
<a name="ln595">        *(c + 1) = '\0';</a>
<a name="ln596">        break;</a>
<a name="ln597">      }</a>
<a name="ln598"> </a>
<a name="ln599">    // Make sure we copy the exif make and model to the correct place if needed</a>
<a name="ln600">    dt_image_refresh_makermodel(img);</a>
<a name="ln601"> </a>
<a name="ln602">    /* Read shutter time */</a>
<a name="ln603">    if(FIND_EXIF_TAG(&quot;Exif.Photo.ExposureTime&quot;))</a>
<a name="ln604">    {</a>
<a name="ln605">      // dt_strlcpy_to_utf8(uf-&gt;conf-&gt;shutterText, max_name, pos, exifData);</a>
<a name="ln606">      img-&gt;exif_exposure = pos-&gt;toFloat();</a>
<a name="ln607">    }</a>
<a name="ln608">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.ShutterSpeedValue&quot;))</a>
<a name="ln609">    {</a>
<a name="ln610">      // uf_strlcpy_to_utf8(uf-&gt;conf-&gt;shutterText, max_name, pos, exifData);</a>
<a name="ln611">      img-&gt;exif_exposure = 1.0 / pos-&gt;toFloat();</a>
<a name="ln612">    }</a>
<a name="ln613">    /* Read aperture */</a>
<a name="ln614">    if(FIND_EXIF_TAG(&quot;Exif.Photo.FNumber&quot;))</a>
<a name="ln615">    {</a>
<a name="ln616">      img-&gt;exif_aperture = pos-&gt;toFloat();</a>
<a name="ln617">    }</a>
<a name="ln618">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.ApertureValue&quot;))</a>
<a name="ln619">    {</a>
<a name="ln620">      img-&gt;exif_aperture = pos-&gt;toFloat();</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    /* Read ISO speed - Nikon happens to return a pair for Lo and Hi modes */</a>
<a name="ln624">    if((pos = Exiv2::isoSpeed(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln625">    {</a>
<a name="ln626">      // if standard exif iso tag, use the old way of interpreting the return value to be more regression-save</a>
<a name="ln627">      if(strcmp(pos-&gt;key().c_str(), &quot;Exif.Photo.ISOSpeedRatings&quot;) == 0)</a>
<a name="ln628">      {</a>
<a name="ln629">        int isofield = pos-&gt;count() &gt; 1 ? 1 : 0;</a>
<a name="ln630">        img-&gt;exif_iso = pos-&gt;toFloat(isofield);</a>
<a name="ln631">      }</a>
<a name="ln632">      else</a>
<a name="ln633">      {</a>
<a name="ln634">        std::string str = pos-&gt;print();</a>
<a name="ln635">        img-&gt;exif_iso = (float)std::atof(str.c_str());</a>
<a name="ln636">      }</a>
<a name="ln637">    }</a>
<a name="ln638">    // some newer cameras support iso settings that exceed the 16 bit of exif's ISOSpeedRatings</a>
<a name="ln639">    if(img-&gt;exif_iso == 65535 || img-&gt;exif_iso == 0)</a>
<a name="ln640">    {</a>
<a name="ln641">      if(FIND_EXIF_TAG(&quot;Exif.PentaxDng.ISO&quot;) || FIND_EXIF_TAG(&quot;Exif.Pentax.ISO&quot;))</a>
<a name="ln642">      {</a>
<a name="ln643">        std::string str = pos-&gt;print();</a>
<a name="ln644">        img-&gt;exif_iso = (float)std::atof(str.c_str());</a>
<a name="ln645">      }</a>
<a name="ln646">      else if((!g_strcmp0(img-&gt;exif_maker, &quot;SONY&quot;) || !g_strcmp0(img-&gt;exif_maker, &quot;Canon&quot;))</a>
<a name="ln647">        &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Photo.RecommendedExposureIndex&quot;))</a>
<a name="ln648">      {</a>
<a name="ln649">        img-&gt;exif_iso = pos-&gt;toFloat();</a>
<a name="ln650">      }</a>
<a name="ln651">    }</a>
<a name="ln652"> </a>
<a name="ln653">    /* Read focal length  */</a>
<a name="ln654">    if((pos = Exiv2::focalLength(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln655">    {</a>
<a name="ln656">      // This works around a bug in exiv2 the developers refuse to fix</a>
<a name="ln657">      // For details see http://dev.exiv2.org/issues/1083</a>
<a name="ln658">      if (pos-&gt;key() == &quot;Exif.Canon.FocalLength&quot; &amp;&amp; pos-&gt;count() == 4)</a>
<a name="ln659">        img-&gt;exif_focal_length = pos-&gt;toFloat(1);</a>
<a name="ln660">      else</a>
<a name="ln661">        img-&gt;exif_focal_length = pos-&gt;toFloat();</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">    /* Read focal length in 35mm if available and try to calculate crop factor */</a>
<a name="ln665">    if(FIND_EXIF_TAG(&quot;Exif.Photo.FocalLengthIn35mmFilm&quot;))</a>
<a name="ln666">    {</a>
<a name="ln667">      const float focal_length_35mm = pos-&gt;toFloat();</a>
<a name="ln668">      if(focal_length_35mm &gt; 0.0f &amp;&amp; img-&gt;exif_focal_length &gt; 0.0f)</a>
<a name="ln669">        img-&gt;exif_crop = focal_length_35mm / img-&gt;exif_focal_length;</a>
<a name="ln670">      else</a>
<a name="ln671">        img-&gt;exif_crop = 1.0f;</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">    if (dt_check_usercrop(exifData, img))</a>
<a name="ln675">      {</a>
<a name="ln676">        img-&gt;flags |= DT_IMAGE_HAS_USERCROP;</a>
<a name="ln677">        guint tagid = 0;</a>
<a name="ln678">        char tagname[64];</a>
<a name="ln679">        snprintf(tagname, sizeof(tagname), &quot;darktable|mode|exif-crop&quot;);</a>
<a name="ln680">        dt_tag_new(tagname, &amp;tagid);</a>
<a name="ln681">        dt_tag_attach(tagid, img-&gt;id);</a>
<a name="ln682">      }</a>
<a name="ln683">    /*</a>
<a name="ln684">     * Get the focus distance in meters.</a>
<a name="ln685">     */</a>
<a name="ln686">    if(FIND_EXIF_TAG(&quot;Exif.NikonLd2.FocusDistance&quot;))</a>
<a name="ln687">    {</a>
<a name="ln688">      float value = pos-&gt;toFloat();</a>
<a name="ln689">      img-&gt;exif_focus_distance = (0.01 * pow(10, value / 40));</a>
<a name="ln690">    }</a>
<a name="ln691">    else if(FIND_EXIF_TAG(&quot;Exif.NikonLd3.FocusDistance&quot;))</a>
<a name="ln692">    {</a>
<a name="ln693">      float value = pos-&gt;toFloat();</a>
<a name="ln694">      img-&gt;exif_focus_distance = (0.01 * pow(10, value / 40));</a>
<a name="ln695">    }</a>
<a name="ln696">    else if(FIND_EXIF_TAG(&quot;Exif.OlympusFi.FocusDistance&quot;))</a>
<a name="ln697">    {</a>
<a name="ln698">      /* the distance is stored as a rational (fraction). according to</a>
<a name="ln699">       * http://www.dpreview.com/forums/thread/1173960?page=4</a>
<a name="ln700">       * some Olympus cameras have a wrong denominator of 10 in there while the nominator is always in mm.</a>
<a name="ln701">       * thus we ignore the denominator</a>
<a name="ln702">       * and divide with 1000.</a>
<a name="ln703">       * &quot;I've checked a number of E-1 and E-300 images, and I agree that the FocusDistance looks like it is</a>
<a name="ln704">       * in mm for the E-1. However,</a>
<a name="ln705">       * it looks more like cm for the E-300.</a>
<a name="ln706">       * For both cameras, this value is stored as a rational. With the E-1, the denominator is always 1,</a>
<a name="ln707">       * while for the E-300 it is 10.</a>
<a name="ln708">       * Therefore, it looks like the numerator in both cases is in mm (which makes a bit of sense, in an odd</a>
<a name="ln709">       * sort of way). So I think</a>
<a name="ln710">       * what I will do in ExifTool is to take the numerator and divide by 1000 to display the focus distance</a>
<a name="ln711">       * in meters.&quot;</a>
<a name="ln712">       *   -- Boardhead, dpreview forums in 2005</a>
<a name="ln713">       */</a>
<a name="ln714">      int nominator = pos-&gt;toRational(0).first;</a>
<a name="ln715">      img-&gt;exif_focus_distance = fmax(0.0, (0.001 * nominator));</a>
<a name="ln716">    }</a>
<a name="ln717">    else if(EXIV2_MAKE_VERSION(0,25,0) &lt;= Exiv2::versionNumber() &amp;&amp; FIND_EXIF_TAG(&quot;Exif.CanonFi.FocusDistanceUpper&quot;))</a>
<a name="ln718">    {</a>
<a name="ln719">      const float FocusDistanceUpper = pos-&gt;toFloat();</a>
<a name="ln720">      if(FocusDistanceUpper &lt;= 0.0f || (int)FocusDistanceUpper &gt;= 0xffff)</a>
<a name="ln721">      {</a>
<a name="ln722">        img-&gt;exif_focus_distance = 0.0f;</a>
<a name="ln723">      }</a>
<a name="ln724">      else</a>
<a name="ln725">      {</a>
<a name="ln726">        img-&gt;exif_focus_distance = FocusDistanceUpper / 100.0;</a>
<a name="ln727">        if(FIND_EXIF_TAG(&quot;Exif.CanonFi.FocusDistanceLower&quot;))</a>
<a name="ln728">        {</a>
<a name="ln729">          const float FocusDistanceLower = pos-&gt;toFloat();</a>
<a name="ln730">          if(FocusDistanceLower &gt; 0.0f &amp;&amp; (int)FocusDistanceLower &lt; 0xffff)</a>
<a name="ln731">          {</a>
<a name="ln732">            img-&gt;exif_focus_distance += FocusDistanceLower / 100.0;</a>
<a name="ln733">            img-&gt;exif_focus_distance /= 2.0;</a>
<a name="ln734">          }</a>
<a name="ln735">        }</a>
<a name="ln736">      }</a>
<a name="ln737">    }</a>
<a name="ln738">    else if(FIND_EXIF_TAG(&quot;Exif.CanonSi.SubjectDistance&quot;))</a>
<a name="ln739">    {</a>
<a name="ln740">      img-&gt;exif_focus_distance = pos-&gt;toFloat() / 100.0;</a>
<a name="ln741">    }</a>
<a name="ln742">    else if((pos = Exiv2::subjectDistance(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln743">    {</a>
<a name="ln744">      img-&gt;exif_focus_distance = pos-&gt;toFloat();</a>
<a name="ln745">    }</a>
<a name="ln746">    else if(Exiv2::testVersion(0,27,2) &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Sony2Fp.FocusPosition2&quot;))</a>
<a name="ln747">    {</a>
<a name="ln748">      const float focus_position = pos-&gt;toFloat();</a>
<a name="ln749"> </a>
<a name="ln750">      if (FIND_EXIF_TAG(&quot;Exif.Photo.FocalLengthIn35mmFilm&quot;)) {</a>
<a name="ln751">          const float focal_length_35mm = pos-&gt;toFloat();</a>
<a name="ln752"> </a>
<a name="ln753">          /* http://u88.n24.queensu.ca/exiftool/forum/index.php/topic,3688.msg29653.html#msg29653 */</a>
<a name="ln754">          img-&gt;exif_focus_distance = (pow(2, focus_position / 16 - 5) + 1) * focal_length_35mm / 1000;</a>
<a name="ln755">      }</a>
<a name="ln756">    }</a>
<a name="ln757"> </a>
<a name="ln758">    /*</a>
<a name="ln759">     * Read image orientation</a>
<a name="ln760">     */</a>
<a name="ln761">    if(FIND_EXIF_TAG(&quot;Exif.Image.Orientation&quot;))</a>
<a name="ln762">    {</a>
<a name="ln763">      img-&gt;orientation = dt_image_orientation_to_flip_bits(pos-&gt;toLong());</a>
<a name="ln764">    }</a>
<a name="ln765">    else if(FIND_EXIF_TAG(&quot;Exif.PanasonicRaw.Orientation&quot;))</a>
<a name="ln766">    {</a>
<a name="ln767">      img-&gt;orientation = dt_image_orientation_to_flip_bits(pos-&gt;toLong());</a>
<a name="ln768">    }</a>
<a name="ln769"> </a>
<a name="ln770">    /* read gps location */</a>
<a name="ln771">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSLatitude&quot;))</a>
<a name="ln772">    {</a>
<a name="ln773">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSLatitudeRef&quot;));</a>
<a name="ln774">      if(ref != exifData.end() &amp;&amp; ref-&gt;size() &amp;&amp; pos-&gt;count() == 3)</a>
<a name="ln775">      {</a>
<a name="ln776">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln777">        const char *sign = sign_str.c_str();</a>
<a name="ln778">        double latitude = 0.0;</a>
<a name="ln779">        if(dt_util_gps_rationale_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second,</a>
<a name="ln780">                                           pos-&gt;toRational(1).first, pos-&gt;toRational(1).second,</a>
<a name="ln781">                                           pos-&gt;toRational(2).first, pos-&gt;toRational(2).second, sign[0], &amp;latitude))</a>
<a name="ln782">          img-&gt;geoloc.latitude = latitude;</a>
<a name="ln783">      }</a>
<a name="ln784">    }</a>
<a name="ln785"> </a>
<a name="ln786">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSLongitude&quot;))</a>
<a name="ln787">    {</a>
<a name="ln788">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSLongitudeRef&quot;));</a>
<a name="ln789">      if(ref != exifData.end() &amp;&amp; ref-&gt;size() &amp;&amp; pos-&gt;count() == 3)</a>
<a name="ln790">      {</a>
<a name="ln791">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln792">        const char *sign = sign_str.c_str();</a>
<a name="ln793">        double longitude = 0.0;</a>
<a name="ln794">        if(dt_util_gps_rationale_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second,</a>
<a name="ln795">                                           pos-&gt;toRational(1).first, pos-&gt;toRational(1).second,</a>
<a name="ln796">                                           pos-&gt;toRational(2).first, pos-&gt;toRational(2).second, sign[0], &amp;longitude))</a>
<a name="ln797">          img-&gt;geoloc.longitude = longitude;</a>
<a name="ln798">      }</a>
<a name="ln799">    }</a>
<a name="ln800"> </a>
<a name="ln801">    if(FIND_EXIF_TAG(&quot;Exif.GPSInfo.GPSAltitude&quot;))</a>
<a name="ln802">    {</a>
<a name="ln803">      Exiv2::ExifData::const_iterator ref = exifData.findKey(Exiv2::ExifKey(&quot;Exif.GPSInfo.GPSAltitudeRef&quot;));</a>
<a name="ln804">      if(ref != exifData.end() &amp;&amp; ref-&gt;size())</a>
<a name="ln805">      {</a>
<a name="ln806">        std::string sign_str = ref-&gt;toString();</a>
<a name="ln807">        const char *sign = sign_str.c_str();</a>
<a name="ln808">        double elevation = 0.0;</a>
<a name="ln809">        if(dt_util_gps_elevation_to_number(pos-&gt;toRational(0).first, pos-&gt;toRational(0).second, sign[0], &amp;elevation))</a>
<a name="ln810">          img-&gt;geoloc.elevation = elevation;</a>
<a name="ln811">      }</a>
<a name="ln812">    }</a>
<a name="ln813"> </a>
<a name="ln814">    /* Read lens name */</a>
<a name="ln815">    if((FIND_EXIF_TAG(&quot;Exif.CanonCs.LensType&quot;) &amp;&amp; pos-&gt;print(&amp;exifData) != &quot;(0)&quot;</a>
<a name="ln816">        &amp;&amp; pos-&gt;print(&amp;exifData) != &quot;(65535)&quot;)</a>
<a name="ln817">       || FIND_EXIF_TAG(&quot;Exif.Canon.0x0095&quot;))</a>
<a name="ln818">    {</a>
<a name="ln819">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln820">    }</a>
<a name="ln821">    else if(EXIV2_MAKE_VERSION(0,25,0) &lt;= Exiv2::versionNumber() &amp;&amp; FIND_EXIF_TAG(&quot;Exif.PentaxDng.LensType&quot;))</a>
<a name="ln822">    {</a>
<a name="ln823">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln824">    }</a>
<a name="ln825">    else if(FIND_EXIF_TAG(&quot;Exif.Panasonic.LensType&quot;))</a>
<a name="ln826">    {</a>
<a name="ln827">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln828">    }</a>
<a name="ln829">    else if(FIND_EXIF_TAG(&quot;Exif.OlympusEq.LensType&quot;))</a>
<a name="ln830">    {</a>
<a name="ln831">      /* For every Olympus camera Exif.OlympusEq.LensType is present. */</a>
<a name="ln832">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln833"> </a>
<a name="ln834">      /* We have to check if Exif.OlympusEq.LensType has been translated by</a>
<a name="ln835">       * exiv2. If it hasn't, fall back to Exif.OlympusEq.LensModel. */</a>
<a name="ln836">      std::string lens(img-&gt;exif_lens);</a>
<a name="ln837">      if(std::string::npos == lens.find_first_not_of(&quot; 1234567890&quot;))</a>
<a name="ln838">      {</a>
<a name="ln839">        /* Exif.OlympusEq.LensType contains only digits and spaces.</a>
<a name="ln840">         * This means that exiv2 couldn't convert it to human readable</a>
<a name="ln841">         * form. */</a>
<a name="ln842">        if(FIND_EXIF_TAG(&quot;Exif.OlympusEq.LensModel&quot;))</a>
<a name="ln843">        {</a>
<a name="ln844">          dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln845">        }</a>
<a name="ln846">        /* Just in case Exif.OlympusEq.LensModel hasn't been found */</a>
<a name="ln847">        else if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln848">        {</a>
<a name="ln849">          dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln850">        }</a>
<a name="ln851">        fprintf(stderr, &quot;[exif] Warning: lens \&quot;%s\&quot; unknown as \&quot;%s\&quot;\n&quot;, img-&gt;exif_lens, lens.c_str());</a>
<a name="ln852">      }</a>
<a name="ln853">    }</a>
<a name="ln854">    else if((pos = Exiv2::lensName(exifData)) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln855">    {</a>
<a name="ln856">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln857">    }</a>
<a name="ln858">    else if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln859">    {</a>
<a name="ln860">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863">#if 0</a>
<a name="ln864">    /* Read flash mode */</a>
<a name="ln865">    if ( (pos=exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.Flash&quot;)))</a>
<a name="ln866">         != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln867">    {</a>
<a name="ln868">      uf_strlcpy_to_utf8(uf-&gt;conf-&gt;flashText, max_name, pos, exifData);</a>
<a name="ln869">    }</a>
<a name="ln870">    /* Read White Balance Setting */</a>
<a name="ln871">    if ( (pos=exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.WhiteBalance&quot;)))</a>
<a name="ln872">         != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln873">    {</a>
<a name="ln874">      uf_strlcpy_to_utf8(uf-&gt;conf-&gt;whiteBalanceText, max_name, pos, exifData);</a>
<a name="ln875">    }</a>
<a name="ln876">#endif</a>
<a name="ln877"> </a>
<a name="ln878">    _find_datetime_taken(exifData, pos, img-&gt;exif_datetime_taken);</a>
<a name="ln879"> </a>
<a name="ln880">    if(FIND_EXIF_TAG(&quot;Exif.Image.Artist&quot;))</a>
<a name="ln881">    {</a>
<a name="ln882">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln883">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln884">    }</a>
<a name="ln885">    else if(FIND_EXIF_TAG(&quot;Exif.Canon.OwnerName&quot;))</a>
<a name="ln886">    {</a>
<a name="ln887">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln888">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str.c_str());</a>
<a name="ln889">    }</a>
<a name="ln890"> </a>
<a name="ln891">    // FIXME: Should the UserComment go into the description? Or do we need an extra field for this?</a>
<a name="ln892">    if(FIND_EXIF_TAG(&quot;Exif.Photo.UserComment&quot;))</a>
<a name="ln893">    {</a>
<a name="ln894">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln895">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.description&quot;, str.c_str());</a>
<a name="ln896">    }</a>
<a name="ln897"> </a>
<a name="ln898">    if(FIND_EXIF_TAG(&quot;Exif.Image.Copyright&quot;))</a>
<a name="ln899">    {</a>
<a name="ln900">      std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln901">      dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str.c_str());</a>
<a name="ln902">    }</a>
<a name="ln903"> </a>
<a name="ln904">    if(FIND_EXIF_TAG(&quot;Exif.Image.Rating&quot;))</a>
<a name="ln905">    {</a>
<a name="ln906">      int stars = pos-&gt;toLong();</a>
<a name="ln907">      if(stars == 0)</a>
<a name="ln908">      {</a>
<a name="ln909">        stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln910">      }</a>
<a name="ln911">      else</a>
<a name="ln912">      {</a>
<a name="ln913">        stars = (stars == -1) ? 6 : stars;</a>
<a name="ln914">      }</a>
<a name="ln915">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln916">    }</a>
<a name="ln917">    else if(FIND_EXIF_TAG(&quot;Exif.Image.RatingPercent&quot;))</a>
<a name="ln918">    {</a>
<a name="ln919">      int stars = pos-&gt;toLong() * 5. / 100;</a>
<a name="ln920">      if(stars == 0)</a>
<a name="ln921">      {</a>
<a name="ln922">        stars = dt_conf_get_int(&quot;ui_last/import_initial_rating&quot;);</a>
<a name="ln923">      }</a>
<a name="ln924">      else</a>
<a name="ln925">      {</a>
<a name="ln926">        stars = (stars == -1) ? 6 : stars;</a>
<a name="ln927">      }</a>
<a name="ln928">      img-&gt;flags = (img-&gt;flags &amp; ~0x7) | (0x7 &amp; stars);</a>
<a name="ln929">    }</a>
<a name="ln930"> </a>
<a name="ln931">    // read embedded color matrix as used in DNGs</a>
<a name="ln932">    {</a>
<a name="ln933">      int illu1 = -1, illu2 = -1, illu = -1; // -1: not found, otherwise the detected CalibrationIlluminant</a>
<a name="ln934">      float colmatrix[12];</a>
<a name="ln935">      img-&gt;d65_color_matrix[0] = NAN; // make sure for later testing</a>
<a name="ln936">      // The correction matrices are taken from</a>
<a name="ln937">      // http://www.brucelindbloom.com - chromatic Adaption.</a>
<a name="ln938">      // using Bradford method: found Illuminant -&gt; D65</a>
<a name="ln939">      const float correctmat[6][9] = {</a>
<a name="ln940">        { 0.9555766, -0.0230393, 0.0631636, -0.0282895, 1.0099416, 0.0210077, 0.0122982, -0.0204830,</a>
<a name="ln941">          1.3299098 }, // 23 = D50</a>
<a name="ln942">        { 0.9726856, -0.0135482, 0.0361731, -0.0167463, 1.0049102, 0.0120598, 0.0070026, -0.0116372,</a>
<a name="ln943">          1.1869548 }, // 20 = D55</a>
<a name="ln944">        { 1.0206905, 0.0091588, -0.0228796, 0.0115005, 0.9984917, -0.0076762, -0.0043619, 0.0072053,</a>
<a name="ln945">          0.8853432 }, // 22 = D75</a>
<a name="ln946">        { 0.8446965, -0.1179225, 0.3948108, -0.1366303, 1.1041226, 0.1291718, 0.0798489, -0.1348999,</a>
<a name="ln947">          3.1924009 }, // 17 = Standard light A</a>
<a name="ln948">        { 0.9415037, -0.0321240, 0.0584672, -0.0428238, 1.0250998, 0.0203309, 0.0101511, -0.0161170,</a>
<a name="ln949">          1.2847354 }, // 18 = Standard light B</a>
<a name="ln950">        { 0.9904476, -0.0071683, -0.0116156, -0.0123712, 1.0155950, -0.0029282, -0.0035635, 0.0067697,</a>
<a name="ln951">          0.9181569 } // 19 = Standard light C</a>
<a name="ln952">      };</a>
<a name="ln953"> </a>
<a name="ln954">      if(FIND_EXIF_TAG(&quot;Exif.Image.CalibrationIlluminant1&quot;)) illu1 = pos-&gt;toLong();</a>
<a name="ln955">      if(FIND_EXIF_TAG(&quot;Exif.Image.CalibrationIlluminant2&quot;)) illu2 = pos-&gt;toLong();</a>
<a name="ln956">      Exiv2::ExifData::const_iterator cm1_pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Image.ColorMatrix1&quot;));</a>
<a name="ln957">      Exiv2::ExifData::const_iterator cm2_pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Image.ColorMatrix2&quot;));</a>
<a name="ln958"> </a>
<a name="ln959">      // Which is the wanted colormatrix?</a>
<a name="ln960">      // If we have D65 in Illuminant1 we use it; otherwise we prefer Illuminant2 because it's the higher</a>
<a name="ln961">      // color temperature and thus closer to D65</a>
<a name="ln962">      if(illu1 == 21 &amp;&amp; cm1_pos != exifData.end() &amp;&amp; cm1_pos-&gt;count() == 9 &amp;&amp; cm1_pos-&gt;size())</a>
<a name="ln963">      {</a>
<a name="ln964">        for(int i = 0; i &lt; 9; i++) colmatrix[i] = cm1_pos-&gt;toFloat(i);</a>
<a name="ln965">        illu = illu1;</a>
<a name="ln966">      }</a>
<a name="ln967">      else if(illu2 != -1 &amp;&amp; cm2_pos != exifData.end() &amp;&amp; cm2_pos-&gt;count() == 9 &amp;&amp; cm2_pos-&gt;size())</a>
<a name="ln968">      {</a>
<a name="ln969">        for(int i = 0; i &lt; 9; i++) colmatrix[i] = cm2_pos-&gt;toFloat(i);</a>
<a name="ln970">        illu = illu2;</a>
<a name="ln971">      }</a>
<a name="ln972">      else if(illu1 != -1 &amp;&amp; cm1_pos != exifData.end() &amp;&amp; cm1_pos-&gt;count() == 9 &amp;&amp; cm1_pos-&gt;size())</a>
<a name="ln973">      {</a>
<a name="ln974">        for(int i = 0; i &lt; 9; i++) colmatrix[i] = cm1_pos-&gt;toFloat(i);</a>
<a name="ln975">        illu = illu1;</a>
<a name="ln976">    }</a>
<a name="ln977">      // Take the found CalibrationIlluminant / ColorMatrix pair.</a>
<a name="ln978">      // If it is D65: just copy otherwise multiply by the specific correction matrix.</a>
<a name="ln979">      if(illu != -1)</a>
<a name="ln980">      {</a>
<a name="ln981">       // If no supported Illuminant is found it's better NOT to use the found matrix.</a>
<a name="ln982">       // The colorin module will write an error message and use a fallback matrix</a>
<a name="ln983">       // instead of showing wrong colors.</a>
<a name="ln984">       switch(illu)</a>
<a name="ln985">        {</a>
<a name="ln986">          case 21:</a>
<a name="ln987">            for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = colmatrix[i];</a>
<a name="ln988">            break;</a>
<a name="ln989">          case 23:</a>
<a name="ln990">            mat3mul(img-&gt;d65_color_matrix, correctmat[0], colmatrix);</a>
<a name="ln991">            break;</a>
<a name="ln992">          case 20:</a>
<a name="ln993">            mat3mul(img-&gt;d65_color_matrix, correctmat[1], colmatrix);</a>
<a name="ln994">            break;</a>
<a name="ln995">          case 22:</a>
<a name="ln996">            mat3mul(img-&gt;d65_color_matrix, correctmat[2], colmatrix);</a>
<a name="ln997">            break;</a>
<a name="ln998">          case 17:</a>
<a name="ln999">            mat3mul(img-&gt;d65_color_matrix, correctmat[3], colmatrix);</a>
<a name="ln1000">            break;</a>
<a name="ln1001">          case 18:</a>
<a name="ln1002">            mat3mul(img-&gt;d65_color_matrix, correctmat[4], colmatrix);</a>
<a name="ln1003">            break;</a>
<a name="ln1004">          case 19:</a>
<a name="ln1005">            mat3mul(img-&gt;d65_color_matrix, correctmat[5], colmatrix);</a>
<a name="ln1006">            break;</a>
<a name="ln1007">        }</a>
<a name="ln1008">        // Maybe there is a predefined camera matrix in adobe_coeff?</a>
<a name="ln1009">        // This is tested to possibly override the matrix.</a>
<a name="ln1010">        colmatrix[0] = NAN;</a>
<a name="ln1011">        dt_dcraw_adobe_coeff(img-&gt;camera_model, (float(*)[12])colmatrix);</a>
<a name="ln1012">        if(!isnan(colmatrix[0]))</a>
<a name="ln1013">          for(int i = 0; i &lt; 9; i++) img-&gt;d65_color_matrix[i] = colmatrix[i];</a>
<a name="ln1014">      }</a>
<a name="ln1015">    }</a>
<a name="ln1016"> </a>
<a name="ln1017"> </a>
<a name="ln1018">    // some files have the colorspace explicitly set. try to read that.</a>
<a name="ln1019">    // is_ldr -&gt; none</a>
<a name="ln1020">    // 0x01   -&gt; sRGB</a>
<a name="ln1021">    // 0x02   -&gt; AdobeRGB</a>
<a name="ln1022">    // 0xffff -&gt; Uncalibrated</a>
<a name="ln1023">    //          + Exif.Iop.InteroperabilityIndex of 'R03' -&gt; AdobeRGB</a>
<a name="ln1024">    //          + Exif.Iop.InteroperabilityIndex of 'R98' -&gt; sRGB</a>
<a name="ln1025">    if(dt_image_is_ldr(img) &amp;&amp; FIND_EXIF_TAG(&quot;Exif.Photo.ColorSpace&quot;))</a>
<a name="ln1026">    {</a>
<a name="ln1027">      int colorspace = pos-&gt;toLong();</a>
<a name="ln1028">      if(colorspace == 0x01)</a>
<a name="ln1029">        img-&gt;colorspace = DT_IMAGE_COLORSPACE_SRGB;</a>
<a name="ln1030">      else if(colorspace == 0x02)</a>
<a name="ln1031">        img-&gt;colorspace = DT_IMAGE_COLORSPACE_ADOBE_RGB;</a>
<a name="ln1032">      else if(colorspace == 0xffff)</a>
<a name="ln1033">      {</a>
<a name="ln1034">        if(FIND_EXIF_TAG(&quot;Exif.Iop.InteroperabilityIndex&quot;))</a>
<a name="ln1035">        {</a>
<a name="ln1036">          std::string interop_index = pos-&gt;toString();</a>
<a name="ln1037">          if(interop_index == &quot;R03&quot;)</a>
<a name="ln1038">            img-&gt;colorspace = DT_IMAGE_COLORSPACE_ADOBE_RGB;</a>
<a name="ln1039">          else if(interop_index == &quot;R98&quot;)</a>
<a name="ln1040">            img-&gt;colorspace = DT_IMAGE_COLORSPACE_SRGB;</a>
<a name="ln1041">        }</a>
<a name="ln1042">      }</a>
<a name="ln1043">    }</a>
<a name="ln1044"> </a>
<a name="ln1045">#if EXIV2_MINOR_VERSION &lt; 23</a>
<a name="ln1046">    // workaround for an exiv2 bug writing random garbage into exif_lens for this camera:</a>
<a name="ln1047">    // http://dev.exiv2.org/issues/779</a>
<a name="ln1048">    if(!strcmp(img-&gt;exif_model, &quot;DMC-GH2&quot;)) snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;(unknown)&quot;);</a>
<a name="ln1049">#endif</a>
<a name="ln1050"> </a>
<a name="ln1051">    // Improve lens detection for Sony SAL lenses.</a>
<a name="ln1052">    if(FIND_EXIF_TAG(&quot;Exif.Sony2.LensID&quot;) &amp;&amp; pos-&gt;toLong() != 65535 &amp;&amp; pos-&gt;print().find('|') == std::string::npos)</a>
<a name="ln1053">    {</a>
<a name="ln1054">      dt_strlcpy_to_utf8(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), pos, exifData);</a>
<a name="ln1055">    }</a>
<a name="ln1056">    // Workaround for an issue on newer Sony NEX cams.</a>
<a name="ln1057">    // The default EXIF field is not used by Sony to store lens data</a>
<a name="ln1058">    // http://dev.exiv2.org/issues/883</a>
<a name="ln1059">    // http://darktable.org/redmine/issues/8813</a>
<a name="ln1060">    // FIXME: This is still a workaround</a>
<a name="ln1061">    else if((!strncmp(img-&gt;exif_model, &quot;NEX&quot;, 3)) || (!strncmp(img-&gt;exif_model, &quot;ILCE&quot;, 4)))</a>
<a name="ln1062">    {</a>
<a name="ln1063">      snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;(unknown)&quot;);</a>
<a name="ln1064">      if(FIND_EXIF_TAG(&quot;Exif.Photo.LensModel&quot;))</a>
<a name="ln1065">      {</a>
<a name="ln1066">        std::string str = pos-&gt;print(&amp;exifData);</a>
<a name="ln1067">        snprintf(img-&gt;exif_lens, sizeof(img-&gt;exif_lens), &quot;%s&quot;, str.c_str());</a>
<a name="ln1068">      }</a>
<a name="ln1069">    };</a>
<a name="ln1070"> </a>
<a name="ln1071">    img-&gt;exif_inited = 1;</a>
<a name="ln1072">    return true;</a>
<a name="ln1073">  }</a>
<a name="ln1074">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1075">  {</a>
<a name="ln1076">    std::string s(e.what());</a>
<a name="ln1077">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1078">    return false;</a>
<a name="ln1079">  }</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">static void dt_exif_apply_global_overwrites(dt_image_t *img)</a>
<a name="ln1083">{</a>
<a name="ln1084">  if(dt_conf_get_bool(&quot;ui_last/import_apply_metadata&quot;) == TRUE)</a>
<a name="ln1085">  {</a>
<a name="ln1086">    char *str;</a>
<a name="ln1087"> </a>
<a name="ln1088">    str = dt_conf_get_string(&quot;ui_last/import_last_creator&quot;);</a>
<a name="ln1089">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.creator&quot;, str);</a>
<a name="ln1090">    g_free(str);</a>
<a name="ln1091"> </a>
<a name="ln1092">    str = dt_conf_get_string(&quot;ui_last/import_last_rights&quot;);</a>
<a name="ln1093">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.rights&quot;, str);</a>
<a name="ln1094">    g_free(str);</a>
<a name="ln1095"> </a>
<a name="ln1096">    str = dt_conf_get_string(&quot;ui_last/import_last_publisher&quot;);</a>
<a name="ln1097">    if(str != NULL &amp;&amp; str[0] != '\0') dt_metadata_set(img-&gt;id, &quot;Xmp.dc.publisher&quot;, str);</a>
<a name="ln1098">    g_free(str);</a>
<a name="ln1099"> </a>
<a name="ln1100">    str = dt_conf_get_string(&quot;ui_last/import_last_tags&quot;);</a>
<a name="ln1101">    if(str != NULL &amp;&amp; str[0] != '\0') dt_tag_attach_string_list(str, img-&gt;id);</a>
<a name="ln1102">    g_free(str);</a>
<a name="ln1103">  }</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">// TODO: can this blob also contain xmp and iptc data?</a>
<a name="ln1107">int dt_exif_read_from_blob(dt_image_t *img, uint8_t *blob, const int size)</a>
<a name="ln1108">{</a>
<a name="ln1109">  try</a>
<a name="ln1110">  {</a>
<a name="ln1111">    Exiv2::ExifData exifData;</a>
<a name="ln1112">    Exiv2::ExifParser::decode(exifData, blob, size);</a>
<a name="ln1113">    bool res = dt_exif_read_exif_data(img, exifData);</a>
<a name="ln1114">    dt_exif_apply_global_overwrites(img);</a>
<a name="ln1115">    return res ? 0 : 1;</a>
<a name="ln1116">  }</a>
<a name="ln1117">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1118">  {</a>
<a name="ln1119">    std::string s(e.what());</a>
<a name="ln1120">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; img-&gt;filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1121">    return 1;</a>
<a name="ln1122">  }</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">/**</a>
<a name="ln1126"> * Get the largest possible thumbnail from the image</a>
<a name="ln1127"> */</a>
<a name="ln1128">int dt_exif_get_thumbnail(const char *path, uint8_t **buffer, size_t *size, char **mime_type)</a>
<a name="ln1129">{</a>
<a name="ln1130">  try</a>
<a name="ln1131">  {</a>
<a name="ln1132">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1133">    assert(image.get() != 0);</a>
<a name="ln1134">    read_metadata_threadsafe(image);</a>
<a name="ln1135"> </a>
<a name="ln1136">    // Get a list of preview images available in the image. The list is sorted</a>
<a name="ln1137">    // by the preview image pixel size, starting with the smallest preview.</a>
<a name="ln1138">    Exiv2::PreviewManager loader(*image);</a>
<a name="ln1139">    Exiv2::PreviewPropertiesList list = loader.getPreviewProperties();</a>
<a name="ln1140">    if(list.empty())</a>
<a name="ln1141">    {</a>
<a name="ln1142">      dt_print(DT_DEBUG_LIGHTTABLE, &quot;[exiv2] couldn't find thumbnail for %s&quot;, path);</a>
<a name="ln1143">      return 1;</a>
<a name="ln1144">    }</a>
<a name="ln1145"> </a>
<a name="ln1146">    // Select the largest one</a>
<a name="ln1147">    // FIXME: We could probably select a smaller thumbnail to match the mip size</a>
<a name="ln1148">    //        we actually want to create. Is it really much faster though?</a>
<a name="ln1149">    Exiv2::PreviewProperties selected = list.back();</a>
<a name="ln1150"> </a>
<a name="ln1151">    // Get the selected preview image</a>
<a name="ln1152">    Exiv2::PreviewImage preview = loader.getPreviewImage(selected);</a>
<a name="ln1153">    const unsigned  char *tmp = preview.pData();</a>
<a name="ln1154">    size_t _size = preview.size();</a>
<a name="ln1155"> </a>
<a name="ln1156">    *size = _size;</a>
<a name="ln1157">    *mime_type = strdup(preview.mimeType().c_str());</a>
<a name="ln1158">    *buffer = (uint8_t *)malloc(_size);</a>
<a name="ln1159">    if(!*buffer) {</a>
<a name="ln1160">      std::cerr &lt;&lt; &quot;[exiv2] couldn't allocate memory for thumbnail for &quot; &lt;&lt; path &lt;&lt; std::endl;</a>
<a name="ln1161">      return 1;</a>
<a name="ln1162">    }</a>
<a name="ln1163">    //std::cerr &lt;&lt; &quot;[exiv2] &quot;&lt;&lt; path &lt;&lt; &quot;: found thumbnail &quot;&lt;&lt; preview.width() &lt;&lt; &quot;x&quot; &lt;&lt; preview.height() &lt;&lt; std::endl;</a>
<a name="ln1164">    memcpy(*buffer, tmp, _size);</a>
<a name="ln1165"> </a>
<a name="ln1166">    return 0;</a>
<a name="ln1167">  }</a>
<a name="ln1168">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1169">  {</a>
<a name="ln1170">    std::string s(e.what());</a>
<a name="ln1171">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1172">    return 1;</a>
<a name="ln1173">  }</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">/** read the metadata of an image.</a>
<a name="ln1177"> * XMP data trumps IPTC data trumps EXIF data</a>
<a name="ln1178"> */</a>
<a name="ln1179">int dt_exif_read(dt_image_t *img, const char *path)</a>
<a name="ln1180">{</a>
<a name="ln1181">  // at least set datetime taken to something useful in case there is no exif data in this file (pfm, png,</a>
<a name="ln1182">  // ...)</a>
<a name="ln1183">  struct stat statbuf;</a>
<a name="ln1184"> </a>
<a name="ln1185">  if(!stat(path, &amp;statbuf))</a>
<a name="ln1186">  {</a>
<a name="ln1187">    struct tm result;</a>
<a name="ln1188">    strftime(img-&gt;exif_datetime_taken, 20, &quot;%Y:%m:%d %H:%M:%S&quot;, localtime_r(&amp;statbuf.st_mtime, &amp;result));</a>
<a name="ln1189">  }</a>
<a name="ln1190"> </a>
<a name="ln1191">  try</a>
<a name="ln1192">  {</a>
<a name="ln1193">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1194">    assert(image.get() != 0);</a>
<a name="ln1195">    read_metadata_threadsafe(image);</a>
<a name="ln1196">    bool res = true;</a>
<a name="ln1197"> </a>
<a name="ln1198">    // EXIF metadata</a>
<a name="ln1199">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln1200">    if(!exifData.empty())</a>
<a name="ln1201">      res = dt_exif_read_exif_data(img, exifData);</a>
<a name="ln1202">    else</a>
<a name="ln1203">      img-&gt;exif_inited = 1;</a>
<a name="ln1204"> </a>
<a name="ln1205">    // these get overwritten by IPTC and XMP. is that how it should work?</a>
<a name="ln1206">    dt_exif_apply_global_overwrites(img);</a>
<a name="ln1207"> </a>
<a name="ln1208">    // IPTC metadata.</a>
<a name="ln1209">    Exiv2::IptcData &amp;iptcData = image-&gt;iptcData();</a>
<a name="ln1210">    if(!iptcData.empty()) res = dt_exif_read_iptc_data(img, iptcData) &amp;&amp; res;</a>
<a name="ln1211"> </a>
<a name="ln1212">    // XMP metadata</a>
<a name="ln1213">    Exiv2::XmpData &amp;xmpData = image-&gt;xmpData();</a>
<a name="ln1214">    if(!xmpData.empty()) res = dt_exif_read_xmp_data(img, xmpData, -1, true) &amp;&amp; res;</a>
<a name="ln1215"> </a>
<a name="ln1216">    // Initialize size - don't wait for full raw to be loaded to get this</a>
<a name="ln1217">    // information. If use_embedded_thumbnail is set, it will take a</a>
<a name="ln1218">    // change in development history to have this information</a>
<a name="ln1219">    img-&gt;height = image-&gt;pixelHeight();</a>
<a name="ln1220">    img-&gt;width = image-&gt;pixelWidth();</a>
<a name="ln1221"> </a>
<a name="ln1222">    return res ? 0 : 1;</a>
<a name="ln1223">  }</a>
<a name="ln1224">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1225">  {</a>
<a name="ln1226">    std::string s(e.what());</a>
<a name="ln1227">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1228">    return 1;</a>
<a name="ln1229">  }</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">int dt_exif_write_blob(uint8_t *blob, uint32_t size, const char *path, const int compressed)</a>
<a name="ln1233">{</a>
<a name="ln1234">  try</a>
<a name="ln1235">  {</a>
<a name="ln1236">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1237">    assert(image.get() != 0);</a>
<a name="ln1238">    read_metadata_threadsafe(image);</a>
<a name="ln1239">    Exiv2::ExifData &amp;imgExifData = image-&gt;exifData();</a>
<a name="ln1240">    Exiv2::ExifData blobExifData;</a>
<a name="ln1241">    Exiv2::ExifParser::decode(blobExifData, blob + 6, size);</a>
<a name="ln1242">    Exiv2::ExifData::const_iterator end = blobExifData.end();</a>
<a name="ln1243">    Exiv2::ExifData::iterator it;</a>
<a name="ln1244">    for(Exiv2::ExifData::const_iterator i = blobExifData.begin(); i != end; ++i)</a>
<a name="ln1245">    {</a>
<a name="ln1246">      // add() does not override! we need to delete existing key first.</a>
<a name="ln1247">      Exiv2::ExifKey key(i-&gt;key());</a>
<a name="ln1248">      if((it = imgExifData.findKey(key)) != imgExifData.end()) imgExifData.erase(it);</a>
<a name="ln1249"> </a>
<a name="ln1250">      imgExifData.add(Exiv2::ExifKey(i-&gt;key()), &amp;i-&gt;value());</a>
<a name="ln1251">    }</a>
<a name="ln1252"> </a>
<a name="ln1253">    {</a>
<a name="ln1254">      // Remove thumbnail</a>
<a name="ln1255">      static const char *keys[] = {</a>
<a name="ln1256">        &quot;Exif.Thumbnail.Compression&quot;,</a>
<a name="ln1257">        &quot;Exif.Thumbnail.XResolution&quot;,</a>
<a name="ln1258">        &quot;Exif.Thumbnail.YResolution&quot;,</a>
<a name="ln1259">        &quot;Exif.Thumbnail.ResolutionUnit&quot;,</a>
<a name="ln1260">        &quot;Exif.Thumbnail.JPEGInterchangeFormat&quot;,</a>
<a name="ln1261">        &quot;Exif.Thumbnail.JPEGInterchangeFormatLength&quot;</a>
<a name="ln1262">      };</a>
<a name="ln1263">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1264">      dt_remove_exif_keys(imgExifData, keys, n_keys);</a>
<a name="ln1265">    }</a>
<a name="ln1266"> </a>
<a name="ln1267">    // only compressed images may set PixelXDimension and PixelYDimension</a>
<a name="ln1268">    if(!compressed)</a>
<a name="ln1269">    {</a>
<a name="ln1270">      static const char *keys[] = {</a>
<a name="ln1271">        &quot;Exif.Photo.PixelXDimension&quot;,</a>
<a name="ln1272">        &quot;Exif.Photo.PixelYDimension&quot;</a>
<a name="ln1273">      };</a>
<a name="ln1274">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1275">      dt_remove_exif_keys(imgExifData, keys, n_keys);</a>
<a name="ln1276">    }</a>
<a name="ln1277"> </a>
<a name="ln1278">    imgExifData.sortByTag();</a>
<a name="ln1279">    image-&gt;writeMetadata();</a>
<a name="ln1280">  }</a>
<a name="ln1281">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1282">  {</a>
<a name="ln1283">    std::string s(e.what());</a>
<a name="ln1284">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1285">    return 0;</a>
<a name="ln1286">  }</a>
<a name="ln1287">  return 1;</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">int dt_exif_read_blob(uint8_t **buf, const char *path, const int imgid, const int sRGB, const int out_width,</a>
<a name="ln1291">                      const int out_height, const int dng_mode)</a>
<a name="ln1292">{</a>
<a name="ln1293">  *buf = NULL;</a>
<a name="ln1294">  try</a>
<a name="ln1295">  {</a>
<a name="ln1296">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(path)));</a>
<a name="ln1297">    assert(image.get() != 0);</a>
<a name="ln1298">    read_metadata_threadsafe(image);</a>
<a name="ln1299">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln1300"> </a>
<a name="ln1301">    // get rid of thumbnails</a>
<a name="ln1302">    Exiv2::ExifThumb(exifData).erase();</a>
<a name="ln1303"> </a>
<a name="ln1304">    // ufraw-style exif stripping:</a>
<a name="ln1305">    Exiv2::ExifData::iterator pos;</a>
<a name="ln1306">    {</a>
<a name="ln1307">    /* Delete original TIFF data, which is irrelevant*/</a>
<a name="ln1308">      static const char *keys[] = {</a>
<a name="ln1309">        &quot;Exif.Image.ImageWidth&quot;,</a>
<a name="ln1310">        &quot;Exif.Image.ImageLength&quot;,</a>
<a name="ln1311">        &quot;Exif.Image.BitsPerSample&quot;,</a>
<a name="ln1312">        &quot;Exif.Image.Compression&quot;,</a>
<a name="ln1313">        &quot;Exif.Image.PhotometricInterpretation&quot;,</a>
<a name="ln1314">        &quot;Exif.Image.FillOrder&quot;,</a>
<a name="ln1315">        &quot;Exif.Image.SamplesPerPixel&quot;,</a>
<a name="ln1316">        &quot;Exif.Image.StripOffsets&quot;,</a>
<a name="ln1317">        &quot;Exif.Image.RowsPerStrip&quot;,</a>
<a name="ln1318">        &quot;Exif.Image.StripByteCounts&quot;,</a>
<a name="ln1319">        &quot;Exif.Image.PlanarConfiguration&quot;,</a>
<a name="ln1320">        &quot;Exif.Image.DNGVersion&quot;,</a>
<a name="ln1321">        &quot;Exif.Image.DNGBackwardVersion&quot;</a>
<a name="ln1322">      };</a>
<a name="ln1323">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1324">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1325">    }</a>
<a name="ln1326"> </a>
<a name="ln1327">    if(!dng_mode)</a>
<a name="ln1328">    {</a>
<a name="ln1329">      /* Delete various MakerNote fields only applicable to the raw file */</a>
<a name="ln1330"> </a>
<a name="ln1331">      exifData[&quot;Exif.Image.Orientation&quot;] = uint16_t(1);</a>
<a name="ln1332"> </a>
<a name="ln1333">      {</a>
<a name="ln1334">        static const char *keys[] = {</a>
<a name="ln1335">          // Embedded color profile info</a>
<a name="ln1336">          &quot;Exif.Image.BaselineExposureOffset&quot;,</a>
<a name="ln1337">          &quot;Exif.Image.CalibrationIlluminant1&quot;,</a>
<a name="ln1338">          &quot;Exif.Image.CalibrationIlluminant2&quot;,</a>
<a name="ln1339">          &quot;Exif.Image.ColorMatrix1&quot;,</a>
<a name="ln1340">          &quot;Exif.Image.ColorMatrix2&quot;,</a>
<a name="ln1341">          &quot;Exif.Image.DefaultBlackRender&quot;,</a>
<a name="ln1342">          &quot;Exif.Image.ForwardMatrix1&quot;,</a>
<a name="ln1343">          &quot;Exif.Image.ForwardMatrix2&quot;,</a>
<a name="ln1344">          &quot;Exif.Image.ProfileCalibrationSignature&quot;,</a>
<a name="ln1345">          &quot;Exif.Image.ProfileCopyright&quot;,</a>
<a name="ln1346">          &quot;Exif.Image.ProfileEmbedPolicy&quot;,</a>
<a name="ln1347">          &quot;Exif.Image.ProfileHueSatMapData1&quot;,</a>
<a name="ln1348">          &quot;Exif.Image.ProfileHueSatMapData2&quot;,</a>
<a name="ln1349">          &quot;Exif.Image.ProfileHueSatMapDims&quot;,</a>
<a name="ln1350">          &quot;Exif.Image.ProfileHueSatMapEncoding&quot;,</a>
<a name="ln1351">          &quot;Exif.Image.ProfileLookTableData&quot;,</a>
<a name="ln1352">          &quot;Exif.Image.ProfileLookTableDims&quot;,</a>
<a name="ln1353">          &quot;Exif.Image.ProfileLookTableEncoding&quot;,</a>
<a name="ln1354">          &quot;Exif.Image.ProfileName&quot;,</a>
<a name="ln1355">          &quot;Exif.Image.ProfileToneCurve&quot;,</a>
<a name="ln1356">          &quot;Exif.Image.ReductionMatrix1&quot;,</a>
<a name="ln1357">          &quot;Exif.Image.ReductionMatrix2&quot;,</a>
<a name="ln1358"> </a>
<a name="ln1359">          // Canon color space info</a>
<a name="ln1360">          &quot;Exif.Canon.ColorSpace&quot;,</a>
<a name="ln1361">          &quot;Exif.Canon.ColorData&quot;,</a>
<a name="ln1362"> </a>
<a name="ln1363">          // Nikon thumbnail data</a>
<a name="ln1364">          &quot;Exif.Nikon3.Preview&quot;,</a>
<a name="ln1365">          &quot;Exif.NikonPreview.JPEGInterchangeFormat&quot;,</a>
<a name="ln1366"> </a>
<a name="ln1367">          // DNG private data</a>
<a name="ln1368">          &quot;Exif.Image.DNGPrivateData&quot;,</a>
<a name="ln1369"> </a>
<a name="ln1370">          // Pentax thumbnail data</a>
<a name="ln1371">          &quot;Exif.Pentax.PreviewResolution&quot;,</a>
<a name="ln1372">          &quot;Exif.Pentax.PreviewLength&quot;,</a>
<a name="ln1373">          &quot;Exif.Pentax.PreviewOffset&quot;,</a>
<a name="ln1374">          &quot;Exif.PentaxDng.PreviewResolution&quot;,</a>
<a name="ln1375">          &quot;Exif.PentaxDng.PreviewLength&quot;,</a>
<a name="ln1376">          &quot;Exif.PentaxDng.PreviewOffset&quot;,</a>
<a name="ln1377">          // Pentax color info</a>
<a name="ln1378">          &quot;Exif.PentaxDng.ColorInfo&quot;,</a>
<a name="ln1379"> </a>
<a name="ln1380">          // Minolta thumbnail data</a>
<a name="ln1381">          &quot;Exif.Minolta.Thumbnail&quot;,</a>
<a name="ln1382">          &quot;Exif.Minolta.ThumbnailOffset&quot;,</a>
<a name="ln1383">          &quot;Exif.Minolta.ThumbnailLength&quot;,</a>
<a name="ln1384"> </a>
<a name="ln1385">          // Sony thumbnail data</a>
<a name="ln1386">          &quot;Exif.SonyMinolta.ThumbnailOffset&quot;,</a>
<a name="ln1387">          &quot;Exif.SonyMinolta.ThumbnailLength&quot;,</a>
<a name="ln1388"> </a>
<a name="ln1389">          // Olympus thumbnail data</a>
<a name="ln1390">          &quot;Exif.Olympus.Thumbnail&quot;,</a>
<a name="ln1391">          &quot;Exif.Olympus.ThumbnailOffset&quot;,</a>
<a name="ln1392">          &quot;Exif.Olympus.ThumbnailLength&quot;</a>
<a name="ln1393">        };</a>
<a name="ln1394">        static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1395">        dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1396">      }</a>
<a name="ln1397"> </a>
<a name="ln1398">      // remove subimage* trees, related to thumbnails or HDR usually</a>
<a name="ln1399">      for(Exiv2::ExifData::iterator i = exifData.begin(); i != exifData.end();)</a>
<a name="ln1400">      {</a>
<a name="ln1401">        static const std::string needle = &quot;Exif.SubImage&quot;;</a>
<a name="ln1402">        if(i-&gt;key().compare(0, needle.length(), needle) == 0)</a>
<a name="ln1403">          i = exifData.erase(i);</a>
<a name="ln1404">        else</a>
<a name="ln1405">          ++i;</a>
<a name="ln1406">      }</a>
<a name="ln1407"> </a>
<a name="ln1408">#if EXIV2_MINOR_VERSION &gt;= 23</a>
<a name="ln1409">      {</a>
<a name="ln1410">        // Exiv2 versions older than 0.23 drop all EXIF if the code below is executed</a>
<a name="ln1411">        // Samsung makernote cleanup, the entries below have no relevance for exported images</a>
<a name="ln1412">        static const char *keys[] = {</a>
<a name="ln1413">          &quot;Exif.Samsung2.SensorAreas&quot;,</a>
<a name="ln1414">          &quot;Exif.Samsung2.ColorSpace&quot;,</a>
<a name="ln1415">          &quot;Exif.Samsung2.EncryptionKey&quot;,</a>
<a name="ln1416">          &quot;Exif.Samsung2.WB_RGGBLevelsUncorrected&quot;,</a>
<a name="ln1417">          &quot;Exif.Samsung2.WB_RGGBLevelsAuto&quot;,</a>
<a name="ln1418">          &quot;Exif.Samsung2.WB_RGGBLevelsIlluminator1&quot;,</a>
<a name="ln1419">          &quot;Exif.Samsung2.WB_RGGBLevelsIlluminator2&quot;,</a>
<a name="ln1420">          &quot;Exif.Samsung2.WB_RGGBLevelsBlack&quot;,</a>
<a name="ln1421">          &quot;Exif.Samsung2.ColorMatrix&quot;,</a>
<a name="ln1422">          &quot;Exif.Samsung2.ColorMatrixSRGB&quot;,</a>
<a name="ln1423">          &quot;Exif.Samsung2.ColorMatrixAdobeRGB&quot;,</a>
<a name="ln1424">          &quot;Exif.Samsung2.ToneCurve1&quot;,</a>
<a name="ln1425">          &quot;Exif.Samsung2.ToneCurve2&quot;,</a>
<a name="ln1426">          &quot;Exif.Samsung2.ToneCurve3&quot;,</a>
<a name="ln1427">          &quot;Exif.Samsung2.ToneCurve4&quot;</a>
<a name="ln1428">        };</a>
<a name="ln1429">        static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1430">        dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1431">      }</a>
<a name="ln1432">#endif</a>
<a name="ln1433"> </a>
<a name="ln1434">      /* Write appropriate color space tag if using sRGB output */</a>
<a name="ln1435">      if(sRGB)</a>
<a name="ln1436">        exifData[&quot;Exif.Photo.ColorSpace&quot;] = uint16_t(1); /* sRGB */</a>
<a name="ln1437">      else</a>
<a name="ln1438">        exifData[&quot;Exif.Photo.ColorSpace&quot;] = uint16_t(0xFFFF); /* Uncalibrated */</a>
<a name="ln1439">    }</a>
<a name="ln1440"> </a>
<a name="ln1441">    /* Replace RAW dimension with output dimensions (for example after crop/scale, or orientation for dng</a>
<a name="ln1442">     * mode) */</a>
<a name="ln1443">    if(out_width &gt; 0) exifData[&quot;Exif.Photo.PixelXDimension&quot;] = (uint32_t)out_width;</a>
<a name="ln1444">    if(out_height &gt; 0) exifData[&quot;Exif.Photo.PixelYDimension&quot;] = (uint32_t)out_height;</a>
<a name="ln1445"> </a>
<a name="ln1446">    int resolution = dt_conf_get_int(&quot;metadata/resolution&quot;);</a>
<a name="ln1447">    if(resolution &gt; 0)</a>
<a name="ln1448">    {</a>
<a name="ln1449">      exifData[&quot;Exif.Image.XResolution&quot;] = Exiv2::Rational(resolution, 1);</a>
<a name="ln1450">      exifData[&quot;Exif.Image.YResolution&quot;] = Exiv2::Rational(resolution, 1);</a>
<a name="ln1451">      exifData[&quot;Exif.Image.ResolutionUnit&quot;] = uint16_t(2); /* inches */</a>
<a name="ln1452">    }</a>
<a name="ln1453">    else</a>
<a name="ln1454">    {</a>
<a name="ln1455">      static const char *keys[] = {</a>
<a name="ln1456">        &quot;Exif.Image.XResolution&quot;,</a>
<a name="ln1457">        &quot;Exif.Image.YResolution&quot;,</a>
<a name="ln1458">        &quot;Exif.Image.ResolutionUnit&quot;</a>
<a name="ln1459">      };</a>
<a name="ln1460">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1461">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1462">    }</a>
<a name="ln1463"> </a>
<a name="ln1464">    exifData[&quot;Exif.Image.Software&quot;] = darktable_package_string;</a>
<a name="ln1465"> </a>
<a name="ln1466">    // TODO: find a nice place for the missing metadata (tags, publisher, colorlabels?). Additionally find out</a>
<a name="ln1467">    // how to embed XMP data.</a>
<a name="ln1468">    //       And shall we add a description of the history stack to Exif.Image.ImageHistory?</a>
<a name="ln1469">    if(imgid &gt;= 0)</a>
<a name="ln1470">    {</a>
<a name="ln1471">      /* Delete metadata taken from the original file if it's fields we manage in dt, too */</a>
<a name="ln1472">      static const char * keys[] = {</a>
<a name="ln1473">        &quot;Exif.Image.Artist&quot;,</a>
<a name="ln1474">        &quot;Exif.Image.ImageDescription&quot;,</a>
<a name="ln1475">        &quot;Exif.Photo.UserComment&quot;,</a>
<a name="ln1476">        &quot;Exif.Image.Copyright&quot;,</a>
<a name="ln1477">        &quot;Exif.Image.Rating&quot;,</a>
<a name="ln1478">        &quot;Exif.Image.RatingPercent&quot;,</a>
<a name="ln1479">        &quot;Exif.GPSInfo.GPSVersionID&quot;,</a>
<a name="ln1480">        &quot;Exif.GPSInfo.GPSLongitudeRef&quot;,</a>
<a name="ln1481">        &quot;Exif.GPSInfo.GPSLatitudeRef&quot;,</a>
<a name="ln1482">        &quot;Exif.GPSInfo.GPSLongitude&quot;,</a>
<a name="ln1483">        &quot;Exif.GPSInfo.GPSLatitude&quot;,</a>
<a name="ln1484">        &quot;Exif.GPSInfo.GPSAltitudeRef&quot;,</a>
<a name="ln1485">        &quot;Exif.GPSInfo.GPSAltitude&quot;</a>
<a name="ln1486">      };</a>
<a name="ln1487">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln1488">      dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln1489"> </a>
<a name="ln1490">      GList *res = dt_metadata_get(imgid, &quot;Xmp.dc.creator&quot;, NULL);</a>
<a name="ln1491">      if(res != NULL)</a>
<a name="ln1492">      {</a>
<a name="ln1493">        exifData[&quot;Exif.Image.Artist&quot;] = (char *)res-&gt;data;</a>
<a name="ln1494">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1495">      }</a>
<a name="ln1496"> </a>
<a name="ln1497">      res = dt_metadata_get(imgid, &quot;Xmp.dc.description&quot;, NULL);</a>
<a name="ln1498">      if(res != NULL)</a>
<a name="ln1499">      {</a>
<a name="ln1500">        char *desc = (char *)res-&gt;data;</a>
<a name="ln1501">        if(g_str_is_ascii(desc))</a>
<a name="ln1502">          exifData[&quot;Exif.Image.ImageDescription&quot;] = desc;</a>
<a name="ln1503">        else</a>
<a name="ln1504">          exifData[&quot;Exif.Photo.UserComment&quot;] = desc;</a>
<a name="ln1505">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1506">      }</a>
<a name="ln1507"> </a>
<a name="ln1508">      res = dt_metadata_get(imgid, &quot;Xmp.dc.rights&quot;, NULL);</a>
<a name="ln1509">      if(res != NULL)</a>
<a name="ln1510">      {</a>
<a name="ln1511">        exifData[&quot;Exif.Image.Copyright&quot;] = (char *)res-&gt;data;</a>
<a name="ln1512">        g_list_free_full(res, &amp;g_free);</a>
<a name="ln1513">      }</a>
<a name="ln1514"> </a>
<a name="ln1515">      res = dt_metadata_get(imgid, &quot;Xmp.xmp.Rating&quot;, NULL);</a>
<a name="ln1516">      if(res != NULL)</a>
<a name="ln1517">      {</a>
<a name="ln1518">        int rating = GPOINTER_TO_INT(res-&gt;data) + 1;</a>
<a name="ln1519">        exifData[&quot;Exif.Image.Rating&quot;] = rating;</a>
<a name="ln1520">        exifData[&quot;Exif.Image.RatingPercent&quot;] = int(rating / 5. * 100.);</a>
<a name="ln1521">        g_list_free(res);</a>
<a name="ln1522">      }</a>
<a name="ln1523"> </a>
<a name="ln1524">      // GPS data</a>
<a name="ln1525">      const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1526">      if(!std::isnan(cimg-&gt;geoloc.longitude) &amp;&amp; !std::isnan(cimg-&gt;geoloc.latitude))</a>
<a name="ln1527">      {</a>
<a name="ln1528">        exifData[&quot;Exif.GPSInfo.GPSVersionID&quot;] = &quot;02 02 00 00&quot;;</a>
<a name="ln1529">        exifData[&quot;Exif.GPSInfo.GPSLongitudeRef&quot;] = (cimg-&gt;geoloc.longitude &lt; 0) ? &quot;W&quot; : &quot;E&quot;;</a>
<a name="ln1530">        exifData[&quot;Exif.GPSInfo.GPSLatitudeRef&quot;] = (cimg-&gt;geoloc.latitude &lt; 0) ? &quot;S&quot; : &quot;N&quot;;</a>
<a name="ln1531"> </a>
<a name="ln1532">        long long_deg = (int)floor(fabs(cimg-&gt;geoloc.longitude));</a>
<a name="ln1533">        long lat_deg = (int)floor(fabs(cimg-&gt;geoloc.latitude));</a>
<a name="ln1534">        long long_min = (int)floor((fabs(cimg-&gt;geoloc.longitude) - floor(fabs(cimg-&gt;geoloc.longitude))) * 60000000);</a>
<a name="ln1535">        long lat_min = (int)floor((fabs(cimg-&gt;geoloc.latitude) - floor(fabs(cimg-&gt;geoloc.latitude))) * 60000000);</a>
<a name="ln1536">        gchar *long_str = g_strdup_printf(&quot;%ld/1 %ld/1000000 0/1&quot;, long_deg, long_min);</a>
<a name="ln1537">        gchar *lat_str = g_strdup_printf(&quot;%ld/1 %ld/1000000 0/1&quot;, lat_deg, lat_min);</a>
<a name="ln1538">        exifData[&quot;Exif.GPSInfo.GPSLongitude&quot;] = long_str;</a>
<a name="ln1539">        exifData[&quot;Exif.GPSInfo.GPSLatitude&quot;] = lat_str;</a>
<a name="ln1540">        g_free(long_str);</a>
<a name="ln1541">        g_free(lat_str);</a>
<a name="ln1542">      }</a>
<a name="ln1543">      if(!std::isnan(cimg-&gt;geoloc.elevation))</a>
<a name="ln1544">      {</a>
<a name="ln1545">        exifData[&quot;Exif.GPSInfo.GPSVersionID&quot;] = &quot;02 02 00 00&quot;;</a>
<a name="ln1546">        exifData[&quot;Exif.GPSInfo.GPSAltitudeRef&quot;] = (cimg-&gt;geoloc.elevation &lt; 0) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln1547"> </a>
<a name="ln1548">        long ele_dm = (int)floor(fabs(10.0 * cimg-&gt;geoloc.elevation));</a>
<a name="ln1549">        gchar *ele_str = g_strdup_printf(&quot;%ld/10&quot;, ele_dm);</a>
<a name="ln1550">        exifData[&quot;Exif.GPSInfo.GPSAltitude&quot;] = ele_str;</a>
<a name="ln1551">        g_free(ele_str);</a>
<a name="ln1552">      }</a>
<a name="ln1553"> </a>
<a name="ln1554">      // According to the Exif specs DateTime is to be set to the last modification time while</a>
<a name="ln1555">      // DateTimeOriginal is to be kept.</a>
<a name="ln1556">      // For us &quot;keeping&quot; it means to write out what we have in DB to support people adding a time offset in</a>
<a name="ln1557">      // the geotagging module.</a>
<a name="ln1558">      gchar new_datetime[20];</a>
<a name="ln1559">      dt_gettime(new_datetime, sizeof(new_datetime));</a>
<a name="ln1560">      exifData[&quot;Exif.Image.DateTime&quot;] = new_datetime;</a>
<a name="ln1561">      exifData[&quot;Exif.Image.DateTimeOriginal&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1562">      exifData[&quot;Exif.Photo.DateTimeOriginal&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1563">      // FIXME: What about DateTimeDigitized? we currently update it, too, which might not be what is expected</a>
<a name="ln1564">      // for scanned images</a>
<a name="ln1565">      exifData[&quot;Exif.Photo.DateTimeDigitized&quot;] = cimg-&gt;exif_datetime_taken;</a>
<a name="ln1566"> </a>
<a name="ln1567">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1568">    }</a>
<a name="ln1569"> </a>
<a name="ln1570">    Exiv2::Blob blob;</a>
<a name="ln1571">    Exiv2::ExifParser::encode(blob, Exiv2::bigEndian, exifData);</a>
<a name="ln1572">    const int length = blob.size();</a>
<a name="ln1573">    *buf = (uint8_t *)malloc(length+6);</a>
<a name="ln1574">    if (!*buf)</a>
<a name="ln1575">    {</a>
<a name="ln1576">      return 0;</a>
<a name="ln1577">    }</a>
<a name="ln1578">    memcpy(*buf, &quot;Exif\000\000&quot;, 6);</a>
<a name="ln1579">    memcpy(*buf + 6, &amp;(blob[0]), length);</a>
<a name="ln1580">    return length + 6;</a>
<a name="ln1581">  }</a>
<a name="ln1582">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln1583">  {</a>
<a name="ln1584">    // std::cerr.rdbuf(savecerr);</a>
<a name="ln1585">    std::string s(e.what());</a>
<a name="ln1586">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; path &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln1587">    free(*buf);</a>
<a name="ln1588">    *buf = NULL;</a>
<a name="ln1589">    return 0;</a>
<a name="ln1590">  }</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">// encode binary blob into text:</a>
<a name="ln1594">char *dt_exif_xmp_encode(const unsigned char *input, const int len, int *output_len)</a>
<a name="ln1595">{</a>
<a name="ln1596">#define COMPRESS_THRESHOLD 100</a>
<a name="ln1597"> </a>
<a name="ln1598">  gboolean do_compress = FALSE;</a>
<a name="ln1599"> </a>
<a name="ln1600">  // if input data field exceeds a certain size we compress it and convert to base64;</a>
<a name="ln1601">  // main reason for compression: make more xmp data fit into 64k segment within</a>
<a name="ln1602">  // JPEG output files.</a>
<a name="ln1603">  char *config = dt_conf_get_string(&quot;compress_xmp_tags&quot;);</a>
<a name="ln1604">  if(config)</a>
<a name="ln1605">  {</a>
<a name="ln1606">    if(!strcmp(config, &quot;always&quot;))</a>
<a name="ln1607">      do_compress = TRUE;</a>
<a name="ln1608">    else if((len &gt; COMPRESS_THRESHOLD) &amp;&amp; !strcmp(config, &quot;only large entries&quot;))</a>
<a name="ln1609">      do_compress = TRUE;</a>
<a name="ln1610">    else</a>
<a name="ln1611">      do_compress = FALSE;</a>
<a name="ln1612">    g_free(config);</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  return dt_exif_xmp_encode_internal(input, len, output_len, do_compress);</a>
<a name="ln1616"> </a>
<a name="ln1617">#undef COMPRESS_THRESHOLD</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">char *dt_exif_xmp_encode_internal(const unsigned char *input, const int len, int *output_len, gboolean do_compress)</a>
<a name="ln1621">{</a>
<a name="ln1622">  char *output = NULL;</a>
<a name="ln1623"> </a>
<a name="ln1624">  if(do_compress)</a>
<a name="ln1625">  {</a>
<a name="ln1626">    int result;</a>
<a name="ln1627">    uLongf destLen = compressBound(len);</a>
<a name="ln1628">    unsigned char *buffer1 = (unsigned char *)malloc(destLen);</a>
<a name="ln1629"> </a>
<a name="ln1630">    result = compress(buffer1, &amp;destLen, input, len);</a>
<a name="ln1631"> </a>
<a name="ln1632">    if(result != Z_OK)</a>
<a name="ln1633">    {</a>
<a name="ln1634">      free(buffer1);</a>
<a name="ln1635">      return NULL;</a>
<a name="ln1636">    }</a>
<a name="ln1637"> </a>
<a name="ln1638">    // we store the compression factor</a>
<a name="ln1639">    const int factor = MIN(len / destLen + 1, 99);</a>
<a name="ln1640"> </a>
<a name="ln1641">    char *buffer2 = (char *)g_base64_encode(buffer1, destLen);</a>
<a name="ln1642">    free(buffer1);</a>
<a name="ln1643">    if(!buffer2) return NULL;</a>
<a name="ln1644"> </a>
<a name="ln1645">    int outlen = strlen(buffer2) + 5; // leading &quot;gz&quot; + compression factor + base64 string + trailing '\0'</a>
<a name="ln1646">    output = (char *)malloc(outlen);</a>
<a name="ln1647">    if(!output)</a>
<a name="ln1648">    {</a>
<a name="ln1649">      g_free(buffer2);</a>
<a name="ln1650">      return NULL;</a>
<a name="ln1651">    }</a>
<a name="ln1652"> </a>
<a name="ln1653">    output[0] = 'g';</a>
<a name="ln1654">    output[1] = 'z';</a>
<a name="ln1655">    output[2] = factor / 10 + '0';</a>
<a name="ln1656">    output[3] = factor % 10 + '0';</a>
<a name="ln1657">    g_strlcpy(output + 4, buffer2, outlen);</a>
<a name="ln1658">    g_free(buffer2);</a>
<a name="ln1659"> </a>
<a name="ln1660">    if(output_len) *output_len = outlen;</a>
<a name="ln1661">  }</a>
<a name="ln1662">  else</a>
<a name="ln1663">  {</a>
<a name="ln1664">    const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };</a>
<a name="ln1665"> </a>
<a name="ln1666">    output = (char *)malloc(2 * len + 1);</a>
<a name="ln1667">    if(!output) return NULL;</a>
<a name="ln1668"> </a>
<a name="ln1669">    if(output_len) *output_len = 2 * len + 1;</a>
<a name="ln1670"> </a>
<a name="ln1671">    for(int i = 0; i &lt; len; i++)</a>
<a name="ln1672">    {</a>
<a name="ln1673">      const int hi = input[i] &gt;&gt; 4;</a>
<a name="ln1674">      const int lo = input[i] &amp; 15;</a>
<a name="ln1675">      output[2 * i] = hex[hi];</a>
<a name="ln1676">      output[2 * i + 1] = hex[lo];</a>
<a name="ln1677">    }</a>
<a name="ln1678">    output[2 * len] = '\0';</a>
<a name="ln1679">  }</a>
<a name="ln1680"> </a>
<a name="ln1681">  return output;</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">// and back to binary</a>
<a name="ln1685">unsigned char *dt_exif_xmp_decode(const char *input, const int len, int *output_len)</a>
<a name="ln1686">{</a>
<a name="ln1687">  unsigned char *output = NULL;</a>
<a name="ln1688"> </a>
<a name="ln1689">  // check if data is in compressed format</a>
<a name="ln1690">  if(!strncmp(input, &quot;gz&quot;, 2))</a>
<a name="ln1691">  {</a>
<a name="ln1692">    // we have compressed data in base64 representation with leading &quot;gz&quot;</a>
<a name="ln1693"> </a>
<a name="ln1694">    // get stored compression factor so we know the needed buffer size for uncompress</a>
<a name="ln1695">    const float factor = 10 * (input[2] - '0') + (input[3] - '0');</a>
<a name="ln1696"> </a>
<a name="ln1697">    // get a rw copy of input buffer omitting leading &quot;gz&quot; and compression factor</a>
<a name="ln1698">    unsigned char *buffer = (unsigned char *)strdup(input + 4);</a>
<a name="ln1699">    if(!buffer) return NULL;</a>
<a name="ln1700"> </a>
<a name="ln1701">    // decode from base64 to compressed binary</a>
<a name="ln1702">    gsize compressed_size;</a>
<a name="ln1703">    g_base64_decode_inplace((char *)buffer, &amp;compressed_size);</a>
<a name="ln1704"> </a>
<a name="ln1705">    // do the actual uncompress step</a>
<a name="ln1706">    int result = Z_BUF_ERROR;</a>
<a name="ln1707">    uLongf bufLen = factor * compressed_size;</a>
<a name="ln1708">    uLongf destLen;</a>
<a name="ln1709"> </a>
<a name="ln1710">    // we know the actual compression factor but if that fails we re-try with</a>
<a name="ln1711">    // increasing buffer sizes, eg. we don't know (unlikely) factors &gt; 99</a>
<a name="ln1712">    do</a>
<a name="ln1713">    {</a>
<a name="ln1714">      if(output) free(output);</a>
<a name="ln1715">      output = (unsigned char *)malloc(bufLen);</a>
<a name="ln1716">      if(!output) break;</a>
<a name="ln1717"> </a>
<a name="ln1718">      destLen = bufLen;</a>
<a name="ln1719"> </a>
<a name="ln1720">      result = uncompress(output, &amp;destLen, buffer, compressed_size);</a>
<a name="ln1721"> </a>
<a name="ln1722">      bufLen *= 2;</a>
<a name="ln1723"> </a>
<a name="ln1724">    } while(result == Z_BUF_ERROR);</a>
<a name="ln1725"> </a>
<a name="ln1726"> </a>
<a name="ln1727">    free(buffer);</a>
<a name="ln1728"> </a>
<a name="ln1729">    if(result != Z_OK)</a>
<a name="ln1730">    {</a>
<a name="ln1731">      if(output) free(output);</a>
<a name="ln1732">      return NULL;</a>
<a name="ln1733">    }</a>
<a name="ln1734"> </a>
<a name="ln1735">    if(output_len) *output_len = destLen;</a>
<a name="ln1736">  }</a>
<a name="ln1737">  else</a>
<a name="ln1738">  {</a>
<a name="ln1739">// we have uncompressed data in hexadecimal ascii representation</a>
<a name="ln1740"> </a>
<a name="ln1741">// ascii table:</a>
<a name="ln1742">// 48- 57 0-9</a>
<a name="ln1743">// 97-102 a-f</a>
<a name="ln1744">#define TO_BINARY(a) (a &gt; 57 ? a - 97 + 10 : a - 48)</a>
<a name="ln1745"> </a>
<a name="ln1746">    // make sure that we don't find any unexpected characters indicating corrupted data</a>
<a name="ln1747">    if(strspn(input, &quot;0123456789abcdef&quot;) != strlen(input)) return NULL;</a>
<a name="ln1748"> </a>
<a name="ln1749">    output = (unsigned char *)malloc(len / 2);</a>
<a name="ln1750">    if(!output) return NULL;</a>
<a name="ln1751"> </a>
<a name="ln1752">    if(output_len) *output_len = len / 2;</a>
<a name="ln1753"> </a>
<a name="ln1754">    for(int i = 0; i &lt; len / 2; i++)</a>
<a name="ln1755">    {</a>
<a name="ln1756">      const int hi = TO_BINARY(input[2 * i]);</a>
<a name="ln1757">      const int lo = TO_BINARY(input[2 * i + 1]);</a>
<a name="ln1758">      output[i] = (hi &lt;&lt; 4) | lo;</a>
<a name="ln1759">    }</a>
<a name="ln1760">#undef TO_BINARY</a>
<a name="ln1761">  }</a>
<a name="ln1762"> </a>
<a name="ln1763">  return output;</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766">static void _exif_import_tags(dt_image_t *img, Exiv2::XmpData::iterator &amp;pos)</a>
<a name="ln1767">{</a>
<a name="ln1768">  // tags in array</a>
<a name="ln1769">  const int cnt = pos-&gt;count();</a>
<a name="ln1770"> </a>
<a name="ln1771">  sqlite3_stmt *stmt_sel_id, *stmt_ins_tags, *stmt_ins_tagged;</a>
<a name="ln1772">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM data.tags WHERE name = ?1&quot;, -1,</a>
<a name="ln1773">                              &amp;stmt_sel_id, NULL);</a>
<a name="ln1774">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;INSERT INTO data.tags (id, name) VALUES (NULL, ?1)&quot;,</a>
<a name="ln1775">                              -1, &amp;stmt_ins_tags, NULL);</a>
<a name="ln1776">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln1777">                              &quot;INSERT INTO main.tagged_images (tagid, imgid) VALUES (?1, ?2)&quot;, -1,</a>
<a name="ln1778">                              &amp;stmt_ins_tagged, NULL);</a>
<a name="ln1779">  for(int i = 0; i &lt; cnt; i++)</a>
<a name="ln1780">  {</a>
<a name="ln1781">    char tagbuf[1024];</a>
<a name="ln1782">    std::string pos_str = pos-&gt;toString(i);</a>
<a name="ln1783">    g_strlcpy(tagbuf, pos_str.c_str(), sizeof(tagbuf));</a>
<a name="ln1784">    int tagid = -1;</a>
<a name="ln1785">    char *tag = tagbuf;</a>
<a name="ln1786">    while(tag)</a>
<a name="ln1787">    {</a>
<a name="ln1788">      char *next_tag = strstr(tag, &quot;,&quot;);</a>
<a name="ln1789">      if(next_tag) *(next_tag++) = 0;</a>
<a name="ln1790">      // check if tag is available, get its id:</a>
<a name="ln1791">      for(int k = 0; k &lt; 2; k++)</a>
<a name="ln1792">      {</a>
<a name="ln1793">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt_sel_id, 1, tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1794">        if(sqlite3_step(stmt_sel_id) == SQLITE_ROW) tagid = sqlite3_column_int(stmt_sel_id, 0);</a>
<a name="ln1795">        sqlite3_reset(stmt_sel_id);</a>
<a name="ln1796">        sqlite3_clear_bindings(stmt_sel_id);</a>
<a name="ln1797"> </a>
<a name="ln1798">        if(tagid &gt; 0) break;</a>
<a name="ln1799"> </a>
<a name="ln1800">        fprintf(stderr, &quot;[xmp_import] creating tag: %s\n&quot;, tag);</a>
<a name="ln1801">        // create this tag (increment id, leave icon empty), retry.</a>
<a name="ln1802">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt_ins_tags, 1, tag, -1, SQLITE_TRANSIENT);</a>
<a name="ln1803">        sqlite3_step(stmt_ins_tags);</a>
<a name="ln1804">        sqlite3_reset(stmt_ins_tags);</a>
<a name="ln1805">        sqlite3_clear_bindings(stmt_ins_tags);</a>
<a name="ln1806">      }</a>
<a name="ln1807">      // associate image and tag.</a>
<a name="ln1808">      DT_DEBUG_SQLITE3_BIND_INT(stmt_ins_tagged, 1, tagid);</a>
<a name="ln1809">      DT_DEBUG_SQLITE3_BIND_INT(stmt_ins_tagged, 2, img-&gt;id);</a>
<a name="ln1810">      sqlite3_step(stmt_ins_tagged);</a>
<a name="ln1811">      sqlite3_reset(stmt_ins_tagged);</a>
<a name="ln1812">      sqlite3_clear_bindings(stmt_ins_tagged);</a>
<a name="ln1813"> </a>
<a name="ln1814">      tag = next_tag;</a>
<a name="ln1815">    }</a>
<a name="ln1816">  }</a>
<a name="ln1817">  sqlite3_finalize(stmt_sel_id);</a>
<a name="ln1818">  sqlite3_finalize(stmt_ins_tags);</a>
<a name="ln1819">  sqlite3_finalize(stmt_ins_tagged);</a>
<a name="ln1820"> </a>
<a name="ln1821">  // update used_tags</a>
<a name="ln1822">  dt_tag_update_used_tags();</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825">typedef struct history_entry_t</a>
<a name="ln1826">{</a>
<a name="ln1827">  char *operation;</a>
<a name="ln1828">  gboolean enabled;</a>
<a name="ln1829">  int modversion;</a>
<a name="ln1830">  unsigned char *params;</a>
<a name="ln1831">  int params_len;</a>
<a name="ln1832">  char *multi_name;</a>
<a name="ln1833">  int multi_priority;</a>
<a name="ln1834">  int blendop_version;</a>
<a name="ln1835">  unsigned char *blendop_params;</a>
<a name="ln1836">  int blendop_params_len;</a>
<a name="ln1837">  int num;</a>
<a name="ln1838">  double iop_order;</a>
<a name="ln1839"> </a>
<a name="ln1840">  // sanity checking</a>
<a name="ln1841">  gboolean have_operation, have_params, have_modversion;</a>
<a name="ln1842">} history_entry_t;</a>
<a name="ln1843"> </a>
<a name="ln1844">// used for a hash table that maps mask_id to the mask data</a>
<a name="ln1845">typedef struct mask_entry_t</a>
<a name="ln1846">{</a>
<a name="ln1847">  int mask_id;</a>
<a name="ln1848">  int mask_type;</a>
<a name="ln1849">  char *mask_name;</a>
<a name="ln1850">  int mask_version;</a>
<a name="ln1851">  unsigned char *mask_points;</a>
<a name="ln1852">  int mask_points_len;</a>
<a name="ln1853">  int mask_nb;</a>
<a name="ln1854">  unsigned char *mask_src;</a>
<a name="ln1855">  int mask_src_len;</a>
<a name="ln1856">  gboolean already_added;</a>
<a name="ln1857">  int mask_num;</a>
<a name="ln1858">  int version;</a>
<a name="ln1859">} mask_entry_t;</a>
<a name="ln1860"> </a>
<a name="ln1861">static void print_history_entry(history_entry_t *entry) __attribute__((unused));</a>
<a name="ln1862">static void print_history_entry(history_entry_t *entry)</a>
<a name="ln1863">{</a>
<a name="ln1864">  if(!entry || !entry-&gt;operation)</a>
<a name="ln1865">  {</a>
<a name="ln1866">    std::cout &lt;&lt; &quot;malformed entry&quot; &lt;&lt; std::endl;</a>
<a name="ln1867">    return;</a>
<a name="ln1868">  }</a>
<a name="ln1869"> </a>
<a name="ln1870">  std::cout &lt;&lt; entry-&gt;operation &lt;&lt; std::endl;</a>
<a name="ln1871">  std::cout &lt;&lt; &quot;  modversion      :&quot; &lt;&lt;  entry-&gt;modversion                                    &lt;&lt; std::endl;</a>
<a name="ln1872">  std::cout &lt;&lt; &quot;  enabled         :&quot; &lt;&lt;  entry-&gt;enabled                                       &lt;&lt; std::endl;</a>
<a name="ln1873">  std::cout &lt;&lt; &quot;  params          :&quot; &lt;&lt; (entry-&gt;params ? &quot;&lt;found&gt;&quot; : &quot;&lt;missing&gt;&quot;)             &lt;&lt; std::endl;</a>
<a name="ln1874">  std::cout &lt;&lt; &quot;  multi_name      :&quot; &lt;&lt; (entry-&gt;multi_name ? entry-&gt;multi_name : &quot;&lt;missing&gt;&quot;) &lt;&lt; std::endl;</a>
<a name="ln1875">  std::cout &lt;&lt; &quot;  multi_priority  :&quot; &lt;&lt;  entry-&gt;multi_priority                                &lt;&lt; std::endl;</a>
<a name="ln1876">  std::cout &lt;&lt; &quot;  iop_order       :&quot; &lt;&lt; entry-&gt;iop_order                                      &lt;&lt; std::endl;</a>
<a name="ln1877">  std::cout &lt;&lt; &quot;  blendop_version :&quot; &lt;&lt;  entry-&gt;blendop_version                               &lt;&lt; std::endl;</a>
<a name="ln1878">  std::cout &lt;&lt; &quot;  blendop_params  :&quot; &lt;&lt; (entry-&gt;blendop_params ? &quot;&lt;found&gt;&quot; : &quot;&lt;missing&gt;&quot;)     &lt;&lt; std::endl;</a>
<a name="ln1879">  std::cout &lt;&lt; std::endl;</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882">static void free_history_entry(gpointer data)</a>
<a name="ln1883">{</a>
<a name="ln1884">  history_entry_t *entry = (history_entry_t *)data;</a>
<a name="ln1885">  g_free(entry-&gt;operation);</a>
<a name="ln1886">  g_free(entry-&gt;multi_name);</a>
<a name="ln1887">  free(entry-&gt;params);</a>
<a name="ln1888">  free(entry-&gt;blendop_params);</a>
<a name="ln1889">  free(entry);</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892">// we have to use pugixml as the old format could contain empty rdf:li elements in the multi_name array</a>
<a name="ln1893">// which causes problems when accessing it with libexiv2 :(</a>
<a name="ln1894">// superold is a flag indicating that data is wrapped in &lt;rdf:Bag&gt; instead of &lt;rdf:Seq&gt;.</a>
<a name="ln1895">static GList *read_history_v1(const std::string &amp;xmpPacket, const char *filename, const int superold)</a>
<a name="ln1896">{</a>
<a name="ln1897">  GList *history_entries = NULL;</a>
<a name="ln1898"> </a>
<a name="ln1899">  pugi::xml_document doc;</a>
<a name="ln1900">#if defined(PUGIXML_VERSION) &amp;&amp; PUGIXML_VERSION &gt;= 150</a>
<a name="ln1901">  pugi::xml_parse_result result = doc.load_string(xmpPacket.c_str());</a>
<a name="ln1902">#else</a>
<a name="ln1903">  pugi::xml_parse_result result = doc.load(xmpPacket.c_str());</a>
<a name="ln1904">#endif</a>
<a name="ln1905"> </a>
<a name="ln1906">  if(!result)</a>
<a name="ln1907">  {</a>
<a name="ln1908">    std::cerr &lt;&lt; &quot;XML '&quot; &lt;&lt; filename &lt;&lt; &quot;' parsed with errors&quot; &lt;&lt; std::endl;</a>
<a name="ln1909">    std::cerr &lt;&lt; &quot;Error description: &quot; &lt;&lt; result.description() &lt;&lt; std::endl;</a>
<a name="ln1910">    std::cerr &lt;&lt; &quot;Error offset: &quot; &lt;&lt; result.offset &lt;&lt; std::endl;</a>
<a name="ln1911">    return NULL;</a>
<a name="ln1912">  }</a>
<a name="ln1913"> </a>
<a name="ln1914">  // get the old elements</a>
<a name="ln1915">  // select_single_node() is deprecated and just kept for old versions shipped in some distributions</a>
<a name="ln1916">#if defined(PUGIXML_VERSION) &amp;&amp; PUGIXML_VERSION &gt;= 150</a>
<a name="ln1917">  pugi::xpath_node modversion      = superold ?</a>
<a name="ln1918">    doc.select_node(&quot;//darktable:history_modversion/rdf:Bag&quot;):</a>
<a name="ln1919">    doc.select_node(&quot;//darktable:history_modversion/rdf:Seq&quot;);</a>
<a name="ln1920">  pugi::xpath_node enabled         = superold ?</a>
<a name="ln1921">    doc.select_node(&quot;//darktable:history_enabled/rdf:Bag&quot;):</a>
<a name="ln1922">    doc.select_node(&quot;//darktable:history_enabled/rdf:Seq&quot;);</a>
<a name="ln1923">  pugi::xpath_node operation       = superold ?</a>
<a name="ln1924">    doc.select_node(&quot;//darktable:history_operation/rdf:Bag&quot;):</a>
<a name="ln1925">    doc.select_node(&quot;//darktable:history_operation/rdf:Seq&quot;);</a>
<a name="ln1926">  pugi::xpath_node params          = superold ?</a>
<a name="ln1927">    doc.select_node(&quot;//darktable:history_params/rdf:Bag&quot;):</a>
<a name="ln1928">    doc.select_node(&quot;//darktable:history_params/rdf:Seq&quot;);</a>
<a name="ln1929">  pugi::xpath_node blendop_params  = superold ?</a>
<a name="ln1930">    doc.select_node(&quot;//darktable:blendop_params/rdf:Bag&quot;):</a>
<a name="ln1931">    doc.select_node(&quot;//darktable:blendop_params/rdf:Seq&quot;);</a>
<a name="ln1932">  pugi::xpath_node blendop_version = superold ?</a>
<a name="ln1933">    doc.select_node(&quot;//darktable:blendop_version/rdf:Bag&quot;):</a>
<a name="ln1934">    doc.select_node(&quot;//darktable:blendop_version/rdf:Seq&quot;);</a>
<a name="ln1935">  pugi::xpath_node multi_priority  = superold ?</a>
<a name="ln1936">    doc.select_node(&quot;//darktable:multi_priority/rdf:Bag&quot;):</a>
<a name="ln1937">    doc.select_node(&quot;//darktable:multi_priority/rdf:Seq&quot;);</a>
<a name="ln1938">  pugi::xpath_node multi_name      = superold ?</a>
<a name="ln1939">    doc.select_node(&quot;//darktable:multi_name/rdf:Bag&quot;):</a>
<a name="ln1940">    doc.select_node(&quot;//darktable:multi_name/rdf:Bag&quot;);</a>
<a name="ln1941">#else</a>
<a name="ln1942">  pugi::xpath_node modversion      = superold ?</a>
<a name="ln1943">    doc.select_single_node(&quot;//darktable:history_modversion/rdf:Bag&quot;):</a>
<a name="ln1944">    doc.select_single_node(&quot;//darktable:history_modversion/rdf:Seq&quot;);</a>
<a name="ln1945">  pugi::xpath_node enabled         = superold ?</a>
<a name="ln1946">    doc.select_single_node(&quot;//darktable:history_enabled/rdf:Bag&quot;):</a>
<a name="ln1947">    doc.select_single_node(&quot;//darktable:history_enabled/rdf:Seq&quot;);</a>
<a name="ln1948">  pugi::xpath_node operation       = superold ?</a>
<a name="ln1949">    doc.select_single_node(&quot;//darktable:history_operation/rdf:Bag&quot;):</a>
<a name="ln1950">    doc.select_single_node(&quot;//darktable:history_operation/rdf:Seq&quot;);</a>
<a name="ln1951">  pugi::xpath_node params          = superold ?</a>
<a name="ln1952">    doc.select_single_node(&quot;//darktable:history_params/rdf:Bag&quot;):</a>
<a name="ln1953">    doc.select_single_node(&quot;//darktable:history_params/rdf:Seq&quot;);</a>
<a name="ln1954">  pugi::xpath_node blendop_params  = superold ?</a>
<a name="ln1955">    doc.select_single_node(&quot;//darktable:blendop_params/rdf:Bag&quot;):</a>
<a name="ln1956">    doc.select_single_node(&quot;//darktable:blendop_params/rdf:Seq&quot;);</a>
<a name="ln1957">  pugi::xpath_node blendop_version = superold ?</a>
<a name="ln1958">    doc.select_single_node(&quot;//darktable:blendop_version/rdf:Bag&quot;):</a>
<a name="ln1959">    doc.select_single_node(&quot;//darktable:blendop_version/rdf:Seq&quot;);</a>
<a name="ln1960">  pugi::xpath_node multi_priority  = superold ?</a>
<a name="ln1961">    doc.select_single_node(&quot;//darktable:multi_priority/rdf:Bag&quot;):</a>
<a name="ln1962">    doc.select_single_node(&quot;//darktable:multi_priority/rdf:Seq&quot;);</a>
<a name="ln1963">  pugi::xpath_node multi_name      = superold ?</a>
<a name="ln1964">    doc.select_single_node(&quot;//darktable:multi_name/rdf:Bag&quot;):</a>
<a name="ln1965">    doc.select_single_node(&quot;//darktable:multi_name/rdf:Bag&quot;);</a>
<a name="ln1966">#endif</a>
<a name="ln1967"> </a>
<a name="ln1968">  // fill the list of history entries. we are iterating over history_operation as we know that it's there.</a>
<a name="ln1969">  // the other iters are taken care of manually.</a>
<a name="ln1970">  auto modversion_iter = modversion.node().children().begin();</a>
<a name="ln1971">  auto enabled_iter = enabled.node().children().begin();</a>
<a name="ln1972">  auto params_iter = params.node().children().begin();</a>
<a name="ln1973">  auto blendop_params_iter = blendop_params.node().children().begin();</a>
<a name="ln1974">  auto blendop_version_iter = blendop_version.node().children().begin();</a>
<a name="ln1975">  auto multi_priority_iter = multi_priority.node().children().begin();</a>
<a name="ln1976">  auto multi_name_iter = multi_name.node().children().begin();</a>
<a name="ln1977"> </a>
<a name="ln1978">  for(pugi::xml_node operation_iter: operation.node().children())</a>
<a name="ln1979">  {</a>
<a name="ln1980">    history_entry_t *current_entry = (history_entry_t *)calloc(1, sizeof(history_entry_t));</a>
<a name="ln1981">    current_entry-&gt;blendop_version = 1; // default version in case it's not specified</a>
<a name="ln1982">    history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln1983"> </a>
<a name="ln1984">    current_entry-&gt;operation = g_strdup(operation_iter.child_value());</a>
<a name="ln1985"> </a>
<a name="ln1986">    current_entry-&gt;enabled = g_strcmp0(enabled_iter-&gt;child_value(), &quot;0&quot;) != 0;</a>
<a name="ln1987"> </a>
<a name="ln1988">    current_entry-&gt;modversion = atoi(modversion_iter-&gt;child_value());</a>
<a name="ln1989"> </a>
<a name="ln1990">    current_entry-&gt;params = dt_exif_xmp_decode(params_iter-&gt;child_value(), strlen(params_iter-&gt;child_value()),</a>
<a name="ln1991">                                               &amp;current_entry-&gt;params_len);</a>
<a name="ln1992"> </a>
<a name="ln1993">    if(multi_name &amp;&amp; multi_name_iter != multi_name.node().children().end())</a>
<a name="ln1994">    {</a>
<a name="ln1995">      current_entry-&gt;multi_name = g_strdup(multi_name_iter-&gt;child_value());</a>
<a name="ln1996">      multi_name_iter++;</a>
<a name="ln1997">    }</a>
<a name="ln1998"> </a>
<a name="ln1999">    if(multi_priority &amp;&amp; multi_priority_iter != multi_priority.node().children().end())</a>
<a name="ln2000">    {</a>
<a name="ln2001">      current_entry-&gt;multi_priority = atoi(multi_priority_iter-&gt;child_value());</a>
<a name="ln2002">      multi_priority_iter++;</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    if(blendop_version &amp;&amp; blendop_version_iter != blendop_version.node().children().end())</a>
<a name="ln2006">    {</a>
<a name="ln2007">      current_entry-&gt;blendop_version = atoi(blendop_version_iter-&gt;child_value());</a>
<a name="ln2008">      blendop_version_iter++;</a>
<a name="ln2009">    }</a>
<a name="ln2010"> </a>
<a name="ln2011">    if(blendop_params &amp;&amp; blendop_params_iter != blendop_params.node().children().end())</a>
<a name="ln2012">    {</a>
<a name="ln2013">      current_entry-&gt;blendop_params = dt_exif_xmp_decode(blendop_params_iter-&gt;child_value(),</a>
<a name="ln2014">                                                         strlen(blendop_params_iter-&gt;child_value()),</a>
<a name="ln2015">                                                         &amp;current_entry-&gt;blendop_params_len);</a>
<a name="ln2016">      blendop_params_iter++;</a>
<a name="ln2017">    }</a>
<a name="ln2018"> </a>
<a name="ln2019">    current_entry-&gt;iop_order = -1.0;</a>
<a name="ln2020"> </a>
<a name="ln2021">    modversion_iter++;</a>
<a name="ln2022">    enabled_iter++;</a>
<a name="ln2023">    params_iter++;</a>
<a name="ln2024">  }</a>
<a name="ln2025"> </a>
<a name="ln2026">  return history_entries;</a>
<a name="ln2027">}</a>
<a name="ln2028"> </a>
<a name="ln2029">static GList *read_history_v2(Exiv2::XmpData &amp;xmpData, const char *filename)</a>
<a name="ln2030">{</a>
<a name="ln2031">  GList *history_entries = NULL;</a>
<a name="ln2032">  history_entry_t *current_entry = NULL;</a>
<a name="ln2033"> </a>
<a name="ln2034">  for(auto history = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.history&quot;)); history != xmpData.end(); history++)</a>
<a name="ln2035">  {</a>
<a name="ln2036">    // TODO: support human readable params via introspection with something like this:</a>
<a name="ln2037">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:name = width</a>
<a name="ln2038">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:value = 23</a>
<a name="ln2039"> </a>
<a name="ln2040">    char *key = g_strdup(history-&gt;key().c_str());</a>
<a name="ln2041">    char *key_iter = key;</a>
<a name="ln2042">    if(g_str_has_prefix(key, &quot;Xmp.darktable.history[&quot;))</a>
<a name="ln2043">    {</a>
<a name="ln2044">      key_iter += strlen(&quot;Xmp.darktable.history[&quot;);</a>
<a name="ln2045">      errno = 0;</a>
<a name="ln2046">      unsigned int n = strtol(key_iter, &amp;key_iter, 10);</a>
<a name="ln2047">      if(errno)</a>
<a name="ln2048">      {</a>
<a name="ln2049">        std::cerr &lt;&lt; &quot;error reading history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2050">        g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2051">        g_free(key);</a>
<a name="ln2052">        return NULL;</a>
<a name="ln2053">      }</a>
<a name="ln2054"> </a>
<a name="ln2055">      // skip everything that isn't part of the actual array</a>
<a name="ln2056">      if(*(key_iter++) != ']')</a>
<a name="ln2057">      {</a>
<a name="ln2058">        std::cerr &lt;&lt; &quot;error reading history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2059">        g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2060">        g_free(key);</a>
<a name="ln2061">        return NULL;</a>
<a name="ln2062">      }</a>
<a name="ln2063">      if(*(key_iter++) != '/') goto skip;</a>
<a name="ln2064">      if(*key_iter == '?') key_iter++;</a>
<a name="ln2065"> </a>
<a name="ln2066">      // make sure we are filling in the details of the correct entry</a>
<a name="ln2067">      unsigned int length = g_list_length(history_entries);</a>
<a name="ln2068">      if(n &gt; length)</a>
<a name="ln2069">      {</a>
<a name="ln2070">        current_entry = (history_entry_t *)calloc(1, sizeof(history_entry_t));</a>
<a name="ln2071">        current_entry-&gt;blendop_version = 1; // default version in case it's not specified</a>
<a name="ln2072">        current_entry-&gt;iop_order = -1.0;</a>
<a name="ln2073">        history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln2074">      }</a>
<a name="ln2075">      else if(n &lt; length)</a>
<a name="ln2076">      {</a>
<a name="ln2077">        // AFAICT this can't happen with regular exiv2 parsed XMP data, but better safe than sorry.</a>
<a name="ln2078">        // it can happen though when constructing things in a unusual order and then passing it to us without</a>
<a name="ln2079">        // serializing it in between</a>
<a name="ln2080">        current_entry = (history_entry_t *)g_list_nth_data(history_entries, n - 1); // XMP starts counting at 1!</a>
<a name="ln2081">      }</a>
<a name="ln2082"> </a>
<a name="ln2083">      // go on reading things into current_entry</a>
<a name="ln2084">      if(g_str_has_prefix(key_iter, &quot;darktable:operation&quot;))</a>
<a name="ln2085">      {</a>
<a name="ln2086">        current_entry-&gt;have_operation = TRUE;</a>
<a name="ln2087">        current_entry-&gt;operation = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln2088">      }</a>
<a name="ln2089">      else if(g_str_has_prefix(key_iter, &quot;darktable:num&quot;))</a>
<a name="ln2090">      {</a>
<a name="ln2091">        current_entry-&gt;num = history-&gt;value().toLong();</a>
<a name="ln2092">      }</a>
<a name="ln2093">      else if(g_str_has_prefix(key_iter, &quot;darktable:enabled&quot;))</a>
<a name="ln2094">      {</a>
<a name="ln2095">        current_entry-&gt;enabled = history-&gt;value().toLong() == 1;</a>
<a name="ln2096">      }</a>
<a name="ln2097">      else if(g_str_has_prefix(key_iter, &quot;darktable:modversion&quot;))</a>
<a name="ln2098">      {</a>
<a name="ln2099">        current_entry-&gt;have_modversion = TRUE;</a>
<a name="ln2100">        current_entry-&gt;modversion = history-&gt;value().toLong();</a>
<a name="ln2101">      }</a>
<a name="ln2102">      else if(g_str_has_prefix(key_iter, &quot;darktable:params&quot;))</a>
<a name="ln2103">      {</a>
<a name="ln2104">        current_entry-&gt;have_params = TRUE;</a>
<a name="ln2105">        current_entry-&gt;params = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(),</a>
<a name="ln2106">                                                   &amp;current_entry-&gt;params_len);</a>
<a name="ln2107">      }</a>
<a name="ln2108">      else if(g_str_has_prefix(key_iter, &quot;darktable:multi_name&quot;))</a>
<a name="ln2109">      {</a>
<a name="ln2110">        current_entry-&gt;multi_name = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln2111">      }</a>
<a name="ln2112">      else if(g_str_has_prefix(key_iter, &quot;darktable:multi_priority&quot;))</a>
<a name="ln2113">      {</a>
<a name="ln2114">        current_entry-&gt;multi_priority = history-&gt;value().toLong();</a>
<a name="ln2115">      }</a>
<a name="ln2116">      else if(g_str_has_prefix(key_iter, &quot;darktable:iop_order&quot;))</a>
<a name="ln2117">      {</a>
<a name="ln2118">        // we ensure reading the iop_order as a high precision float</a>
<a name="ln2119">        string str = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln2120">        static const std::locale&amp; c_locale = std::locale(&quot;C&quot;);</a>
<a name="ln2121">        std::istringstream istring(str);</a>
<a name="ln2122">        istring.imbue(c_locale);</a>
<a name="ln2123">        istring &gt;&gt; current_entry-&gt;iop_order;</a>
<a name="ln2124">      }</a>
<a name="ln2125">      else if(g_str_has_prefix(key_iter, &quot;darktable:blendop_version&quot;))</a>
<a name="ln2126">      {</a>
<a name="ln2127">        current_entry-&gt;blendop_version = history-&gt;value().toLong();</a>
<a name="ln2128">      }</a>
<a name="ln2129">      else if(g_str_has_prefix(key_iter, &quot;darktable:blendop_params&quot;))</a>
<a name="ln2130">      {</a>
<a name="ln2131">        current_entry-&gt;blendop_params = dt_exif_xmp_decode(history-&gt;value().toString().c_str(),</a>
<a name="ln2132">                                                           history-&gt;value().size(),</a>
<a name="ln2133">                                                           &amp;current_entry-&gt;blendop_params_len);</a>
<a name="ln2134">      }</a>
<a name="ln2135">    }</a>
<a name="ln2136">skip:</a>
<a name="ln2137">    g_free(key);</a>
<a name="ln2138">  }</a>
<a name="ln2139"> </a>
<a name="ln2140">  // a final sanity check</a>
<a name="ln2141">  for(GList *iter = history_entries; iter; iter = g_list_next(iter))</a>
<a name="ln2142">  {</a>
<a name="ln2143">    history_entry_t *entry = (history_entry_t *)iter-&gt;data;</a>
<a name="ln2144">    if(!(entry-&gt;have_operation &amp;&amp; entry-&gt;have_params &amp;&amp; entry-&gt;have_modversion))</a>
<a name="ln2145">    {</a>
<a name="ln2146">      std::cerr &lt;&lt; &quot;[exif] error: reading history from '&quot; &lt;&lt; filename &lt;&lt; &quot;' failed due to missing tags&quot; &lt;&lt; std::endl;</a>
<a name="ln2147">      g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2148">      history_entries = NULL;</a>
<a name="ln2149">      break;</a>
<a name="ln2150">    }</a>
<a name="ln2151">  }</a>
<a name="ln2152"> </a>
<a name="ln2153">  return history_entries;</a>
<a name="ln2154">}</a>
<a name="ln2155"> </a>
<a name="ln2156">void free_mask_entry(gpointer data)</a>
<a name="ln2157">{</a>
<a name="ln2158">  mask_entry_t *entry = (mask_entry_t *)data;</a>
<a name="ln2159">  g_free(entry-&gt;mask_name);</a>
<a name="ln2160">  free(entry-&gt;mask_points);</a>
<a name="ln2161">  free(entry-&gt;mask_src);</a>
<a name="ln2162">  free(entry);</a>
<a name="ln2163">}</a>
<a name="ln2164"> </a>
<a name="ln2165">static GHashTable *read_masks(Exiv2::XmpData &amp;xmpData, const char *filename, const int version)</a>
<a name="ln2166">{</a>
<a name="ln2167">  GHashTable *mask_entries = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, free_mask_entry);</a>
<a name="ln2168"> </a>
<a name="ln2169">  // TODO: turn that into something like Xmp.darktable.history!</a>
<a name="ln2170">  Exiv2::XmpData::iterator mask;</a>
<a name="ln2171">  Exiv2::XmpData::iterator mask_name;</a>
<a name="ln2172">  Exiv2::XmpData::iterator mask_type;</a>
<a name="ln2173">  Exiv2::XmpData::iterator mask_version;</a>
<a name="ln2174">  Exiv2::XmpData::iterator mask_id;</a>
<a name="ln2175">  Exiv2::XmpData::iterator mask_nb;</a>
<a name="ln2176">  Exiv2::XmpData::iterator mask_src;</a>
<a name="ln2177">  if((mask = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask&quot;))) != xmpData.end()</a>
<a name="ln2178">    &amp;&amp; (mask_src = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_src&quot;))) != xmpData.end()</a>
<a name="ln2179">    &amp;&amp; (mask_name = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_name&quot;))) != xmpData.end()</a>
<a name="ln2180">    &amp;&amp; (mask_type = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_type&quot;))) != xmpData.end()</a>
<a name="ln2181">    &amp;&amp; (mask_version = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_version&quot;))) != xmpData.end()</a>
<a name="ln2182">    &amp;&amp; (mask_id = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_id&quot;))) != xmpData.end()</a>
<a name="ln2183">    &amp;&amp; (mask_nb = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.mask_nb&quot;))) != xmpData.end())</a>
<a name="ln2184">  {</a>
<a name="ln2185">    // fixes API change happened after exiv2 v0.27.2.1</a>
<a name="ln2186">    const size_t cnt = (size_t)mask-&gt;count();</a>
<a name="ln2187">    const size_t mask_src_cnt = (size_t)mask_src-&gt;count();</a>
<a name="ln2188">    const size_t mask_name_cnt = (size_t)mask_name-&gt;count();</a>
<a name="ln2189">    const size_t mask_type_cnt = (size_t)mask_type-&gt;count();</a>
<a name="ln2190">    const size_t mask_version_cnt = (size_t)mask_version-&gt;count();</a>
<a name="ln2191">    const size_t mask_id_cnt = (size_t)mask_id-&gt;count();</a>
<a name="ln2192">    const size_t mask_nb_cnt = (size_t)mask_nb-&gt;count();</a>
<a name="ln2193">    if(cnt == mask_src_cnt &amp;&amp; cnt == mask_name_cnt &amp;&amp; cnt == mask_type_cnt</a>
<a name="ln2194">       &amp;&amp; cnt == mask_version_cnt &amp;&amp; cnt == mask_id_cnt &amp;&amp; cnt == mask_nb_cnt)</a>
<a name="ln2195">    {</a>
<a name="ln2196">      for(size_t i = 0; i &lt; cnt; i++)</a>
<a name="ln2197">      {</a>
<a name="ln2198">        mask_entry_t *entry = (mask_entry_t *)calloc(1, sizeof(mask_entry_t));</a>
<a name="ln2199"> </a>
<a name="ln2200">        entry-&gt;version = version;</a>
<a name="ln2201">        entry-&gt;mask_id = mask_id-&gt;toLong(i);</a>
<a name="ln2202">        entry-&gt;mask_type = mask_type-&gt;toLong(i);</a>
<a name="ln2203">        std::string mask_name_str = mask_name-&gt;toString(i);</a>
<a name="ln2204">        if(mask_name_str.c_str() != NULL)</a>
<a name="ln2205">          entry-&gt;mask_name = g_strdup(mask_name_str.c_str());</a>
<a name="ln2206">        else</a>
<a name="ln2207">          entry-&gt;mask_name = g_strdup(&quot;form&quot;);</a>
<a name="ln2208"> </a>
<a name="ln2209">        entry-&gt;mask_version = mask_version-&gt;toLong(i);</a>
<a name="ln2210"> </a>
<a name="ln2211">        std::string mask_str = mask-&gt;toString(i);</a>
<a name="ln2212">        const char *mask_c = mask_str.c_str();</a>
<a name="ln2213">        const size_t mask_c_len = strlen(mask_c);</a>
<a name="ln2214">        entry-&gt;mask_points = dt_exif_xmp_decode(mask_c, mask_c_len, &amp;entry-&gt;mask_points_len);</a>
<a name="ln2215"> </a>
<a name="ln2216">        entry-&gt;mask_nb = mask_nb-&gt;toLong(i);</a>
<a name="ln2217"> </a>
<a name="ln2218">        std::string mask_src_str = mask_src-&gt;toString(i);</a>
<a name="ln2219">        const char *mask_src_c = mask_src_str.c_str();</a>
<a name="ln2220">        const size_t mask_src_c_len = strlen(mask_src_c);</a>
<a name="ln2221">        entry-&gt;mask_src = dt_exif_xmp_decode(mask_src_c, mask_src_c_len, &amp;entry-&gt;mask_src_len);</a>
<a name="ln2222"> </a>
<a name="ln2223">        g_hash_table_insert(mask_entries, &amp;entry-&gt;mask_id, (gpointer)entry);</a>
<a name="ln2224">      }</a>
<a name="ln2225">    }</a>
<a name="ln2226">  }</a>
<a name="ln2227"> </a>
<a name="ln2228">  return mask_entries;</a>
<a name="ln2229">}</a>
<a name="ln2230"> </a>
<a name="ln2231">static GList *read_masks_v3(Exiv2::XmpData &amp;xmpData, const char *filename, const int version)</a>
<a name="ln2232">{</a>
<a name="ln2233">  GList *history_entries = NULL;</a>
<a name="ln2234">  mask_entry_t *current_entry = NULL;</a>
<a name="ln2235"> </a>
<a name="ln2236">  for(auto history = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.masks_history&quot;)); history != xmpData.end(); history++)</a>
<a name="ln2237">  {</a>
<a name="ln2238">    // TODO: support human readable params via introspection with something like this:</a>
<a name="ln2239">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:name = width</a>
<a name="ln2240">    // XmpText: Xmp.darktable.history[1]/darktable:settings[1]/darktable:value = 23</a>
<a name="ln2241"> </a>
<a name="ln2242">    char *key = g_strdup(history-&gt;key().c_str());</a>
<a name="ln2243">    char *key_iter = key;</a>
<a name="ln2244">    if(g_str_has_prefix(key, &quot;Xmp.darktable.masks_history[&quot;))</a>
<a name="ln2245">    {</a>
<a name="ln2246">      key_iter += strlen(&quot;Xmp.darktable.masks_history[&quot;);</a>
<a name="ln2247">      errno = 0;</a>
<a name="ln2248">      unsigned int n = strtol(key_iter, &amp;key_iter, 10);</a>
<a name="ln2249">      if(errno)</a>
<a name="ln2250">      {</a>
<a name="ln2251">        std::cerr &lt;&lt; &quot;error reading masks history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2252">        g_list_free_full(history_entries, free_mask_entry);</a>
<a name="ln2253">        g_free(key);</a>
<a name="ln2254">        return NULL;</a>
<a name="ln2255">      }</a>
<a name="ln2256"> </a>
<a name="ln2257">      // skip everything that isn't part of the actual array</a>
<a name="ln2258">      if(*(key_iter++) != ']')</a>
<a name="ln2259">      {</a>
<a name="ln2260">        std::cerr &lt;&lt; &quot;error reading masks history from '&quot; &lt;&lt; key &lt;&lt; &quot;' (&quot; &lt;&lt; filename &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</a>
<a name="ln2261">        g_list_free_full(history_entries, free_mask_entry);</a>
<a name="ln2262">        g_free(key);</a>
<a name="ln2263">        return NULL;</a>
<a name="ln2264">      }</a>
<a name="ln2265">      if(*(key_iter++) != '/') goto skip;</a>
<a name="ln2266">      if(*key_iter == '?') key_iter++;</a>
<a name="ln2267"> </a>
<a name="ln2268">      // make sure we are filling in the details of the correct entry</a>
<a name="ln2269">      unsigned int length = g_list_length(history_entries);</a>
<a name="ln2270">      if(n &gt; length)</a>
<a name="ln2271">      {</a>
<a name="ln2272">        current_entry = (mask_entry_t *)calloc(1, sizeof(mask_entry_t));</a>
<a name="ln2273">        current_entry-&gt;version = version;</a>
<a name="ln2274">        history_entries = g_list_append(history_entries, current_entry);</a>
<a name="ln2275">      }</a>
<a name="ln2276">      else if(n &lt; length)</a>
<a name="ln2277">      {</a>
<a name="ln2278">        // AFAICT this can't happen with regular exiv2 parsed XMP data, but better safe than sorry.</a>
<a name="ln2279">        // it can happen though when constructing things in a unusual order and then passing it to us without</a>
<a name="ln2280">        // serializing it in between</a>
<a name="ln2281">        current_entry = (mask_entry_t *)g_list_nth_data(history_entries, n - 1); // XMP starts counting at 1!</a>
<a name="ln2282">      }</a>
<a name="ln2283"> </a>
<a name="ln2284">      // go on reading things into current_entry</a>
<a name="ln2285">      if(g_str_has_prefix(key_iter, &quot;darktable:mask_num&quot;))</a>
<a name="ln2286">      {</a>
<a name="ln2287">        current_entry-&gt;mask_num = history-&gt;value().toLong();</a>
<a name="ln2288">      }</a>
<a name="ln2289">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_id&quot;))</a>
<a name="ln2290">      {</a>
<a name="ln2291">        current_entry-&gt;mask_id = history-&gt;value().toLong();</a>
<a name="ln2292">      }</a>
<a name="ln2293">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_type&quot;))</a>
<a name="ln2294">      {</a>
<a name="ln2295">        current_entry-&gt;mask_type = history-&gt;value().toLong();</a>
<a name="ln2296">      }</a>
<a name="ln2297">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_name&quot;))</a>
<a name="ln2298">      {</a>
<a name="ln2299">        current_entry-&gt;mask_name = g_strdup(history-&gt;value().toString().c_str());</a>
<a name="ln2300">      }</a>
<a name="ln2301">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_version&quot;))</a>
<a name="ln2302">      {</a>
<a name="ln2303">        current_entry-&gt;mask_version = history-&gt;value().toLong();</a>
<a name="ln2304">      }</a>
<a name="ln2305">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_points&quot;))</a>
<a name="ln2306">      {</a>
<a name="ln2307">        current_entry-&gt;mask_points = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(), &amp;current_entry-&gt;mask_points_len);</a>
<a name="ln2308">      }</a>
<a name="ln2309">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_nb&quot;))</a>
<a name="ln2310">      {</a>
<a name="ln2311">        current_entry-&gt;mask_nb = history-&gt;value().toLong();</a>
<a name="ln2312">      }</a>
<a name="ln2313">      else if(g_str_has_prefix(key_iter, &quot;darktable:mask_src&quot;))</a>
<a name="ln2314">      {</a>
<a name="ln2315">        current_entry-&gt;mask_src = dt_exif_xmp_decode(history-&gt;value().toString().c_str(), history-&gt;value().size(), &amp;current_entry-&gt;mask_src_len);</a>
<a name="ln2316">      }</a>
<a name="ln2317"> </a>
<a name="ln2318">    }</a>
<a name="ln2319">skip:</a>
<a name="ln2320">    g_free(key);</a>
<a name="ln2321">  }</a>
<a name="ln2322"> </a>
<a name="ln2323">  return history_entries;</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326">static void add_mask_entry_to_db(int imgid, mask_entry_t *entry)</a>
<a name="ln2327">{</a>
<a name="ln2328">  // add the mask entry only once</a>
<a name="ln2329">  if(entry-&gt;already_added)</a>
<a name="ln2330">    return;</a>
<a name="ln2331">  entry-&gt;already_added = TRUE;</a>
<a name="ln2332"> </a>
<a name="ln2333">  const int mask_num = 0;</a>
<a name="ln2334"> </a>
<a name="ln2335">  sqlite3_stmt *stmt;</a>
<a name="ln2336">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2337">    dt_database_get(darktable.db),</a>
<a name="ln2338">                              &quot;INSERT INTO main.masks_history (imgid, num, formid, form, name, version, points, points_count, source) &quot;</a>
<a name="ln2339">                              &quot;VALUES (?1, ?9, ?2, ?3, ?4, ?5, ?6, ?7, ?8)&quot;,</a>
<a name="ln2340">                              -1, &amp;stmt, NULL);</a>
<a name="ln2341">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2342">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, entry-&gt;mask_id);</a>
<a name="ln2343">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, entry-&gt;mask_type);</a>
<a name="ln2344">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, entry-&gt;mask_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2345">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 5, entry-&gt;mask_version);</a>
<a name="ln2346">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 6, entry-&gt;mask_points, entry-&gt;mask_points_len, SQLITE_TRANSIENT);</a>
<a name="ln2347">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 7, entry-&gt;mask_nb);</a>
<a name="ln2348">  DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 8, entry-&gt;mask_src, entry-&gt;mask_src_len, SQLITE_TRANSIENT);</a>
<a name="ln2349">  if(entry-&gt;version &lt; 3)</a>
<a name="ln2350">  {</a>
<a name="ln2351">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, mask_num);</a>
<a name="ln2352">  }</a>
<a name="ln2353">  else</a>
<a name="ln2354">  {</a>
<a name="ln2355">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, entry-&gt;mask_num);</a>
<a name="ln2356">  }</a>
<a name="ln2357">  sqlite3_step(stmt);</a>
<a name="ln2358">  sqlite3_finalize(stmt);</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361">static void add_non_clone_mask_entries_to_db(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln2362">{</a>
<a name="ln2363">  int imgid = *(int *)user_data;</a>
<a name="ln2364">  mask_entry_t *entry = (mask_entry_t *)value;</a>
<a name="ln2365">  if(!(entry-&gt;mask_type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))) add_mask_entry_to_db(imgid, entry);</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">static void add_mask_entries_to_db(int imgid, GHashTable *mask_entries, int mask_id)</a>
<a name="ln2369">{</a>
<a name="ln2370">  if(mask_id &lt;= 0) return;</a>
<a name="ln2371"> </a>
<a name="ln2372">  // look for mask_id in the hash table</a>
<a name="ln2373">  mask_entry_t *entry = (mask_entry_t *)g_hash_table_lookup(mask_entries, &amp;mask_id);</a>
<a name="ln2374"> </a>
<a name="ln2375">  if(!entry) return;</a>
<a name="ln2376"> </a>
<a name="ln2377">  // if it's a group: recurse into the children first</a>
<a name="ln2378">  if(entry-&gt;mask_type &amp; DT_MASKS_GROUP)</a>
<a name="ln2379">  {</a>
<a name="ln2380">    dt_masks_point_group_t *group = (dt_masks_point_group_t *)entry-&gt;mask_points;</a>
<a name="ln2381">    if((int)(entry-&gt;mask_nb * sizeof(dt_masks_point_group_t)) != entry-&gt;mask_points_len)</a>
<a name="ln2382">    {</a>
<a name="ln2383">      fprintf(stderr, &quot;[masks] error loading masks from xmp file, bad binary blob size.\n&quot;);</a>
<a name="ln2384">      return;</a>
<a name="ln2385">    }</a>
<a name="ln2386">    for(int i = 0; i &lt; entry-&gt;mask_nb; i++)</a>
<a name="ln2387">      add_mask_entries_to_db(imgid, mask_entries, group[i].formid);</a>
<a name="ln2388">  }</a>
<a name="ln2389"> </a>
<a name="ln2390">  add_mask_entry_to_db(imgid, entry);</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">static int history_v1_to_v3(const int imgid)</a>
<a name="ln2394">{</a>
<a name="ln2395">  int all_ok = 1;</a>
<a name="ln2396">  sqlite3_stmt *stmt;</a>
<a name="ln2397">  sqlite3_stmt *sel_stmt;</a>
<a name="ln2398"> </a>
<a name="ln2399">  // get iop order up to this version</a>
<a name="ln2400">  int iop_order_version = 1;</a>
<a name="ln2401">  GList *iop_order_v1 = dt_ioppr_get_iop_order_list(&amp;iop_order_version);</a>
<a name="ln2402"> </a>
<a name="ln2403">  // set the iop_order version</a>
<a name="ln2404">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2405">                              &quot;UPDATE main.images SET iop_order_version = 1 WHERE id = ?1&quot;, -1,</a>
<a name="ln2406">                              &amp;stmt, NULL);</a>
<a name="ln2407">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2408"> </a>
<a name="ln2409">  if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2410">  {</a>
<a name="ln2411">    fprintf(stderr, &quot;[exif] error updating iop_order_version for image %d\n&quot;, imgid);</a>
<a name="ln2412">    fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2413">    all_ok = FALSE;</a>
<a name="ln2414">    sqlite3_finalize(stmt);</a>
<a name="ln2415">    goto end;</a>
<a name="ln2416">  }</a>
<a name="ln2417">  sqlite3_finalize(stmt);</a>
<a name="ln2418"> </a>
<a name="ln2419">  // create the order of the pipe</a>
<a name="ln2420">  // iop_order is by default the module priority</a>
<a name="ln2421">  // if there's multi-instances we add the multi_priority</a>
<a name="ln2422">  // multi_priority is in reverse order in this version,</a>
<a name="ln2423">  // so we assume that is always less than 1000 and reverse it</a>
<a name="ln2424">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2425">                              &quot;SELECT num, multi_priority, operation FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2426">                              &amp;sel_stmt, NULL);</a>
<a name="ln2427">  DT_DEBUG_SQLITE3_BIND_INT(sel_stmt, 1, imgid);</a>
<a name="ln2428">  while(sqlite3_step(sel_stmt) == SQLITE_ROW)</a>
<a name="ln2429">  {</a>
<a name="ln2430">    const int num = sqlite3_column_int(sel_stmt, 0);</a>
<a name="ln2431">    const int multi_priority = sqlite3_column_int(sel_stmt, 1);</a>
<a name="ln2432">    const char *op_name = (const char *)sqlite3_column_text(sel_stmt, 2);</a>
<a name="ln2433"> </a>
<a name="ln2434">    // search for the priority for this operation</a>
<a name="ln2435">    dt_iop_order_entry_t *prior_v1 = dt_ioppr_get_iop_order_entry(iop_order_v1, op_name);</a>
<a name="ln2436"> </a>
<a name="ln2437">    if(prior_v1)</a>
<a name="ln2438">    {</a>
<a name="ln2439">      int multi_priority_max = -1;</a>
<a name="ln2440">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2441">                                  &quot;SELECT MAX(multi_priority) FROM main.history WHERE imgid = ?1 AND operation = ?2&quot;, -1,</a>
<a name="ln2442">                                  &amp;stmt, NULL);</a>
<a name="ln2443">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2444">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, op_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2445">      if(sqlite3_step(stmt) == SQLITE_ROW) multi_priority_max = sqlite3_column_int(stmt, 0);</a>
<a name="ln2446">      sqlite3_finalize(stmt);</a>
<a name="ln2447">      if(multi_priority_max &gt;= 0)</a>
<a name="ln2448">      {</a>
<a name="ln2449">        const double iop_order = ((float)(multi_priority_max + 1 - multi_priority) / 1000.0) + prior_v1-&gt;iop_order;</a>
<a name="ln2450"> </a>
<a name="ln2451">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2452">                                    &quot;UPDATE main.history SET iop_order = ?2 WHERE imgid = ?1 AND num = ?3&quot;, -1,</a>
<a name="ln2453">                                    &amp;stmt, NULL);</a>
<a name="ln2454">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2455">        DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 2, iop_order);</a>
<a name="ln2456">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, num);</a>
<a name="ln2457"> </a>
<a name="ln2458">        if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2459">        {</a>
<a name="ln2460">          fprintf(stderr, &quot;[exif] error updating pipe order in history for image %d\n&quot;, imgid);</a>
<a name="ln2461">          fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2462">          all_ok = FALSE;</a>
<a name="ln2463">          sqlite3_finalize(stmt);</a>
<a name="ln2464">          sqlite3_finalize(sel_stmt);</a>
<a name="ln2465">          goto end;</a>
<a name="ln2466">        }</a>
<a name="ln2467">        sqlite3_finalize(stmt);</a>
<a name="ln2468">      }</a>
<a name="ln2469">      else</a>
<a name="ln2470">        fprintf(stderr, &quot;[exif] error reading max multi_priority on module %s for image %d\n&quot;, op_name, imgid);</a>
<a name="ln2471">    }</a>
<a name="ln2472">    else</a>
<a name="ln2473">      fprintf(stderr, &quot;[exif] can't find default priority on module %s for image %d\n&quot;, op_name, imgid);</a>
<a name="ln2474">  }</a>
<a name="ln2475">  sqlite3_finalize(sel_stmt);</a>
<a name="ln2476"> </a>
<a name="ln2477">end:</a>
<a name="ln2478">  g_list_free_full(iop_order_v1, free);</a>
<a name="ln2479"> </a>
<a name="ln2480">  return all_ok;</a>
<a name="ln2481">}</a>
<a name="ln2482"> </a>
<a name="ln2483">// need a write lock on *img (non-const) to write stars (and soon color labels).</a>
<a name="ln2484">int dt_exif_xmp_read(dt_image_t *img, const char *filename, const int history_only)</a>
<a name="ln2485">{</a>
<a name="ln2486">  // exclude pfm to avoid stupid errors on the console</a>
<a name="ln2487">  const char *c = filename + strlen(filename) - 4;</a>
<a name="ln2488">  if(c &gt;= filename &amp;&amp; !strcmp(c, &quot;.pfm&quot;)) return 1;</a>
<a name="ln2489">  try</a>
<a name="ln2490">  {</a>
<a name="ln2491">    // read xmp sidecar</a>
<a name="ln2492">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln2493">    assert(image.get() != 0);</a>
<a name="ln2494">    read_metadata_threadsafe(image);</a>
<a name="ln2495">    Exiv2::XmpData &amp;xmpData = image-&gt;xmpData();</a>
<a name="ln2496"> </a>
<a name="ln2497">    sqlite3_stmt *stmt;</a>
<a name="ln2498"> </a>
<a name="ln2499">    Exiv2::XmpData::iterator pos;</a>
<a name="ln2500"> </a>
<a name="ln2501">    int version = 0;</a>
<a name="ln2502">    int iop_order_version = 0;</a>
<a name="ln2503">    int num_masks = 0;</a>
<a name="ln2504">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.xmp_version&quot;))) != xmpData.end())</a>
<a name="ln2505">      version = pos-&gt;toLong();</a>
<a name="ln2506"> </a>
<a name="ln2507">    if(!history_only)</a>
<a name="ln2508">    {</a>
<a name="ln2509">      // otherwise we ignore title, description, ... from non-dt xmp files :(</a>
<a name="ln2510">      size_t ns_pos = image-&gt;xmpPacket().find(&quot;xmlns:darktable=\&quot;http://darktable.sf.net/\&quot;&quot;);</a>
<a name="ln2511">      bool is_a_dt_xmp = (ns_pos != std::string::npos);</a>
<a name="ln2512">      dt_exif_read_xmp_data(img, xmpData, is_a_dt_xmp ? version : -1, false);</a>
<a name="ln2513">    }</a>
<a name="ln2514"> </a>
<a name="ln2515"> </a>
<a name="ln2516">    // convert legacy flip bits (will not be written anymore, convert to flip history item here):</a>
<a name="ln2517">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.raw_params&quot;))) != xmpData.end())</a>
<a name="ln2518">    {</a>
<a name="ln2519">      union {</a>
<a name="ln2520">          int32_t in;</a>
<a name="ln2521">          dt_image_raw_parameters_t out;</a>
<a name="ln2522">      } raw_params;</a>
<a name="ln2523">      raw_params.in = pos-&gt;toLong();</a>
<a name="ln2524">      const int32_t user_flip = raw_params.out.user_flip;</a>
<a name="ln2525">      img-&gt;legacy_flip.user_flip = user_flip;</a>
<a name="ln2526">      img-&gt;legacy_flip.legacy = 0;</a>
<a name="ln2527">    }</a>
<a name="ln2528"> </a>
<a name="ln2529">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.auto_presets_applied&quot;))) != xmpData.end())</a>
<a name="ln2530">    {</a>
<a name="ln2531">      const int32_t i = pos-&gt;toLong();</a>
<a name="ln2532">      // set or clear bit in image struct</a>
<a name="ln2533">      if(i == 1) img-&gt;flags |= DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2534">      if(i == 0) img-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2535">      // in any case, this is no legacy image.</a>
<a name="ln2536">      img-&gt;flags |= DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln2537">    }</a>
<a name="ln2538">    else</a>
<a name="ln2539">    {</a>
<a name="ln2540">      // not found means 0 (old xmp)</a>
<a name="ln2541">      img-&gt;flags &amp;= ~DT_IMAGE_AUTO_PRESETS_APPLIED;</a>
<a name="ln2542">      // so we are legacy (thus have to clear the no-legacy flag)</a>
<a name="ln2543">      img-&gt;flags &amp;= ~DT_IMAGE_NO_LEGACY_PRESETS;</a>
<a name="ln2544">    }</a>
<a name="ln2545">    // when we are reading the xmp data it doesn't make sense to flag the image as removed</a>
<a name="ln2546">    img-&gt;flags &amp;= ~DT_IMAGE_REMOVE;</a>
<a name="ln2547"> </a>
<a name="ln2548">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.iop_order_version&quot;))) != xmpData.end())</a>
<a name="ln2549">    {</a>
<a name="ln2550">      iop_order_version = pos-&gt;toLong();</a>
<a name="ln2551">    }</a>
<a name="ln2552"> </a>
<a name="ln2553"> </a>
<a name="ln2554">    // masks</a>
<a name="ln2555">    GHashTable *mask_entries = NULL;</a>
<a name="ln2556">    GList *mask_entries_v3 = NULL;</a>
<a name="ln2557"> </a>
<a name="ln2558">    // clean all old masks for this image</a>
<a name="ln2559">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.masks_history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2560">                                &amp;stmt, NULL);</a>
<a name="ln2561">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2562">    sqlite3_step(stmt);</a>
<a name="ln2563">    sqlite3_finalize(stmt);</a>
<a name="ln2564"> </a>
<a name="ln2565">    // read the masks from the file first so we can add them to the db while reading history entries</a>
<a name="ln2566">    if(version &lt; 3)</a>
<a name="ln2567">      mask_entries = read_masks(xmpData, filename, version);</a>
<a name="ln2568">    else</a>
<a name="ln2569">      mask_entries_v3 = read_masks_v3(xmpData, filename, version);</a>
<a name="ln2570"> </a>
<a name="ln2571">    // now add all masks that are not used for cloning. keeping them might be useful.</a>
<a name="ln2572">    // TODO: make this configurable? or remove it altogether?</a>
<a name="ln2573">    sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2574">    if(version &lt; 3)</a>
<a name="ln2575">    {</a>
<a name="ln2576">      g_hash_table_foreach(mask_entries, add_non_clone_mask_entries_to_db, &amp;img-&gt;id);</a>
<a name="ln2577">    }</a>
<a name="ln2578">    else</a>
<a name="ln2579">    {</a>
<a name="ln2580">      GList *m_entries = g_list_first(mask_entries_v3);</a>
<a name="ln2581">      while(m_entries)</a>
<a name="ln2582">      {</a>
<a name="ln2583">        mask_entry_t *mask_entry = (mask_entry_t *)m_entries-&gt;data;</a>
<a name="ln2584"> </a>
<a name="ln2585">        add_mask_entry_to_db(img-&gt;id, mask_entry);</a>
<a name="ln2586"> </a>
<a name="ln2587">        m_entries = g_list_next(m_entries);</a>
<a name="ln2588">      }</a>
<a name="ln2589">    }</a>
<a name="ln2590">    sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln2591"> </a>
<a name="ln2592">    // history</a>
<a name="ln2593">    int num = 0;</a>
<a name="ln2594">    gboolean all_ok = TRUE;</a>
<a name="ln2595">    GList *history_entries = NULL;</a>
<a name="ln2596"> </a>
<a name="ln2597">    if(version &lt; 2)</a>
<a name="ln2598">    {</a>
<a name="ln2599">      std::string &amp;xmpPacket = image-&gt;xmpPacket();</a>
<a name="ln2600">      history_entries = read_history_v1(xmpPacket, filename, 0);</a>
<a name="ln2601">      if(!history_entries) // didn't work? try super old version with rdf:Bag</a>
<a name="ln2602">        history_entries = read_history_v1(xmpPacket, filename, 1);</a>
<a name="ln2603">    }</a>
<a name="ln2604">    else if(version == 2 || version == 3)</a>
<a name="ln2605">      history_entries = read_history_v2(xmpData, filename);</a>
<a name="ln2606">    else</a>
<a name="ln2607">    {</a>
<a name="ln2608">      std::cerr &lt;&lt; &quot;error: Xmp schema version &quot; &lt;&lt; version &lt;&lt; &quot; in &quot; &lt;&lt; filename &lt;&lt; &quot; not supported&quot; &lt;&lt; std::endl;</a>
<a name="ln2609">      g_hash_table_destroy(mask_entries);</a>
<a name="ln2610">      return 1;</a>
<a name="ln2611">    }</a>
<a name="ln2612"> </a>
<a name="ln2613">    sqlite3_exec(dt_database_get(darktable.db), &quot;BEGIN TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2614"> </a>
<a name="ln2615">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2616">                                &amp;stmt, NULL);</a>
<a name="ln2617">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2618">    if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2619">    {</a>
<a name="ln2620">      fprintf(stderr, &quot;[exif] error deleting history for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2621">      fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2622">      all_ok = FALSE;</a>
<a name="ln2623">      goto end;</a>
<a name="ln2624">    }</a>
<a name="ln2625">    sqlite3_finalize(stmt);</a>
<a name="ln2626"> </a>
<a name="ln2627">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2628">                                &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln2629">                                &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln2630">                                &quot;VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln2631"> </a>
<a name="ln2632">    for(GList *iter = history_entries; iter; iter = g_list_next(iter))</a>
<a name="ln2633">    {</a>
<a name="ln2634">      history_entry_t *entry = (history_entry_t *)iter-&gt;data;</a>
<a name="ln2635">//       print_history_entry(entry);</a>
<a name="ln2636"> </a>
<a name="ln2637">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2638">      if(version &lt; 3)</a>
<a name="ln2639">      {</a>
<a name="ln2640">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, num);</a>
<a name="ln2641">      }</a>
<a name="ln2642">      else</a>
<a name="ln2643">      {</a>
<a name="ln2644">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, entry-&gt;num);</a>
<a name="ln2645">      }</a>
<a name="ln2646">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 3, entry-&gt;modversion);</a>
<a name="ln2647">      DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 4, entry-&gt;operation, -1, SQLITE_TRANSIENT);</a>
<a name="ln2648">      DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 5, entry-&gt;params, entry-&gt;params_len, SQLITE_TRANSIENT);</a>
<a name="ln2649">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 6, entry-&gt;enabled);</a>
<a name="ln2650">      if(entry-&gt;blendop_params)</a>
<a name="ln2651">      {</a>
<a name="ln2652">        DT_DEBUG_SQLITE3_BIND_BLOB(stmt, 7, entry-&gt;blendop_params, entry-&gt;blendop_params_len, SQLITE_TRANSIENT);</a>
<a name="ln2653"> </a>
<a name="ln2654">        if(version &lt; 3)</a>
<a name="ln2655">        {</a>
<a name="ln2656">          // check what mask entries belong to this iop and add them to the db</a>
<a name="ln2657">          const dt_develop_blend_params_t *blendop_params = (dt_develop_blend_params_t *)entry-&gt;blendop_params;</a>
<a name="ln2658">          add_mask_entries_to_db(img-&gt;id, mask_entries, blendop_params-&gt;mask_id);</a>
<a name="ln2659">        }</a>
<a name="ln2660">      }</a>
<a name="ln2661">      else</a>
<a name="ln2662">      {</a>
<a name="ln2663">        sqlite3_bind_null(stmt, 7);</a>
<a name="ln2664">      }</a>
<a name="ln2665">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 8, entry-&gt;blendop_version);</a>
<a name="ln2666">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 9, entry-&gt;multi_priority);</a>
<a name="ln2667">      if(entry-&gt;multi_name)</a>
<a name="ln2668">      {</a>
<a name="ln2669">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, entry-&gt;multi_name, -1, SQLITE_TRANSIENT);</a>
<a name="ln2670">      }</a>
<a name="ln2671">      else</a>
<a name="ln2672">      {</a>
<a name="ln2673">        DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 10, &quot;&quot;, -1, SQLITE_TRANSIENT); // &quot;&quot; instead of &quot; &quot; should be fine now</a>
<a name="ln2674">      }</a>
<a name="ln2675">      DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 11, entry-&gt;iop_order);</a>
<a name="ln2676"> </a>
<a name="ln2677">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2678">      {</a>
<a name="ln2679">        fprintf(stderr, &quot;[exif] error adding history entry for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2680">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2681">        all_ok = FALSE;</a>
<a name="ln2682">        goto end;</a>
<a name="ln2683">      }</a>
<a name="ln2684">      sqlite3_reset(stmt);</a>
<a name="ln2685">      sqlite3_clear_bindings(stmt);</a>
<a name="ln2686"> </a>
<a name="ln2687">      num++;</a>
<a name="ln2688">    }</a>
<a name="ln2689">    sqlite3_finalize(stmt);</a>
<a name="ln2690"> </a>
<a name="ln2691">    // if masks have been readed create a mask manager entry in history</a>
<a name="ln2692">    if(version &lt; 3)</a>
<a name="ln2693">    {</a>
<a name="ln2694">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT COUNT(*) FROM main.masks_history WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2695">                                  &amp;stmt, NULL);</a>
<a name="ln2696">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2697">      if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2698">        num_masks = sqlite3_column_int(stmt, 0);</a>
<a name="ln2699">      sqlite3_finalize(stmt);</a>
<a name="ln2700"> </a>
<a name="ln2701">      if(num_masks &gt; 0)</a>
<a name="ln2702">      {</a>
<a name="ln2703">        // make room for mask_manager entry</a>
<a name="ln2704">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.history SET num = num + 1 WHERE imgid = ?1&quot;, -1,</a>
<a name="ln2705">                                    &amp;stmt, NULL);</a>
<a name="ln2706">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2707">        sqlite3_step(stmt);</a>
<a name="ln2708">        sqlite3_finalize(stmt);</a>
<a name="ln2709"> </a>
<a name="ln2710">        // insert mask_manager entry</a>
<a name="ln2711">        int iop_order_version1 = 1;</a>
<a name="ln2712">        GList *iop_order_list = dt_ioppr_get_iop_order_list(&amp;iop_order_version1);</a>
<a name="ln2713">        const float iop_order_mask_manager = dt_ioppr_get_iop_order(iop_order_list, &quot;mask_manager&quot;);</a>
<a name="ln2714">        g_list_free_full(iop_order_list, free);</a>
<a name="ln2715"> </a>
<a name="ln2716">        DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2717">                                    &quot;INSERT INTO main.history (imgid, num, module, operation, op_params, enabled, &quot;</a>
<a name="ln2718">                                    &quot;blendop_params, blendop_version, multi_priority, multi_name, iop_order) &quot;</a>
<a name="ln2719">                                    &quot;VALUES (?1, 0, 1, 'mask_manager', NULL, 0, NULL, 0, 0, '', ?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln2720">        DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2721">        DT_DEBUG_SQLITE3_BIND_DOUBLE(stmt, 2, iop_order_mask_manager);</a>
<a name="ln2722">        if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2723">        {</a>
<a name="ln2724">          fprintf(stderr, &quot;[exif] error adding mask history entry for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2725">          fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2726">          all_ok = FALSE;</a>
<a name="ln2727">          goto end;</a>
<a name="ln2728">        }</a>
<a name="ln2729">        sqlite3_finalize(stmt);</a>
<a name="ln2730"> </a>
<a name="ln2731">        num++;</a>
<a name="ln2732">      }</a>
<a name="ln2733">    }</a>
<a name="ln2734"> </a>
<a name="ln2735">    // we shouldn't change history_end when no history was read!</a>
<a name="ln2736">    if((pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.darktable.history_end&quot;))) != xmpData.end() &amp;&amp; num &gt; 0)</a>
<a name="ln2737">    {</a>
<a name="ln2738">      int history_end = MIN(pos-&gt;toLong(), num);</a>
<a name="ln2739">      if(num_masks &gt; 0) history_end++;</a>
<a name="ln2740">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2741">                                  &quot;UPDATE main.images SET history_end = ?1 WHERE id = ?2&quot;, -1,</a>
<a name="ln2742">                                  &amp;stmt, NULL);</a>
<a name="ln2743">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, history_end);</a>
<a name="ln2744">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, img-&gt;id);</a>
<a name="ln2745">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2746">      {</a>
<a name="ln2747">        fprintf(stderr, &quot;[exif] error writing history_end for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2748">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2749">        all_ok = FALSE;</a>
<a name="ln2750">        goto end;</a>
<a name="ln2751">      }</a>
<a name="ln2752">    }</a>
<a name="ln2753">    else</a>
<a name="ln2754">    {</a>
<a name="ln2755">      DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2756">                                  &quot;UPDATE main.images SET history_end = (SELECT IFNULL(MAX(num) + 1, 0) &quot;</a>
<a name="ln2757">                                  &quot;FROM main.history WHERE imgid = ?1) WHERE id = ?1&quot;, -1,</a>
<a name="ln2758">                                  &amp;stmt, NULL);</a>
<a name="ln2759">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, img-&gt;id);</a>
<a name="ln2760">      if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2761">      {</a>
<a name="ln2762">        fprintf(stderr, &quot;[exif] error writing history_end for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2763">        fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2764">        all_ok = FALSE;</a>
<a name="ln2765">        goto end;</a>
<a name="ln2766">      }</a>
<a name="ln2767">    }</a>
<a name="ln2768"> </a>
<a name="ln2769">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln2770">                                &quot;UPDATE main.images SET iop_order_version = ?1 WHERE id = ?2&quot;, -1,</a>
<a name="ln2771">                                &amp;stmt, NULL);</a>
<a name="ln2772">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, iop_order_version);</a>
<a name="ln2773">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, img-&gt;id);</a>
<a name="ln2774">    if(sqlite3_step(stmt) != SQLITE_DONE)</a>
<a name="ln2775">    {</a>
<a name="ln2776">      fprintf(stderr, &quot;[exif] error writing iop_order_version for image %d\n&quot;, img-&gt;id);</a>
<a name="ln2777">      fprintf(stderr, &quot;[exif]   %s\n&quot;, sqlite3_errmsg(dt_database_get(darktable.db)));</a>
<a name="ln2778">      all_ok = FALSE;</a>
<a name="ln2779">      goto end;</a>
<a name="ln2780">    }</a>
<a name="ln2781"> </a>
<a name="ln2782">end:</a>
<a name="ln2783">    sqlite3_finalize(stmt);</a>
<a name="ln2784"> </a>
<a name="ln2785">    g_list_free_full(history_entries, free_history_entry);</a>
<a name="ln2786">    g_list_free_full(mask_entries_v3, free_mask_entry);</a>
<a name="ln2787">    if(mask_entries) g_hash_table_destroy(mask_entries);</a>
<a name="ln2788"> </a>
<a name="ln2789">    if(all_ok)</a>
<a name="ln2790">    {</a>
<a name="ln2791">      if(version &lt; 3)</a>
<a name="ln2792">      {</a>
<a name="ln2793">        all_ok = history_v1_to_v3(img-&gt;id);</a>
<a name="ln2794">      }</a>
<a name="ln2795">    }</a>
<a name="ln2796"> </a>
<a name="ln2797">    if(all_ok)</a>
<a name="ln2798">    {</a>
<a name="ln2799">      sqlite3_exec(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln2800">    }</a>
<a name="ln2801">    else</a>
<a name="ln2802">    {</a>
<a name="ln2803">      std::cerr &lt;&lt; &quot;[exif] error reading history from '&quot; &lt;&lt; filename &lt;&lt; &quot;'&quot; &lt;&lt; std::endl;</a>
<a name="ln2804">      sqlite3_exec(dt_database_get(darktable.db), &quot;ROLLBACK TRANSACTION&quot;, NULL, NULL, NULL);</a>
<a name="ln2805">      return 1;</a>
<a name="ln2806">    }</a>
<a name="ln2807"> </a>
<a name="ln2808">  }</a>
<a name="ln2809">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln2810">  {</a>
<a name="ln2811">    // actually nobody's interested in that if the file doesn't exist:</a>
<a name="ln2812">    // std::string s(e.what());</a>
<a name="ln2813">    // std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; filename &lt;&lt; &quot;: &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln2814">    return 1;</a>
<a name="ln2815">  }</a>
<a name="ln2816">  return 0;</a>
<a name="ln2817">}</a>
<a name="ln2818"> </a>
<a name="ln2819">// add history metadata to XmpData</a>
<a name="ln2820">static void dt_set_xmp_dt_history(Exiv2::XmpData &amp;xmpData, const int imgid, int history_end)</a>
<a name="ln2821">{</a>
<a name="ln2822">  sqlite3_stmt *stmt;</a>
<a name="ln2823"> </a>
<a name="ln2824">  // masks:</a>
<a name="ln2825">  char key[1024];</a>
<a name="ln2826">  int num = 1;</a>
<a name="ln2827"> </a>
<a name="ln2828">  // masks history:</a>
<a name="ln2829">  num = 1;</a>
<a name="ln2830"> </a>
<a name="ln2831">  // create an array:</a>
<a name="ln2832">  Exiv2::XmpTextValue tvm(&quot;&quot;);</a>
<a name="ln2833">  tvm.setXmpArrayType(Exiv2::XmpValue::xaSeq);</a>
<a name="ln2834">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.masks_history&quot;), &amp;tvm);</a>
<a name="ln2835"> </a>
<a name="ln2836">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2837">      dt_database_get(darktable.db),</a>
<a name="ln2838">      &quot;SELECT imgid, formid, form, name, version, points, points_count, source, num FROM main.masks_history WHERE imgid = ?1 ORDER BY num&quot;,</a>
<a name="ln2839">      -1, &amp;stmt, NULL);</a>
<a name="ln2840">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2841">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2842">  {</a>
<a name="ln2843">    const int32_t mask_num = sqlite3_column_int(stmt, 8);</a>
<a name="ln2844">    const int32_t mask_id = sqlite3_column_int(stmt, 1);</a>
<a name="ln2845">    const int32_t mask_type = sqlite3_column_int(stmt, 2);</a>
<a name="ln2846">    const char *mask_name = (const char *)sqlite3_column_text(stmt, 3);</a>
<a name="ln2847">    const int32_t mask_version = sqlite3_column_int(stmt, 4);</a>
<a name="ln2848">    int32_t len = sqlite3_column_bytes(stmt, 5);</a>
<a name="ln2849">    char *mask_d = dt_exif_xmp_encode((const unsigned char *)sqlite3_column_blob(stmt, 5), len, NULL);</a>
<a name="ln2850">    const int32_t mask_nb = sqlite3_column_int(stmt, 6);</a>
<a name="ln2851">    len = sqlite3_column_bytes(stmt, 7);</a>
<a name="ln2852">    char *mask_src = dt_exif_xmp_encode((const unsigned char *)sqlite3_column_blob(stmt, 7), len, NULL);</a>
<a name="ln2853"> </a>
<a name="ln2854">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_num&quot;, num);</a>
<a name="ln2855">    xmpData[key] = mask_num;</a>
<a name="ln2856">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_id&quot;, num);</a>
<a name="ln2857">    xmpData[key] = mask_id;</a>
<a name="ln2858">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_type&quot;, num);</a>
<a name="ln2859">    xmpData[key] = mask_type;</a>
<a name="ln2860">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_name&quot;, num);</a>
<a name="ln2861">    xmpData[key] = mask_name;</a>
<a name="ln2862">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_version&quot;, num);</a>
<a name="ln2863">    xmpData[key] = mask_version;</a>
<a name="ln2864">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_points&quot;, num);</a>
<a name="ln2865">    xmpData[key] = mask_d;</a>
<a name="ln2866">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_nb&quot;, num);</a>
<a name="ln2867">    xmpData[key] = mask_nb;</a>
<a name="ln2868">    snprintf(key, sizeof(key), &quot;Xmp.darktable.masks_history[%d]/darktable:mask_src&quot;, num);</a>
<a name="ln2869">    xmpData[key] = mask_src;</a>
<a name="ln2870"> </a>
<a name="ln2871">    free(mask_d);</a>
<a name="ln2872">    free(mask_src);</a>
<a name="ln2873"> </a>
<a name="ln2874">    num++;</a>
<a name="ln2875">  }</a>
<a name="ln2876">  sqlite3_finalize(stmt);</a>
<a name="ln2877"> </a>
<a name="ln2878">  // history stack:</a>
<a name="ln2879">  num = 1;</a>
<a name="ln2880"> </a>
<a name="ln2881">  // create an array:</a>
<a name="ln2882">  Exiv2::XmpTextValue tv(&quot;&quot;);</a>
<a name="ln2883">  tv.setXmpArrayType(Exiv2::XmpValue::xaSeq);</a>
<a name="ln2884">  xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.history&quot;), &amp;tv);</a>
<a name="ln2885"> </a>
<a name="ln2886">  DT_DEBUG_SQLITE3_PREPARE_V2(</a>
<a name="ln2887">      dt_database_get(darktable.db),</a>
<a name="ln2888">      &quot;SELECT module, operation, op_params, enabled, blendop_params, &quot;</a>
<a name="ln2889">      &quot;blendop_version, multi_priority, multi_name, num, iop_order FROM main.history WHERE imgid = ?1 ORDER BY num&quot;,</a>
<a name="ln2890">      -1, &amp;stmt, NULL);</a>
<a name="ln2891">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln2892">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln2893">  {</a>
<a name="ln2894">    int32_t modversion = sqlite3_column_int(stmt, 0);</a>
<a name="ln2895">    const char *operation = (const char *)sqlite3_column_text(stmt, 1);</a>
<a name="ln2896">    int32_t params_len = sqlite3_column_bytes(stmt, 2);</a>
<a name="ln2897">    const void *params_blob = sqlite3_column_blob(stmt, 2);</a>
<a name="ln2898">    int32_t enabled = sqlite3_column_int(stmt, 3);</a>
<a name="ln2899">    const void *blendop_blob = sqlite3_column_blob(stmt, 4);</a>
<a name="ln2900">    int32_t blendop_params_len = sqlite3_column_bytes(stmt, 4);</a>
<a name="ln2901">    int32_t blendop_version = sqlite3_column_int(stmt, 5);</a>
<a name="ln2902">    int32_t multi_priority = sqlite3_column_int(stmt, 6);</a>
<a name="ln2903">    const char *multi_name = (const char *)sqlite3_column_text(stmt, 7);</a>
<a name="ln2904">    int32_t hist_num = sqlite3_column_int(stmt, 8);</a>
<a name="ln2905">    double iop_order = sqlite3_column_double(stmt, 9);</a>
<a name="ln2906"> </a>
<a name="ln2907">    if(!operation) continue; // no op is fatal.</a>
<a name="ln2908"> </a>
<a name="ln2909">    char *params = dt_exif_xmp_encode((const unsigned char *)params_blob, params_len, NULL);</a>
<a name="ln2910"> </a>
<a name="ln2911">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:num&quot;, num);</a>
<a name="ln2912">    xmpData[key] = hist_num;</a>
<a name="ln2913">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:operation&quot;, num);</a>
<a name="ln2914">    xmpData[key] = operation;</a>
<a name="ln2915">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:enabled&quot;, num);</a>
<a name="ln2916">    xmpData[key] = enabled;</a>
<a name="ln2917">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:modversion&quot;, num);</a>
<a name="ln2918">    xmpData[key] = modversion;</a>
<a name="ln2919">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:params&quot;, num);</a>
<a name="ln2920">    xmpData[key] = params;</a>
<a name="ln2921">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:multi_name&quot;, num);</a>
<a name="ln2922">    xmpData[key] = multi_name ? multi_name : &quot;&quot;;</a>
<a name="ln2923">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:multi_priority&quot;, num);</a>
<a name="ln2924">    xmpData[key] = multi_priority;</a>
<a name="ln2925">    snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:iop_order&quot;, num);</a>
<a name="ln2926">    // we ensure writing the iop_order as a high precision float to avoid</a>
<a name="ln2927">    // as much as possible clashes.</a>
<a name="ln2928">    char *str = (char *)g_malloc(G_ASCII_DTOSTR_BUF_SIZE);</a>
<a name="ln2929">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%.13f&quot;, iop_order);</a>
<a name="ln2930">    xmpData[key] = str;</a>
<a name="ln2931">    g_free(str);</a>
<a name="ln2932"> </a>
<a name="ln2933">    if(blendop_blob)</a>
<a name="ln2934">    {</a>
<a name="ln2935">      // this shouldn't fail in general, but reading is robust enough to allow it,</a>
<a name="ln2936">      // and flipping images from LT will result in this being left out</a>
<a name="ln2937">      char *blendop_params = dt_exif_xmp_encode((const unsigned char *)blendop_blob, blendop_params_len, NULL);</a>
<a name="ln2938">      snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:blendop_version&quot;, num);</a>
<a name="ln2939">      xmpData[key] = blendop_version;</a>
<a name="ln2940">      snprintf(key, sizeof(key), &quot;Xmp.darktable.history[%d]/darktable:blendop_params&quot;, num);</a>
<a name="ln2941">      xmpData[key] = blendop_params;</a>
<a name="ln2942">      free(blendop_params);</a>
<a name="ln2943">    }</a>
<a name="ln2944"> </a>
<a name="ln2945">    free(params);</a>
<a name="ln2946"> </a>
<a name="ln2947">    num++;</a>
<a name="ln2948">  }</a>
<a name="ln2949"> </a>
<a name="ln2950">  sqlite3_finalize(stmt);</a>
<a name="ln2951">  if(history_end == -1) history_end = num - 1;</a>
<a name="ln2952">  else history_end = MIN(history_end, num - 1); // safeguard for some old buggy libraries</a>
<a name="ln2953">  xmpData[&quot;Xmp.darktable.history_end&quot;] = history_end;</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">static void dt_set_xmp_exif_geotag(Exiv2::XmpData &amp;xmpData, double longitude, double latitude, double altitude)</a>
<a name="ln2957">{</a>
<a name="ln2958">  if(!std::isnan(longitude) &amp;&amp; !std::isnan(latitude))</a>
<a name="ln2959">  {</a>
<a name="ln2960">    char long_dir = 'E', lat_dir = 'N';</a>
<a name="ln2961">    if(longitude &lt; 0) long_dir = 'W';</a>
<a name="ln2962">    if(latitude &lt; 0) lat_dir = 'S';</a>
<a name="ln2963"> </a>
<a name="ln2964">    longitude = fabs(longitude);</a>
<a name="ln2965">    latitude = fabs(latitude);</a>
<a name="ln2966"> </a>
<a name="ln2967">    int long_deg = (int)floor(longitude);</a>
<a name="ln2968">    int lat_deg = (int)floor(latitude);</a>
<a name="ln2969">    double long_min = (longitude - (double)long_deg) * 60.0;</a>
<a name="ln2970">    double lat_min = (latitude - (double)lat_deg) * 60.0;</a>
<a name="ln2971"> </a>
<a name="ln2972">    char *str = (char *)g_malloc(G_ASCII_DTOSTR_BUF_SIZE);</a>
<a name="ln2973"> </a>
<a name="ln2974">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%08f&quot;, long_min);</a>
<a name="ln2975">    gchar *long_str = g_strdup_printf(&quot;%d,%s%c&quot;, long_deg, str, long_dir);</a>
<a name="ln2976">    g_ascii_formatd(str, G_ASCII_DTOSTR_BUF_SIZE, &quot;%08f&quot;, lat_min);</a>
<a name="ln2977">    gchar *lat_str = g_strdup_printf(&quot;%d,%s%c&quot;, lat_deg, str, lat_dir);</a>
<a name="ln2978"> </a>
<a name="ln2979">    xmpData[&quot;Xmp.exif.GPSVersionID&quot;] = &quot;2.2.0.0&quot;;</a>
<a name="ln2980">    xmpData[&quot;Xmp.exif.GPSLongitude&quot;] = long_str;</a>
<a name="ln2981">    xmpData[&quot;Xmp.exif.GPSLatitude&quot;] = lat_str;</a>
<a name="ln2982">    g_free(long_str);</a>
<a name="ln2983">    g_free(lat_str);</a>
<a name="ln2984">    g_free(str);</a>
<a name="ln2985">  }</a>
<a name="ln2986">  if(!std::isnan(altitude))</a>
<a name="ln2987">  {</a>
<a name="ln2988">    xmpData[&quot;Xmp.exif.GPSAltitudeRef&quot;] = (altitude &lt; 0) ? &quot;1&quot; : &quot;0&quot;;</a>
<a name="ln2989"> </a>
<a name="ln2990">    long ele_dm = (int)floor(fabs(10.0 * altitude));</a>
<a name="ln2991">    gchar *ele_str = g_strdup_printf(&quot;%ld/10&quot;, ele_dm);</a>
<a name="ln2992">    xmpData[&quot;Xmp.exif.GPSAltitude&quot;] = ele_str;</a>
<a name="ln2993">    g_free(ele_str);</a>
<a name="ln2994">  }</a>
<a name="ln2995">}</a>
<a name="ln2996"> </a>
<a name="ln2997">static void dt_remove_xmp_exif_geotag(Exiv2::XmpData &amp;xmpData)</a>
<a name="ln2998">{</a>
<a name="ln2999">  static const char *keys[] =</a>
<a name="ln3000">  {</a>
<a name="ln3001">    &quot;Xmp.exif.GPSVersionID&quot;,</a>
<a name="ln3002">    &quot;Xmp.exif.GPSLongitude&quot;,</a>
<a name="ln3003">    &quot;Xmp.exif.GPSLatitude&quot;,</a>
<a name="ln3004">    &quot;Xmp.exif.GPSAltitudeRef&quot;,</a>
<a name="ln3005">    &quot;Xmp.exif.GPSAltitude&quot;</a>
<a name="ln3006">  };</a>
<a name="ln3007">  static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln3008">  dt_remove_xmp_keys(xmpData, keys, n_keys);</a>
<a name="ln3009">}</a>
<a name="ln3010"> </a>
<a name="ln3011">static void dt_remove_exif_geotag(Exiv2::ExifData &amp;exifData)</a>
<a name="ln3012">{</a>
<a name="ln3013">  static const char *keys[] =</a>
<a name="ln3014">  {</a>
<a name="ln3015">    &quot;Exif.GPSInfo.GPSLatitude&quot;,</a>
<a name="ln3016">    &quot;Exif.GPSInfo.GPSLongitude&quot;,</a>
<a name="ln3017">    &quot;Exif.GPSInfo.GPSAltitude&quot;,</a>
<a name="ln3018">    &quot;Exif.GPSInfo.GPSLatitudeRef&quot;,</a>
<a name="ln3019">    &quot;Exif.GPSInfo.GPSLongitudeRef&quot;,</a>
<a name="ln3020">    &quot;Exif.GPSInfo.GPSAltitudeRef&quot;,</a>
<a name="ln3021">    &quot;Exif.GPSInfo.GPSVersionID&quot;</a>
<a name="ln3022">  };</a>
<a name="ln3023">  static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln3024">  dt_remove_exif_keys(exifData, keys, n_keys);</a>
<a name="ln3025">}</a>
<a name="ln3026"> </a>
<a name="ln3027">static void dt_set_xmp_dt_metadata(Exiv2::XmpData &amp;xmpData, const int imgid)</a>
<a name="ln3028">{</a>
<a name="ln3029">  sqlite3_stmt *stmt;</a>
<a name="ln3030">  // metadata</a>
<a name="ln3031">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT key, value FROM main.meta_data WHERE id = ?1&quot;,</a>
<a name="ln3032">                              -1, &amp;stmt, NULL);</a>
<a name="ln3033">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln3034">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln3035">  {</a>
<a name="ln3036">    int key = sqlite3_column_int(stmt, 0);</a>
<a name="ln3037">    switch(key)</a>
<a name="ln3038">    {</a>
<a name="ln3039">      case DT_METADATA_XMP_DC_CREATOR:</a>
<a name="ln3040">        xmpData[&quot;Xmp.dc.creator&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln3041">        break;</a>
<a name="ln3042">      case DT_METADATA_XMP_DC_PUBLISHER:</a>
<a name="ln3043">        xmpData[&quot;Xmp.dc.publisher&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln3044">        break;</a>
<a name="ln3045">      case DT_METADATA_XMP_DC_TITLE:</a>
<a name="ln3046">        xmpData[&quot;Xmp.dc.title&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln3047">        break;</a>
<a name="ln3048">      case DT_METADATA_XMP_DC_DESCRIPTION:</a>
<a name="ln3049">        xmpData[&quot;Xmp.dc.description&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln3050">        break;</a>
<a name="ln3051">      case DT_METADATA_XMP_DC_RIGHTS:</a>
<a name="ln3052">        xmpData[&quot;Xmp.dc.rights&quot;] = sqlite3_column_text(stmt, 1);</a>
<a name="ln3053">        break;</a>
<a name="ln3054">    }</a>
<a name="ln3055">  }</a>
<a name="ln3056">  sqlite3_finalize(stmt);</a>
<a name="ln3057"> </a>
<a name="ln3058">  // color labels</a>
<a name="ln3059">  char val[2048];</a>
<a name="ln3060">  std::unique_ptr&lt;Exiv2::Value&gt; v(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln3061"> </a>
<a name="ln3062">  /* Already initialized v = Exiv2::Value::create(Exiv2::xmpSeq); // or xmpBag or xmpAlt.*/</a>
<a name="ln3063">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT color FROM main.color_labels WHERE imgid=?1&quot;,</a>
<a name="ln3064">                              -1, &amp;stmt, NULL);</a>
<a name="ln3065">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln3066">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln3067">  {</a>
<a name="ln3068">    snprintf(val, sizeof(val), &quot;%d&quot;, sqlite3_column_int(stmt, 0));</a>
<a name="ln3069">    v-&gt;read(val);</a>
<a name="ln3070">  }</a>
<a name="ln3071">  sqlite3_finalize(stmt);</a>
<a name="ln3072">  if(v-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.darktable.colorlabels&quot;), v.get());</a>
<a name="ln3073">}</a>
<a name="ln3074"> </a>
<a name="ln3075">// helper to create an xmp data thing. throws exiv2 exceptions if stuff goes wrong.</a>
<a name="ln3076">static void dt_exif_xmp_read_data(Exiv2::XmpData &amp;xmpData, const int imgid)</a>
<a name="ln3077">{</a>
<a name="ln3078">  const int xmp_version = 3;</a>
<a name="ln3079">  int stars = 1, raw_params = 0, history_end = -1;</a>
<a name="ln3080">  int iop_order_version = 0;</a>
<a name="ln3081">  double longitude = NAN, latitude = NAN, altitude = NAN;</a>
<a name="ln3082">  gchar *filename = NULL;</a>
<a name="ln3083">  gchar *datetime_taken = NULL;</a>
<a name="ln3084"> </a>
<a name="ln3085">  // get stars and raw params from db</a>
<a name="ln3086">  sqlite3_stmt *stmt;</a>
<a name="ln3087">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT filename, flags, raw_parameters, &quot;</a>
<a name="ln3088">                                                             &quot;longitude, latitude, altitude, history_end, iop_order_version, datetime_taken &quot;</a>
<a name="ln3089">                                                             &quot;FROM main.images WHERE id = ?1&quot;,</a>
<a name="ln3090">                              -1, &amp;stmt, NULL);</a>
<a name="ln3091">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln3092">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln3093">  {</a>
<a name="ln3094">    filename = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln3095">    stars = sqlite3_column_int(stmt, 1);</a>
<a name="ln3096">    raw_params = sqlite3_column_int(stmt, 2);</a>
<a name="ln3097">    if(sqlite3_column_type(stmt, 3) == SQLITE_FLOAT) longitude = sqlite3_column_double(stmt, 3);</a>
<a name="ln3098">    if(sqlite3_column_type(stmt, 4) == SQLITE_FLOAT) latitude = sqlite3_column_double(stmt, 4);</a>
<a name="ln3099">    if(sqlite3_column_type(stmt, 5) == SQLITE_FLOAT) altitude = sqlite3_column_double(stmt, 5);</a>
<a name="ln3100">    history_end = sqlite3_column_int(stmt, 6);</a>
<a name="ln3101">    iop_order_version = sqlite3_column_int(stmt, 7);</a>
<a name="ln3102">    datetime_taken = (gchar *)sqlite3_column_text(stmt, 8);</a>
<a name="ln3103">  }</a>
<a name="ln3104"> </a>
<a name="ln3105">  // Store datetime_taken as DateTimeOriginal to take into account the user's selected date/time</a>
<a name="ln3106">  xmpData[&quot;Xmp.exif.DateTimeOriginal&quot;] = datetime_taken;</a>
<a name="ln3107"> </a>
<a name="ln3108">  // We have to erase the old ratings first as exiv2 seems to not change it otherwise.</a>
<a name="ln3109">  Exiv2::XmpData::iterator pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.xmp.Rating&quot;));</a>
<a name="ln3110">  if(pos != xmpData.end()) xmpData.erase(pos);</a>
<a name="ln3111">  xmpData[&quot;Xmp.xmp.Rating&quot;] = ((stars &amp; 0x7) == 6) ? -1 : (stars &amp; 0x7); // rejected image = -1, others = 0..5</a>
<a name="ln3112"> </a>
<a name="ln3113">  // The original file name</a>
<a name="ln3114">  if(filename) xmpData[&quot;Xmp.xmpMM.DerivedFrom&quot;] = filename;</a>
<a name="ln3115"> </a>
<a name="ln3116">  // GPS data</a>
<a name="ln3117">  dt_set_xmp_exif_geotag(xmpData, longitude, latitude, altitude);</a>
<a name="ln3118">  sqlite3_finalize(stmt);</a>
<a name="ln3119"> </a>
<a name="ln3120">  // the meta data</a>
<a name="ln3121">  dt_set_xmp_dt_metadata(xmpData, imgid);</a>
<a name="ln3122"> </a>
<a name="ln3123">  // get tags from db, store in dublin core</a>
<a name="ln3124">  std::unique_ptr&lt;Exiv2::Value&gt; v1(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln3125"> </a>
<a name="ln3126">  std::unique_ptr&lt;Exiv2::Value&gt; v2(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln3127"> </a>
<a name="ln3128">  GList *tags = dt_tag_get_list(imgid);</a>
<a name="ln3129">  while(tags)</a>
<a name="ln3130">  {</a>
<a name="ln3131">    v1-&gt;read((char *)tags-&gt;data);</a>
<a name="ln3132">    tags = g_list_next(tags);</a>
<a name="ln3133">  }</a>
<a name="ln3134">  if(v1-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.dc.subject&quot;), v1.get());</a>
<a name="ln3135">  g_list_free_full(tags, g_free);</a>
<a name="ln3136"> </a>
<a name="ln3137">  GList *hierarchical = dt_tag_get_hierarchical(imgid);</a>
<a name="ln3138">  while(hierarchical)</a>
<a name="ln3139">  {</a>
<a name="ln3140">    v2-&gt;read((char *)hierarchical-&gt;data);</a>
<a name="ln3141">    hierarchical = g_list_next(hierarchical);</a>
<a name="ln3142">  }</a>
<a name="ln3143">  if(v2-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.lr.hierarchicalSubject&quot;), v2.get());</a>
<a name="ln3144">  g_list_free_full(hierarchical, g_free);</a>
<a name="ln3145">  /* TODO: Add tags to IPTC namespace as well */</a>
<a name="ln3146"> </a>
<a name="ln3147">  xmpData[&quot;Xmp.darktable.xmp_version&quot;] = xmp_version;</a>
<a name="ln3148">  xmpData[&quot;Xmp.darktable.raw_params&quot;] = raw_params;</a>
<a name="ln3149">  if(stars &amp; DT_IMAGE_AUTO_PRESETS_APPLIED)</a>
<a name="ln3150">    xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 1;</a>
<a name="ln3151">  else</a>
<a name="ln3152">    xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 0;</a>
<a name="ln3153">  dt_set_xmp_dt_history(xmpData, imgid, history_end);</a>
<a name="ln3154">  xmpData[&quot;Xmp.darktable.iop_order_version&quot;] = iop_order_version;</a>
<a name="ln3155">}</a>
<a name="ln3156"> </a>
<a name="ln3157">// helper to create an xmp data thing. throws exiv2 exceptions if stuff goes wrong.</a>
<a name="ln3158">static void dt_exif_xmp_read_data_export(Exiv2::XmpData &amp;xmpData, const int imgid, dt_export_metadata_t *metadata)</a>
<a name="ln3159">{</a>
<a name="ln3160">  const int xmp_version = 3;</a>
<a name="ln3161">  int stars = 1, raw_params = 0, history_end = -1;</a>
<a name="ln3162">  int iop_order_version = 0;</a>
<a name="ln3163">  double longitude = NAN, latitude = NAN, altitude = NAN;</a>
<a name="ln3164">  gchar *filename = NULL;</a>
<a name="ln3165">  gchar *datetime_taken = NULL;</a>
<a name="ln3166"> </a>
<a name="ln3167">  // get stars and raw params from db</a>
<a name="ln3168">  sqlite3_stmt *stmt;</a>
<a name="ln3169">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT filename, flags, raw_parameters, &quot;</a>
<a name="ln3170">                                                             &quot;longitude, latitude, altitude, history_end, iop_order_version, datetime_taken &quot;</a>
<a name="ln3171">                                                             &quot;FROM main.images WHERE id = ?1&quot;,</a>
<a name="ln3172">                              -1, &amp;stmt, NULL);</a>
<a name="ln3173">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln3174">  if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln3175">  {</a>
<a name="ln3176">    filename = (gchar *)sqlite3_column_text(stmt, 0);</a>
<a name="ln3177">    stars = sqlite3_column_int(stmt, 1);</a>
<a name="ln3178">    raw_params = sqlite3_column_int(stmt, 2);</a>
<a name="ln3179">    if(sqlite3_column_type(stmt, 3) == SQLITE_FLOAT) longitude = sqlite3_column_double(stmt, 3);</a>
<a name="ln3180">    if(sqlite3_column_type(stmt, 4) == SQLITE_FLOAT) latitude = sqlite3_column_double(stmt, 4);</a>
<a name="ln3181">    if(sqlite3_column_type(stmt, 5) == SQLITE_FLOAT) altitude = sqlite3_column_double(stmt, 5);</a>
<a name="ln3182">    history_end = sqlite3_column_int(stmt, 6);</a>
<a name="ln3183">    iop_order_version = sqlite3_column_int(stmt, 7);</a>
<a name="ln3184">    datetime_taken = (gchar *)sqlite3_column_text(stmt, 8);</a>
<a name="ln3185">  }</a>
<a name="ln3186"> </a>
<a name="ln3187">  // Store datetime_taken as DateTimeOriginal to take into account the user's selected date/time</a>
<a name="ln3188">  if (!(metadata-&gt;flags &amp; DT_META_EXIF))</a>
<a name="ln3189">    xmpData[&quot;Xmp.exif.DateTimeOriginal&quot;] = datetime_taken;</a>
<a name="ln3190"> </a>
<a name="ln3191">  // We have to erase the old ratings first as exiv2 seems to not change it otherwise.</a>
<a name="ln3192">  Exiv2::XmpData::iterator pos = xmpData.findKey(Exiv2::XmpKey(&quot;Xmp.xmp.Rating&quot;));</a>
<a name="ln3193">  if(pos != xmpData.end()) xmpData.erase(pos);</a>
<a name="ln3194">  xmpData[&quot;Xmp.xmp.Rating&quot;] = ((stars &amp; 0x7) == 6) ? -1 : (stars &amp; 0x7); // rejected image = -1, others = 0..5</a>
<a name="ln3195"> </a>
<a name="ln3196">  // The original file name</a>
<a name="ln3197">  if(filename) xmpData[&quot;Xmp.xmpMM.DerivedFrom&quot;] = filename;</a>
<a name="ln3198"> </a>
<a name="ln3199">  // GPS data</a>
<a name="ln3200">  if (metadata-&gt;flags &amp; DT_META_GEOTAG)</a>
<a name="ln3201">    dt_set_xmp_exif_geotag(xmpData, longitude, latitude, altitude);</a>
<a name="ln3202">  else</a>
<a name="ln3203">    dt_remove_xmp_exif_geotag(xmpData);</a>
<a name="ln3204"> </a>
<a name="ln3205">  sqlite3_finalize(stmt);</a>
<a name="ln3206"> </a>
<a name="ln3207">  // the meta data</a>
<a name="ln3208">  if (metadata-&gt;flags &amp; DT_META_METADATA)</a>
<a name="ln3209">    dt_set_xmp_dt_metadata(xmpData, imgid);</a>
<a name="ln3210"> </a>
<a name="ln3211">  // tags</a>
<a name="ln3212">  if (metadata-&gt;flags &amp; DT_META_TAG)</a>
<a name="ln3213">  {</a>
<a name="ln3214">    // get tags from db, store in dublin core</a>
<a name="ln3215">    std::unique_ptr&lt;Exiv2::Value&gt; v1(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln3216">    GList *tags = dt_tag_get_list_export(imgid, metadata-&gt;flags);</a>
<a name="ln3217">    while(tags)</a>
<a name="ln3218">    {</a>
<a name="ln3219">      v1-&gt;read((char *)tags-&gt;data);</a>
<a name="ln3220">      tags = g_list_next(tags);</a>
<a name="ln3221">    }</a>
<a name="ln3222">    if(v1-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.dc.subject&quot;), v1.get());</a>
<a name="ln3223">    g_list_free_full(tags, g_free);</a>
<a name="ln3224">  }</a>
<a name="ln3225"> </a>
<a name="ln3226">  if (metadata-&gt;flags &amp; DT_META_HIERARCHICAL_TAG)</a>
<a name="ln3227">  {</a>
<a name="ln3228">    std::unique_ptr&lt;Exiv2::Value&gt; v2(Exiv2::Value::create(Exiv2::xmpSeq)); // or xmpBag or xmpAlt.</a>
<a name="ln3229">    GList *hierarchical = dt_tag_get_hierarchical_export(imgid, metadata-&gt;flags);</a>
<a name="ln3230">    while(hierarchical)</a>
<a name="ln3231">    {</a>
<a name="ln3232">      v2-&gt;read((char *)hierarchical-&gt;data);</a>
<a name="ln3233">      hierarchical = g_list_next(hierarchical);</a>
<a name="ln3234">    }</a>
<a name="ln3235">    if(v2-&gt;count() &gt; 0) xmpData.add(Exiv2::XmpKey(&quot;Xmp.lr.hierarchicalSubject&quot;), v2.get());</a>
<a name="ln3236">    g_list_free_full(hierarchical, g_free);</a>
<a name="ln3237">  }</a>
<a name="ln3238"> </a>
<a name="ln3239">  /* TODO: Add tags to IPTC namespace as well */</a>
<a name="ln3240"> </a>
<a name="ln3241">  if (metadata-&gt;flags &amp; DT_META_DT_HISTORY)</a>
<a name="ln3242">  {</a>
<a name="ln3243">    xmpData[&quot;Xmp.darktable.xmp_version&quot;] = xmp_version;</a>
<a name="ln3244">    xmpData[&quot;Xmp.darktable.raw_params&quot;] = raw_params;</a>
<a name="ln3245">    if(stars &amp; DT_IMAGE_AUTO_PRESETS_APPLIED)</a>
<a name="ln3246">      xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 1;</a>
<a name="ln3247">    else</a>
<a name="ln3248">      xmpData[&quot;Xmp.darktable.auto_presets_applied&quot;] = 0;</a>
<a name="ln3249">    dt_set_xmp_dt_history(xmpData, imgid, history_end);</a>
<a name="ln3250">    xmpData[&quot;Xmp.darktable.iop_order_version&quot;] = iop_order_version;</a>
<a name="ln3251">  }</a>
<a name="ln3252">}</a>
<a name="ln3253"> </a>
<a name="ln3254">#if EXIV2_VERSION &gt;= EXIV2_MAKE_VERSION(0,27,0)</a>
<a name="ln3255">#define ERROR_CODE(a) (static_cast&lt;Exiv2::ErrorCode&gt;((a)))</a>
<a name="ln3256">#else</a>
<a name="ln3257">#define ERROR_CODE(a) (a)</a>
<a name="ln3258">#endif</a>
<a name="ln3259"> </a>
<a name="ln3260">char *dt_exif_xmp_read_string(const int imgid)</a>
<a name="ln3261">{</a>
<a name="ln3262">  try</a>
<a name="ln3263">  {</a>
<a name="ln3264">    char input_filename[PATH_MAX] = { 0 };</a>
<a name="ln3265">    gboolean from_cache = FALSE;</a>
<a name="ln3266">    dt_image_full_path(imgid, input_filename, sizeof(input_filename), &amp;from_cache);</a>
<a name="ln3267"> </a>
<a name="ln3268">    // first take over the data from the source image</a>
<a name="ln3269">    Exiv2::XmpData xmpData;</a>
<a name="ln3270">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln3271">    {</a>
<a name="ln3272">      std::string xmpPacket;</a>
<a name="ln3273"> </a>
<a name="ln3274">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln3275">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln3276">      Exiv2::XmpParser::decode(xmpData, xmpPacket);</a>
<a name="ln3277">      // because XmpSeq or XmpBag are added to the list, we first have</a>
<a name="ln3278">      // to remove these so that we don't end up with a string of duplicates</a>
<a name="ln3279">      dt_remove_known_keys(xmpData);</a>
<a name="ln3280">    }</a>
<a name="ln3281"> </a>
<a name="ln3282">    // now add whatever we have in the sidecar XMP. this overwrites stuff from the source image</a>
<a name="ln3283">    dt_image_path_append_version(imgid, input_filename, sizeof(input_filename));</a>
<a name="ln3284">    g_strlcat(input_filename, &quot;.xmp&quot;, sizeof(input_filename));</a>
<a name="ln3285">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln3286">    {</a>
<a name="ln3287">      Exiv2::XmpData sidecarXmpData;</a>
<a name="ln3288">      std::string xmpPacket;</a>
<a name="ln3289"> </a>
<a name="ln3290">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln3291">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln3292">      Exiv2::XmpParser::decode(sidecarXmpData, xmpPacket);</a>
<a name="ln3293"> </a>
<a name="ln3294">      for(Exiv2::XmpData::const_iterator it = sidecarXmpData.begin(); it != sidecarXmpData.end(); ++it)</a>
<a name="ln3295">        xmpData.add(*it);</a>
<a name="ln3296">    }</a>
<a name="ln3297"> </a>
<a name="ln3298">    dt_remove_known_keys(xmpData); // is this needed?</a>
<a name="ln3299"> </a>
<a name="ln3300">    // last but not least attach what we have in DB to the XMP. in theory that should be</a>
<a name="ln3301">    // the same as what we just copied over from the sidecar file, but you never know ...</a>
<a name="ln3302">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln3303"> </a>
<a name="ln3304">    // serialize the xmp data and output the xmp packet</a>
<a name="ln3305">    std::string xmpPacket;</a>
<a name="ln3306">    if(Exiv2::XmpParser::encode(xmpPacket, xmpData,</a>
<a name="ln3307">      Exiv2::XmpParser::useCompactFormat | Exiv2::XmpParser::omitPacketWrapper) != 0)</a>
<a name="ln3308">    {</a>
<a name="ln3309">      throw Exiv2::Error(ERROR_CODE(1), &quot;[xmp_write] failed to serialize xmp data&quot;);</a>
<a name="ln3310">    }</a>
<a name="ln3311">    return g_strdup(xmpPacket.c_str());</a>
<a name="ln3312">  }</a>
<a name="ln3313">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3314">  {</a>
<a name="ln3315">    std::cerr &lt;&lt; &quot;[xmp_read_blob] caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3316">    return NULL;</a>
<a name="ln3317">  }</a>
<a name="ln3318">}</a>
<a name="ln3319"> </a>
<a name="ln3320">static void dt_remove_xmp_key(Exiv2::XmpData &amp;xmp, const char *key)</a>
<a name="ln3321">{</a>
<a name="ln3322">  try</a>
<a name="ln3323">  {</a>
<a name="ln3324">    Exiv2::XmpData::iterator pos = xmp.findKey(Exiv2::XmpKey(key));</a>
<a name="ln3325">    if (pos != xmp.end())</a>
<a name="ln3326">      xmp.erase(pos);</a>
<a name="ln3327">  }</a>
<a name="ln3328">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3329">  {</a>
<a name="ln3330">  }</a>
<a name="ln3331">}</a>
<a name="ln3332"> </a>
<a name="ln3333">static void dt_remove_exif_key(Exiv2::ExifData &amp;exif, const char *key)</a>
<a name="ln3334">{</a>
<a name="ln3335">  try</a>
<a name="ln3336">  {</a>
<a name="ln3337">    Exiv2::ExifData::iterator pos = exif.findKey(Exiv2::ExifKey(key));</a>
<a name="ln3338">    if (pos != exif.end())</a>
<a name="ln3339">      exif.erase(pos);</a>
<a name="ln3340">  }</a>
<a name="ln3341">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3342">  {</a>
<a name="ln3343">  }</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346">int dt_exif_xmp_attach_export(const int imgid, const char *filename, void *metadata)</a>
<a name="ln3347">{</a>
<a name="ln3348">  dt_export_metadata_t *m = (dt_export_metadata_t *)metadata;</a>
<a name="ln3349">  try</a>
<a name="ln3350">  {</a>
<a name="ln3351">    char input_filename[PATH_MAX] = { 0 };</a>
<a name="ln3352">    gboolean from_cache = TRUE;</a>
<a name="ln3353">    dt_image_full_path(imgid, input_filename, sizeof(input_filename), &amp;from_cache);</a>
<a name="ln3354"> </a>
<a name="ln3355">    std::unique_ptr&lt;Exiv2::Image&gt; img(Exiv2::ImageFactory::open(WIDEN(filename)));</a>
<a name="ln3356">    // unfortunately it seems we have to read the metadata, to not erase the exif (which we just wrote).</a>
<a name="ln3357">    // will make export slightly slower, oh well.</a>
<a name="ln3358">    // img-&gt;clearXmpPacket();</a>
<a name="ln3359">    read_metadata_threadsafe(img);</a>
<a name="ln3360"> </a>
<a name="ln3361">    try</a>
<a name="ln3362">    {</a>
<a name="ln3363">      // initialize XMP and IPTC data with the one from the original file</a>
<a name="ln3364">      std::unique_ptr&lt;Exiv2::Image&gt; input_image(Exiv2::ImageFactory::open(WIDEN(input_filename)));</a>
<a name="ln3365">      if(input_image.get() != 0)</a>
<a name="ln3366">      {</a>
<a name="ln3367">        read_metadata_threadsafe(input_image);</a>
<a name="ln3368">        img-&gt;setIptcData(input_image-&gt;iptcData());</a>
<a name="ln3369">        img-&gt;setXmpData(input_image-&gt;xmpData());</a>
<a name="ln3370">      }</a>
<a name="ln3371">    }</a>
<a name="ln3372">    catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3373">    {</a>
<a name="ln3374">      std::cerr &lt;&lt; &quot;[xmp_attach] &quot; &lt;&lt; input_filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3375">    }</a>
<a name="ln3376"> </a>
<a name="ln3377">    Exiv2::XmpData &amp;xmpData = img-&gt;xmpData();</a>
<a name="ln3378"> </a>
<a name="ln3379">    // now add whatever we have in the sidecar XMP. this overwrites stuff from the source image</a>
<a name="ln3380">    dt_image_path_append_version(imgid, input_filename, sizeof(input_filename));</a>
<a name="ln3381">    g_strlcat(input_filename, &quot;.xmp&quot;, sizeof(input_filename));</a>
<a name="ln3382">    if(g_file_test(input_filename, G_FILE_TEST_EXISTS))</a>
<a name="ln3383">    {</a>
<a name="ln3384">      Exiv2::XmpData sidecarXmpData;</a>
<a name="ln3385">      std::string xmpPacket;</a>
<a name="ln3386"> </a>
<a name="ln3387">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(input_filename));</a>
<a name="ln3388">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln3389">      Exiv2::XmpParser::decode(sidecarXmpData, xmpPacket);</a>
<a name="ln3390"> </a>
<a name="ln3391">      for(Exiv2::XmpData::const_iterator it = sidecarXmpData.begin(); it != sidecarXmpData.end(); ++it)</a>
<a name="ln3392">        xmpData.add(*it);</a>
<a name="ln3393">    }</a>
<a name="ln3394"> </a>
<a name="ln3395">    dt_remove_known_keys(xmpData); // is this needed?</a>
<a name="ln3396"> </a>
<a name="ln3397">    {</a>
<a name="ln3398">      // We also want to make sure to not have some tags that might</a>
<a name="ln3399">      // have come in from XMP files created by digikam or similar</a>
<a name="ln3400">      static const char *keys[] = {</a>
<a name="ln3401">        &quot;Xmp.tiff.Orientation&quot;</a>
<a name="ln3402">      };</a>
<a name="ln3403">      static const guint n_keys = G_N_ELEMENTS(keys);</a>
<a name="ln3404">      dt_remove_xmp_keys(xmpData, keys, n_keys);</a>
<a name="ln3405">    }</a>
<a name="ln3406"> </a>
<a name="ln3407">    if (!(m-&gt;flags &amp; DT_META_EXIF))</a>
<a name="ln3408">      img-&gt;clearExifData();</a>
<a name="ln3409"> </a>
<a name="ln3410"> </a>
<a name="ln3411"> </a>
<a name="ln3412">    // last but not least attach what we have in DB to the XMP. in theory that should be</a>
<a name="ln3413">    // the same as what we just copied over from the sidecar file, but you never know ...</a>
<a name="ln3414">    dt_exif_xmp_read_data_export(xmpData, imgid, m);</a>
<a name="ln3415"> </a>
<a name="ln3416">    Exiv2::IptcData &amp;iptcData = img-&gt;iptcData();</a>
<a name="ln3417">    Exiv2::ExifData &amp;exifData = img-&gt;exifData();</a>
<a name="ln3418">    // make sure to remove all geotags if necessary</a>
<a name="ln3419">    if (!(m-&gt;flags &amp; DT_META_GEOTAG))</a>
<a name="ln3420">      dt_remove_exif_geotag(exifData);</a>
<a name="ln3421">    // calculated metadata</a>
<a name="ln3422">    dt_variables_params_t *params;</a>
<a name="ln3423">    dt_variables_params_init(&amp;params);</a>
<a name="ln3424">    params-&gt;filename = input_filename;</a>
<a name="ln3425">    params-&gt;jobcode = &quot;export&quot;;</a>
<a name="ln3426">    params-&gt;sequence = 0;</a>
<a name="ln3427">    params-&gt;imgid = imgid;</a>
<a name="ln3428">    dt_variables_set_tags_flags(params, m-&gt;flags);</a>
<a name="ln3429">    for (GList *tags = m-&gt;list; tags; tags = g_list_next(tags))</a>
<a name="ln3430">    {</a>
<a name="ln3431">      gchar *tagname = (gchar *)tags-&gt;data;</a>
<a name="ln3432">      tags = g_list_next(tags);</a>
<a name="ln3433">      if (!tags) break;</a>
<a name="ln3434">      gchar *formula = (gchar *)tags-&gt;data;</a>
<a name="ln3435">      if (formula[0])</a>
<a name="ln3436">      {</a>
<a name="ln3437">        gchar *result = dt_variables_expand(params, formula, FALSE);</a>
<a name="ln3438">        if (result &amp;&amp; result[0])</a>
<a name="ln3439">        {</a>
<a name="ln3440">          if (g_str_has_prefix(tagname, &quot;Xmp.&quot;))</a>
<a name="ln3441">            xmpData[tagname] = result;</a>
<a name="ln3442">          else if (g_str_has_prefix(tagname, &quot;Iptc.&quot;))</a>
<a name="ln3443">            iptcData[tagname] = result;</a>
<a name="ln3444">          else if (g_str_has_prefix(tagname, &quot;Exif.&quot;))</a>
<a name="ln3445">            exifData[tagname] = result;</a>
<a name="ln3446">        }</a>
<a name="ln3447">        g_free(result);</a>
<a name="ln3448">      }</a>
<a name="ln3449">      else</a>
<a name="ln3450">      {</a>
<a name="ln3451">        if (g_str_has_prefix(tagname, &quot;Xmp.&quot;))</a>
<a name="ln3452">          dt_remove_xmp_key(xmpData, tagname);</a>
<a name="ln3453">        else if (g_str_has_prefix(tagname, &quot;Exif.&quot;))</a>
<a name="ln3454">          dt_remove_exif_key(exifData, tagname);</a>
<a name="ln3455">      }</a>
<a name="ln3456">    }</a>
<a name="ln3457">    dt_variables_params_destroy(params);</a>
<a name="ln3458"> </a>
<a name="ln3459"> </a>
<a name="ln3460">    img-&gt;writeMetadata();</a>
<a name="ln3461">    return 0;</a>
<a name="ln3462">  }</a>
<a name="ln3463">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3464">  {</a>
<a name="ln3465">    std::cerr &lt;&lt; &quot;[xmp_attach] &quot; &lt;&lt; filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3466">    return -1;</a>
<a name="ln3467">  }</a>
<a name="ln3468">}</a>
<a name="ln3469"> </a>
<a name="ln3470">// write xmp sidecar file:</a>
<a name="ln3471">int dt_exif_xmp_write(const int imgid, const char *filename)</a>
<a name="ln3472">{</a>
<a name="ln3473">  // refuse to write sidecar for non-existent image:</a>
<a name="ln3474">  char imgfname[PATH_MAX] = { 0 };</a>
<a name="ln3475">  gboolean from_cache = TRUE;</a>
<a name="ln3476"> </a>
<a name="ln3477">  dt_image_full_path(imgid, imgfname, sizeof(imgfname), &amp;from_cache);</a>
<a name="ln3478">  if(!g_file_test(imgfname, G_FILE_TEST_IS_REGULAR)) return 1;</a>
<a name="ln3479"> </a>
<a name="ln3480">  try</a>
<a name="ln3481">  {</a>
<a name="ln3482">    Exiv2::XmpData xmpData;</a>
<a name="ln3483">    std::string xmpPacket;</a>
<a name="ln3484">    char *checksum_old = NULL;</a>
<a name="ln3485">    if(g_file_test(filename, G_FILE_TEST_EXISTS))</a>
<a name="ln3486">    {</a>
<a name="ln3487">      // we want to avoid writing the sidecar file if it didn't change to avoid issues when using the same images</a>
<a name="ln3488">      // from different computers. sample use case: images on NAS, several computers using them NOT AT THE SAME TIME and</a>
<a name="ln3489">      // the xmp crawler is used to find changed sidecars.</a>
<a name="ln3490">      FILE *fd = g_fopen(filename, &quot;rb&quot;);</a>
<a name="ln3491">      if(fd)</a>
<a name="ln3492">      {</a>
<a name="ln3493">        fseek(fd, 0, SEEK_END);</a>
<a name="ln3494">        size_t end = ftell(fd);</a>
<a name="ln3495">        rewind(fd);</a>
<a name="ln3496">        unsigned char *content = (unsigned char *)malloc(end * sizeof(char));</a>
<a name="ln3497">        if(content)</a>
<a name="ln3498">        {</a>
<a name="ln3499">          if(fread(content, sizeof(unsigned char), end, fd) == end)</a>
<a name="ln3500">            checksum_old = g_compute_checksum_for_data(G_CHECKSUM_MD5, content, end);</a>
<a name="ln3501">          free(content);</a>
<a name="ln3502">        }</a>
<a name="ln3503">        fclose(fd);</a>
<a name="ln3504">      }</a>
<a name="ln3505"> </a>
<a name="ln3506">      Exiv2::DataBuf buf = Exiv2::readFile(WIDEN(filename));</a>
<a name="ln3507">      xmpPacket.assign(reinterpret_cast&lt;char *&gt;(buf.pData_), buf.size_);</a>
<a name="ln3508">      Exiv2::XmpParser::decode(xmpData, xmpPacket);</a>
<a name="ln3509">      // because XmpSeq or XmpBag are added to the list, we first have</a>
<a name="ln3510">      // to remove these so that we don't end up with a string of duplicates</a>
<a name="ln3511">      dt_remove_known_keys(xmpData);</a>
<a name="ln3512">    }</a>
<a name="ln3513"> </a>
<a name="ln3514">    // initialize xmp data:</a>
<a name="ln3515">    dt_exif_xmp_read_data(xmpData, imgid);</a>
<a name="ln3516"> </a>
<a name="ln3517">    // serialize the xmp data and output the xmp packet</a>
<a name="ln3518">    if(Exiv2::XmpParser::encode(xmpPacket, xmpData,</a>
<a name="ln3519">       Exiv2::XmpParser::useCompactFormat | Exiv2::XmpParser::omitPacketWrapper) != 0)</a>
<a name="ln3520">    {</a>
<a name="ln3521">      throw Exiv2::Error(ERROR_CODE(1), &quot;[xmp_write] failed to serialize xmp data&quot;);</a>
<a name="ln3522">    }</a>
<a name="ln3523"> </a>
<a name="ln3524">    // hash the new data and compare it to the old hash (if applicable)</a>
<a name="ln3525">    const char *xml_header = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;</a>
<a name="ln3526">    gboolean write_sidecar = TRUE;</a>
<a name="ln3527">    if(checksum_old)</a>
<a name="ln3528">    {</a>
<a name="ln3529">      GChecksum *checksum = g_checksum_new(G_CHECKSUM_MD5);</a>
<a name="ln3530">      if(checksum)</a>
<a name="ln3531">      {</a>
<a name="ln3532">        g_checksum_update(checksum, (unsigned char*)xml_header, -1);</a>
<a name="ln3533">        g_checksum_update(checksum, (unsigned char*)xmpPacket.c_str(), -1);</a>
<a name="ln3534">        const char *checksum_new = g_checksum_get_string(checksum);</a>
<a name="ln3535">        write_sidecar = g_strcmp0(checksum_old, checksum_new) != 0;</a>
<a name="ln3536">        g_checksum_free(checksum);</a>
<a name="ln3537">      }</a>
<a name="ln3538">      g_free(checksum_old);</a>
<a name="ln3539">    }</a>
<a name="ln3540"> </a>
<a name="ln3541">    if(write_sidecar)</a>
<a name="ln3542">    {</a>
<a name="ln3543">      // using std::ofstream isn't possible here -- on Windows it doesn't support Unicode filenames with mingw</a>
<a name="ln3544">      FILE *fout = g_fopen(filename, &quot;wb&quot;);</a>
<a name="ln3545">      if(fout)</a>
<a name="ln3546">      {</a>
<a name="ln3547">        fprintf(fout, &quot;%s&quot;, xml_header);</a>
<a name="ln3548">        fprintf(fout, &quot;%s&quot;, xmpPacket.c_str());</a>
<a name="ln3549">        fclose(fout);</a>
<a name="ln3550">      }</a>
<a name="ln3551">    }</a>
<a name="ln3552"> </a>
<a name="ln3553">    return 0;</a>
<a name="ln3554">  }</a>
<a name="ln3555">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3556">  {</a>
<a name="ln3557">    std::cerr &lt;&lt; &quot;[xmp_write] &quot; &lt;&lt; filename &lt;&lt; &quot;: caught exiv2 exception '&quot; &lt;&lt; e &lt;&lt; &quot;'\n&quot;;</a>
<a name="ln3558">    return -1;</a>
<a name="ln3559">  }</a>
<a name="ln3560">}</a>
<a name="ln3561"> </a>
<a name="ln3562">dt_colorspaces_color_profile_type_t dt_exif_get_color_space(const uint8_t *data, size_t size)</a>
<a name="ln3563">{</a>
<a name="ln3564">  try</a>
<a name="ln3565">  {</a>
<a name="ln3566">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln3567">    Exiv2::ExifData exifData;</a>
<a name="ln3568">    Exiv2::ExifParser::decode(exifData, data, size);</a>
<a name="ln3569"> </a>
<a name="ln3570">    // 0x01   -&gt; sRGB</a>
<a name="ln3571">    // 0x02   -&gt; AdobeRGB</a>
<a name="ln3572">    // 0xffff -&gt; Uncalibrated</a>
<a name="ln3573">    //          + Exif.Iop.InteroperabilityIndex of 'R03' -&gt; AdobeRGB</a>
<a name="ln3574">    //          + Exif.Iop.InteroperabilityIndex of 'R98' -&gt; sRGB</a>
<a name="ln3575">    if((pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Photo.ColorSpace&quot;))) != exifData.end() &amp;&amp; pos-&gt;size())</a>
<a name="ln3576">    {</a>
<a name="ln3577">      int colorspace = pos-&gt;toLong();</a>
<a name="ln3578">      if(colorspace == 0x01)</a>
<a name="ln3579">        return DT_COLORSPACE_SRGB;</a>
<a name="ln3580">      else if(colorspace == 0x02)</a>
<a name="ln3581">        return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln3582">      else if(colorspace == 0xffff)</a>
<a name="ln3583">      {</a>
<a name="ln3584">        if((pos = exifData.findKey(Exiv2::ExifKey(&quot;Exif.Iop.InteroperabilityIndex&quot;))) != exifData.end()</a>
<a name="ln3585">          &amp;&amp; pos-&gt;size())</a>
<a name="ln3586">        {</a>
<a name="ln3587">          std::string interop_index = pos-&gt;toString();</a>
<a name="ln3588">          if(interop_index == &quot;R03&quot;)</a>
<a name="ln3589">            return DT_COLORSPACE_ADOBERGB;</a>
<a name="ln3590">          else if(interop_index == &quot;R98&quot;)</a>
<a name="ln3591">            return DT_COLORSPACE_SRGB;</a>
<a name="ln3592">        }</a>
<a name="ln3593">      }</a>
<a name="ln3594">    }</a>
<a name="ln3595"> </a>
<a name="ln3596">    return DT_COLORSPACE_DISPLAY; // nothing embedded</a>
<a name="ln3597">  }</a>
<a name="ln3598">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3599">  {</a>
<a name="ln3600">    std::string s(e.what());</a>
<a name="ln3601">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln3602">    return DT_COLORSPACE_DISPLAY;</a>
<a name="ln3603">  }</a>
<a name="ln3604">}</a>
<a name="ln3605"> </a>
<a name="ln3606">gboolean dt_exif_get_datetime_taken(const uint8_t *data, size_t size, time_t *datetime_taken)</a>
<a name="ln3607">{</a>
<a name="ln3608">  try</a>
<a name="ln3609">  {</a>
<a name="ln3610">    Exiv2::ExifData::const_iterator pos;</a>
<a name="ln3611">    std::unique_ptr&lt;Exiv2::Image&gt; image(Exiv2::ImageFactory::open(data, size));</a>
<a name="ln3612">    read_metadata_threadsafe(image);</a>
<a name="ln3613">    Exiv2::ExifData &amp;exifData = image-&gt;exifData();</a>
<a name="ln3614"> </a>
<a name="ln3615">    char exif_datetime_taken[20];</a>
<a name="ln3616">    _find_datetime_taken(exifData, pos, exif_datetime_taken);</a>
<a name="ln3617"> </a>
<a name="ln3618">    if(*exif_datetime_taken)</a>
<a name="ln3619">    {</a>
<a name="ln3620">      struct tm exif_tm= {0};</a>
<a name="ln3621">      if(sscanf(exif_datetime_taken,&quot;%d:%d:%d %d:%d:%d&quot;,</a>
<a name="ln3622">        &amp;exif_tm.tm_year,</a>
<a name="ln3623">        &amp;exif_tm.tm_mon,</a>
<a name="ln3624">        &amp;exif_tm.tm_mday,</a>
<a name="ln3625">        &amp;exif_tm.tm_hour,</a>
<a name="ln3626">        &amp;exif_tm.tm_min,</a>
<a name="ln3627">        &amp;exif_tm.tm_sec) == 6)</a>
<a name="ln3628">      {</a>
<a name="ln3629">        exif_tm.tm_year -= 1900;</a>
<a name="ln3630">        exif_tm.tm_mon--;</a>
<a name="ln3631">        *datetime_taken = mktime(&amp;exif_tm);</a>
<a name="ln3632">        return TRUE;</a>
<a name="ln3633">      }</a>
<a name="ln3634">    }</a>
<a name="ln3635"> </a>
<a name="ln3636">    return FALSE;</a>
<a name="ln3637">  }</a>
<a name="ln3638">  catch(Exiv2::AnyError &amp;e)</a>
<a name="ln3639">  {</a>
<a name="ln3640">    std::string s(e.what());</a>
<a name="ln3641">    std::cerr &lt;&lt; &quot;[exiv2] &quot; &lt;&lt; s &lt;&lt; std::endl;</a>
<a name="ln3642">    return FALSE;</a>
<a name="ln3643">  }</a>
<a name="ln3644">}</a>
<a name="ln3645"> </a>
<a name="ln3646">static void dt_exif_log_handler(int log_level, const char *message)</a>
<a name="ln3647">{</a>
<a name="ln3648">  if(log_level &gt;= Exiv2::LogMsg::level())</a>
<a name="ln3649">  {</a>
<a name="ln3650">    // We don't seem to need \n in the format string as exiv2 includes it</a>
<a name="ln3651">    // in the messages themselves</a>
<a name="ln3652">    dt_print(DT_DEBUG_CAMERA_SUPPORT, &quot;[exiv2] %s&quot;, message);</a>
<a name="ln3653">  }</a>
<a name="ln3654">}</a>
<a name="ln3655"> </a>
<a name="ln3656">void dt_exif_init()</a>
<a name="ln3657">{</a>
<a name="ln3658">  // preface the exiv2 messages with &quot;[exiv2] &quot;</a>
<a name="ln3659">  Exiv2::LogMsg::setHandler(&amp;dt_exif_log_handler);</a>
<a name="ln3660"> </a>
<a name="ln3661">  Exiv2::XmpParser::initialize();</a>
<a name="ln3662">  // this has to stay with the old url (namespace already propagated outside dt)</a>
<a name="ln3663">  Exiv2::XmpProperties::registerNs(&quot;http://darktable.sf.net/&quot;, &quot;darktable&quot;);</a>
<a name="ln3664">  Exiv2::XmpProperties::registerNs(&quot;http://ns.adobe.com/lightroom/1.0/&quot;, &quot;lr&quot;);</a>
<a name="ln3665">  Exiv2::XmpProperties::registerNs(&quot;http://cipa.jp/exif/1.0/&quot;, &quot;exifEX&quot;);</a>
<a name="ln3666">}</a>
<a name="ln3667"> </a>
<a name="ln3668">void dt_exif_cleanup()</a>
<a name="ln3669">{</a>
<a name="ln3670">  Exiv2::XmpParser::terminate();</a>
<a name="ln3671">}</a>
<a name="ln3672"> </a>
<a name="ln3673">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3674">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3675">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="227"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 227, 225.</p></div>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 240, 238.</p></div>
<div class="balloon" rel="253"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 253, 251.</p></div>
<div class="balloon" rel="266"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 266, 264.</p></div>
<div class="balloon" rel="279"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 279, 277.</p></div>
<div class="balloon" rel="359"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strncmp' function. Inspect the first argument. Check lines: 359, 357.</p></div>
<div class="balloon" rel="382"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'strchr' function. Inspect the first argument. Check lines: 382, 372.</p></div>
<div class="balloon" rel="1630"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'compress' function. Inspect the first argument. Check lines: 1630, 1628.</p></div>
<div class="balloon" rel="1715"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'output' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1938"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v583/" target="_blank">V583</a> The '?:' operator, regardless of its conditional expression, always returns one and the same value.</p></div>
<div class="balloon" rel="1981"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 1981, 1980.</p></div>
<div class="balloon" rel="2067"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_length' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2071"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 2071, 2070.</p></div>
<div class="balloon" rel="2200"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'entry'. Check lines: 2200, 2198.</p></div>
<div class="balloon" rel="2204"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'mask_name_str.c_str() != __null' is always true.</p></div>
<div class="balloon" rel="2269"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_length' function. Inspect the first argument.</p></div>
<div class="balloon" rel="2273"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'current_entry'. Check lines: 2273, 2272.</p></div>
<div class="balloon" rel="3135"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="3144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="3223"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="3236"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>
<div class="balloon" rel="3424"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'input_filename' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="3616"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized iterator 'pos' used. Consider checking the second actual argument of the '_find_datetime_taken' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
