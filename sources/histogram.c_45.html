
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2014-2016 LebedevRI.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &lt;math.h&gt;</a>
<a name="ln19">#include &lt;stddef.h&gt;</a>
<a name="ln20">#include &lt;stdint.h&gt;</a>
<a name="ln21">#if defined(__SSE__)</a>
<a name="ln22">#include &lt;xmmintrin.h&gt;</a>
<a name="ln23">#endif</a>
<a name="ln24">#include &lt;assert.h&gt;</a>
<a name="ln25">#include &lt;stdlib.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;common/darktable.h&quot;</a>
<a name="ln28">#include &quot;common/histogram.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#define S(V, params) ((params-&gt;mul) * ((float)V))</a>
<a name="ln32">#define P(V, params) (CLAMP((V), 0, (params-&gt;bins_count - 1)))</a>
<a name="ln33">#define PU(V, params) (MIN((V), (params-&gt;bins_count - 1)))</a>
<a name="ln34">#define PS(V, params) (P(S(V, params), params))</a>
<a name="ln35"> </a>
<a name="ln36">//------------------------------------------------------------------------------</a>
<a name="ln37"> </a>
<a name="ln38">inline static void histogram_helper_cs_RAW_helper_process_pixel_float(</a>
<a name="ln39">    const dt_dev_histogram_collection_params_t *const histogram_params, const float *pixel, uint32_t *histogram)</a>
<a name="ln40">{</a>
<a name="ln41">  const uint32_t i = PS(*pixel, histogram_params);</a>
<a name="ln42">  histogram[4 * i]++;</a>
<a name="ln43">}</a>
<a name="ln44"> </a>
<a name="ln45">inline static void histogram_helper_cs_RAW(const dt_dev_histogram_collection_params_t *const histogram_params,</a>
<a name="ln46">                                           const void *pixel, uint32_t *histogram, int j)</a>
<a name="ln47">{</a>
<a name="ln48">  const dt_histogram_roi_t *roi = histogram_params-&gt;roi;</a>
<a name="ln49">  const float *input = (float *)pixel + roi-&gt;width * j + roi-&gt;crop_x;</a>
<a name="ln50">  for(int i = 0; i &lt; roi-&gt;width - roi-&gt;crop_width - roi-&gt;crop_x; i++, input++)</a>
<a name="ln51">  {</a>
<a name="ln52">    histogram_helper_cs_RAW_helper_process_pixel_float(histogram_params, input, histogram);</a>
<a name="ln53">  }</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">//------------------------------------------------------------------------------</a>
<a name="ln57"> </a>
<a name="ln58">// WARNING: you must ensure that bins_count is big enough</a>
<a name="ln59">inline static void histogram_helper_cs_RAW_helper_process_pixel_uint16(</a>
<a name="ln60">    const dt_dev_histogram_collection_params_t *const histogram_params, const uint16_t *pixel, uint32_t *histogram)</a>
<a name="ln61">{</a>
<a name="ln62">  const uint16_t i = PU(*pixel, histogram_params);</a>
<a name="ln63">  histogram[4 * i]++;</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">inline void dt_histogram_helper_cs_RAW_uint16(const dt_dev_histogram_collection_params_t *const histogram_params,</a>
<a name="ln67">                                              const void *pixel, uint32_t *histogram, int j)</a>
<a name="ln68">{</a>
<a name="ln69">  const dt_histogram_roi_t *roi = histogram_params-&gt;roi;</a>
<a name="ln70">  uint16_t *in = (uint16_t *)pixel + roi-&gt;width * j + roi-&gt;crop_x;</a>
<a name="ln71"> </a>
<a name="ln72">  // process pixels</a>
<a name="ln73">  for(int i = 0; i &lt; roi-&gt;width - roi-&gt;crop_width - roi-&gt;crop_x; i++, in++)</a>
<a name="ln74">    histogram_helper_cs_RAW_helper_process_pixel_uint16(histogram_params, in, histogram);</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">//------------------------------------------------------------------------------</a>
<a name="ln78"> </a>
<a name="ln79">inline static void __attribute__((__unused__)) histogram_helper_cs_rgb_helper_process_pixel_float(</a>
<a name="ln80">    const dt_dev_histogram_collection_params_t *const histogram_params, const float *pixel, uint32_t *histogram)</a>
<a name="ln81">{</a>
<a name="ln82">  const uint32_t R = PS(pixel[0], histogram_params);</a>
<a name="ln83">  const uint32_t G = PS(pixel[1], histogram_params);</a>
<a name="ln84">  const uint32_t B = PS(pixel[2], histogram_params);</a>
<a name="ln85">  histogram[4 * R]++;</a>
<a name="ln86">  histogram[4 * G + 1]++;</a>
<a name="ln87">  histogram[4 * B + 2]++;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">#if defined(__SSE2__)</a>
<a name="ln91">inline static void histogram_helper_cs_rgb_helper_process_pixel_m128(</a>
<a name="ln92">    const dt_dev_histogram_collection_params_t *const histogram_params, const float *pixel, uint32_t *histogram)</a>
<a name="ln93">{</a>
<a name="ln94">  const __m128 scale = _mm_set1_ps(histogram_params-&gt;mul);</a>
<a name="ln95">  const __m128 val_min = _mm_setzero_ps();</a>
<a name="ln96">  const __m128 val_max = _mm_set1_ps(histogram_params-&gt;bins_count - 1);</a>
<a name="ln97"> </a>
<a name="ln98">  assert(dt_is_aligned(pixel, 16));</a>
<a name="ln99">  const __m128 input = _mm_load_ps(pixel);</a>
<a name="ln100">  const __m128 scaled = _mm_mul_ps(input, scale);</a>
<a name="ln101">  const __m128 clamped = _mm_max_ps(_mm_min_ps(scaled, val_max), val_min);</a>
<a name="ln102"> </a>
<a name="ln103">  const __m128i indexes = _mm_cvtps_epi32(clamped);</a>
<a name="ln104"> </a>
<a name="ln105">  __m128i values __attribute__((aligned(16)));</a>
<a name="ln106">  _mm_store_si128(&amp;values, indexes);</a>
<a name="ln107"> </a>
<a name="ln108">  const uint32_t *valuesi = (uint32_t *)(&amp;values);</a>
<a name="ln109"> </a>
<a name="ln110">  histogram[4 * valuesi[0]]++;</a>
<a name="ln111">  histogram[4 * valuesi[1] + 1]++;</a>
<a name="ln112">  histogram[4 * valuesi[2] + 2]++;</a>
<a name="ln113">}</a>
<a name="ln114">#endif</a>
<a name="ln115"> </a>
<a name="ln116">inline static void histogram_helper_cs_rgb(const dt_dev_histogram_collection_params_t *const histogram_params,</a>
<a name="ln117">                                           const void *pixel, uint32_t *histogram, int j)</a>
<a name="ln118">{</a>
<a name="ln119">  const dt_histogram_roi_t *roi = histogram_params-&gt;roi;</a>
<a name="ln120">  float *in = (float *)pixel + 4 * (roi-&gt;width * j + roi-&gt;crop_x);</a>
<a name="ln121"> </a>
<a name="ln122">  // process aligned pixels with SSE</a>
<a name="ln123">  for(int i = 0; i &lt; roi-&gt;width - roi-&gt;crop_width - roi-&gt;crop_x; i++, in += 4)</a>
<a name="ln124">  {</a>
<a name="ln125">    if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln126">      histogram_helper_cs_rgb_helper_process_pixel_float(histogram_params, in, histogram);</a>
<a name="ln127">#if defined(__SSE2__)</a>
<a name="ln128">    else if(darktable.codepath.SSE2)</a>
<a name="ln129">      histogram_helper_cs_rgb_helper_process_pixel_m128(histogram_params, in, histogram);</a>
<a name="ln130">#endif</a>
<a name="ln131">    else</a>
<a name="ln132">      dt_unreachable_codepath();</a>
<a name="ln133">  }</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">//------------------------------------------------------------------------------</a>
<a name="ln137"> </a>
<a name="ln138">inline static void __attribute__((__unused__)) histogram_helper_cs_Lab_helper_process_pixel_float(</a>
<a name="ln139">    const dt_dev_histogram_collection_params_t *const histogram_params, const float *pixel, uint32_t *histogram)</a>
<a name="ln140">{</a>
<a name="ln141">  const float Lv = pixel[0];</a>
<a name="ln142">  const float av = pixel[1];</a>
<a name="ln143">  const float bv = pixel[2];</a>
<a name="ln144">  const float max = histogram_params-&gt;bins_count - 1;</a>
<a name="ln145">  const uint32_t L = CLAMP(histogram_params-&gt;mul / 100.0f * (Lv), 0, max);</a>
<a name="ln146">  const uint32_t a = CLAMP(histogram_params-&gt;mul / 256.0f * (av + 128.0f), 0, max);</a>
<a name="ln147">  const uint32_t b = CLAMP(histogram_params-&gt;mul / 256.0f * (bv + 128.0f), 0, max);</a>
<a name="ln148">  histogram[4 * L]++;</a>
<a name="ln149">  histogram[4 * a + 1]++;</a>
<a name="ln150">  histogram[4 * b + 2]++;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">#if defined(__SSE2__)</a>
<a name="ln154">inline static void histogram_helper_cs_Lab_helper_process_pixel_m128(</a>
<a name="ln155">    const dt_dev_histogram_collection_params_t *const histogram_params, const float *pixel, uint32_t *histogram)</a>
<a name="ln156">{</a>
<a name="ln157">  const float fscale = histogram_params-&gt;mul;</a>
<a name="ln158"> </a>
<a name="ln159">  const __m128 shift = _mm_set_ps(0.0f, 128.0f, 128.0f, 0.0f);</a>
<a name="ln160">  const __m128 scale = _mm_set_ps(fscale / 1.0f, fscale / 256.0f, fscale / 256.0f, fscale / 100.0f);</a>
<a name="ln161">  const __m128 val_min = _mm_setzero_ps();</a>
<a name="ln162">  const __m128 val_max = _mm_set1_ps(histogram_params-&gt;bins_count - 1);</a>
<a name="ln163"> </a>
<a name="ln164">  assert(dt_is_aligned(pixel, 16));</a>
<a name="ln165">  const __m128 input = _mm_load_ps(pixel);</a>
<a name="ln166">  const __m128 shifted = _mm_add_ps(input, shift);</a>
<a name="ln167">  const __m128 scaled = _mm_mul_ps(shifted, scale);</a>
<a name="ln168">  const __m128 clamped = _mm_max_ps(_mm_min_ps(scaled, val_max), val_min);</a>
<a name="ln169"> </a>
<a name="ln170">  const __m128i indexes = _mm_cvtps_epi32(clamped);</a>
<a name="ln171"> </a>
<a name="ln172">  __m128i values __attribute__((aligned(16)));</a>
<a name="ln173">  _mm_store_si128(&amp;values, indexes);</a>
<a name="ln174"> </a>
<a name="ln175">  const uint32_t *valuesi = (uint32_t *)(&amp;values);</a>
<a name="ln176"> </a>
<a name="ln177">  histogram[4 * valuesi[0]]++;</a>
<a name="ln178">  histogram[4 * valuesi[1] + 1]++;</a>
<a name="ln179">  histogram[4 * valuesi[2] + 2]++;</a>
<a name="ln180">}</a>
<a name="ln181">#endif</a>
<a name="ln182"> </a>
<a name="ln183">inline static void histogram_helper_cs_Lab(const dt_dev_histogram_collection_params_t *const histogram_params,</a>
<a name="ln184">                                           const void *pixel, uint32_t *histogram, int j)</a>
<a name="ln185">{</a>
<a name="ln186">  const dt_histogram_roi_t *roi = histogram_params-&gt;roi;</a>
<a name="ln187">  float *in = (float *)pixel + 4 * (roi-&gt;width * j + roi-&gt;crop_x);</a>
<a name="ln188"> </a>
<a name="ln189">  // process aligned pixels with SSE</a>
<a name="ln190">  for(int i = 0; i &lt; roi-&gt;width - roi-&gt;crop_width - roi-&gt;crop_x; i++, in += 4)</a>
<a name="ln191">  {</a>
<a name="ln192">    if(darktable.codepath.OPENMP_SIMD)</a>
<a name="ln193">      histogram_helper_cs_Lab_helper_process_pixel_float(histogram_params, in, histogram);</a>
<a name="ln194">#if defined(__SSE2__)</a>
<a name="ln195">    else if(darktable.codepath.SSE2)</a>
<a name="ln196">      histogram_helper_cs_Lab_helper_process_pixel_m128(histogram_params, in, histogram);</a>
<a name="ln197">#endif</a>
<a name="ln198">    else</a>
<a name="ln199">      dt_unreachable_codepath();</a>
<a name="ln200">  }</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">//==============================================================================</a>
<a name="ln204"> </a>
<a name="ln205">void dt_histogram_worker(dt_dev_histogram_collection_params_t *const histogram_params,</a>
<a name="ln206">                         dt_dev_histogram_stats_t *histogram_stats, const void *const pixel,</a>
<a name="ln207">                         uint32_t **histogram, const dt_worker Worker)</a>
<a name="ln208">{</a>
<a name="ln209">  const int nthreads = omp_get_max_threads();</a>
<a name="ln210"> </a>
<a name="ln211">  const size_t bins_total = (size_t)4 * histogram_params-&gt;bins_count;</a>
<a name="ln212">  const size_t buf_size = bins_total * sizeof(uint32_t);</a>
<a name="ln213">  void *partial_hists = calloc(nthreads, buf_size);</a>
<a name="ln214"> </a>
<a name="ln215">  if(histogram_params-&gt;mul == 0) histogram_params-&gt;mul = (double)(histogram_params-&gt;bins_count - 1);</a>
<a name="ln216"> </a>
<a name="ln217">  const dt_histogram_roi_t *const roi = histogram_params-&gt;roi;</a>
<a name="ln218"> </a>
<a name="ln219">#ifdef _OPENMP</a>
<a name="ln220">#pragma omp parallel for schedule(static) default(none) shared(partial_hists)</a>
<a name="ln221">#endif</a>
<a name="ln222">  for(int j = roi-&gt;crop_y; j &lt; roi-&gt;height - roi-&gt;crop_height; j++)</a>
<a name="ln223">  {</a>
<a name="ln224">    uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * omp_get_thread_num();</a>
<a name="ln225">    Worker(histogram_params, pixel, thread_hist, j);</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">#ifdef _OPENMP</a>
<a name="ln229">  *histogram = realloc(*histogram, buf_size);</a>
<a name="ln230">  memset(*histogram, 0, buf_size);</a>
<a name="ln231">  uint32_t *hist = *histogram;</a>
<a name="ln232"> </a>
<a name="ln233">#pragma omp parallel for schedule(static) default(none) shared(hist, partial_hists)</a>
<a name="ln234">  for(size_t k = 0; k &lt; bins_total; k++)</a>
<a name="ln235">  {</a>
<a name="ln236">    for(size_t n = 0; n &lt; nthreads; n++)</a>
<a name="ln237">    {</a>
<a name="ln238">      const uint32_t *thread_hist = (uint32_t *)partial_hists + bins_total * n;</a>
<a name="ln239">      hist[k] += thread_hist[k];</a>
<a name="ln240">    }</a>
<a name="ln241">  }</a>
<a name="ln242">#else</a>
<a name="ln243">  *histogram = realloc(*histogram, buf_size);</a>
<a name="ln244">  memmove(*histogram, partial_hists, buf_size);</a>
<a name="ln245">#endif</a>
<a name="ln246">  free(partial_hists);</a>
<a name="ln247"> </a>
<a name="ln248">  histogram_stats-&gt;bins_count = histogram_params-&gt;bins_count;</a>
<a name="ln249">  histogram_stats-&gt;pixels = (roi-&gt;width - roi-&gt;crop_width - roi-&gt;crop_x)</a>
<a name="ln250">                            * (roi-&gt;height - roi-&gt;crop_height - roi-&gt;crop_y);</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">//------------------------------------------------------------------------------</a>
<a name="ln254"> </a>
<a name="ln255">void dt_histogram_helper(dt_dev_histogram_collection_params_t *histogram_params,</a>
<a name="ln256">                         dt_dev_histogram_stats_t *histogram_stats, dt_iop_colorspace_type_t cst,</a>
<a name="ln257">                         const void *pixel, uint32_t **histogram)</a>
<a name="ln258">{</a>
<a name="ln259">  switch(cst)</a>
<a name="ln260">  {</a>
<a name="ln261">    case iop_cs_RAW:</a>
<a name="ln262">      dt_histogram_worker(histogram_params, histogram_stats, pixel, histogram, histogram_helper_cs_RAW);</a>
<a name="ln263">      histogram_stats-&gt;ch = 1u;</a>
<a name="ln264">      break;</a>
<a name="ln265"> </a>
<a name="ln266">    case iop_cs_rgb:</a>
<a name="ln267">      dt_histogram_worker(histogram_params, histogram_stats, pixel, histogram, histogram_helper_cs_rgb);</a>
<a name="ln268">      histogram_stats-&gt;ch = 3u;</a>
<a name="ln269">      break;</a>
<a name="ln270"> </a>
<a name="ln271">    case iop_cs_Lab:</a>
<a name="ln272">    default:</a>
<a name="ln273">      dt_histogram_worker(histogram_params, histogram_stats, pixel, histogram, histogram_helper_cs_Lab);</a>
<a name="ln274">      histogram_stats-&gt;ch = 3u;</a>
<a name="ln275">      break;</a>
<a name="ln276">  }</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">void dt_histogram_max_helper(const dt_dev_histogram_stats_t *const histogram_stats,</a>
<a name="ln280">                             dt_iop_colorspace_type_t cst, uint32_t **histogram, uint32_t *histogram_max)</a>
<a name="ln281">{</a>
<a name="ln282">  if(*histogram == NULL) return;</a>
<a name="ln283">  histogram_max[0] = histogram_max[1] = histogram_max[2] = histogram_max[3] = 0;</a>
<a name="ln284">  uint32_t *hist = *histogram;</a>
<a name="ln285">  switch(cst)</a>
<a name="ln286">  {</a>
<a name="ln287">    case iop_cs_RAW:</a>
<a name="ln288">      for(int k = 0; k &lt; 4 * histogram_stats-&gt;bins_count; k += 4)</a>
<a name="ln289">        histogram_max[0] = histogram_max[0] &gt; hist[k] ? histogram_max[0] : hist[k];</a>
<a name="ln290">      break;</a>
<a name="ln291"> </a>
<a name="ln292">    case iop_cs_rgb:</a>
<a name="ln293">      // don't count &lt;= 0 pixels</a>
<a name="ln294">      for(int k = 4; k &lt; 4 * histogram_stats-&gt;bins_count; k += 4)</a>
<a name="ln295">        histogram_max[0] = histogram_max[0] &gt; hist[k] ? histogram_max[0] : hist[k];</a>
<a name="ln296">      for(int k = 5; k &lt; 4 * histogram_stats-&gt;bins_count; k += 4)</a>
<a name="ln297">        histogram_max[1] = histogram_max[1] &gt; hist[k] ? histogram_max[1] : hist[k];</a>
<a name="ln298">      for(int k = 6; k &lt; 4 * histogram_stats-&gt;bins_count; k += 4)</a>
<a name="ln299">        histogram_max[2] = histogram_max[2] &gt; hist[k] ? histogram_max[2] : hist[k];</a>
<a name="ln300">      for(int k = 7; k &lt; 4 * histogram_stats-&gt;bins_count; k += 4)</a>
<a name="ln301">        histogram_max[3] = histogram_max[3] &gt; hist[k] ? histogram_max[3] : hist[k];</a>
<a name="ln302">      break;</a>
<a name="ln303"> </a>
<a name="ln304">    case iop_cs_Lab:</a>
<a name="ln305">    default:</a>
<a name="ln306">      // don't count &lt;= 0 pixels in L</a>
<a name="ln307">      for(int k = 4; k &lt; 4 * histogram_stats-&gt;bins_count; k += 4)</a>
<a name="ln308">        histogram_max[0] = histogram_max[0] &gt; hist[k] ? histogram_max[0] : hist[k];</a>
<a name="ln309"> </a>
<a name="ln310">      // don't count &lt;= -128 and &gt;= +128 pixels in a and b</a>
<a name="ln311">      for(int k = 5; k &lt; 4 * (histogram_stats-&gt;bins_count - 1); k += 4)</a>
<a name="ln312">        histogram_max[1] = histogram_max[1] &gt; hist[k] ? histogram_max[1] : hist[k];</a>
<a name="ln313">      for(int k = 6; k &lt; 4 * (histogram_stats-&gt;bins_count - 1); k += 4)</a>
<a name="ln314">        histogram_max[2] = histogram_max[2] &gt; hist[k] ? histogram_max[2] : hist[k];</a>
<a name="ln315">      break;</a>
<a name="ln316">  }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln320">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln321">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The '(uint32_t *) partial_hists' pointer in the expression could be nullptr. In such case, resulting value of arithmetic operations on this pointer will be senseless and it should not be used. Check lines: 224, 213.</p></div>
<div class="balloon" rel="229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v701/" target="_blank">V701</a> realloc() possible leak: when realloc() fails in allocating memory, original pointer '* histogram' is lost. Consider assigning realloc() to a temporary pointer.</p></div>
<div class="balloon" rel="239"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'thread_hist'. Check lines: 239, 213.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
