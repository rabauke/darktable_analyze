
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011--2013 johannes hanika.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/exif.h&quot;</a>
<a name="ln23">#include &quot;common/noiseprofiles.h&quot;</a>
<a name="ln24">#include &quot;common/opencl.h&quot;</a>
<a name="ln25">#include &quot;control/control.h&quot;</a>
<a name="ln26">#include &quot;develop/blend.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln29">#include &quot;develop/tiling.h&quot;</a>
<a name="ln30">#include &quot;dtgtk/drawingarea.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;gui/presets.h&quot;</a>
<a name="ln34">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln37">#include &lt;math.h&gt;</a>
<a name="ln38">#include &lt;stdlib.h&gt;</a>
<a name="ln39">#if defined(__SSE__)</a>
<a name="ln40">#include &lt;xmmintrin.h&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#define REDUCESIZE 64</a>
<a name="ln44">#define NUM_BUCKETS 4</a>
<a name="ln45"> </a>
<a name="ln46">#define DT_IOP_DENOISE_PROFILE_INSET DT_PIXEL_APPLY_DPI(5)</a>
<a name="ln47">#define DT_IOP_DENOISE_PROFILE_RES 64</a>
<a name="ln48">#define DT_IOP_DENOISE_PROFILE_V8_BANDS 5</a>
<a name="ln49">#define DT_IOP_DENOISE_PROFILE_BANDS 7</a>
<a name="ln50"> </a>
<a name="ln51">// the following fulcrum is used to help user to set shadows and strength</a>
<a name="ln52">// parameters.</a>
<a name="ln53">// applying precondition on this value will give the same value even</a>
<a name="ln54">// if shadows slider is changed, as strength will be adjusted to</a>
<a name="ln55">// guarantee that.</a>
<a name="ln56">// from a user point of view, it separates &quot;shadows&quot; area from the rest</a>
<a name="ln57">// of the image.</a>
<a name="ln58">#define DT_IOP_DENOISE_PROFILE_P_FULCRUM 0.05f</a>
<a name="ln59"> </a>
<a name="ln60">typedef enum dt_iop_denoiseprofile_mode_t {</a>
<a name="ln61">  MODE_NLMEANS = 0,</a>
<a name="ln62">  MODE_WAVELETS = 1,</a>
<a name="ln63">  MODE_VARIANCE = 2,</a>
<a name="ln64">  MODE_NLMEANS_AUTO = 3,</a>
<a name="ln65">  MODE_WAVELETS_AUTO = 4</a>
<a name="ln66">} dt_iop_denoiseprofile_mode_t;</a>
<a name="ln67"> </a>
<a name="ln68">typedef enum dt_iop_denoiseprofile_channel_t</a>
<a name="ln69">{</a>
<a name="ln70">  DT_DENOISE_PROFILE_ALL = 0,</a>
<a name="ln71">  DT_DENOISE_PROFILE_R = 1,</a>
<a name="ln72">  DT_DENOISE_PROFILE_G = 2,</a>
<a name="ln73">  DT_DENOISE_PROFILE_B = 3,</a>
<a name="ln74">  DT_DENOISE_PROFILE_NONE = 4</a>
<a name="ln75">} dt_iop_denoiseprofile_channel_t;</a>
<a name="ln76"> </a>
<a name="ln77">// this is the version of the modules parameters,</a>
<a name="ln78">// and includes version information about compile-time dt</a>
<a name="ln79">DT_MODULE_INTROSPECTION(9, dt_iop_denoiseprofile_params_t)</a>
<a name="ln80"> </a>
<a name="ln81">typedef struct dt_iop_denoiseprofile_params_v1_t</a>
<a name="ln82">{</a>
<a name="ln83">  float radius;     // search radius</a>
<a name="ln84">  float strength;   // noise level after equalization</a>
<a name="ln85">  float a[3], b[3]; // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln86">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln87">} dt_iop_denoiseprofile_params_v1_t;</a>
<a name="ln88"> </a>
<a name="ln89">typedef struct dt_iop_denoiseprofile_params_v4_t</a>
<a name="ln90">{</a>
<a name="ln91">  float radius;     // search radius</a>
<a name="ln92">  float strength;   // noise level after equalization</a>
<a name="ln93">  float a[3], b[3]; // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln94">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln95">  float x[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS];</a>
<a name="ln96">  float y[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS]; // values to change wavelet force by frequency</a>
<a name="ln97">} dt_iop_denoiseprofile_params_v4_t;</a>
<a name="ln98"> </a>
<a name="ln99">typedef struct dt_iop_denoiseprofile_params_v5_t</a>
<a name="ln100">{</a>
<a name="ln101">  float radius;                      // patch size</a>
<a name="ln102">  float nbhood;                      // search radius</a>
<a name="ln103">  float strength;                    // noise level after equalization</a>
<a name="ln104">  float a[3], b[3];                  // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln105">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln106">  float x[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS];</a>
<a name="ln107">  float y[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS]; // values to change wavelet force by frequency</a>
<a name="ln108">} dt_iop_denoiseprofile_params_v5_t;</a>
<a name="ln109"> </a>
<a name="ln110">typedef struct dt_iop_denoiseprofile_params_v6_t</a>
<a name="ln111">{</a>
<a name="ln112">  float radius;                      // patch size</a>
<a name="ln113">  float nbhood;                      // search radius</a>
<a name="ln114">  float strength;                    // noise level after equalization</a>
<a name="ln115">  float scattering;                  // spread the patch search zone without increasing number of patches</a>
<a name="ln116">  float a[3], b[3];                  // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln117">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln118">  float x[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS];</a>
<a name="ln119">  float y[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS]; // values to change wavelet force by frequency</a>
<a name="ln120">} dt_iop_denoiseprofile_params_v6_t;</a>
<a name="ln121"> </a>
<a name="ln122">typedef struct dt_iop_denoiseprofile_params_v7_t</a>
<a name="ln123">{</a>
<a name="ln124">  float radius;                      // patch size</a>
<a name="ln125">  float nbhood;                      // search radius</a>
<a name="ln126">  float strength;                    // noise level after equalization</a>
<a name="ln127">  float scattering;                  // spread the patch search zone without increasing number of patches</a>
<a name="ln128">  float central_pixel_weight;        // increase central pixel's weight in patch comparison</a>
<a name="ln129">  float a[3], b[3];                  // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln130">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln131">  float x[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS];</a>
<a name="ln132">  float y[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS]; // values to change wavelet force by frequency</a>
<a name="ln133">  gboolean wb_adaptive_anscombe; // whether to adapt anscombe transform to wb coeffs</a>
<a name="ln134">  // backward compatibility options</a>
<a name="ln135">  gboolean fix_anscombe_and_nlmeans_norm;</a>
<a name="ln136">} dt_iop_denoiseprofile_params_v7_t;</a>
<a name="ln137"> </a>
<a name="ln138">typedef struct dt_iop_denoiseprofile_params_v8_t</a>
<a name="ln139">{</a>
<a name="ln140">  float radius;     // patch size</a>
<a name="ln141">  float nbhood;     // search radius</a>
<a name="ln142">  float strength;   // noise level after equalization</a>
<a name="ln143">  float shadows;    // control the impact on shadows</a>
<a name="ln144">  float bias;       // allows to reduce backtransform bias</a>
<a name="ln145">  float scattering; // spread the patch search zone without increasing number of patches</a>
<a name="ln146">  float central_pixel_weight; // increase central pixel's weight in patch comparison</a>
<a name="ln147">  float overshooting; // adjusts the way parameters are autoset</a>
<a name="ln148">  float a[3], b[3]; // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln149">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln150">  float x[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS];</a>
<a name="ln151">  float y[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_V8_BANDS]; // values to change wavelet force by frequency</a>
<a name="ln152">  gboolean wb_adaptive_anscombe; // whether to adapt anscombe transform to wb coeffs</a>
<a name="ln153">  // backward compatibility options</a>
<a name="ln154">  gboolean fix_anscombe_and_nlmeans_norm;</a>
<a name="ln155">  gboolean use_new_vst;</a>
<a name="ln156">} dt_iop_denoiseprofile_params_v8_t;</a>
<a name="ln157"> </a>
<a name="ln158">typedef struct dt_iop_denoiseprofile_params_t</a>
<a name="ln159">{</a>
<a name="ln160">  float radius;     // patch size</a>
<a name="ln161">  float nbhood;     // search radius</a>
<a name="ln162">  float strength;   // noise level after equalization</a>
<a name="ln163">  float shadows;    // control the impact on shadows</a>
<a name="ln164">  float bias;       // allows to reduce backtransform bias</a>
<a name="ln165">  float scattering; // spread the patch search zone without increasing number of patches</a>
<a name="ln166">  float central_pixel_weight; // increase central pixel's weight in patch comparison</a>
<a name="ln167">  float overshooting; // adjusts the way parameters are autoset</a>
<a name="ln168">  float a[3], b[3]; // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln169">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln170">  float x[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_BANDS];</a>
<a name="ln171">  float y[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_BANDS]; // values to change wavelet force by frequency</a>
<a name="ln172">  gboolean wb_adaptive_anscombe; // whether to adapt anscombe transform to wb coeffs</a>
<a name="ln173">  // backward compatibility options</a>
<a name="ln174">  gboolean fix_anscombe_and_nlmeans_norm;</a>
<a name="ln175">  gboolean use_new_vst;</a>
<a name="ln176">} dt_iop_denoiseprofile_params_t;</a>
<a name="ln177"> </a>
<a name="ln178">typedef struct dt_iop_denoiseprofile_gui_data_t</a>
<a name="ln179">{</a>
<a name="ln180">  GtkWidget *profile;</a>
<a name="ln181">  GtkWidget *mode;</a>
<a name="ln182">  GtkWidget *radius;</a>
<a name="ln183">  GtkWidget *nbhood;</a>
<a name="ln184">  GtkWidget *strength;</a>
<a name="ln185">  GtkWidget *shadows;</a>
<a name="ln186">  GtkWidget *bias;</a>
<a name="ln187">  GtkWidget *scattering;</a>
<a name="ln188">  GtkWidget *central_pixel_weight;</a>
<a name="ln189">  GtkWidget *overshooting;</a>
<a name="ln190">  dt_noiseprofile_t interpolated; // don't use name, maker or model, they may point to garbage</a>
<a name="ln191">  GList *profiles;</a>
<a name="ln192">  GtkWidget *box_nlm;</a>
<a name="ln193">  GtkWidget *box_wavelets;</a>
<a name="ln194">  GtkWidget *box_variance;</a>
<a name="ln195">  dt_draw_curve_t *transition_curve; // curve for gui to draw</a>
<a name="ln196">  GtkDrawingArea *area;</a>
<a name="ln197">  GtkNotebook *channel_tabs;</a>
<a name="ln198">  double mouse_x, mouse_y, mouse_pick;</a>
<a name="ln199">  float mouse_radius;</a>
<a name="ln200">  dt_iop_denoiseprofile_params_t drag_params;</a>
<a name="ln201">  int dragging;</a>
<a name="ln202">  int x_move;</a>
<a name="ln203">  dt_iop_denoiseprofile_channel_t channel;</a>
<a name="ln204">  float draw_xs[DT_IOP_DENOISE_PROFILE_RES], draw_ys[DT_IOP_DENOISE_PROFILE_RES];</a>
<a name="ln205">  float draw_min_xs[DT_IOP_DENOISE_PROFILE_RES], draw_min_ys[DT_IOP_DENOISE_PROFILE_RES];</a>
<a name="ln206">  float draw_max_xs[DT_IOP_DENOISE_PROFILE_RES], draw_max_ys[DT_IOP_DENOISE_PROFILE_RES];</a>
<a name="ln207">  GtkWidget *wb_adaptive_anscombe;</a>
<a name="ln208">  GtkLabel *label_var;</a>
<a name="ln209">  float variance_R;</a>
<a name="ln210">  GtkLabel *label_var_R;</a>
<a name="ln211">  float variance_G;</a>
<a name="ln212">  GtkLabel *label_var_G;</a>
<a name="ln213">  float variance_B;</a>
<a name="ln214">  GtkLabel *label_var_B;</a>
<a name="ln215">  // backward compatibility options</a>
<a name="ln216">  GtkWidget *fix_anscombe_and_nlmeans_norm;</a>
<a name="ln217">  GtkWidget *use_new_vst;</a>
<a name="ln218">} dt_iop_denoiseprofile_gui_data_t;</a>
<a name="ln219"> </a>
<a name="ln220">typedef struct dt_iop_denoiseprofile_data_t</a>
<a name="ln221">{</a>
<a name="ln222">  float radius;                      // patch radius</a>
<a name="ln223">  float nbhood;                      // search radius</a>
<a name="ln224">  float strength;                    // noise level after equalization</a>
<a name="ln225">  float shadows;                     // controls noise reduction in shadows</a>
<a name="ln226">  float bias;                        // controls bias in backtransform</a>
<a name="ln227">  float scattering;                  // spread the search zone without changing number of patches</a>
<a name="ln228">  float central_pixel_weight;        // increase central pixel's weight in patch comparison</a>
<a name="ln229">  float overshooting;                // adjusts the way parameters are autoset</a>
<a name="ln230">  float a[3], b[3];                  // fit for poissonian-gaussian noise per color channel.</a>
<a name="ln231">  dt_iop_denoiseprofile_mode_t mode; // switch between nlmeans and wavelets</a>
<a name="ln232">  dt_draw_curve_t *curve[DT_DENOISE_PROFILE_NONE];</a>
<a name="ln233">  dt_iop_denoiseprofile_channel_t channel;</a>
<a name="ln234">  float force[DT_DENOISE_PROFILE_NONE][DT_IOP_DENOISE_PROFILE_BANDS];</a>
<a name="ln235">  gboolean wb_adaptive_anscombe; // whether to adapt anscombe transform to wb coeffs</a>
<a name="ln236">  // backward compatibility options</a>
<a name="ln237">  gboolean fix_anscombe_and_nlmeans_norm;</a>
<a name="ln238">  gboolean use_new_vst;</a>
<a name="ln239">} dt_iop_denoiseprofile_data_t;</a>
<a name="ln240"> </a>
<a name="ln241">typedef struct dt_iop_denoiseprofile_global_data_t</a>
<a name="ln242">{</a>
<a name="ln243">  int kernel_denoiseprofile_precondition;</a>
<a name="ln244">  int kernel_denoiseprofile_precondition_v2;</a>
<a name="ln245">  int kernel_denoiseprofile_init;</a>
<a name="ln246">  int kernel_denoiseprofile_dist;</a>
<a name="ln247">  int kernel_denoiseprofile_horiz;</a>
<a name="ln248">  int kernel_denoiseprofile_vert;</a>
<a name="ln249">  int kernel_denoiseprofile_accu;</a>
<a name="ln250">  int kernel_denoiseprofile_finish;</a>
<a name="ln251">  int kernel_denoiseprofile_finish_v2;</a>
<a name="ln252">  int kernel_denoiseprofile_backtransform;</a>
<a name="ln253">  int kernel_denoiseprofile_backtransform_v2;</a>
<a name="ln254">  int kernel_denoiseprofile_decompose;</a>
<a name="ln255">  int kernel_denoiseprofile_synthesize;</a>
<a name="ln256">  int kernel_denoiseprofile_reduce_first;</a>
<a name="ln257">  int kernel_denoiseprofile_reduce_second;</a>
<a name="ln258">} dt_iop_denoiseprofile_global_data_t;</a>
<a name="ln259"> </a>
<a name="ln260">static dt_noiseprofile_t dt_iop_denoiseprofile_get_auto_profile(dt_iop_module_t *self);</a>
<a name="ln261"> </a>
<a name="ln262">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln263">                  void *new_params, const int new_version)</a>
<a name="ln264">{</a>
<a name="ln265">  if((old_version == 1 || old_version == 2 || old_version == 3) &amp;&amp; new_version == 4)</a>
<a name="ln266">  {</a>
<a name="ln267">    const dt_iop_denoiseprofile_params_v1_t *o = old_params;</a>
<a name="ln268">    dt_iop_denoiseprofile_params_v4_t *n = new_params;</a>
<a name="ln269">    if(old_version == 1)</a>
<a name="ln270">    {</a>
<a name="ln271">      n-&gt;mode = MODE_NLMEANS;</a>
<a name="ln272">    }</a>
<a name="ln273">    else</a>
<a name="ln274">    {</a>
<a name="ln275">      n-&gt;mode = o-&gt;mode;</a>
<a name="ln276">    }</a>
<a name="ln277">    n-&gt;radius = o-&gt;radius;</a>
<a name="ln278">    n-&gt;strength = o-&gt;strength;</a>
<a name="ln279">    memcpy(n-&gt;a, o-&gt;a, sizeof(float) * 3);</a>
<a name="ln280">    memcpy(n-&gt;b, o-&gt;b, sizeof(float) * 3);</a>
<a name="ln281">    // init curves coordinates</a>
<a name="ln282">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_V8_BANDS; b++)</a>
<a name="ln283">    {</a>
<a name="ln284">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln285">      {</a>
<a name="ln286">        n-&gt;x[c][b] = b / (DT_IOP_DENOISE_PROFILE_V8_BANDS - 1.0f);</a>
<a name="ln287">        n-&gt;y[c][b] = 0.5f;</a>
<a name="ln288">      }</a>
<a name="ln289">    }</a>
<a name="ln290">    // autodetect current profile:</a>
<a name="ln291">    if(!self-&gt;dev)</a>
<a name="ln292">    {</a>
<a name="ln293">      // we are probably handling a style or preset, do nothing for them, we can't do anything to detect if</a>
<a name="ln294">      // autodetection was used or not</a>
<a name="ln295">      return 0;</a>
<a name="ln296">    }</a>
<a name="ln297">    dt_noiseprofile_t interpolated = dt_iop_denoiseprofile_get_auto_profile(self);</a>
<a name="ln298">    // if the profile in old_version is an autodetected one (this would mean a+b params match the interpolated</a>
<a name="ln299">    // one, AND</a>
<a name="ln300">    // the profile is actually the first selected one - however we can only detect the params, but most people</a>
<a name="ln301">    // did probably</a>
<a name="ln302">    // not set the exact ISO on purpose instead of the &quot;found match&quot; - they probably still want</a>
<a name="ln303">    // autodetection!)</a>
<a name="ln304">    if(!memcmp(interpolated.a, o-&gt;a, sizeof(float) * 3) &amp;&amp; !memcmp(interpolated.b, o-&gt;b, sizeof(float) * 3))</a>
<a name="ln305">    {</a>
<a name="ln306">      // set the param a[0] to -1.0 to signal the autodetection</a>
<a name="ln307">      n-&gt;a[0] = -1.0f;</a>
<a name="ln308">    }</a>
<a name="ln309">    return 0;</a>
<a name="ln310">  }</a>
<a name="ln311">  else if(new_version == 5)</a>
<a name="ln312">  {</a>
<a name="ln313">    dt_iop_denoiseprofile_params_v4_t v4;</a>
<a name="ln314">    if(old_version &lt; 4)</a>
<a name="ln315">    {</a>
<a name="ln316">      // first update to v4</a>
<a name="ln317">      if(legacy_params(self, old_params, old_version, &amp;v4, 4))</a>
<a name="ln318">        return 1;</a>
<a name="ln319">    }</a>
<a name="ln320">    else</a>
<a name="ln321">      memcpy(&amp;v4, old_params, sizeof(v4)); // was v4 already</a>
<a name="ln322"> </a>
<a name="ln323">    dt_iop_denoiseprofile_params_v5_t *v5 = new_params;</a>
<a name="ln324">    v5-&gt;radius = v4.radius;</a>
<a name="ln325">    v5-&gt;strength = v4.strength;</a>
<a name="ln326">    v5-&gt;mode = v4.mode;</a>
<a name="ln327">    for(int k=0;k&lt;3;k++)</a>
<a name="ln328">    {</a>
<a name="ln329">      v5-&gt;a[k] = v4.a[k];</a>
<a name="ln330">      v5-&gt;b[k] = v4.b[k];</a>
<a name="ln331">    }</a>
<a name="ln332">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_V8_BANDS; b++)</a>
<a name="ln333">    {</a>
<a name="ln334">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln335">      {</a>
<a name="ln336">        v5-&gt;x[c][b] = v4.x[c][b];</a>
<a name="ln337">        v5-&gt;y[c][b] = v4.y[c][b];</a>
<a name="ln338">      }</a>
<a name="ln339">    }</a>
<a name="ln340">    v5-&gt;nbhood = 7; // set to old hardcoded default</a>
<a name="ln341">    return 0;</a>
<a name="ln342">  }</a>
<a name="ln343">  else if(new_version == 6)</a>
<a name="ln344">  {</a>
<a name="ln345">    dt_iop_denoiseprofile_params_v5_t v5;</a>
<a name="ln346">    if(old_version &lt; 5)</a>
<a name="ln347">    {</a>
<a name="ln348">      // first update to v5</a>
<a name="ln349">      if(legacy_params(self, old_params, old_version, &amp;v5, 5)) return 1;</a>
<a name="ln350">    }</a>
<a name="ln351">    else</a>
<a name="ln352">      memcpy(&amp;v5, old_params, sizeof(v5)); // was v5 already</a>
<a name="ln353"> </a>
<a name="ln354">    dt_iop_denoiseprofile_params_v6_t *v6 = new_params;</a>
<a name="ln355">    v6-&gt;radius = v5.radius;</a>
<a name="ln356">    v6-&gt;strength = v5.strength;</a>
<a name="ln357">    v6-&gt;mode = v5.mode;</a>
<a name="ln358">    v6-&gt;nbhood = v5.nbhood;</a>
<a name="ln359">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln360">    {</a>
<a name="ln361">      v6-&gt;a[k] = v5.a[k];</a>
<a name="ln362">      v6-&gt;b[k] = v5.b[k];</a>
<a name="ln363">    }</a>
<a name="ln364">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_V8_BANDS; b++)</a>
<a name="ln365">    {</a>
<a name="ln366">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln367">      {</a>
<a name="ln368">        v6-&gt;x[c][b] = v5.x[c][b];</a>
<a name="ln369">        v6-&gt;y[c][b] = v5.y[c][b];</a>
<a name="ln370">      }</a>
<a name="ln371">    }</a>
<a name="ln372">    v6-&gt;scattering = 0.0; // no scattering</a>
<a name="ln373">    return 0;</a>
<a name="ln374">  }</a>
<a name="ln375">  else if(new_version == 7)</a>
<a name="ln376">  {</a>
<a name="ln377">    dt_iop_denoiseprofile_params_v6_t v6;</a>
<a name="ln378">    if(old_version &lt; 6)</a>
<a name="ln379">    {</a>
<a name="ln380">      // first update to v6</a>
<a name="ln381">      if(legacy_params(self, old_params, old_version, &amp;v6, 6)) return 1;</a>
<a name="ln382">    }</a>
<a name="ln383">    else</a>
<a name="ln384">      memcpy(&amp;v6, old_params, sizeof(v6)); // was v6 already</a>
<a name="ln385">    dt_iop_denoiseprofile_params_v7_t *v7 = new_params;</a>
<a name="ln386">    v7-&gt;radius = v6.radius;</a>
<a name="ln387">    v7-&gt;strength = v6.strength;</a>
<a name="ln388">    v7-&gt;mode = v6.mode;</a>
<a name="ln389">    v7-&gt;nbhood = v6.nbhood;</a>
<a name="ln390">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln391">    {</a>
<a name="ln392">      v7-&gt;a[k] = v6.a[k];</a>
<a name="ln393">      v7-&gt;b[k] = v6.b[k];</a>
<a name="ln394">    }</a>
<a name="ln395">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_V8_BANDS; b++)</a>
<a name="ln396">    {</a>
<a name="ln397">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln398">      {</a>
<a name="ln399">        v7-&gt;x[c][b] = v6.x[c][b];</a>
<a name="ln400">        v7-&gt;y[c][b] = v6.y[c][b];</a>
<a name="ln401">      }</a>
<a name="ln402">    }</a>
<a name="ln403">    v7-&gt;scattering = v6.scattering;</a>
<a name="ln404">    v7-&gt;central_pixel_weight = 0.0;</a>
<a name="ln405">    v7-&gt;fix_anscombe_and_nlmeans_norm = FALSE; // don't fix anscombe and norm to ensure backward compatibility</a>
<a name="ln406">    v7-&gt;wb_adaptive_anscombe = TRUE;</a>
<a name="ln407">    return 0;</a>
<a name="ln408">  }</a>
<a name="ln409">  else if(new_version == 8)</a>
<a name="ln410">  {</a>
<a name="ln411">    dt_iop_denoiseprofile_params_v7_t v7;</a>
<a name="ln412">    if(old_version &lt; 7)</a>
<a name="ln413">    {</a>
<a name="ln414">      // first update to v7</a>
<a name="ln415">      if(legacy_params(self, old_params, old_version, &amp;v7, 7)) return 1;</a>
<a name="ln416">    }</a>
<a name="ln417">    else</a>
<a name="ln418">      memcpy(&amp;v7, old_params, sizeof(v7)); // was v7 already</a>
<a name="ln419">    dt_iop_denoiseprofile_params_v8_t *v8 = new_params;</a>
<a name="ln420">    v8-&gt;radius = v7.radius;</a>
<a name="ln421">    v8-&gt;strength = v7.strength;</a>
<a name="ln422">    v8-&gt;mode = v7.mode;</a>
<a name="ln423">    v8-&gt;nbhood = v7.nbhood;</a>
<a name="ln424">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln425">    {</a>
<a name="ln426">      v8-&gt;a[k] = v7.a[k];</a>
<a name="ln427">      v8-&gt;b[k] = v7.b[k];</a>
<a name="ln428">    }</a>
<a name="ln429">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_V8_BANDS; b++)</a>
<a name="ln430">    {</a>
<a name="ln431">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln432">      {</a>
<a name="ln433">        v8-&gt;x[c][b] = v7.x[c][b];</a>
<a name="ln434">        v8-&gt;y[c][b] = v7.y[c][b];</a>
<a name="ln435">      }</a>
<a name="ln436">    }</a>
<a name="ln437">    v8-&gt;scattering = v7.scattering;</a>
<a name="ln438">    v8-&gt;central_pixel_weight = v7.central_pixel_weight;</a>
<a name="ln439">    v8-&gt;fix_anscombe_and_nlmeans_norm = v7.fix_anscombe_and_nlmeans_norm;</a>
<a name="ln440">    v8-&gt;wb_adaptive_anscombe = v7.wb_adaptive_anscombe;</a>
<a name="ln441">    v8-&gt;shadows = 1.0f;</a>
<a name="ln442">    v8-&gt;bias = 0.0f;</a>
<a name="ln443">    v8-&gt;use_new_vst = FALSE;</a>
<a name="ln444">    v8-&gt;overshooting = 1.0f;</a>
<a name="ln445">    return 0;</a>
<a name="ln446">  }</a>
<a name="ln447">  else if(new_version == 9)</a>
<a name="ln448">  {</a>
<a name="ln449">    dt_iop_denoiseprofile_params_v8_t v8;</a>
<a name="ln450">    if(old_version &lt; 8)</a>
<a name="ln451">    {</a>
<a name="ln452">      // first update to v8</a>
<a name="ln453">      if(legacy_params(self, old_params, old_version, &amp;v8, 8)) return 1;</a>
<a name="ln454">    }</a>
<a name="ln455">    else</a>
<a name="ln456">      memcpy(&amp;v8, old_params, sizeof(v8)); // was v8 already</a>
<a name="ln457">    dt_iop_denoiseprofile_params_t *v9 = new_params;</a>
<a name="ln458">    v9-&gt;radius = v8.radius;</a>
<a name="ln459">    v9-&gt;strength = v8.strength;</a>
<a name="ln460">    v9-&gt;mode = v8.mode;</a>
<a name="ln461">    v9-&gt;nbhood = v8.nbhood;</a>
<a name="ln462">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln463">    {</a>
<a name="ln464">      v9-&gt;a[k] = v8.a[k];</a>
<a name="ln465">      v9-&gt;b[k] = v8.b[k];</a>
<a name="ln466">    }</a>
<a name="ln467">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_BANDS; b++)</a>
<a name="ln468">    {</a>
<a name="ln469">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln470">      {</a>
<a name="ln471">        v9-&gt;x[c][b] = b / (DT_IOP_DENOISE_PROFILE_BANDS - 1.0f);</a>
<a name="ln472">        v9-&gt;y[c][b] = 0.0f;</a>
<a name="ln473">      }</a>
<a name="ln474">    }</a>
<a name="ln475">    for(int b = 0; b &lt; DT_IOP_DENOISE_PROFILE_V8_BANDS; b++)</a>
<a name="ln476">    {</a>
<a name="ln477">      for(int c = 0; c &lt; DT_DENOISE_PROFILE_NONE; c++)</a>
<a name="ln478">      {</a>
<a name="ln479">        v9-&gt;y[c][b + DT_IOP_DENOISE_PROFILE_BANDS - DT_IOP_DENOISE_PROFILE_V8_BANDS] = v8.y[c][b];</a>
<a name="ln480">      }</a>
<a name="ln481">    }</a>
<a name="ln482">    v9-&gt;scattering = v8.scattering;</a>
<a name="ln483">    v9-&gt;central_pixel_weight = v8.central_pixel_weight;</a>
<a name="ln484">    v9-&gt;fix_anscombe_and_nlmeans_norm = v8.fix_anscombe_and_nlmeans_norm;</a>
<a name="ln485">    v9-&gt;wb_adaptive_anscombe = v8.wb_adaptive_anscombe;</a>
<a name="ln486">    v9-&gt;shadows = v8.shadows;</a>
<a name="ln487">    v9-&gt;bias = v8.shadows;</a>
<a name="ln488">    v9-&gt;use_new_vst = v8.use_new_vst;</a>
<a name="ln489">    v9-&gt;overshooting = v8.overshooting;</a>
<a name="ln490">    return 0;</a>
<a name="ln491">  }</a>
<a name="ln492">  return 1;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495"> </a>
<a name="ln496">const char *name()</a>
<a name="ln497">{</a>
<a name="ln498">  return _(&quot;denoise (profiled)&quot;);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">int default_group()</a>
<a name="ln502">{</a>
<a name="ln503">  return IOP_GROUP_CORRECT;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">int flags()</a>
<a name="ln507">{</a>
<a name="ln508">  return IOP_FLAGS_SUPPORTS_BLENDING | IOP_FLAGS_ALLOW_TILING;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln512">{</a>
<a name="ln513">  return iop_cs_rgb;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">static void add_preset(</a>
<a name="ln517">    dt_iop_module_so_t *self, const char *name,</a>
<a name="ln518">    const char *pi,  const int version,</a>
<a name="ln519">    const char *bpi, const int blendop_version)</a>
<a name="ln520">{</a>
<a name="ln521">  int len, blen;</a>
<a name="ln522">  uint8_t *p  = dt_exif_xmp_decode(pi, strlen(pi), &amp;len);</a>
<a name="ln523">  uint8_t *bp = dt_exif_xmp_decode(bpi, strlen(bpi), &amp;blen);</a>
<a name="ln524">  if(blendop_version != dt_develop_blend_version())</a>
<a name="ln525">  {</a>
<a name="ln526">    // update to current blendop params format</a>
<a name="ln527">    void *bp_new = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln528"> </a>
<a name="ln529">    if(dt_develop_blend_legacy_params_from_so(self, bp, blendop_version, bp_new, dt_develop_blend_version(),</a>
<a name="ln530">      blen) == 0)</a>
<a name="ln531">    {</a>
<a name="ln532">      free(bp);</a>
<a name="ln533">      bp = bp_new;</a>
<a name="ln534">      blen = sizeof(dt_develop_blend_params_t);</a>
<a name="ln535">    }</a>
<a name="ln536">    else</a>
<a name="ln537">    {</a>
<a name="ln538">      free(bp);</a>
<a name="ln539">      free(bp_new);</a>
<a name="ln540">      bp = NULL;</a>
<a name="ln541">    }</a>
<a name="ln542">  }</a>
<a name="ln543"> </a>
<a name="ln544">  if(p &amp;&amp; bp)</a>
<a name="ln545">    dt_gui_presets_add_with_blendop(name, self-&gt;op, version, p, len, bp, 1);</a>
<a name="ln546">  free(bp);</a>
<a name="ln547">  free(p);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln551">{</a>
<a name="ln552">  // these blobs were exported as dtstyle and copied from there:</a>
<a name="ln553">  add_preset(self, _(&quot;chroma (use on 1st instance)&quot;),</a>
<a name="ln554">             &quot;gz03eJxjYGiwZ2B44MAApmEYBsD8/dti91vWKRhZcYsxmibv5THN2n3XhAWqYvUqLbvVq1bZAZn2QLZ9aGgo3AwayIGxeNQ/u+7l/+zMOFntD7wztpc9Ug+XoyZmBBIwDAC4Ejr7&quot;, 9,</a>
<a name="ln555">             &quot;gz11eJxjZGBgkGUAgRNODGiAEV0AJ2iwh+CRyscOAA9yGQo=&quot;, 9);</a>
<a name="ln556">  add_preset(self, _(&quot;luma (use on 2nd instance)&quot;),</a>
<a name="ln557">             &quot;gz03eJxjYGiwZ2B44DBr5kw7BjAbhGEAzN/vZxlg6T53n+UlPVXTRI7nJuGZ1qYsUBWrV2nZrV61CqiXwR7Itg8NDYWbQW25Svb/tvZCv22/6Py1PaGqbfe7fKGdYfYPu8LWpWC1NMAMjFAMAAFgQFE=&quot;, 9,</a>
<a name="ln558">             &quot;gz11eJxjZGBgkGEAgR4nBjTAiC6AEzTYQ/BI5WMHAL7TGM0=&quot;, 9);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">typedef union floatint_t</a>
<a name="ln562">{</a>
<a name="ln563">  float f;</a>
<a name="ln564">  uint32_t i;</a>
<a name="ln565">} floatint_t;</a>
<a name="ln566"> </a>
<a name="ln567">// very fast approximation for 2^-x (returns 0 for x &gt; 126)</a>
<a name="ln568">static inline float fast_mexp2f(const float x)</a>
<a name="ln569">{</a>
<a name="ln570">  const float i1 = (float)0x3f800000u; // 2^0</a>
<a name="ln571">  const float i2 = (float)0x3f000000u; // 2^-1</a>
<a name="ln572">  const float k0 = i1 + x * (i2 - i1);</a>
<a name="ln573">  floatint_t k;</a>
<a name="ln574">  k.i = k0 &gt;= (float)0x800000u ? k0 : 0;</a>
<a name="ln575">  return k.f;</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">void tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln579">                     const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln580">                     struct dt_develop_tiling_t *tiling)</a>
<a name="ln581">{</a>
<a name="ln582">  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece-&gt;data;</a>
<a name="ln583"> </a>
<a name="ln584">  if(d-&gt;mode == MODE_NLMEANS || d-&gt;mode == MODE_NLMEANS_AUTO)</a>
<a name="ln585">  {</a>
<a name="ln586">    const int P = ceilf(d-&gt;radius * fminf(roi_in-&gt;scale, 2.0f) / fmaxf(piece-&gt;iscale, 1.0f)); // pixel filter size</a>
<a name="ln587">    const int K = ceilf(d-&gt;nbhood * fminf(roi_in-&gt;scale, 2.0f) / fmaxf(piece-&gt;iscale, 1.0f)); // nbhood</a>
<a name="ln588">    const int K_scattered = ceilf(d-&gt;scattering * (K * K * K + 7.0 * K * sqrt(K)) / 6.0) + K;</a>
<a name="ln589"> </a>
<a name="ln590">    tiling-&gt;factor = 4.0f + 0.25f * NUM_BUCKETS; // in + out + (2 + NUM_BUCKETS * 0.25) tmp</a>
<a name="ln591">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln592">    tiling-&gt;overhead = 0;</a>
<a name="ln593">    tiling-&gt;overlap = P + K_scattered;</a>
<a name="ln594">    tiling-&gt;xalign = 1;</a>
<a name="ln595">    tiling-&gt;yalign = 1;</a>
<a name="ln596">  }</a>
<a name="ln597">  else</a>
<a name="ln598">  {</a>
<a name="ln599">    const int max_max_scale = 5; // hard limit</a>
<a name="ln600">    int max_scale = 0;</a>
<a name="ln601">    const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln602">    // largest desired filter on input buffer (20% of input dim)</a>
<a name="ln603">    const float supp0</a>
<a name="ln604">        = fminf(2 * (2u &lt;&lt; (max_max_scale - 1)) + 1,</a>
<a name="ln605">              fmaxf(piece-&gt;buf_in.height * piece-&gt;iscale, piece-&gt;buf_in.width * piece-&gt;iscale) * 0.2f);</a>
<a name="ln606">    const float i0 = dt_log2f((supp0 - 1.0f) * .5f);</a>
<a name="ln607">    for(; max_scale &lt; max_max_scale; max_scale++)</a>
<a name="ln608">    {</a>
<a name="ln609">      // actual filter support on scaled buffer</a>
<a name="ln610">      const float supp = 2 * (2u &lt;&lt; max_scale) + 1;</a>
<a name="ln611">      // approximates this filter size on unscaled input image:</a>
<a name="ln612">      const float supp_in = supp * (1.0f / scale);</a>
<a name="ln613">      const float i_in = dt_log2f((supp_in - 1) * .5f) - 1.0f;</a>
<a name="ln614">      // i_in = max_scale .. .. .. 0</a>
<a name="ln615">      const float t = 1.0f - (i_in + .5f) / i0;</a>
<a name="ln616">      if(t &lt; 0.0f) break;</a>
<a name="ln617">    }</a>
<a name="ln618"> </a>
<a name="ln619">    const int max_filter_radius = (1u &lt;&lt; max_scale); // 2 * 2^max_scale</a>
<a name="ln620"> </a>
<a name="ln621">    tiling-&gt;factor = 3.5f + max_scale; // in + out + tmp + reducebuffer + scale buffers</a>
<a name="ln622">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln623">    tiling-&gt;overhead = 0;</a>
<a name="ln624">    tiling-&gt;overlap = max_filter_radius;</a>
<a name="ln625">    tiling-&gt;xalign = 1;</a>
<a name="ln626">    tiling-&gt;yalign = 1;</a>
<a name="ln627">  }</a>
<a name="ln628"> </a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">static inline void precondition(const float *const in, float *const buf, const int wd, const int ht,</a>
<a name="ln632">                                const float a[3], const float b[3])</a>
<a name="ln633">{</a>
<a name="ln634">  const float sigma2_plus_3_8[3]</a>
<a name="ln635">      = { (b[0] / a[0]) * (b[0] / a[0]) + 3.f / 8.f,</a>
<a name="ln636">          (b[1] / a[1]) * (b[1] / a[1]) + 3.f / 8.f,</a>
<a name="ln637">          (b[2] / a[2]) * (b[2] / a[2]) + 3.f / 8.f };</a>
<a name="ln638"> </a>
<a name="ln639">#ifdef _OPENMP</a>
<a name="ln640">#pragma omp parallel for default(none) \</a>
<a name="ln641">  dt_omp_firstprivate(buf, ht, in, sigma2_plus_3_8, wd) \</a>
<a name="ln642">  shared(a) \</a>
<a name="ln643">  schedule(static)</a>
<a name="ln644">#endif</a>
<a name="ln645">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln646">  {</a>
<a name="ln647">    float *buf2 = buf + (size_t)4 * j * wd;</a>
<a name="ln648">    const float *in2 = in + (size_t)4 * j * wd;</a>
<a name="ln649">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln650">    {</a>
<a name="ln651">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln652">      {</a>
<a name="ln653">        const float d = fmaxf(0.0f, in2[c] / a[c] + sigma2_plus_3_8[c]);</a>
<a name="ln654">        buf2[c] = 2.0f * sqrtf(d);</a>
<a name="ln655">      }</a>
<a name="ln656">      buf2 += 4;</a>
<a name="ln657">      in2 += 4;</a>
<a name="ln658">    }</a>
<a name="ln659">  }</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">static inline void backtransform(float *const buf, const int wd, const int ht, const float a[3],</a>
<a name="ln663">                                 const float b[3])</a>
<a name="ln664">{</a>
<a name="ln665">  const float sigma2_plus_1_8[3]</a>
<a name="ln666">      = { (b[0] / a[0]) * (b[0] / a[0]) + 1.f / 8.f,</a>
<a name="ln667">          (b[1] / a[1]) * (b[1] / a[1]) + 1.f / 8.f,</a>
<a name="ln668">          (b[2] / a[2]) * (b[2] / a[2]) + 1.f / 8.f };</a>
<a name="ln669"> </a>
<a name="ln670">#ifdef _OPENMP</a>
<a name="ln671">#pragma omp parallel for default(none) \</a>
<a name="ln672">  dt_omp_firstprivate(buf, ht, sigma2_plus_1_8, wd) \</a>
<a name="ln673">  shared(a) \</a>
<a name="ln674">  schedule(static)</a>
<a name="ln675">#endif</a>
<a name="ln676">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln677">  {</a>
<a name="ln678">    float *buf2 = buf + (size_t)4 * j * wd;</a>
<a name="ln679">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln680">    {</a>
<a name="ln681">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln682">      {</a>
<a name="ln683">        const float x = buf2[c], x2 = x * x;</a>
<a name="ln684">        // closed form approximation to unbiased inverse (input range was 0..200 for fit, not 0..1)</a>
<a name="ln685">        if(x &lt; .5f)</a>
<a name="ln686">          buf2[c] = 0.0f;</a>
<a name="ln687">        else</a>
<a name="ln688">          buf2[c] = 1.f / 4.f * x2 + 1.f / 4.f * sqrtf(3.f / 2.f) / x - 11.f / 8.f / x2</a>
<a name="ln689">                    + 5.f / 8.f * sqrtf(3.f / 2.f) / (x * x2) - sigma2_plus_1_8[c];</a>
<a name="ln690">        // asymptotic form:</a>
<a name="ln691">        // buf2[c] = fmaxf(0.0f, 1./4.*x*x - 1./8. - sigma2[c]);</a>
<a name="ln692">        buf2[c] *= a[c];</a>
<a name="ln693">      }</a>
<a name="ln694">      buf2 += 4;</a>
<a name="ln695">    }</a>
<a name="ln696">  }</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">// the &quot;v2&quot; variance stabilizing transform is an extension of the generalized</a>
<a name="ln700">// anscombe transform.</a>
<a name="ln701">// In the generalized anscombe transform, the profiles gives a and b such as:</a>
<a name="ln702">// V(X) = a * E[X] + b</a>
<a name="ln703">// In this new transform, we have an additional parameter, p, such as:</a>
<a name="ln704">// V(X) = a * (E[X] + b) ^ p</a>
<a name="ln705">// When p == 1, we get back the equation of generalized anscombe transform.</a>
<a name="ln706">// Now, let's see how we derive the precondition.</a>
<a name="ln707">// The goal of a VST f is to make variance constant: V(f(X)) = constant</a>
<a name="ln708">// Using a Taylor expansion, we have:</a>
<a name="ln709">// V(f(X)) ~= V(f(E[X])+f'(X)(X-E[X]))</a>
<a name="ln710">//          = V(f'(X)(X-E[X]))</a>
<a name="ln711">//          = f'(X)^2 * V(X-E[X])</a>
<a name="ln712">//          = f'(X)^2 * V(X)</a>
<a name="ln713">// So the condition V(f(X)) = constant gives us the following condition:</a>
<a name="ln714">// V(X) = constant / f'(X)^2</a>
<a name="ln715">// Usually, we take constant = 1</a>
<a name="ln716">// If we have V(X) = a * (E[X] + b) ^ p</a>
<a name="ln717">// then: f'(X) = 1 / sqrt(a) * (E[X] + b) ^ (-p / 2)</a>
<a name="ln718">// then: f(x) = 1 / (sqrt(a) * (1 - p / 2)) * (x + b) ^ (1 - p / 2)</a>
<a name="ln719">//            = 2 * (x + b) ^ (1 - p / 2) / (sqrt(a) * (2 - p))</a>
<a name="ln720">// is a suitable function.</a>
<a name="ln721">// This is the function we use here.</a>
<a name="ln722">static inline void precondition_v2(const float *const in, float *const buf, const int wd, const int ht,</a>
<a name="ln723">                                   const float a, const float p[3], const float b, const float wb[3])</a>
<a name="ln724">{</a>
<a name="ln725">#ifdef _OPENMP</a>
<a name="ln726">#pragma omp parallel for default(none) \</a>
<a name="ln727">  dt_omp_firstprivate(buf, ht, in, wd, a, p, b, wb) \</a>
<a name="ln728">  schedule(static)</a>
<a name="ln729">#endif</a>
<a name="ln730">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln731">  {</a>
<a name="ln732">    float *buf2 = buf + (size_t)4 * j * wd;</a>
<a name="ln733">    const float *in2 = in + (size_t)4 * j * wd;</a>
<a name="ln734">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln735">    {</a>
<a name="ln736">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln737">      {</a>
<a name="ln738">        buf2[c] = 2.0f * powf(MAX(in2[c] / wb[c] + b, 0.0f), -p[c] / 2 + 1) / ((-p[c] + 2) * sqrt(a));</a>
<a name="ln739">      }</a>
<a name="ln740">      buf2 += 4;</a>
<a name="ln741">      in2 += 4;</a>
<a name="ln742">    }</a>
<a name="ln743">  }</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">// this backtransform aims at being a low bias backtransform</a>
<a name="ln747">// you can see that it is not equal to f-1</a>
<a name="ln748">// this is because E[X] != f-1(E[f(X)])</a>
<a name="ln749">// so let's try to find a better backtransform than f-1:</a>
<a name="ln750">// we want to find E[X] knowing E[f(X)]</a>
<a name="ln751">// let's apply Taylor expansion to E[f(X)] to see if we can get something better:</a>
<a name="ln752">// E[f(X)] ~= E[f(E[X]) + f'(E[X])(X-E[X])]</a>
<a name="ln753">//          = E[f(E[X]) + f'(E[X]) * X - f'(E[X]) * E[X]]</a>
<a name="ln754">//          = f(E[X]) + f'(E[X]) * E[X] - f'(E[X]) * E[X]</a>
<a name="ln755">//          = f(E[X])</a>
<a name="ln756">// so first order Taylor expansion is not useful.</a>
<a name="ln757">// going to the second order:</a>
<a name="ln758">// E[f(X)] ~= E[f(E[X]) + f'(E[X])(X-E[X]) + f&quot;(E[X])/2 * (X-E[X])^2]</a>
<a name="ln759">//          = f(E[X]) + f&quot;(E[X])/2 * E[(X-E[X])^2]</a>
<a name="ln760">//          = f(E[X]) + f&quot;(E[X])/2 * V(X)</a>
<a name="ln761">// and we know that V(X) = constant / f'(X)^2</a>
<a name="ln762">// the constant here is not 1, due to problems in noise profiling tool</a>
<a name="ln763">// so in fact constant depends on the image (and is approximately in [10;15])</a>
<a name="ln764">// so:</a>
<a name="ln765">// E[f(X)] ~= f(E[X]) + f&quot;(E[X])/2 * constant / f'(E[X])^2</a>
<a name="ln766">// we have:</a>
<a name="ln767">// f(x) = 2 * (x + b) ^ (1 - p / 2) / (sqrt(a) * (2 - p))</a>
<a name="ln768">// f'(x) = 1 / sqrt(a) * (x + b) ^ (-p / 2)</a>
<a name="ln769">// 1/f'(x)^2 = a * (x + b) ^ p</a>
<a name="ln770">// f&quot;(x) = 1 / sqrt(a) * (-p / 2) * (x + b) ^ (- p / 2 - 1)</a>
<a name="ln771">// let's replace f, f', and f&quot; by their analytical expressions in our equation:</a>
<a name="ln772">// let x = E[X]</a>
<a name="ln773">// E[f(X)] ~= 2 * (x + b) ^ (1 - p / 2) / (sqrt(a) * (2 - p))</a>
<a name="ln774">//            + constant / 2 * (1 / sqrt(a) * (-p / 2) * (x + b) ^ (- p / 2 - 1)) * (a * (x + b) ^ p)</a>
<a name="ln775">//          = 2 * (x + b) ^ (1 - p / 2) / (sqrt(a) * (2 - p))</a>
<a name="ln776">//            + constant / 2 * 1 / sqrt(a) * (-p / 2) * a * (x + b) ^ (p / 2 - 1)</a>
<a name="ln777">//          = 2 * (x + b) ^ (1 - p / 2) / (sqrt(a) * (2 - p))</a>
<a name="ln778">//            - constant / 4 * sqrt(a) * p * (x + b) ^ (p / 2 - 1)</a>
<a name="ln779">// let z = (x + b) ^ (1 - p / 2)</a>
<a name="ln780">// E[f(X)] ~= 2 / (sqrt(a) * (2 - p)) * z</a>
<a name="ln781">//            - constant / 4 * sqrt(a) * p * z^(-1)</a>
<a name="ln782">// let y = E[f(X)]</a>
<a name="ln783">// y ~= 2 / (sqrt(a) * (2 - p)) * z - constant / 4 * sqrt(a) * p * z^(-1)</a>
<a name="ln784">// y * z = 2 / (sqrt(a) * (2 - p)) * z^2 - constant / 4 * sqrt(a) * p</a>
<a name="ln785">// 0 = 2 / (sqrt(a) * (2 - p)) * z^2 - y * z - constant / 4 * sqrt(a) * p</a>
<a name="ln786">// let's solve this equation:</a>
<a name="ln787">// delta = y ^ 2 - 4 * 2 / (sqrt(a) * (2 - p)) * (- constant / 4 * sqrt(a))</a>
<a name="ln788">//       = y ^ 2 + 2 * p * constant / (2 - p)</a>
<a name="ln789">// delta &gt;= 0</a>
<a name="ln790">// the 2 solutions are:</a>
<a name="ln791">// z0 = (y - sqrt(delta)) / (2 * 2 / (sqrt(a) * (2 - p)))</a>
<a name="ln792">// z1 = (y + sqrt(delta)) / (2 * 2 / (sqrt(a) * (2 - p)))</a>
<a name="ln793">// as delta &gt; y^2, sqrt(delta) &gt; y, so z0 is negative</a>
<a name="ln794">// so z1 is the only possible solution.</a>
<a name="ln795">// Then, to find E[X], we only have to do:</a>
<a name="ln796">// z = (x + b) ^ (1 - p / 2) &lt;=&gt; x = z ^ (1 / (1 - p / 2)) - b</a>
<a name="ln797">//</a>
<a name="ln798">// What we see here is that a bias compensation term is in delta:</a>
<a name="ln799">// the term: 2 * p * constant / (2 - p)</a>
<a name="ln800">// But we are not sure at all what the value of the constant is</a>
<a name="ln801">// That's why we introduce a user-controled bias parameter to be able to</a>
<a name="ln802">// control the bias:</a>
<a name="ln803">// we replace the 2 * p * constant / (2 - p) part of delta by user</a>
<a name="ln804">// defined bias controller.</a>
<a name="ln805">static inline void backtransform_v2(float *const buf, const int wd, const int ht, const float a, const float p[3],</a>
<a name="ln806">                                    const float b, const float bias, const float wb[3])</a>
<a name="ln807">{</a>
<a name="ln808">#ifdef _OPENMP</a>
<a name="ln809">#pragma omp parallel for default(none) \</a>
<a name="ln810">  dt_omp_firstprivate(buf, ht, wd, a, p, b, bias, wb) \</a>
<a name="ln811">  schedule(static)</a>
<a name="ln812">#endif</a>
<a name="ln813">  for(int j = 0; j &lt; ht; j++)</a>
<a name="ln814">  {</a>
<a name="ln815">    float *buf2 = buf + (size_t)4 * j * wd;</a>
<a name="ln816">    for(int i = 0; i &lt; wd; i++)</a>
<a name="ln817">    {</a>
<a name="ln818">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln819">      {</a>
<a name="ln820">        const float x = buf2[c];</a>
<a name="ln821">        const float delta = x * x + bias;</a>
<a name="ln822">        const float denominator = 4.0f / (sqrt(a) * (2.0f - p[c]));</a>
<a name="ln823">        const float z1 = (x + sqrt(MAX(delta, 0.0f))) / denominator;</a>
<a name="ln824">        buf2[c] = powf(z1, 1.0f / (1.0f - p[c] / 2.0f)) - b;</a>
<a name="ln825">        buf2[c] *= wb[c];</a>
<a name="ln826">      }</a>
<a name="ln827">      buf2 += 4;</a>
<a name="ln828">    }</a>
<a name="ln829">  }</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">// =====================================================================================</a>
<a name="ln833">// begin wavelet code:</a>
<a name="ln834">// =====================================================================================</a>
<a name="ln835"> </a>
<a name="ln836">static inline float weight(const float *c1, const float *c2, const float inv_sigma2)</a>
<a name="ln837">{</a>
<a name="ln838">// return _mm_set1_ps(1.0f);</a>
<a name="ln839">#if 1</a>
<a name="ln840">  // 3d distance based on color</a>
<a name="ln841">  float diff[4];</a>
<a name="ln842">  for(int c = 0; c &lt; 4; c++) diff[c] = c1[c] - c2[c];</a>
<a name="ln843"> </a>
<a name="ln844">  float sqr[4];</a>
<a name="ln845">  for(int c = 0; c &lt; 4; c++) sqr[c] = diff[c] * diff[c];</a>
<a name="ln846"> </a>
<a name="ln847">  const float dot = (sqr[0] + sqr[1] + sqr[2]) * inv_sigma2;</a>
<a name="ln848">  const float var</a>
<a name="ln849">      = 0.02f; // FIXME: this should ideally depend on the image before noise stabilizing transforms!</a>
<a name="ln850">  const float off2 = 9.0f; // (3 sigma)^2</a>
<a name="ln851">  return fast_mexp2f(MAX(0, dot * var - off2));</a>
<a name="ln852">#endif</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">#if defined(__SSE__)</a>
<a name="ln856">static inline __m128 weight_sse(const __m128 *c1, const __m128 *c2, const float inv_sigma2)</a>
<a name="ln857">{</a>
<a name="ln858">// return _mm_set1_ps(1.0f);</a>
<a name="ln859">#if 1</a>
<a name="ln860">  // 3d distance based on color</a>
<a name="ln861">  __m128 diff = _mm_sub_ps(*c1, *c2);</a>
<a name="ln862">  __m128 sqr = _mm_mul_ps(diff, diff);</a>
<a name="ln863">  float *fsqr = (float *)&amp;sqr;</a>
<a name="ln864">  const float dot = (fsqr[0] + fsqr[1] + fsqr[2]) * inv_sigma2;</a>
<a name="ln865">  const float var</a>
<a name="ln866">      = 0.02f; // FIXME: this should ideally depend on the image before noise stabilizing transforms!</a>
<a name="ln867">  const float off2 = 9.0f; // (3 sigma)^2</a>
<a name="ln868">  return _mm_set1_ps(fast_mexp2f(MAX(0, dot * var - off2)));</a>
<a name="ln869">#endif</a>
<a name="ln870">}</a>
<a name="ln871">#endif</a>
<a name="ln872"> </a>
<a name="ln873">#define SUM_PIXEL_CONTRIBUTION_COMMON(ii, jj)                                                                \</a>
<a name="ln874">  do                                                                                                         \</a>
<a name="ln875">  {                                                                                                          \</a>
<a name="ln876">    const float f = filter[(ii)] * filter[(jj)];                                                             \</a>
<a name="ln877">    const float wp = weight(px, px2, inv_sigma2);                                                            \</a>
<a name="ln878">    const float w = f * wp;                                                                                  \</a>
<a name="ln879">    float pd[4];                                                                                             \</a>
<a name="ln880">    for(int c = 0; c &lt; 4; c++) pd[c] = w * px2[c];                                                           \</a>
<a name="ln881">    for(int c = 0; c &lt; 4; c++) sum[c] += pd[c];                                                              \</a>
<a name="ln882">    for(int c = 0; c &lt; 4; c++) wgt[c] += w;                                                                  \</a>
<a name="ln883">  } while(0)</a>
<a name="ln884"> </a>
<a name="ln885">#if defined(__SSE__)</a>
<a name="ln886">#define SUM_PIXEL_CONTRIBUTION_COMMON_SSE(ii, jj)                                                            \</a>
<a name="ln887">  do                                                                                                         \</a>
<a name="ln888">  {                                                                                                          \</a>
<a name="ln889">    const __m128 f = _mm_set1_ps(filter[(ii)] * filter[(jj)]);                                               \</a>
<a name="ln890">    const __m128 wp = weight_sse(px, px2, inv_sigma2);                                                       \</a>
<a name="ln891">    const __m128 w = _mm_mul_ps(f, wp);                                                                      \</a>
<a name="ln892">    const __m128 pd = _mm_mul_ps(w, *px2);                                                                   \</a>
<a name="ln893">    sum = _mm_add_ps(sum, pd);                                                                               \</a>
<a name="ln894">    wgt = _mm_add_ps(wgt, w);                                                                                \</a>
<a name="ln895">  } while(0)</a>
<a name="ln896">#endif</a>
<a name="ln897"> </a>
<a name="ln898">#define SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj)                                                             \</a>
<a name="ln899">  do                                                                                                         \</a>
<a name="ln900">  {                                                                                                          \</a>
<a name="ln901">    const int iii = (ii)-2;                                                                                  \</a>
<a name="ln902">    const int jjj = (jj)-2;                                                                                  \</a>
<a name="ln903">    int x = i + mult * iii;                                                                                  \</a>
<a name="ln904">    int y = j + mult * jjj;                                                                                  \</a>
<a name="ln905">                                                                                                             \</a>
<a name="ln906">    if(x &lt; 0) x = 0;                                                                                         \</a>
<a name="ln907">    if(x &gt;= width) x = width - 1;                                                                            \</a>
<a name="ln908">    if(y &lt; 0) y = 0;                                                                                         \</a>
<a name="ln909">    if(y &gt;= height) y = height - 1;                                                                          \</a>
<a name="ln910">                                                                                                             \</a>
<a name="ln911">    px2 = ((float *)in) + 4 * x + (size_t)4 * y * width;                                                     \</a>
<a name="ln912">                                                                                                             \</a>
<a name="ln913">    SUM_PIXEL_CONTRIBUTION_COMMON(ii, jj);                                                                   \</a>
<a name="ln914">  } while(0)</a>
<a name="ln915"> </a>
<a name="ln916">#if defined(__SSE__)</a>
<a name="ln917">#define SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE(ii, jj)                                                         \</a>
<a name="ln918">  do                                                                                                         \</a>
<a name="ln919">  {                                                                                                          \</a>
<a name="ln920">    const int iii = (ii)-2;                                                                                  \</a>
<a name="ln921">    const int jjj = (jj)-2;                                                                                  \</a>
<a name="ln922">    int x = i + mult * iii;                                                                                  \</a>
<a name="ln923">    int y = j + mult * jjj;                                                                                  \</a>
<a name="ln924">                                                                                                             \</a>
<a name="ln925">    if(x &lt; 0) x = 0;                                                                                         \</a>
<a name="ln926">    if(x &gt;= width) x = width - 1;                                                                            \</a>
<a name="ln927">    if(y &lt; 0) y = 0;                                                                                         \</a>
<a name="ln928">    if(y &gt;= height) y = height - 1;                                                                          \</a>
<a name="ln929">                                                                                                             \</a>
<a name="ln930">    px2 = ((__m128 *)in) + x + (size_t)y * width;                                                            \</a>
<a name="ln931">                                                                                                             \</a>
<a name="ln932">    SUM_PIXEL_CONTRIBUTION_COMMON_SSE(ii, jj);                                                               \</a>
<a name="ln933">  } while(0)</a>
<a name="ln934">#endif</a>
<a name="ln935"> </a>
<a name="ln936">#define ROW_PROLOGUE                                                                                         \</a>
<a name="ln937">  const float *px = ((float *)in) + (size_t)4 * j * width;                                                   \</a>
<a name="ln938">  const float *px2;                                                                                          \</a>
<a name="ln939">  float *pdetail = detail + (size_t)4 * j * width;                                                           \</a>
<a name="ln940">  float *pcoarse = out + (size_t)4 * j * width;</a>
<a name="ln941"> </a>
<a name="ln942">#if defined(__SSE__)</a>
<a name="ln943">#define ROW_PROLOGUE_SSE                                                                                     \</a>
<a name="ln944">  const __m128 *px = ((__m128 *)in) + (size_t)j * width;                                                     \</a>
<a name="ln945">  const __m128 *px2;                                                                                         \</a>
<a name="ln946">  float *pdetail = detail + (size_t)4 * j * width;                                                           \</a>
<a name="ln947">  float *pcoarse = out + (size_t)4 * j * width;</a>
<a name="ln948">#endif</a>
<a name="ln949"> </a>
<a name="ln950">#define SUM_PIXEL_PROLOGUE                                                                                   \</a>
<a name="ln951">  float sum[4] = { 0.0f, 0.0f, 0.0f, 0.0f };                                                                 \</a>
<a name="ln952">  float wgt[4] = { 0.0f, 0.0f, 0.0f, 0.0f };</a>
<a name="ln953"> </a>
<a name="ln954">#if defined(__SSE__)</a>
<a name="ln955">#define SUM_PIXEL_PROLOGUE_SSE                                                                               \</a>
<a name="ln956">  __m128 sum = _mm_setzero_ps();                                                                             \</a>
<a name="ln957">  __m128 wgt = _mm_setzero_ps();</a>
<a name="ln958">#endif</a>
<a name="ln959"> </a>
<a name="ln960">#define SUM_PIXEL_EPILOGUE                                                                                   \</a>
<a name="ln961">  for(int c = 0; c &lt; 4; c++) sum[c] /= wgt[c];                                                               \</a>
<a name="ln962">                                                                                                             \</a>
<a name="ln963">  for(int c = 0; c &lt; 4; c++) pdetail[c] = (px[c] - sum[c]);                                                  \</a>
<a name="ln964">  for(int c = 0; c &lt; 4; c++) pcoarse[c] = sum[c];                                                            \</a>
<a name="ln965">  px += 4;                                                                                                   \</a>
<a name="ln966">  pdetail += 4;                                                                                              \</a>
<a name="ln967">  pcoarse += 4;</a>
<a name="ln968"> </a>
<a name="ln969">#if defined(__SSE__)</a>
<a name="ln970">#define SUM_PIXEL_EPILOGUE_SSE                                                                               \</a>
<a name="ln971">  sum = _mm_div_ps(sum, wgt);                                                                                \</a>
<a name="ln972">                                                                                                             \</a>
<a name="ln973">  _mm_stream_ps(pdetail, _mm_sub_ps(*px, sum));                                                              \</a>
<a name="ln974">  _mm_stream_ps(pcoarse, sum);                                                                               \</a>
<a name="ln975">  px++;                                                                                                      \</a>
<a name="ln976">  pdetail += 4;                                                                                              \</a>
<a name="ln977">  pcoarse += 4;</a>
<a name="ln978">#endif</a>
<a name="ln979"> </a>
<a name="ln980">typedef void((*eaw_decompose_t)(float *const out, const float *const in, float *const detail, const int scale,</a>
<a name="ln981">                                const float inv_sigma2, const int32_t width, const int32_t height));</a>
<a name="ln982"> </a>
<a name="ln983">static void eaw_decompose(float *const out, const float *const in, float *const detail, const int scale,</a>
<a name="ln984">                          const float inv_sigma2, const int32_t width, const int32_t height)</a>
<a name="ln985">{</a>
<a name="ln986">  const int mult = 1u &lt;&lt; scale;</a>
<a name="ln987">  static const float filter[5] = { 1.0f / 16.0f, 4.0f / 16.0f, 6.0f / 16.0f, 4.0f / 16.0f, 1.0f / 16.0f };</a>
<a name="ln988"> </a>
<a name="ln989">/* The first &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln990"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln991">#ifdef _OPENMP</a>
<a name="ln992">#pragma omp parallel for default(none) \</a>
<a name="ln993">  dt_omp_firstprivate(detail, filter, height, in, inv_sigma2, mult, out, width) \</a>
<a name="ln994">  schedule(static)</a>
<a name="ln995">#endif</a>
<a name="ln996">  for(int j = 0; j &lt; 2 * mult; j++)</a>
<a name="ln997">  {</a>
<a name="ln998">    ROW_PROLOGUE</a>
<a name="ln999"> </a>
<a name="ln1000">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1001">    {</a>
<a name="ln1002">      SUM_PIXEL_PROLOGUE</a>
<a name="ln1003">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1004">      {</a>
<a name="ln1005">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1006">        {</a>
<a name="ln1007">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln1008">        }</a>
<a name="ln1009">      }</a>
<a name="ln1010">      SUM_PIXEL_EPILOGUE</a>
<a name="ln1011">    }</a>
<a name="ln1012">  }</a>
<a name="ln1013"> </a>
<a name="ln1014">#ifdef _OPENMP</a>
<a name="ln1015">#pragma omp parallel for default(none) \</a>
<a name="ln1016">  dt_omp_firstprivate(detail, filter, height, in, inv_sigma2, mult, out, width) \</a>
<a name="ln1017">  schedule(static)</a>
<a name="ln1018">#endif</a>
<a name="ln1019">  for(int j = 2 * mult; j &lt; height - 2 * mult; j++)</a>
<a name="ln1020">  {</a>
<a name="ln1021">    ROW_PROLOGUE</a>
<a name="ln1022"> </a>
<a name="ln1023">    /* The first &quot;2*mult&quot; pixels use the macro with tests because the 5x5 kernel</a>
<a name="ln1024">     * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln1025">    for(int i = 0; i &lt; 2 * mult; i++)</a>
<a name="ln1026">    {</a>
<a name="ln1027">      SUM_PIXEL_PROLOGUE</a>
<a name="ln1028">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1029">      {</a>
<a name="ln1030">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1031">        {</a>
<a name="ln1032">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln1033">        }</a>
<a name="ln1034">      }</a>
<a name="ln1035">      SUM_PIXEL_EPILOGUE</a>
<a name="ln1036">    }</a>
<a name="ln1037"> </a>
<a name="ln1038">    /* For pixels [2*mult, width-2*mult], we can safely use macro w/o tests</a>
<a name="ln1039">     * to avoid unneeded branching in the inner loops */</a>
<a name="ln1040">    for(int i = 2 * mult; i &lt; width - 2 * mult; i++)</a>
<a name="ln1041">    {</a>
<a name="ln1042">      SUM_PIXEL_PROLOGUE</a>
<a name="ln1043">      px2 = ((float *)in) + (size_t)4 * (i - 2 * mult + (size_t)(j - 2 * mult) * width);</a>
<a name="ln1044">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1045">      {</a>
<a name="ln1046">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1047">        {</a>
<a name="ln1048">          SUM_PIXEL_CONTRIBUTION_COMMON(ii, jj);</a>
<a name="ln1049">          px2 += (size_t)4 * mult;</a>
<a name="ln1050">        }</a>
<a name="ln1051">        px2 += (size_t)4 * (width - 5) * mult;</a>
<a name="ln1052">      }</a>
<a name="ln1053">      SUM_PIXEL_EPILOGUE</a>
<a name="ln1054">    }</a>
<a name="ln1055"> </a>
<a name="ln1056">    /* Last two pixels in the row require a slow variant... blablabla */</a>
<a name="ln1057">    for(int i = width - 2 * mult; i &lt; width; i++)</a>
<a name="ln1058">    {</a>
<a name="ln1059">      SUM_PIXEL_PROLOGUE</a>
<a name="ln1060">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1061">      {</a>
<a name="ln1062">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1063">        {</a>
<a name="ln1064">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln1065">        }</a>
<a name="ln1066">      }</a>
<a name="ln1067">      SUM_PIXEL_EPILOGUE</a>
<a name="ln1068">    }</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">/* The last &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln1072"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln1073">#ifdef _OPENMP</a>
<a name="ln1074">#pragma omp parallel for default(none) \</a>
<a name="ln1075">  dt_omp_firstprivate(detail, filter, height, in, inv_sigma2, mult, out, width) \</a>
<a name="ln1076">  schedule(static)</a>
<a name="ln1077">#endif</a>
<a name="ln1078">  for(int j = height - 2 * mult; j &lt; height; j++)</a>
<a name="ln1079">  {</a>
<a name="ln1080">    ROW_PROLOGUE</a>
<a name="ln1081"> </a>
<a name="ln1082">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1083">    {</a>
<a name="ln1084">      SUM_PIXEL_PROLOGUE</a>
<a name="ln1085">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1086">      {</a>
<a name="ln1087">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1088">        {</a>
<a name="ln1089">          SUM_PIXEL_CONTRIBUTION_WITH_TEST(ii, jj);</a>
<a name="ln1090">        }</a>
<a name="ln1091">      }</a>
<a name="ln1092">      SUM_PIXEL_EPILOGUE</a>
<a name="ln1093">    }</a>
<a name="ln1094">  }</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">#undef SUM_PIXEL_CONTRIBUTION_COMMON</a>
<a name="ln1098">#undef SUM_PIXEL_CONTRIBUTION_WITH_TEST</a>
<a name="ln1099">#undef ROW_PROLOGUE</a>
<a name="ln1100">#undef SUM_PIXEL_PROLOGUE</a>
<a name="ln1101">#undef SUM_PIXEL_EPILOGUE</a>
<a name="ln1102"> </a>
<a name="ln1103">#if defined(__SSE2__)</a>
<a name="ln1104">static void eaw_decompose_sse(float *const out, const float *const in, float *const detail, const int scale,</a>
<a name="ln1105">                              const float inv_sigma2, const int32_t width, const int32_t height)</a>
<a name="ln1106">{</a>
<a name="ln1107">  const int mult = 1u &lt;&lt; scale;</a>
<a name="ln1108">  static const float filter[5] = { 1.0f / 16.0f, 4.0f / 16.0f, 6.0f / 16.0f, 4.0f / 16.0f, 1.0f / 16.0f };</a>
<a name="ln1109"> </a>
<a name="ln1110">/* The first &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln1111"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln1112">#ifdef _OPENMP</a>
<a name="ln1113">#pragma omp parallel for default(none) \</a>
<a name="ln1114">  dt_omp_firstprivate(detail, filter, height, in, inv_sigma2, mult, out, width) \</a>
<a name="ln1115">  schedule(static)</a>
<a name="ln1116">#endif</a>
<a name="ln1117">  for(int j = 0; j &lt; 2 * mult; j++)</a>
<a name="ln1118">  {</a>
<a name="ln1119">    ROW_PROLOGUE_SSE</a>
<a name="ln1120"> </a>
<a name="ln1121">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1122">    {</a>
<a name="ln1123">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln1124">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1125">      {</a>
<a name="ln1126">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1127">        {</a>
<a name="ln1128">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE(ii, jj);</a>
<a name="ln1129">        }</a>
<a name="ln1130">      }</a>
<a name="ln1131">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln1132">    }</a>
<a name="ln1133">  }</a>
<a name="ln1134"> </a>
<a name="ln1135">#ifdef _OPENMP</a>
<a name="ln1136">#pragma omp parallel for default(none) \</a>
<a name="ln1137">  dt_omp_firstprivate(detail, filter, height, in, inv_sigma2, mult, out, width) \</a>
<a name="ln1138">  schedule(static)</a>
<a name="ln1139">#endif</a>
<a name="ln1140">  for(int j = 2 * mult; j &lt; height - 2 * mult; j++)</a>
<a name="ln1141">  {</a>
<a name="ln1142">    ROW_PROLOGUE_SSE</a>
<a name="ln1143"> </a>
<a name="ln1144">    /* The first &quot;2*mult&quot; pixels use the macro with tests because the 5x5 kernel</a>
<a name="ln1145">     * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln1146">    for(int i = 0; i &lt; 2 * mult; i++)</a>
<a name="ln1147">    {</a>
<a name="ln1148">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln1149">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1150">      {</a>
<a name="ln1151">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1152">        {</a>
<a name="ln1153">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE(ii, jj);</a>
<a name="ln1154">        }</a>
<a name="ln1155">      }</a>
<a name="ln1156">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln1157">    }</a>
<a name="ln1158"> </a>
<a name="ln1159">    /* For pixels [2*mult, width-2*mult], we can safely use macro w/o tests</a>
<a name="ln1160">     * to avoid unneeded branching in the inner loops */</a>
<a name="ln1161">    for(int i = 2 * mult; i &lt; width - 2 * mult; i++)</a>
<a name="ln1162">    {</a>
<a name="ln1163">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln1164">      px2 = ((__m128 *)in) + i - 2 * mult + (size_t)(j - 2 * mult) * width;</a>
<a name="ln1165">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1166">      {</a>
<a name="ln1167">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1168">        {</a>
<a name="ln1169">          SUM_PIXEL_CONTRIBUTION_COMMON_SSE(ii, jj);</a>
<a name="ln1170">          px2 += mult;</a>
<a name="ln1171">        }</a>
<a name="ln1172">        px2 += (width - 5) * mult;</a>
<a name="ln1173">      }</a>
<a name="ln1174">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln1175">    }</a>
<a name="ln1176"> </a>
<a name="ln1177">    /* Last two pixels in the row require a slow variant... blablabla */</a>
<a name="ln1178">    for(int i = width - 2 * mult; i &lt; width; i++)</a>
<a name="ln1179">    {</a>
<a name="ln1180">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln1181">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1182">      {</a>
<a name="ln1183">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1184">        {</a>
<a name="ln1185">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE(ii, jj);</a>
<a name="ln1186">        }</a>
<a name="ln1187">      }</a>
<a name="ln1188">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln1189">    }</a>
<a name="ln1190">  }</a>
<a name="ln1191"> </a>
<a name="ln1192">/* The last &quot;2*mult&quot; lines use the macro with tests because the 5x5 kernel</a>
<a name="ln1193"> * requires nearest pixel interpolation for at least a pixel in the sum */</a>
<a name="ln1194">#ifdef _OPENMP</a>
<a name="ln1195">#pragma omp parallel for default(none) \</a>
<a name="ln1196">  dt_omp_firstprivate(detail, filter, height, in, inv_sigma2, mult, out, width) \</a>
<a name="ln1197">  schedule(static)</a>
<a name="ln1198">#endif</a>
<a name="ln1199">  for(int j = height - 2 * mult; j &lt; height; j++)</a>
<a name="ln1200">  {</a>
<a name="ln1201">    ROW_PROLOGUE_SSE</a>
<a name="ln1202"> </a>
<a name="ln1203">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1204">    {</a>
<a name="ln1205">      SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln1206">      for(int jj = 0; jj &lt; 5; jj++)</a>
<a name="ln1207">      {</a>
<a name="ln1208">        for(int ii = 0; ii &lt; 5; ii++)</a>
<a name="ln1209">        {</a>
<a name="ln1210">          SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE(ii, jj);</a>
<a name="ln1211">        }</a>
<a name="ln1212">      }</a>
<a name="ln1213">      SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln1214">    }</a>
<a name="ln1215">  }</a>
<a name="ln1216"> </a>
<a name="ln1217">  _mm_sfence();</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220">#undef SUM_PIXEL_CONTRIBUTION_COMMON_SSE</a>
<a name="ln1221">#undef SUM_PIXEL_CONTRIBUTION_WITH_TEST_SSE</a>
<a name="ln1222">#undef ROW_PROLOGUE_SSE</a>
<a name="ln1223">#undef SUM_PIXEL_PROLOGUE_SSE</a>
<a name="ln1224">#undef SUM_PIXEL_EPILOGUE_SSE</a>
<a name="ln1225">#endif</a>
<a name="ln1226"> </a>
<a name="ln1227">typedef void((*eaw_synthesize_t)(float *const out, const float *const in, const float *const detail,</a>
<a name="ln1228">                                 const float *thrsf, const float *boostf, const int32_t width,</a>
<a name="ln1229">                                 const int32_t height));</a>
<a name="ln1230"> </a>
<a name="ln1231">static void eaw_synthesize(float *const out, const float *const in, const float *const detail,</a>
<a name="ln1232">                           const float *thrsf, const float *boostf, const int32_t width, const int32_t height)</a>
<a name="ln1233">{</a>
<a name="ln1234">  const float threshold[4] = { thrsf[0], thrsf[1], thrsf[2], thrsf[3] };</a>
<a name="ln1235">  const float boost[4] = { boostf[0], boostf[1], boostf[2], boostf[3] };</a>
<a name="ln1236"> </a>
<a name="ln1237">#ifdef _OPENMP</a>
<a name="ln1238">#pragma omp parallel for SIMD() default(none) \</a>
<a name="ln1239">  dt_omp_firstprivate(boost, detail, height, in, out, threshold, width) \</a>
<a name="ln1240">  schedule(static) \</a>
<a name="ln1241">  collapse(2)</a>
<a name="ln1242">#endif</a>
<a name="ln1243">  for(size_t k = 0; k &lt; (size_t)4 * width * height; k += 4)</a>
<a name="ln1244">  {</a>
<a name="ln1245">    for(size_t c = 0; c &lt; 4; c++)</a>
<a name="ln1246">    {</a>
<a name="ln1247">      const float absamt = MAX(0.0f, (fabsf(detail[k + c]) - threshold[c]));</a>
<a name="ln1248">      const float amount = copysignf(absamt, detail[k + c]);</a>
<a name="ln1249">      out[k + c] = in[k + c] + (boost[c] * amount);</a>
<a name="ln1250">    }</a>
<a name="ln1251">  }</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">#if defined(__SSE2__)</a>
<a name="ln1255">static void eaw_synthesize_sse2(float *const out, const float *const in, const float *const detail,</a>
<a name="ln1256">                                const float *thrsf, const float *boostf, const int32_t width,</a>
<a name="ln1257">                                const int32_t height)</a>
<a name="ln1258">{</a>
<a name="ln1259">  const __m128 threshold = _mm_set_ps(thrsf[3], thrsf[2], thrsf[1], thrsf[0]);</a>
<a name="ln1260">  const __m128 boost = _mm_set_ps(boostf[3], boostf[2], boostf[1], boostf[0]);</a>
<a name="ln1261"> </a>
<a name="ln1262">#ifdef _OPENMP</a>
<a name="ln1263">#pragma omp parallel for default(none) \</a>
<a name="ln1264">  dt_omp_firstprivate(boost, detail, height, in, out, threshold, width) \</a>
<a name="ln1265">  schedule(static)</a>
<a name="ln1266">#endif</a>
<a name="ln1267">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1268">  {</a>
<a name="ln1269">    // TODO: prefetch? _mm_prefetch()</a>
<a name="ln1270">    const __m128 *pin = (__m128 *)in + (size_t)j * width;</a>
<a name="ln1271">    __m128 *pdetail = (__m128 *)detail + (size_t)j * width;</a>
<a name="ln1272">    float *pout = out + (size_t)4 * j * width;</a>
<a name="ln1273">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1274">    {</a>
<a name="ln1275">#if 1</a>
<a name="ln1276">      const __m128i maski = _mm_set1_epi32(0x80000000u);</a>
<a name="ln1277">      const __m128 *mask = (__m128 *)&amp;maski;</a>
<a name="ln1278">      const __m128 absamt</a>
<a name="ln1279">          = _mm_max_ps(_mm_setzero_ps(), _mm_sub_ps(_mm_andnot_ps(*mask, *pdetail), threshold));</a>
<a name="ln1280">      const __m128 amount = _mm_or_ps(_mm_and_ps(*pdetail, *mask), absamt);</a>
<a name="ln1281">      _mm_stream_ps(pout, _mm_add_ps(*pin, _mm_mul_ps(boost, amount)));</a>
<a name="ln1282">#endif</a>
<a name="ln1283">      // _mm_stream_ps(pout, _mm_add_ps(*pin, *pdetail));</a>
<a name="ln1284">      pdetail++;</a>
<a name="ln1285">      pin++;</a>
<a name="ln1286">      pout += 4;</a>
<a name="ln1287">    }</a>
<a name="ln1288">  }</a>
<a name="ln1289">  _mm_sfence();</a>
<a name="ln1290">}</a>
<a name="ln1291">#endif</a>
<a name="ln1292"> </a>
<a name="ln1293">// =====================================================================================</a>
<a name="ln1294"> </a>
<a name="ln1295">static void process_wavelets(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1296">                             const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1297">                             const dt_iop_roi_t *const roi_out, const eaw_decompose_t decompose,</a>
<a name="ln1298">                             const eaw_synthesize_t synthesize)</a>
<a name="ln1299">{</a>
<a name="ln1300">  // this is called for preview and full pipe separately, each with its own pixelpipe piece.</a>
<a name="ln1301">  // get our data struct:</a>
<a name="ln1302">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)piece-&gt;data;</a>
<a name="ln1303"> </a>
<a name="ln1304">#define MAX_MAX_SCALE DT_IOP_DENOISE_PROFILE_BANDS // hard limit</a>
<a name="ln1305"> </a>
<a name="ln1306">  int max_scale = 0;</a>
<a name="ln1307">  const float in_scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln1308">  // largest desired filter on input buffer (20% of input dim)</a>
<a name="ln1309">  const float supp0 = MIN(2 * (2u &lt;&lt; (MAX_MAX_SCALE - 1)) + 1,</a>
<a name="ln1310">                          MAX(piece-&gt;buf_in.height * piece-&gt;iscale, piece-&gt;buf_in.width * piece-&gt;iscale) * 0.2f);</a>
<a name="ln1311">  const float i0 = dt_log2f((supp0 - 1.0f) * .5f);</a>
<a name="ln1312">  for(; max_scale &lt; MAX_MAX_SCALE; max_scale++)</a>
<a name="ln1313">  {</a>
<a name="ln1314">    // actual filter support on scaled buffer</a>
<a name="ln1315">    const float supp = 2 * (2u &lt;&lt; max_scale) + 1;</a>
<a name="ln1316">    // approximates this filter size on unscaled input image:</a>
<a name="ln1317">    const float supp_in = supp * (1.0f / in_scale);</a>
<a name="ln1318">    const float i_in = dt_log2f((supp_in - 1) * .5f) - 1.0f;</a>
<a name="ln1319">    // i_in = max_scale .. .. .. 0</a>
<a name="ln1320">    const float t = 1.0f - (i_in + .5f) / i0;</a>
<a name="ln1321">    if(t &lt; 0.0f) break;</a>
<a name="ln1322">  }</a>
<a name="ln1323"> </a>
<a name="ln1324">  const int width = roi_in-&gt;width, height = roi_in-&gt;height;</a>
<a name="ln1325">  const size_t npixels = (size_t)width*height;</a>
<a name="ln1326"> </a>
<a name="ln1327">  // corner case of extremely small image. this is not really likely to happen but would cause issues later</a>
<a name="ln1328">  // when we divide by (n-1). so let's be prepared</a>
<a name="ln1329">  if(npixels &lt; 2)</a>
<a name="ln1330">  {</a>
<a name="ln1331">    memcpy(ovoid, ivoid, npixels * 4 * sizeof(float));</a>
<a name="ln1332">    return;</a>
<a name="ln1333">  }</a>
<a name="ln1334"> </a>
<a name="ln1335">  float *buf[MAX_MAX_SCALE];</a>
<a name="ln1336">  float *tmp = NULL;</a>
<a name="ln1337">  float *buf1 = NULL, *buf2 = NULL;</a>
<a name="ln1338">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln1339">    buf[k] = dt_alloc_align(64, (size_t)4 * sizeof(float) * npixels);</a>
<a name="ln1340">  tmp = dt_alloc_align(64, (size_t)4 * sizeof(float) * npixels);</a>
<a name="ln1341"> </a>
<a name="ln1342">  const float wb_mean = (piece-&gt;pipe-&gt;dsc.temperature.coeffs[0] + piece-&gt;pipe-&gt;dsc.temperature.coeffs[1]</a>
<a name="ln1343">                         + piece-&gt;pipe-&gt;dsc.temperature.coeffs[2])</a>
<a name="ln1344">                        / 3.0f;</a>
<a name="ln1345">  // we init wb by the mean of the coeffs, which corresponds to the mean</a>
<a name="ln1346">  // amplification that is done in addition to the &quot;ISO&quot; related amplification</a>
<a name="ln1347">  float wb[3] = { wb_mean, wb_mean, wb_mean };</a>
<a name="ln1348">  if(d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln1349">  {</a>
<a name="ln1350">    if(wb_mean != 0.0f &amp;&amp; d-&gt;wb_adaptive_anscombe)</a>
<a name="ln1351">    {</a>
<a name="ln1352">      for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.temperature.coeffs[i];</a>
<a name="ln1353">    }</a>
<a name="ln1354">    else if(wb_mean == 0.0f)</a>
<a name="ln1355">    {</a>
<a name="ln1356">      // temperature coeffs are equal to 0 if we open a JPG image.</a>
<a name="ln1357">      // in this case consider them equal to 1.</a>
<a name="ln1358">      for(int i = 0; i &lt; 3; i++) wb[i] = 1.0f;</a>
<a name="ln1359">    }</a>
<a name="ln1360">    // else, wb_adaptive_anscombe is false and our wb array is</a>
<a name="ln1361">    // filled with the wb_mean</a>
<a name="ln1362">  }</a>
<a name="ln1363">  else</a>
<a name="ln1364">  {</a>
<a name="ln1365">    wb[0] = 2.0f * piece-&gt;pipe-&gt;dsc.processed_maximum[0];</a>
<a name="ln1366">    wb[1] = piece-&gt;pipe-&gt;dsc.processed_maximum[1];</a>
<a name="ln1367">    wb[2] = 2.0f * piece-&gt;pipe-&gt;dsc.processed_maximum[2];</a>
<a name="ln1368">  }</a>
<a name="ln1369">  // adaptive p depending on white balance</a>
<a name="ln1370">  const float p[3] = { MAX(d-&gt;shadows + 0.1 * logf(in_scale / wb[0]), 0.0f) ,</a>
<a name="ln1371">                       MAX(d-&gt;shadows + 0.1 * logf(in_scale / wb[1]), 0.0f),</a>
<a name="ln1372">                       MAX(d-&gt;shadows + 0.1 * logf(in_scale / wb[2]), 0.0f)};</a>
<a name="ln1373"> </a>
<a name="ln1374">  // update the coeffs with strength and scale</a>
<a name="ln1375">  for(int i = 0; i &lt; 3; i++) wb[i] *= d-&gt;strength * in_scale;</a>
<a name="ln1376">  // only use green channel + wb for now:</a>
<a name="ln1377">  const float aa[3] = { d-&gt;a[1] * wb[0], d-&gt;a[1] * wb[1], d-&gt;a[1] * wb[2] };</a>
<a name="ln1378">  const float bb[3] = { d-&gt;b[1] * wb[0], d-&gt;b[1] * wb[1], d-&gt;b[1] * wb[2] };</a>
<a name="ln1379"> </a>
<a name="ln1380">  const float compensate_p = DT_IOP_DENOISE_PROFILE_P_FULCRUM / powf(DT_IOP_DENOISE_PROFILE_P_FULCRUM, d-&gt;shadows);</a>
<a name="ln1381">  if(!d-&gt;use_new_vst)</a>
<a name="ln1382">  {</a>
<a name="ln1383">    precondition((float *)ivoid, (float *)ovoid, width, height, aa, bb);</a>
<a name="ln1384">  }</a>
<a name="ln1385">  else</a>
<a name="ln1386">  {</a>
<a name="ln1387">    precondition_v2((float *)ivoid, (float *)ovoid, width, height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], wb);</a>
<a name="ln1388">  }</a>
<a name="ln1389"> </a>
<a name="ln1390">#if 0 // DEBUG: see what variance we have after transform</a>
<a name="ln1391">  if(piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1392">  {</a>
<a name="ln1393">    const int n = width*height;</a>
<a name="ln1394">    FILE *f = g_fopen(&quot;/tmp/transformed.pfm&quot;, &quot;wb&quot;);</a>
<a name="ln1395">    fprintf(f, &quot;PF\n%d %d\n-1.0\n&quot;, width, height);</a>
<a name="ln1396">    for(int k=0; k&lt;n; k++)</a>
<a name="ln1397">      fwrite(((float*)ovoid)+4*k, sizeof(float), 3, f);</a>
<a name="ln1398">    fclose(f);</a>
<a name="ln1399">  }</a>
<a name="ln1400">#endif</a>
<a name="ln1401"> </a>
<a name="ln1402">  buf1 = (float *)ovoid;</a>
<a name="ln1403">  buf2 = tmp;</a>
<a name="ln1404"> </a>
<a name="ln1405">  for(int scale = 0; scale &lt; max_scale; scale++)</a>
<a name="ln1406">  {</a>
<a name="ln1407">    const float sigma = 1.0f;</a>
<a name="ln1408">    const float varf = sqrtf(2.0f + 2.0f * 4.0f * 4.0f + 6.0f * 6.0f) / 16.0f; // about 0.5</a>
<a name="ln1409">    const float sigma_band = powf(varf, scale) * sigma;</a>
<a name="ln1410">    decompose(buf2, buf1, buf[scale], scale, 1.0f / (sigma_band * sigma_band), width, height);</a>
<a name="ln1411">// DEBUG: clean out temporary memory:</a>
<a name="ln1412">// memset(buf1, 0, sizeof(float)*4*width*height);</a>
<a name="ln1413">#if 0 // DEBUG: print wavelet scales:</a>
<a name="ln1414">    if(piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln1415">    {</a>
<a name="ln1416">      char filename[512];</a>
<a name="ln1417">      snprintf(filename, sizeof(filename), &quot;/tmp/coarse_%d.pfm&quot;, scale);</a>
<a name="ln1418">      FILE *f = g_fopen(filename, &quot;wb&quot;);</a>
<a name="ln1419">      fprintf(f, &quot;PF\n%d %d\n-1.0\n&quot;, width, height);</a>
<a name="ln1420">      for(size_t k = 0; k &lt; npixels; k++)</a>
<a name="ln1421">        fwrite(buf2+4*k, sizeof(float), 3, f);</a>
<a name="ln1422">      fclose(f);</a>
<a name="ln1423">      snprintf(filename, sizeof(filename), &quot;/tmp/detail_%d.pfm&quot;, scale);</a>
<a name="ln1424">      f = g_fopen(filename, &quot;wb&quot;);</a>
<a name="ln1425">      fprintf(f, &quot;PF\n%d %d\n-1.0\n&quot;, width, height);</a>
<a name="ln1426">      for(size_t k = 0; k &lt; npixels; k++)</a>
<a name="ln1427">        fwrite(buf[scale]+4*k, sizeof(float), 3, f);</a>
<a name="ln1428">      fclose(f);</a>
<a name="ln1429">    }</a>
<a name="ln1430">#endif</a>
<a name="ln1431">    float *buf3 = buf2;</a>
<a name="ln1432">    buf2 = buf1;</a>
<a name="ln1433">    buf1 = buf3;</a>
<a name="ln1434">  }</a>
<a name="ln1435"> </a>
<a name="ln1436">  // now do everything backwards, so the result will end up in *ovoid</a>
<a name="ln1437">  for(int scale = max_scale - 1; scale &gt;= 0; scale--)</a>
<a name="ln1438">  {</a>
<a name="ln1439">#if 1</a>
<a name="ln1440">    // variance stabilizing transform maps sigma to unity.</a>
<a name="ln1441">    const float sigma = 1.0f;</a>
<a name="ln1442">    // it is then transformed by wavelet scales via the 5 tap a-trous filter:</a>
<a name="ln1443">    const float varf = sqrtf(2.0f + 2.0f * 4.0f * 4.0f + 6.0f * 6.0f) / 16.0f; // about 0.5</a>
<a name="ln1444">    const float sigma_band = powf(varf, scale) * sigma;</a>
<a name="ln1445">    // determine thrs as bayesshrink</a>
<a name="ln1446">    // TODO: parallelize!</a>
<a name="ln1447">    float sum_y2[3] = { 0.0f };</a>
<a name="ln1448">    for(size_t k = 0; k &lt; npixels; k++)</a>
<a name="ln1449">      for(int c = 0; c &lt; 3; c++) sum_y2[c] += buf[scale][4 * k + c] * buf[scale][4 * k + c];</a>
<a name="ln1450"> </a>
<a name="ln1451">    const float sb2 = sigma_band * sigma_band;</a>
<a name="ln1452">    const float var_y[3] = { sum_y2[0] / (npixels - 1.0f), sum_y2[1] / (npixels - 1.0f), sum_y2[2] / (npixels - 1.0f) };</a>
<a name="ln1453">    const float std_x[3] = { sqrtf(MAX(1e-6f, var_y[0] - sb2)), sqrtf(MAX(1e-6f, var_y[1] - sb2)),</a>
<a name="ln1454">                             sqrtf(MAX(1e-6f, var_y[2] - sb2)) };</a>
<a name="ln1455">    // add 8.0 here because it seemed a little weak</a>
<a name="ln1456">    float adjt[3] = { 8.0f, 8.0f, 8.0f };</a>
<a name="ln1457"> </a>
<a name="ln1458">    int offset_scale = DT_IOP_DENOISE_PROFILE_BANDS - max_scale;</a>
<a name="ln1459">    // current scale number is scale+offset_scale</a>
<a name="ln1460">    // for instance, largest scale is DT_IOP_DENOISE_PROFILE_BANDS</a>
<a name="ln1461">    // max_scale only indicates the number of scales to process at THIS</a>
<a name="ln1462">    // zoom level, it does NOT corresponds to the the maximum number of scales.</a>
<a name="ln1463">    // in other words, max_scale is the maximum number of VISIBLE scales.</a>
<a name="ln1464">    // That is why we have this &quot;scale+offset_scale&quot;</a>
<a name="ln1465">    float band_force_exp_2</a>
<a name="ln1466">        = d-&gt;force[DT_DENOISE_PROFILE_ALL][DT_IOP_DENOISE_PROFILE_BANDS - (scale + offset_scale + 1)];</a>
<a name="ln1467">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln1468">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln1469">    for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln1470">    {</a>
<a name="ln1471">      adjt[ch] *= band_force_exp_2;</a>
<a name="ln1472">    }</a>
<a name="ln1473">    band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_R][DT_IOP_DENOISE_PROFILE_BANDS - (scale + offset_scale + 1)];</a>
<a name="ln1474">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln1475">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln1476">    adjt[0] *= band_force_exp_2;</a>
<a name="ln1477">    band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_G][DT_IOP_DENOISE_PROFILE_BANDS - (scale + offset_scale + 1)];</a>
<a name="ln1478">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln1479">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln1480">    adjt[1] *= band_force_exp_2;</a>
<a name="ln1481">    band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_B][DT_IOP_DENOISE_PROFILE_BANDS - (scale + offset_scale + 1)];</a>
<a name="ln1482">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln1483">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln1484">    adjt[2] *= band_force_exp_2;</a>
<a name="ln1485"> </a>
<a name="ln1486">    const float thrs[4] = { adjt[0] * sb2 / std_x[0], adjt[1] * sb2 / std_x[1], adjt[2] * sb2 / std_x[2], 0.0f };</a>
<a name="ln1487">// const float std = (std_x[0] + std_x[1] + std_x[2])/3.0f;</a>
<a name="ln1488">// const float thrs[4] = { adjt*sigma*sigma/std, adjt*sigma*sigma/std, adjt*sigma*sigma/std, 0.0f};</a>
<a name="ln1489">// fprintf(stderr, &quot;scale %d thrs %f %f %f = %f / %f %f %f \n&quot;, scale, thrs[0], thrs[1], thrs[2], sb2,</a>
<a name="ln1490">// std_x[0], std_x[1], std_x[2]);</a>
<a name="ln1491">#endif</a>
<a name="ln1492">    const float boost[4] = { 1.0f, 1.0f, 1.0f, 1.0f };</a>
<a name="ln1493">    // const float thrs[4] = { 0.0, 0.0, 0.0, 0.0 };</a>
<a name="ln1494">    synthesize(buf2, buf1, buf[scale], thrs, boost, width, height);</a>
<a name="ln1495">    // DEBUG: clean out temporary memory:</a>
<a name="ln1496">    // memset(buf1, 0, sizeof(float)*4*width*height);</a>
<a name="ln1497"> </a>
<a name="ln1498">    float *buf3 = buf2;</a>
<a name="ln1499">    buf2 = buf1;</a>
<a name="ln1500">    buf1 = buf3;</a>
<a name="ln1501">  }</a>
<a name="ln1502"> </a>
<a name="ln1503">  if(!d-&gt;use_new_vst)</a>
<a name="ln1504">  {</a>
<a name="ln1505">    backtransform((float *)ovoid, width, height, aa, bb);</a>
<a name="ln1506">  }</a>
<a name="ln1507">  else</a>
<a name="ln1508">  {</a>
<a name="ln1509">    backtransform_v2((float *)ovoid, width, height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], d-&gt;bias - 0.5 * logf(in_scale), wb);</a>
<a name="ln1510">  }</a>
<a name="ln1511"> </a>
<a name="ln1512">  for(int k = 0; k &lt; max_scale; k++) dt_free_align(buf[k]);</a>
<a name="ln1513">  dt_free_align(tmp);</a>
<a name="ln1514"> </a>
<a name="ln1515">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height);</a>
<a name="ln1516"> </a>
<a name="ln1517">#undef MAX_MAX_SCALE</a>
<a name="ln1518">}</a>
<a name="ln1519"> </a>
<a name="ln1520">static int sign(int a)</a>
<a name="ln1521">{</a>
<a name="ln1522">  return (a &gt; 0) - (a &lt; 0);</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">static void process_nlmeans(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1526">                            const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1527">                            const dt_iop_roi_t *const roi_out)</a>
<a name="ln1528">{</a>
<a name="ln1529">  // this is called for preview and full pipe separately, each with its own pixelpipe piece.</a>
<a name="ln1530">  // get our data struct:</a>
<a name="ln1531">  const dt_iop_denoiseprofile_data_t *const d = piece-&gt;data;</a>
<a name="ln1532"> </a>
<a name="ln1533">  const int ch = piece-&gt;colors;</a>
<a name="ln1534"> </a>
<a name="ln1535">  // TODO: fixed K to use adaptive size trading variance and bias!</a>
<a name="ln1536">  // adjust to zoom size:</a>
<a name="ln1537">  const float scale = fminf(roi_in-&gt;scale, 2.0f) / fmaxf(piece-&gt;iscale, 1.0f);</a>
<a name="ln1538">  const int P = ceilf(d-&gt;radius * scale); // pixel filter size</a>
<a name="ln1539">  int K = d-&gt;nbhood; // nbhood</a>
<a name="ln1540">  float scattering = d-&gt;scattering;</a>
<a name="ln1541">  // Each patch has a width of 2P+1 and a height of 2P+1</a>
<a name="ln1542">  // thus, divide by (2P+1)^2.</a>
<a name="ln1543">  // The 0.045 was derived from the old formula, to keep the</a>
<a name="ln1544">  // norm identical when P=1, as the norm for P=1 seemed</a>
<a name="ln1545">  // to work quite well: 0.045 = 0.015 * (2 * P + 1) with P=1.</a>
<a name="ln1546">  float norm = .045f / ((2 * P + 1) * (2 * P + 1));</a>
<a name="ln1547">  if(!d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln1548">  {</a>
<a name="ln1549">    // use old formula</a>
<a name="ln1550">    norm = .015f / (2 * P + 1);</a>
<a name="ln1551">  }</a>
<a name="ln1552"> </a>
<a name="ln1553">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln1554">  {</a>
<a name="ln1555">    // much faster slightly more inaccurate preview</a>
<a name="ln1556">    const int maxk = (K * K * K + 7.0 * K * sqrt(K)) * scattering / 6.0 + K;</a>
<a name="ln1557">    K = MIN(3, K);</a>
<a name="ln1558">    scattering = (maxk - K) * 6.0 / (K * K * K + 7.0 * K * sqrt(K));</a>
<a name="ln1559">  }</a>
<a name="ln1560">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln1561">  {</a>
<a name="ln1562">    // much faster slightly more inaccurate preview</a>
<a name="ln1563">    const int maxk = (K * K * K + 7.0 * K * sqrt(K)) * scattering / 6.0 + K;</a>
<a name="ln1564">    K = MAX(MIN(4, K), K * scale);</a>
<a name="ln1565">    scattering = (maxk - K) * 6.0 / (K * K * K + 7.0 * K * sqrt(K));</a>
<a name="ln1566">  }</a>
<a name="ln1567"> </a>
<a name="ln1568"> </a>
<a name="ln1569">  // P == 0 : this will degenerate to a (fast) bilateral filter.</a>
<a name="ln1570"> </a>
<a name="ln1571">  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out-&gt;width * dt_get_num_threads());</a>
<a name="ln1572">  // we want to sum up weights in col[3], so need to init to 0:</a>
<a name="ln1573">  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out-&gt;width * roi_out-&gt;height * 4);</a>
<a name="ln1574">  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln1575"> </a>
<a name="ln1576">  const float wb_mean = (piece-&gt;pipe-&gt;dsc.temperature.coeffs[0] + piece-&gt;pipe-&gt;dsc.temperature.coeffs[1]</a>
<a name="ln1577">                         + piece-&gt;pipe-&gt;dsc.temperature.coeffs[2])</a>
<a name="ln1578">                        / 3.0f;</a>
<a name="ln1579">  // we init wb by the mean of the coeffs, which corresponds to the mean</a>
<a name="ln1580">  // amplification that is done in addition to the &quot;ISO&quot; related amplification</a>
<a name="ln1581">  float wb[3] = { wb_mean, wb_mean, wb_mean };</a>
<a name="ln1582">  if(d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln1583">  {</a>
<a name="ln1584">    if(wb_mean != 0.0f &amp;&amp; d-&gt;wb_adaptive_anscombe)</a>
<a name="ln1585">    {</a>
<a name="ln1586">      for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.temperature.coeffs[i];</a>
<a name="ln1587">    }</a>
<a name="ln1588">    else if(wb_mean == 0.0f)</a>
<a name="ln1589">    {</a>
<a name="ln1590">      // temperature coeffs are equal to 0 if we open a JPG image.</a>
<a name="ln1591">      // in this case consider them equal to 1.</a>
<a name="ln1592">      for(int i = 0; i &lt; 3; i++) wb[i] = 1.0f;</a>
<a name="ln1593">    }</a>
<a name="ln1594">    // else, wb_adaptive_anscombe is false and our wb array is</a>
<a name="ln1595">    // filled with the wb_mean</a>
<a name="ln1596">  }</a>
<a name="ln1597">  else</a>
<a name="ln1598">  {</a>
<a name="ln1599">    for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.processed_maximum[i];</a>
<a name="ln1600">  }</a>
<a name="ln1601">  // adaptive p depending on white balance</a>
<a name="ln1602">  const float p[3] = { MAX(d-&gt;shadows + 0.1 * logf(scale / wb[0]), 0.0f) ,</a>
<a name="ln1603">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[1]), 0.0f),</a>
<a name="ln1604">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[2]), 0.0f)};</a>
<a name="ln1605"> </a>
<a name="ln1606">  // update the coeffs with strength and scale</a>
<a name="ln1607">  for(int i = 0; i &lt; 3; i++) wb[i] *= d-&gt;strength * scale;</a>
<a name="ln1608">  const float central_pixel_weight = d-&gt;central_pixel_weight * scale;</a>
<a name="ln1609">  const float aa[3] = { d-&gt;a[1] * wb[0], d-&gt;a[1] * wb[1], d-&gt;a[1] * wb[2] };</a>
<a name="ln1610">  const float bb[3] = { d-&gt;b[1] * wb[0], d-&gt;b[1] * wb[1], d-&gt;b[1] * wb[2] };</a>
<a name="ln1611">  const float compensate_p = DT_IOP_DENOISE_PROFILE_P_FULCRUM / powf(DT_IOP_DENOISE_PROFILE_P_FULCRUM, d-&gt;shadows);</a>
<a name="ln1612">  if(!d-&gt;use_new_vst)</a>
<a name="ln1613">  {</a>
<a name="ln1614">    precondition((float *)ivoid, in, roi_in-&gt;width, roi_in-&gt;height, aa, bb);</a>
<a name="ln1615">  }</a>
<a name="ln1616">  else</a>
<a name="ln1617">  {</a>
<a name="ln1618">    precondition_v2((float *)ivoid, in, roi_in-&gt;width, roi_in-&gt;height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], wb);</a>
<a name="ln1619">  }</a>
<a name="ln1620">  // for each shift vector</a>
<a name="ln1621">  for(int kj_index = -K; kj_index &lt;= K; kj_index++)</a>
<a name="ln1622">  {</a>
<a name="ln1623">    for(int ki_index = -K; ki_index &lt;= K; ki_index++)</a>
<a name="ln1624">    {</a>
<a name="ln1625">      // This formula is made for:</a>
<a name="ln1626">      // - ensuring that kj = kj_index and ki = ki_index when d-&gt;scattering is 0</a>
<a name="ln1627">      // - ensuring that no patch can appear twice (provided that d-&gt;scattering is in 0,1 range)</a>
<a name="ln1628">      // - avoiding grid artifacts by trying to take patches on various lines and columns</a>
<a name="ln1629">      const int abs_kj = abs(kj_index);</a>
<a name="ln1630">      const int abs_ki = abs(ki_index);</a>
<a name="ln1631">      int kj = scale * ((abs_kj * abs_kj * abs_kj + 7.0 * abs_kj * sqrt(abs_ki)) * sign(kj_index) * scattering / 6.0 + kj_index);</a>
<a name="ln1632">      int ki = scale * ((abs_ki * abs_ki * abs_ki + 7.0 * abs_ki * sqrt(abs_kj)) * sign(ki_index) * scattering / 6.0 + ki_index);</a>
<a name="ln1633">      // TODO: adaptive K tests here!</a>
<a name="ln1634">      // TODO: expf eval for real bilateral experience :)</a>
<a name="ln1635"> </a>
<a name="ln1636">      int inited_slide = 0;</a>
<a name="ln1637">// don't construct summed area tables but use sliding window! (applies to cpu version res &lt; 1k only, or else</a>
<a name="ln1638">// we will add up errors)</a>
<a name="ln1639">// do this in parallel with a little threading overhead. could parallelize the outer loops with a bit more</a>
<a name="ln1640">// memory</a>
<a name="ln1641">#ifdef _OPENMP</a>
<a name="ln1642">#pragma omp parallel for default(none) \</a>
<a name="ln1643">      dt_omp_firstprivate(d, ovoid, P, roi_in, roi_out, central_pixel_weight) \</a>
<a name="ln1644">      firstprivate(inited_slide, norm) \</a>
<a name="ln1645">      shared(kj, ki, in, Sa) \</a>
<a name="ln1646">      schedule(static)</a>
<a name="ln1647">#endif</a>
<a name="ln1648">      for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1649">      {</a>
<a name="ln1650">        if(j + kj &lt; 0 || j + kj &gt;= roi_out-&gt;height) continue;</a>
<a name="ln1651">        float *S = Sa + dt_get_thread_num() * roi_out-&gt;width;</a>
<a name="ln1652">        const float *ins = in + 4l * ((size_t)roi_in-&gt;width * (j + kj) + ki);</a>
<a name="ln1653">        float *out = ((float *)ovoid) + (size_t)4 * roi_out-&gt;width * j;</a>
<a name="ln1654"> </a>
<a name="ln1655">        const int Pm = MIN(MIN(P, j + kj), j);</a>
<a name="ln1656">        const int PM = MIN(MIN(P, roi_out-&gt;height - 1 - j - kj), roi_out-&gt;height - 1 - j);</a>
<a name="ln1657">        // first line of every thread</a>
<a name="ln1658">        // TODO: also every once in a while to assert numerical precision!</a>
<a name="ln1659">        if(!inited_slide)</a>
<a name="ln1660">        {</a>
<a name="ln1661">          // sum up a line</a>
<a name="ln1662">          memset(S, 0x0, sizeof(float) * roi_out-&gt;width);</a>
<a name="ln1663">          for(int jj = -Pm; jj &lt;= PM; jj++)</a>
<a name="ln1664">          {</a>
<a name="ln1665">            int i = MAX(0, -ki);</a>
<a name="ln1666">            float *s = S + i;</a>
<a name="ln1667">            const float *inp = in + 4 * i + (size_t)4 * roi_in-&gt;width * (j + jj);</a>
<a name="ln1668">            const float *inps = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j + jj + kj) + ki);</a>
<a name="ln1669">            const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln1670">            for(; i &lt; last; i++, inp += 4, inps += 4, s++)</a>
<a name="ln1671">            {</a>
<a name="ln1672">              for(int k = 0; k &lt; 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]);</a>
<a name="ln1673">            }</a>
<a name="ln1674">          }</a>
<a name="ln1675">          // only reuse this if we had a full stripe</a>
<a name="ln1676">          if(Pm == P &amp;&amp; PM == P) inited_slide = 1;</a>
<a name="ln1677">        }</a>
<a name="ln1678"> </a>
<a name="ln1679">        // sliding window for this line:</a>
<a name="ln1680">        float *s = S;</a>
<a name="ln1681">        float slide = 0.0f;</a>
<a name="ln1682">        // sum up the first -P..P</a>
<a name="ln1683">        for(int i = 0; i &lt; 2 * P + 1; i++) slide += s[i];</a>
<a name="ln1684">        for(int i = 0; i &lt; roi_out-&gt;width; i++, s++, ins += 4, out += 4)</a>
<a name="ln1685">        {</a>
<a name="ln1686">          // FIXME: the comment above is actually relevant even for 1000 px width already.</a>
<a name="ln1687">          // XXX    numerical precision will not forgive us:</a>
<a name="ln1688">          if(i - P &gt; 0 &amp;&amp; i + P &lt; roi_out-&gt;width) slide += s[P] - s[-P - 1];</a>
<a name="ln1689">          if(i + ki &gt;= 0 &amp;&amp; i + ki &lt; roi_out-&gt;width)</a>
<a name="ln1690">          {</a>
<a name="ln1691">            // TODO: could put that outside the loop.</a>
<a name="ln1692">            // DEBUG XXX bring back to computable range:</a>
<a name="ln1693">            const float iv[4] = { ins[0], ins[1], ins[2], 1.0f };</a>
<a name="ln1694">            const float *inp = in + 4 * i + (size_t)4 * roi_in-&gt;width * j;</a>
<a name="ln1695">            const float *inps = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j + kj) + ki);</a>
<a name="ln1696">            float contribution_center = 0.0f;</a>
<a name="ln1697">            for(int k = 0; k &lt; 3; k++) contribution_center += (inp[k] - inps[k]) * (inp[k] - inps[k]);</a>
<a name="ln1698">            // multiply the center contribution to be able to have a general setting</a>
<a name="ln1699">            // that does not depend on patch size.</a>
<a name="ln1700">            contribution_center *= (2 * P + 1) * (2 * P + 1);</a>
<a name="ln1701">            float patch_dissimilarity = slide + contribution_center * central_pixel_weight;</a>
<a name="ln1702">            patch_dissimilarity /= (1.0 + central_pixel_weight);</a>
<a name="ln1703">#if defined(_OPENMP) &amp;&amp; defined(OPENMP_SIMD_)</a>
<a name="ln1704">#pragma omp SIMD()</a>
<a name="ln1705">#endif</a>
<a name="ln1706">            for(size_t c = 0; c &lt; 4; c++)</a>
<a name="ln1707">            {</a>
<a name="ln1708">              out[c] += iv[c] * fast_mexp2f(fmaxf(0.0f, patch_dissimilarity * norm - 2.0f));</a>
<a name="ln1709">            }</a>
<a name="ln1710">          }</a>
<a name="ln1711">        }</a>
<a name="ln1712">        if(inited_slide &amp;&amp; j + P + 1 + MAX(0, kj) &lt; roi_out-&gt;height)</a>
<a name="ln1713">        {</a>
<a name="ln1714">          // sliding window in j direction:</a>
<a name="ln1715">          int i = MAX(0, -ki);</a>
<a name="ln1716">          s = S + i;</a>
<a name="ln1717">          const float *inp = in + 4 * i + 4l * (size_t)roi_in-&gt;width * (j + P + 1);</a>
<a name="ln1718">          const float *inps = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j + P + 1 + kj) + ki);</a>
<a name="ln1719">          const float *inm = in + 4 * i + 4l * (size_t)roi_in-&gt;width * (j - P);</a>
<a name="ln1720">          const float *inms = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j - P + kj) + ki);</a>
<a name="ln1721">          const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln1722">          for(; i &lt; last; i++, inp += 4, inps += 4, inm += 4, inms += 4, s++)</a>
<a name="ln1723">          {</a>
<a name="ln1724">            float stmp = s[0];</a>
<a name="ln1725">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1726">              stmp += ((inp[k] - inps[k]) * (inp[k] - inps[k]) - (inm[k] - inms[k]) * (inm[k] - inms[k]));</a>
<a name="ln1727">            s[0] = stmp;</a>
<a name="ln1728">          }</a>
<a name="ln1729">        }</a>
<a name="ln1730">        else</a>
<a name="ln1731">          inited_slide = 0;</a>
<a name="ln1732">      }</a>
<a name="ln1733">    }</a>
<a name="ln1734">  }</a>
<a name="ln1735"> </a>
<a name="ln1736">  float *const out = ((float *const)ovoid);</a>
<a name="ln1737"> </a>
<a name="ln1738">// normalize</a>
<a name="ln1739">#ifdef _OPENMP</a>
<a name="ln1740">#pragma omp parallel for default(none) \</a>
<a name="ln1741">  dt_omp_firstprivate(ch, out, roi_out) \</a>
<a name="ln1742">  schedule(static)</a>
<a name="ln1743">#endif</a>
<a name="ln1744">  for(size_t k = 0; k &lt; (size_t)ch * roi_out-&gt;width * roi_out-&gt;height; k += ch)</a>
<a name="ln1745">  {</a>
<a name="ln1746">    if(out[k + 3] &lt;= 0.0f) continue;</a>
<a name="ln1747">    for(size_t c = 0; c &lt; 4; c++)</a>
<a name="ln1748">    {</a>
<a name="ln1749">      out[k + c] *= (1.0f / out[k + 3]);</a>
<a name="ln1750">    }</a>
<a name="ln1751">  }</a>
<a name="ln1752"> </a>
<a name="ln1753">  // free shared tmp memory:</a>
<a name="ln1754">  dt_free_align(Sa);</a>
<a name="ln1755">  dt_free_align(in);</a>
<a name="ln1756">  if(!d-&gt;use_new_vst)</a>
<a name="ln1757">  {</a>
<a name="ln1758">    backtransform((float *)ovoid, roi_in-&gt;width, roi_in-&gt;height, aa, bb);</a>
<a name="ln1759">  }</a>
<a name="ln1760">  else</a>
<a name="ln1761">  {</a>
<a name="ln1762">    backtransform_v2((float *)ovoid, roi_in-&gt;width, roi_in-&gt;height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], d-&gt;bias - 0.5 * logf(scale), wb);</a>
<a name="ln1763">  }</a>
<a name="ln1764"> </a>
<a name="ln1765">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">#if defined(__SSE2__)</a>
<a name="ln1769">static void process_nlmeans_sse(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1770">                                const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1771">                                const dt_iop_roi_t *const roi_out)</a>
<a name="ln1772">{</a>
<a name="ln1773">  // this is called for preview and full pipe separately, each with its own pixelpipe piece.</a>
<a name="ln1774">  // get our data struct:</a>
<a name="ln1775">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)piece-&gt;data;</a>
<a name="ln1776"> </a>
<a name="ln1777">  // adjust to zoom size:</a>
<a name="ln1778">  const float scale = fminf(roi_in-&gt;scale, 2.0f) / fmaxf(piece-&gt;iscale, 1.0f);</a>
<a name="ln1779">  const int P = ceilf(d-&gt;radius * scale); // pixel filter size</a>
<a name="ln1780">  int K = d-&gt;nbhood; // nbhood</a>
<a name="ln1781">  float scattering = d-&gt;scattering;</a>
<a name="ln1782">  // Each patch has a width of 2P+1 and a height of 2P+1</a>
<a name="ln1783">  // thus, divide by (2P+1)^2.</a>
<a name="ln1784">  // The 0.045 was derived from the old formula, to keep the</a>
<a name="ln1785">  // norm identical when P=1, as the norm for P=1 seemed</a>
<a name="ln1786">  // to work quite well: 0.045 = 0.015 * (2 * P + 1) with P=1.</a>
<a name="ln1787">  float norm = .045f / ((2 * P + 1) * (2 * P + 1));</a>
<a name="ln1788">  if(!d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln1789">  {</a>
<a name="ln1790">    // use old formula</a>
<a name="ln1791">    norm = .015f / (2 * P + 1);</a>
<a name="ln1792">  }</a>
<a name="ln1793"> </a>
<a name="ln1794">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln1795">  {</a>
<a name="ln1796">    // much faster slightly more inaccurate preview</a>
<a name="ln1797">    const int maxk = (K * K * K + 7.0 * K * sqrt(K)) * scattering / 6.0 + K;</a>
<a name="ln1798">    K = MIN(3, K);</a>
<a name="ln1799">    scattering = (maxk - K) * 6.0 / (K * K * K + 7.0 * K * sqrt(K));</a>
<a name="ln1800">  }</a>
<a name="ln1801">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln1802">  {</a>
<a name="ln1803">    // much faster slightly more inaccurate preview</a>
<a name="ln1804">    const int maxk = (K * K * K + 7.0 * K * sqrt(K)) * scattering / 6.0 + K;</a>
<a name="ln1805">    K = MAX(MIN(4, K), K * scale);</a>
<a name="ln1806">    scattering = (maxk - K) * 6.0 / (K * K * K + 7.0 * K * sqrt(K));</a>
<a name="ln1807">  }</a>
<a name="ln1808"> </a>
<a name="ln1809">  // P == 0 : this will degenerate to a (fast) bilateral filter.</a>
<a name="ln1810"> </a>
<a name="ln1811">  float *Sa = dt_alloc_align(64, (size_t)sizeof(float) * roi_out-&gt;width * dt_get_num_threads());</a>
<a name="ln1812">  // we want to sum up weights in col[3], so need to init to 0:</a>
<a name="ln1813">  memset(ovoid, 0x0, (size_t)sizeof(float) * roi_out-&gt;width * roi_out-&gt;height * 4);</a>
<a name="ln1814">  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln1815"> </a>
<a name="ln1816">  const float wb_mean = (piece-&gt;pipe-&gt;dsc.temperature.coeffs[0] + piece-&gt;pipe-&gt;dsc.temperature.coeffs[1]</a>
<a name="ln1817">                         + piece-&gt;pipe-&gt;dsc.temperature.coeffs[2])</a>
<a name="ln1818">                        / 3.0f;</a>
<a name="ln1819">  // we init wb by the mean of the coeffs, which corresponds to the mean</a>
<a name="ln1820">  // amplification that is done in addition to the &quot;ISO&quot; related amplification</a>
<a name="ln1821">  float wb[3] = { wb_mean, wb_mean, wb_mean };</a>
<a name="ln1822">  if(d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln1823">  {</a>
<a name="ln1824">    if(wb_mean != 0.0f &amp;&amp; d-&gt;wb_adaptive_anscombe)</a>
<a name="ln1825">    {</a>
<a name="ln1826">      for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.temperature.coeffs[i];</a>
<a name="ln1827">    }</a>
<a name="ln1828">    else if(wb_mean == 0.0f)</a>
<a name="ln1829">    {</a>
<a name="ln1830">      // temperature coeffs are equal to 0 if we open a JPG image.</a>
<a name="ln1831">      // in this case consider them equal to 1.</a>
<a name="ln1832">      for(int i = 0; i &lt; 3; i++) wb[i] = 1.0f;</a>
<a name="ln1833">    }</a>
<a name="ln1834">    // else, wb_adaptive_anscombe is false and our wb array is</a>
<a name="ln1835">    // filled with the wb_mean</a>
<a name="ln1836">  }</a>
<a name="ln1837">  else</a>
<a name="ln1838">  {</a>
<a name="ln1839">    for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.processed_maximum[i];</a>
<a name="ln1840">  }</a>
<a name="ln1841">  // adaptive p depending on white balance</a>
<a name="ln1842">  const float p[3] = { MAX(d-&gt;shadows + 0.1 * logf(scale / wb[0]), 0.0f) ,</a>
<a name="ln1843">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[1]), 0.0f),</a>
<a name="ln1844">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[2]), 0.0f)};</a>
<a name="ln1845">  // update the coeffs with strength and scale</a>
<a name="ln1846">  for(int i = 0; i &lt; 3; i++) wb[i] *= d-&gt;strength * scale;</a>
<a name="ln1847">  const float central_pixel_weight = d-&gt;central_pixel_weight * scale;</a>
<a name="ln1848"> </a>
<a name="ln1849">  const float aa[3] = { d-&gt;a[1] * wb[0], d-&gt;a[1] * wb[1], d-&gt;a[1] * wb[2] };</a>
<a name="ln1850">  const float bb[3] = { d-&gt;b[1] * wb[0], d-&gt;b[1] * wb[1], d-&gt;b[1] * wb[2] };</a>
<a name="ln1851">  const float compensate_p = DT_IOP_DENOISE_PROFILE_P_FULCRUM / powf(DT_IOP_DENOISE_PROFILE_P_FULCRUM, d-&gt;shadows);</a>
<a name="ln1852">  if(!d-&gt;use_new_vst)</a>
<a name="ln1853">  {</a>
<a name="ln1854">    precondition((float *)ivoid, in, roi_in-&gt;width, roi_in-&gt;height, aa, bb);</a>
<a name="ln1855">  }</a>
<a name="ln1856">  else</a>
<a name="ln1857">  {</a>
<a name="ln1858">    precondition_v2((float *)ivoid, in, roi_in-&gt;width, roi_in-&gt;height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], wb);</a>
<a name="ln1859">  }</a>
<a name="ln1860"> </a>
<a name="ln1861">  // for each shift vector</a>
<a name="ln1862">  for(int kj_index = -K; kj_index &lt;= K; kj_index++)</a>
<a name="ln1863">  {</a>
<a name="ln1864">    for(int ki_index = -K; ki_index &lt;= K; ki_index++)</a>
<a name="ln1865">    {</a>
<a name="ln1866">      // This formula is made for:</a>
<a name="ln1867">      // - ensuring that kj = kj_index and ki = ki_index when d-&gt;scattering is 0</a>
<a name="ln1868">      // - ensuring that no patch can appear twice (provided that d-&gt;scattering is in 0,1 range)</a>
<a name="ln1869">      // - avoiding grid artifacts by trying to take patches on various lines and columns</a>
<a name="ln1870">      const int abs_kj = abs(kj_index);</a>
<a name="ln1871">      const int abs_ki = abs(ki_index);</a>
<a name="ln1872">      int kj = scale * ((abs_kj * abs_kj * abs_kj + 7.0 * abs_kj * sqrt(abs_ki)) * sign(kj_index) * scattering / 6.0 + kj_index);</a>
<a name="ln1873">      int ki = scale * ((abs_ki * abs_ki * abs_ki + 7.0 * abs_ki * sqrt(abs_kj)) * sign(ki_index) * scattering / 6.0 + ki_index);</a>
<a name="ln1874"> </a>
<a name="ln1875">      int inited_slide = 0;</a>
<a name="ln1876">// don't construct summed area tables but use sliding window! (applies to cpu version res &lt; 1k only, or else</a>
<a name="ln1877">// we will add up errors)</a>
<a name="ln1878">// do this in parallel with a little threading overhead. could parallelize the outer loops with a bit more</a>
<a name="ln1879">// memory</a>
<a name="ln1880">#ifdef _OPENMP</a>
<a name="ln1881">#pragma omp parallel for default(none) \</a>
<a name="ln1882">      dt_omp_firstprivate(ovoid, P, roi_in, roi_out, central_pixel_weight) \</a>
<a name="ln1883">      firstprivate(inited_slide, d, norm) \</a>
<a name="ln1884">      shared(kj, ki, in, Sa) \</a>
<a name="ln1885">      schedule(static)</a>
<a name="ln1886">#endif</a>
<a name="ln1887">      for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln1888">      {</a>
<a name="ln1889">        if(j + kj &lt; 0 || j + kj &gt;= roi_out-&gt;height) continue;</a>
<a name="ln1890">        float *S = Sa + dt_get_thread_num() * roi_out-&gt;width;</a>
<a name="ln1891">        const float *ins = in + 4l * ((size_t)roi_in-&gt;width * (j + kj) + ki);</a>
<a name="ln1892">        float *out = ((float *)ovoid) + (size_t)4 * roi_out-&gt;width * j;</a>
<a name="ln1893"> </a>
<a name="ln1894">        const int Pm = MIN(MIN(P, j + kj), j);</a>
<a name="ln1895">        const int PM = MIN(MIN(P, roi_out-&gt;height - 1 - j - kj), roi_out-&gt;height - 1 - j);</a>
<a name="ln1896">        // first line of every thread</a>
<a name="ln1897">        // TODO: also every once in a while to assert numerical precision!</a>
<a name="ln1898">        if(!inited_slide)</a>
<a name="ln1899">        {</a>
<a name="ln1900">          // sum up a line</a>
<a name="ln1901">          memset(S, 0x0, sizeof(float) * roi_out-&gt;width);</a>
<a name="ln1902">          for(int jj = -Pm; jj &lt;= PM; jj++)</a>
<a name="ln1903">          {</a>
<a name="ln1904">            int i = MAX(0, -ki);</a>
<a name="ln1905">            float *s = S + i;</a>
<a name="ln1906">            const float *inp = in + 4 * i + (size_t)4 * roi_in-&gt;width * (j + jj);</a>
<a name="ln1907">            const float *inps = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j + jj + kj) + ki);</a>
<a name="ln1908">            const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln1909">            for(; i &lt; last; i++, inp += 4, inps += 4, s++)</a>
<a name="ln1910">            {</a>
<a name="ln1911">              for(int k = 0; k &lt; 3; k++) s[0] += (inp[k] - inps[k]) * (inp[k] - inps[k]);</a>
<a name="ln1912">            }</a>
<a name="ln1913">          }</a>
<a name="ln1914">          // only reuse this if we had a full stripe</a>
<a name="ln1915">          if(Pm == P &amp;&amp; PM == P) inited_slide = 1;</a>
<a name="ln1916">        }</a>
<a name="ln1917"> </a>
<a name="ln1918">        // sliding window for this line:</a>
<a name="ln1919">        float *s = S;</a>
<a name="ln1920">        float slide = 0.0f;</a>
<a name="ln1921">        // sum up the first -P..P</a>
<a name="ln1922">        for(int i = 0; i &lt; 2 * P + 1; i++) slide += s[i];</a>
<a name="ln1923">        for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln1924">        {</a>
<a name="ln1925">          // FIXME: the comment above is actually relevant even for 1000 px width already.</a>
<a name="ln1926">          // XXX    numerical precision will not forgive us:</a>
<a name="ln1927">          if(i - P &gt; 0 &amp;&amp; i + P &lt; roi_out-&gt;width) slide += s[P] - s[-P - 1];</a>
<a name="ln1928">          if(i + ki &gt;= 0 &amp;&amp; i + ki &lt; roi_out-&gt;width)</a>
<a name="ln1929">          {</a>
<a name="ln1930">            // TODO: could put that outside the loop.</a>
<a name="ln1931">            // DEBUG XXX bring back to computable range:</a>
<a name="ln1932">            const __m128 iv = { ins[0], ins[1], ins[2], 1.0f };</a>
<a name="ln1933">            const float *inp = in + 4 * i + (size_t)4 * roi_in-&gt;width * j;</a>
<a name="ln1934">            const float *inps = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j + kj) + ki);</a>
<a name="ln1935">            float contribution_center = 0.0f;</a>
<a name="ln1936">            for(int k = 0; k &lt; 3; k++) contribution_center += (inp[k] - inps[k]) * (inp[k] - inps[k]);</a>
<a name="ln1937">            // multiply the center contribution to be able to have a general setting</a>
<a name="ln1938">            // that does not depend on patch size.</a>
<a name="ln1939">            contribution_center *= (2 * P + 1) * (2 * P + 1);</a>
<a name="ln1940">            float patch_dissimilarity = slide + contribution_center * central_pixel_weight;</a>
<a name="ln1941">            patch_dissimilarity /= (1.0 + central_pixel_weight);</a>
<a name="ln1942">            _mm_store_ps(out, _mm_load_ps(out)</a>
<a name="ln1943">                                  + iv * _mm_set1_ps(fast_mexp2f(fmaxf(0.0f, patch_dissimilarity * norm - 2.0f))));</a>
<a name="ln1944">            // _mm_store_ps(out, _mm_load_ps(out) + iv * _mm_set1_ps(fast_mexp2f(fmaxf(0.0f, slide*norm))));</a>
<a name="ln1945">          }</a>
<a name="ln1946">          s++;</a>
<a name="ln1947">          ins += 4;</a>
<a name="ln1948">          out += 4;</a>
<a name="ln1949">        }</a>
<a name="ln1950">        if(inited_slide &amp;&amp; j + P + 1 + MAX(0, kj) &lt; roi_out-&gt;height)</a>
<a name="ln1951">        {</a>
<a name="ln1952">          // sliding window in j direction:</a>
<a name="ln1953">          int i = MAX(0, -ki);</a>
<a name="ln1954">          s = S + i;</a>
<a name="ln1955">          const float *inp = in + 4 * i + 4l * (size_t)roi_in-&gt;width * (j + P + 1);</a>
<a name="ln1956">          const float *inps = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j + P + 1 + kj) + ki);</a>
<a name="ln1957">          const float *inm = in + 4 * i + 4l * (size_t)roi_in-&gt;width * (j - P);</a>
<a name="ln1958">          const float *inms = in + 4 * i + 4l * ((size_t)roi_in-&gt;width * (j - P + kj) + ki);</a>
<a name="ln1959">          const int last = roi_out-&gt;width + MIN(0, -ki);</a>
<a name="ln1960">          for(; ((intptr_t)s &amp; 0xf) != 0 &amp;&amp; i &lt; last; i++, inp += 4, inps += 4, inm += 4, inms += 4, s++)</a>
<a name="ln1961">          {</a>
<a name="ln1962">            float stmp = s[0];</a>
<a name="ln1963">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln1964">              stmp += ((inp[k] - inps[k]) * (inp[k] - inps[k]) - (inm[k] - inms[k]) * (inm[k] - inms[k]));</a>
<a name="ln1965">            s[0] = stmp;</a>
<a name="ln1966">          }</a>
<a name="ln1967">          /* Process most of the line 4 pixels at a time */</a>
<a name="ln1968">          for(; i &lt; last - 4; i += 4, inp += 16, inps += 16, inm += 16, inms += 16, s += 4)</a>
<a name="ln1969">          {</a>
<a name="ln1970">            __m128 sv = _mm_load_ps(s);</a>
<a name="ln1971">            const __m128 inp1 = _mm_sub_ps(_mm_load_ps(inp), _mm_load_ps(inps));</a>
<a name="ln1972">            const __m128 inp2 = _mm_sub_ps(_mm_load_ps(inp + 4), _mm_load_ps(inps + 4));</a>
<a name="ln1973">            const __m128 inp3 = _mm_sub_ps(_mm_load_ps(inp + 8), _mm_load_ps(inps + 8));</a>
<a name="ln1974">            const __m128 inp4 = _mm_sub_ps(_mm_load_ps(inp + 12), _mm_load_ps(inps + 12));</a>
<a name="ln1975"> </a>
<a name="ln1976">            const __m128 inp12lo = _mm_unpacklo_ps(inp1, inp2);</a>
<a name="ln1977">            const __m128 inp34lo = _mm_unpacklo_ps(inp3, inp4);</a>
<a name="ln1978">            const __m128 inp12hi = _mm_unpackhi_ps(inp1, inp2);</a>
<a name="ln1979">            const __m128 inp34hi = _mm_unpackhi_ps(inp3, inp4);</a>
<a name="ln1980"> </a>
<a name="ln1981">            const __m128 inpv0 = _mm_movelh_ps(inp12lo, inp34lo);</a>
<a name="ln1982">            sv += inpv0 * inpv0;</a>
<a name="ln1983"> </a>
<a name="ln1984">            const __m128 inpv1 = _mm_movehl_ps(inp34lo, inp12lo);</a>
<a name="ln1985">            sv += inpv1 * inpv1;</a>
<a name="ln1986"> </a>
<a name="ln1987">            const __m128 inpv2 = _mm_movelh_ps(inp12hi, inp34hi);</a>
<a name="ln1988">            sv += inpv2 * inpv2;</a>
<a name="ln1989"> </a>
<a name="ln1990">            const __m128 inm1 = _mm_sub_ps(_mm_load_ps(inm), _mm_load_ps(inms));</a>
<a name="ln1991">            const __m128 inm2 = _mm_sub_ps(_mm_load_ps(inm + 4), _mm_load_ps(inms + 4));</a>
<a name="ln1992">            const __m128 inm3 = _mm_sub_ps(_mm_load_ps(inm + 8), _mm_load_ps(inms + 8));</a>
<a name="ln1993">            const __m128 inm4 = _mm_sub_ps(_mm_load_ps(inm + 12), _mm_load_ps(inms + 12));</a>
<a name="ln1994"> </a>
<a name="ln1995">            const __m128 inm12lo = _mm_unpacklo_ps(inm1, inm2);</a>
<a name="ln1996">            const __m128 inm34lo = _mm_unpacklo_ps(inm3, inm4);</a>
<a name="ln1997">            const __m128 inm12hi = _mm_unpackhi_ps(inm1, inm2);</a>
<a name="ln1998">            const __m128 inm34hi = _mm_unpackhi_ps(inm3, inm4);</a>
<a name="ln1999"> </a>
<a name="ln2000">            const __m128 inmv0 = _mm_movelh_ps(inm12lo, inm34lo);</a>
<a name="ln2001">            sv -= inmv0 * inmv0;</a>
<a name="ln2002"> </a>
<a name="ln2003">            const __m128 inmv1 = _mm_movehl_ps(inm34lo, inm12lo);</a>
<a name="ln2004">            sv -= inmv1 * inmv1;</a>
<a name="ln2005"> </a>
<a name="ln2006">            const __m128 inmv2 = _mm_movelh_ps(inm12hi, inm34hi);</a>
<a name="ln2007">            sv -= inmv2 * inmv2;</a>
<a name="ln2008"> </a>
<a name="ln2009">            _mm_store_ps(s, sv);</a>
<a name="ln2010">          }</a>
<a name="ln2011">          for(; i &lt; last; i++, inp += 4, inps += 4, inm += 4, inms += 4, s++)</a>
<a name="ln2012">          {</a>
<a name="ln2013">            float stmp = s[0];</a>
<a name="ln2014">            for(int k = 0; k &lt; 3; k++)</a>
<a name="ln2015">              stmp += ((inp[k] - inps[k]) * (inp[k] - inps[k]) - (inm[k] - inms[k]) * (inm[k] - inms[k]));</a>
<a name="ln2016">            s[0] = stmp;</a>
<a name="ln2017">          }</a>
<a name="ln2018">        }</a>
<a name="ln2019">        else</a>
<a name="ln2020">          inited_slide = 0;</a>
<a name="ln2021">      }</a>
<a name="ln2022">    }</a>
<a name="ln2023">  }</a>
<a name="ln2024">// normalize</a>
<a name="ln2025">#ifdef _OPENMP</a>
<a name="ln2026">#pragma omp parallel for default(none) \</a>
<a name="ln2027">  dt_omp_firstprivate(ovoid, roi_out) \</a>
<a name="ln2028">  shared(d) \</a>
<a name="ln2029">  schedule(static)</a>
<a name="ln2030">#endif</a>
<a name="ln2031">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2032">  {</a>
<a name="ln2033">    float *out = ((float *)ovoid) + (size_t)4 * roi_out-&gt;width * j;</a>
<a name="ln2034">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2035">    {</a>
<a name="ln2036">      if(out[3] &gt; 0.0f) _mm_store_ps(out, _mm_mul_ps(_mm_load_ps(out), _mm_set1_ps(1.0f / out[3])));</a>
<a name="ln2037">      // DEBUG show weights</a>
<a name="ln2038">      // _mm_store_ps(out, _mm_set1_ps(1.0f/out[3]));</a>
<a name="ln2039">      out += 4;</a>
<a name="ln2040">    }</a>
<a name="ln2041">  }</a>
<a name="ln2042">  // free shared tmp memory:</a>
<a name="ln2043">  dt_free_align(Sa);</a>
<a name="ln2044">  dt_free_align(in);</a>
<a name="ln2045">  if(!d-&gt;use_new_vst)</a>
<a name="ln2046">  {</a>
<a name="ln2047">    backtransform((float *)ovoid, roi_in-&gt;width, roi_in-&gt;height, aa, bb);</a>
<a name="ln2048">  }</a>
<a name="ln2049">  else</a>
<a name="ln2050">  {</a>
<a name="ln2051">    backtransform_v2((float *)ovoid, roi_in-&gt;width, roi_in-&gt;height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], d-&gt;bias - 0.5 * logf(scale), wb);</a>
<a name="ln2052">  }</a>
<a name="ln2053"> </a>
<a name="ln2054">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln2055">}</a>
<a name="ln2056">#endif</a>
<a name="ln2057"> </a>
<a name="ln2058">static void sum_rec(const unsigned npixels, const float *in, float *out)</a>
<a name="ln2059">{</a>
<a name="ln2060">  if(npixels &lt;= 3)</a>
<a name="ln2061">  {</a>
<a name="ln2062">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2063">    {</a>
<a name="ln2064">      out[c] = 0.0;</a>
<a name="ln2065">    }</a>
<a name="ln2066">    for(int i = 0; i &lt; npixels; i++)</a>
<a name="ln2067">    {</a>
<a name="ln2068">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2069">      {</a>
<a name="ln2070">        out[c] += in[i * 4 + c];</a>
<a name="ln2071">      }</a>
<a name="ln2072">    }</a>
<a name="ln2073">    return;</a>
<a name="ln2074">  }</a>
<a name="ln2075"> </a>
<a name="ln2076">  unsigned npixels_first_half = npixels &gt;&gt; 1;</a>
<a name="ln2077">  unsigned npixels_second_half = npixels - npixels_first_half;</a>
<a name="ln2078">  sum_rec(npixels_first_half, in, out);</a>
<a name="ln2079">  sum_rec(npixels_second_half, in + 4 * npixels_first_half, out + 4 * npixels_first_half);</a>
<a name="ln2080">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2081">  {</a>
<a name="ln2082">    out[c] += out[4 * npixels_first_half + c];</a>
<a name="ln2083">  }</a>
<a name="ln2084">}</a>
<a name="ln2085"> </a>
<a name="ln2086">/* this gives (npixels-1)*V[X] */</a>
<a name="ln2087">static void variance_rec(const unsigned npixels, const float *in, float *out, const float mean[3])</a>
<a name="ln2088">{</a>
<a name="ln2089">  if(npixels &lt;= 3)</a>
<a name="ln2090">  {</a>
<a name="ln2091">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2092">    {</a>
<a name="ln2093">      out[c] = 0.0;</a>
<a name="ln2094">    }</a>
<a name="ln2095">    for(int i = 0; i &lt; npixels; i++)</a>
<a name="ln2096">    {</a>
<a name="ln2097">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2098">      {</a>
<a name="ln2099">        float diff = in[i * 4 + c] - mean[c];</a>
<a name="ln2100">        out[c] += diff * diff;</a>
<a name="ln2101">      }</a>
<a name="ln2102">    }</a>
<a name="ln2103">    return;</a>
<a name="ln2104">  }</a>
<a name="ln2105"> </a>
<a name="ln2106">  unsigned npixels_first_half = npixels &gt;&gt; 1;</a>
<a name="ln2107">  unsigned npixels_second_half = npixels - npixels_first_half;</a>
<a name="ln2108">  variance_rec(npixels_first_half, in, out, mean);</a>
<a name="ln2109">  variance_rec(npixels_second_half, in + 4 * npixels_first_half, out + 4 * npixels_first_half, mean);</a>
<a name="ln2110">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2111">  {</a>
<a name="ln2112">    out[c] += out[4 * npixels_first_half + c];</a>
<a name="ln2113">  }</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">static void process_variance(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln2117">                             void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2118">                             const dt_iop_roi_t *const roi_out)</a>
<a name="ln2119">{</a>
<a name="ln2120">  const dt_iop_denoiseprofile_data_t *const d = piece-&gt;data;</a>
<a name="ln2121">  dt_iop_denoiseprofile_gui_data_t *g = self-&gt;gui_data;</a>
<a name="ln2122"> </a>
<a name="ln2123">  const int width = roi_in-&gt;width, height = roi_in-&gt;height;</a>
<a name="ln2124">  size_t npixels = (size_t)width * height;</a>
<a name="ln2125"> </a>
<a name="ln2126">  memcpy(ovoid, ivoid, npixels * 4 * sizeof(float));</a>
<a name="ln2127">  if((piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW) || (g == NULL))</a>
<a name="ln2128">  {</a>
<a name="ln2129">    return;</a>
<a name="ln2130">  }</a>
<a name="ln2131"> </a>
<a name="ln2132">  float *in = dt_alloc_align(64, (size_t)4 * sizeof(float) * roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln2133"> </a>
<a name="ln2134">  const float wb_mean = (piece-&gt;pipe-&gt;dsc.temperature.coeffs[0] + piece-&gt;pipe-&gt;dsc.temperature.coeffs[1]</a>
<a name="ln2135">                         + piece-&gt;pipe-&gt;dsc.temperature.coeffs[2])</a>
<a name="ln2136">                        / 3.0f;</a>
<a name="ln2137">  // we init wb by the mean of the coeffs, which corresponds to the mean</a>
<a name="ln2138">  // amplification that is done in addition to the &quot;ISO&quot; related amplification</a>
<a name="ln2139">  float wb[3] = { wb_mean, wb_mean, wb_mean };</a>
<a name="ln2140">  if(d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln2141">  {</a>
<a name="ln2142">    if(wb_mean != 0.0f &amp;&amp; d-&gt;wb_adaptive_anscombe)</a>
<a name="ln2143">    {</a>
<a name="ln2144">      for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.temperature.coeffs[i];</a>
<a name="ln2145">    }</a>
<a name="ln2146">    else if(wb_mean == 0.0f)</a>
<a name="ln2147">    {</a>
<a name="ln2148">      // temperature coeffs are equal to 0 if we open a JPG image.</a>
<a name="ln2149">      // in this case consider them equal to 1.</a>
<a name="ln2150">      for(int i = 0; i &lt; 3; i++) wb[i] = 1.0f;</a>
<a name="ln2151">    }</a>
<a name="ln2152">    // else, wb_adaptive_anscombe is false and our wb array is</a>
<a name="ln2153">    // filled with the wb_mean</a>
<a name="ln2154">  }</a>
<a name="ln2155">  else</a>
<a name="ln2156">  {</a>
<a name="ln2157">    for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.processed_maximum[i];</a>
<a name="ln2158">  }</a>
<a name="ln2159">  // adaptive p depending on white balance</a>
<a name="ln2160">  const float p[3] = { MAX(d-&gt;shadows - 0.1 * logf(wb[0]), 0.0f),</a>
<a name="ln2161">                       MAX(d-&gt;shadows - 0.1 * logf(wb[1]), 0.0f),</a>
<a name="ln2162">                       MAX(d-&gt;shadows - 0.1 * logf(wb[2]), 0.0f)};</a>
<a name="ln2163"> </a>
<a name="ln2164">  // update the coeffs with strength</a>
<a name="ln2165">  for(int i = 0; i &lt; 3; i++) wb[i] *= d-&gt;strength;</a>
<a name="ln2166"> </a>
<a name="ln2167">  const float compensate_p = DT_IOP_DENOISE_PROFILE_P_FULCRUM / powf(DT_IOP_DENOISE_PROFILE_P_FULCRUM, d-&gt;shadows);</a>
<a name="ln2168">  precondition_v2((float *)ivoid, (float *)ovoid, roi_in-&gt;width, roi_in-&gt;height, d-&gt;a[1] * compensate_p, p, d-&gt;b[1], wb);</a>
<a name="ln2169"> </a>
<a name="ln2170">  float *out = (float *)ovoid;</a>
<a name="ln2171">  // we use out as a temporary buffer here</a>
<a name="ln2172">  // compute mean</a>
<a name="ln2173">  sum_rec(npixels, in, out);</a>
<a name="ln2174">  float mean[3];</a>
<a name="ln2175">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2176">  {</a>
<a name="ln2177">    mean[c] = out[c] / npixels;</a>
<a name="ln2178">  }</a>
<a name="ln2179">  variance_rec(npixels, in, out, mean);</a>
<a name="ln2180">  float var[3];</a>
<a name="ln2181">  for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2182">  {</a>
<a name="ln2183">    var[c] = out[c] / (npixels - 1);</a>
<a name="ln2184">  }</a>
<a name="ln2185">  g-&gt;variance_R = var[0];</a>
<a name="ln2186">  g-&gt;variance_G = var[1];</a>
<a name="ln2187">  g-&gt;variance_B = var[2];</a>
<a name="ln2188"> </a>
<a name="ln2189">  memcpy(ovoid, ivoid, npixels * 4 * sizeof(float));</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">#ifdef HAVE_OPENCL</a>
<a name="ln2193">static int bucket_next(unsigned int *state, unsigned int max)</a>
<a name="ln2194">{</a>
<a name="ln2195">  unsigned int current = *state;</a>
<a name="ln2196">  unsigned int next = (current &gt;= max - 1 ? 0 : current + 1);</a>
<a name="ln2197"> </a>
<a name="ln2198">  *state = next;</a>
<a name="ln2199"> </a>
<a name="ln2200">  return next;</a>
<a name="ln2201">}</a>
<a name="ln2202"> </a>
<a name="ln2203">static int process_nlmeans_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln2204">                              cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2205">                              const dt_iop_roi_t *const roi_out)</a>
<a name="ln2206">{</a>
<a name="ln2207">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)piece-&gt;data;</a>
<a name="ln2208">  dt_iop_denoiseprofile_global_data_t *gd = (dt_iop_denoiseprofile_global_data_t *)self-&gt;global_data;</a>
<a name="ln2209"> </a>
<a name="ln2210">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2211">  const int width = roi_in-&gt;width;</a>
<a name="ln2212">  const int height = roi_in-&gt;height;</a>
<a name="ln2213"> </a>
<a name="ln2214">  cl_mem dev_tmp = NULL;</a>
<a name="ln2215">  cl_mem dev_U2 = NULL;</a>
<a name="ln2216">  cl_mem dev_U4 = NULL;</a>
<a name="ln2217">  cl_mem dev_U4_t = NULL;</a>
<a name="ln2218">  cl_mem dev_U4_tt = NULL;</a>
<a name="ln2219"> </a>
<a name="ln2220">  unsigned int state = 0;</a>
<a name="ln2221">  cl_mem buckets[NUM_BUCKETS] = { NULL };</a>
<a name="ln2222"> </a>
<a name="ln2223"> </a>
<a name="ln2224">  cl_int err = -999;</a>
<a name="ln2225"> </a>
<a name="ln2226">  const float scale = fminf(roi_in-&gt;scale, 2.0f) / fmaxf(piece-&gt;iscale, 1.0f);</a>
<a name="ln2227">  const int P = ceilf(d-&gt;radius * scale); // pixel filter size</a>
<a name="ln2228">  int K = d-&gt;nbhood; // nbhood</a>
<a name="ln2229">  float scattering = d-&gt;scattering;</a>
<a name="ln2230"> </a>
<a name="ln2231">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln2232">  {</a>
<a name="ln2233">    // much faster slightly more inaccurate preview</a>
<a name="ln2234">    const int maxk = (K * K * K + 7.0 * K * sqrt(K)) * scattering / 6.0 + K;</a>
<a name="ln2235">    K = MIN(3, K);</a>
<a name="ln2236">    scattering = (maxk - K) * 6.0 / (K * K * K + 7.0 * K * sqrt(K));</a>
<a name="ln2237">  }</a>
<a name="ln2238">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_FULL)</a>
<a name="ln2239">  {</a>
<a name="ln2240">    // much faster slightly more inaccurate preview</a>
<a name="ln2241">    const int maxk = (K * K * K + 7.0 * K * sqrt(K)) * scattering / 6.0 + K;</a>
<a name="ln2242">    K = MAX(MIN(4, K), K * scale);</a>
<a name="ln2243">    scattering = (maxk - K) * 6.0 / (K * K * K + 7.0 * K * sqrt(K));</a>
<a name="ln2244">  }</a>
<a name="ln2245"> </a>
<a name="ln2246">  // Each patch has a width of 2P+1 and a height of 2P+1</a>
<a name="ln2247">  // thus, divide by (2P+1)^2.</a>
<a name="ln2248">  // The 0.045 was derived from the old formula, to keep the</a>
<a name="ln2249">  // norm identical when P=1, as the norm for P=1 seemed</a>
<a name="ln2250">  // to work quite well: 0.045 = 0.015 * (2 * P + 1) with P=1.</a>
<a name="ln2251">  float norm = .045f / ((2 * P + 1) * (2 * P + 1));</a>
<a name="ln2252">  if(!d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln2253">  {</a>
<a name="ln2254">    // use old formula</a>
<a name="ln2255">    norm = .015f / (2 * P + 1);</a>
<a name="ln2256">  }</a>
<a name="ln2257"> </a>
<a name="ln2258">  const float wb_mean = (piece-&gt;pipe-&gt;dsc.temperature.coeffs[0] + piece-&gt;pipe-&gt;dsc.temperature.coeffs[1]</a>
<a name="ln2259">                         + piece-&gt;pipe-&gt;dsc.temperature.coeffs[2])</a>
<a name="ln2260">                        / 3.0f;</a>
<a name="ln2261">  // we init wb by the mean of the coeffs, which corresponds to the mean</a>
<a name="ln2262">  // amplification that is done in addition to the &quot;ISO&quot; related amplification</a>
<a name="ln2263">  float wb[4] = { wb_mean, wb_mean, wb_mean, 0.0f };</a>
<a name="ln2264">  if(d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln2265">  {</a>
<a name="ln2266">    if(wb_mean != 0.0f &amp;&amp; d-&gt;wb_adaptive_anscombe)</a>
<a name="ln2267">    {</a>
<a name="ln2268">      for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.temperature.coeffs[i];</a>
<a name="ln2269">    }</a>
<a name="ln2270">    else if(wb_mean == 0.0f)</a>
<a name="ln2271">    {</a>
<a name="ln2272">      // temperature coeffs are equal to 0 if we open a JPG image.</a>
<a name="ln2273">      // in this case consider them equal to 1.</a>
<a name="ln2274">      for(int i = 0; i &lt; 3; i++) wb[i] = 1.0f;</a>
<a name="ln2275">    }</a>
<a name="ln2276">    // else, wb_adaptive_anscombe is false and our wb array is</a>
<a name="ln2277">    // filled with the wb_mean</a>
<a name="ln2278">  }</a>
<a name="ln2279">  else</a>
<a name="ln2280">  {</a>
<a name="ln2281">    for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.processed_maximum[i];</a>
<a name="ln2282">  }</a>
<a name="ln2283">  // adaptive p depending on white balance</a>
<a name="ln2284">  const float p[4] = { MAX(d-&gt;shadows + 0.1 * logf(scale / wb[0]), 0.0f),</a>
<a name="ln2285">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[1]), 0.0f),</a>
<a name="ln2286">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[2]), 0.0f), 1.0f};</a>
<a name="ln2287"> </a>
<a name="ln2288">  // update the coeffs with strength and scale</a>
<a name="ln2289">  for(int i = 0; i &lt; 3; i++) wb[i] *= d-&gt;strength * scale;</a>
<a name="ln2290">  const float central_pixel_weight = d-&gt;central_pixel_weight * scale;</a>
<a name="ln2291"> </a>
<a name="ln2292">  float aa[4] = { d-&gt;a[1] * wb[0], d-&gt;a[1] * wb[1], d-&gt;a[1] * wb[2], 1.0f };</a>
<a name="ln2293">  float bb[4] = { d-&gt;b[1] * wb[0], d-&gt;b[1] * wb[1], d-&gt;b[1] * wb[2], 1.0f };</a>
<a name="ln2294">  const float sigma2[4] = { (bb[0] / aa[0]) * (bb[0] / aa[0]), (bb[1] / aa[1]) * (bb[1] / aa[1]),</a>
<a name="ln2295">                            (bb[2] / aa[2]) * (bb[2] / aa[2]), 0.0f };</a>
<a name="ln2296">  const float compensate_p = DT_IOP_DENOISE_PROFILE_P_FULCRUM / powf(DT_IOP_DENOISE_PROFILE_P_FULCRUM, d-&gt;shadows);</a>
<a name="ln2297">  if(d-&gt;use_new_vst)</a>
<a name="ln2298">  {</a>
<a name="ln2299">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2300">    {</a>
<a name="ln2301">      aa[c] = d-&gt;a[1] * compensate_p;</a>
<a name="ln2302">      bb[c] = d-&gt;b[1];</a>
<a name="ln2303">    }</a>
<a name="ln2304">  }</a>
<a name="ln2305"> </a>
<a name="ln2306">  dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2307">  if(dev_tmp == NULL) goto error;</a>
<a name="ln2308"> </a>
<a name="ln2309">  dev_U2 = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln2310">  if(dev_U2 == NULL) goto error;</a>
<a name="ln2311"> </a>
<a name="ln2312">  for(int k = 0; k &lt; NUM_BUCKETS; k++)</a>
<a name="ln2313">  {</a>
<a name="ln2314">    buckets[k] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(float));</a>
<a name="ln2315">    if(buckets[k] == NULL) goto error;</a>
<a name="ln2316">  }</a>
<a name="ln2317"> </a>
<a name="ln2318">  int hblocksize;</a>
<a name="ln2319">  dt_opencl_local_buffer_t hlocopt</a>
<a name="ln2320">    = (dt_opencl_local_buffer_t){ .xoffset = 2 * P, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln2321">                                  .cellsize = sizeof(float), .overhead = 0,</a>
<a name="ln2322">                                  .sizex = 1u &lt;&lt; 16, .sizey = 1 };</a>
<a name="ln2323"> </a>
<a name="ln2324">  if(dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_denoiseprofile_horiz, &amp;hlocopt))</a>
<a name="ln2325">    hblocksize = hlocopt.sizex;</a>
<a name="ln2326">  else</a>
<a name="ln2327">    hblocksize = 1;</a>
<a name="ln2328"> </a>
<a name="ln2329">  int vblocksize;</a>
<a name="ln2330">  dt_opencl_local_buffer_t vlocopt</a>
<a name="ln2331">    = (dt_opencl_local_buffer_t){ .xoffset = 1, .xfactor = 1, .yoffset = 2 * P, .yfactor = 1,</a>
<a name="ln2332">                                  .cellsize = sizeof(float), .overhead = 0,</a>
<a name="ln2333">                                  .sizex = 1, .sizey = 1u &lt;&lt; 16 };</a>
<a name="ln2334"> </a>
<a name="ln2335">  if(dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_denoiseprofile_vert, &amp;vlocopt))</a>
<a name="ln2336">    vblocksize = vlocopt.sizey;</a>
<a name="ln2337">  else</a>
<a name="ln2338">    vblocksize = 1;</a>
<a name="ln2339"> </a>
<a name="ln2340"> </a>
<a name="ln2341">  const size_t bwidth = ROUNDUP(width, hblocksize);</a>
<a name="ln2342">  const size_t bheight = ROUNDUP(height, vblocksize);</a>
<a name="ln2343"> </a>
<a name="ln2344">  const size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln2345">  size_t sizesl[3];</a>
<a name="ln2346">  size_t local[3];</a>
<a name="ln2347"> </a>
<a name="ln2348">  if(!d-&gt;use_new_vst)</a>
<a name="ln2349">  {</a>
<a name="ln2350">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln2351">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2352">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2353">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2354">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 4, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2355">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 5, 4 * sizeof(float), (void *)&amp;sigma2);</a>
<a name="ln2356">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_precondition, sizes);</a>
<a name="ln2357">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2358">  }</a>
<a name="ln2359">  else</a>
<a name="ln2360">  {</a>
<a name="ln2361">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln2362">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2363">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2364">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2365">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 4, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2366">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 5, 4 * sizeof(float), (void *)&amp;p);</a>
<a name="ln2367">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 6, 4 * sizeof(float), (void *)&amp;bb);</a>
<a name="ln2368">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 7, 4 * sizeof(float), (void *)&amp;wb);</a>
<a name="ln2369">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, sizes);</a>
<a name="ln2370">  }</a>
<a name="ln2371"> </a>
<a name="ln2372">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_init, 0, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln2373">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_init, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln2374">  dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_init, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln2375">  err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_init, sizes);</a>
<a name="ln2376">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln2377"> </a>
<a name="ln2378">  for(int kj_index = -K; kj_index &lt;= 0; kj_index++)</a>
<a name="ln2379">  {</a>
<a name="ln2380">    for(int ki_index = -K; ki_index &lt;= K; ki_index++)</a>
<a name="ln2381">    {</a>
<a name="ln2382">      // This formula is made for:</a>
<a name="ln2383">      // - ensuring that j = kj_index and i = ki_index when d-&gt;scattering is 0</a>
<a name="ln2384">      // - ensuring that no patch can appear twice (provided that d-&gt;scattering is in 0,1 range)</a>
<a name="ln2385">      // - avoiding grid artifacts by trying to take patches on various lines and columns</a>
<a name="ln2386">      const int abs_kj = abs(kj_index);</a>
<a name="ln2387">      const int abs_ki = abs(ki_index);</a>
<a name="ln2388">      const int j = scale * ((abs_kj * abs_kj * abs_kj + 7.0 * abs_kj * sqrt(abs_ki)) * sign(kj_index) * scattering / 6.0 + kj_index);</a>
<a name="ln2389">      const int i = scale * ((abs_ki * abs_ki * abs_ki + 7.0 * abs_ki * sqrt(abs_kj)) * sign(ki_index) * scattering / 6.0 + ki_index);</a>
<a name="ln2390">      int q[2] = { i, j };</a>
<a name="ln2391"> </a>
<a name="ln2392">      dev_U4 = buckets[bucket_next(&amp;state, NUM_BUCKETS)];</a>
<a name="ln2393">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_dist, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2394">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_dist, 1, sizeof(cl_mem), (void *)&amp;dev_U4);</a>
<a name="ln2395">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_dist, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2396">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_dist, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2397">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_dist, 4, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln2398">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_dist, sizes);</a>
<a name="ln2399">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln2400"> </a>
<a name="ln2401">      sizesl[0] = bwidth;</a>
<a name="ln2402">      sizesl[1] = ROUNDUPHT(height);</a>
<a name="ln2403">      sizesl[2] = 1;</a>
<a name="ln2404">      local[0] = hblocksize;</a>
<a name="ln2405">      local[1] = 1;</a>
<a name="ln2406">      local[2] = 1;</a>
<a name="ln2407">      dev_U4_t = buckets[bucket_next(&amp;state, NUM_BUCKETS)];</a>
<a name="ln2408">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 0, sizeof(cl_mem), (void *)&amp;dev_U4);</a>
<a name="ln2409">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 1, sizeof(cl_mem), (void *)&amp;dev_U4_t);</a>
<a name="ln2410">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2411">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2412">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 4, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln2413">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 5, sizeof(int), (void *)&amp;P);</a>
<a name="ln2414">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_horiz, 6, (hblocksize + 2 * P) * sizeof(float),</a>
<a name="ln2415">                               NULL);</a>
<a name="ln2416">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_denoiseprofile_horiz, sizesl, local);</a>
<a name="ln2417">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln2418"> </a>
<a name="ln2419">      sizesl[0] = ROUNDUPWD(width);</a>
<a name="ln2420">      sizesl[1] = bheight;</a>
<a name="ln2421">      sizesl[2] = 1;</a>
<a name="ln2422">      local[0] = 1;</a>
<a name="ln2423">      local[1] = vblocksize;</a>
<a name="ln2424">      local[2] = 1;</a>
<a name="ln2425">      dev_U4_tt = buckets[bucket_next(&amp;state, NUM_BUCKETS)];</a>
<a name="ln2426">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 0, sizeof(cl_mem), (void *)&amp;dev_U4_t);</a>
<a name="ln2427">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 1, sizeof(cl_mem), (void *)&amp;dev_U4_tt);</a>
<a name="ln2428">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2429">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2430">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 4, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln2431">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 5, sizeof(int), (void *)&amp;P);</a>
<a name="ln2432">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 6, sizeof(float), (void *)&amp;norm);</a>
<a name="ln2433">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 7, (vblocksize + 2 * P) * sizeof(float),</a>
<a name="ln2434">                               NULL);</a>
<a name="ln2435">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 8, sizeof(float),</a>
<a name="ln2436">                               (void *)&amp;central_pixel_weight);</a>
<a name="ln2437">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_vert, 9, sizeof(cl_mem), ((void *)&amp;dev_U4));</a>
<a name="ln2438">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_denoiseprofile_vert, sizesl, local);</a>
<a name="ln2439">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln2440"> </a>
<a name="ln2441"> </a>
<a name="ln2442">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_accu, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2443">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_accu, 1, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln2444">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_accu, 2, sizeof(cl_mem), (void *)&amp;dev_U4_tt);</a>
<a name="ln2445">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_accu, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln2446">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_accu, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln2447">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_accu, 5, 2 * sizeof(int), (void *)&amp;q);</a>
<a name="ln2448">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_accu, sizes);</a>
<a name="ln2449">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln2450"> </a>
<a name="ln2451">      if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln2452">        dt_opencl_finish(devid);</a>
<a name="ln2453"> </a>
<a name="ln2454">      // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln2455">      dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln2456">    }</a>
<a name="ln2457">  }</a>
<a name="ln2458"> </a>
<a name="ln2459">  if(!d-&gt;use_new_vst)</a>
<a name="ln2460">  {</a>
<a name="ln2461">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln2462">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 1, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln2463">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 2, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln2464">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln2465">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln2466">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 5, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2467">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish, 6, 4 * sizeof(float), (void *)&amp;sigma2);</a>
<a name="ln2468">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_finish, sizes);</a>
<a name="ln2469">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2470">  }</a>
<a name="ln2471">  else</a>
<a name="ln2472">  {</a>
<a name="ln2473">    const float bias = d-&gt;bias - 0.5 * logf(scale);</a>
<a name="ln2474">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln2475">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 1, sizeof(cl_mem), (void *)&amp;dev_U2);</a>
<a name="ln2476">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 2, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln2477">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln2478">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln2479">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 5, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2480">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 6, 4 * sizeof(float), (void *)&amp;p);</a>
<a name="ln2481">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 7, 4 * sizeof(float), (void *)&amp;bb);</a>
<a name="ln2482">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 8, sizeof(float), (void *)&amp;bias);</a>
<a name="ln2483">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_finish_v2, 9, 4 * sizeof(float), (void *)&amp;wb);</a>
<a name="ln2484">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_finish_v2, sizes);</a>
<a name="ln2485">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2486">  }</a>
<a name="ln2487"> </a>
<a name="ln2488">  for(int k = 0; k &lt; NUM_BUCKETS; k++)</a>
<a name="ln2489">  {</a>
<a name="ln2490">    dt_opencl_release_mem_object(buckets[k]);</a>
<a name="ln2491">  }</a>
<a name="ln2492">  dt_opencl_release_mem_object(dev_U2);</a>
<a name="ln2493">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2494">  return TRUE;</a>
<a name="ln2495"> </a>
<a name="ln2496">error:</a>
<a name="ln2497">  for(int k = 0; k &lt; NUM_BUCKETS; k++)</a>
<a name="ln2498">  {</a>
<a name="ln2499">    dt_opencl_release_mem_object(buckets[k]);</a>
<a name="ln2500">  }</a>
<a name="ln2501">  dt_opencl_release_mem_object(dev_U2);</a>
<a name="ln2502">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2503">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_denoiseprofile] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln2504">  return FALSE;</a>
<a name="ln2505">}</a>
<a name="ln2506"> </a>
<a name="ln2507"> </a>
<a name="ln2508">static int process_wavelets_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln2509">                               cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2510">                               const dt_iop_roi_t *const roi_out)</a>
<a name="ln2511">{</a>
<a name="ln2512">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)piece-&gt;data;</a>
<a name="ln2513">  dt_iop_denoiseprofile_global_data_t *gd = (dt_iop_denoiseprofile_global_data_t *)self-&gt;global_data;</a>
<a name="ln2514"> </a>
<a name="ln2515">  const int max_max_scale = DT_IOP_DENOISE_PROFILE_BANDS; // hard limit</a>
<a name="ln2516">  int max_scale = 0;</a>
<a name="ln2517">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln2518">  // largest desired filter on input buffer (20% of input dim)</a>
<a name="ln2519">  const float supp0</a>
<a name="ln2520">      = MIN(2 * (2u &lt;&lt; (max_max_scale - 1)) + 1,</a>
<a name="ln2521">            MAX(piece-&gt;buf_in.height * piece-&gt;iscale, piece-&gt;buf_in.width * piece-&gt;iscale) * 0.2f);</a>
<a name="ln2522">  const float i0 = dt_log2f((supp0 - 1.0f) * .5f);</a>
<a name="ln2523">  for(; max_scale &lt; max_max_scale; max_scale++)</a>
<a name="ln2524">  {</a>
<a name="ln2525">    // actual filter support on scaled buffer</a>
<a name="ln2526">    const float supp = 2 * (2u &lt;&lt; max_scale) + 1;</a>
<a name="ln2527">    // approximates this filter size on unscaled input image:</a>
<a name="ln2528">    const float supp_in = supp * (1.0f / scale);</a>
<a name="ln2529">    const float i_in = dt_log2f((supp_in - 1) * .5f) - 1.0f;</a>
<a name="ln2530">    // i_in = max_scale .. .. .. 0</a>
<a name="ln2531">    const float t = 1.0f - (i_in + .5f) / i0;</a>
<a name="ln2532">    if(t &lt; 0.0f) break;</a>
<a name="ln2533">  }</a>
<a name="ln2534"> </a>
<a name="ln2535">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2536">  cl_int err = -999;</a>
<a name="ln2537">  const int width = roi_in-&gt;width;</a>
<a name="ln2538">  const int height = roi_in-&gt;height;</a>
<a name="ln2539">  const size_t npixels = (size_t)width * height;</a>
<a name="ln2540"> </a>
<a name="ln2541">  cl_mem dev_tmp = NULL;</a>
<a name="ln2542">  cl_mem dev_buf1 = NULL;</a>
<a name="ln2543">  cl_mem dev_buf2 = NULL;</a>
<a name="ln2544">  cl_mem dev_m = NULL;</a>
<a name="ln2545">  cl_mem dev_r = NULL;</a>
<a name="ln2546">  cl_mem dev_filter = NULL;</a>
<a name="ln2547">  cl_mem *dev_detail = calloc(max_max_scale, sizeof(cl_mem));</a>
<a name="ln2548">  float *sumsum = NULL;</a>
<a name="ln2549"> </a>
<a name="ln2550">  // corner case of extremely small image. this is not really likely to happen but would cause issues later</a>
<a name="ln2551">  // when we divide by (n-1). so let's be prepared</a>
<a name="ln2552">  if(npixels &lt; 2)</a>
<a name="ln2553">  {</a>
<a name="ln2554">    // copy original input from dev_in -&gt; dev_out</a>
<a name="ln2555">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2556">    size_t region[] = { width, height, 1 };</a>
<a name="ln2557">    err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_out, origin, origin, region);</a>
<a name="ln2558">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2559">    free(dev_detail);</a>
<a name="ln2560">    return TRUE;</a>
<a name="ln2561">  }</a>
<a name="ln2562"> </a>
<a name="ln2563">  dt_opencl_local_buffer_t flocopt</a>
<a name="ln2564">    = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln2565">                                  .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln2566">                                  .sizex = 1u &lt;&lt; 4, .sizey = 1u &lt;&lt; 4 };</a>
<a name="ln2567"> </a>
<a name="ln2568">  if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_denoiseprofile_reduce_first, &amp;flocopt))</a>
<a name="ln2569">    goto error;</a>
<a name="ln2570"> </a>
<a name="ln2571">  const size_t bwidth = ROUNDUP(width, flocopt.sizex);</a>
<a name="ln2572">  const size_t bheight = ROUNDUP(height, flocopt.sizey);</a>
<a name="ln2573"> </a>
<a name="ln2574">  const int bufsize = (bwidth / flocopt.sizex) * (bheight / flocopt.sizey);</a>
<a name="ln2575"> </a>
<a name="ln2576">  dt_opencl_local_buffer_t slocopt</a>
<a name="ln2577">    = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln2578">                                  .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln2579">                                  .sizex = 1u &lt;&lt; 16, .sizey = 1 };</a>
<a name="ln2580"> </a>
<a name="ln2581">  if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_denoiseprofile_reduce_first, &amp;slocopt))</a>
<a name="ln2582">    goto error;</a>
<a name="ln2583"> </a>
<a name="ln2584">  const int reducesize = MIN(REDUCESIZE, ROUNDUP(bufsize, slocopt.sizex) / slocopt.sizex);</a>
<a name="ln2585"> </a>
<a name="ln2586">  dev_m = dt_opencl_alloc_device_buffer(devid, (size_t)bufsize * 4 * sizeof(float));</a>
<a name="ln2587">  if(dev_m == NULL) goto error;</a>
<a name="ln2588"> </a>
<a name="ln2589">  dev_r = dt_opencl_alloc_device_buffer(devid, (size_t)reducesize * 4 * sizeof(float));</a>
<a name="ln2590">  if(dev_r == NULL) goto error;</a>
<a name="ln2591"> </a>
<a name="ln2592">  sumsum = dt_alloc_align(64, (size_t)reducesize * 4 * sizeof(float));</a>
<a name="ln2593">  if(sumsum == NULL) goto error;</a>
<a name="ln2594"> </a>
<a name="ln2595">  dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2596">  if(dev_tmp == NULL) goto error;</a>
<a name="ln2597"> </a>
<a name="ln2598">  float m[] = { 0.0625f, 0.25f, 0.375f, 0.25f, 0.0625f }; // 1/16, 4/16, 6/16, 4/16, 1/16</a>
<a name="ln2599">  float mm[5][5];</a>
<a name="ln2600">  for(int j = 0; j &lt; 5; j++)</a>
<a name="ln2601">    for(int i = 0; i &lt; 5; i++) mm[j][i] = m[i] * m[j];</a>
<a name="ln2602"> </a>
<a name="ln2603">  dev_filter = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 25, mm);</a>
<a name="ln2604">  if(dev_filter == NULL) goto error;</a>
<a name="ln2605"> </a>
<a name="ln2606">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln2607">  {</a>
<a name="ln2608">    dev_detail[k] = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2609">    if(dev_detail[k] == NULL) goto error;</a>
<a name="ln2610">  }</a>
<a name="ln2611"> </a>
<a name="ln2612">  const float wb_mean = (piece-&gt;pipe-&gt;dsc.temperature.coeffs[0] + piece-&gt;pipe-&gt;dsc.temperature.coeffs[1]</a>
<a name="ln2613">                         + piece-&gt;pipe-&gt;dsc.temperature.coeffs[2])</a>
<a name="ln2614">                        / 3.0f;</a>
<a name="ln2615">  // we init wb by the mean of the coeffs, which corresponds to the mean</a>
<a name="ln2616">  // amplification that is done in addition to the &quot;ISO&quot; related amplification</a>
<a name="ln2617">  float wb[4] = { wb_mean, wb_mean, wb_mean, 0.0f };</a>
<a name="ln2618">  if(d-&gt;fix_anscombe_and_nlmeans_norm)</a>
<a name="ln2619">  {</a>
<a name="ln2620">    if(wb_mean != 0.0f &amp;&amp; d-&gt;wb_adaptive_anscombe)</a>
<a name="ln2621">    {</a>
<a name="ln2622">      for(int i = 0; i &lt; 3; i++) wb[i] = piece-&gt;pipe-&gt;dsc.temperature.coeffs[i];</a>
<a name="ln2623">    }</a>
<a name="ln2624">    else if(wb_mean == 0.0f)</a>
<a name="ln2625">    {</a>
<a name="ln2626">      // temperature coeffs are equal to 0 if we open a JPG image.</a>
<a name="ln2627">      // in this case consider them equal to 1.</a>
<a name="ln2628">      for(int i = 0; i &lt; 3; i++) wb[i] = 1.0f;</a>
<a name="ln2629">    }</a>
<a name="ln2630">    // else, wb_adaptive_anscombe is false and our wb array is</a>
<a name="ln2631">    // filled with the wb_mean</a>
<a name="ln2632">  }</a>
<a name="ln2633">  else</a>
<a name="ln2634">  {</a>
<a name="ln2635">    wb[0] = 2.0f * piece-&gt;pipe-&gt;dsc.processed_maximum[0];</a>
<a name="ln2636">    wb[1] = piece-&gt;pipe-&gt;dsc.processed_maximum[1];</a>
<a name="ln2637">    wb[2] = 2.0f * piece-&gt;pipe-&gt;dsc.processed_maximum[2];</a>
<a name="ln2638">  }</a>
<a name="ln2639">  // adaptive p depending on white balance</a>
<a name="ln2640">  const float p[4] = { MAX(d-&gt;shadows + 0.1 * logf(scale / wb[0]), 0.0f),</a>
<a name="ln2641">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[1]), 0.0f),</a>
<a name="ln2642">                       MAX(d-&gt;shadows + 0.1 * logf(scale / wb[2]), 0.0f), 1.0f};</a>
<a name="ln2643"> </a>
<a name="ln2644">  // update the coeffs with strength and scale</a>
<a name="ln2645">  for(int i = 0; i &lt; 3; i++) wb[i] *= d-&gt;strength * scale;</a>
<a name="ln2646"> </a>
<a name="ln2647">  float aa[4] = { d-&gt;a[1] * wb[0], d-&gt;a[1] * wb[1], d-&gt;a[1] * wb[2], 1.0f };</a>
<a name="ln2648">  float bb[4] = { d-&gt;b[1] * wb[0], d-&gt;b[1] * wb[1], d-&gt;b[1] * wb[2], 1.0f };</a>
<a name="ln2649">  const float sigma2[4] = { (bb[0] / aa[0]) * (bb[0] / aa[0]), (bb[1] / aa[1]) * (bb[1] / aa[1]),</a>
<a name="ln2650">                            (bb[2] / aa[2]) * (bb[2] / aa[2]), 0.0f };</a>
<a name="ln2651">  const float compensate_p = DT_IOP_DENOISE_PROFILE_P_FULCRUM / powf(DT_IOP_DENOISE_PROFILE_P_FULCRUM, d-&gt;shadows);</a>
<a name="ln2652">  if(d-&gt;use_new_vst)</a>
<a name="ln2653">  {</a>
<a name="ln2654">    for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2655">    {</a>
<a name="ln2656">      aa[c] = d-&gt;a[1] * compensate_p;</a>
<a name="ln2657">      bb[c] = d-&gt;b[1];</a>
<a name="ln2658">    }</a>
<a name="ln2659">  }</a>
<a name="ln2660"> </a>
<a name="ln2661">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln2662"> </a>
<a name="ln2663">  if(!d-&gt;use_new_vst)</a>
<a name="ln2664">  {</a>
<a name="ln2665">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln2666">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln2667">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2668">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2669">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 4, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2670">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition, 5, 4 * sizeof(float), (void *)&amp;sigma2);</a>
<a name="ln2671">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_precondition, sizes);</a>
<a name="ln2672">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2673">  }</a>
<a name="ln2674">  else</a>
<a name="ln2675">  {</a>
<a name="ln2676">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln2677">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln2678">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2679">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2680">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 4, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2681">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 5, 4 * sizeof(float), (void *)&amp;p);</a>
<a name="ln2682">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 6, 4 * sizeof(float), (void *)&amp;bb);</a>
<a name="ln2683">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, 7, 4 * sizeof(float), (void *)&amp;wb);</a>
<a name="ln2684">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_precondition_v2, sizes);</a>
<a name="ln2685">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2686">  }</a>
<a name="ln2687"> </a>
<a name="ln2688">  dev_buf1 = dev_out;</a>
<a name="ln2689">  dev_buf2 = dev_tmp;</a>
<a name="ln2690"> </a>
<a name="ln2691">  /* decompose image into detail scales and coarse */</a>
<a name="ln2692">  for(int s = 0; s &lt; max_scale; s++)</a>
<a name="ln2693">  {</a>
<a name="ln2694">    const float sigma = 1.0f;</a>
<a name="ln2695">    const float varf = sqrtf(2.0f + 2.0f * 4.0f * 4.0f + 6.0f * 6.0f) / 16.0f; // about 0.5</a>
<a name="ln2696">    const float sigma_band = powf(varf, s) * sigma;</a>
<a name="ln2697">    const float inv_sigma2 = 1.0f / (sigma_band * sigma_band);</a>
<a name="ln2698"> </a>
<a name="ln2699">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 0, sizeof(cl_mem), (void *)&amp;dev_buf1);</a>
<a name="ln2700">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 1, sizeof(cl_mem), (void *)&amp;dev_buf2);</a>
<a name="ln2701">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 2, sizeof(cl_mem),</a>
<a name="ln2702">                             (void *)&amp;dev_detail[s]);</a>
<a name="ln2703">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln2704">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln2705">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 5, sizeof(unsigned int),</a>
<a name="ln2706">                             (void *)&amp;s);</a>
<a name="ln2707">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 6, sizeof(float),</a>
<a name="ln2708">                             (void *)&amp;inv_sigma2);</a>
<a name="ln2709">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_decompose, 7, sizeof(cl_mem),</a>
<a name="ln2710">                             (void *)&amp;dev_filter);</a>
<a name="ln2711">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_decompose, sizes);</a>
<a name="ln2712">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2713"> </a>
<a name="ln2714">    // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln2715">    dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln2716"> </a>
<a name="ln2717">    // swap buffers</a>
<a name="ln2718">    cl_mem dev_buf3 = dev_buf2;</a>
<a name="ln2719">    dev_buf2 = dev_buf1;</a>
<a name="ln2720">    dev_buf1 = dev_buf3;</a>
<a name="ln2721">  }</a>
<a name="ln2722"> </a>
<a name="ln2723">  /* now synthesize again */</a>
<a name="ln2724">  for(int s = max_scale - 1; s &gt;= 0; s--)</a>
<a name="ln2725">  {</a>
<a name="ln2726">    // variance stabilizing transform maps sigma to unity.</a>
<a name="ln2727">    const float sigma = 1.0f;</a>
<a name="ln2728">    // it is then transformed by wavelet scales via the 5 tap a-trous filter:</a>
<a name="ln2729">    const float varf = sqrtf(2.0f + 2.0f * 4.0f * 4.0f + 6.0f * 6.0f) / 16.0f; // about 0.5</a>
<a name="ln2730">    const float sigma_band = powf(varf, s) * sigma;</a>
<a name="ln2731"> </a>
<a name="ln2732">    // determine thrs as bayesshrink</a>
<a name="ln2733">    float sum_y2[3] = { 0.0f };</a>
<a name="ln2734"> </a>
<a name="ln2735">    size_t lsizes[3];</a>
<a name="ln2736">    size_t llocal[3];</a>
<a name="ln2737"> </a>
<a name="ln2738">    lsizes[0] = bwidth;</a>
<a name="ln2739">    lsizes[1] = bheight;</a>
<a name="ln2740">    lsizes[2] = 1;</a>
<a name="ln2741">    llocal[0] = flocopt.sizex;</a>
<a name="ln2742">    llocal[1] = flocopt.sizey;</a>
<a name="ln2743">    llocal[2] = 1;</a>
<a name="ln2744">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_first, 0, sizeof(cl_mem),</a>
<a name="ln2745">                             &amp;(dev_detail[s]));</a>
<a name="ln2746">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_first, 1, sizeof(int), &amp;width);</a>
<a name="ln2747">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_first, 2, sizeof(int), &amp;height);</a>
<a name="ln2748">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_first, 3, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln2749">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_first, 4,</a>
<a name="ln2750">                             flocopt.sizex * flocopt.sizey * 4 * sizeof(float), NULL);</a>
<a name="ln2751">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_denoiseprofile_reduce_first, lsizes,</a>
<a name="ln2752">                                                 llocal);</a>
<a name="ln2753">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2754"> </a>
<a name="ln2755"> </a>
<a name="ln2756">    lsizes[0] = reducesize * slocopt.sizex;</a>
<a name="ln2757">    lsizes[1] = 1;</a>
<a name="ln2758">    lsizes[2] = 1;</a>
<a name="ln2759">    llocal[0] = slocopt.sizex;</a>
<a name="ln2760">    llocal[1] = 1;</a>
<a name="ln2761">    llocal[2] = 1;</a>
<a name="ln2762">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_second, 0, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln2763">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_second, 1, sizeof(cl_mem), &amp;dev_r);</a>
<a name="ln2764">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_second, 2, sizeof(int), &amp;bufsize);</a>
<a name="ln2765">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_reduce_second, 3, slocopt.sizex * 4 * sizeof(float),</a>
<a name="ln2766">                             NULL);</a>
<a name="ln2767">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_denoiseprofile_reduce_second, lsizes,</a>
<a name="ln2768">                                                 llocal);</a>
<a name="ln2769">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2770"> </a>
<a name="ln2771">    err = dt_opencl_read_buffer_from_device(devid, (void *)sumsum, dev_r, 0,</a>
<a name="ln2772">                                            (size_t)reducesize * 4 * sizeof(float), CL_TRUE);</a>
<a name="ln2773">    if(err != CL_SUCCESS)</a>
<a name="ln2774">      goto error;</a>
<a name="ln2775"> </a>
<a name="ln2776">    for(int k = 0; k &lt; reducesize; k++)</a>
<a name="ln2777">    {</a>
<a name="ln2778">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2779">      {</a>
<a name="ln2780">        sum_y2[c] += sumsum[4 * k + c];</a>
<a name="ln2781">      }</a>
<a name="ln2782">    }</a>
<a name="ln2783"> </a>
<a name="ln2784">    const float sb2 = sigma_band * sigma_band;</a>
<a name="ln2785">    const float var_y[3] = { sum_y2[0] / (npixels - 1.0f), sum_y2[1] / (npixels - 1.0f), sum_y2[2] / (npixels - 1.0f) };</a>
<a name="ln2786">    const float std_x[3] = { sqrtf(MAX(1e-6f, var_y[0] - sb2)), sqrtf(MAX(1e-6f, var_y[1] - sb2)),</a>
<a name="ln2787">                             sqrtf(MAX(1e-6f, var_y[2] - sb2)) };</a>
<a name="ln2788">    // add 8.0 here because it seemed a little weak</a>
<a name="ln2789">    float adjt[3] = { 8.0f, 8.0f, 8.0f };</a>
<a name="ln2790"> </a>
<a name="ln2791">    int offset_scale = DT_IOP_DENOISE_PROFILE_BANDS - max_scale;</a>
<a name="ln2792">    // current scale number is s+offset_scale</a>
<a name="ln2793">    // for instance, largest scale is DT_IOP_DENOISE_PROFILE_BANDS</a>
<a name="ln2794">    // max_scale only indicates the number of scales to process at THIS</a>
<a name="ln2795">    // zoom level, it does NOT corresponds to the the maximum number of scales.</a>
<a name="ln2796">    // in other words, max_scale is the maximum number of VISIBLE scales.</a>
<a name="ln2797">    // That is why we have this &quot;s+offset_scale&quot;</a>
<a name="ln2798">    float band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_ALL][DT_IOP_DENOISE_PROFILE_BANDS - (s + offset_scale + 1)];</a>
<a name="ln2799">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln2800">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln2801">    for(int ch = 0; ch &lt; 3; ch++)</a>
<a name="ln2802">    {</a>
<a name="ln2803">      adjt[ch] *= band_force_exp_2;</a>
<a name="ln2804">    }</a>
<a name="ln2805">    band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_R][DT_IOP_DENOISE_PROFILE_BANDS - (s + offset_scale + 1)];</a>
<a name="ln2806">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln2807">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln2808">    adjt[0] *= band_force_exp_2;</a>
<a name="ln2809">    band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_G][DT_IOP_DENOISE_PROFILE_BANDS - (s + offset_scale + 1)];</a>
<a name="ln2810">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln2811">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln2812">    adjt[1] *= band_force_exp_2;</a>
<a name="ln2813">    band_force_exp_2 = d-&gt;force[DT_DENOISE_PROFILE_B][DT_IOP_DENOISE_PROFILE_BANDS - (s + offset_scale + 1)];</a>
<a name="ln2814">    band_force_exp_2 *= band_force_exp_2;</a>
<a name="ln2815">    band_force_exp_2 *= 4; // scale to [0,4]. 1 is the neutral curve point</a>
<a name="ln2816">    adjt[2] *= band_force_exp_2;</a>
<a name="ln2817"> </a>
<a name="ln2818">    const float thrs[4] = { adjt[0] * sb2 / std_x[0], adjt[1] * sb2 / std_x[1], adjt[2] * sb2 / std_x[2], 0.0f };</a>
<a name="ln2819">    // fprintf(stderr, &quot;scale %d thrs %f %f %f\n&quot;, s, thrs[0], thrs[1], thrs[2]);</a>
<a name="ln2820"> </a>
<a name="ln2821">    const float boost[4] = { 1.0f, 1.0f, 1.0f, 1.0f };</a>
<a name="ln2822"> </a>
<a name="ln2823">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 0, sizeof(cl_mem),</a>
<a name="ln2824">                             (void *)&amp;dev_buf1);</a>
<a name="ln2825">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 1, sizeof(cl_mem),</a>
<a name="ln2826">                             (void *)&amp;dev_detail[s]);</a>
<a name="ln2827">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 2, sizeof(cl_mem),</a>
<a name="ln2828">                             (void *)&amp;dev_buf2);</a>
<a name="ln2829">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln2830">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln2831">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 5, sizeof(float), (void *)&amp;thrs[0]);</a>
<a name="ln2832">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 6, sizeof(float), (void *)&amp;thrs[1]);</a>
<a name="ln2833">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 7, sizeof(float), (void *)&amp;thrs[2]);</a>
<a name="ln2834">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 8, sizeof(float), (void *)&amp;thrs[3]);</a>
<a name="ln2835">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 9, sizeof(float), (void *)&amp;boost[0]);</a>
<a name="ln2836">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 10, sizeof(float),</a>
<a name="ln2837">                             (void *)&amp;boost[1]);</a>
<a name="ln2838">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 11, sizeof(float),</a>
<a name="ln2839">                             (void *)&amp;boost[2]);</a>
<a name="ln2840">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_synthesize, 12, sizeof(float),</a>
<a name="ln2841">                             (void *)&amp;boost[3]);</a>
<a name="ln2842">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_synthesize, sizes);</a>
<a name="ln2843">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2844"> </a>
<a name="ln2845">    // indirectly give gpu some air to breathe (and to do display related stuff)</a>
<a name="ln2846">    dt_iop_nap(darktable.opencl-&gt;micro_nap);</a>
<a name="ln2847"> </a>
<a name="ln2848">    // swap buffers</a>
<a name="ln2849">    cl_mem dev_buf3 = dev_buf2;</a>
<a name="ln2850">    dev_buf2 = dev_buf1;</a>
<a name="ln2851">    dev_buf1 = dev_buf3;</a>
<a name="ln2852">  }</a>
<a name="ln2853"> </a>
<a name="ln2854">  // copy output of last run of synthesize kernel to dev_tmp (if not already there)</a>
<a name="ln2855">  // note: we need to take swap of buffers into account, so current output lies in dev_buf1</a>
<a name="ln2856">  if(dev_buf1 != dev_tmp)</a>
<a name="ln2857">  {</a>
<a name="ln2858">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln2859">    size_t region[] = { width, height, 1 };</a>
<a name="ln2860">    err = dt_opencl_enqueue_copy_image(devid, dev_buf1, dev_tmp, origin, origin, region);</a>
<a name="ln2861">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2862">  }</a>
<a name="ln2863"> </a>
<a name="ln2864">  if(!d-&gt;use_new_vst)</a>
<a name="ln2865">  {</a>
<a name="ln2866">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2867">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln2868">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2869">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2870">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform, 4, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2871">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform, 5, 4 * sizeof(float), (void *)&amp;sigma2);</a>
<a name="ln2872">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_backtransform, sizes);</a>
<a name="ln2873">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2874">  }</a>
<a name="ln2875">  else</a>
<a name="ln2876">  {</a>
<a name="ln2877">    const float bias = d-&gt;bias - 0.5 * logf(scale);</a>
<a name="ln2878">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln2879">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln2880">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln2881">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln2882">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 4, 4 * sizeof(float), (void *)&amp;aa);</a>
<a name="ln2883">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 5, 4 * sizeof(float), (void *)&amp;p);</a>
<a name="ln2884">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 6, 4 * sizeof(float), (void *)&amp;bb);</a>
<a name="ln2885">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 7, 4 * sizeof(float), (void *)&amp;bias);</a>
<a name="ln2886">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, 8, 4 * sizeof(float), (void *)&amp;wb);</a>
<a name="ln2887">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_denoiseprofile_backtransform_v2, sizes);</a>
<a name="ln2888">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln2889">  }</a>
<a name="ln2890"> </a>
<a name="ln2891">  if(!darktable.opencl-&gt;async_pixelpipe || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_EXPORT)</a>
<a name="ln2892">    dt_opencl_finish(devid);</a>
<a name="ln2893"> </a>
<a name="ln2894"> </a>
<a name="ln2895">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln2896">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln2897">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2898">  dt_opencl_release_mem_object(dev_filter);</a>
<a name="ln2899">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln2900">    dt_opencl_release_mem_object(dev_detail[k]);</a>
<a name="ln2901">  free(dev_detail);</a>
<a name="ln2902">  dt_free_align(sumsum);</a>
<a name="ln2903">  return TRUE;</a>
<a name="ln2904"> </a>
<a name="ln2905">error:</a>
<a name="ln2906">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln2907">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln2908">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln2909">  dt_opencl_release_mem_object(dev_filter);</a>
<a name="ln2910">  for(int k = 0; k &lt; max_scale; k++)</a>
<a name="ln2911">    dt_opencl_release_mem_object(dev_detail[k]);</a>
<a name="ln2912">  free(dev_detail);</a>
<a name="ln2913">  dt_free_align(sumsum);</a>
<a name="ln2914">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_denoiseprofile] couldn't enqueue kernel! %d, devid %d\n&quot;, err, devid);</a>
<a name="ln2915">  return FALSE;</a>
<a name="ln2916">}</a>
<a name="ln2917"> </a>
<a name="ln2918">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln2919">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2920">{</a>
<a name="ln2921">  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece-&gt;data;</a>
<a name="ln2922"> </a>
<a name="ln2923">  if(d-&gt;mode == MODE_NLMEANS || d-&gt;mode == MODE_NLMEANS_AUTO)</a>
<a name="ln2924">  {</a>
<a name="ln2925">    return process_nlmeans_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln2926">  }</a>
<a name="ln2927">  else if(d-&gt;mode == MODE_WAVELETS || d-&gt;mode == MODE_WAVELETS_AUTO)</a>
<a name="ln2928">  {</a>
<a name="ln2929">    return process_wavelets_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln2930">  }</a>
<a name="ln2931">  else</a>
<a name="ln2932">  {</a>
<a name="ln2933">    dt_print(DT_DEBUG_OPENCL, &quot;[opencl_denoiseprofile] compute variance not yet supported by opencl code\n&quot;);</a>
<a name="ln2934">    return FALSE;</a>
<a name="ln2935">  }</a>
<a name="ln2936">}</a>
<a name="ln2937">#endif // HAVE_OPENCL</a>
<a name="ln2938"> </a>
<a name="ln2939">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln2940">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2941">{</a>
<a name="ln2942">  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece-&gt;data;</a>
<a name="ln2943">  if(d-&gt;mode == MODE_NLMEANS || d-&gt;mode == MODE_NLMEANS_AUTO)</a>
<a name="ln2944">    process_nlmeans(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln2945">  else if(d-&gt;mode == MODE_WAVELETS || d-&gt;mode == MODE_WAVELETS_AUTO)</a>
<a name="ln2946">    process_wavelets(self, piece, ivoid, ovoid, roi_in, roi_out, eaw_decompose, eaw_synthesize);</a>
<a name="ln2947">  else</a>
<a name="ln2948">    process_variance(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln2949">}</a>
<a name="ln2950"> </a>
<a name="ln2951">#if defined(__SSE2__)</a>
<a name="ln2952">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln2953">                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2954">{</a>
<a name="ln2955">  dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)piece-&gt;data;</a>
<a name="ln2956">  if(d-&gt;mode == MODE_NLMEANS || d-&gt;mode == MODE_NLMEANS_AUTO)</a>
<a name="ln2957">    process_nlmeans_sse(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln2958">  else if(d-&gt;mode == MODE_WAVELETS || d-&gt;mode == MODE_WAVELETS_AUTO)</a>
<a name="ln2959">    process_wavelets(self, piece, ivoid, ovoid, roi_in, roi_out, eaw_decompose_sse, eaw_synthesize_sse2);</a>
<a name="ln2960">  else</a>
<a name="ln2961">    process_variance(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln2962">}</a>
<a name="ln2963">#endif</a>
<a name="ln2964"> </a>
<a name="ln2965">static inline unsigned infer_radius_from_profile(const float a)</a>
<a name="ln2966">{</a>
<a name="ln2967">  return MIN((unsigned)(1.0f + a * 15000.0f + a * a * 300000.0f), 8);</a>
<a name="ln2968">}</a>
<a name="ln2969"> </a>
<a name="ln2970">static inline float infer_scattering_from_profile(const float a)</a>
<a name="ln2971">{</a>
<a name="ln2972">  return MIN(3000.0f * a, 1.0f);</a>
<a name="ln2973">}</a>
<a name="ln2974"> </a>
<a name="ln2975">static inline float infer_shadows_from_profile(const float a)</a>
<a name="ln2976">{</a>
<a name="ln2977">  return MIN(MAX(0.1f - 0.1 * logf(a), 0.7f), 1.8f);</a>
<a name="ln2978">}</a>
<a name="ln2979"> </a>
<a name="ln2980">static inline float infer_bias_from_profile(const float a)</a>
<a name="ln2981">{</a>
<a name="ln2982">  return -MAX(5 + 0.5 * logf(a), 0.0);</a>
<a name="ln2983">}</a>
<a name="ln2984"> </a>
<a name="ln2985">/** this will be called to init new defaults if a new image is loaded from film strip mode. */</a>
<a name="ln2986">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln2987">{</a>
<a name="ln2988">  // our module is disabled by default</a>
<a name="ln2989">  module-&gt;default_enabled = 0;</a>
<a name="ln2990">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2991">  if(g)</a>
<a name="ln2992">  {</a>
<a name="ln2993">    dt_bauhaus_combobox_clear(g-&gt;profile);</a>
<a name="ln2994"> </a>
<a name="ln2995">    // get matching profiles:</a>
<a name="ln2996">    char name[512];</a>
<a name="ln2997">    if(g-&gt;profiles) g_list_free_full(g-&gt;profiles, dt_noiseprofile_free);</a>
<a name="ln2998">    g-&gt;profiles = dt_noiseprofile_get_matching(&amp;module-&gt;dev-&gt;image_storage);</a>
<a name="ln2999">    g-&gt;interpolated = dt_noiseprofile_generic; // default to generic poissonian</a>
<a name="ln3000">    g_strlcpy(name, _(g-&gt;interpolated.name), sizeof(name));</a>
<a name="ln3001"> </a>
<a name="ln3002">    const int iso = module-&gt;dev-&gt;image_storage.exif_iso;</a>
<a name="ln3003">    dt_noiseprofile_t *last = NULL;</a>
<a name="ln3004">    for(GList *iter = g-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln3005">    {</a>
<a name="ln3006">      dt_noiseprofile_t *current = (dt_noiseprofile_t *)iter-&gt;data;</a>
<a name="ln3007"> </a>
<a name="ln3008">      if(current-&gt;iso == iso)</a>
<a name="ln3009">      {</a>
<a name="ln3010">        g-&gt;interpolated = *current;</a>
<a name="ln3011">        // signal later autodetection in commit_params:</a>
<a name="ln3012">        g-&gt;interpolated.a[0] = -1.0f;</a>
<a name="ln3013">        snprintf(name, sizeof(name), _(&quot;found match for ISO %d&quot;), iso);</a>
<a name="ln3014">        break;</a>
<a name="ln3015">      }</a>
<a name="ln3016">      if(last &amp;&amp; last-&gt;iso &lt; iso &amp;&amp; current-&gt;iso &gt; iso)</a>
<a name="ln3017">      {</a>
<a name="ln3018">        g-&gt;interpolated.iso = iso;</a>
<a name="ln3019">        dt_noiseprofile_interpolate(last, current, &amp;g-&gt;interpolated);</a>
<a name="ln3020">        // signal later autodetection in commit_params:</a>
<a name="ln3021">        g-&gt;interpolated.a[0] = -1.0f;</a>
<a name="ln3022">        snprintf(name, sizeof(name), _(&quot;interpolated from ISO %d and %d&quot;), last-&gt;iso, current-&gt;iso);</a>
<a name="ln3023">        break;</a>
<a name="ln3024">      }</a>
<a name="ln3025">      last = current;</a>
<a name="ln3026">    }</a>
<a name="ln3027"> </a>
<a name="ln3028">    dt_bauhaus_combobox_add(g-&gt;profile, name);</a>
<a name="ln3029">    for(GList *iter = g-&gt;profiles; iter; iter = g_list_next(iter))</a>
<a name="ln3030">    {</a>
<a name="ln3031">      dt_noiseprofile_t *profile = (dt_noiseprofile_t *)iter-&gt;data;</a>
<a name="ln3032">      dt_bauhaus_combobox_add(g-&gt;profile, profile-&gt;name);</a>
<a name="ln3033">    }</a>
<a name="ln3034"> </a>
<a name="ln3035">    // set defaults depending on the profile</a>
<a name="ln3036">    // all these formulas were &quot;guessed&quot; and are completely empirical</a>
<a name="ln3037">    const float a = g-&gt;interpolated.a[1];</a>
<a name="ln3038">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;wb_adaptive_anscombe = TRUE;</a>
<a name="ln3039">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;radius = infer_radius_from_profile(a);</a>
<a name="ln3040">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;nbhood = 7.0f;</a>
<a name="ln3041">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;scattering = infer_scattering_from_profile(a);</a>
<a name="ln3042">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;central_pixel_weight = 0.1f;</a>
<a name="ln3043">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;strength = 1.0f;</a>
<a name="ln3044">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;overshooting = 1.0f;</a>
<a name="ln3045">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;shadows = infer_shadows_from_profile(a);</a>
<a name="ln3046">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;bias = infer_bias_from_profile(a);</a>
<a name="ln3047">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;mode = MODE_NLMEANS;</a>
<a name="ln3048">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;fix_anscombe_and_nlmeans_norm = TRUE;</a>
<a name="ln3049">    ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;use_new_vst = TRUE;</a>
<a name="ln3050">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln3051">    {</a>
<a name="ln3052">      ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;a[k] = g-&gt;interpolated.a[k];</a>
<a name="ln3053">      ((dt_iop_denoiseprofile_params_t *)module-&gt;default_params)-&gt;b[k] = g-&gt;interpolated.b[k];</a>
<a name="ln3054">    }</a>
<a name="ln3055">    memcpy(module-&gt;params, module-&gt;default_params, sizeof(dt_iop_denoiseprofile_params_t));</a>
<a name="ln3056">  }</a>
<a name="ln3057">}</a>
<a name="ln3058"> </a>
<a name="ln3059">/** init, cleanup, commit to pipeline */</a>
<a name="ln3060">void init(dt_iop_module_t *module)</a>
<a name="ln3061">{</a>
<a name="ln3062">  module-&gt;params = calloc(1, sizeof(dt_iop_denoiseprofile_params_t));</a>
<a name="ln3063">  module-&gt;default_params = calloc(1, sizeof(dt_iop_denoiseprofile_params_t));</a>
<a name="ln3064">  module-&gt;params_size = sizeof(dt_iop_denoiseprofile_params_t);</a>
<a name="ln3065">  module-&gt;gui_data = NULL;</a>
<a name="ln3066">  module-&gt;global_data = NULL;</a>
<a name="ln3067">  dt_iop_denoiseprofile_params_t tmp;</a>
<a name="ln3068">  memset(&amp;tmp, 0, sizeof(dt_iop_denoiseprofile_params_t));</a>
<a name="ln3069">  for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3070">  {</a>
<a name="ln3071">    for(int ch = 0; ch &lt; DT_DENOISE_PROFILE_NONE; ch++)</a>
<a name="ln3072">    {</a>
<a name="ln3073">      tmp.x[ch][k] = k / (DT_IOP_DENOISE_PROFILE_BANDS - 1.f);</a>
<a name="ln3074">      tmp.y[ch][k] = 0.5f;</a>
<a name="ln3075">    }</a>
<a name="ln3076">  }</a>
<a name="ln3077">  tmp.fix_anscombe_and_nlmeans_norm = TRUE;</a>
<a name="ln3078">  tmp.wb_adaptive_anscombe = TRUE;</a>
<a name="ln3079">  tmp.use_new_vst = TRUE;</a>
<a name="ln3080">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_denoiseprofile_params_t));</a>
<a name="ln3081">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_denoiseprofile_params_t));</a>
<a name="ln3082">}</a>
<a name="ln3083"> </a>
<a name="ln3084">void cleanup(dt_iop_module_t *module)</a>
<a name="ln3085">{</a>
<a name="ln3086">  free(module-&gt;params);</a>
<a name="ln3087">  module-&gt;params = NULL;</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln3091">{</a>
<a name="ln3092">  const int program = 11; // denoiseprofile.cl, from programs.conf</a>
<a name="ln3093">  dt_iop_denoiseprofile_global_data_t *gd</a>
<a name="ln3094">      = (dt_iop_denoiseprofile_global_data_t *)malloc(sizeof(dt_iop_denoiseprofile_global_data_t));</a>
<a name="ln3095">  module-&gt;data = gd;</a>
<a name="ln3096">  gd-&gt;kernel_denoiseprofile_precondition = dt_opencl_create_kernel(program, &quot;denoiseprofile_precondition&quot;);</a>
<a name="ln3097">  gd-&gt;kernel_denoiseprofile_precondition_v2 = dt_opencl_create_kernel(program, &quot;denoiseprofile_precondition_v2&quot;);</a>
<a name="ln3098">  gd-&gt;kernel_denoiseprofile_init = dt_opencl_create_kernel(program, &quot;denoiseprofile_init&quot;);</a>
<a name="ln3099">  gd-&gt;kernel_denoiseprofile_dist = dt_opencl_create_kernel(program, &quot;denoiseprofile_dist&quot;);</a>
<a name="ln3100">  gd-&gt;kernel_denoiseprofile_horiz = dt_opencl_create_kernel(program, &quot;denoiseprofile_horiz&quot;);</a>
<a name="ln3101">  gd-&gt;kernel_denoiseprofile_vert = dt_opencl_create_kernel(program, &quot;denoiseprofile_vert&quot;);</a>
<a name="ln3102">  gd-&gt;kernel_denoiseprofile_accu = dt_opencl_create_kernel(program, &quot;denoiseprofile_accu&quot;);</a>
<a name="ln3103">  gd-&gt;kernel_denoiseprofile_finish = dt_opencl_create_kernel(program, &quot;denoiseprofile_finish&quot;);</a>
<a name="ln3104">  gd-&gt;kernel_denoiseprofile_finish_v2 = dt_opencl_create_kernel(program, &quot;denoiseprofile_finish_v2&quot;);</a>
<a name="ln3105">  gd-&gt;kernel_denoiseprofile_backtransform = dt_opencl_create_kernel(program, &quot;denoiseprofile_backtransform&quot;);</a>
<a name="ln3106">  gd-&gt;kernel_denoiseprofile_backtransform_v2 = dt_opencl_create_kernel(program, &quot;denoiseprofile_backtransform_v2&quot;);</a>
<a name="ln3107">  gd-&gt;kernel_denoiseprofile_decompose = dt_opencl_create_kernel(program, &quot;denoiseprofile_decompose&quot;);</a>
<a name="ln3108">  gd-&gt;kernel_denoiseprofile_synthesize = dt_opencl_create_kernel(program, &quot;denoiseprofile_synthesize&quot;);</a>
<a name="ln3109">  gd-&gt;kernel_denoiseprofile_reduce_first = dt_opencl_create_kernel(program, &quot;denoiseprofile_reduce_first&quot;);</a>
<a name="ln3110">  gd-&gt;kernel_denoiseprofile_reduce_second = dt_opencl_create_kernel(program, &quot;denoiseprofile_reduce_second&quot;);</a>
<a name="ln3111">}</a>
<a name="ln3112"> </a>
<a name="ln3113">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln3114">{</a>
<a name="ln3115">  dt_iop_denoiseprofile_global_data_t *gd = (dt_iop_denoiseprofile_global_data_t *)module-&gt;data;</a>
<a name="ln3116">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_precondition);</a>
<a name="ln3117">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_precondition_v2);</a>
<a name="ln3118">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_init);</a>
<a name="ln3119">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_dist);</a>
<a name="ln3120">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_horiz);</a>
<a name="ln3121">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_vert);</a>
<a name="ln3122">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_accu);</a>
<a name="ln3123">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_finish);</a>
<a name="ln3124">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_finish_v2);</a>
<a name="ln3125">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_backtransform);</a>
<a name="ln3126">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_backtransform_v2);</a>
<a name="ln3127">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_decompose);</a>
<a name="ln3128">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_synthesize);</a>
<a name="ln3129">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_reduce_first);</a>
<a name="ln3130">  dt_opencl_free_kernel(gd-&gt;kernel_denoiseprofile_reduce_second);</a>
<a name="ln3131">  free(module-&gt;data);</a>
<a name="ln3132">  module-&gt;data = NULL;</a>
<a name="ln3133">}</a>
<a name="ln3134"> </a>
<a name="ln3135">static dt_noiseprofile_t dt_iop_denoiseprofile_get_auto_profile(dt_iop_module_t *self)</a>
<a name="ln3136">{</a>
<a name="ln3137">  GList *profiles = dt_noiseprofile_get_matching(&amp;self-&gt;dev-&gt;image_storage);</a>
<a name="ln3138">  dt_noiseprofile_t interpolated = dt_noiseprofile_generic; // default to generic poissonian</a>
<a name="ln3139"> </a>
<a name="ln3140">  const int iso = self-&gt;dev-&gt;image_storage.exif_iso;</a>
<a name="ln3141">  dt_noiseprofile_t *last = NULL;</a>
<a name="ln3142">  for(GList *iter = profiles; iter; iter = g_list_next(iter))</a>
<a name="ln3143">  {</a>
<a name="ln3144">    dt_noiseprofile_t *current = (dt_noiseprofile_t *)iter-&gt;data;</a>
<a name="ln3145">    if(current-&gt;iso == iso)</a>
<a name="ln3146">    {</a>
<a name="ln3147">      interpolated = *current;</a>
<a name="ln3148">      break;</a>
<a name="ln3149">    }</a>
<a name="ln3150">    if(last &amp;&amp; last-&gt;iso &lt; iso &amp;&amp; current-&gt;iso &gt; iso)</a>
<a name="ln3151">    {</a>
<a name="ln3152">      interpolated.iso = iso;</a>
<a name="ln3153">      dt_noiseprofile_interpolate(last, current, &amp;interpolated);</a>
<a name="ln3154">      break;</a>
<a name="ln3155">    }</a>
<a name="ln3156">    last = current;</a>
<a name="ln3157">  }</a>
<a name="ln3158">  g_list_free_full(profiles, dt_noiseprofile_free);</a>
<a name="ln3159">  return interpolated;</a>
<a name="ln3160">}</a>
<a name="ln3161"> </a>
<a name="ln3162">/** commit is the synch point between core and gui, so it copies params to pipe data. */</a>
<a name="ln3163">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln3164">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln3165">{</a>
<a name="ln3166">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)params;</a>
<a name="ln3167">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)piece-&gt;data;</a>
<a name="ln3168"> </a>
<a name="ln3169">  d-&gt;nbhood = p-&gt;nbhood;</a>
<a name="ln3170">  d-&gt;central_pixel_weight = p-&gt;central_pixel_weight;</a>
<a name="ln3171">  d-&gt;strength = p-&gt;strength;</a>
<a name="ln3172">  d-&gt;overshooting = p-&gt;overshooting;</a>
<a name="ln3173">  for(int i = 0; i &lt; 3; i++)</a>
<a name="ln3174">  {</a>
<a name="ln3175">    d-&gt;a[i] = p-&gt;a[i];</a>
<a name="ln3176">    d-&gt;b[i] = p-&gt;b[i];</a>
<a name="ln3177">  }</a>
<a name="ln3178">  d-&gt;mode = p-&gt;mode;</a>
<a name="ln3179"> </a>
<a name="ln3180">  // compare if a[0] in params is set to &quot;magic value&quot; -1.0 for autodetection</a>
<a name="ln3181">  if(p-&gt;a[0] == -1.0)</a>
<a name="ln3182">  {</a>
<a name="ln3183">    // autodetect matching profile again, the same way as detecting their names,</a>
<a name="ln3184">    // this is partially duplicated code and data because we are not allowed to access</a>
<a name="ln3185">    // gui_data here ..</a>
<a name="ln3186">    dt_noiseprofile_t interpolated = dt_iop_denoiseprofile_get_auto_profile(self);</a>
<a name="ln3187">    for(int k = 0; k &lt; 3; k++)</a>
<a name="ln3188">    {</a>
<a name="ln3189">      d-&gt;a[k] = interpolated.a[k];</a>
<a name="ln3190">      d-&gt;b[k] = interpolated.b[k];</a>
<a name="ln3191">    }</a>
<a name="ln3192">  }</a>
<a name="ln3193"> </a>
<a name="ln3194">  if((p-&gt;mode == MODE_NLMEANS_AUTO) || (p-&gt;mode == MODE_WAVELETS_AUTO))</a>
<a name="ln3195">  {</a>
<a name="ln3196">    const float gain = p-&gt;overshooting;</a>
<a name="ln3197">    d-&gt;radius = infer_radius_from_profile(d-&gt;a[1] * gain);</a>
<a name="ln3198">    d-&gt;scattering = infer_scattering_from_profile(d-&gt;a[1] * gain);</a>
<a name="ln3199">    d-&gt;shadows = infer_shadows_from_profile(d-&gt;a[1] * gain);</a>
<a name="ln3200">    d-&gt;bias = infer_bias_from_profile(d-&gt;a[1] * gain);</a>
<a name="ln3201">  }</a>
<a name="ln3202">  else</a>
<a name="ln3203">  {</a>
<a name="ln3204">    d-&gt;radius = p-&gt;radius;</a>
<a name="ln3205">    d-&gt;scattering = p-&gt;scattering;</a>
<a name="ln3206">    d-&gt;shadows = p-&gt;shadows;</a>
<a name="ln3207">    d-&gt;bias = p-&gt;bias;</a>
<a name="ln3208">  }</a>
<a name="ln3209"> </a>
<a name="ln3210">  for(int ch = 0; ch &lt; DT_DENOISE_PROFILE_NONE; ch++)</a>
<a name="ln3211">  {</a>
<a name="ln3212">    dt_draw_curve_set_point(d-&gt;curve[ch], 0, p-&gt;x[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2] - 1.f, p-&gt;y[ch][0]);</a>
<a name="ln3213">    for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3214">      dt_draw_curve_set_point(d-&gt;curve[ch], k, p-&gt;x[ch][k], p-&gt;y[ch][k]);</a>
<a name="ln3215">    dt_draw_curve_set_point(d-&gt;curve[ch], DT_IOP_DENOISE_PROFILE_BANDS + 1, p-&gt;x[ch][1] + 1.f,</a>
<a name="ln3216">                            p-&gt;y[ch][DT_IOP_DENOISE_PROFILE_BANDS - 1]);</a>
<a name="ln3217">    dt_draw_curve_calc_values(d-&gt;curve[ch], 0.0, 1.0, DT_IOP_DENOISE_PROFILE_BANDS, NULL, d-&gt;force[ch]);</a>
<a name="ln3218">  }</a>
<a name="ln3219"> </a>
<a name="ln3220">  d-&gt;wb_adaptive_anscombe = p-&gt;wb_adaptive_anscombe;</a>
<a name="ln3221">  d-&gt;fix_anscombe_and_nlmeans_norm = p-&gt;fix_anscombe_and_nlmeans_norm;</a>
<a name="ln3222">  d-&gt;use_new_vst = p-&gt;use_new_vst;</a>
<a name="ln3223">}</a>
<a name="ln3224"> </a>
<a name="ln3225">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln3226">{</a>
<a name="ln3227">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)malloc(sizeof(dt_iop_denoiseprofile_data_t));</a>
<a name="ln3228">  dt_iop_denoiseprofile_params_t *default_params = (dt_iop_denoiseprofile_params_t *)self-&gt;default_params;</a>
<a name="ln3229"> </a>
<a name="ln3230">  piece-&gt;data = (void *)d;</a>
<a name="ln3231">  for(int ch = 0; ch &lt; DT_DENOISE_PROFILE_NONE; ch++)</a>
<a name="ln3232">  {</a>
<a name="ln3233">    d-&gt;curve[ch] = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln3234">    for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3235">      (void)dt_draw_curve_add_point(d-&gt;curve[ch], default_params-&gt;x[ch][k], default_params-&gt;y[ch][k]);</a>
<a name="ln3236">  }</a>
<a name="ln3237">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln3238">}</a>
<a name="ln3239"> </a>
<a name="ln3240">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln3241">{</a>
<a name="ln3242">  dt_iop_denoiseprofile_data_t *d = (dt_iop_denoiseprofile_data_t *)(piece-&gt;data);</a>
<a name="ln3243">  for(int ch = 0; ch &lt; DT_DENOISE_PROFILE_NONE; ch++) dt_draw_curve_destroy(d-&gt;curve[ch]);</a>
<a name="ln3244">  free(piece-&gt;data);</a>
<a name="ln3245">  piece-&gt;data = NULL;</a>
<a name="ln3246">}</a>
<a name="ln3247"> </a>
<a name="ln3248">static void profile_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3249">{</a>
<a name="ln3250">  int i = dt_bauhaus_combobox_get(w);</a>
<a name="ln3251">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3252">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3253">  const dt_noiseprofile_t *profile = &amp;(g-&gt;interpolated);</a>
<a name="ln3254">  if(i &gt; 0) profile = (dt_noiseprofile_t *)g_list_nth_data(g-&gt;profiles, i - 1);</a>
<a name="ln3255">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln3256">  {</a>
<a name="ln3257">    p-&gt;a[k] = profile-&gt;a[k];</a>
<a name="ln3258">    p-&gt;b[k] = profile-&gt;b[k];</a>
<a name="ln3259">  }</a>
<a name="ln3260">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3261">}</a>
<a name="ln3262"> </a>
<a name="ln3263">static void mode_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3264">{</a>
<a name="ln3265">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3266">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3267">  const unsigned mode = dt_bauhaus_combobox_get(w);</a>
<a name="ln3268">  switch(mode)</a>
<a name="ln3269">  {</a>
<a name="ln3270">    case 0:</a>
<a name="ln3271">      p-&gt;mode = MODE_NLMEANS;</a>
<a name="ln3272">      gtk_widget_hide(g-&gt;box_wavelets);</a>
<a name="ln3273">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3274">      gtk_widget_show_all(g-&gt;box_nlm);</a>
<a name="ln3275">      break;</a>
<a name="ln3276">    case 1:</a>
<a name="ln3277">      p-&gt;mode = MODE_NLMEANS_AUTO;</a>
<a name="ln3278">      gtk_widget_hide(g-&gt;box_wavelets);</a>
<a name="ln3279">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3280">      gtk_widget_show_all(g-&gt;box_nlm);</a>
<a name="ln3281">      gtk_widget_set_visible(g-&gt;radius, FALSE);</a>
<a name="ln3282">      gtk_widget_set_visible(g-&gt;nbhood, FALSE);</a>
<a name="ln3283">      gtk_widget_set_visible(g-&gt;scattering, FALSE);</a>
<a name="ln3284">      break;</a>
<a name="ln3285">    case 2:</a>
<a name="ln3286">      p-&gt;mode = MODE_WAVELETS;</a>
<a name="ln3287">      gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3288">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3289">      gtk_widget_show_all(g-&gt;box_wavelets);</a>
<a name="ln3290">      break;</a>
<a name="ln3291">    case 3:</a>
<a name="ln3292">      p-&gt;mode = MODE_WAVELETS_AUTO;</a>
<a name="ln3293">      gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3294">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3295">      gtk_widget_show_all(g-&gt;box_wavelets);</a>
<a name="ln3296">      break;</a>
<a name="ln3297">    case 4:</a>
<a name="ln3298">      p-&gt;mode = MODE_VARIANCE;</a>
<a name="ln3299">      gtk_widget_hide(g-&gt;box_wavelets);</a>
<a name="ln3300">      gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3301">      gtk_widget_show_all(g-&gt;box_variance);</a>
<a name="ln3302">      break;</a>
<a name="ln3303">  }</a>
<a name="ln3304">  const gboolean auto_mode = (p-&gt;mode == MODE_NLMEANS_AUTO) || (p-&gt;mode == MODE_WAVELETS_AUTO);</a>
<a name="ln3305">  gtk_widget_set_visible(g-&gt;shadows, !auto_mode);</a>
<a name="ln3306">  gtk_widget_set_visible(g-&gt;bias, !auto_mode);</a>
<a name="ln3307">  gtk_widget_set_visible(g-&gt;overshooting, auto_mode);</a>
<a name="ln3308">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3309">}</a>
<a name="ln3310"> </a>
<a name="ln3311">static void radius_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3312">{</a>
<a name="ln3313">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3314">  p-&gt;radius = (int)dt_bauhaus_slider_get(w);</a>
<a name="ln3315">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3316">}</a>
<a name="ln3317"> </a>
<a name="ln3318">static void nbhood_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3319">{</a>
<a name="ln3320">  dt_iop_denoiseprofile_params_t *p = self-&gt;params;</a>
<a name="ln3321">  p-&gt;nbhood = (int)dt_bauhaus_slider_get(w);</a>
<a name="ln3322">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3323">}</a>
<a name="ln3324"> </a>
<a name="ln3325">static void scattering_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3326">{</a>
<a name="ln3327">  dt_iop_denoiseprofile_params_t *p = self-&gt;params;</a>
<a name="ln3328">  p-&gt;scattering = dt_bauhaus_slider_get(w);</a>
<a name="ln3329">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3330">}</a>
<a name="ln3331"> </a>
<a name="ln3332">static void central_pixel_weight_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3333">{</a>
<a name="ln3334">  dt_iop_denoiseprofile_params_t *p = self-&gt;params;</a>
<a name="ln3335">  p-&gt;central_pixel_weight = dt_bauhaus_slider_get(w);</a>
<a name="ln3336">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3337">}</a>
<a name="ln3338"> </a>
<a name="ln3339">static void strength_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3340">{</a>
<a name="ln3341">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3342">  p-&gt;strength = dt_bauhaus_slider_get(w);</a>
<a name="ln3343">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346">static void overshooting_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3347">{</a>
<a name="ln3348">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3349">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3350">  p-&gt;overshooting = dt_bauhaus_slider_get(w);</a>
<a name="ln3351">  const float gain = p-&gt;overshooting;</a>
<a name="ln3352">  float a = p-&gt;a[1];</a>
<a name="ln3353">  if(p-&gt;a[0] == -1.0)</a>
<a name="ln3354">  {</a>
<a name="ln3355">    dt_noiseprofile_t interpolated = dt_iop_denoiseprofile_get_auto_profile(self);</a>
<a name="ln3356">    a = interpolated.a[1];</a>
<a name="ln3357">  }</a>
<a name="ln3358">  // set the sliders as visible while we are setting their values</a>
<a name="ln3359">  // otherwise a log message appears</a>
<a name="ln3360">  if(p-&gt;mode == MODE_NLMEANS_AUTO)</a>
<a name="ln3361">  {</a>
<a name="ln3362">    gtk_widget_set_visible(g-&gt;radius, TRUE);</a>
<a name="ln3363">    gtk_widget_set_visible(g-&gt;scattering, TRUE);</a>
<a name="ln3364">    dt_bauhaus_slider_set_soft(g-&gt;radius, infer_radius_from_profile(a * gain));</a>
<a name="ln3365">    dt_bauhaus_slider_set_soft(g-&gt;scattering, infer_scattering_from_profile(a * gain));</a>
<a name="ln3366">    gtk_widget_set_visible(g-&gt;radius, FALSE);</a>
<a name="ln3367">    gtk_widget_set_visible(g-&gt;scattering, FALSE);</a>
<a name="ln3368">  }</a>
<a name="ln3369">  else</a>
<a name="ln3370">  {</a>
<a name="ln3371">    // we are in wavelets mode.</a>
<a name="ln3372">    // we need to show the box_nlm, setting the sliders to visible is not enough</a>
<a name="ln3373">    gtk_widget_show_all(g-&gt;box_nlm);</a>
<a name="ln3374">    dt_bauhaus_slider_set_soft(g-&gt;radius, infer_radius_from_profile(a * gain));</a>
<a name="ln3375">    dt_bauhaus_slider_set_soft(g-&gt;scattering, infer_scattering_from_profile(a * gain));</a>
<a name="ln3376">    gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3377">  }</a>
<a name="ln3378">  gtk_widget_set_visible(g-&gt;shadows, TRUE);</a>
<a name="ln3379">  gtk_widget_set_visible(g-&gt;bias, TRUE);</a>
<a name="ln3380">  dt_bauhaus_slider_set(g-&gt;shadows, infer_shadows_from_profile(a * gain));</a>
<a name="ln3381">  dt_bauhaus_slider_set(g-&gt;bias, infer_bias_from_profile(a * gain));</a>
<a name="ln3382">  gtk_widget_set_visible(g-&gt;shadows, FALSE);</a>
<a name="ln3383">  gtk_widget_set_visible(g-&gt;bias, FALSE);</a>
<a name="ln3384"> </a>
<a name="ln3385">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3386">}</a>
<a name="ln3387"> </a>
<a name="ln3388">static void shadows_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3389">{</a>
<a name="ln3390">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3391">  p-&gt;shadows = dt_bauhaus_slider_get(w);</a>
<a name="ln3392">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3393">}</a>
<a name="ln3394"> </a>
<a name="ln3395">static void bias_callback(GtkWidget *w, dt_iop_module_t *self)</a>
<a name="ln3396">{</a>
<a name="ln3397">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3398">  p-&gt;bias = dt_bauhaus_slider_get(w);</a>
<a name="ln3399">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3400">}</a>
<a name="ln3401"> </a>
<a name="ln3402">void gui_update(dt_iop_module_t *self)</a>
<a name="ln3403">{</a>
<a name="ln3404">  // let gui slider match current parameters:</a>
<a name="ln3405">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3406">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3407">  dt_bauhaus_slider_set_soft(g-&gt;radius, p-&gt;radius);</a>
<a name="ln3408">  dt_bauhaus_slider_set(g-&gt;nbhood, p-&gt;nbhood);</a>
<a name="ln3409">  dt_bauhaus_slider_set_soft(g-&gt;strength, p-&gt;strength);</a>
<a name="ln3410">  dt_bauhaus_slider_set_soft(g-&gt;overshooting, p-&gt;overshooting);</a>
<a name="ln3411">  dt_bauhaus_slider_set(g-&gt;shadows, p-&gt;shadows);</a>
<a name="ln3412">  dt_bauhaus_slider_set_soft(g-&gt;bias, p-&gt;bias);</a>
<a name="ln3413">  dt_bauhaus_slider_set_soft(g-&gt;scattering, p-&gt;scattering);</a>
<a name="ln3414">  dt_bauhaus_slider_set_soft(g-&gt;central_pixel_weight, p-&gt;central_pixel_weight);</a>
<a name="ln3415">  dt_bauhaus_combobox_set(g-&gt;profile, -1);</a>
<a name="ln3416">  unsigned combobox_index = 0;</a>
<a name="ln3417">  switch (p-&gt;mode)</a>
<a name="ln3418">  {</a>
<a name="ln3419">    case MODE_NLMEANS:</a>
<a name="ln3420">      combobox_index = 0;</a>
<a name="ln3421">      gtk_widget_hide(g-&gt;box_wavelets);</a>
<a name="ln3422">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3423">      gtk_widget_show_all(g-&gt;box_nlm);</a>
<a name="ln3424">      break;</a>
<a name="ln3425">    case MODE_NLMEANS_AUTO:</a>
<a name="ln3426">      combobox_index = 1;</a>
<a name="ln3427">      gtk_widget_hide(g-&gt;box_wavelets);</a>
<a name="ln3428">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3429">      gtk_widget_show_all(g-&gt;box_nlm);</a>
<a name="ln3430">      gtk_widget_set_visible(g-&gt;radius, FALSE);</a>
<a name="ln3431">      gtk_widget_set_visible(g-&gt;nbhood, FALSE);</a>
<a name="ln3432">      gtk_widget_set_visible(g-&gt;scattering, FALSE);</a>
<a name="ln3433">      break;</a>
<a name="ln3434">    case MODE_WAVELETS:</a>
<a name="ln3435">      combobox_index = 2;</a>
<a name="ln3436">      gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3437">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3438">      gtk_widget_show_all(g-&gt;box_wavelets);</a>
<a name="ln3439">      break;</a>
<a name="ln3440">    case MODE_WAVELETS_AUTO:</a>
<a name="ln3441">      combobox_index = 3;</a>
<a name="ln3442">      gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3443">      gtk_widget_hide(g-&gt;box_variance);</a>
<a name="ln3444">      gtk_widget_show_all(g-&gt;box_wavelets);</a>
<a name="ln3445">      break;</a>
<a name="ln3446">    case MODE_VARIANCE:</a>
<a name="ln3447">      combobox_index = 4;</a>
<a name="ln3448">      gtk_widget_hide(g-&gt;box_wavelets);</a>
<a name="ln3449">      gtk_widget_hide(g-&gt;box_nlm);</a>
<a name="ln3450">      gtk_widget_show_all(g-&gt;box_variance);</a>
<a name="ln3451">      if(dt_bauhaus_combobox_length(g-&gt;mode) == 4)</a>
<a name="ln3452">      {</a>
<a name="ln3453">        dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;compute variance&quot;));</a>
<a name="ln3454">      }</a>
<a name="ln3455">      break;</a>
<a name="ln3456">  }</a>
<a name="ln3457">  float a = p-&gt;a[1];</a>
<a name="ln3458">  if(p-&gt;a[0] == -1.0)</a>
<a name="ln3459">  {</a>
<a name="ln3460">    dt_noiseprofile_t interpolated = dt_iop_denoiseprofile_get_auto_profile(self);</a>
<a name="ln3461">    a = interpolated.a[1];</a>
<a name="ln3462">  }</a>
<a name="ln3463">  if((p-&gt;mode == MODE_NLMEANS_AUTO) || (p-&gt;mode == MODE_WAVELETS_AUTO))</a>
<a name="ln3464">  {</a>
<a name="ln3465">    const float gain = p-&gt;overshooting;</a>
<a name="ln3466">    dt_bauhaus_slider_set_soft(g-&gt;radius, infer_radius_from_profile(a * gain));</a>
<a name="ln3467">    dt_bauhaus_slider_set_soft(g-&gt;scattering, infer_scattering_from_profile(a * gain));</a>
<a name="ln3468">    dt_bauhaus_slider_set(g-&gt;shadows, infer_shadows_from_profile(a * gain));</a>
<a name="ln3469">    dt_bauhaus_slider_set(g-&gt;bias, infer_bias_from_profile(a * gain));</a>
<a name="ln3470">  }</a>
<a name="ln3471">  dt_bauhaus_slider_set_default(g-&gt;radius, infer_radius_from_profile(a));</a>
<a name="ln3472">  dt_bauhaus_slider_set_default(g-&gt;scattering, infer_scattering_from_profile(a));</a>
<a name="ln3473">  dt_bauhaus_slider_set_default(g-&gt;shadows, infer_shadows_from_profile(a));</a>
<a name="ln3474">  dt_bauhaus_slider_set_default(g-&gt;bias, infer_bias_from_profile(a));</a>
<a name="ln3475">  dt_bauhaus_combobox_set(g-&gt;mode, combobox_index);</a>
<a name="ln3476">  if(p-&gt;a[0] == -1.0)</a>
<a name="ln3477">  {</a>
<a name="ln3478">    dt_bauhaus_combobox_set(g-&gt;profile, 0);</a>
<a name="ln3479">  }</a>
<a name="ln3480">  else</a>
<a name="ln3481">  {</a>
<a name="ln3482">    int i = 1;</a>
<a name="ln3483">    for(GList *iter = g-&gt;profiles; iter; iter = g_list_next(iter), i++)</a>
<a name="ln3484">    {</a>
<a name="ln3485">      dt_noiseprofile_t *profile = (dt_noiseprofile_t *)iter-&gt;data;</a>
<a name="ln3486">      if(!memcmp(profile-&gt;a, p-&gt;a, sizeof(float) * 3)</a>
<a name="ln3487">         &amp;&amp; !memcmp(profile-&gt;b, p-&gt;b, sizeof(float) * 3))</a>
<a name="ln3488">      {</a>
<a name="ln3489">        dt_bauhaus_combobox_set(g-&gt;profile, i);</a>
<a name="ln3490">        break;</a>
<a name="ln3491">      }</a>
<a name="ln3492">    }</a>
<a name="ln3493">  }</a>
<a name="ln3494">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;wb_adaptive_anscombe), p-&gt;wb_adaptive_anscombe);</a>
<a name="ln3495">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;fix_anscombe_and_nlmeans_norm), p-&gt;fix_anscombe_and_nlmeans_norm);</a>
<a name="ln3496">  gtk_widget_set_visible(g-&gt;fix_anscombe_and_nlmeans_norm, !p-&gt;fix_anscombe_and_nlmeans_norm);</a>
<a name="ln3497">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;use_new_vst), p-&gt;use_new_vst);</a>
<a name="ln3498">  gtk_widget_set_visible(g-&gt;use_new_vst, !p-&gt;use_new_vst);</a>
<a name="ln3499">  const gboolean auto_mode = (p-&gt;mode == MODE_NLMEANS_AUTO) || (p-&gt;mode == MODE_WAVELETS_AUTO);</a>
<a name="ln3500">  gtk_widget_set_visible(g-&gt;overshooting, auto_mode);</a>
<a name="ln3501">  gtk_widget_set_visible(g-&gt;shadows, p-&gt;use_new_vst &amp;&amp; !auto_mode);</a>
<a name="ln3502">  gtk_widget_set_visible(g-&gt;bias, p-&gt;use_new_vst &amp;&amp; !auto_mode);</a>
<a name="ln3503">}</a>
<a name="ln3504"> </a>
<a name="ln3505">void gui_reset(dt_iop_module_t *self)</a>
<a name="ln3506">{</a>
<a name="ln3507">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3508">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3509">  gtk_widget_set_visible(g-&gt;fix_anscombe_and_nlmeans_norm, !p-&gt;fix_anscombe_and_nlmeans_norm);</a>
<a name="ln3510">  gtk_widget_set_visible(g-&gt;use_new_vst, !p-&gt;use_new_vst);</a>
<a name="ln3511">}</a>
<a name="ln3512"> </a>
<a name="ln3513">static void dt_iop_denoiseprofile_get_params(dt_iop_denoiseprofile_params_t *p, const int ch, const double mouse_x,</a>
<a name="ln3514">                                             const double mouse_y, const float rad)</a>
<a name="ln3515">{</a>
<a name="ln3516">  for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3517">  {</a>
<a name="ln3518">    const float f = expf(-(mouse_x - p-&gt;x[ch][k]) * (mouse_x - p-&gt;x[ch][k]) / (rad * rad));</a>
<a name="ln3519">    p-&gt;y[ch][k] = (1 - f) * p-&gt;y[ch][k] + f * mouse_y;</a>
<a name="ln3520">  }</a>
<a name="ln3521">}</a>
<a name="ln3522"> </a>
<a name="ln3523">static gboolean denoiseprofile_draw_variance(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln3524">{</a>
<a name="ln3525">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln3526"> </a>
<a name="ln3527">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3528">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3529"> </a>
<a name="ln3530">  if(!isnan(c-&gt;variance_R))</a>
<a name="ln3531">  {</a>
<a name="ln3532">    gchar *str = g_strdup_printf(&quot;%.2f&quot;, c-&gt;variance_R);</a>
<a name="ln3533">    const int reset = darktable.gui-&gt;reset;</a>
<a name="ln3534">    darktable.gui-&gt;reset = 1;</a>
<a name="ln3535">    gtk_label_set_text(c-&gt;label_var_R, str);</a>
<a name="ln3536">    darktable.gui-&gt;reset = reset;</a>
<a name="ln3537">    g_free(str);</a>
<a name="ln3538">  }</a>
<a name="ln3539">  if(!isnan(c-&gt;variance_G))</a>
<a name="ln3540">  {</a>
<a name="ln3541">    gchar *str = g_strdup_printf(&quot;%.2f&quot;, c-&gt;variance_G);</a>
<a name="ln3542">    const int reset = darktable.gui-&gt;reset;</a>
<a name="ln3543">    darktable.gui-&gt;reset = 1;</a>
<a name="ln3544">    gtk_label_set_text(c-&gt;label_var_G, str);</a>
<a name="ln3545">    darktable.gui-&gt;reset = reset;</a>
<a name="ln3546">    g_free(str);</a>
<a name="ln3547">  }</a>
<a name="ln3548">  if(!isnan(c-&gt;variance_B))</a>
<a name="ln3549">  {</a>
<a name="ln3550">    gchar *str = g_strdup_printf(&quot;%.2f&quot;, c-&gt;variance_B);</a>
<a name="ln3551">    const int reset = darktable.gui-&gt;reset;</a>
<a name="ln3552">    darktable.gui-&gt;reset = 1;</a>
<a name="ln3553">    gtk_label_set_text(c-&gt;label_var_B, str);</a>
<a name="ln3554">    darktable.gui-&gt;reset = reset;</a>
<a name="ln3555">    g_free(str);</a>
<a name="ln3556">  }</a>
<a name="ln3557">  return FALSE;</a>
<a name="ln3558">}</a>
<a name="ln3559"> </a>
<a name="ln3560">static gboolean denoiseprofile_draw(GtkWidget *widget, cairo_t *crf, gpointer user_data)</a>
<a name="ln3561">{</a>
<a name="ln3562">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3563">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3564">  dt_iop_denoiseprofile_params_t p = *(dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3565"> </a>
<a name="ln3566">  int ch = (int)c-&gt;channel;</a>
<a name="ln3567">  dt_draw_curve_set_point(c-&gt;transition_curve, 0, p.x[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2] - 1.f, p.y[ch][0]);</a>
<a name="ln3568">  for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3569">    dt_draw_curve_set_point(c-&gt;transition_curve, k + 1, p.x[ch][k], p.y[ch][k]);</a>
<a name="ln3570">  dt_draw_curve_set_point(c-&gt;transition_curve, DT_IOP_DENOISE_PROFILE_BANDS + 1, p.x[ch][1] + 1.f,</a>
<a name="ln3571">                          p.y[ch][DT_IOP_DENOISE_PROFILE_BANDS - 1]);</a>
<a name="ln3572"> </a>
<a name="ln3573">  const int inset = DT_IOP_DENOISE_PROFILE_INSET;</a>
<a name="ln3574">  GtkAllocation allocation;</a>
<a name="ln3575">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln3576">  int width = allocation.width, height = allocation.height;</a>
<a name="ln3577">  cairo_surface_t *cst = dt_cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);</a>
<a name="ln3578">  cairo_t *cr = cairo_create(cst);</a>
<a name="ln3579">  cairo_set_source_rgb(cr, .2, .2, .2);</a>
<a name="ln3580"> </a>
<a name="ln3581">  cairo_paint(cr);</a>
<a name="ln3582"> </a>
<a name="ln3583">  cairo_translate(cr, inset, inset);</a>
<a name="ln3584">  width -= 2 * inset;</a>
<a name="ln3585">  height -= 2 * inset;</a>
<a name="ln3586"> </a>
<a name="ln3587">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0));</a>
<a name="ln3588">  cairo_set_source_rgb(cr, .1, .1, .1);</a>
<a name="ln3589">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3590">  cairo_stroke(cr);</a>
<a name="ln3591"> </a>
<a name="ln3592">  cairo_set_source_rgb(cr, .3, .3, .3);</a>
<a name="ln3593">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3594">  cairo_fill(cr);</a>
<a name="ln3595"> </a>
<a name="ln3596">  // draw grid</a>
<a name="ln3597">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(.4));</a>
<a name="ln3598">  cairo_set_source_rgb(cr, .1, .1, .1);</a>
<a name="ln3599">  dt_draw_grid(cr, 8, 0, 0, width, height);</a>
<a name="ln3600"> </a>
<a name="ln3601">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln3602">  {</a>
<a name="ln3603">    // draw min/max curves:</a>
<a name="ln3604">    dt_iop_denoiseprofile_get_params(&amp;p, c-&gt;channel, c-&gt;mouse_x, 1., c-&gt;mouse_radius);</a>
<a name="ln3605">    dt_draw_curve_set_point(c-&gt;transition_curve, 0, p.x[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2] - 1.f, p.y[ch][0]);</a>
<a name="ln3606">    for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3607">      dt_draw_curve_set_point(c-&gt;transition_curve, k + 1, p.x[ch][k], p.y[ch][k]);</a>
<a name="ln3608">    dt_draw_curve_set_point(c-&gt;transition_curve, DT_IOP_DENOISE_PROFILE_BANDS + 1, p.x[ch][1] + 1.f,</a>
<a name="ln3609">                            p.y[ch][DT_IOP_DENOISE_PROFILE_BANDS - 1]);</a>
<a name="ln3610">    dt_draw_curve_calc_values(c-&gt;transition_curve, 0.0, 1.0, DT_IOP_DENOISE_PROFILE_RES, c-&gt;draw_min_xs,</a>
<a name="ln3611">                              c-&gt;draw_min_ys);</a>
<a name="ln3612"> </a>
<a name="ln3613">    p = *(dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3614">    dt_iop_denoiseprofile_get_params(&amp;p, c-&gt;channel, c-&gt;mouse_x, .0, c-&gt;mouse_radius);</a>
<a name="ln3615">    dt_draw_curve_set_point(c-&gt;transition_curve, 0, p.x[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2] - 1.f, p.y[ch][0]);</a>
<a name="ln3616">    for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3617">      dt_draw_curve_set_point(c-&gt;transition_curve, k + 1, p.x[ch][k], p.y[ch][k]);</a>
<a name="ln3618">    dt_draw_curve_set_point(c-&gt;transition_curve, DT_IOP_DENOISE_PROFILE_BANDS + 1, p.x[ch][1] + 1.f,</a>
<a name="ln3619">                            p.y[ch][DT_IOP_DENOISE_PROFILE_BANDS - 1]);</a>
<a name="ln3620">    dt_draw_curve_calc_values(c-&gt;transition_curve, 0.0, 1.0, DT_IOP_DENOISE_PROFILE_RES, c-&gt;draw_max_xs,</a>
<a name="ln3621">                              c-&gt;draw_max_ys);</a>
<a name="ln3622">  }</a>
<a name="ln3623"> </a>
<a name="ln3624">  cairo_save(cr);</a>
<a name="ln3625"> </a>
<a name="ln3626">  // draw selected cursor</a>
<a name="ln3627">  cairo_translate(cr, 0, height);</a>
<a name="ln3628"> </a>
<a name="ln3629">  cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln3630">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.));</a>
<a name="ln3631"> </a>
<a name="ln3632">  for(int i = 0; i &lt; DT_DENOISE_PROFILE_NONE; i++)</a>
<a name="ln3633">  {</a>
<a name="ln3634">    // draw curves, selected last</a>
<a name="ln3635">    ch = ((int)c-&gt;channel + i + 1) % DT_DENOISE_PROFILE_NONE;</a>
<a name="ln3636">    float alpha = 0.3;</a>
<a name="ln3637">    if(i == DT_DENOISE_PROFILE_NONE - 1) alpha = 1.0;</a>
<a name="ln3638">    switch(ch)</a>
<a name="ln3639">    {</a>
<a name="ln3640">      case 0:</a>
<a name="ln3641">        cairo_set_source_rgba(cr, .7, .7, .7, alpha);</a>
<a name="ln3642">        break;</a>
<a name="ln3643">      case 1:</a>
<a name="ln3644">        cairo_set_source_rgba(cr, .7, .1, .1, alpha);</a>
<a name="ln3645">        break;</a>
<a name="ln3646">      case 2:</a>
<a name="ln3647">        cairo_set_source_rgba(cr, .1, .7, .1, alpha);</a>
<a name="ln3648">        break;</a>
<a name="ln3649">      case 3:</a>
<a name="ln3650">        cairo_set_source_rgba(cr, .1, .1, .7, alpha);</a>
<a name="ln3651">        break;</a>
<a name="ln3652">    }</a>
<a name="ln3653"> </a>
<a name="ln3654">    p = *(dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3655">    dt_draw_curve_set_point(c-&gt;transition_curve, 0, p.x[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2] - 1.0f, p.y[ch][0]);</a>
<a name="ln3656">    for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3657">      dt_draw_curve_set_point(c-&gt;transition_curve, k + 1, p.x[ch][k], p.y[ch][k]);</a>
<a name="ln3658">    dt_draw_curve_set_point(c-&gt;transition_curve, DT_IOP_DENOISE_PROFILE_BANDS + 1, p.x[ch][1] + 1.0f,</a>
<a name="ln3659">                            p.y[ch][DT_IOP_DENOISE_PROFILE_BANDS - 1]);</a>
<a name="ln3660">    dt_draw_curve_calc_values(c-&gt;transition_curve, 0.0, 1.0, DT_IOP_DENOISE_PROFILE_RES, c-&gt;draw_xs, c-&gt;draw_ys);</a>
<a name="ln3661">    cairo_move_to(cr, 0 * width / (float)(DT_IOP_DENOISE_PROFILE_RES - 1), -height * c-&gt;draw_ys[0]);</a>
<a name="ln3662">    for(int k = 1; k &lt; DT_IOP_DENOISE_PROFILE_RES; k++)</a>
<a name="ln3663">      cairo_line_to(cr, k * width / (float)(DT_IOP_DENOISE_PROFILE_RES - 1), -height * c-&gt;draw_ys[k]);</a>
<a name="ln3664">    cairo_stroke(cr);</a>
<a name="ln3665">  }</a>
<a name="ln3666"> </a>
<a name="ln3667">  ch = c-&gt;channel;</a>
<a name="ln3668">  // draw dots on knots</a>
<a name="ln3669">  cairo_set_source_rgb(cr, 0.7, 0.7, 0.7);</a>
<a name="ln3670">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.));</a>
<a name="ln3671">  for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3672">  {</a>
<a name="ln3673">    cairo_arc(cr, width * p.x[ch][k], -height * p.y[ch][k], DT_PIXEL_APPLY_DPI(3.0), 0.0, 2.0 * M_PI);</a>
<a name="ln3674">    if(c-&gt;x_move == k)</a>
<a name="ln3675">      cairo_fill(cr);</a>
<a name="ln3676">    else</a>
<a name="ln3677">      cairo_stroke(cr);</a>
<a name="ln3678">  }</a>
<a name="ln3679"> </a>
<a name="ln3680">  if(c-&gt;mouse_y &gt; 0 || c-&gt;dragging)</a>
<a name="ln3681">  {</a>
<a name="ln3682">    // draw min/max, if selected</a>
<a name="ln3683">    cairo_set_source_rgba(cr, .7, .7, .7, .6);</a>
<a name="ln3684">    cairo_move_to(cr, 0, -height * c-&gt;draw_min_ys[0]);</a>
<a name="ln3685">    for(int k = 1; k &lt; DT_IOP_DENOISE_PROFILE_RES; k++)</a>
<a name="ln3686">      cairo_line_to(cr, k * width / (float)(DT_IOP_DENOISE_PROFILE_RES - 1), -height * c-&gt;draw_min_ys[k]);</a>
<a name="ln3687">    for(int k = DT_IOP_DENOISE_PROFILE_RES - 1; k &gt;= 0; k--)</a>
<a name="ln3688">      cairo_line_to(cr, k * width / (float)(DT_IOP_DENOISE_PROFILE_RES - 1), -height * c-&gt;draw_max_ys[k]);</a>
<a name="ln3689">    cairo_close_path(cr);</a>
<a name="ln3690">    cairo_fill(cr);</a>
<a name="ln3691">    // draw mouse focus circle</a>
<a name="ln3692">    cairo_set_source_rgba(cr, .9, .9, .9, .5);</a>
<a name="ln3693">    const float pos = DT_IOP_DENOISE_PROFILE_RES * c-&gt;mouse_x;</a>
<a name="ln3694">    int k = (int)pos;</a>
<a name="ln3695">    const float f = k - pos;</a>
<a name="ln3696">    if(k &gt;= DT_IOP_DENOISE_PROFILE_RES - 1) k = DT_IOP_DENOISE_PROFILE_RES - 2;</a>
<a name="ln3697">    float ht = -height * (f * c-&gt;draw_ys[k] + (1 - f) * c-&gt;draw_ys[k + 1]);</a>
<a name="ln3698">    cairo_arc(cr, c-&gt;mouse_x * width, ht, c-&gt;mouse_radius * width, 0, 2. * M_PI);</a>
<a name="ln3699">    cairo_stroke(cr);</a>
<a name="ln3700">  }</a>
<a name="ln3701"> </a>
<a name="ln3702">  cairo_restore(cr);</a>
<a name="ln3703"> </a>
<a name="ln3704">  cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);</a>
<a name="ln3705"> </a>
<a name="ln3706">  // draw labels:</a>
<a name="ln3707">  PangoLayout *layout;</a>
<a name="ln3708">  PangoRectangle ink;</a>
<a name="ln3709">  PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln3710">  pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln3711">  pango_font_description_set_absolute_size(desc, (.08 * height) * PANGO_SCALE);</a>
<a name="ln3712">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln3713">  pango_layout_set_font_description(layout, desc);</a>
<a name="ln3714">  cairo_set_source_rgb(cr, .1, .1, .1);</a>
<a name="ln3715"> </a>
<a name="ln3716">  pango_layout_set_text(layout, _(&quot;coarse&quot;), -1);</a>
<a name="ln3717">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln3718">  cairo_move_to(cr, .02 * width - ink.y, .5 * (height + ink.width));</a>
<a name="ln3719">  cairo_save(cr);</a>
<a name="ln3720">  cairo_rotate(cr, -M_PI * .5f);</a>
<a name="ln3721">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln3722">  cairo_restore(cr);</a>
<a name="ln3723"> </a>
<a name="ln3724">  pango_layout_set_text(layout, _(&quot;fine&quot;), -1);</a>
<a name="ln3725">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln3726">  cairo_move_to(cr, .98 * width - ink.height, .5 * (height + ink.width));</a>
<a name="ln3727">  cairo_save(cr);</a>
<a name="ln3728">  cairo_rotate(cr, -M_PI * .5f);</a>
<a name="ln3729">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln3730">  cairo_restore(cr);</a>
<a name="ln3731"> </a>
<a name="ln3732"> </a>
<a name="ln3733">  pango_layout_set_text(layout, _(&quot;smooth&quot;), -1);</a>
<a name="ln3734">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln3735">  cairo_move_to(cr, .5 * (width - ink.width), .08 * height - ink.height);</a>
<a name="ln3736">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln3737"> </a>
<a name="ln3738">  pango_layout_set_text(layout, _(&quot;noisy&quot;), -1);</a>
<a name="ln3739">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln3740">  cairo_move_to(cr, .5 * (width - ink.width), .97 * height - ink.height);</a>
<a name="ln3741">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln3742"> </a>
<a name="ln3743">  pango_font_description_free(desc);</a>
<a name="ln3744">  g_object_unref(layout);</a>
<a name="ln3745">  cairo_destroy(cr);</a>
<a name="ln3746">  cairo_set_source_surface(crf, cst, 0, 0);</a>
<a name="ln3747">  cairo_paint(crf);</a>
<a name="ln3748">  cairo_surface_destroy(cst);</a>
<a name="ln3749">  return TRUE;</a>
<a name="ln3750">}</a>
<a name="ln3751"> </a>
<a name="ln3752">static gboolean denoiseprofile_motion_notify(GtkWidget *widget, GdkEventMotion *event, gpointer user_data)</a>
<a name="ln3753">{</a>
<a name="ln3754">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3755">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3756">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3757">  const int inset = DT_IOP_DENOISE_PROFILE_INSET;</a>
<a name="ln3758">  GtkAllocation allocation;</a>
<a name="ln3759">  gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln3760">  int height = allocation.height - 2 * inset, width = allocation.width - 2 * inset;</a>
<a name="ln3761">  if(!c-&gt;dragging) c-&gt;mouse_x = CLAMP(event-&gt;x - inset, 0, width) / (float)width;</a>
<a name="ln3762">  c-&gt;mouse_y = 1.0 - CLAMP(event-&gt;y - inset, 0, height) / (float)height;</a>
<a name="ln3763">  if(c-&gt;dragging)</a>
<a name="ln3764">  {</a>
<a name="ln3765">    *p = c-&gt;drag_params;</a>
<a name="ln3766">    if(c-&gt;x_move &lt; 0)</a>
<a name="ln3767">    {</a>
<a name="ln3768">      dt_iop_denoiseprofile_get_params(p, c-&gt;channel, c-&gt;mouse_x, c-&gt;mouse_y + c-&gt;mouse_pick, c-&gt;mouse_radius);</a>
<a name="ln3769">    }</a>
<a name="ln3770">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3771">  }</a>
<a name="ln3772">  else</a>
<a name="ln3773">  {</a>
<a name="ln3774">    c-&gt;x_move = -1;</a>
<a name="ln3775">  }</a>
<a name="ln3776">  gtk_widget_queue_draw(widget);</a>
<a name="ln3777">  gint x, y;</a>
<a name="ln3778">#if GTK_CHECK_VERSION(3, 20, 0)</a>
<a name="ln3779">  gdk_window_get_device_position(</a>
<a name="ln3780">      event-&gt;window, gdk_seat_get_pointer(gdk_display_get_default_seat(gdk_window_get_display(event-&gt;window))), &amp;x,</a>
<a name="ln3781">      &amp;y, 0);</a>
<a name="ln3782">#else</a>
<a name="ln3783">  gdk_window_get_device_position(</a>
<a name="ln3784">      event-&gt;window,</a>
<a name="ln3785">      gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gdk_window_get_display(event-&gt;window))),</a>
<a name="ln3786">      &amp;x, &amp;y, NULL);</a>
<a name="ln3787">#endif</a>
<a name="ln3788">  return TRUE;</a>
<a name="ln3789">}</a>
<a name="ln3790"> </a>
<a name="ln3791">static gboolean denoiseprofile_button_press(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln3792">{</a>
<a name="ln3793">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3794">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3795">  const int ch = c-&gt;channel;</a>
<a name="ln3796">  if(event-&gt;button == 1 &amp;&amp; event-&gt;type == GDK_2BUTTON_PRESS)</a>
<a name="ln3797">  {</a>
<a name="ln3798">    // reset current curve</a>
<a name="ln3799">    dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3800">    dt_iop_denoiseprofile_params_t *d = (dt_iop_denoiseprofile_params_t *)self-&gt;default_params;</a>
<a name="ln3801">    /*   dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data; */</a>
<a name="ln3802">    for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3803">    {</a>
<a name="ln3804">      p-&gt;x[ch][k] = d-&gt;x[ch][k];</a>
<a name="ln3805">      p-&gt;y[ch][k] = d-&gt;y[ch][k];</a>
<a name="ln3806">    }</a>
<a name="ln3807">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3808">    gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln3809">  }</a>
<a name="ln3810">  else if(event-&gt;button == 1)</a>
<a name="ln3811">  {</a>
<a name="ln3812">    c-&gt;drag_params = *(dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3813">    const int inset = DT_IOP_DENOISE_PROFILE_INSET;</a>
<a name="ln3814">    GtkAllocation allocation;</a>
<a name="ln3815">    gtk_widget_get_allocation(widget, &amp;allocation);</a>
<a name="ln3816">    int height = allocation.height - 2 * inset, width = allocation.width - 2 * inset;</a>
<a name="ln3817">    c-&gt;mouse_pick</a>
<a name="ln3818">        = dt_draw_curve_calc_value(c-&gt;transition_curve, CLAMP(event-&gt;x - inset, 0, width) / (float)width);</a>
<a name="ln3819">    c-&gt;mouse_pick -= 1.0 - CLAMP(event-&gt;y - inset, 0, height) / (float)height;</a>
<a name="ln3820">    c-&gt;dragging = 1;</a>
<a name="ln3821">    return TRUE;</a>
<a name="ln3822">  }</a>
<a name="ln3823">  return FALSE;</a>
<a name="ln3824">}</a>
<a name="ln3825"> </a>
<a name="ln3826">static gboolean denoiseprofile_button_release(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln3827">{</a>
<a name="ln3828">  if(event-&gt;button == 1)</a>
<a name="ln3829">  {</a>
<a name="ln3830">    dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3831">    dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3832">    c-&gt;dragging = 0;</a>
<a name="ln3833">    return TRUE;</a>
<a name="ln3834">  }</a>
<a name="ln3835">  return FALSE;</a>
<a name="ln3836">}</a>
<a name="ln3837"> </a>
<a name="ln3838">static gboolean denoiseprofile_leave_notify(GtkWidget *widget, GdkEventCrossing *event, gpointer user_data)</a>
<a name="ln3839">{</a>
<a name="ln3840">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3841">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3842">  if(!c-&gt;dragging) c-&gt;mouse_y = -1.0;</a>
<a name="ln3843">  gtk_widget_queue_draw(widget);</a>
<a name="ln3844">  return TRUE;</a>
<a name="ln3845">}</a>
<a name="ln3846"> </a>
<a name="ln3847">static gboolean denoiseprofile_scrolled(GtkWidget *widget, GdkEventScroll *event, gpointer user_data)</a>
<a name="ln3848">{</a>
<a name="ln3849">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3850">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3851"> </a>
<a name="ln3852">  gdouble delta_y;</a>
<a name="ln3853">  if(dt_gui_get_scroll_deltas(event, NULL, &amp;delta_y))</a>
<a name="ln3854">  {</a>
<a name="ln3855">    c-&gt;mouse_radius = CLAMP(c-&gt;mouse_radius * (1.f + 0.1f * delta_y), 0.2f / DT_IOP_DENOISE_PROFILE_BANDS, 1.f);</a>
<a name="ln3856">    gtk_widget_queue_draw(widget);</a>
<a name="ln3857">  }</a>
<a name="ln3858"> </a>
<a name="ln3859">  return TRUE;</a>
<a name="ln3860">}</a>
<a name="ln3861"> </a>
<a name="ln3862">static void denoiseprofile_tab_switch(GtkNotebook *notebook, GtkWidget *page, guint page_num, gpointer user_data)</a>
<a name="ln3863">{</a>
<a name="ln3864">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln3865">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln3866">  dt_iop_denoiseprofile_gui_data_t *c = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3867">  c-&gt;channel = (dt_iop_denoiseprofile_channel_t)page_num;</a>
<a name="ln3868">  gtk_widget_queue_draw(self-&gt;widget);</a>
<a name="ln3869">}</a>
<a name="ln3870"> </a>
<a name="ln3871">static void wb_adaptive_anscombe_callback(GtkWidget *widget, dt_iop_module_t *self)</a>
<a name="ln3872">{</a>
<a name="ln3873">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln3874">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3875">  p-&gt;wb_adaptive_anscombe = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));</a>
<a name="ln3876">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3877">}</a>
<a name="ln3878"> </a>
<a name="ln3879">static void fix_anscombe_and_nlmeans_norm_callback(GtkWidget *widget, dt_iop_module_t *self)</a>
<a name="ln3880">{</a>
<a name="ln3881">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln3882">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3883">  p-&gt;fix_anscombe_and_nlmeans_norm = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));</a>
<a name="ln3884">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3885">}</a>
<a name="ln3886"> </a>
<a name="ln3887">static void use_new_vst_callback(GtkWidget *widget, dt_iop_module_t *self)</a>
<a name="ln3888">{</a>
<a name="ln3889">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln3890">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3891">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3892">  p-&gt;use_new_vst = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));</a>
<a name="ln3893">  const gboolean auto_mode = (p-&gt;mode == MODE_NLMEANS_AUTO) || (p-&gt;mode == MODE_WAVELETS_AUTO);</a>
<a name="ln3894">  gtk_widget_set_visible(g-&gt;shadows, p-&gt;use_new_vst &amp;&amp; !auto_mode);</a>
<a name="ln3895">  gtk_widget_set_visible(g-&gt;bias, p-&gt;use_new_vst &amp;&amp; !auto_mode);</a>
<a name="ln3896">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3897">}</a>
<a name="ln3898"> </a>
<a name="ln3899">void gui_init(dt_iop_module_t *self)</a>
<a name="ln3900">{</a>
<a name="ln3901">  // init the slider (more sophisticated layouts are possible with gtk tables and boxes):</a>
<a name="ln3902">  self-&gt;gui_data = malloc(sizeof(dt_iop_denoiseprofile_gui_data_t));</a>
<a name="ln3903">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3904">  dt_iop_denoiseprofile_params_t *p = (dt_iop_denoiseprofile_params_t *)self-&gt;params;</a>
<a name="ln3905">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln3906">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln3907">  g-&gt;profiles = NULL;</a>
<a name="ln3908">  g-&gt;profile = dt_bauhaus_combobox_new(self);</a>
<a name="ln3909">  g-&gt;strength = dt_bauhaus_slider_new_with_range(self, 0.001f, 4.0f, .05, 1.f, 3);</a>
<a name="ln3910">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;strength, 0.001f, 1000.0f);</a>
<a name="ln3911">  g-&gt;overshooting = dt_bauhaus_slider_new_with_range(self, 0.001f, 4.0f, .05, 1.f, 2);</a>
<a name="ln3912">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;overshooting, 0.001f, 1000.0f);</a>
<a name="ln3913">  g-&gt;shadows = dt_bauhaus_slider_new_with_range(self, 0.0f, 1.8f, .05, 1.f, 2);</a>
<a name="ln3914">  g-&gt;bias = dt_bauhaus_slider_new_with_range(self, -10.0f, 10.0f, 1.0f, 0.f, 1);</a>
<a name="ln3915">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;bias, -1000.0f, 1000.0f);</a>
<a name="ln3916">  g-&gt;mode = dt_bauhaus_combobox_new(self);</a>
<a name="ln3917">  g-&gt;radius = dt_bauhaus_slider_new_with_range(self, 0.0f, 8.0f, 1.f, 1.f, 0);</a>
<a name="ln3918">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;radius, 0.0, 12.0);</a>
<a name="ln3919">  g-&gt;nbhood = dt_bauhaus_slider_new_with_range(self, 1.0f, 30.0f, 1.f, 7.f, 0);</a>
<a name="ln3920">  g-&gt;scattering = dt_bauhaus_slider_new_with_range(self, 0.0f, 1.0f, 0.01, 0.0f, 2);</a>
<a name="ln3921">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;scattering, 0.0, 20.0);</a>
<a name="ln3922">  g-&gt;central_pixel_weight = dt_bauhaus_slider_new_with_range(self, 0.0f, 1.0f, 0.01, 0.1f, 2);</a>
<a name="ln3923">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;central_pixel_weight, 0.0, 10.0);</a>
<a name="ln3924">  g-&gt;channel = dt_conf_get_int(&quot;plugins/darkroom/denoiseprofile/gui_channel&quot;);</a>
<a name="ln3925"> </a>
<a name="ln3926">  g-&gt;box_nlm = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln3927">  g-&gt;box_wavelets = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln3928">  g-&gt;box_variance = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln3929"> </a>
<a name="ln3930">  gtk_box_pack_start(GTK_BOX(g-&gt;box_nlm), g-&gt;radius, TRUE, TRUE, 0);</a>
<a name="ln3931">  gtk_box_pack_start(GTK_BOX(g-&gt;box_nlm), g-&gt;nbhood, TRUE, TRUE, 0);</a>
<a name="ln3932">  gtk_box_pack_start(GTK_BOX(g-&gt;box_nlm), g-&gt;scattering, TRUE, TRUE, 0);</a>
<a name="ln3933">  gtk_box_pack_start(GTK_BOX(g-&gt;box_nlm), g-&gt;central_pixel_weight, TRUE, TRUE, 0);</a>
<a name="ln3934"> </a>
<a name="ln3935">  g-&gt;label_var = GTK_LABEL(gtk_label_new(_(&quot;use only with a perfectly\n&quot;</a>
<a name="ln3936">                                           &quot;uniform image if you want to\n&quot;</a>
<a name="ln3937">                                           &quot;estimate the noise variance.&quot;)));</a>
<a name="ln3938">  gtk_widget_set_halign(GTK_WIDGET(g-&gt;label_var), GTK_ALIGN_START);</a>
<a name="ln3939">  gtk_box_pack_start(GTK_BOX(g-&gt;box_variance), GTK_WIDGET(g-&gt;label_var), TRUE, TRUE, 0);</a>
<a name="ln3940"> </a>
<a name="ln3941">  GtkBox *hboxR = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln3942">  GtkLabel *labelR = GTK_LABEL(gtk_label_new(_(&quot;variance red: &quot;)));</a>
<a name="ln3943">  gtk_box_pack_start(GTK_BOX(hboxR), GTK_WIDGET(labelR), FALSE, FALSE, 0);</a>
<a name="ln3944">  g-&gt;label_var_R = GTK_LABEL(gtk_label_new(&quot;&quot;)); // This gets filled in by process</a>
<a name="ln3945">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;label_var_R), _(&quot;variance computed on the red channel&quot;));</a>
<a name="ln3946">  gtk_box_pack_start(GTK_BOX(hboxR), GTK_WIDGET(g-&gt;label_var_R), FALSE, FALSE, 0);</a>
<a name="ln3947">  gtk_box_pack_start(GTK_BOX(g-&gt;box_variance), GTK_WIDGET(hboxR), TRUE, TRUE, 0);</a>
<a name="ln3948"> </a>
<a name="ln3949">  GtkBox *hboxG = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln3950">  GtkLabel *labelG = GTK_LABEL(gtk_label_new(_(&quot;variance green: &quot;)));</a>
<a name="ln3951">  gtk_box_pack_start(GTK_BOX(hboxG), GTK_WIDGET(labelG), FALSE, FALSE, 0);</a>
<a name="ln3952">  g-&gt;label_var_G = GTK_LABEL(gtk_label_new(&quot;&quot;)); // This gets filled in by process</a>
<a name="ln3953">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;label_var_G), _(&quot;variance computed on the green channel&quot;));</a>
<a name="ln3954">  gtk_box_pack_start(GTK_BOX(hboxG), GTK_WIDGET(g-&gt;label_var_G), FALSE, FALSE, 0);</a>
<a name="ln3955">  gtk_box_pack_start(GTK_BOX(g-&gt;box_variance), GTK_WIDGET(hboxG), TRUE, TRUE, 0);</a>
<a name="ln3956"> </a>
<a name="ln3957">  GtkBox *hboxB = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln3958">  GtkLabel *labelB = GTK_LABEL(gtk_label_new(_(&quot;variance blue: &quot;)));</a>
<a name="ln3959">  gtk_box_pack_start(GTK_BOX(hboxB), GTK_WIDGET(labelB), FALSE, FALSE, 0);</a>
<a name="ln3960">  g-&gt;label_var_B = GTK_LABEL(gtk_label_new(&quot;&quot;)); // This gets filled in by process</a>
<a name="ln3961">  gtk_widget_set_tooltip_text(GTK_WIDGET(g-&gt;label_var_B), _(&quot;variance computed on the blue channel&quot;));</a>
<a name="ln3962">  gtk_box_pack_start(GTK_BOX(hboxB), GTK_WIDGET(g-&gt;label_var_B), FALSE, FALSE, 0);</a>
<a name="ln3963">  gtk_box_pack_start(GTK_BOX(g-&gt;box_variance), GTK_WIDGET(hboxB), TRUE, TRUE, 0);</a>
<a name="ln3964"> </a>
<a name="ln3965">  g_signal_connect(G_OBJECT(g-&gt;box_variance), &quot;draw&quot;, G_CALLBACK(denoiseprofile_draw_variance), self);</a>
<a name="ln3966"> </a>
<a name="ln3967">  g-&gt;channel_tabs = GTK_NOTEBOOK(gtk_notebook_new());</a>
<a name="ln3968"> </a>
<a name="ln3969">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;channel_tabs), GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln3970">                           gtk_label_new(_(&quot;all&quot;)));</a>
<a name="ln3971">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;channel_tabs), GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln3972">                           gtk_label_new(_(&quot;R&quot;)));</a>
<a name="ln3973">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;channel_tabs), GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln3974">                           gtk_label_new(_(&quot;G&quot;)));</a>
<a name="ln3975">  gtk_notebook_append_page(GTK_NOTEBOOK(g-&gt;channel_tabs), GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0)),</a>
<a name="ln3976">                           gtk_label_new(_(&quot;B&quot;)));</a>
<a name="ln3977"> </a>
<a name="ln3978">  gtk_widget_show_all(GTK_WIDGET(gtk_notebook_get_nth_page(g-&gt;channel_tabs, g-&gt;channel)));</a>
<a name="ln3979">  gtk_notebook_set_current_page(GTK_NOTEBOOK(g-&gt;channel_tabs), g-&gt;channel);</a>
<a name="ln3980">  g_signal_connect(G_OBJECT(g-&gt;channel_tabs), &quot;switch_page&quot;, G_CALLBACK(denoiseprofile_tab_switch), self);</a>
<a name="ln3981"> </a>
<a name="ln3982">  const int ch = (int)g-&gt;channel;</a>
<a name="ln3983">  g-&gt;transition_curve = dt_draw_curve_new(0.0, 1.0, CATMULL_ROM);</a>
<a name="ln3984">  (void)dt_draw_curve_add_point(g-&gt;transition_curve, p-&gt;x[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2] - 1.0f,</a>
<a name="ln3985">                                p-&gt;y[ch][DT_IOP_DENOISE_PROFILE_BANDS - 2]);</a>
<a name="ln3986">  for(int k = 0; k &lt; DT_IOP_DENOISE_PROFILE_BANDS; k++)</a>
<a name="ln3987">    (void)dt_draw_curve_add_point(g-&gt;transition_curve, p-&gt;x[ch][k], p-&gt;y[ch][k]);</a>
<a name="ln3988">  (void)dt_draw_curve_add_point(g-&gt;transition_curve, p-&gt;x[ch][1] + 1.0f, p-&gt;y[ch][1]);</a>
<a name="ln3989"> </a>
<a name="ln3990">  g-&gt;mouse_x = g-&gt;mouse_y = g-&gt;mouse_pick = -1.0;</a>
<a name="ln3991">  g-&gt;dragging = 0;</a>
<a name="ln3992">  g-&gt;x_move = -1;</a>
<a name="ln3993">  g-&gt;mouse_radius = 1.0f / (DT_IOP_DENOISE_PROFILE_BANDS * 2);</a>
<a name="ln3994"> </a>
<a name="ln3995">  g-&gt;area = GTK_DRAWING_AREA(dtgtk_drawing_area_new_with_aspect_ratio(9.0 / 16.0));</a>
<a name="ln3996"> </a>
<a name="ln3997">  gtk_box_pack_start(GTK_BOX(g-&gt;box_wavelets), GTK_WIDGET(g-&gt;channel_tabs), FALSE, FALSE, 0);</a>
<a name="ln3998">  gtk_box_pack_start(GTK_BOX(g-&gt;box_wavelets), GTK_WIDGET(g-&gt;area), FALSE, FALSE, 0);</a>
<a name="ln3999"> </a>
<a name="ln4000">  gtk_widget_add_events(GTK_WIDGET(g-&gt;area), GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK</a>
<a name="ln4001">                                                 | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK</a>
<a name="ln4002">                                                 | GDK_LEAVE_NOTIFY_MASK | darktable.gui-&gt;scroll_mask);</a>
<a name="ln4003">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;draw&quot;, G_CALLBACK(denoiseprofile_draw), self);</a>
<a name="ln4004">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;button-press-event&quot;, G_CALLBACK(denoiseprofile_button_press), self);</a>
<a name="ln4005">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;button-release-event&quot;, G_CALLBACK(denoiseprofile_button_release), self);</a>
<a name="ln4006">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;motion-notify-event&quot;, G_CALLBACK(denoiseprofile_motion_notify), self);</a>
<a name="ln4007">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;leave-notify-event&quot;, G_CALLBACK(denoiseprofile_leave_notify), self);</a>
<a name="ln4008">  g_signal_connect(G_OBJECT(g-&gt;area), &quot;scroll-event&quot;, G_CALLBACK(denoiseprofile_scrolled), self);</a>
<a name="ln4009"> </a>
<a name="ln4010">  g-&gt;wb_adaptive_anscombe = gtk_check_button_new_with_label(_(&quot;whitebalance-adaptive transform&quot;));</a>
<a name="ln4011">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;wb_adaptive_anscombe), p-&gt;wb_adaptive_anscombe);</a>
<a name="ln4012">  gtk_widget_set_tooltip_text(g-&gt;wb_adaptive_anscombe, _(&quot;adapt denoising according to the\n&quot;</a>
<a name="ln4013">                                                         &quot;white balance coefficients.\n&quot;</a>
<a name="ln4014">                                                         &quot;should be enabled on a first instance\n&quot;</a>
<a name="ln4015">                                                         &quot;for better denoising.\n&quot;</a>
<a name="ln4016">                                                         &quot;should be disabled if an earlier instance\n&quot;</a>
<a name="ln4017">                                                         &quot;has been used with a color blending mode.&quot;));</a>
<a name="ln4018">  g_signal_connect(G_OBJECT(g-&gt;wb_adaptive_anscombe), &quot;toggled&quot;, G_CALLBACK(wb_adaptive_anscombe_callback), self);</a>
<a name="ln4019"> </a>
<a name="ln4020"> </a>
<a name="ln4021">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;profile, TRUE, TRUE, 0);</a>
<a name="ln4022">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;wb_adaptive_anscombe, TRUE, TRUE, 0);</a>
<a name="ln4023">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;mode, TRUE, TRUE, 0);</a>
<a name="ln4024">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_nlm, TRUE, TRUE, 0);</a>
<a name="ln4025">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_wavelets, TRUE, TRUE, 0);</a>
<a name="ln4026">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;overshooting, TRUE, TRUE, 0);</a>
<a name="ln4027">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;strength, TRUE, TRUE, 0);</a>
<a name="ln4028">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;shadows, TRUE, TRUE, 0);</a>
<a name="ln4029">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;bias, TRUE, TRUE, 0);</a>
<a name="ln4030">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_variance, TRUE, TRUE, 0);</a>
<a name="ln4031"> </a>
<a name="ln4032">  g-&gt;fix_anscombe_and_nlmeans_norm = gtk_check_button_new_with_label(_(&quot;fix various bugs in algorithm&quot;));</a>
<a name="ln4033">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;fix_anscombe_and_nlmeans_norm), p-&gt;fix_anscombe_and_nlmeans_norm);</a>
<a name="ln4034">  gtk_widget_set_tooltip_text(g-&gt;fix_anscombe_and_nlmeans_norm, _(&quot;fix bugs in anscombe transform resulting\n&quot;</a>
<a name="ln4035">                                                 &quot;in undersmoothing of the green channel in\n&quot;</a>
<a name="ln4036">                                                 &quot;wavelets mode, combined with a bad handling\n&quot;</a>
<a name="ln4037">                                                 &quot;of white balance coefficients, and a bug in\n&quot;</a>
<a name="ln4038">                                                 &quot;non local means normalization resulting in\n&quot;</a>
<a name="ln4039">                                                 &quot;undersmoothing when patch size was increased.\n&quot;</a>
<a name="ln4040">                                                 &quot;enabling this option will change the denoising\n&quot;</a>
<a name="ln4041">                                                 &quot;you get. once enabled, you won't be able to\n&quot;</a>
<a name="ln4042">                                                 &quot;return back to old algorithm.&quot;));</a>
<a name="ln4043">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;fix_anscombe_and_nlmeans_norm, TRUE, TRUE, 0);</a>
<a name="ln4044">  g_signal_connect(G_OBJECT(g-&gt;fix_anscombe_and_nlmeans_norm), &quot;toggled&quot;, G_CALLBACK(fix_anscombe_and_nlmeans_norm_callback), self);</a>
<a name="ln4045">  g-&gt;use_new_vst = gtk_check_button_new_with_label(_(&quot;upgrade profiled transform&quot;));</a>
<a name="ln4046">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;use_new_vst), p-&gt;use_new_vst);</a>
<a name="ln4047">  gtk_widget_set_tooltip_text(g-&gt;use_new_vst, _(&quot;upgrade the variance stabilizing algorithm.\n&quot;</a>
<a name="ln4048">                                                &quot;new algorithm extends the current one.\n&quot;</a>
<a name="ln4049">                                                &quot;it is more flexible but could give small\n&quot;</a>
<a name="ln4050">                                                &quot;differences in the images already processed.&quot;));</a>
<a name="ln4051">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;use_new_vst, TRUE, TRUE, 0);</a>
<a name="ln4052">  g_signal_connect(G_OBJECT(g-&gt;use_new_vst), &quot;toggled&quot;, G_CALLBACK(use_new_vst_callback), self);</a>
<a name="ln4053"> </a>
<a name="ln4054">  gtk_widget_show_all(g-&gt;box_nlm);</a>
<a name="ln4055">  gtk_widget_show_all(g-&gt;box_wavelets);</a>
<a name="ln4056">  gtk_widget_show_all(g-&gt;box_variance);</a>
<a name="ln4057"> </a>
<a name="ln4058">  dt_bauhaus_widget_set_label(g-&gt;profile, NULL, _(&quot;profile&quot;));</a>
<a name="ln4059">  dt_bauhaus_widget_set_label(g-&gt;mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln4060">  dt_bauhaus_widget_set_label(g-&gt;radius, NULL, _(&quot;patch size&quot;));</a>
<a name="ln4061">  dt_bauhaus_slider_set_format(g-&gt;radius, &quot;%.0f&quot;);</a>
<a name="ln4062">  dt_bauhaus_widget_set_label(g-&gt;nbhood, NULL, _(&quot;search radius&quot;));</a>
<a name="ln4063">  dt_bauhaus_slider_set_format(g-&gt;nbhood, &quot;%.0f&quot;);</a>
<a name="ln4064">  dt_bauhaus_widget_set_label(g-&gt;scattering, NULL, _(&quot;scattering (coarse-grain noise)&quot;));</a>
<a name="ln4065">  dt_bauhaus_widget_set_label(g-&gt;central_pixel_weight, NULL, _(&quot;central pixel weight (details)&quot;));</a>
<a name="ln4066">  dt_bauhaus_widget_set_label(g-&gt;strength, NULL, _(&quot;strength&quot;));</a>
<a name="ln4067">  dt_bauhaus_widget_set_label(g-&gt;overshooting, NULL, _(&quot;adjust autoset parameters&quot;));</a>
<a name="ln4068">  dt_bauhaus_widget_set_label(g-&gt;shadows, NULL, _(&quot;preserve shadows&quot;));</a>
<a name="ln4069">  dt_bauhaus_widget_set_label(g-&gt;bias, NULL, _(&quot;bias correction&quot;));</a>
<a name="ln4070">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;non-local means&quot;));</a>
<a name="ln4071">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;non-local means auto&quot;));</a>
<a name="ln4072">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;wavelets&quot;));</a>
<a name="ln4073">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;wavelets auto&quot;));</a>
<a name="ln4074">  const gboolean compute_variance = dt_conf_get_bool(&quot;plugins/darkroom/denoiseprofile/show_compute_variance_mode&quot;);</a>
<a name="ln4075">  if(compute_variance)</a>
<a name="ln4076">  {</a>
<a name="ln4077">    dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;compute variance&quot;));</a>
<a name="ln4078">  }</a>
<a name="ln4079">  gtk_widget_set_tooltip_text(g-&gt;profile, _(&quot;profile used for variance stabilization&quot;));</a>
<a name="ln4080">  gtk_widget_set_tooltip_text(g-&gt;mode, _(&quot;method used in the denoising core. &quot;</a>
<a name="ln4081">                                         &quot;non-local means works best for `lightness' blending, &quot;</a>
<a name="ln4082">                                         &quot;wavelets work best for `color' blending&quot;));</a>
<a name="ln4083">  gtk_widget_set_tooltip_text(g-&gt;radius, _(&quot;radius of the patches to match.\n&quot;</a>
<a name="ln4084">                                           &quot;increase for more sharpness on strong edges, and better denoising of smooth areas.\n&quot;</a>
<a name="ln4085">                                           &quot;if details are oversmoothed, reduce this value or increase the details slider.&quot;));</a>
<a name="ln4086">  gtk_widget_set_tooltip_text(g-&gt;nbhood, _(&quot;emergency use only: radius of the neighbourhood to search patches in. increase for better denoising performance, but watch the long runtimes! large radii can be very slow. you have been warned&quot;));</a>
<a name="ln4087">  gtk_widget_set_tooltip_text(g-&gt;scattering,</a>
<a name="ln4088">                              _(&quot;scattering of the neighbourhood to search patches in. increase for better &quot;</a>
<a name="ln4089">                                &quot;coarse-grain noise reduction. does not affect execution time.&quot;));</a>
<a name="ln4090">  gtk_widget_set_tooltip_text(g-&gt;central_pixel_weight, _(&quot;increase the weight of the central pixel\n&quot;</a>
<a name="ln4091">                                                         &quot;of the patch in the patch comparison.\n&quot;</a>
<a name="ln4092">                                                         &quot;useful to recover details when patch size\n&quot;</a>
<a name="ln4093">                                                         &quot;is quite big.&quot;));</a>
<a name="ln4094">  gtk_widget_set_tooltip_text(g-&gt;strength, _(&quot;finetune denoising strength&quot;));</a>
<a name="ln4095">  gtk_widget_set_tooltip_text(g-&gt;overshooting, _(&quot;controls the way parameters are autoset\n&quot;</a>
<a name="ln4096">                                                 &quot;increase if shadows are not denoised enough\n&quot;</a>
<a name="ln4097">                                                 &quot;or if chroma noise remains.\n&quot;</a>
<a name="ln4098">                                                 &quot;this can happen if your picture is underexposed.&quot;));</a>
<a name="ln4099">  gtk_widget_set_tooltip_text(g-&gt;shadows, _(&quot;finetune shadows denoising.\n&quot;</a>
<a name="ln4100">                                            &quot;decrease to denoise more aggressively\n&quot;</a>
<a name="ln4101">                                            &quot;dark areas of the image.\n&quot;));</a>
<a name="ln4102">  gtk_widget_set_tooltip_text(g-&gt;bias, _(&quot;correct color cast in shadows.\n&quot;</a>
<a name="ln4103">                                         &quot;decrease if shadows are too purple.\n&quot;</a>
<a name="ln4104">                                         &quot;increase if shadows are too green.&quot;));</a>
<a name="ln4105">  g_signal_connect(G_OBJECT(g-&gt;profile), &quot;value-changed&quot;, G_CALLBACK(profile_callback), self);</a>
<a name="ln4106">  g_signal_connect(G_OBJECT(g-&gt;mode), &quot;value-changed&quot;, G_CALLBACK(mode_callback), self);</a>
<a name="ln4107">  g_signal_connect(G_OBJECT(g-&gt;radius), &quot;value-changed&quot;, G_CALLBACK(radius_callback), self);</a>
<a name="ln4108">  g_signal_connect(G_OBJECT(g-&gt;nbhood), &quot;value-changed&quot;, G_CALLBACK(nbhood_callback), self);</a>
<a name="ln4109">  g_signal_connect(G_OBJECT(g-&gt;scattering), &quot;value-changed&quot;, G_CALLBACK(scattering_callback), self);</a>
<a name="ln4110">  g_signal_connect(G_OBJECT(g-&gt;central_pixel_weight), &quot;value-changed&quot;, G_CALLBACK(central_pixel_weight_callback),</a>
<a name="ln4111">                   self);</a>
<a name="ln4112">  g_signal_connect(G_OBJECT(g-&gt;strength), &quot;value-changed&quot;, G_CALLBACK(strength_callback), self);</a>
<a name="ln4113">  g_signal_connect(G_OBJECT(g-&gt;overshooting), &quot;value-changed&quot;, G_CALLBACK(overshooting_callback), self);</a>
<a name="ln4114">  g_signal_connect(G_OBJECT(g-&gt;shadows), &quot;value-changed&quot;, G_CALLBACK(shadows_callback), self);</a>
<a name="ln4115">  g_signal_connect(G_OBJECT(g-&gt;bias), &quot;value-changed&quot;, G_CALLBACK(bias_callback), self);</a>
<a name="ln4116">}</a>
<a name="ln4117"> </a>
<a name="ln4118">void gui_cleanup(dt_iop_module_t *self)</a>
<a name="ln4119">{</a>
<a name="ln4120">  dt_iop_denoiseprofile_gui_data_t *g = (dt_iop_denoiseprofile_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4121">  g_list_free_full(g-&gt;profiles, dt_noiseprofile_free);</a>
<a name="ln4122">  dt_draw_curve_destroy(g-&gt;transition_curve);</a>
<a name="ln4123">  // nothing else necessary, gtk will clean up the slider.</a>
<a name="ln4124">  free(self-&gt;gui_data);</a>
<a name="ln4125">  self-&gt;gui_data = NULL;</a>
<a name="ln4126">}</a>
<a name="ln4127"> </a>
<a name="ln4128">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln4129">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln4130">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="2608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'dev_detail'. Check lines: 2608, 2547.</p></div>
<div class="balloon" rel="3080"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 3080, 3062.</p></div>
<div class="balloon" rel="3081"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 3081, 3063.</p></div>
<div class="balloon" rel="3096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 3096, 3094.</p></div>
<div class="balloon" rel="3233"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 3233, 3227.</p></div>
<div class="balloon" rel="3907"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 3907, 3902.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
