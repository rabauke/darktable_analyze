
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/collection.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/exif.h&quot;</a>
<a name="ln23">#include &quot;common/film.h&quot;</a>
<a name="ln24">#include &quot;common/image_cache.h&quot;</a>
<a name="ln25">#include &quot;common/imageio.h&quot;</a>
<a name="ln26">#include &quot;common/imageio_jpeg.h&quot;</a>
<a name="ln27">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln28">#include &quot;control/conf.h&quot;</a>
<a name="ln29">#include &quot;control/control.h&quot;</a>
<a name="ln30">#ifdef HAVE_GPHOTO2</a>
<a name="ln31">#include &quot;control/jobs/camera_jobs.h&quot;</a>
<a name="ln32">#endif</a>
<a name="ln33">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln34">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln35">#include &quot;gui/gtk.h&quot;</a>
<a name="ln36">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln37">#ifdef HAVE_GPHOTO2</a>
<a name="ln38">#include &quot;gui/camera_import_dialog.h&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40">#include &quot;libs/lib.h&quot;</a>
<a name="ln41">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln42">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln43">#include &quot;osx/osx.h&quot;</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;librsvg/rsvg.h&gt;</a>
<a name="ln47">// ugh, ugly hack. why do people break stuff all the time?</a>
<a name="ln48">#ifndef RSVG_CAIRO_H</a>
<a name="ln49">#include &lt;librsvg/rsvg-cairo.h&gt;</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#ifdef USE_LUA</a>
<a name="ln53">#include &quot;lua/widget/widget.h&quot;</a>
<a name="ln54">#endif</a>
<a name="ln55">DT_MODULE(1)</a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">#ifdef HAVE_GPHOTO2</a>
<a name="ln59">/** helper function to update ui with available cameras and their actionbuttons */</a>
<a name="ln60">static void _lib_import_ui_devices_update(dt_lib_module_t *self);</a>
<a name="ln61">#endif</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">typedef struct dt_lib_import_t</a>
<a name="ln65">{</a>
<a name="ln66">#ifdef HAVE_GPHOTO2</a>
<a name="ln67">  dt_camctl_listener_t camctl_listener;</a>
<a name="ln68">#endif</a>
<a name="ln69">  GtkButton *import_file;</a>
<a name="ln70">  GtkButton *import_directory;</a>
<a name="ln71">  GtkButton *import_camera;</a>
<a name="ln72">  GtkButton *scan_devices;</a>
<a name="ln73">  GtkButton *tethered_shoot;</a>
<a name="ln74"> </a>
<a name="ln75">  GtkBox *devices;</a>
<a name="ln76">#ifdef USE_LUA</a>
<a name="ln77">  GtkWidget *extra_lua_widgets;</a>
<a name="ln78">#endif</a>
<a name="ln79">} dt_lib_import_t;</a>
<a name="ln80"> </a>
<a name="ln81">typedef struct dt_lib_import_metadata_t</a>
<a name="ln82">{</a>
<a name="ln83">  GtkWidget *frame;</a>
<a name="ln84">  GtkWidget *recursive;</a>
<a name="ln85">  GtkWidget *ignore_jpeg;</a>
<a name="ln86">  GtkWidget *expander;</a>
<a name="ln87">  GtkWidget *apply_metadata;</a>
<a name="ln88">  GtkWidget *presets;</a>
<a name="ln89">  GtkWidget *creator;</a>
<a name="ln90">  GtkWidget *publisher;</a>
<a name="ln91">  GtkWidget *rights;</a>
<a name="ln92">  GtkWidget *tags;</a>
<a name="ln93">} dt_lib_import_metadata_t;</a>
<a name="ln94"> </a>
<a name="ln95">enum</a>
<a name="ln96">{</a>
<a name="ln97">  NAME_COLUMN,</a>
<a name="ln98">  CREATOR_COLUMN,</a>
<a name="ln99">  PUBLISHER_COLUMN,</a>
<a name="ln100">  RIGHTS_COLUMN,</a>
<a name="ln101">  N_COLUMNS</a>
<a name="ln102">};</a>
<a name="ln103"> </a>
<a name="ln104">const char *name(dt_lib_module_t *self)</a>
<a name="ln105">{</a>
<a name="ln106">  return _(&quot;import&quot;);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">const char **views(dt_lib_module_t *self)</a>
<a name="ln111">{</a>
<a name="ln112">  static const char *v[] = {&quot;lighttable&quot;, NULL};</a>
<a name="ln113">  return v;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln117">{</a>
<a name="ln118">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">int position()</a>
<a name="ln122">{</a>
<a name="ln123">  return 999;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln127">{</a>
<a name="ln128">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;scan for devices&quot;), 0, 0);</a>
<a name="ln129">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;import from camera&quot;), 0, 0);</a>
<a name="ln130">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;tethered shoot&quot;), 0, 0);</a>
<a name="ln131">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;import image&quot;), 0, 0);</a>
<a name="ln132">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;import folder&quot;), GDK_KEY_i, GDK_CONTROL_MASK | GDK_SHIFT_MASK);</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln136">{</a>
<a name="ln137">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln138"> </a>
<a name="ln139">  dt_accel_connect_button_lib(self, &quot;scan for devices&quot;, GTK_WIDGET(d-&gt;scan_devices));</a>
<a name="ln140">  dt_accel_connect_button_lib(self, &quot;import image&quot;, GTK_WIDGET(d-&gt;import_file));</a>
<a name="ln141">  dt_accel_connect_button_lib(self, &quot;import folder&quot;, GTK_WIDGET(d-&gt;import_directory));</a>
<a name="ln142">  if(d-&gt;tethered_shoot) dt_accel_connect_button_lib(self, &quot;tethered shoot&quot;, GTK_WIDGET(d-&gt;tethered_shoot));</a>
<a name="ln143">  if(d-&gt;import_camera) dt_accel_connect_button_lib(self, &quot;import from camera&quot;, GTK_WIDGET(d-&gt;import_camera));</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">#ifdef HAVE_GPHOTO2</a>
<a name="ln147"> </a>
<a name="ln148">/* scan for new devices button callback */</a>
<a name="ln149">static void _lib_import_scan_devices_callback(GtkButton *button, gpointer data)</a>
<a name="ln150">{</a>
<a name="ln151">  /* detect cameras */</a>
<a name="ln152">  dt_camctl_detect_cameras(darktable.camctl);</a>
<a name="ln153">  /* update UI */</a>
<a name="ln154">  // this part is now asynchronously done by the signal connected to in gui_init()</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">/* show import from camera dialog */</a>
<a name="ln158">static void _lib_import_from_camera_callback(GtkButton *button, gpointer data)</a>
<a name="ln159">{</a>
<a name="ln160">  dt_camera_import_dialog_param_t *params</a>
<a name="ln161">      = (dt_camera_import_dialog_param_t *)g_malloc0(sizeof(dt_camera_import_dialog_param_t));</a>
<a name="ln162">  params-&gt;camera = (dt_camera_t *)data;</a>
<a name="ln163"> </a>
<a name="ln164">  dt_camera_import_dialog_new(params);</a>
<a name="ln165">  if(params-&gt;result)</a>
<a name="ln166">  {</a>
<a name="ln167">    /* initialize a import job and put it on queue.... */</a>
<a name="ln168">    dt_control_add_job(</a>
<a name="ln169">        darktable.control, DT_JOB_QUEUE_USER_BG,</a>
<a name="ln170">        dt_camera_import_job_create(params-&gt;jobcode, params-&gt;result, params-&gt;camera, params-&gt;time_override));</a>
<a name="ln171">  }</a>
<a name="ln172">  g_free(params-&gt;jobcode);</a>
<a name="ln173">  g_list_free(params-&gt;result);</a>
<a name="ln174">  g_free(params);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/* enter tethering mode for camera */</a>
<a name="ln178">static void _lib_import_tethered_callback(GtkToggleButton *button, gpointer data)</a>
<a name="ln179">{</a>
<a name="ln180">  /* select camera to work with before switching mode */</a>
<a name="ln181">  dt_camctl_select_camera(darktable.camctl, (dt_camera_t *)data);</a>
<a name="ln182">  dt_ctl_switch_mode_to(&quot;tethering&quot;);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">/** update the device list */</a>
<a name="ln187">void _lib_import_ui_devices_update(dt_lib_module_t *self)</a>
<a name="ln188">{</a>
<a name="ln189">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln190"> </a>
<a name="ln191">  GList *citem;</a>
<a name="ln192"> </a>
<a name="ln193">  /* cleanup of widgets in devices container*/</a>
<a name="ln194">  GList *item, *iter;</a>
<a name="ln195"> </a>
<a name="ln196">  if((iter = item = gtk_container_get_children(GTK_CONTAINER(d-&gt;devices))) != NULL) do</a>
<a name="ln197">    {</a>
<a name="ln198">      gtk_container_remove(GTK_CONTAINER(d-&gt;devices), GTK_WIDGET(iter-&gt;data));</a>
<a name="ln199">    } while((iter = g_list_next(iter)) != NULL);</a>
<a name="ln200"> </a>
<a name="ln201">  g_list_free(item);</a>
<a name="ln202"> </a>
<a name="ln203">  uint32_t count = 0;</a>
<a name="ln204">  /* FIXME: Verify that it's safe to access camctl-&gt;cameras list here ? */</a>
<a name="ln205">  if((citem = g_list_first(darktable.camctl-&gt;cameras)) != NULL)</a>
<a name="ln206">  {</a>
<a name="ln207">    // Add detected supported devices</a>
<a name="ln208">    char buffer[512] = { 0 };</a>
<a name="ln209">    do</a>
<a name="ln210">    {</a>
<a name="ln211">      dt_camera_t *camera = (dt_camera_t *)citem-&gt;data;</a>
<a name="ln212">      count++;</a>
<a name="ln213"> </a>
<a name="ln214">      /* add camera label */</a>
<a name="ln215">      GtkWidget *label = dt_ui_section_label_new(camera-&gt;model);</a>
<a name="ln216">      gtk_widget_set_margin_top(label, DT_PIXEL_APPLY_DPI(15));</a>
<a name="ln217">      gtk_box_pack_start(GTK_BOX(d-&gt;devices), label, TRUE, TRUE, 0);</a>
<a name="ln218"> </a>
<a name="ln219">      /* set camera summary if available */</a>
<a name="ln220">      if(*camera-&gt;summary.text)</a>
<a name="ln221">      {</a>
<a name="ln222">        gtk_widget_set_tooltip_text(label, camera-&gt;summary.text);</a>
<a name="ln223">      }</a>
<a name="ln224">      else</a>
<a name="ln225">      {</a>
<a name="ln226">        snprintf(buffer, sizeof(buffer), _(&quot;device \&quot;%s\&quot; connected on port \&quot;%s\&quot;.&quot;), camera-&gt;model,</a>
<a name="ln227">                 camera-&gt;port);</a>
<a name="ln228">        gtk_widget_set_tooltip_text(label, buffer);</a>
<a name="ln229">      }</a>
<a name="ln230"> </a>
<a name="ln231">      /* add camera actions buttons */</a>
<a name="ln232">      GtkWidget *ib = NULL, *tb = NULL;</a>
<a name="ln233">      GtkWidget *vbx = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln234">      if(camera-&gt;can_import == TRUE)</a>
<a name="ln235">      {</a>
<a name="ln236">        gtk_box_pack_start(GTK_BOX(vbx), (ib = gtk_button_new_with_label(_(&quot;import from camera&quot;))), FALSE,</a>
<a name="ln237">                           FALSE, 0);</a>
<a name="ln238">        d-&gt;import_camera = GTK_BUTTON(ib);</a>
<a name="ln239">      }</a>
<a name="ln240">      if(camera-&gt;can_tether == TRUE)</a>
<a name="ln241">      {</a>
<a name="ln242">        gtk_box_pack_start(GTK_BOX(vbx), (tb = gtk_button_new_with_label(_(&quot;tethered shoot&quot;))), FALSE, FALSE,</a>
<a name="ln243">                           0);</a>
<a name="ln244">        d-&gt;tethered_shoot = GTK_BUTTON(tb);</a>
<a name="ln245">      }</a>
<a name="ln246"> </a>
<a name="ln247">      if(ib)</a>
<a name="ln248">      {</a>
<a name="ln249">        g_signal_connect(G_OBJECT(ib), &quot;clicked&quot;, G_CALLBACK(_lib_import_from_camera_callback), camera);</a>
<a name="ln250">        gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(ib)), GTK_ALIGN_START);</a>
<a name="ln251">        dt_gui_add_help_link(ib, &quot;lighttable_panels.html#import_from_camera&quot;);</a>
<a name="ln252">      }</a>
<a name="ln253">      if(tb)</a>
<a name="ln254">      {</a>
<a name="ln255">        g_signal_connect(G_OBJECT(tb), &quot;clicked&quot;, G_CALLBACK(_lib_import_tethered_callback), camera);</a>
<a name="ln256">        gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(tb)), GTK_ALIGN_START);</a>
<a name="ln257">        dt_gui_add_help_link(tb, &quot;lighttable_panels.html#import_from_camera&quot;);</a>
<a name="ln258">      }</a>
<a name="ln259">      gtk_box_pack_start(GTK_BOX(d-&gt;devices), vbx, FALSE, FALSE, 0);</a>
<a name="ln260">    } while((citem = g_list_next(citem)) != NULL);</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  if(count == 0)</a>
<a name="ln264">  {</a>
<a name="ln265">    // No supported devices is detected lets notice user..</a>
<a name="ln266">    GtkWidget *label = gtk_label_new(_(&quot;no supported devices found&quot;));</a>
<a name="ln267">    gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);</a>
<a name="ln268">    g_object_set(G_OBJECT(label), &quot;xalign&quot;, 0.0, (gchar *)0);</a>
<a name="ln269">    gtk_box_pack_start(GTK_BOX(d-&gt;devices), label, TRUE, TRUE, 0);</a>
<a name="ln270">  }</a>
<a name="ln271">  gtk_widget_show_all(GTK_WIDGET(d-&gt;devices));</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">/** camctl camera disconnect callback */</a>
<a name="ln275">static gboolean _detect_async(gpointer user_data)</a>
<a name="ln276">{</a>
<a name="ln277">  dt_camctl_detect_cameras(darktable.camctl);</a>
<a name="ln278">  return FALSE;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static void _camctl_camera_disconnected_callback(const dt_camera_t *camera, void *data)</a>
<a name="ln282">{</a>
<a name="ln283">  /* rescan connected cameras. do that asynchronously since otherwise we deadlock (#10314) */</a>
<a name="ln284">  g_idle_add(_detect_async, NULL);</a>
<a name="ln285"> </a>
<a name="ln286">  /* update gui with detected devices */</a>
<a name="ln287">  // this is done asynchronously in _camera_detected()</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/** camctl status listener callback */</a>
<a name="ln291">typedef struct _control_status_params_t</a>
<a name="ln292">{</a>
<a name="ln293">  dt_camctl_status_t status;</a>
<a name="ln294">  dt_lib_module_t *self;</a>
<a name="ln295">} _control_status_params_t;</a>
<a name="ln296"> </a>
<a name="ln297">static gboolean _camctl_camera_control_status_callback_gui_thread(gpointer user_data)</a>
<a name="ln298">{</a>
<a name="ln299">  _control_status_params_t *params = (_control_status_params_t *)user_data;</a>
<a name="ln300"> </a>
<a name="ln301">  dt_lib_import_t *d = (dt_lib_import_t *)params-&gt;self-&gt;data;</a>
<a name="ln302"> </a>
<a name="ln303">  /* handle camctl status */</a>
<a name="ln304">  switch(params-&gt;status)</a>
<a name="ln305">  {</a>
<a name="ln306">    case CAMERA_CONTROL_BUSY:</a>
<a name="ln307">    {</a>
<a name="ln308">      /* set all devices as inaccessible */</a>
<a name="ln309">      GList *list, *child;</a>
<a name="ln310">      list = child = gtk_container_get_children(GTK_CONTAINER(d-&gt;devices));</a>
<a name="ln311">      if(child) do</a>
<a name="ln312">      {</a>
<a name="ln313">        if(!(GTK_IS_TOGGLE_BUTTON(child-&gt;data)</a>
<a name="ln314">          &amp;&amp; gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(child-&gt;data)) == TRUE))</a>
<a name="ln315">          gtk_widget_set_sensitive(GTK_WIDGET(child-&gt;data), FALSE);</a>
<a name="ln316">      } while((child = g_list_next(child)));</a>
<a name="ln317">      g_list_free(list);</a>
<a name="ln318">    }</a>
<a name="ln319">    break;</a>
<a name="ln320"> </a>
<a name="ln321">    case CAMERA_CONTROL_AVAILABLE:</a>
<a name="ln322">    {</a>
<a name="ln323">      /* set all devices as accessible */</a>
<a name="ln324">      GList *list, *child;</a>
<a name="ln325">      list = child = gtk_container_get_children(GTK_CONTAINER(d-&gt;devices));</a>
<a name="ln326">      if(child) do</a>
<a name="ln327">      {</a>
<a name="ln328">        gtk_widget_set_sensitive(GTK_WIDGET(child-&gt;data), TRUE);</a>
<a name="ln329">      } while((child = g_list_next(child)));</a>
<a name="ln330">      g_list_free(list);</a>
<a name="ln331">    }</a>
<a name="ln332">    break;</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  free(params);</a>
<a name="ln336">  return FALSE;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">static void _camctl_camera_control_status_callback(dt_camctl_status_t status, void *data)</a>
<a name="ln340">{</a>
<a name="ln341">  dt_lib_module_t *self = (dt_lib_module_t *)data;</a>
<a name="ln342">  _control_status_params_t *params = (_control_status_params_t *)malloc(sizeof(_control_status_params_t));</a>
<a name="ln343">  if(!params) return;</a>
<a name="ln344">  params-&gt;status = status;</a>
<a name="ln345">  params-&gt;self = self;</a>
<a name="ln346">  g_main_context_invoke(NULL, _camctl_camera_control_status_callback_gui_thread, params);</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">#endif // HAVE_GPHOTO2</a>
<a name="ln350"> </a>
<a name="ln351">static void _lib_import_metadata_changed(GtkWidget *widget, GtkComboBox *box)</a>
<a name="ln352">{</a>
<a name="ln353">  gtk_combo_box_set_active(box, -1);</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">static void _lib_import_apply_metadata_toggled(GtkWidget *widget, gpointer user_data)</a>
<a name="ln357">{</a>
<a name="ln358">  GtkWidget *grid = GTK_WIDGET(user_data);</a>
<a name="ln359">  gtk_widget_set_sensitive(grid, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">static void _lib_import_presets_changed(GtkWidget *widget, dt_lib_import_metadata_t *data)</a>
<a name="ln363">{</a>
<a name="ln364">  GtkTreeIter iter;</a>
<a name="ln365"> </a>
<a name="ln366">  if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(widget), &amp;iter) == TRUE)</a>
<a name="ln367">  {</a>
<a name="ln368">    GtkTreeModel *model = gtk_combo_box_get_model(GTK_COMBO_BOX(widget));</a>
<a name="ln369">    GValue value = {</a>
<a name="ln370">      0,</a>
<a name="ln371">    };</a>
<a name="ln372">    gchar *sv;</a>
<a name="ln373"> </a>
<a name="ln374">    gtk_tree_model_get_value(model, &amp;iter, CREATOR_COLUMN, &amp;value);</a>
<a name="ln375">    if((sv = (gchar *)g_value_get_string(&amp;value)) != NULL &amp;&amp; sv[0] != '\0')</a>
<a name="ln376">    {</a>
<a name="ln377">      g_signal_handlers_block_by_func(data-&gt;creator, _lib_import_metadata_changed, data-&gt;presets);</a>
<a name="ln378">      gtk_entry_set_text(GTK_ENTRY(data-&gt;creator), sv);</a>
<a name="ln379">      g_signal_handlers_unblock_by_func(data-&gt;creator, _lib_import_metadata_changed, data-&gt;presets);</a>
<a name="ln380">    }</a>
<a name="ln381">    g_value_unset(&amp;value);</a>
<a name="ln382"> </a>
<a name="ln383">    gtk_tree_model_get_value(model, &amp;iter, PUBLISHER_COLUMN, &amp;value);</a>
<a name="ln384">    if((sv = (gchar *)g_value_get_string(&amp;value)) != NULL &amp;&amp; sv[0] != '\0')</a>
<a name="ln385">    {</a>
<a name="ln386">      g_signal_handlers_block_by_func(data-&gt;publisher, _lib_import_metadata_changed, data-&gt;presets);</a>
<a name="ln387">      gtk_entry_set_text(GTK_ENTRY(data-&gt;publisher), sv);</a>
<a name="ln388">      g_signal_handlers_unblock_by_func(data-&gt;publisher, _lib_import_metadata_changed, data-&gt;presets);</a>
<a name="ln389">    }</a>
<a name="ln390">    g_value_unset(&amp;value);</a>
<a name="ln391"> </a>
<a name="ln392">    gtk_tree_model_get_value(model, &amp;iter, RIGHTS_COLUMN, &amp;value);</a>
<a name="ln393">    if((sv = (gchar *)g_value_get_string(&amp;value)) != NULL &amp;&amp; sv[0] != '\0')</a>
<a name="ln394">    {</a>
<a name="ln395">      g_signal_handlers_block_by_func(data-&gt;rights, _lib_import_metadata_changed, data-&gt;presets);</a>
<a name="ln396">      gtk_entry_set_text(GTK_ENTRY(data-&gt;rights), sv);</a>
<a name="ln397">      g_signal_handlers_unblock_by_func(data-&gt;rights, _lib_import_metadata_changed, data-&gt;presets);</a>
<a name="ln398">    }</a>
<a name="ln399">    g_value_unset(&amp;value);</a>
<a name="ln400">  }</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">#ifdef USE_LUA</a>
<a name="ln404">static void reset_child(GtkWidget* child, gpointer user_data)</a>
<a name="ln405">{</a>
<a name="ln406">  dt_lua_async_call_alien(dt_lua_widget_trigger_callback,</a>
<a name="ln407">      0,NULL,NULL,</a>
<a name="ln408">      LUA_ASYNC_TYPENAME,&quot;lua_widget&quot;,child, // the GtkWidget is an alias for the lua_widget</a>
<a name="ln409">      LUA_ASYNC_TYPENAME,&quot;const char*&quot;,&quot;reset&quot;,</a>
<a name="ln410">      LUA_ASYNC_DONE);</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">// remove the extra portion from the filechooser before destroying it</a>
<a name="ln414">static void detach_lua_widgets(GtkWidget *extra_lua_widgets)</a>
<a name="ln415">{</a>
<a name="ln416">  GtkWidget *parent = gtk_widget_get_parent(extra_lua_widgets);</a>
<a name="ln417">  gtk_container_remove(GTK_CONTAINER(parent), extra_lua_widgets);</a>
<a name="ln418">}</a>
<a name="ln419">#endif</a>
<a name="ln420"> </a>
<a name="ln421">static void _check_button_callback(GtkWidget *widget, gpointer data)</a>
<a name="ln422">{</a>
<a name="ln423">    dt_conf_set_bool(&quot;ui_last/import_ignore_jpegs&quot;,</a>
<a name="ln424">                     gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">static GtkWidget *_lib_import_get_extra_widget(dt_lib_module_t *self,dt_lib_import_metadata_t *data, gboolean import_folder)</a>
<a name="ln428">{</a>
<a name="ln429">  // add extra lines to 'extra'. don't forget to destroy the widgets later.</a>
<a name="ln430">  GtkWidget *expander = gtk_expander_new(_(&quot;import options&quot;));</a>
<a name="ln431">  gtk_expander_set_expanded(GTK_EXPANDER(expander), dt_conf_get_bool(&quot;ui_last/import_options_expanded&quot;));</a>
<a name="ln432"> </a>
<a name="ln433">  GtkWidget *frame = gtk_frame_new(NULL);</a>
<a name="ln434">  gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_IN);</a>
<a name="ln435">  gtk_widget_set_hexpand(frame, TRUE);</a>
<a name="ln436">  GtkWidget *event_box = gtk_event_box_new();</a>
<a name="ln437"> </a>
<a name="ln438">  gtk_widget_set_margin_start(event_box, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln439">  gtk_widget_set_margin_end(event_box, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln440">  gtk_widget_set_margin_top(event_box, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln441">  gtk_widget_set_margin_bottom(event_box, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln442"> </a>
<a name="ln443">  gtk_container_add(GTK_CONTAINER(frame), event_box);</a>
<a name="ln444">  gtk_container_add(GTK_CONTAINER(event_box), expander);</a>
<a name="ln445"> </a>
<a name="ln446">  GtkWidget *extra;</a>
<a name="ln447">  extra = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln448">  gtk_container_add(GTK_CONTAINER(expander), extra);</a>
<a name="ln449"> </a>
<a name="ln450">  gtk_widget_set_margin_start(extra, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln451">  gtk_widget_set_margin_end(extra, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln452">  gtk_widget_set_margin_top(extra, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln453">  gtk_widget_set_margin_bottom(extra, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln454"> </a>
<a name="ln455">  GtkWidget *recursive = NULL, *ignore_jpeg = NULL;</a>
<a name="ln456">  if(import_folder == TRUE)</a>
<a name="ln457">  {</a>
<a name="ln458">    // recursive opening.</a>
<a name="ln459">    recursive = gtk_check_button_new_with_label(_(&quot;import directories recursively&quot;));</a>
<a name="ln460">    gtk_widget_set_tooltip_text(recursive,</a>
<a name="ln461">                                _(&quot;recursively import subdirectories. each directory goes into a new film roll.&quot;));</a>
<a name="ln462">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(recursive), dt_conf_get_bool(&quot;ui_last/import_recursive&quot;));</a>
<a name="ln463">    gtk_box_pack_start(GTK_BOX(extra), recursive, FALSE, FALSE, 0);</a>
<a name="ln464"> </a>
<a name="ln465">    // ignoring of jpegs. hack while we don't handle raw+jpeg in the same directories.</a>
<a name="ln466">    ignore_jpeg = gtk_check_button_new_with_label(_(&quot;ignore JPEG files&quot;));</a>
<a name="ln467">    gtk_widget_set_tooltip_text(ignore_jpeg, _(&quot;do not load files with an extension of .jpg or .jpeg. this &quot;</a>
<a name="ln468">                                               &quot;can be useful when there are raw+JPEG in a directory.&quot;));</a>
<a name="ln469">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(ignore_jpeg),</a>
<a name="ln470">                                 dt_conf_get_bool(&quot;ui_last/import_ignore_jpegs&quot;));</a>
<a name="ln471">    gtk_box_pack_start(GTK_BOX(extra), ignore_jpeg, FALSE, FALSE, 0);</a>
<a name="ln472">    g_signal_connect(G_OBJECT(ignore_jpeg), &quot;clicked&quot;,</a>
<a name="ln473">                   G_CALLBACK(_check_button_callback), ignore_jpeg);</a>
<a name="ln474">  }</a>
<a name="ln475"> </a>
<a name="ln476">  // default metadata</a>
<a name="ln477">  GtkWidget *apply_metadata;</a>
<a name="ln478">  GtkWidget *grid, *label, *creator, *publisher, *rights, *tags;</a>
<a name="ln479">  apply_metadata = gtk_check_button_new_with_label(_(&quot;apply metadata on import&quot;));</a>
<a name="ln480">  gtk_widget_set_tooltip_text(apply_metadata, _(&quot;apply some metadata to all newly imported images.&quot;));</a>
<a name="ln481">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(apply_metadata),</a>
<a name="ln482">                               dt_conf_get_bool(&quot;ui_last/import_apply_metadata&quot;));</a>
<a name="ln483">  gtk_box_pack_start(GTK_BOX(extra), apply_metadata, FALSE, FALSE, 0);</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">  GValue value = {</a>
<a name="ln487">    0,</a>
<a name="ln488">  };</a>
<a name="ln489">  g_value_init(&amp;value, G_TYPE_INT);</a>
<a name="ln490">  gtk_widget_style_get_property(apply_metadata, &quot;indicator-size&quot;, &amp;value);</a>
<a name="ln491">  gint indicator_size = g_value_get_int(&amp;value);</a>
<a name="ln492">  gtk_widget_style_get_property(apply_metadata, &quot;indicator-spacing&quot;, &amp;value);</a>
<a name="ln493">  gint indicator_spacing = g_value_get_int(&amp;value);</a>
<a name="ln494">  g_value_unset(&amp;value);</a>
<a name="ln495"> </a>
<a name="ln496">  grid = gtk_grid_new();</a>
<a name="ln497">  gtk_grid_set_row_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln498">  gtk_grid_set_column_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln499">  gtk_widget_set_margin_start(grid,  2 * (indicator_spacing + indicator_size));</a>
<a name="ln500">  gtk_box_pack_start(GTK_BOX(extra), grid, FALSE, FALSE, 0);</a>
<a name="ln501"> </a>
<a name="ln502">#ifdef USE_LUA</a>
<a name="ln503">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln504">  gtk_box_pack_start(GTK_BOX(extra),d-&gt;extra_lua_widgets , FALSE, FALSE, 0);</a>
<a name="ln505">  gtk_container_foreach(GTK_CONTAINER(d-&gt;extra_lua_widgets),reset_child,NULL);</a>
<a name="ln506">#endif</a>
<a name="ln507"> </a>
<a name="ln508">  creator = gtk_entry_new();</a>
<a name="ln509">  gtk_widget_set_size_request(creator, DT_PIXEL_APPLY_DPI(300), -1);</a>
<a name="ln510">  gchar *str = dt_conf_get_string(&quot;ui_last/import_last_creator&quot;);</a>
<a name="ln511">  gtk_entry_set_text(GTK_ENTRY(creator), str);</a>
<a name="ln512">  g_free(str);</a>
<a name="ln513"> </a>
<a name="ln514">  publisher = gtk_entry_new();</a>
<a name="ln515">  str = dt_conf_get_string(&quot;ui_last/import_last_publisher&quot;);</a>
<a name="ln516">  gtk_entry_set_text(GTK_ENTRY(publisher), str);</a>
<a name="ln517">  g_free(str);</a>
<a name="ln518"> </a>
<a name="ln519">  rights = gtk_entry_new();</a>
<a name="ln520">  str = dt_conf_get_string(&quot;ui_last/import_last_rights&quot;);</a>
<a name="ln521">  gtk_entry_set_text(GTK_ENTRY(rights), str);</a>
<a name="ln522">  g_free(str);</a>
<a name="ln523"> </a>
<a name="ln524">  tags = gtk_entry_new();</a>
<a name="ln525">  str = dt_conf_get_string(&quot;ui_last/import_last_tags&quot;);</a>
<a name="ln526">  gtk_widget_set_tooltip_text(tags, _(&quot;comma separated list of tags&quot;));</a>
<a name="ln527">  gtk_entry_set_text(GTK_ENTRY(tags), str);</a>
<a name="ln528">  g_free(str);</a>
<a name="ln529"> </a>
<a name="ln530">  // presets from the metadata plugin</a>
<a name="ln531">  GtkCellRenderer *renderer;</a>
<a name="ln532">  GtkTreeIter iter;</a>
<a name="ln533">  GtkListStore *model = gtk_list_store_new(N_COLUMNS, G_TYPE_STRING /*name*/, G_TYPE_STRING /*creator*/,</a>
<a name="ln534">                                           G_TYPE_STRING /*publisher*/, G_TYPE_STRING /*rights*/);</a>
<a name="ln535"> </a>
<a name="ln536">  GtkWidget *presets = gtk_combo_box_new_with_model(GTK_TREE_MODEL(model));</a>
<a name="ln537">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln538">  gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(presets), renderer, FALSE);</a>
<a name="ln539">  gtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(presets), renderer, &quot;text&quot;, NAME_COLUMN, NULL);</a>
<a name="ln540"> </a>
<a name="ln541">  sqlite3_stmt *stmt;</a>
<a name="ln542">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln543">                              &quot;SELECT name, op_params FROM data.presets WHERE operation = \&quot;metadata\&quot;&quot;, -1, &amp;stmt,</a>
<a name="ln544">                              NULL);</a>
<a name="ln545">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln546">  {</a>
<a name="ln547">    void *op_params = (void *)sqlite3_column_blob(stmt, 1);</a>
<a name="ln548">    int32_t op_params_size = sqlite3_column_bytes(stmt, 1);</a>
<a name="ln549"> </a>
<a name="ln550">    char *buf = (char *)op_params;</a>
<a name="ln551">    char *title_str = buf;</a>
<a name="ln552">    buf += strlen(title_str) + 1;</a>
<a name="ln553">    char *description_str = buf;</a>
<a name="ln554">    buf += strlen(description_str) + 1;</a>
<a name="ln555">    char *rights_str = buf;</a>
<a name="ln556">    buf += strlen(rights_str) + 1;</a>
<a name="ln557">    char *creator_str = buf;</a>
<a name="ln558">    buf += strlen(creator_str) + 1;</a>
<a name="ln559">    char *publisher_str = buf;</a>
<a name="ln560"> </a>
<a name="ln561">    if(op_params_size</a>
<a name="ln562">       == strlen(title_str) + strlen(description_str) + strlen(rights_str) + strlen(creator_str)</a>
<a name="ln563">              + strlen(publisher_str) + 5)</a>
<a name="ln564">    {</a>
<a name="ln565">      gtk_list_store_append(model, &amp;iter);</a>
<a name="ln566">      gtk_list_store_set(model, &amp;iter, NAME_COLUMN, (char *)sqlite3_column_text(stmt, 0), CREATOR_COLUMN,</a>
<a name="ln567">                         creator_str, PUBLISHER_COLUMN, publisher_str, RIGHTS_COLUMN, rights_str, -1);</a>
<a name="ln568">    }</a>
<a name="ln569">  }</a>
<a name="ln570">  sqlite3_finalize(stmt);</a>
<a name="ln571"> </a>
<a name="ln572">  g_object_unref(model);</a>
<a name="ln573"> </a>
<a name="ln574">  int line = 0;</a>
<a name="ln575"> </a>
<a name="ln576">  label = gtk_label_new(_(&quot;preset&quot;));</a>
<a name="ln577">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln578">  gtk_grid_attach(GTK_GRID(grid), label, 0, line++, 1, 1);</a>
<a name="ln579">  gtk_grid_attach_next_to(GTK_GRID(grid), presets, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln580"> </a>
<a name="ln581">  label = gtk_label_new(_(&quot;creator&quot;));</a>
<a name="ln582">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln583">  gtk_grid_attach(GTK_GRID(grid), label, 0, line++, 1, 1);</a>
<a name="ln584">  gtk_grid_attach_next_to(GTK_GRID(grid), creator, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln585"> </a>
<a name="ln586">  label = gtk_label_new(_(&quot;publisher&quot;));</a>
<a name="ln587">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln588">  gtk_grid_attach(GTK_GRID(grid), label, 0, line++, 1, 1);</a>
<a name="ln589">  gtk_grid_attach_next_to(GTK_GRID(grid), publisher, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln590"> </a>
<a name="ln591">  label = gtk_label_new(_(&quot;rights&quot;));</a>
<a name="ln592">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln593">  gtk_grid_attach(GTK_GRID(grid), label, 0, line++, 1, 1);</a>
<a name="ln594">  gtk_grid_attach_next_to(GTK_GRID(grid), rights, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln595"> </a>
<a name="ln596">  label = gtk_label_new(_(&quot;tags&quot;));</a>
<a name="ln597">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln598">  gtk_grid_attach(GTK_GRID(grid), label, 0, line, 1, 1);</a>
<a name="ln599">  gtk_grid_attach_next_to(GTK_GRID(grid), tags, label, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln600"> </a>
<a name="ln601">  gtk_widget_show_all(frame);</a>
<a name="ln602"> </a>
<a name="ln603">  if(data != NULL)</a>
<a name="ln604">  {</a>
<a name="ln605">    data-&gt;frame = frame;</a>
<a name="ln606">    data-&gt;recursive = recursive;</a>
<a name="ln607">    data-&gt;ignore_jpeg = ignore_jpeg;</a>
<a name="ln608">    data-&gt;expander = expander;</a>
<a name="ln609">    data-&gt;apply_metadata = apply_metadata;</a>
<a name="ln610">    data-&gt;presets = presets;</a>
<a name="ln611">    data-&gt;creator = creator;</a>
<a name="ln612">    data-&gt;publisher = publisher;</a>
<a name="ln613">    data-&gt;rights = rights;</a>
<a name="ln614">    data-&gt;tags = tags;</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  g_signal_connect(apply_metadata, &quot;toggled&quot;, G_CALLBACK(_lib_import_apply_metadata_toggled), grid);</a>
<a name="ln618">  // needed since the apply_metadata starts being turned off, and setting it to off doesn't emit the 'toggled' signal ...</a>
<a name="ln619">  _lib_import_apply_metadata_toggled(apply_metadata, grid);</a>
<a name="ln620"> </a>
<a name="ln621">  g_signal_connect(presets, &quot;changed&quot;, G_CALLBACK(_lib_import_presets_changed), data);</a>
<a name="ln622">  g_signal_connect(GTK_ENTRY(creator), &quot;changed&quot;, G_CALLBACK(_lib_import_metadata_changed), presets);</a>
<a name="ln623">  g_signal_connect(GTK_ENTRY(publisher), &quot;changed&quot;, G_CALLBACK(_lib_import_metadata_changed), presets);</a>
<a name="ln624">  g_signal_connect(GTK_ENTRY(rights), &quot;changed&quot;, G_CALLBACK(_lib_import_metadata_changed), presets);</a>
<a name="ln625"> </a>
<a name="ln626">  return frame;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">static void _lib_import_evaluate_extra_widget(dt_lib_import_metadata_t *data, gboolean import_folder)</a>
<a name="ln630">{</a>
<a name="ln631">  if(import_folder == TRUE)</a>
<a name="ln632">  {</a>
<a name="ln633">    dt_conf_set_bool(&quot;ui_last/import_recursive&quot;,</a>
<a name="ln634">                     gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data-&gt;recursive)));</a>
<a name="ln635">    dt_conf_set_bool(&quot;ui_last/import_ignore_jpegs&quot;,</a>
<a name="ln636">                     gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data-&gt;ignore_jpeg)));</a>
<a name="ln637">  }</a>
<a name="ln638">  dt_conf_set_bool(&quot;ui_last/import_options_expanded&quot;, gtk_expander_get_expanded(GTK_EXPANDER(data-&gt;expander)));</a>
<a name="ln639">  dt_conf_set_bool(&quot;ui_last/import_apply_metadata&quot;,</a>
<a name="ln640">                   gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data-&gt;apply_metadata)));</a>
<a name="ln641">  dt_conf_set_string(&quot;ui_last/import_last_creator&quot;, gtk_entry_get_text(GTK_ENTRY(data-&gt;creator)));</a>
<a name="ln642">  dt_conf_set_string(&quot;ui_last/import_last_publisher&quot;, gtk_entry_get_text(GTK_ENTRY(data-&gt;publisher)));</a>
<a name="ln643">  dt_conf_set_string(&quot;ui_last/import_last_rights&quot;, gtk_entry_get_text(GTK_ENTRY(data-&gt;rights)));</a>
<a name="ln644">  dt_conf_set_string(&quot;ui_last/import_last_tags&quot;, gtk_entry_get_text(GTK_ENTRY(data-&gt;tags)));</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">// maybe this should be (partly) in common/imageio.[c|h]?</a>
<a name="ln648">static void _lib_import_update_preview(GtkFileChooser *file_chooser, gpointer data)</a>
<a name="ln649">{</a>
<a name="ln650">  GtkWidget *preview;</a>
<a name="ln651">  char *filename;</a>
<a name="ln652">  GdkPixbuf *pixbuf = NULL;</a>
<a name="ln653">  gboolean have_preview = FALSE, no_preview_fallback = FALSE;</a>
<a name="ln654"> </a>
<a name="ln655">  preview = GTK_WIDGET(data);</a>
<a name="ln656">  filename = gtk_file_chooser_get_preview_filename(file_chooser);</a>
<a name="ln657"> </a>
<a name="ln658">  if(filename &amp;&amp; g_file_test(filename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln659">  {</a>
<a name="ln660">    // don't create dng thumbnails to avoid crashes in libtiff when these are hdr:</a>
<a name="ln661">    char *c = filename + strlen(filename);</a>
<a name="ln662">    while(c &gt; filename &amp;&amp; *c != '.') c--;</a>
<a name="ln663">    if(!strcasecmp(c, &quot;.dng&quot;)) no_preview_fallback = TRUE;</a>
<a name="ln664">  }</a>
<a name="ln665">  else</a>
<a name="ln666">  {</a>
<a name="ln667">    no_preview_fallback = TRUE;</a>
<a name="ln668">  }</a>
<a name="ln669"> </a>
<a name="ln670">  // Step 1: try to check whether the picture contains embedded thumbnail</a>
<a name="ln671">  // In case it has, we'll use that thumbnail to show on the dialog</a>
<a name="ln672">  if(!have_preview &amp;&amp; !no_preview_fallback)</a>
<a name="ln673">  {</a>
<a name="ln674">    uint8_t *buffer = NULL;</a>
<a name="ln675">    size_t size;</a>
<a name="ln676">    char *mime_type = NULL;</a>
<a name="ln677">    if(!dt_exif_get_thumbnail(filename, &amp;buffer, &amp;size, &amp;mime_type))</a>
<a name="ln678">    {</a>
<a name="ln679">      // Scale the image to the correct size</a>
<a name="ln680">      GdkPixbuf *tmp;</a>
<a name="ln681">      GdkPixbufLoader *loader = gdk_pixbuf_loader_new();</a>
<a name="ln682">      if (!gdk_pixbuf_loader_write(loader, buffer, size, NULL)) goto cleanup;</a>
<a name="ln683">      // Calling gdk_pixbuf_loader_close forces the data to be parsed by the</a>
<a name="ln684">      // loader. We must do this before calling gdk_pixbuf_loader_get_pixbuf.</a>
<a name="ln685">      if(!gdk_pixbuf_loader_close(loader, NULL)) goto cleanup;</a>
<a name="ln686">      if (!(tmp = gdk_pixbuf_loader_get_pixbuf(loader))) goto cleanup;</a>
<a name="ln687">      float ratio = 1.0 * gdk_pixbuf_get_height(tmp) / gdk_pixbuf_get_width(tmp);</a>
<a name="ln688">      int width = 128, height = 128 * ratio;</a>
<a name="ln689">      pixbuf = gdk_pixbuf_scale_simple(tmp, width, height, GDK_INTERP_BILINEAR);</a>
<a name="ln690"> </a>
<a name="ln691">      have_preview = TRUE;</a>
<a name="ln692"> </a>
<a name="ln693">    cleanup:</a>
<a name="ln694">      gdk_pixbuf_loader_close(loader, NULL);</a>
<a name="ln695">      free(mime_type);</a>
<a name="ln696">      free(buffer);</a>
<a name="ln697">      g_object_unref(loader); // This should clean up tmp as well</a>
<a name="ln698">    }</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701">  // Step 2: if we were not able to get a thumbnail at step 1,</a>
<a name="ln702">  // read the whole file to get a small size thumbnail</a>
<a name="ln703">  // this will not try to read DNG files at all</a>
<a name="ln704">  if(!have_preview &amp;&amp; !no_preview_fallback)</a>
<a name="ln705">  {</a>
<a name="ln706">    pixbuf = gdk_pixbuf_new_from_file_at_size(filename, 128, 128, NULL);</a>
<a name="ln707">    if(pixbuf != NULL) have_preview = TRUE;</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  // If we got a thumbnail (either embedded or reading the file directly)</a>
<a name="ln711">  // we need to find out the rotation as well</a>
<a name="ln712">  if(have_preview &amp;&amp; !no_preview_fallback)</a>
<a name="ln713">  {</a>
<a name="ln714"> </a>
<a name="ln715">    // get image orientation</a>
<a name="ln716">    dt_image_t img = { 0 };</a>
<a name="ln717">    (void)dt_exif_read(&amp;img, filename);</a>
<a name="ln718"> </a>
<a name="ln719">    // Rotate the image to the correct orientation</a>
<a name="ln720">    GdkPixbuf *tmp = pixbuf;</a>
<a name="ln721"> </a>
<a name="ln722">    if(img.orientation == ORIENTATION_ROTATE_CCW_90_DEG)</a>
<a name="ln723">    {</a>
<a name="ln724">      tmp = gdk_pixbuf_rotate_simple(pixbuf, GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE);</a>
<a name="ln725">    }</a>
<a name="ln726">    else if(img.orientation == ORIENTATION_ROTATE_CW_90_DEG)</a>
<a name="ln727">    {</a>
<a name="ln728">      tmp = gdk_pixbuf_rotate_simple(pixbuf, GDK_PIXBUF_ROTATE_CLOCKWISE);</a>
<a name="ln729">    }</a>
<a name="ln730">    else if(img.orientation == ORIENTATION_ROTATE_180_DEG)</a>
<a name="ln731">    {</a>
<a name="ln732">      tmp = gdk_pixbuf_rotate_simple(pixbuf, GDK_PIXBUF_ROTATE_UPSIDEDOWN);</a>
<a name="ln733">    }</a>
<a name="ln734"> </a>
<a name="ln735">    if(pixbuf != tmp)</a>
<a name="ln736">    {</a>
<a name="ln737">      g_object_unref(pixbuf);</a>
<a name="ln738">      pixbuf = tmp;</a>
<a name="ln739">    }</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">  // if no thumbanail found or read failed for whatever reason</a>
<a name="ln743">  // or in case of DNG files</a>
<a name="ln744">  // just display the default darktable logo</a>
<a name="ln745">  if(!have_preview || no_preview_fallback)</a>
<a name="ln746">  {</a>
<a name="ln747">    /* load the dt logo as a brackground */</a>
<a name="ln748">    cairo_surface_t *surface = dt_util_get_logo(128.0);</a>
<a name="ln749">    if(surface)</a>
<a name="ln750">    {</a>
<a name="ln751">      guint8 *image_buffer = cairo_image_surface_get_data(surface);</a>
<a name="ln752">      int image_width = cairo_image_surface_get_width(surface);</a>
<a name="ln753">      int image_height = cairo_image_surface_get_height(surface);</a>
<a name="ln754"> </a>
<a name="ln755">      pixbuf = gdk_pixbuf_get_from_surface(surface, 0, 0, image_width, image_height);</a>
<a name="ln756"> </a>
<a name="ln757">      cairo_surface_destroy(surface);</a>
<a name="ln758">      free(image_buffer);</a>
<a name="ln759"> </a>
<a name="ln760">      have_preview = TRUE;</a>
<a name="ln761">    }</a>
<a name="ln762">  }</a>
<a name="ln763">  if(have_preview) gtk_image_set_from_pixbuf(GTK_IMAGE(preview), pixbuf);</a>
<a name="ln764">  if(pixbuf) g_object_unref(pixbuf);</a>
<a name="ln765">  g_free(filename);</a>
<a name="ln766"> </a>
<a name="ln767">  gtk_file_chooser_set_preview_widget_active(file_chooser, have_preview);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">static void _lib_import_single_image_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln771">{</a>
<a name="ln772">  dt_lib_module_t* self = (dt_lib_module_t*)user_data;</a>
<a name="ln773">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln774">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln775">      _(&quot;import image&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_OPEN, _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln776">      _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln777">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln778">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln779">#endif</a>
<a name="ln780"> </a>
<a name="ln781">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), TRUE);</a>
<a name="ln782"> </a>
<a name="ln783">  char *last_directory = dt_conf_get_string(&quot;ui_last/import_last_directory&quot;);</a>
<a name="ln784">  if(last_directory != NULL)</a>
<a name="ln785">  {</a>
<a name="ln786">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_directory);</a>
<a name="ln787">    g_free(last_directory);</a>
<a name="ln788">  }</a>
<a name="ln789"> </a>
<a name="ln790">  GtkFileFilter *filter;</a>
<a name="ln791">  filter = GTK_FILE_FILTER(gtk_file_filter_new());</a>
<a name="ln792">  for(const char **i = dt_supported_extensions; *i != NULL; i++)</a>
<a name="ln793">  {</a>
<a name="ln794">    char *ext = g_strdup_printf(&quot;*.%s&quot;, *i);</a>
<a name="ln795">    char *ext_upper = g_ascii_strup(ext, -1);</a>
<a name="ln796">    gtk_file_filter_add_pattern(filter, ext);</a>
<a name="ln797">    gtk_file_filter_add_pattern(filter, ext_upper);</a>
<a name="ln798">    g_free(ext_upper);</a>
<a name="ln799">    g_free(ext);</a>
<a name="ln800">  }</a>
<a name="ln801">  gtk_file_filter_set_name(filter, _(&quot;supported images&quot;));</a>
<a name="ln802">  gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(filechooser), filter);</a>
<a name="ln803"> </a>
<a name="ln804">  filter = GTK_FILE_FILTER(gtk_file_filter_new());</a>
<a name="ln805">  gtk_file_filter_add_pattern(filter, &quot;*&quot;);</a>
<a name="ln806">  gtk_file_filter_set_name(filter, _(&quot;all files&quot;));</a>
<a name="ln807">  gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(filechooser), filter);</a>
<a name="ln808"> </a>
<a name="ln809">  GtkWidget *preview = gtk_image_new();</a>
<a name="ln810">  gtk_file_chooser_set_preview_widget(GTK_FILE_CHOOSER(filechooser), preview);</a>
<a name="ln811">  g_signal_connect(filechooser, &quot;update-preview&quot;, G_CALLBACK(_lib_import_update_preview), preview);</a>
<a name="ln812"> </a>
<a name="ln813">  dt_lib_import_metadata_t metadata;</a>
<a name="ln814">  gtk_file_chooser_set_extra_widget(GTK_FILE_CHOOSER(filechooser),</a>
<a name="ln815">                                    _lib_import_get_extra_widget(self, &amp;metadata, FALSE));</a>
<a name="ln816"> </a>
<a name="ln817">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln818">  {</a>
<a name="ln819">    gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln820">    dt_conf_set_string(&quot;ui_last/import_last_directory&quot;, folder);</a>
<a name="ln821">    g_free(folder);</a>
<a name="ln822"> </a>
<a name="ln823">    _lib_import_evaluate_extra_widget(&amp;metadata, FALSE);</a>
<a name="ln824"> </a>
<a name="ln825">    char *filename = NULL;</a>
<a name="ln826">    dt_film_t film;</a>
<a name="ln827">    GSList *list = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln828">    GSList *it = list;</a>
<a name="ln829">    int id = 0;</a>
<a name="ln830">    int filmid = 0;</a>
<a name="ln831"> </a>
<a name="ln832">    /* reset filter so that view isn't empty */</a>
<a name="ln833">    dt_view_filter_reset(darktable.view_manager, TRUE);</a>
<a name="ln834"> </a>
<a name="ln835">    while(it)</a>
<a name="ln836">    {</a>
<a name="ln837">      filename = (char *)it-&gt;data;</a>
<a name="ln838">      gchar *directory = g_path_get_dirname((const gchar *)filename);</a>
<a name="ln839">      filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln840">      id = dt_image_import(filmid, filename, TRUE);</a>
<a name="ln841">      if(!id) dt_control_log(_(&quot;error loading file `%s'&quot;), filename);</a>
<a name="ln842">      g_free(filename);</a>
<a name="ln843">      g_free(directory);</a>
<a name="ln844">      it = g_slist_next(it);</a>
<a name="ln845">    }</a>
<a name="ln846"> </a>
<a name="ln847">    if(id)</a>
<a name="ln848">    {</a>
<a name="ln849">      dt_film_open(filmid);</a>
<a name="ln850">      // make sure buffers are loaded (load full for testing)</a>
<a name="ln851">      dt_mipmap_buffer_t buf;</a>
<a name="ln852">      dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, id, DT_MIPMAP_FULL, DT_MIPMAP_BLOCKING, 'r');</a>
<a name="ln853">      gboolean loaded = (buf.buf != NULL);</a>
<a name="ln854">      dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln855">      if(!loaded)</a>
<a name="ln856">      {</a>
<a name="ln857">        dt_control_log(_(&quot;file has unknown format!&quot;));</a>
<a name="ln858">      }</a>
<a name="ln859">      else</a>
<a name="ln860">      {</a>
<a name="ln861">        dt_control_set_mouse_over_id(id);</a>
<a name="ln862">        dt_ctl_switch_mode_to(&quot;darkroom&quot;);</a>
<a name="ln863">      }</a>
<a name="ln864">    }</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">#ifdef USE_LUA</a>
<a name="ln868">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln869">  detach_lua_widgets(d-&gt;extra_lua_widgets);</a>
<a name="ln870">#endif</a>
<a name="ln871"> </a>
<a name="ln872">  gtk_widget_destroy(metadata.frame);</a>
<a name="ln873">  gtk_widget_destroy(filechooser);</a>
<a name="ln874">  gtk_widget_queue_draw(dt_ui_center(darktable.gui-&gt;ui));</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">static void _lib_import_folder_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln878">{</a>
<a name="ln879">  dt_lib_module_t* self= (dt_lib_module_t*) user_data;</a>
<a name="ln880">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln881">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln882">      _(&quot;import film&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln883">      GTK_RESPONSE_CANCEL, _(&quot;_open&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln884">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln885">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln886">#endif</a>
<a name="ln887"> </a>
<a name="ln888">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), TRUE);</a>
<a name="ln889"> </a>
<a name="ln890">  char *last_directory = dt_conf_get_string(&quot;ui_last/import_last_directory&quot;);</a>
<a name="ln891">  if(last_directory != NULL)</a>
<a name="ln892">  {</a>
<a name="ln893">    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_directory);</a>
<a name="ln894">    g_free(last_directory);</a>
<a name="ln895">  }</a>
<a name="ln896"> </a>
<a name="ln897">  dt_lib_import_metadata_t metadata;</a>
<a name="ln898">  gtk_file_chooser_set_extra_widget(GTK_FILE_CHOOSER(filechooser),</a>
<a name="ln899">                                    _lib_import_get_extra_widget(self, &amp;metadata, TRUE));</a>
<a name="ln900"> </a>
<a name="ln901">  // run the dialog</a>
<a name="ln902">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln903">  {</a>
<a name="ln904">    gchar *folder = gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln905">    dt_conf_set_string(&quot;ui_last/import_last_directory&quot;, folder);</a>
<a name="ln906">    g_free(folder);</a>
<a name="ln907"> </a>
<a name="ln908">    _lib_import_evaluate_extra_widget(&amp;metadata, TRUE);</a>
<a name="ln909"> </a>
<a name="ln910">    char *filename = NULL, *first_filename = NULL;</a>
<a name="ln911">    GSList *list = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln912">    GSList *it = list;</a>
<a name="ln913"> </a>
<a name="ln914">    /* reset filter so that view isn't empty */</a>
<a name="ln915">    dt_view_filter_reset(darktable.view_manager, TRUE);</a>
<a name="ln916"> </a>
<a name="ln917">    /* for each selected folder add import job */</a>
<a name="ln918">    while(it)</a>
<a name="ln919">    {</a>
<a name="ln920">      filename = (char *)it-&gt;data;</a>
<a name="ln921">      dt_film_import(filename);</a>
<a name="ln922">      if(!first_filename)</a>
<a name="ln923">      {</a>
<a name="ln924">        first_filename = g_strdup(filename);</a>
<a name="ln925">        if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(metadata.recursive)))</a>
<a name="ln926">          first_filename = dt_util_dstrcat(first_filename, &quot;%%&quot;);</a>
<a name="ln927">      }</a>
<a name="ln928">      g_free(filename);</a>
<a name="ln929">      it = g_slist_next(it);</a>
<a name="ln930">    }</a>
<a name="ln931"> </a>
<a name="ln932">    /* update collection to view import */</a>
<a name="ln933">    if(first_filename)</a>
<a name="ln934">    {</a>
<a name="ln935">      dt_conf_set_int(&quot;plugins/lighttable/collect/num_rules&quot;, 1);</a>
<a name="ln936">      dt_conf_set_int(&quot;plugins/lighttable/collect/item0&quot;, 0);</a>
<a name="ln937">      dt_conf_set_string(&quot;plugins/lighttable/collect/string0&quot;, first_filename);</a>
<a name="ln938">      dt_collection_update_query(darktable.collection);</a>
<a name="ln939">      g_free(first_filename);</a>
<a name="ln940">    }</a>
<a name="ln941"> </a>
<a name="ln942"> </a>
<a name="ln943">    g_slist_free(list);</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946">#ifdef USE_LUA</a>
<a name="ln947">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln948">  detach_lua_widgets(d-&gt;extra_lua_widgets);</a>
<a name="ln949">#endif</a>
<a name="ln950"> </a>
<a name="ln951">  gtk_widget_destroy(metadata.frame);</a>
<a name="ln952">  gtk_widget_destroy(filechooser);</a>
<a name="ln953">  gtk_widget_queue_draw(dt_ui_center(darktable.gui-&gt;ui));</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">#ifdef HAVE_GPHOTO2</a>
<a name="ln957">static void _camera_detected(gpointer instance, gpointer self)</a>
<a name="ln958">{</a>
<a name="ln959">  /* update gui with detected devices */</a>
<a name="ln960">  _lib_import_ui_devices_update(self);</a>
<a name="ln961">}</a>
<a name="ln962">#endif</a>
<a name="ln963">#ifdef USE_LUA</a>
<a name="ln964">static int lua_register_widget(lua_State *L)</a>
<a name="ln965">{</a>
<a name="ln966">  dt_lib_module_t *self = lua_touserdata(L, lua_upvalueindex(1));</a>
<a name="ln967">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln968">  lua_widget widget;</a>
<a name="ln969">  luaA_to(L,lua_widget,&amp;widget,1);</a>
<a name="ln970">  dt_lua_widget_bind(L,widget);</a>
<a name="ln971">  gtk_box_pack_start(GTK_BOX(d-&gt;extra_lua_widgets),widget-&gt;widget, TRUE, TRUE, 0);</a>
<a name="ln972">  return 0;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">void init(dt_lib_module_t *self)</a>
<a name="ln977">{</a>
<a name="ln978">  lua_State *L = darktable.lua_state.state;</a>
<a name="ln979">  int my_type = dt_lua_module_entry_get_type(L, &quot;lib&quot;, self-&gt;plugin_name);</a>
<a name="ln980">  lua_pushlightuserdata(L,self);</a>
<a name="ln981">  lua_pushcclosure(L, lua_register_widget,1);</a>
<a name="ln982">  dt_lua_gtk_wrap(L);</a>
<a name="ln983">  lua_pushcclosure(L, dt_lua_type_member_common, 1);</a>
<a name="ln984">  dt_lua_type_register_const_type(L, my_type, &quot;register_widget&quot;);</a>
<a name="ln985">}</a>
<a name="ln986">#endif</a>
<a name="ln987"> </a>
<a name="ln988">void gui_init(dt_lib_module_t *self)</a>
<a name="ln989">{</a>
<a name="ln990">  /* initialize ui widgets */</a>
<a name="ln991">  dt_lib_import_t *d = (dt_lib_import_t *)g_malloc0(sizeof(dt_lib_import_t));</a>
<a name="ln992">  self-&gt;data = (void *)d;</a>
<a name="ln993">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln994">  dt_gui_add_help_link(self-&gt;widget, &quot;lighttable_panels.html#import&quot;);</a>
<a name="ln995"> </a>
<a name="ln996">  /* add import single image buttons */</a>
<a name="ln997">  GtkWidget *widget = gtk_button_new_with_label(_(&quot;image&quot;));</a>
<a name="ln998">  dt_gui_add_help_link(widget, &quot;lighttable_panels.html#import_from_fs&quot;);</a>
<a name="ln999">  d-&gt;import_file = GTK_BUTTON(widget);</a>
<a name="ln1000">  gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(widget)), GTK_ALIGN_START);</a>
<a name="ln1001">  gtk_widget_set_tooltip_text(widget, _(&quot;select one or more images to import&quot;));</a>
<a name="ln1002">  gtk_widget_set_can_focus(widget, TRUE);</a>
<a name="ln1003">  gtk_widget_set_receives_default(widget, TRUE);</a>
<a name="ln1004">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), widget, TRUE, TRUE, 0);</a>
<a name="ln1005">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_lib_import_single_image_callback), self);</a>
<a name="ln1006"> </a>
<a name="ln1007">  /* adding the import folder button */</a>
<a name="ln1008">  widget = gtk_button_new_with_label(_(&quot;folder&quot;));</a>
<a name="ln1009">  dt_gui_add_help_link(widget, &quot;lighttable_panels.html#import_from_fs&quot;);</a>
<a name="ln1010">  d-&gt;import_directory = GTK_BUTTON(widget);</a>
<a name="ln1011">  gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(widget)), GTK_ALIGN_START);</a>
<a name="ln1012">  gtk_widget_set_tooltip_text(widget, _(&quot;select a folder to import as film roll&quot;));</a>
<a name="ln1013">  gtk_widget_set_can_focus(widget, TRUE);</a>
<a name="ln1014">  gtk_widget_set_receives_default(widget, TRUE);</a>
<a name="ln1015">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), widget, TRUE, TRUE, 0);</a>
<a name="ln1016">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_lib_import_folder_callback), self);</a>
<a name="ln1017"> </a>
<a name="ln1018">#ifdef HAVE_GPHOTO2</a>
<a name="ln1019">  /* add the rescan button */</a>
<a name="ln1020">  GtkButton *scan = GTK_BUTTON(gtk_button_new_with_label(_(&quot;scan for devices&quot;)));</a>
<a name="ln1021">  dt_gui_add_help_link(GTK_WIDGET(scan), &quot;lighttable_panels.html#import_from_camera&quot;);</a>
<a name="ln1022">  d-&gt;scan_devices = scan;</a>
<a name="ln1023">  gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(scan)), GTK_ALIGN_START);</a>
<a name="ln1024">  gtk_widget_set_tooltip_text(GTK_WIDGET(scan), _(&quot;scan for newly attached devices&quot;));</a>
<a name="ln1025">  g_signal_connect(G_OBJECT(scan), &quot;clicked&quot;, G_CALLBACK(_lib_import_scan_devices_callback), self);</a>
<a name="ln1026">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(scan), TRUE, TRUE, 0);</a>
<a name="ln1027"> </a>
<a name="ln1028">  /* add devices container for cameras */</a>
<a name="ln1029">  d-&gt;devices = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 5));</a>
<a name="ln1030">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(d-&gt;devices), FALSE, FALSE, 0);</a>
<a name="ln1031"> </a>
<a name="ln1032">  _lib_import_ui_devices_update(self);</a>
<a name="ln1033"> </a>
<a name="ln1034">  /* initialize camctl listener and update devices */</a>
<a name="ln1035">  d-&gt;camctl_listener.data = self;</a>
<a name="ln1036">  d-&gt;camctl_listener.control_status = _camctl_camera_control_status_callback;</a>
<a name="ln1037">  d-&gt;camctl_listener.camera_disconnected = _camctl_camera_disconnected_callback;</a>
<a name="ln1038">  dt_camctl_register_listener(darktable.camctl, &amp;d-&gt;camctl_listener);</a>
<a name="ln1039">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_CAMERA_DETECTED, G_CALLBACK(_camera_detected),</a>
<a name="ln1040">                            self);</a>
<a name="ln1041">#endif</a>
<a name="ln1042">#ifdef USE_LUA</a>
<a name="ln1043">  /* initialize the lua area  and make sure it survives its parent's destruction*/</a>
<a name="ln1044">  d-&gt;extra_lua_widgets = gtk_box_new(GTK_ORIENTATION_VERTICAL,5);</a>
<a name="ln1045">  g_object_ref_sink(d-&gt;extra_lua_widgets);</a>
<a name="ln1046">#endif</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln1050">{</a>
<a name="ln1051">#ifdef HAVE_GPHOTO2</a>
<a name="ln1052">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_camera_detected), self);</a>
<a name="ln1053">  dt_lib_import_t *d = (dt_lib_import_t *)self-&gt;data;</a>
<a name="ln1054">  /* unregister camctl listener */</a>
<a name="ln1055">  dt_camctl_unregister_listener(darktable.camctl, &amp;d-&gt;camctl_listener);</a>
<a name="ln1056">#endif</a>
<a name="ln1057"> </a>
<a name="ln1058">  /* cleanup mem */</a>
<a name="ln1059">  g_free(self-&gt;data);</a>
<a name="ln1060">  self-&gt;data = NULL;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1064">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1065">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="672"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !have_preview.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
