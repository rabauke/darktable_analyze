
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011--2012 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">/** this is the view for the darkroom module.  */</a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/collection.h&quot;</a>
<a name="ln22">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln23">#include &quot;common/darktable.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/image_cache.h&quot;</a>
<a name="ln26">#include &quot;common/imageio.h&quot;</a>
<a name="ln27">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln28">#include &quot;common/styles.h&quot;</a>
<a name="ln29">#include &quot;common/tags.h&quot;</a>
<a name="ln30">#include &quot;common/undo.h&quot;</a>
<a name="ln31">#include &quot;control/conf.h&quot;</a>
<a name="ln32">#include &quot;control/control.h&quot;</a>
<a name="ln33">#include &quot;control/jobs.h&quot;</a>
<a name="ln34">#include &quot;develop/blend.h&quot;</a>
<a name="ln35">#include &quot;develop/develop.h&quot;</a>
<a name="ln36">#include &quot;develop/imageop.h&quot;</a>
<a name="ln37">#include &quot;develop/masks.h&quot;</a>
<a name="ln38">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln39">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln40">#include &quot;gui/gtk.h&quot;</a>
<a name="ln41">#include &quot;gui/presets.h&quot;</a>
<a name="ln42">#include &quot;libs/colorpicker.h&quot;</a>
<a name="ln43">#include &quot;views/view.h&quot;</a>
<a name="ln44">#include &quot;views/view_api.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln47">#include &lt;math.h&gt;</a>
<a name="ln48">#include &lt;stdlib.h&gt;</a>
<a name="ln49">#include &lt;string.h&gt;</a>
<a name="ln50">#include &lt;unistd.h&gt;</a>
<a name="ln51">#include &lt;sys/types.h&gt;</a>
<a name="ln52">#include &lt;sys/stat.h&gt;</a>
<a name="ln53">#include &lt;fcntl.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">DT_MODULE(1)</a>
<a name="ln56"> </a>
<a name="ln57">static gboolean film_strip_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln58">                                     GdkModifierType modifier, gpointer data);</a>
<a name="ln59"> </a>
<a name="ln60">static gboolean zoom_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln61">                               GdkModifierType modifier, gpointer data);</a>
<a name="ln62"> </a>
<a name="ln63">static gboolean export_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln64">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln65"> </a>
<a name="ln66">static gboolean skip_f_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln67">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln68">static gboolean skip_b_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln69">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln70">static gboolean _toolbox_toggle_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln71">                                         GdkModifierType modifier, gpointer data);</a>
<a name="ln72">static gboolean _brush_size_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln73">                                        GdkModifierType modifier, gpointer data);</a>
<a name="ln74">static gboolean _brush_size_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln75">                                          GdkModifierType modifier, gpointer data);</a>
<a name="ln76">static gboolean _brush_hardness_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln77">                                            GdkModifierType modifier, gpointer data);</a>
<a name="ln78">static gboolean _brush_hardness_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln79">                                              GdkModifierType modifier, gpointer data);</a>
<a name="ln80">static gboolean _brush_opacity_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln81">                                           GdkModifierType modifier, gpointer data);</a>
<a name="ln82">static gboolean _brush_opacity_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln83">                                             GdkModifierType modifier, gpointer data);</a>
<a name="ln84"> </a>
<a name="ln85">static void _update_softproof_gamut_checking(dt_develop_t *d);</a>
<a name="ln86"> </a>
<a name="ln87">/* signal handler for filmstrip image switching */</a>
<a name="ln88">static void _view_darkroom_filmstrip_activate_callback(gpointer instance, gpointer user_data);</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">const char *name(dt_view_t *self)</a>
<a name="ln92">{</a>
<a name="ln93">  return _(&quot;darkroom&quot;);</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">void init(dt_view_t *self)</a>
<a name="ln98">{</a>
<a name="ln99">  self-&gt;data = malloc(sizeof(dt_develop_t));</a>
<a name="ln100">  dt_dev_init((dt_develop_t *)self-&gt;data, 1);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">uint32_t view(const dt_view_t *self)</a>
<a name="ln104">{</a>
<a name="ln105">  return DT_VIEW_DARKROOM;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">void cleanup(dt_view_t *self)</a>
<a name="ln109">{</a>
<a name="ln110">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln111">  dt_dev_cleanup(dev);</a>
<a name="ln112">  free(dev);</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">static cairo_status_t write_snapshot_data(void *closure, const unsigned char *data, unsigned int length)</a>
<a name="ln116">{</a>
<a name="ln117">  int fd = GPOINTER_TO_INT(closure);</a>
<a name="ln118">  ssize_t res = write(fd, data, length);</a>
<a name="ln119">  if(res != length)</a>
<a name="ln120">    return CAIRO_STATUS_WRITE_ERROR;</a>
<a name="ln121">  return CAIRO_STATUS_SUCCESS;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">void expose(</a>
<a name="ln125">    dt_view_t *self,</a>
<a name="ln126">    cairo_t *cri,</a>
<a name="ln127">    int32_t width,</a>
<a name="ln128">    int32_t height,</a>
<a name="ln129">    int32_t pointerx,</a>
<a name="ln130">    int32_t pointery)</a>
<a name="ln131">{</a>
<a name="ln132">  cairo_set_source_rgb(cri, .2, .2, .2);</a>
<a name="ln133">  cairo_save(cri);</a>
<a name="ln134"> </a>
<a name="ln135">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln136">  // account for border, make it transparent for other modules called below:</a>
<a name="ln137">  pointerx -= tb;</a>
<a name="ln138">  pointery -= tb;</a>
<a name="ln139"> </a>
<a name="ln140">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln141"> </a>
<a name="ln142">  if(dev-&gt;gui_synch &amp;&amp; !dev-&gt;image_loading)</a>
<a name="ln143">  {</a>
<a name="ln144">    // synch module guis from gtk thread:</a>
<a name="ln145">    darktable.gui-&gt;reset = 1;</a>
<a name="ln146">    GList *modules = dev-&gt;iop;</a>
<a name="ln147">    while(modules)</a>
<a name="ln148">    {</a>
<a name="ln149">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln150">      dt_iop_gui_update(module);</a>
<a name="ln151">      modules = g_list_next(modules);</a>
<a name="ln152">    }</a>
<a name="ln153">    darktable.gui-&gt;reset = 0;</a>
<a name="ln154">    dev-&gt;gui_synch = 0;</a>
<a name="ln155">  }</a>
<a name="ln156"> </a>
<a name="ln157">  if(dev-&gt;image_status == DT_DEV_PIXELPIPE_DIRTY || dev-&gt;image_status == DT_DEV_PIXELPIPE_INVALID</a>
<a name="ln158">     || dev-&gt;pipe-&gt;input_timestamp &lt; dev-&gt;preview_pipe-&gt;input_timestamp)</a>
<a name="ln159">    dt_dev_process_image(dev);</a>
<a name="ln160">  if(dev-&gt;preview_status == DT_DEV_PIXELPIPE_DIRTY || dev-&gt;preview_status == DT_DEV_PIXELPIPE_INVALID</a>
<a name="ln161">     || dev-&gt;pipe-&gt;input_timestamp &gt; dev-&gt;preview_pipe-&gt;input_timestamp)</a>
<a name="ln162">    dt_dev_process_preview(dev);</a>
<a name="ln163"> </a>
<a name="ln164">  dt_pthread_mutex_t *mutex = NULL;</a>
<a name="ln165">  int stride;</a>
<a name="ln166">  const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln167">  const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln168">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln169">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln170">  static cairo_surface_t *image_surface = NULL;</a>
<a name="ln171">  static int image_surface_width = 0, image_surface_height = 0, image_surface_imgid = -1;</a>
<a name="ln172">  static float roi_hash_old = -1.0f;</a>
<a name="ln173">  // compute patented dreggn hash so we don't need to check all values:</a>
<a name="ln174">  const float roi_hash = width + 7.0f * height + 23.0f * zoom + 42.0f * zoom_x + 91.0f * zoom_y</a>
<a name="ln175">                         + 666.0f * zoom;</a>
<a name="ln176"> </a>
<a name="ln177">  if(image_surface_width != width || image_surface_height != height || image_surface == NULL)</a>
<a name="ln178">  {</a>
<a name="ln179">    // create double-buffered image to draw on, to make modules draw more fluently.</a>
<a name="ln180">    image_surface_width = width;</a>
<a name="ln181">    image_surface_height = height;</a>
<a name="ln182">    if(image_surface) cairo_surface_destroy(image_surface);</a>
<a name="ln183">    image_surface = dt_cairo_image_surface_create(CAIRO_FORMAT_RGB24, width, height);</a>
<a name="ln184">    image_surface_imgid = -1; // invalidate old stuff</a>
<a name="ln185">  }</a>
<a name="ln186">  cairo_surface_t *surface;</a>
<a name="ln187">  cairo_t *cr = cairo_create(image_surface);</a>
<a name="ln188"> </a>
<a name="ln189">  // adjust scroll bars</a>
<a name="ln190">  {</a>
<a name="ln191">    float zx = zoom_x, zy = zoom_y, boxw = 1., boxh = 1.;</a>
<a name="ln192">    dt_dev_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, &amp;boxw, &amp;boxh);</a>
<a name="ln193">    dt_view_set_scrollbar(self, zx, -0.5 + boxw/2, 0.5, boxw/2, zy, -0.5+ boxh/2, 0.5, boxh/2);</a>
<a name="ln194">  }</a>
<a name="ln195"> </a>
<a name="ln196">  if((dev-&gt;image_status == DT_DEV_PIXELPIPE_VALID)</a>
<a name="ln197">     &amp;&amp; dev-&gt;pipe-&gt;input_timestamp &gt;= dev-&gt;preview_pipe-&gt;input_timestamp)</a>
<a name="ln198">  {</a>
<a name="ln199">    // draw image</a>
<a name="ln200">    roi_hash_old = roi_hash;</a>
<a name="ln201">    mutex = &amp;dev-&gt;pipe-&gt;backbuf_mutex;</a>
<a name="ln202">    dt_pthread_mutex_lock(mutex);</a>
<a name="ln203">    float wd = dev-&gt;pipe-&gt;backbuf_width;</a>
<a name="ln204">    float ht = dev-&gt;pipe-&gt;backbuf_height;</a>
<a name="ln205">    stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln206">    surface = dt_cairo_image_surface_create_for_data(dev-&gt;pipe-&gt;backbuf, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln207">    wd /= darktable.gui-&gt;ppd;</a>
<a name="ln208">    ht /= darktable.gui-&gt;ppd;</a>
<a name="ln209">    if(dev-&gt;full_preview)</a>
<a name="ln210">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_PREVIEW_BG);</a>
<a name="ln211">    else</a>
<a name="ln212">      dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_BG);</a>
<a name="ln213">    cairo_paint(cr);</a>
<a name="ln214">    cairo_translate(cr, .5f * (width - wd), .5f * (height - ht));</a>
<a name="ln215">    if(closeup)</a>
<a name="ln216">    {</a>
<a name="ln217">      const double scale = 1&lt;&lt;closeup;</a>
<a name="ln218">      cairo_scale(cr, scale, scale);</a>
<a name="ln219">      cairo_translate(cr, -(.5 - 0.5/scale) * wd, -(.5 - 0.5/scale) * ht);</a>
<a name="ln220">    }</a>
<a name="ln221">    cairo_rectangle(cr, 0, 0, wd, ht);</a>
<a name="ln222">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln223">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln224">    cairo_fill_preserve(cr);</a>
<a name="ln225">    cairo_set_line_width(cr, 1.0);</a>
<a name="ln226">    cairo_set_source_rgb(cr, .3, .3, .3);</a>
<a name="ln227">    cairo_stroke(cr);</a>
<a name="ln228">    cairo_surface_destroy(surface);</a>
<a name="ln229">    dt_pthread_mutex_unlock(mutex);</a>
<a name="ln230">    image_surface_imgid = dev-&gt;image_storage.id;</a>
<a name="ln231">  }</a>
<a name="ln232">  else if((dev-&gt;preview_status == DT_DEV_PIXELPIPE_VALID) &amp;&amp; (roi_hash != roi_hash_old))</a>
<a name="ln233">  {</a>
<a name="ln234">    // draw preview</a>
<a name="ln235">    roi_hash_old = roi_hash;</a>
<a name="ln236">    mutex = &amp;dev-&gt;preview_pipe-&gt;backbuf_mutex;</a>
<a name="ln237">    dt_pthread_mutex_lock(mutex);</a>
<a name="ln238"> </a>
<a name="ln239">    const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln240">    const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln241">    const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln242">    dt_gui_gtk_set_source_rgb(cr, DT_GUI_COLOR_DARKROOM_BG);</a>
<a name="ln243">    cairo_paint(cr);</a>
<a name="ln244">    cairo_rectangle(cr, tb, tb, width-2*tb, height-2*tb);</a>
<a name="ln245">    cairo_clip(cr);</a>
<a name="ln246">    stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, wd);</a>
<a name="ln247">    surface</a>
<a name="ln248">        = cairo_image_surface_create_for_data(dev-&gt;preview_pipe-&gt;backbuf, CAIRO_FORMAT_RGB24, wd, ht, stride);</a>
<a name="ln249">    cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln250">    cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln251">    cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln252">    // avoid to draw the 1px garbage that sometimes shows up in the preview :(</a>
<a name="ln253">    cairo_rectangle(cr, 0, 0, wd - 1, ht - 1);</a>
<a name="ln254">    cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln255">    cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_FAST);</a>
<a name="ln256">    cairo_fill(cr);</a>
<a name="ln257">    cairo_surface_destroy(surface);</a>
<a name="ln258">    dt_pthread_mutex_unlock(mutex);</a>
<a name="ln259">    image_surface_imgid = dev-&gt;image_storage.id;</a>
<a name="ln260">  }</a>
<a name="ln261">  cairo_restore(cri);</a>
<a name="ln262"> </a>
<a name="ln263">  if(image_surface_imgid == dev-&gt;image_storage.id)</a>
<a name="ln264">  {</a>
<a name="ln265">    cairo_destroy(cr);</a>
<a name="ln266">    cairo_set_source_surface(cri, image_surface, 0, 0);</a>
<a name="ln267">    cairo_paint(cri);</a>
<a name="ln268">  }</a>
<a name="ln269"> </a>
<a name="ln270">  /* if we are in full preview mode, we don&quot;t want anything else than the image */</a>
<a name="ln271">  if(dev-&gt;full_preview) return;</a>
<a name="ln272"> </a>
<a name="ln273">  /* check if we should create a snapshot of view */</a>
<a name="ln274">  if(darktable.develop-&gt;proxy.snapshot.request &amp;&amp; !darktable.develop-&gt;image_loading)</a>
<a name="ln275">  {</a>
<a name="ln276">    /* reset the request */</a>
<a name="ln277">    darktable.develop-&gt;proxy.snapshot.request = FALSE;</a>
<a name="ln278"> </a>
<a name="ln279">    /* validation of snapshot filename */</a>
<a name="ln280">    g_assert(darktable.develop-&gt;proxy.snapshot.filename != NULL);</a>
<a name="ln281"> </a>
<a name="ln282">    /* Store current image surface to snapshot file.</a>
<a name="ln283">       FIXME: add checks so that we dont make snapshots of preview pipe image surface.</a>
<a name="ln284">    */</a>
<a name="ln285">    int fd = g_open(darktable.develop-&gt;proxy.snapshot.filename, O_CREAT | O_WRONLY, 0600);</a>
<a name="ln286">    cairo_surface_write_to_png_stream(image_surface, write_snapshot_data, GINT_TO_POINTER(fd));</a>
<a name="ln287">    close(fd);</a>
<a name="ln288">  }</a>
<a name="ln289"> </a>
<a name="ln290">  // Displaying sample areas if enabled</a>
<a name="ln291">  if(darktable.lib-&gt;proxy.colorpicker.live_samples &amp;&amp; darktable.lib-&gt;proxy.colorpicker.display_samples)</a>
<a name="ln292">  {</a>
<a name="ln293">    GSList *samples = darktable.lib-&gt;proxy.colorpicker.live_samples;</a>
<a name="ln294">    dt_colorpicker_sample_t *sample = NULL;</a>
<a name="ln295"> </a>
<a name="ln296">    cairo_save(cri);</a>
<a name="ln297"> </a>
<a name="ln298">    const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln299">    const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln300">    const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln301"> </a>
<a name="ln302">    cairo_translate(cri, width / 2.0, height / 2.0f);</a>
<a name="ln303">    cairo_scale(cri, zoom_scale, zoom_scale);</a>
<a name="ln304">    cairo_translate(cri, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln305"> </a>
<a name="ln306">    while(samples)</a>
<a name="ln307">    {</a>
<a name="ln308">      sample = samples-&gt;data;</a>
<a name="ln309"> </a>
<a name="ln310">      cairo_set_line_width(cri, 1.0 / zoom_scale);</a>
<a name="ln311">      if(sample == darktable.lib-&gt;proxy.colorpicker.selected_sample)</a>
<a name="ln312">        cairo_set_source_rgb(cri, .2, 0, 0);</a>
<a name="ln313">      else</a>
<a name="ln314">        cairo_set_source_rgb(cri, 0, 0, .2);</a>
<a name="ln315"> </a>
<a name="ln316">      const float *box = sample-&gt;box;</a>
<a name="ln317">      const float *point = sample-&gt;point;</a>
<a name="ln318">      if(sample-&gt;size == DT_COLORPICKER_SIZE_BOX)</a>
<a name="ln319">      {</a>
<a name="ln320">        cairo_rectangle(cri, box[0] * wd, box[1] * ht, (box[2] - box[0]) * wd, (box[3] - box[1]) * ht);</a>
<a name="ln321">        cairo_stroke(cri);</a>
<a name="ln322">        cairo_translate(cri, 1.0 / zoom_scale, 1.0 / zoom_scale);</a>
<a name="ln323">        if(sample == darktable.lib-&gt;proxy.colorpicker.selected_sample)</a>
<a name="ln324">          cairo_set_source_rgb(cri, .8, 0, 0);</a>
<a name="ln325">        else</a>
<a name="ln326">          cairo_set_source_rgb(cri, 0, 0, .8);</a>
<a name="ln327">        cairo_rectangle(cri, box[0] * wd + 1.0 / zoom_scale, box[1] * ht,</a>
<a name="ln328">                        (box[2] - box[0]) * wd - 3. / zoom_scale, (box[3] - box[1]) * ht - 2. / zoom_scale);</a>
<a name="ln329">        cairo_stroke(cri);</a>
<a name="ln330">      }</a>
<a name="ln331">      else</a>
<a name="ln332">      {</a>
<a name="ln333">        cairo_rectangle(cri, point[0] * wd - .01 * wd, point[1] * ht - .01 * wd, .02 * wd, .02 * wd);</a>
<a name="ln334">        cairo_stroke(cri);</a>
<a name="ln335"> </a>
<a name="ln336">        if(sample == darktable.lib-&gt;proxy.colorpicker.selected_sample)</a>
<a name="ln337">          cairo_set_source_rgb(cri, .8, 0, 0);</a>
<a name="ln338">        else</a>
<a name="ln339">          cairo_set_source_rgb(cri, 0, 0, .8);</a>
<a name="ln340">        cairo_rectangle(cri, (point[0] - 0.01) * wd + 1.0 / zoom_scale,</a>
<a name="ln341">                        point[1] * ht - 0.01 * wd + 1.0 / zoom_scale, .02 * wd - 2. / zoom_scale,</a>
<a name="ln342">                        .02 * wd - 2. / zoom_scale);</a>
<a name="ln343">        cairo_move_to(cri, point[0] * wd, point[1] * ht - .01 * wd + 1. / zoom_scale);</a>
<a name="ln344">        cairo_line_to(cri, point[0] * wd, point[1] * ht + .01 * wd - 1. / zoom_scale);</a>
<a name="ln345">        cairo_move_to(cri, point[0] * wd - .01 * wd + 1. / zoom_scale, point[1] * ht);</a>
<a name="ln346">        cairo_line_to(cri, point[0] * wd + .01 * wd - 1. / zoom_scale, point[1] * ht);</a>
<a name="ln347">        cairo_stroke(cri);</a>
<a name="ln348">      }</a>
<a name="ln349"> </a>
<a name="ln350">      samples = g_slist_next(samples);</a>
<a name="ln351">    }</a>
<a name="ln352"> </a>
<a name="ln353">    cairo_restore(cri);</a>
<a name="ln354">  }</a>
<a name="ln355"> </a>
<a name="ln356">  // execute module callback hook.</a>
<a name="ln357">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF)</a>
<a name="ln358">  {</a>
<a name="ln359">    const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln360">    const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln361">    const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln362"> </a>
<a name="ln363">    cairo_translate(cri, width / 2.0, height / 2.0f);</a>
<a name="ln364">    cairo_scale(cri, zoom_scale, zoom_scale);</a>
<a name="ln365">    cairo_translate(cri, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln366"> </a>
<a name="ln367">    // cairo_set_operator(cri, CAIRO_OPERATOR_XOR);</a>
<a name="ln368">    cairo_set_line_width(cri, 1.0 / zoom_scale);</a>
<a name="ln369">    cairo_set_source_rgb(cri, .2, .2, .2);</a>
<a name="ln370"> </a>
<a name="ln371">    const float *box = dev-&gt;gui_module-&gt;color_picker_box;</a>
<a name="ln372">    const float *point = dev-&gt;gui_module-&gt;color_picker_point;</a>
<a name="ln373">    if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln374">    {</a>
<a name="ln375">      cairo_rectangle(cri, box[0] * wd, box[1] * ht, (box[2] - box[0]) * wd, (box[3] - box[1]) * ht);</a>
<a name="ln376">      cairo_stroke(cri);</a>
<a name="ln377">      cairo_translate(cri, 1.0 / zoom_scale, 1.0 / zoom_scale);</a>
<a name="ln378">      cairo_set_source_rgb(cri, .8, .8, .8);</a>
<a name="ln379">      cairo_rectangle(cri, box[0] * wd + 1.0 / zoom_scale, box[1] * ht,</a>
<a name="ln380">                      (box[2] - box[0]) * wd - 3. / zoom_scale, (box[3] - box[1]) * ht - 2. / zoom_scale);</a>
<a name="ln381">      cairo_stroke(cri);</a>
<a name="ln382">    }</a>
<a name="ln383">    else if(point[0] &gt;= 0.0f &amp;&amp; point[0] &lt;= 1.0f &amp;&amp; point[1] &gt;= 0.0f &amp;&amp; point[1] &lt;= 1.0f)</a>
<a name="ln384">    {</a>
<a name="ln385">      cairo_rectangle(cri, point[0] * wd - .01 * wd, point[1] * ht - .01 * wd, .02 * wd, .02 * wd);</a>
<a name="ln386">      cairo_stroke(cri);</a>
<a name="ln387"> </a>
<a name="ln388">      cairo_set_source_rgb(cri, .8, .8, .8);</a>
<a name="ln389">      cairo_rectangle(cri, (point[0] - 0.01) * wd + 1.0 / zoom_scale,</a>
<a name="ln390">                      point[1] * ht - 0.01 * wd + 1.0 / zoom_scale, .02 * wd - 2. / zoom_scale,</a>
<a name="ln391">                      .02 * wd - 2. / zoom_scale);</a>
<a name="ln392">      cairo_move_to(cri, point[0] * wd, point[1] * ht - .01 * wd + 1. / zoom_scale);</a>
<a name="ln393">      cairo_line_to(cri, point[0] * wd, point[1] * ht + .01 * wd - 1. / zoom_scale);</a>
<a name="ln394">      cairo_move_to(cri, point[0] * wd - .01 * wd + 1. / zoom_scale, point[1] * ht);</a>
<a name="ln395">      cairo_line_to(cri, point[0] * wd + .01 * wd - 1. / zoom_scale, point[1] * ht);</a>
<a name="ln396">      cairo_stroke(cri);</a>
<a name="ln397">    }</a>
<a name="ln398">  }</a>
<a name="ln399">  else</a>
<a name="ln400">  {</a>
<a name="ln401">    // masks</a>
<a name="ln402">    if(dev-&gt;form_visible)</a>
<a name="ln403">      dt_masks_events_post_expose(dev-&gt;gui_module, cri, width, height, pointerx, pointery);</a>
<a name="ln404">    // module</a>
<a name="ln405">    if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;gui_post_expose)</a>
<a name="ln406">      dev-&gt;gui_module-&gt;gui_post_expose(dev-&gt;gui_module, cri, width, height, pointerx, pointery);</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  // indicate if we are in gamut check or softproof mode</a>
<a name="ln410">  if(darktable.color_profiles-&gt;mode != DT_PROFILE_NORMAL)</a>
<a name="ln411">  {</a>
<a name="ln412">    gchar *label = darktable.color_profiles-&gt;mode == DT_PROFILE_GAMUTCHECK ? _(&quot;gamut check&quot;) : _(&quot;soft proof&quot;);</a>
<a name="ln413">    cairo_set_source_rgba(cri, 0.5, 0.5, 0.5, 0.5);</a>
<a name="ln414">    PangoLayout *layout;</a>
<a name="ln415">    PangoRectangle ink;</a>
<a name="ln416">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln417">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln418">    layout = pango_cairo_create_layout(cri);</a>
<a name="ln419">    pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(20) * PANGO_SCALE);</a>
<a name="ln420">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln421">    pango_layout_set_text(layout, label, -1);</a>
<a name="ln422">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln423">    cairo_move_to(cri, ink.height * 2, height - (ink.height * 3));</a>
<a name="ln424">    pango_cairo_layout_path(cri, layout);</a>
<a name="ln425">    cairo_set_source_rgb(cri, 0.7, 0.7, 0.7);</a>
<a name="ln426">    cairo_fill_preserve(cri);</a>
<a name="ln427">    cairo_set_line_width(cri, 0.7);</a>
<a name="ln428">    cairo_set_source_rgb(cri, 0.3, 0.3, 0.3);</a>
<a name="ln429">    cairo_stroke(cri);</a>
<a name="ln430">    pango_font_description_free(desc);</a>
<a name="ln431">    g_object_unref(layout);</a>
<a name="ln432">  }</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">void reset(dt_view_t *self)</a>
<a name="ln436">{</a>
<a name="ln437">  dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln438">  dt_control_set_dev_zoom_x(0);</a>
<a name="ln439">  dt_control_set_dev_zoom_y(0);</a>
<a name="ln440">  dt_control_set_dev_closeup(0);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">int try_enter(dt_view_t *self)</a>
<a name="ln444">{</a>
<a name="ln445">  int selected = dt_control_get_mouse_over_id();</a>
<a name="ln446">  if(selected &lt; 0)</a>
<a name="ln447">  {</a>
<a name="ln448">    // try last selected</a>
<a name="ln449">    sqlite3_stmt *stmt;</a>
<a name="ln450">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln451">                                NULL);</a>
<a name="ln452">    if(sqlite3_step(stmt) == SQLITE_ROW) selected = sqlite3_column_int(stmt, 0);</a>
<a name="ln453">    sqlite3_finalize(stmt);</a>
<a name="ln454"> </a>
<a name="ln455">    // Leave as selected only the image being edited</a>
<a name="ln456">    DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln457">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln458">                                &quot;INSERT OR IGNORE INTO main.selected_images VALUES (?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln459">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, selected);</a>
<a name="ln460">    sqlite3_step(stmt);</a>
<a name="ln461">    sqlite3_finalize(stmt);</a>
<a name="ln462">  }</a>
<a name="ln463"> </a>
<a name="ln464">  if(selected &lt; 0)</a>
<a name="ln465">  {</a>
<a name="ln466">    // fail :(</a>
<a name="ln467">    dt_control_log(_(&quot;no image selected!&quot;));</a>
<a name="ln468">    return 1;</a>
<a name="ln469">  }</a>
<a name="ln470"> </a>
<a name="ln471">  // this loads the image from db if needed:</a>
<a name="ln472">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, selected, 'r');</a>
<a name="ln473">  // get image and check if it has been deleted from disk first!</a>
<a name="ln474"> </a>
<a name="ln475">  char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln476">  gboolean from_cache = TRUE;</a>
<a name="ln477">  dt_image_full_path(img-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln478">  if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln479">  {</a>
<a name="ln480">    dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), img-&gt;filename);</a>
<a name="ln481">    // dt_image_remove(selected);</a>
<a name="ln482">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln483">    return 1;</a>
<a name="ln484">  }</a>
<a name="ln485">  // and drop the lock again.</a>
<a name="ln486">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln487">  darktable.develop-&gt;image_storage.id = selected;</a>
<a name="ln488">  return 0;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">static void select_this_image(const int imgid)</a>
<a name="ln494">{</a>
<a name="ln495">  sqlite3_stmt *stmt;</a>
<a name="ln496">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;DELETE FROM main.selected_images&quot;, NULL, NULL, NULL);</a>
<a name="ln497">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln498">                              &quot;INSERT OR IGNORE INTO main.selected_images VALUES (?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln499">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln500">  sqlite3_step(stmt);</a>
<a name="ln501">  sqlite3_finalize(stmt);</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">static void dt_dev_cleanup_module_accels(dt_iop_module_t *module)</a>
<a name="ln505">{</a>
<a name="ln506">  dt_accel_disconnect_list(module-&gt;accel_closures);</a>
<a name="ln507">  dt_accel_cleanup_locals_iop(module);</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">static void dt_dev_change_image(dt_develop_t *dev, const uint32_t imgid)</a>
<a name="ln511">{</a>
<a name="ln512">  // stop crazy users from sleeping on key-repeat spacebar:</a>
<a name="ln513">  if(dev-&gt;image_loading) return;</a>
<a name="ln514"> </a>
<a name="ln515">  // make sure we can destroy and re-setup the pixel pipes.</a>
<a name="ln516">  // we acquire the pipe locks, which will block the processing threads</a>
<a name="ln517">  // in darkroom mode before they touch the pipes (init buffers etc).</a>
<a name="ln518">  // we don't block here, since we hold the gdk lock, which will</a>
<a name="ln519">  // result in circular locking when background threads emit signals</a>
<a name="ln520">  // which in turn try to acquire the gdk lock.</a>
<a name="ln521">  //</a>
<a name="ln522">  // worst case, it'll drop some change image events. sorry.</a>
<a name="ln523">  if(dt_pthread_mutex_BAD_trylock(&amp;dev-&gt;preview_pipe_mutex)) return;</a>
<a name="ln524">  if(dt_pthread_mutex_BAD_trylock(&amp;dev-&gt;pipe_mutex))</a>
<a name="ln525">  {</a>
<a name="ln526">    dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln527">    return;</a>
<a name="ln528">  }</a>
<a name="ln529"> </a>
<a name="ln530">  // get last active plugin, make sure focus out is called:</a>
<a name="ln531">  gchar *active_plugin = dt_conf_get_string(&quot;plugins/darkroom/active&quot;);</a>
<a name="ln532">  dt_iop_request_focus(NULL);</a>
<a name="ln533">  // store last active group</a>
<a name="ln534">  dt_conf_set_int(&quot;plugins/darkroom/groups&quot;, dt_dev_modulegroups_get(dev));</a>
<a name="ln535"> </a>
<a name="ln536">  // store last active plugin:</a>
<a name="ln537">  if(darktable.develop-&gt;gui_module)</a>
<a name="ln538">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, darktable.develop-&gt;gui_module-&gt;op);</a>
<a name="ln539">  else</a>
<a name="ln540">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, &quot;&quot;);</a>
<a name="ln541">  g_assert(dev-&gt;gui_attached);</a>
<a name="ln542"> </a>
<a name="ln543">  // commit image ops to db</a>
<a name="ln544">  dt_dev_write_history(dev);</a>
<a name="ln545"> </a>
<a name="ln546">  // be sure light table will update the thumbnail</a>
<a name="ln547">  // TODO: only if image changed!</a>
<a name="ln548">  // if()</a>
<a name="ln549">  {</a>
<a name="ln550">    dt_mipmap_cache_remove(darktable.mipmap_cache, dev-&gt;image_storage.id);</a>
<a name="ln551">    dt_image_synch_xmp(dev-&gt;image_storage.id);</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  // cleanup visible masks</a>
<a name="ln555">  if(!dev-&gt;form_gui)</a>
<a name="ln556">  {</a>
<a name="ln557">    dev-&gt;form_gui = (dt_masks_form_gui_t *)calloc(1, sizeof(dt_masks_form_gui_t));</a>
<a name="ln558">    dt_masks_init_form_gui(dev-&gt;form_gui);</a>
<a name="ln559">  }</a>
<a name="ln560">  dt_masks_change_form_gui(NULL);</a>
<a name="ln561"> </a>
<a name="ln562">  select_this_image(imgid);</a>
<a name="ln563"> </a>
<a name="ln564">  while(dev-&gt;history)</a>
<a name="ln565">  {</a>
<a name="ln566">    // clear history of old image</a>
<a name="ln567">    free(((dt_dev_history_item_t *)dev-&gt;history-&gt;data)-&gt;params);</a>
<a name="ln568">    free(((dt_dev_history_item_t *)dev-&gt;history-&gt;data)-&gt;blend_params);</a>
<a name="ln569">    free((dt_dev_history_item_t *)dev-&gt;history-&gt;data);</a>
<a name="ln570">    dev-&gt;history = g_list_delete_link(dev-&gt;history, dev-&gt;history);</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  // get new image:</a>
<a name="ln574">  dt_dev_reload_image(dev, imgid);</a>
<a name="ln575"> </a>
<a name="ln576">  // make sure no signals propagate here:</a>
<a name="ln577">  darktable.gui-&gt;reset = 1;</a>
<a name="ln578"> </a>
<a name="ln579">  const guint nb_iop = g_list_length(dev-&gt;iop);</a>
<a name="ln580">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;pipe);</a>
<a name="ln581">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview_pipe);</a>
<a name="ln582">  for(int i = nb_iop - 1; i &gt;= 0; i--)</a>
<a name="ln583">  {</a>
<a name="ln584">    dt_iop_module_t *module = (dt_iop_module_t *)(g_list_nth_data(dev-&gt;iop, i));</a>
<a name="ln585"> </a>
<a name="ln586">    // the base module is the one with the highest multi_priority</a>
<a name="ln587">    const guint clen = g_list_length(dev-&gt;iop);</a>
<a name="ln588">    int base_multi_priority = 0;</a>
<a name="ln589">    for(int k = 0; k &lt; clen; k++)</a>
<a name="ln590">    {</a>
<a name="ln591">      dt_iop_module_t *mod = (dt_iop_module_t *)(g_list_nth_data(dev-&gt;iop, k));</a>
<a name="ln592">      if(strcmp(module-&gt;op, mod-&gt;op) == 0) base_multi_priority = MAX(base_multi_priority, mod-&gt;multi_priority);</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">    if(module-&gt;multi_priority == base_multi_priority) // if the module is the &quot;base&quot; instance, we keep it</a>
<a name="ln596">    {</a>
<a name="ln597">      module-&gt;multi_priority = 0;</a>
<a name="ln598">      module-&gt;multi_name[0] = '\0';</a>
<a name="ln599">      dt_iop_reload_defaults(module);</a>
<a name="ln600">      dt_iop_gui_update(module);</a>
<a name="ln601">    }</a>
<a name="ln602">    else // else we delete it and remove it from the panel</a>
<a name="ln603">    {</a>
<a name="ln604">      if(!dt_iop_is_hidden(module))</a>
<a name="ln605">      {</a>
<a name="ln606">        gtk_widget_destroy(module-&gt;expander);</a>
<a name="ln607">        dt_iop_gui_cleanup_module(module);</a>
<a name="ln608">      }</a>
<a name="ln609"> </a>
<a name="ln610">      // we remove the module from the list</a>
<a name="ln611">      dev-&gt;iop = g_list_remove_link(dev-&gt;iop, g_list_nth(dev-&gt;iop, i));</a>
<a name="ln612"> </a>
<a name="ln613">      // we cleanup the module</a>
<a name="ln614">      dt_accel_disconnect_list(module-&gt;accel_closures);</a>
<a name="ln615">      dt_accel_cleanup_locals_iop(module);</a>
<a name="ln616">      module-&gt;accel_closures = NULL;</a>
<a name="ln617">      dt_iop_cleanup_module(module);</a>
<a name="ln618">      free(module);</a>
<a name="ln619">    }</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  // we also clear the saved modules</a>
<a name="ln623">  while(dev-&gt;alliop)</a>
<a name="ln624">  {</a>
<a name="ln625">    dt_iop_cleanup_module((dt_iop_module_t *)dev-&gt;alliop-&gt;data);</a>
<a name="ln626">    free(dev-&gt;alliop-&gt;data);</a>
<a name="ln627">    dev-&gt;alliop = g_list_delete_link(dev-&gt;alliop, dev-&gt;alliop);</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630">  dt_dev_pixelpipe_create_nodes(dev-&gt;pipe, dev);</a>
<a name="ln631">  dt_dev_pixelpipe_create_nodes(dev-&gt;preview_pipe, dev);</a>
<a name="ln632">  dt_masks_read_forms(dev);</a>
<a name="ln633">  dt_dev_read_history(dev);</a>
<a name="ln634"> </a>
<a name="ln635">  // we have to init all module instances other than &quot;base&quot; instance</a>
<a name="ln636">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln637">  while(modules)</a>
<a name="ln638">  {</a>
<a name="ln639">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln640">    if(module-&gt;multi_priority &gt; 0)</a>
<a name="ln641">    {</a>
<a name="ln642">      if(!dt_iop_is_hidden(module))</a>
<a name="ln643">      {</a>
<a name="ln644">        module-&gt;gui_init(module);</a>
<a name="ln645">        dt_iop_reload_defaults(module);</a>
<a name="ln646">        // we search the base iop corresponding</a>
<a name="ln647">        GList *mods = g_list_first(dev-&gt;iop);</a>
<a name="ln648">        dt_iop_module_t *base = NULL;</a>
<a name="ln649">        int pos_module = 0;</a>
<a name="ln650">        int pos_base = 0;</a>
<a name="ln651">        int pos = 0;</a>
<a name="ln652">        while(mods)</a>
<a name="ln653">        {</a>
<a name="ln654">          dt_iop_module_t *mod = (dt_iop_module_t *)(mods-&gt;data);</a>
<a name="ln655">          if(mod-&gt;multi_priority == 0 &amp;&amp; mod-&gt;instance == module-&gt;instance)</a>
<a name="ln656">          {</a>
<a name="ln657">            base = mod;</a>
<a name="ln658">            pos_base = pos;</a>
<a name="ln659">          }</a>
<a name="ln660">          else if(mod == module)</a>
<a name="ln661">            pos_module = pos;</a>
<a name="ln662">          mods = g_list_next(mods);</a>
<a name="ln663">          pos++;</a>
<a name="ln664">        }</a>
<a name="ln665">        if(!base) continue;</a>
<a name="ln666"> </a>
<a name="ln667">        /* add module to right panel */</a>
<a name="ln668">        GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln669">        dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln670">        GValue gv = { 0, { { 0 } } };</a>
<a name="ln671">        g_value_init(&amp;gv, G_TYPE_INT);</a>
<a name="ln672">        gtk_container_child_get_property(</a>
<a name="ln673">            GTK_CONTAINER(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER)),</a>
<a name="ln674">            base-&gt;expander, &quot;position&quot;, &amp;gv);</a>
<a name="ln675">        gtk_box_reorder_child(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER),</a>
<a name="ln676">                              expander, g_value_get_int(&amp;gv) + pos_base - pos_module);</a>
<a name="ln677">        dt_iop_gui_set_expanded(module, FALSE, FALSE);</a>
<a name="ln678">        dt_iop_gui_update_blending(module);</a>
<a name="ln679">      }</a>
<a name="ln680"> </a>
<a name="ln681">      /* setup key accelerators */</a>
<a name="ln682">      module-&gt;accel_closures = NULL;</a>
<a name="ln683">      if(module-&gt;connect_key_accels) module-&gt;connect_key_accels(module);</a>
<a name="ln684">      dt_iop_connect_common_accels(module);</a>
<a name="ln685"> </a>
<a name="ln686">      // we update show params for multi-instances for each other instances</a>
<a name="ln687">      dt_dev_modules_update_multishow(module-&gt;dev);</a>
<a name="ln688">    }</a>
<a name="ln689">    else</a>
<a name="ln690">    {</a>
<a name="ln691">      //  update the module header to ensure proper multi-name display</a>
<a name="ln692">      if(!dt_iop_is_hidden(module)) dt_iop_gui_update_header(module);</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">    modules = g_list_previous(modules);</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  dt_dev_pop_history_items(dev, dev-&gt;history_end);</a>
<a name="ln699"> </a>
<a name="ln700">  if(active_plugin)</a>
<a name="ln701">  {</a>
<a name="ln702">    modules = dev-&gt;iop;</a>
<a name="ln703">    while(modules)</a>
<a name="ln704">    {</a>
<a name="ln705">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln706">      if(!strcmp(module-&gt;op, active_plugin)) dt_iop_request_focus(module);</a>
<a name="ln707">      modules = g_list_next(modules);</a>
<a name="ln708">    }</a>
<a name="ln709">    g_free(active_plugin);</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  dt_dev_masks_list_change(dev);</a>
<a name="ln713"> </a>
<a name="ln714">  /* last set the group to update visibility of iop modules for new pipe */</a>
<a name="ln715">  dt_dev_modulegroups_set(dev, dt_conf_get_int(&quot;plugins/darkroom/groups&quot;));</a>
<a name="ln716"> </a>
<a name="ln717">  /* cleanup histograms */</a>
<a name="ln718">  g_list_foreach(dev-&gt;iop, (GFunc)dt_iop_cleanup_histogram, (gpointer)NULL);</a>
<a name="ln719"> </a>
<a name="ln720">  // make signals work again, but only after focus event,</a>
<a name="ln721">  // to avoid crop/rotate for example to add another history item.</a>
<a name="ln722">  darktable.gui-&gt;reset = 0;</a>
<a name="ln723"> </a>
<a name="ln724">  // Signal develop initialize</a>
<a name="ln725">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_IMAGE_CHANGED);</a>
<a name="ln726"> </a>
<a name="ln727">  // prefetch next few from first selected image on.</a>
<a name="ln728">  dt_view_filmstrip_prefetch();</a>
<a name="ln729"> </a>
<a name="ln730">  // release pixel pipe mutices</a>
<a name="ln731">  dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln732">  dt_pthread_mutex_BAD_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln733"> </a>
<a name="ln734">  // update hint message</a>
<a name="ln735">  dt_collection_hint_message(darktable.collection);</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">static void film_strip_activated(const int imgid, void *data)</a>
<a name="ln739">{</a>
<a name="ln740">  // switch images in darkroom mode:</a>
<a name="ln741">  const dt_view_t *self = (dt_view_t *)data;</a>
<a name="ln742">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln743"> </a>
<a name="ln744">  // disable color picker when changing image</a>
<a name="ln745">  if(dev-&gt;gui_module)</a>
<a name="ln746">  {</a>
<a name="ln747">    dev-&gt;gui_module-&gt;request_color_pick = DT_REQUEST_COLORPICK_OFF;</a>
<a name="ln748">  }</a>
<a name="ln749"> </a>
<a name="ln750">  // first compute/update possibly new aspect ratio of current picture</a>
<a name="ln751">  dt_image_set_aspect_ratio(dev-&gt;image_storage.id);</a>
<a name="ln752"> </a>
<a name="ln753">  // clean the undo list</a>
<a name="ln754">  dt_undo_clear(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln755">  dt_dev_change_image(dev, imgid);</a>
<a name="ln756">  dt_view_filmstrip_scroll_to_image(darktable.view_manager, imgid, FALSE);</a>
<a name="ln757">  // record the imgid to display when going back to lighttable</a>
<a name="ln758">  dt_view_lighttable_set_position(darktable.view_manager, dt_collection_image_offset(imgid));</a>
<a name="ln759">  // force redraw</a>
<a name="ln760">  dt_control_queue_redraw();</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">static void _view_darkroom_filmstrip_activate_callback(gpointer instance, gpointer user_data)</a>
<a name="ln764">{</a>
<a name="ln765">  int32_t imgid = 0;</a>
<a name="ln766">  if((imgid = dt_view_filmstrip_get_activated_imgid(darktable.view_manager)) &gt; 0)</a>
<a name="ln767">    film_strip_activated(imgid, user_data);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">static void dt_dev_jump_image(dt_develop_t *dev, int diff)</a>
<a name="ln771">{</a>
<a name="ln772">  const gchar *qin = dt_collection_get_query(darktable.collection);</a>
<a name="ln773">  int offset = 0;</a>
<a name="ln774">  if(qin)</a>
<a name="ln775">  {</a>
<a name="ln776">    int orig_imgid = -1, imgid = -1;</a>
<a name="ln777">    sqlite3_stmt *stmt;</a>
<a name="ln778"> </a>
<a name="ln779">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.selected_images&quot;, -1, &amp;stmt,</a>
<a name="ln780">                                NULL);</a>
<a name="ln781">    if(sqlite3_step(stmt) == SQLITE_ROW) orig_imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln782">    sqlite3_finalize(stmt);</a>
<a name="ln783"> </a>
<a name="ln784">    offset = dt_collection_image_offset(orig_imgid);</a>
<a name="ln785"> </a>
<a name="ln786">    DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), qin, -1, &amp;stmt, NULL);</a>
<a name="ln787">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, offset + diff);</a>
<a name="ln788">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, 1);</a>
<a name="ln789">    if(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln790">    {</a>
<a name="ln791">      imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln792"> </a>
<a name="ln793">      if(orig_imgid == imgid)</a>
<a name="ln794">      {</a>
<a name="ln795">        // nothing to do</a>
<a name="ln796">        sqlite3_finalize(stmt);</a>
<a name="ln797">        return;</a>
<a name="ln798">      }</a>
<a name="ln799"> </a>
<a name="ln800">      if(!dev-&gt;image_loading)</a>
<a name="ln801">      {</a>
<a name="ln802">        dt_view_filmstrip_scroll_to_image(darktable.view_manager, imgid, FALSE);</a>
<a name="ln803">        // record the imgid to display when going back to lighttable</a>
<a name="ln804">        dt_view_lighttable_set_position(darktable.view_manager, dt_collection_image_offset(imgid));</a>
<a name="ln805">        dt_dev_change_image(dev, imgid);</a>
<a name="ln806">      }</a>
<a name="ln807">    }</a>
<a name="ln808">    sqlite3_finalize(stmt);</a>
<a name="ln809">  }</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812">static gboolean zoom_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln813">                               GdkModifierType modifier, gpointer data)</a>
<a name="ln814">{</a>
<a name="ln815">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln816">  int zoom, closeup;</a>
<a name="ln817">  float zoom_x, zoom_y;</a>
<a name="ln818">  switch(GPOINTER_TO_INT(data))</a>
<a name="ln819">  {</a>
<a name="ln820">    case 1:</a>
<a name="ln821">      zoom = dt_control_get_dev_zoom();</a>
<a name="ln822">      zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln823">      zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln824">      closeup = dt_control_get_dev_closeup();</a>
<a name="ln825">      if(zoom == DT_ZOOM_1) closeup = (closeup &gt; 0) ^ 1; // flip closeup/no closeup, no difference whether it was 1 or larger</a>
<a name="ln826">      dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, DT_ZOOM_1, closeup, NULL, NULL);</a>
<a name="ln827">      dt_control_set_dev_zoom(DT_ZOOM_1);</a>
<a name="ln828">      dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln829">      dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln830">      dt_control_set_dev_closeup(closeup);</a>
<a name="ln831">      dt_dev_invalidate(dev);</a>
<a name="ln832">      break;</a>
<a name="ln833">    case 2:</a>
<a name="ln834">      zoom_x = zoom_y = 0.0f;</a>
<a name="ln835">      dt_control_set_dev_zoom(DT_ZOOM_FILL);</a>
<a name="ln836">      dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, DT_ZOOM_FILL, 0, NULL, NULL);</a>
<a name="ln837">      dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln838">      dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln839">      dt_control_set_dev_closeup(0);</a>
<a name="ln840">      dt_dev_invalidate(dev);</a>
<a name="ln841">      break;</a>
<a name="ln842">    case 3:</a>
<a name="ln843">      dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln844">      dt_control_set_dev_zoom_x(0);</a>
<a name="ln845">      dt_control_set_dev_zoom_y(0);</a>
<a name="ln846">      dt_control_set_dev_closeup(0);</a>
<a name="ln847">      dt_dev_invalidate(dev);</a>
<a name="ln848">      break;</a>
<a name="ln849">    default:</a>
<a name="ln850">      break;</a>
<a name="ln851">  }</a>
<a name="ln852">  dt_control_queue_redraw_center();</a>
<a name="ln853">  return TRUE;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">static gboolean film_strip_key_accel(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln857">                                     GdkModifierType modifier, gpointer data)</a>
<a name="ln858">{</a>
<a name="ln859">  dt_lib_module_t *m = darktable.view_manager-&gt;proxy.filmstrip.module;</a>
<a name="ln860">  gboolean vs = dt_lib_is_visible(m);</a>
<a name="ln861">  dt_lib_set_visible(m, !vs);</a>
<a name="ln862">  return TRUE;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">static gboolean export_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln867">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln868">{</a>
<a name="ln869">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln870"> </a>
<a name="ln871">  /* write history before exporting */</a>
<a name="ln872">  dt_dev_write_history(dev);</a>
<a name="ln873"> </a>
<a name="ln874">  /* export current image */</a>
<a name="ln875">  const int max_width = dt_conf_get_int(&quot;plugins/lighttable/export/width&quot;);</a>
<a name="ln876">  const int max_height = dt_conf_get_int(&quot;plugins/lighttable/export/height&quot;);</a>
<a name="ln877">  char *format_name = dt_conf_get_string(&quot;plugins/lighttable/export/format_name&quot;);</a>
<a name="ln878">  char *storage_name = dt_conf_get_string(&quot;plugins/lighttable/export/storage_name&quot;);</a>
<a name="ln879">  const int format_index = dt_imageio_get_index_of_format(dt_imageio_get_format_by_name(format_name));</a>
<a name="ln880">  const int storage_index = dt_imageio_get_index_of_storage(dt_imageio_get_storage_by_name(storage_name));</a>
<a name="ln881">  const gboolean high_quality = dt_conf_get_bool(&quot;plugins/lighttable/export/high_quality_processing&quot;);</a>
<a name="ln882">  const gboolean upscale = dt_conf_get_bool(&quot;plugins/lighttable/export/upscale&quot;);</a>
<a name="ln883">  char *style = dt_conf_get_string(&quot;plugins/lighttable/export/style&quot;);</a>
<a name="ln884">  const gboolean style_append = dt_conf_get_bool(&quot;plugins/lighttable/export/style_append&quot;);</a>
<a name="ln885">  dt_colorspaces_color_profile_type_t icc_type = dt_conf_get_int(&quot;plugins/lighttable/export/icctype&quot;);</a>
<a name="ln886">  gchar *icc_filename = dt_conf_get_string(&quot;plugins/lighttable/export/iccprofile&quot;);</a>
<a name="ln887">  dt_iop_color_intent_t icc_intent = dt_conf_get_int(&quot;plugins/lighttable/export/iccintent&quot;);</a>
<a name="ln888">  // darkroom is for single images, so only export the one the user is working on</a>
<a name="ln889">  GList *l = g_list_append(NULL, GINT_TO_POINTER(dev-&gt;image_storage.id));</a>
<a name="ln890">  dt_control_export(l, max_width, max_height, format_index, storage_index, high_quality, upscale, style, style_append,</a>
<a name="ln891">                    icc_type, icc_filename, icc_intent);</a>
<a name="ln892">  g_free(format_name);</a>
<a name="ln893">  g_free(storage_name);</a>
<a name="ln894">  g_free(style);</a>
<a name="ln895">  g_free(icc_filename);</a>
<a name="ln896">  return TRUE;</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">static gboolean skip_f_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln900">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln901">{</a>
<a name="ln902">  dt_dev_jump_image((dt_develop_t *)data, 1);</a>
<a name="ln903">  return TRUE;</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">static gboolean skip_b_key_accel_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln907">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln908">{</a>
<a name="ln909">  dt_dev_jump_image((dt_develop_t *)data, -1);</a>
<a name="ln910">  return TRUE;</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">static void _darkroom_ui_pipe_finish_signal_callback(gpointer instance, gpointer data)</a>
<a name="ln914">{</a>
<a name="ln915">  dt_control_queue_redraw();</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">static void _darkroom_ui_favorite_presets_popupmenu(GtkWidget *w, gpointer user_data)</a>
<a name="ln919">{</a>
<a name="ln920">  /* create favorites menu and popup */</a>
<a name="ln921">  dt_gui_favorite_presets_menu_show();</a>
<a name="ln922"> </a>
<a name="ln923">  /* if we got any styles, lets popup menu for selection */</a>
<a name="ln924">  if(darktable.gui-&gt;presets_popup_menu)</a>
<a name="ln925">  {</a>
<a name="ln926">    gtk_widget_show_all(GTK_WIDGET(darktable.gui-&gt;presets_popup_menu));</a>
<a name="ln927"> </a>
<a name="ln928">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln929">    gtk_menu_popup_at_pointer(darktable.gui-&gt;presets_popup_menu, NULL);</a>
<a name="ln930">#else</a>
<a name="ln931">    gtk_menu_popup(darktable.gui-&gt;presets_popup_menu, NULL, NULL, NULL, NULL, 0, 0);</a>
<a name="ln932">#endif</a>
<a name="ln933">  }</a>
<a name="ln934">  else</a>
<a name="ln935">    dt_control_log(_(&quot;no userdefined presets for favorite modules were found&quot;));</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">static void _darkroom_ui_apply_style_activate_callback(gchar *name)</a>
<a name="ln939">{</a>
<a name="ln940">  dt_control_log(_(&quot;applied style `%s' on current image&quot;), name);</a>
<a name="ln941"> </a>
<a name="ln942">  /* write current history changes so nothing gets lost */</a>
<a name="ln943">  dt_dev_write_history(darktable.develop);</a>
<a name="ln944"> </a>
<a name="ln945">  /* apply style on image and reload*/</a>
<a name="ln946">  dt_styles_apply_to_image(name, FALSE, darktable.develop-&gt;image_storage.id);</a>
<a name="ln947">  dt_dev_reload_image(darktable.develop, darktable.develop-&gt;image_storage.id);</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950">static void _darkroom_ui_apply_style_popupmenu(GtkWidget *w, gpointer user_data)</a>
<a name="ln951">{</a>
<a name="ln952">  /* show styles popup menu */</a>
<a name="ln953">  GList *styles = dt_styles_get_list(&quot;&quot;);</a>
<a name="ln954">  GtkMenuShell *menu = NULL;</a>
<a name="ln955">  if(styles)</a>
<a name="ln956">  {</a>
<a name="ln957">    menu = GTK_MENU_SHELL(gtk_menu_new());</a>
<a name="ln958">    do</a>
<a name="ln959">    {</a>
<a name="ln960">      dt_style_t *style = (dt_style_t *)styles-&gt;data;</a>
<a name="ln961"> </a>
<a name="ln962">      char *items_string = dt_styles_get_item_list_as_string(style-&gt;name);</a>
<a name="ln963">      gchar *tooltip = NULL;</a>
<a name="ln964"> </a>
<a name="ln965">      if(style-&gt;description &amp;&amp; *style-&gt;description)</a>
<a name="ln966">      {</a>
<a name="ln967">        tooltip = g_strconcat(&quot;&lt;b&gt;&quot;, style-&gt;description, &quot;&lt;/b&gt;\n&quot;, items_string, NULL);</a>
<a name="ln968">      }</a>
<a name="ln969">      else</a>
<a name="ln970">      {</a>
<a name="ln971">        tooltip = g_strdup(items_string);</a>
<a name="ln972">      }</a>
<a name="ln973"> </a>
<a name="ln974">      gchar **split = g_strsplit(style-&gt;name, &quot;|&quot;, 0);</a>
<a name="ln975"> </a>
<a name="ln976">      // if sub-menu, do not put leading group in final name</a>
<a name="ln977"> </a>
<a name="ln978">      gchar *mi_name = NULL;</a>
<a name="ln979"> </a>
<a name="ln980">      if(split[1])</a>
<a name="ln981">      {</a>
<a name="ln982">        mi_name = g_strdup(split[1]);</a>
<a name="ln983">        for(int i=2; split[i]; i++)</a>
<a name="ln984">          mi_name = g_strconcat(mi_name, &quot; | &quot;, split[i], NULL);</a>
<a name="ln985">      }</a>
<a name="ln986">      else</a>
<a name="ln987">        mi_name = g_strdup(split[0]);</a>
<a name="ln988"> </a>
<a name="ln989">      GtkWidget *mi = gtk_menu_item_new_with_label(mi_name);</a>
<a name="ln990">      gtk_widget_set_tooltip_markup(mi, tooltip);</a>
<a name="ln991">      g_free(mi_name);</a>
<a name="ln992"> </a>
<a name="ln993">      // check if we already have a sub-menu with this name</a>
<a name="ln994">      GtkMenu *sm = NULL;</a>
<a name="ln995"> </a>
<a name="ln996">      GList *childs = gtk_container_get_children(GTK_CONTAINER(menu));</a>
<a name="ln997">      while(childs)</a>
<a name="ln998">      {</a>
<a name="ln999">        GtkMenuItem *smi = (GtkMenuItem *)childs-&gt;data;</a>
<a name="ln1000">        if(!g_strcmp0(split[0],gtk_menu_item_get_label(smi)))</a>
<a name="ln1001">        {</a>
<a name="ln1002">          sm = (GtkMenu *)gtk_menu_item_get_submenu(smi);</a>
<a name="ln1003">          g_list_free(childs);</a>
<a name="ln1004">          break;</a>
<a name="ln1005">        }</a>
<a name="ln1006">        childs = g_list_next(childs);</a>
<a name="ln1007">      }</a>
<a name="ln1008"> </a>
<a name="ln1009">      GtkMenuItem *smi = NULL;</a>
<a name="ln1010"> </a>
<a name="ln1011">      // no sub-menu, but we need one</a>
<a name="ln1012">      if(!sm &amp;&amp; split[1])</a>
<a name="ln1013">      {</a>
<a name="ln1014">        smi = (GtkMenuItem *)gtk_menu_item_new_with_label(split[0]);</a>
<a name="ln1015">        sm = (GtkMenu *)gtk_menu_new();</a>
<a name="ln1016">        gtk_menu_item_set_submenu(smi, GTK_WIDGET(sm));</a>
<a name="ln1017">      }</a>
<a name="ln1018"> </a>
<a name="ln1019">      if(sm)</a>
<a name="ln1020">        gtk_menu_shell_append(GTK_MENU_SHELL(sm), mi);</a>
<a name="ln1021">      else</a>
<a name="ln1022">        gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);</a>
<a name="ln1023"> </a>
<a name="ln1024">      if(smi)</a>
<a name="ln1025">      {</a>
<a name="ln1026">        gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(smi));</a>
<a name="ln1027">        gtk_widget_show(GTK_WIDGET(smi));</a>
<a name="ln1028">      }</a>
<a name="ln1029"> </a>
<a name="ln1030">      g_signal_connect_swapped(G_OBJECT(mi), &quot;activate&quot;,</a>
<a name="ln1031">                               G_CALLBACK(_darkroom_ui_apply_style_activate_callback),</a>
<a name="ln1032">                               (gpointer)g_strdup(style-&gt;name));</a>
<a name="ln1033">      gtk_widget_show(mi);</a>
<a name="ln1034"> </a>
<a name="ln1035">      g_free(items_string);</a>
<a name="ln1036">      g_free(tooltip);</a>
<a name="ln1037">      g_strfreev(split);</a>
<a name="ln1038">    } while((styles = g_list_next(styles)) != NULL);</a>
<a name="ln1039">    g_list_free_full(styles, dt_style_free);</a>
<a name="ln1040">  }</a>
<a name="ln1041"> </a>
<a name="ln1042">  /* if we got any styles, lets popup menu for selection */</a>
<a name="ln1043">  if(menu)</a>
<a name="ln1044">  {</a>
<a name="ln1045">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln1046">    gtk_menu_popup_at_pointer(GTK_MENU(menu), NULL);</a>
<a name="ln1047">#else</a>
<a name="ln1048">    gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, 0, 0);</a>
<a name="ln1049">#endif</a>
<a name="ln1050">  }</a>
<a name="ln1051">  else</a>
<a name="ln1052">    dt_control_log(_(&quot;no styles have been created yet&quot;));</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">/** toolbar buttons */</a>
<a name="ln1056"> </a>
<a name="ln1057">static gboolean _toolbar_show_popup(gpointer user_data)</a>
<a name="ln1058">{</a>
<a name="ln1059">  gtk_widget_show_all(GTK_WIDGET(user_data));</a>
<a name="ln1060"> </a>
<a name="ln1061">  // cancel glib timeout if invoked by long button press</a>
<a name="ln1062">  return FALSE;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">/* overexposed */</a>
<a name="ln1066">static void _overexposed_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1067">{</a>
<a name="ln1068">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1069">  d-&gt;overexposed.enabled = !d-&gt;overexposed.enabled;</a>
<a name="ln1070">  //   dt_dev_reprocess_center(d);</a>
<a name="ln1071">  dt_dev_reprocess_all(d);</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">static gboolean _overexposed_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1075">{</a>
<a name="ln1076">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1077">  const GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1078">  if(e-&gt;button == 3)</a>
<a name="ln1079">  {</a>
<a name="ln1080">    _toolbar_show_popup(d-&gt;overexposed.floating_window);</a>
<a name="ln1081">    return TRUE;</a>
<a name="ln1082">  }</a>
<a name="ln1083">  else</a>
<a name="ln1084">  {</a>
<a name="ln1085">    d-&gt;overexposed.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;overexposed.floating_window);</a>
<a name="ln1086">    return FALSE;</a>
<a name="ln1087">  }</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">static gboolean _overexposed_quickbutton_released(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1091">{</a>
<a name="ln1092">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1093">  if(d-&gt;overexposed.timeout &gt; 0) g_source_remove(d-&gt;overexposed.timeout);</a>
<a name="ln1094">  d-&gt;overexposed.timeout = 0;</a>
<a name="ln1095">  return FALSE;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">static void colorscheme_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1099">{</a>
<a name="ln1100">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1101">  d-&gt;overexposed.colorscheme = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1102">  if(d-&gt;overexposed.enabled == FALSE)</a>
<a name="ln1103">    gtk_button_clicked(GTK_BUTTON(d-&gt;overexposed.button));</a>
<a name="ln1104">  else</a>
<a name="ln1105">    //     dt_dev_reprocess_center(d);</a>
<a name="ln1106">    dt_dev_reprocess_all(d);</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">static void lower_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1110">{</a>
<a name="ln1111">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1112">  d-&gt;overexposed.lower = dt_bauhaus_slider_get(slider);</a>
<a name="ln1113">  if(d-&gt;overexposed.enabled == FALSE)</a>
<a name="ln1114">    gtk_button_clicked(GTK_BUTTON(d-&gt;overexposed.button));</a>
<a name="ln1115">  else</a>
<a name="ln1116">    //     dt_dev_reprocess_center(d);</a>
<a name="ln1117">    dt_dev_reprocess_all(d);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">static void upper_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1121">{</a>
<a name="ln1122">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1123">  d-&gt;overexposed.upper = dt_bauhaus_slider_get(slider);</a>
<a name="ln1124">  if(d-&gt;overexposed.enabled == FALSE)</a>
<a name="ln1125">    gtk_button_clicked(GTK_BUTTON(d-&gt;overexposed.button));</a>
<a name="ln1126">  else</a>
<a name="ln1127">    //     dt_dev_reprocess_center(d);</a>
<a name="ln1128">    dt_dev_reprocess_all(d);</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">/* rawoverexposed */</a>
<a name="ln1132">static void _rawoverexposed_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1133">{</a>
<a name="ln1134">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1135">  d-&gt;rawoverexposed.enabled = !d-&gt;rawoverexposed.enabled;</a>
<a name="ln1136">  //   dt_dev_reprocess_center(d);</a>
<a name="ln1137">  dt_dev_reprocess_all(d);</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">static gboolean _rawoverexposed_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1141">{</a>
<a name="ln1142">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1143">  const GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1144">  if(e-&gt;button == 3)</a>
<a name="ln1145">  {</a>
<a name="ln1146">    _toolbar_show_popup(d-&gt;rawoverexposed.floating_window);</a>
<a name="ln1147">    return TRUE;</a>
<a name="ln1148">  }</a>
<a name="ln1149">  else</a>
<a name="ln1150">  {</a>
<a name="ln1151">    d-&gt;rawoverexposed.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;rawoverexposed.floating_window);</a>
<a name="ln1152">    return FALSE;</a>
<a name="ln1153">  }</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">static gboolean _rawoverexposed_quickbutton_released(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1157">{</a>
<a name="ln1158">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1159">  if(d-&gt;rawoverexposed.timeout &gt; 0) g_source_remove(d-&gt;rawoverexposed.timeout);</a>
<a name="ln1160">  d-&gt;rawoverexposed.timeout = 0;</a>
<a name="ln1161">  return FALSE;</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">static void rawoverexposed_mode_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1165">{</a>
<a name="ln1166">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1167">  d-&gt;rawoverexposed.mode = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1168">  if(d-&gt;rawoverexposed.enabled == FALSE)</a>
<a name="ln1169">    gtk_button_clicked(GTK_BUTTON(d-&gt;rawoverexposed.button));</a>
<a name="ln1170">  else</a>
<a name="ln1171">    //     dt_dev_reprocess_center(d);</a>
<a name="ln1172">    dt_dev_reprocess_all(d);</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">static void rawoverexposed_colorscheme_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1176">{</a>
<a name="ln1177">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1178">  d-&gt;rawoverexposed.colorscheme = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1179">  if(d-&gt;rawoverexposed.enabled == FALSE)</a>
<a name="ln1180">    gtk_button_clicked(GTK_BUTTON(d-&gt;rawoverexposed.button));</a>
<a name="ln1181">  else</a>
<a name="ln1182">    //     dt_dev_reprocess_center(d);</a>
<a name="ln1183">    dt_dev_reprocess_all(d);</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">static void rawoverexposed_threshold_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln1187">{</a>
<a name="ln1188">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1189">  d-&gt;rawoverexposed.threshold = dt_bauhaus_slider_get(slider);</a>
<a name="ln1190">  if(d-&gt;rawoverexposed.enabled == FALSE)</a>
<a name="ln1191">    gtk_button_clicked(GTK_BUTTON(d-&gt;rawoverexposed.button));</a>
<a name="ln1192">  else</a>
<a name="ln1193">    //     dt_dev_reprocess_center(d);</a>
<a name="ln1194">    dt_dev_reprocess_all(d);</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">static gboolean _toolbox_toggle_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1198">                                             GdkModifierType modifier, gpointer data)</a>
<a name="ln1199">{</a>
<a name="ln1200">  gtk_button_clicked(GTK_BUTTON(data));</a>
<a name="ln1201">  return TRUE;</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">/* softproof */</a>
<a name="ln1205">static void _softproof_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1206">{</a>
<a name="ln1207">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1208">  if(darktable.color_profiles-&gt;mode == DT_PROFILE_SOFTPROOF)</a>
<a name="ln1209">    darktable.color_profiles-&gt;mode = DT_PROFILE_NORMAL;</a>
<a name="ln1210">  else</a>
<a name="ln1211">    darktable.color_profiles-&gt;mode = DT_PROFILE_SOFTPROOF;</a>
<a name="ln1212"> </a>
<a name="ln1213">  _update_softproof_gamut_checking(d);</a>
<a name="ln1214"> </a>
<a name="ln1215">  dt_dev_reprocess_all(d);</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">static gboolean _softproof_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1219">{</a>
<a name="ln1220">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1221">  GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1222"> </a>
<a name="ln1223">  gtk_popover_set_relative_to(GTK_POPOVER(d-&gt;profile.floating_window), d-&gt;profile.softproof_button);</a>
<a name="ln1224"> </a>
<a name="ln1225">  if(e-&gt;button == 3)</a>
<a name="ln1226">  {</a>
<a name="ln1227">    _toolbar_show_popup(d-&gt;profile.floating_window);</a>
<a name="ln1228">    return TRUE;</a>
<a name="ln1229">  }</a>
<a name="ln1230">  else</a>
<a name="ln1231">  {</a>
<a name="ln1232">    d-&gt;profile.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;profile.floating_window);</a>
<a name="ln1233">    return FALSE;</a>
<a name="ln1234">  }</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">static gboolean _profile_quickbutton_released(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1238">{</a>
<a name="ln1239">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1240">  if(d-&gt;profile.timeout &gt; 0) g_source_remove(d-&gt;profile.timeout);</a>
<a name="ln1241">  d-&gt;profile.timeout = 0;</a>
<a name="ln1242">  return FALSE;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">/* gamut */</a>
<a name="ln1246">static void _gamut_quickbutton_clicked(GtkWidget *w, gpointer user_data)</a>
<a name="ln1247">{</a>
<a name="ln1248">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1249">  if(darktable.color_profiles-&gt;mode == DT_PROFILE_GAMUTCHECK)</a>
<a name="ln1250">    darktable.color_profiles-&gt;mode = DT_PROFILE_NORMAL;</a>
<a name="ln1251">  else</a>
<a name="ln1252">    darktable.color_profiles-&gt;mode = DT_PROFILE_GAMUTCHECK;</a>
<a name="ln1253"> </a>
<a name="ln1254">  _update_softproof_gamut_checking(d);</a>
<a name="ln1255"> </a>
<a name="ln1256">  dt_dev_reprocess_all(d);</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">static gboolean _gamut_quickbutton_pressed(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln1260">{</a>
<a name="ln1261">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1262">  GdkEventButton *e = (GdkEventButton *)event;</a>
<a name="ln1263"> </a>
<a name="ln1264">  gtk_popover_set_relative_to(GTK_POPOVER(d-&gt;profile.floating_window), d-&gt;profile.gamut_button);</a>
<a name="ln1265"> </a>
<a name="ln1266">  if(e-&gt;button == 3)</a>
<a name="ln1267">  {</a>
<a name="ln1268">    _toolbar_show_popup(d-&gt;profile.floating_window);</a>
<a name="ln1269">    return TRUE;</a>
<a name="ln1270">  }</a>
<a name="ln1271">  else</a>
<a name="ln1272">  {</a>
<a name="ln1273">    d-&gt;profile.timeout = g_timeout_add_seconds(1, _toolbar_show_popup, d-&gt;profile.floating_window);</a>
<a name="ln1274">    return FALSE;</a>
<a name="ln1275">  }</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278">/* set the gui state for both softproof and gamut checking */</a>
<a name="ln1279">static void _update_softproof_gamut_checking(dt_develop_t *d)</a>
<a name="ln1280">{</a>
<a name="ln1281">  g_signal_handlers_block_by_func(d-&gt;profile.softproof_button, _softproof_quickbutton_clicked, d);</a>
<a name="ln1282">  g_signal_handlers_block_by_func(d-&gt;profile.gamut_button, _gamut_quickbutton_clicked, d);</a>
<a name="ln1283"> </a>
<a name="ln1284">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;profile.softproof_button), darktable.color_profiles-&gt;mode == DT_PROFILE_SOFTPROOF);</a>
<a name="ln1285">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(d-&gt;profile.gamut_button), darktable.color_profiles-&gt;mode == DT_PROFILE_GAMUTCHECK);</a>
<a name="ln1286"> </a>
<a name="ln1287">  g_signal_handlers_unblock_by_func(d-&gt;profile.softproof_button, _softproof_quickbutton_clicked, d);</a>
<a name="ln1288">  g_signal_handlers_unblock_by_func(d-&gt;profile.gamut_button, _gamut_quickbutton_clicked, d);</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291">static void display_intent_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1292">{</a>
<a name="ln1293">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1294">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1295"> </a>
<a name="ln1296">  dt_iop_color_intent_t new_intent = darktable.color_profiles-&gt;display_intent;</a>
<a name="ln1297"> </a>
<a name="ln1298">  // we are not using the int value directly so it's robust against changes on lcms' side</a>
<a name="ln1299">  switch(pos)</a>
<a name="ln1300">  {</a>
<a name="ln1301">    case 0:</a>
<a name="ln1302">      new_intent = DT_INTENT_PERCEPTUAL;</a>
<a name="ln1303">      break;</a>
<a name="ln1304">    case 1:</a>
<a name="ln1305">      new_intent = DT_INTENT_RELATIVE_COLORIMETRIC;</a>
<a name="ln1306">      break;</a>
<a name="ln1307">    case 2:</a>
<a name="ln1308">      new_intent = DT_INTENT_SATURATION;</a>
<a name="ln1309">      break;</a>
<a name="ln1310">    case 3:</a>
<a name="ln1311">      new_intent = DT_INTENT_ABSOLUTE_COLORIMETRIC;</a>
<a name="ln1312">      break;</a>
<a name="ln1313">  }</a>
<a name="ln1314"> </a>
<a name="ln1315">  if(new_intent != darktable.color_profiles-&gt;display_intent)</a>
<a name="ln1316">  {</a>
<a name="ln1317">    darktable.color_profiles-&gt;display_intent = new_intent;</a>
<a name="ln1318">    dt_dev_reprocess_all(d);</a>
<a name="ln1319">  }</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">static void softproof_profile_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1323">{</a>
<a name="ln1324">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1325">  gboolean profile_changed = FALSE;</a>
<a name="ln1326">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1327">  for(GList *profiles = darktable.color_profiles-&gt;profiles; profiles; profiles = g_list_next(profiles))</a>
<a name="ln1328">  {</a>
<a name="ln1329">    dt_colorspaces_color_profile_t *pp = (dt_colorspaces_color_profile_t *)profiles-&gt;data;</a>
<a name="ln1330">    if(pp-&gt;out_pos == pos)</a>
<a name="ln1331">    {</a>
<a name="ln1332">      if(darktable.color_profiles-&gt;softproof_type != pp-&gt;type</a>
<a name="ln1333">        || (darktable.color_profiles-&gt;softproof_type == DT_COLORSPACE_FILE</a>
<a name="ln1334">            &amp;&amp; strcmp(darktable.color_profiles-&gt;softproof_filename, pp-&gt;filename)))</a>
<a name="ln1335"> </a>
<a name="ln1336">      {</a>
<a name="ln1337">        darktable.color_profiles-&gt;softproof_type = pp-&gt;type;</a>
<a name="ln1338">        g_strlcpy(darktable.color_profiles-&gt;softproof_filename, pp-&gt;filename,</a>
<a name="ln1339">                  sizeof(darktable.color_profiles-&gt;softproof_filename));</a>
<a name="ln1340">        profile_changed = TRUE;</a>
<a name="ln1341">      }</a>
<a name="ln1342">      goto end;</a>
<a name="ln1343">    }</a>
<a name="ln1344">  }</a>
<a name="ln1345"> </a>
<a name="ln1346">  // profile not found, fall back to sRGB. shouldn't happen</a>
<a name="ln1347">  fprintf(stderr, &quot;can't find softproof profile `%s', using sRGB instead\n&quot;, dt_bauhaus_combobox_get_text(combo));</a>
<a name="ln1348">  profile_changed = darktable.color_profiles-&gt;softproof_type != DT_COLORSPACE_SRGB;</a>
<a name="ln1349">  darktable.color_profiles-&gt;softproof_type = DT_COLORSPACE_SRGB;</a>
<a name="ln1350">  darktable.color_profiles-&gt;softproof_filename[0] = '\0';</a>
<a name="ln1351"> </a>
<a name="ln1352">end:</a>
<a name="ln1353">  if(profile_changed) dt_dev_reprocess_all(d);</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356">static void display_profile_callback(GtkWidget *combo, gpointer user_data)</a>
<a name="ln1357">{</a>
<a name="ln1358">  dt_develop_t *d = (dt_develop_t *)user_data;</a>
<a name="ln1359">  gboolean profile_changed = FALSE;</a>
<a name="ln1360">  const int pos = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1361">  for(GList *profiles = darktable.color_profiles-&gt;profiles; profiles; profiles = g_list_next(profiles))</a>
<a name="ln1362">  {</a>
<a name="ln1363">    dt_colorspaces_color_profile_t *pp = (dt_colorspaces_color_profile_t *)profiles-&gt;data;</a>
<a name="ln1364">    if(pp-&gt;display_pos == pos)</a>
<a name="ln1365">    {</a>
<a name="ln1366">      if(darktable.color_profiles-&gt;display_type != pp-&gt;type</a>
<a name="ln1367">        || (darktable.color_profiles-&gt;display_type == DT_COLORSPACE_FILE</a>
<a name="ln1368">            &amp;&amp; strcmp(darktable.color_profiles-&gt;display_filename, pp-&gt;filename)))</a>
<a name="ln1369">      {</a>
<a name="ln1370">        darktable.color_profiles-&gt;display_type = pp-&gt;type;</a>
<a name="ln1371">        g_strlcpy(darktable.color_profiles-&gt;display_filename, pp-&gt;filename,</a>
<a name="ln1372">                  sizeof(darktable.color_profiles-&gt;display_filename));</a>
<a name="ln1373">        profile_changed = TRUE;</a>
<a name="ln1374">      }</a>
<a name="ln1375">      goto end;</a>
<a name="ln1376">    }</a>
<a name="ln1377">  }</a>
<a name="ln1378"> </a>
<a name="ln1379">  // profile not found, fall back to system display profile. shouldn't happen</a>
<a name="ln1380">  fprintf(stderr, &quot;can't find display profile `%s', using system display profile instead\n&quot;, dt_bauhaus_combobox_get_text(combo));</a>
<a name="ln1381">  profile_changed = darktable.color_profiles-&gt;display_type != DT_COLORSPACE_DISPLAY;</a>
<a name="ln1382">  darktable.color_profiles-&gt;display_type = DT_COLORSPACE_DISPLAY;</a>
<a name="ln1383">  darktable.color_profiles-&gt;display_filename[0] = '\0';</a>
<a name="ln1384"> </a>
<a name="ln1385">end:</a>
<a name="ln1386">  if(profile_changed)</a>
<a name="ln1387">  {</a>
<a name="ln1388">    pthread_rwlock_rdlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1389">    dt_colorspaces_update_display_transforms();</a>
<a name="ln1390">    pthread_rwlock_unlock(&amp;darktable.color_profiles-&gt;xprofile_lock);</a>
<a name="ln1391">    dt_dev_reprocess_all(d);</a>
<a name="ln1392">  }</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">// FIXME: turning off lcms2 in prefs hides the widget but leaves the window sized like before -&gt; ugly-ish</a>
<a name="ln1396">static void _preference_changed(gpointer instance, gpointer user_data)</a>
<a name="ln1397">{</a>
<a name="ln1398">  GtkWidget *display_intent = GTK_WIDGET(user_data);</a>
<a name="ln1399"> </a>
<a name="ln1400">  const int force_lcms2 = dt_conf_get_bool(&quot;plugins/lighttable/export/force_lcms2&quot;);</a>
<a name="ln1401">  if(force_lcms2)</a>
<a name="ln1402">  {</a>
<a name="ln1403">    gtk_widget_set_no_show_all(display_intent, FALSE);</a>
<a name="ln1404">    gtk_widget_set_visible(display_intent, TRUE);</a>
<a name="ln1405">  }</a>
<a name="ln1406">  else</a>
<a name="ln1407">  {</a>
<a name="ln1408">    gtk_widget_set_no_show_all(display_intent, TRUE);</a>
<a name="ln1409">    gtk_widget_set_visible(display_intent, FALSE);</a>
<a name="ln1410">  }</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">/** end of toolbox */</a>
<a name="ln1414"> </a>
<a name="ln1415">static gboolean _brush_size_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1416">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln1417">{</a>
<a name="ln1418">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1419"> </a>
<a name="ln1420">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 0, 0);</a>
<a name="ln1421">  return TRUE;</a>
<a name="ln1422">}</a>
<a name="ln1423">static gboolean _brush_size_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1424">                                          GdkModifierType modifier, gpointer data)</a>
<a name="ln1425">{</a>
<a name="ln1426">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1427"> </a>
<a name="ln1428">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 1, 0);</a>
<a name="ln1429">  return TRUE;</a>
<a name="ln1430">}</a>
<a name="ln1431"> </a>
<a name="ln1432">static gboolean _brush_hardness_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1433">                                            GdkModifierType modifier, gpointer data)</a>
<a name="ln1434">{</a>
<a name="ln1435">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1436"> </a>
<a name="ln1437">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 0, GDK_SHIFT_MASK);</a>
<a name="ln1438">  return TRUE;</a>
<a name="ln1439">}</a>
<a name="ln1440">static gboolean _brush_hardness_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1441">                                              GdkModifierType modifier, gpointer data)</a>
<a name="ln1442">{</a>
<a name="ln1443">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1444"> </a>
<a name="ln1445">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 1, GDK_SHIFT_MASK);</a>
<a name="ln1446">  return TRUE;</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">static gboolean _brush_opacity_up_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1450">                                           GdkModifierType modifier, gpointer data)</a>
<a name="ln1451">{</a>
<a name="ln1452">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1453"> </a>
<a name="ln1454">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 0, GDK_CONTROL_MASK);</a>
<a name="ln1455">  return TRUE;</a>
<a name="ln1456">}</a>
<a name="ln1457">static gboolean _brush_opacity_down_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1458">                                             GdkModifierType modifier, gpointer data)</a>
<a name="ln1459">{</a>
<a name="ln1460">  dt_develop_t *dev = (dt_develop_t *)data;</a>
<a name="ln1461"> </a>
<a name="ln1462">  if(dev-&gt;form_visible) dt_masks_events_mouse_scrolled(dev-&gt;gui_module, 0, 0, 1, GDK_CONTROL_MASK);</a>
<a name="ln1463">  return TRUE;</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">void gui_init(dt_view_t *self)</a>
<a name="ln1467">{</a>
<a name="ln1468">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln1469">  /*</a>
<a name="ln1470">   * Add view specific tool buttons</a>
<a name="ln1471">   */</a>
<a name="ln1472"> </a>
<a name="ln1473">  /* create favorite plugin preset popup tool */</a>
<a name="ln1474">  GtkWidget *favorite_presets</a>
<a name="ln1475">      = dtgtk_button_new(dtgtk_cairo_paint_presets, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1476">  gtk_widget_set_tooltip_text(favorite_presets, _(&quot;quick access to presets of your favorites&quot;));</a>
<a name="ln1477">  g_signal_connect(G_OBJECT(favorite_presets), &quot;clicked&quot;, G_CALLBACK(_darkroom_ui_favorite_presets_popupmenu),</a>
<a name="ln1478">                   NULL);</a>
<a name="ln1479">  dt_gui_add_help_link(favorite_presets, dt_get_help_url(&quot;favorite_presets&quot;));</a>
<a name="ln1480">  dt_view_manager_view_toolbox_add(darktable.view_manager, favorite_presets, DT_VIEW_DARKROOM);</a>
<a name="ln1481"> </a>
<a name="ln1482">  /* create quick styles popup menu tool */</a>
<a name="ln1483">  GtkWidget *styles = dtgtk_button_new(dtgtk_cairo_paint_styles, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1484">  g_signal_connect(G_OBJECT(styles), &quot;clicked&quot;, G_CALLBACK(_darkroom_ui_apply_style_popupmenu), NULL);</a>
<a name="ln1485">  gtk_widget_set_tooltip_text(styles, _(&quot;quick access for applying any of your styles&quot;));</a>
<a name="ln1486">  dt_gui_add_help_link(styles, dt_get_help_url(&quot;bottom_panel_styles&quot;));</a>
<a name="ln1487">  dt_view_manager_view_toolbox_add(darktable.view_manager, styles, DT_VIEW_DARKROOM);</a>
<a name="ln1488"> </a>
<a name="ln1489">  const int panel_width = dt_conf_get_int(&quot;panel_width&quot;);</a>
<a name="ln1490"> </a>
<a name="ln1491">  /* create rawoverexposed popup tool */</a>
<a name="ln1492">  {</a>
<a name="ln1493">    // the button</a>
<a name="ln1494">    dev-&gt;rawoverexposed.button</a>
<a name="ln1495">        = dtgtk_togglebutton_new(dtgtk_cairo_paint_rawoverexposed, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1496">    gtk_widget_set_tooltip_text(dev-&gt;rawoverexposed.button,</a>
<a name="ln1497">                                _(&quot;toggle raw over exposed indication\nright click for options&quot;));</a>
<a name="ln1498">    g_signal_connect(G_OBJECT(dev-&gt;rawoverexposed.button), &quot;clicked&quot;,</a>
<a name="ln1499">                     G_CALLBACK(_rawoverexposed_quickbutton_clicked), dev);</a>
<a name="ln1500">    g_signal_connect(G_OBJECT(dev-&gt;rawoverexposed.button), &quot;button-press-event&quot;,</a>
<a name="ln1501">                     G_CALLBACK(_rawoverexposed_quickbutton_pressed), dev);</a>
<a name="ln1502">    g_signal_connect(G_OBJECT(dev-&gt;rawoverexposed.button), &quot;button-release-event&quot;,</a>
<a name="ln1503">                     G_CALLBACK(_rawoverexposed_quickbutton_released), dev);</a>
<a name="ln1504">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;rawoverexposed.button, DT_VIEW_DARKROOM);</a>
<a name="ln1505">    dt_gui_add_help_link(dev-&gt;rawoverexposed.button, dt_get_help_url(&quot;rawoverexposed&quot;));</a>
<a name="ln1506"> </a>
<a name="ln1507">    // and the popup window</a>
<a name="ln1508">    dev-&gt;rawoverexposed.floating_window = gtk_popover_new(dev-&gt;rawoverexposed.button);</a>
<a name="ln1509">    gtk_widget_set_size_request(GTK_WIDGET(dev-&gt;rawoverexposed.floating_window), panel_width, -1);</a>
<a name="ln1510">#if GTK_CHECK_VERSION(3, 16, 0)</a>
<a name="ln1511">    g_object_set(G_OBJECT(dev-&gt;rawoverexposed.floating_window), &quot;transitions-enabled&quot;, FALSE, NULL);</a>
<a name="ln1512">#endif</a>
<a name="ln1513"> </a>
<a name="ln1514">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1515">    gtk_widget_set_margin_start(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1516">    gtk_widget_set_margin_end(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1517">    gtk_widget_set_margin_top(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1518">    gtk_widget_set_margin_bottom(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1519"> </a>
<a name="ln1520">    gtk_container_add(GTK_CONTAINER(dev-&gt;rawoverexposed.floating_window), vbox);</a>
<a name="ln1521"> </a>
<a name="ln1522">    /** let's fill the encapsulating widgets */</a>
<a name="ln1523">    /* mode of operation */</a>
<a name="ln1524">    GtkWidget *mode = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1525">    dt_bauhaus_widget_set_label(mode, NULL, _(&quot;mode&quot;));</a>
<a name="ln1526">    dt_bauhaus_combobox_add(mode, _(&quot;mark with CFA color&quot;));</a>
<a name="ln1527">    dt_bauhaus_combobox_add(mode, _(&quot;mark with solid color&quot;));</a>
<a name="ln1528">    dt_bauhaus_combobox_add(mode, _(&quot;false color&quot;));</a>
<a name="ln1529">    dt_bauhaus_combobox_set(mode, dev-&gt;rawoverexposed.mode);</a>
<a name="ln1530">    gtk_widget_set_tooltip_text(mode, _(&quot;select how to mark the clipped pixels&quot;));</a>
<a name="ln1531">    g_signal_connect(G_OBJECT(mode), &quot;value-changed&quot;, G_CALLBACK(rawoverexposed_mode_callback), dev);</a>
<a name="ln1532">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(mode), TRUE, TRUE, 0);</a>
<a name="ln1533">    gtk_widget_set_state_flags(mode, GTK_STATE_FLAG_SELECTED, TRUE);</a>
<a name="ln1534"> </a>
<a name="ln1535">    /* color scheme */</a>
<a name="ln1536">    GtkWidget *colorscheme = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1537">    dt_bauhaus_widget_set_label(colorscheme, NULL, _(&quot;color scheme&quot;));</a>
<a name="ln1538">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;red&quot;));</a>
<a name="ln1539">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;green&quot;));</a>
<a name="ln1540">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;blue&quot;));</a>
<a name="ln1541">    dt_bauhaus_combobox_add(colorscheme, C_(&quot;solidcolor&quot;, &quot;black&quot;));</a>
<a name="ln1542">    dt_bauhaus_combobox_set(colorscheme, dev-&gt;rawoverexposed.colorscheme);</a>
<a name="ln1543">    gtk_widget_set_tooltip_text(</a>
<a name="ln1544">        colorscheme,</a>
<a name="ln1545">        _(&quot;select the solid color to indicate over exposure.\nwill only be used if mode = mark with solid color&quot;));</a>
<a name="ln1546">    g_signal_connect(G_OBJECT(colorscheme), &quot;value-changed&quot;, G_CALLBACK(rawoverexposed_colorscheme_callback), dev);</a>
<a name="ln1547">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(colorscheme), TRUE, TRUE, 0);</a>
<a name="ln1548">    gtk_widget_set_state_flags(colorscheme, GTK_STATE_FLAG_SELECTED, TRUE);</a>
<a name="ln1549"> </a>
<a name="ln1550">    /* threshold */</a>
<a name="ln1551">    GtkWidget *threshold = dt_bauhaus_slider_new_with_range(NULL, 0.0, 2.0, 0.01, 1.0, 3);</a>
<a name="ln1552">    dt_bauhaus_slider_set(threshold, dev-&gt;rawoverexposed.threshold);</a>
<a name="ln1553">    dt_bauhaus_widget_set_label(threshold, NULL, _(&quot;clipping threshold&quot;));</a>
<a name="ln1554">    gtk_widget_set_tooltip_text(</a>
<a name="ln1555">        threshold, _(&quot;threshold of what shall be considered overexposed\n1.0 - white level\n0.0 - black level&quot;));</a>
<a name="ln1556">    g_signal_connect(G_OBJECT(threshold), &quot;value-changed&quot;, G_CALLBACK(rawoverexposed_threshold_callback), dev);</a>
<a name="ln1557">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(threshold), TRUE, TRUE, 0);</a>
<a name="ln1558">  }</a>
<a name="ln1559"> </a>
<a name="ln1560">  /* create overexposed popup tool */</a>
<a name="ln1561">  {</a>
<a name="ln1562">    // the button</a>
<a name="ln1563">    dev-&gt;overexposed.button</a>
<a name="ln1564">        = dtgtk_togglebutton_new(dtgtk_cairo_paint_overexposed, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1565">    gtk_widget_set_tooltip_text(dev-&gt;overexposed.button,</a>
<a name="ln1566">                                _(&quot;toggle over/under exposed indication\nright click for options&quot;));</a>
<a name="ln1567">    g_signal_connect(G_OBJECT(dev-&gt;overexposed.button), &quot;clicked&quot;,</a>
<a name="ln1568">                     G_CALLBACK(_overexposed_quickbutton_clicked), dev);</a>
<a name="ln1569">    g_signal_connect(G_OBJECT(dev-&gt;overexposed.button), &quot;button-press-event&quot;,</a>
<a name="ln1570">                     G_CALLBACK(_overexposed_quickbutton_pressed), dev);</a>
<a name="ln1571">    g_signal_connect(G_OBJECT(dev-&gt;overexposed.button), &quot;button-release-event&quot;,</a>
<a name="ln1572">                     G_CALLBACK(_overexposed_quickbutton_released), dev);</a>
<a name="ln1573">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;overexposed.button, DT_VIEW_DARKROOM);</a>
<a name="ln1574">    dt_gui_add_help_link(dev-&gt;overexposed.button, dt_get_help_url(&quot;overexposed&quot;));</a>
<a name="ln1575"> </a>
<a name="ln1576">    // and the popup window</a>
<a name="ln1577">    dev-&gt;overexposed.floating_window = gtk_popover_new(dev-&gt;overexposed.button);</a>
<a name="ln1578">    gtk_widget_set_size_request(GTK_WIDGET(dev-&gt;overexposed.floating_window), panel_width, -1);</a>
<a name="ln1579">#if GTK_CHECK_VERSION(3, 16, 0)</a>
<a name="ln1580">    g_object_set(G_OBJECT(dev-&gt;overexposed.floating_window), &quot;transitions-enabled&quot;, FALSE, NULL);</a>
<a name="ln1581">#endif</a>
<a name="ln1582"> </a>
<a name="ln1583">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1584">    gtk_widget_set_margin_start(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1585">    gtk_widget_set_margin_end(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1586">    gtk_widget_set_margin_top(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1587">    gtk_widget_set_margin_bottom(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1588"> </a>
<a name="ln1589">    gtk_container_add(GTK_CONTAINER(dev-&gt;overexposed.floating_window), vbox);</a>
<a name="ln1590"> </a>
<a name="ln1591">    /** let's fill the encapsulating widgets */</a>
<a name="ln1592">    /* color scheme */</a>
<a name="ln1593">    GtkWidget *colorscheme = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1594">    dt_bauhaus_widget_set_label(colorscheme, NULL, _(&quot;color scheme&quot;));</a>
<a name="ln1595">    dt_bauhaus_combobox_add(colorscheme, _(&quot;black &amp; white&quot;));</a>
<a name="ln1596">    dt_bauhaus_combobox_add(colorscheme, _(&quot;red &amp; blue&quot;));</a>
<a name="ln1597">    dt_bauhaus_combobox_add(colorscheme, _(&quot;purple &amp; green&quot;));</a>
<a name="ln1598">    dt_bauhaus_combobox_set(colorscheme, dev-&gt;overexposed.colorscheme);</a>
<a name="ln1599">    gtk_widget_set_tooltip_text(colorscheme, _(&quot;select colors to indicate over/under exposure&quot;));</a>
<a name="ln1600">    g_signal_connect(G_OBJECT(colorscheme), &quot;value-changed&quot;, G_CALLBACK(colorscheme_callback), dev);</a>
<a name="ln1601">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(colorscheme), TRUE, TRUE, 0);</a>
<a name="ln1602">    gtk_widget_set_state_flags(colorscheme, GTK_STATE_FLAG_SELECTED, TRUE);</a>
<a name="ln1603"> </a>
<a name="ln1604">    /* lower */</a>
<a name="ln1605">    GtkWidget *lower = dt_bauhaus_slider_new_with_range(NULL, 0.0, 100.0, 0.1, 2.0, 2);</a>
<a name="ln1606">    dt_bauhaus_slider_set(lower, dev-&gt;overexposed.lower);</a>
<a name="ln1607">    dt_bauhaus_slider_set_format(lower, &quot;%.0f%%&quot;);</a>
<a name="ln1608">    dt_bauhaus_widget_set_label(lower, NULL, _(&quot;lower threshold&quot;));</a>
<a name="ln1609">    gtk_widget_set_tooltip_text(lower, _(&quot;threshold of what shall be considered underexposed&quot;));</a>
<a name="ln1610">    g_signal_connect(G_OBJECT(lower), &quot;value-changed&quot;, G_CALLBACK(lower_callback), dev);</a>
<a name="ln1611">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(lower), TRUE, TRUE, 0);</a>
<a name="ln1612"> </a>
<a name="ln1613">    /* upper */</a>
<a name="ln1614">    GtkWidget *upper = dt_bauhaus_slider_new_with_range(NULL, 0.0, 100.0, 0.1, 98.0, 2);</a>
<a name="ln1615">    dt_bauhaus_slider_set(upper, dev-&gt;overexposed.upper);</a>
<a name="ln1616">    dt_bauhaus_slider_set_format(upper, &quot;%.0f%%&quot;);</a>
<a name="ln1617">    dt_bauhaus_widget_set_label(upper, NULL, _(&quot;upper threshold&quot;));</a>
<a name="ln1618">    gtk_widget_set_tooltip_text(upper, _(&quot;threshold of what shall be considered overexposed&quot;));</a>
<a name="ln1619">    g_signal_connect(G_OBJECT(upper), &quot;value-changed&quot;, G_CALLBACK(upper_callback), dev);</a>
<a name="ln1620">    gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(upper), TRUE, TRUE, 0);</a>
<a name="ln1621">  }</a>
<a name="ln1622"> </a>
<a name="ln1623">  /* create profile popup tool &amp; buttons (softproof + gamut) */</a>
<a name="ln1624">  {</a>
<a name="ln1625">    // the softproof button</a>
<a name="ln1626">    dev-&gt;profile.softproof_button =</a>
<a name="ln1627">      dtgtk_togglebutton_new(dtgtk_cairo_paint_softproof, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1628">    gtk_widget_set_tooltip_text(dev-&gt;profile.softproof_button,</a>
<a name="ln1629">                                _(&quot;toggle softproofing\nright click for profile options&quot;));</a>
<a name="ln1630">    g_signal_connect(G_OBJECT(dev-&gt;profile.softproof_button), &quot;clicked&quot;,</a>
<a name="ln1631">                     G_CALLBACK(_softproof_quickbutton_clicked), dev);</a>
<a name="ln1632">    g_signal_connect(G_OBJECT(dev-&gt;profile.softproof_button), &quot;button-press-event&quot;,</a>
<a name="ln1633">                     G_CALLBACK(_softproof_quickbutton_pressed), dev);</a>
<a name="ln1634">    g_signal_connect(G_OBJECT(dev-&gt;profile.softproof_button), &quot;button-release-event&quot;,</a>
<a name="ln1635">                     G_CALLBACK(_profile_quickbutton_released), dev);</a>
<a name="ln1636">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;profile.softproof_button, DT_VIEW_DARKROOM);</a>
<a name="ln1637">    dt_gui_add_help_link(dev-&gt;profile.softproof_button, dt_get_help_url(&quot;softproof&quot;));</a>
<a name="ln1638"> </a>
<a name="ln1639">    // the gamut check button</a>
<a name="ln1640">    dev-&gt;profile.gamut_button =</a>
<a name="ln1641">      dtgtk_togglebutton_new(dtgtk_cairo_paint_gamut_check, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln1642">    gtk_widget_set_tooltip_text(dev-&gt;profile.gamut_button,</a>
<a name="ln1643">                 _(&quot;toggle gamut checking\nright click for profile options&quot;));</a>
<a name="ln1644">    g_signal_connect(G_OBJECT(dev-&gt;profile.gamut_button), &quot;clicked&quot;,</a>
<a name="ln1645">                     G_CALLBACK(_gamut_quickbutton_clicked), dev);</a>
<a name="ln1646">    g_signal_connect(G_OBJECT(dev-&gt;profile.gamut_button), &quot;button-press-event&quot;,</a>
<a name="ln1647">                     G_CALLBACK(_gamut_quickbutton_pressed), dev);</a>
<a name="ln1648">    g_signal_connect(G_OBJECT(dev-&gt;profile.gamut_button), &quot;button-release-event&quot;,</a>
<a name="ln1649">                     G_CALLBACK(_profile_quickbutton_released), dev);</a>
<a name="ln1650">    dt_view_manager_module_toolbox_add(darktable.view_manager, dev-&gt;profile.gamut_button, DT_VIEW_DARKROOM);</a>
<a name="ln1651">    dt_gui_add_help_link(dev-&gt;profile.gamut_button, dt_get_help_url(&quot;gamut&quot;));</a>
<a name="ln1652"> </a>
<a name="ln1653">    // and the popup window, which is shared between the two profile buttons</a>
<a name="ln1654">    dev-&gt;profile.floating_window = gtk_popover_new(NULL);</a>
<a name="ln1655">    gtk_widget_set_size_request(GTK_WIDGET(dev-&gt;profile.floating_window), panel_width, -1);</a>
<a name="ln1656">#if GTK_CHECK_VERSION(3, 16, 0)</a>
<a name="ln1657">    g_object_set(G_OBJECT(dev-&gt;profile.floating_window), &quot;transitions-enabled&quot;, FALSE, NULL);</a>
<a name="ln1658">#endif</a>
<a name="ln1659"> </a>
<a name="ln1660">    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln1661">    gtk_widget_set_margin_start(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1662">    gtk_widget_set_margin_end(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1663">    gtk_widget_set_margin_top(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1664">    gtk_widget_set_margin_bottom(vbox, DT_PIXEL_APPLY_DPI(8));</a>
<a name="ln1665"> </a>
<a name="ln1666">    gtk_container_add(GTK_CONTAINER(dev-&gt;profile.floating_window), vbox);</a>
<a name="ln1667"> </a>
<a name="ln1668">    /** let's fill the encapsulating widgets */</a>
<a name="ln1669">    char datadir[PATH_MAX] = { 0 };</a>
<a name="ln1670">    char confdir[PATH_MAX] = { 0 };</a>
<a name="ln1671">    dt_loc_get_user_config_dir(confdir, sizeof(confdir));</a>
<a name="ln1672">    dt_loc_get_datadir(datadir, sizeof(datadir));</a>
<a name="ln1673">    const int force_lcms2 = dt_conf_get_bool(&quot;plugins/lighttable/export/force_lcms2&quot;);</a>
<a name="ln1674"> </a>
<a name="ln1675">    GtkWidget *display_intent = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1676">    dt_bauhaus_widget_set_label(display_intent, NULL, _(&quot;display intent&quot;));</a>
<a name="ln1677">    gtk_box_pack_start(GTK_BOX(vbox), display_intent, TRUE, TRUE, 0);</a>
<a name="ln1678">    dt_bauhaus_combobox_add(display_intent, _(&quot;perceptual&quot;));</a>
<a name="ln1679">    dt_bauhaus_combobox_add(display_intent, _(&quot;relative colorimetric&quot;));</a>
<a name="ln1680">    dt_bauhaus_combobox_add(display_intent, C_(&quot;rendering intent&quot;, &quot;saturation&quot;));</a>
<a name="ln1681">    dt_bauhaus_combobox_add(display_intent, _(&quot;absolute colorimetric&quot;));</a>
<a name="ln1682"> </a>
<a name="ln1683">    if(!force_lcms2)</a>
<a name="ln1684">    {</a>
<a name="ln1685">      gtk_widget_set_no_show_all(display_intent, TRUE);</a>
<a name="ln1686">      gtk_widget_set_visible(display_intent, FALSE);</a>
<a name="ln1687">    }</a>
<a name="ln1688"> </a>
<a name="ln1689">    GtkWidget *display_profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1690">    GtkWidget *softproof_profile = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln1691">    dt_bauhaus_widget_set_label(softproof_profile, NULL, _(&quot;softproof profile&quot;));</a>
<a name="ln1692">    dt_bauhaus_widget_set_label(display_profile, NULL, _(&quot;display profile&quot;));</a>
<a name="ln1693">    gtk_box_pack_start(GTK_BOX(vbox), softproof_profile, TRUE, TRUE, 0);</a>
<a name="ln1694">    gtk_box_pack_start(GTK_BOX(vbox), display_profile, TRUE, TRUE, 0);</a>
<a name="ln1695"> </a>
<a name="ln1696">    GList *l = darktable.color_profiles-&gt;profiles;</a>
<a name="ln1697">    while(l)</a>
<a name="ln1698">    {</a>
<a name="ln1699">      dt_colorspaces_color_profile_t *prof = (dt_colorspaces_color_profile_t *)l-&gt;data;</a>
<a name="ln1700">      if(prof-&gt;display_pos &gt; -1)</a>
<a name="ln1701">      {</a>
<a name="ln1702">        dt_bauhaus_combobox_add(display_profile, prof-&gt;name);</a>
<a name="ln1703">        if(prof-&gt;type == darktable.color_profiles-&gt;display_type</a>
<a name="ln1704">          &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln1705">              || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;display_filename)))</a>
<a name="ln1706">        {</a>
<a name="ln1707">          dt_bauhaus_combobox_set(display_profile, prof-&gt;display_pos);</a>
<a name="ln1708">        }</a>
<a name="ln1709">      }</a>
<a name="ln1710">      // the system display profile is only suitable for display purposes</a>
<a name="ln1711">      if(prof-&gt;out_pos &gt; -1)</a>
<a name="ln1712">      {</a>
<a name="ln1713">        dt_bauhaus_combobox_add(softproof_profile, prof-&gt;name);</a>
<a name="ln1714">        if(prof-&gt;type == darktable.color_profiles-&gt;softproof_type</a>
<a name="ln1715">          &amp;&amp; (prof-&gt;type != DT_COLORSPACE_FILE</a>
<a name="ln1716">              || !strcmp(prof-&gt;filename, darktable.color_profiles-&gt;softproof_filename)))</a>
<a name="ln1717">          dt_bauhaus_combobox_set(softproof_profile, prof-&gt;out_pos);</a>
<a name="ln1718">      }</a>
<a name="ln1719">      l = g_list_next(l);</a>
<a name="ln1720">    }</a>
<a name="ln1721"> </a>
<a name="ln1722">    char *system_profile_dir = g_build_filename(datadir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1723">    char *user_profile_dir = g_build_filename(confdir, &quot;color&quot;, &quot;out&quot;, NULL);</a>
<a name="ln1724">    char *tooltip = g_strdup_printf(_(&quot;display ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1725">    gtk_widget_set_tooltip_text(display_profile, tooltip);</a>
<a name="ln1726">    g_free(tooltip);</a>
<a name="ln1727">    tooltip = g_strdup_printf(_(&quot;softproof ICC profiles in %s or %s&quot;), user_profile_dir, system_profile_dir);</a>
<a name="ln1728">    gtk_widget_set_tooltip_text(softproof_profile, tooltip);</a>
<a name="ln1729">    g_free(tooltip);</a>
<a name="ln1730">    g_free(system_profile_dir);</a>
<a name="ln1731">    g_free(user_profile_dir);</a>
<a name="ln1732"> </a>
<a name="ln1733">    g_signal_connect(G_OBJECT(display_intent), &quot;value-changed&quot;, G_CALLBACK(display_intent_callback), dev);</a>
<a name="ln1734">    g_signal_connect(G_OBJECT(display_profile), &quot;value-changed&quot;, G_CALLBACK(display_profile_callback), dev);</a>
<a name="ln1735">    g_signal_connect(G_OBJECT(softproof_profile), &quot;value-changed&quot;, G_CALLBACK(softproof_profile_callback), dev);</a>
<a name="ln1736"> </a>
<a name="ln1737">    _update_softproof_gamut_checking(dev);</a>
<a name="ln1738"> </a>
<a name="ln1739">    // update the gui when the preferences changed (i.e. show intent when using lcms2)</a>
<a name="ln1740">    dt_control_signal_connect(darktable.signals, DT_SIGNAL_PREFERENCES_CHANGE,</a>
<a name="ln1741">                              G_CALLBACK(_preference_changed), (gpointer)display_intent);</a>
<a name="ln1742">  }</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">void enter(dt_view_t *self)</a>
<a name="ln1746">{</a>
<a name="ln1747">  // clean the undo list</a>
<a name="ln1748">  dt_undo_clear(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln1749"> </a>
<a name="ln1750">  /* connect to ui pipe finished signal for redraw */</a>
<a name="ln1751">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_UI_PIPE_FINISHED,</a>
<a name="ln1752">                            G_CALLBACK(_darkroom_ui_pipe_finish_signal_callback), (gpointer)self);</a>
<a name="ln1753"> </a>
<a name="ln1754">  dt_print(DT_DEBUG_CONTROL, &quot;[run_job+] 11 %f in darkroom mode\n&quot;, dt_get_wtime());</a>
<a name="ln1755">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln1756">  if(!dev-&gt;form_gui)</a>
<a name="ln1757">  {</a>
<a name="ln1758">    dev-&gt;form_gui = (dt_masks_form_gui_t *)calloc(1, sizeof(dt_masks_form_gui_t));</a>
<a name="ln1759">    dt_masks_init_form_gui(dev-&gt;form_gui);</a>
<a name="ln1760">  }</a>
<a name="ln1761">  dt_masks_change_form_gui(NULL);</a>
<a name="ln1762">  dev-&gt;form_gui-&gt;pipe_hash = 0;</a>
<a name="ln1763">  dev-&gt;form_gui-&gt;formid = 0;</a>
<a name="ln1764">  dev-&gt;gui_leaving = 0;</a>
<a name="ln1765">  dev-&gt;gui_module = NULL;</a>
<a name="ln1766"> </a>
<a name="ln1767">  select_this_image(dev-&gt;image_storage.id);</a>
<a name="ln1768"> </a>
<a name="ln1769">  dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln1770">  dt_control_set_dev_zoom_x(0);</a>
<a name="ln1771">  dt_control_set_dev_zoom_y(0);</a>
<a name="ln1772">  dt_control_set_dev_closeup(0);</a>
<a name="ln1773"> </a>
<a name="ln1774">  // take a copy of the image struct for convenience.</a>
<a name="ln1775"> </a>
<a name="ln1776">  dt_dev_load_image(darktable.develop, dev-&gt;image_storage.id);</a>
<a name="ln1777"> </a>
<a name="ln1778"> </a>
<a name="ln1779">  /*</a>
<a name="ln1780">   * add IOP modules to plugin list</a>
<a name="ln1781">   */</a>
<a name="ln1782">  // avoid triggering of events before plugin is ready:</a>
<a name="ln1783">  darktable.gui-&gt;reset = 1;</a>
<a name="ln1784">  char option[1024];</a>
<a name="ln1785">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln1786">  while(modules)</a>
<a name="ln1787">  {</a>
<a name="ln1788">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1789"> </a>
<a name="ln1790">    /* initialize gui if iop have one defined */</a>
<a name="ln1791">    if(!dt_iop_is_hidden(module))</a>
<a name="ln1792">    {</a>
<a name="ln1793">      module-&gt;gui_init(module);</a>
<a name="ln1794">      dt_iop_reload_defaults(module);</a>
<a name="ln1795"> </a>
<a name="ln1796">      /* add module to right panel */</a>
<a name="ln1797">      GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln1798">      dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln1799"> </a>
<a name="ln1800">      snprintf(option, sizeof(option), &quot;plugins/darkroom/%s/expanded&quot;, module-&gt;op);</a>
<a name="ln1801">      dt_iop_gui_set_expanded(module, dt_conf_get_bool(option), FALSE);</a>
<a name="ln1802">    }</a>
<a name="ln1803"> </a>
<a name="ln1804">    /* setup key accelerators */</a>
<a name="ln1805">    module-&gt;accel_closures = NULL;</a>
<a name="ln1806">    if(module-&gt;connect_key_accels) module-&gt;connect_key_accels(module);</a>
<a name="ln1807">    dt_iop_connect_common_accels(module);</a>
<a name="ln1808"> </a>
<a name="ln1809">    modules = g_list_previous(modules);</a>
<a name="ln1810">  }</a>
<a name="ln1811">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1812"> </a>
<a name="ln1813">  /* signal that darktable.develop is initialized and ready to be used */</a>
<a name="ln1814">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_INITIALIZE);</a>
<a name="ln1815"> </a>
<a name="ln1816">  // synch gui and flag pipe as dirty</a>
<a name="ln1817">  // this is done here and not in dt_read_history, as it would else be triggered before module-&gt;gui_init.</a>
<a name="ln1818">  dt_dev_pop_history_items(dev, dev-&gt;history_end);</a>
<a name="ln1819"> </a>
<a name="ln1820">  /* ensure that filmstrip shows current image */</a>
<a name="ln1821">  dt_view_filmstrip_scroll_to_image(darktable.view_manager, dev-&gt;image_storage.id, FALSE);</a>
<a name="ln1822"> </a>
<a name="ln1823">  // switch on groups as they were last time:</a>
<a name="ln1824">  dt_dev_modulegroups_set(dev, dt_conf_get_int(&quot;plugins/darkroom/groups&quot;));</a>
<a name="ln1825"> </a>
<a name="ln1826">  // make signals work again:</a>
<a name="ln1827">  darktable.gui-&gt;reset = 0;</a>
<a name="ln1828"> </a>
<a name="ln1829">  // get last active plugin:</a>
<a name="ln1830">  gchar *active_plugin = dt_conf_get_string(&quot;plugins/darkroom/active&quot;);</a>
<a name="ln1831">  if(active_plugin)</a>
<a name="ln1832">  {</a>
<a name="ln1833">    modules = dev-&gt;iop;</a>
<a name="ln1834">    while(modules)</a>
<a name="ln1835">    {</a>
<a name="ln1836">      dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln1837">      if(!strcmp(module-&gt;op, active_plugin)) dt_iop_request_focus(module);</a>
<a name="ln1838">      modules = g_list_next(modules);</a>
<a name="ln1839">    }</a>
<a name="ln1840">    g_free(active_plugin);</a>
<a name="ln1841">  }</a>
<a name="ln1842">  dt_dev_masks_list_change(dev);</a>
<a name="ln1843"> </a>
<a name="ln1844">  // image should be there now.</a>
<a name="ln1845">  float zoom_x, zoom_y;</a>
<a name="ln1846">  dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, DT_ZOOM_FIT, 0, NULL, NULL);</a>
<a name="ln1847">  dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln1848">  dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln1849"> </a>
<a name="ln1850">  /* connect signal for filmstrip image activate */</a>
<a name="ln1851">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_VIEWMANAGER_FILMSTRIP_ACTIVATE,</a>
<a name="ln1852">                            G_CALLBACK(_view_darkroom_filmstrip_activate_callback), self);</a>
<a name="ln1853"> </a>
<a name="ln1854">  // prefetch next few from first selected image on.</a>
<a name="ln1855">  dt_view_filmstrip_prefetch();</a>
<a name="ln1856"> </a>
<a name="ln1857">  dt_collection_hint_message(darktable.collection);</a>
<a name="ln1858"> </a>
<a name="ln1859">  char *scrollbars_conf = dt_conf_get_string(&quot;scrollbars&quot;);</a>
<a name="ln1860"> </a>
<a name="ln1861">  gboolean scrollbars_visible = FALSE;</a>
<a name="ln1862">  if(scrollbars_conf)</a>
<a name="ln1863">  {</a>
<a name="ln1864">    if(!strcmp(scrollbars_conf, &quot;lighttable + darkroom&quot;))</a>
<a name="ln1865">      scrollbars_visible = TRUE;</a>
<a name="ln1866">    g_free(scrollbars_conf);</a>
<a name="ln1867">  }</a>
<a name="ln1868"> </a>
<a name="ln1869">  dt_ui_scrollbars_show(darktable.gui-&gt;ui, scrollbars_visible);</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">void leave(dt_view_t *self)</a>
<a name="ln1873">{</a>
<a name="ln1874">  /* disconnect from filmstrip image activate */</a>
<a name="ln1875">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_view_darkroom_filmstrip_activate_callback),</a>
<a name="ln1876">                               (gpointer)self);</a>
<a name="ln1877"> </a>
<a name="ln1878">  /* disconnect from pipe finish signal */</a>
<a name="ln1879">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_darkroom_ui_pipe_finish_signal_callback),</a>
<a name="ln1880">                               (gpointer)self);</a>
<a name="ln1881"> </a>
<a name="ln1882">  // store groups for next time:</a>
<a name="ln1883">  dt_conf_set_int(&quot;plugins/darkroom/groups&quot;, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln1884"> </a>
<a name="ln1885">  // store last active plugin:</a>
<a name="ln1886">  if(darktable.develop-&gt;gui_module)</a>
<a name="ln1887">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, darktable.develop-&gt;gui_module-&gt;op);</a>
<a name="ln1888">  else</a>
<a name="ln1889">    dt_conf_set_string(&quot;plugins/darkroom/active&quot;, &quot;&quot;);</a>
<a name="ln1890"> </a>
<a name="ln1891">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln1892"> </a>
<a name="ln1893">  // tag image as changed</a>
<a name="ln1894">  // TODO: only tag the image when there was a real change.</a>
<a name="ln1895">  guint tagid = 0;</a>
<a name="ln1896">  dt_tag_new_from_gui(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln1897">  dt_tag_attach(tagid, dev-&gt;image_storage.id);</a>
<a name="ln1898">  // commit image ops to db</a>
<a name="ln1899">  dt_dev_write_history(dev);</a>
<a name="ln1900"> </a>
<a name="ln1901">  // be sure light table will regenerate the thumbnail:</a>
<a name="ln1902">  // TODO: only if changed!</a>
<a name="ln1903">  // if()</a>
<a name="ln1904">  {</a>
<a name="ln1905">    dt_mipmap_cache_remove(darktable.mipmap_cache, dev-&gt;image_storage.id);</a>
<a name="ln1906">    // dump new xmp data</a>
<a name="ln1907">    dt_image_synch_xmp(dev-&gt;image_storage.id);</a>
<a name="ln1908">  }</a>
<a name="ln1909"> </a>
<a name="ln1910">  // update possibly changed aspect ratio</a>
<a name="ln1911">  dt_image_set_aspect_ratio(dev-&gt;image_storage.id);</a>
<a name="ln1912"> </a>
<a name="ln1913">  // clear gui.</a>
<a name="ln1914"> </a>
<a name="ln1915">  dt_pthread_mutex_lock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln1916">  dt_pthread_mutex_lock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln1917"> </a>
<a name="ln1918">  dev-&gt;gui_leaving = 1;</a>
<a name="ln1919"> </a>
<a name="ln1920">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;pipe);</a>
<a name="ln1921">  dt_dev_pixelpipe_cleanup_nodes(dev-&gt;preview_pipe);</a>
<a name="ln1922"> </a>
<a name="ln1923">  dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1924">  while(dev-&gt;history)</a>
<a name="ln1925">  {</a>
<a name="ln1926">    dt_dev_history_item_t *hist = (dt_dev_history_item_t *)(dev-&gt;history-&gt;data);</a>
<a name="ln1927">    // printf(&quot;removing history item %d - %s, data %f %f\n&quot;, hist-&gt;module-&gt;instance, hist-&gt;module-&gt;op, *(float</a>
<a name="ln1928">    // *)hist-&gt;params, *((float *)hist-&gt;params+1));</a>
<a name="ln1929">    free(hist-&gt;params);</a>
<a name="ln1930">    hist-&gt;params = NULL;</a>
<a name="ln1931">    free(hist-&gt;blend_params);</a>
<a name="ln1932">    hist-&gt;blend_params = NULL;</a>
<a name="ln1933">    free(hist);</a>
<a name="ln1934">    dev-&gt;history = g_list_delete_link(dev-&gt;history, dev-&gt;history);</a>
<a name="ln1935">  }</a>
<a name="ln1936"> </a>
<a name="ln1937">  while(dev-&gt;iop)</a>
<a name="ln1938">  {</a>
<a name="ln1939">    dt_iop_module_t *module = (dt_iop_module_t *)(dev-&gt;iop-&gt;data);</a>
<a name="ln1940">    if(!dt_iop_is_hidden(module)) dt_iop_gui_cleanup_module(module);</a>
<a name="ln1941"> </a>
<a name="ln1942">    dt_dev_cleanup_module_accels(module);</a>
<a name="ln1943">    module-&gt;accel_closures = NULL;</a>
<a name="ln1944">    dt_iop_cleanup_module(module);</a>
<a name="ln1945">    free(module);</a>
<a name="ln1946">    dev-&gt;iop = g_list_delete_link(dev-&gt;iop, dev-&gt;iop);</a>
<a name="ln1947">  }</a>
<a name="ln1948">  while(dev-&gt;alliop)</a>
<a name="ln1949">  {</a>
<a name="ln1950">    dt_iop_cleanup_module((dt_iop_module_t *)dev-&gt;alliop-&gt;data);</a>
<a name="ln1951">    free(dev-&gt;alliop-&gt;data);</a>
<a name="ln1952">    dev-&gt;alliop = g_list_delete_link(dev-&gt;alliop, dev-&gt;alliop);</a>
<a name="ln1953">  }</a>
<a name="ln1954"> </a>
<a name="ln1955">  dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln1956"> </a>
<a name="ln1957">  dt_pthread_mutex_unlock(&amp;dev-&gt;pipe_mutex);</a>
<a name="ln1958">  dt_pthread_mutex_unlock(&amp;dev-&gt;preview_pipe_mutex);</a>
<a name="ln1959"> </a>
<a name="ln1960">  // cleanup visible masks</a>
<a name="ln1961">  if(dev-&gt;form_gui)</a>
<a name="ln1962">  {</a>
<a name="ln1963">    dev-&gt;gui_module = NULL; // modules have already been free()</a>
<a name="ln1964">    dt_masks_clear_form_gui(dev);</a>
<a name="ln1965">    free(dev-&gt;form_gui);</a>
<a name="ln1966">    dev-&gt;form_gui = NULL;</a>
<a name="ln1967">    dt_masks_change_form_gui(NULL);</a>
<a name="ln1968">  }</a>
<a name="ln1969"> </a>
<a name="ln1970">  // take care of the overexposed window</a>
<a name="ln1971">  if(dev-&gt;overexposed.timeout &gt; 0) g_source_remove(dev-&gt;overexposed.timeout);</a>
<a name="ln1972">  gtk_widget_hide(dev-&gt;overexposed.floating_window);</a>
<a name="ln1973">  gtk_widget_hide(dev-&gt;profile.floating_window);</a>
<a name="ln1974"> </a>
<a name="ln1975">  dt_ui_scrollbars_show(darktable.gui-&gt;ui, FALSE);</a>
<a name="ln1976"> </a>
<a name="ln1977">  darktable.develop-&gt;image_storage.id = -1;</a>
<a name="ln1978"> </a>
<a name="ln1979">  dt_print(DT_DEBUG_CONTROL, &quot;[run_job-] 11 %f in darkroom mode\n&quot;, dt_get_wtime());</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">void mouse_leave(dt_view_t *self)</a>
<a name="ln1983">{</a>
<a name="ln1984">  // if we are not hovering over a thumbnail in the filmstrip -&gt; show metadata of opened image.</a>
<a name="ln1985">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln1986">  dt_control_set_mouse_over_id(dev-&gt;image_storage.id);</a>
<a name="ln1987"> </a>
<a name="ln1988">  // masks</a>
<a name="ln1989">  int handled = dt_masks_events_mouse_leave(dev-&gt;gui_module);</a>
<a name="ln1990">  if(handled) return;</a>
<a name="ln1991">  // module</a>
<a name="ln1992">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;mouse_leave)</a>
<a name="ln1993">    handled = dev-&gt;gui_module-&gt;mouse_leave(dev-&gt;gui_module);</a>
<a name="ln1994"> </a>
<a name="ln1995">  // reset any changes the selected plugin might have made.</a>
<a name="ln1996">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">void mouse_enter(dt_view_t *self)</a>
<a name="ln2000">{</a>
<a name="ln2001">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2002">  // masks</a>
<a name="ln2003">  dt_masks_events_mouse_enter(dev-&gt;gui_module);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">void mouse_moved(dt_view_t *self, double x, double y, double pressure, int which)</a>
<a name="ln2007">{</a>
<a name="ln2008">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2009">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2010">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2011">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2012"> </a>
<a name="ln2013">  // if we are not hovering over a thumbnail in the filmstrip -&gt; show metadata of opened image.</a>
<a name="ln2014">  int32_t mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln2015">  if(mouse_over_id == -1)</a>
<a name="ln2016">  {</a>
<a name="ln2017">    mouse_over_id = dev-&gt;image_storage.id;</a>
<a name="ln2018">    dt_control_set_mouse_over_id(mouse_over_id);</a>
<a name="ln2019">  }</a>
<a name="ln2020"> </a>
<a name="ln2021">  dt_control_t *ctl = darktable.control;</a>
<a name="ln2022">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2023">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2024">  int32_t offx = 0.0f, offy = 0.0f;</a>
<a name="ln2025">  if(width_i &gt; capwd) offx = (capwd - width_i) * .5f;</a>
<a name="ln2026">  if(height_i &gt; capht) offy = (capht - height_i) * .5f;</a>
<a name="ln2027">  int handled = 0;</a>
<a name="ln2028">  x += offx;</a>
<a name="ln2029">  y += offy;</a>
<a name="ln2030"> </a>
<a name="ln2031">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF &amp;&amp; ctl-&gt;button_down</a>
<a name="ln2032">     &amp;&amp; ctl-&gt;button_down_which == 1)</a>
<a name="ln2033">  {</a>
<a name="ln2034">    // module requested a color box</a>
<a name="ln2035">    float zoom_x, zoom_y, bzoom_x, bzoom_y;</a>
<a name="ln2036">    dt_dev_get_pointer_zoom_pos(dev, x, y, &amp;zoom_x, &amp;zoom_y);</a>
<a name="ln2037">    dt_dev_get_pointer_zoom_pos(dev, ctl-&gt;button_x + offx, ctl-&gt;button_y + offy, &amp;bzoom_x, &amp;bzoom_y);</a>
<a name="ln2038">    if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln2039">    {</a>
<a name="ln2040">      dev-&gt;gui_module-&gt;color_picker_box[0] = fmaxf(0.0, fminf(.5f + bzoom_x, .5f + zoom_x));</a>
<a name="ln2041">      dev-&gt;gui_module-&gt;color_picker_box[1] = fmaxf(0.0, fminf(.5f + bzoom_y, .5f + zoom_y));</a>
<a name="ln2042">      dev-&gt;gui_module-&gt;color_picker_box[2] = fminf(1.0, fmaxf(.5f + bzoom_x, .5f + zoom_x));</a>
<a name="ln2043">      dev-&gt;gui_module-&gt;color_picker_box[3] = fminf(1.0, fmaxf(.5f + bzoom_y, .5f + zoom_y));</a>
<a name="ln2044">    }</a>
<a name="ln2045">    else</a>
<a name="ln2046">    {</a>
<a name="ln2047">      dev-&gt;gui_module-&gt;color_picker_point[0] = .5f + zoom_x;</a>
<a name="ln2048">      dev-&gt;gui_module-&gt;color_picker_point[1] = .5f + zoom_y;</a>
<a name="ln2049">    }</a>
<a name="ln2050"> </a>
<a name="ln2051">    dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln2052">    dt_dev_invalidate_all(dev);</a>
<a name="ln2053">    dt_control_queue_redraw();</a>
<a name="ln2054">    return;</a>
<a name="ln2055">  }</a>
<a name="ln2056">  // masks</a>
<a name="ln2057">  handled = dt_masks_events_mouse_moved(dev-&gt;gui_module, x, y, pressure, which);</a>
<a name="ln2058">  if(handled) return;</a>
<a name="ln2059">  // module</a>
<a name="ln2060">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;mouse_moved)</a>
<a name="ln2061">    handled = dev-&gt;gui_module-&gt;mouse_moved(dev-&gt;gui_module, x, y, pressure, which);</a>
<a name="ln2062">  if(handled) return;</a>
<a name="ln2063"> </a>
<a name="ln2064">  if(darktable.control-&gt;button_down &amp;&amp; darktable.control-&gt;button_down_which == 1)</a>
<a name="ln2065">  {</a>
<a name="ln2066">    // depending on dev_zoom, adjust dev_zoom_x/y.</a>
<a name="ln2067">    const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln2068">    const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln2069">    int procw, proch;</a>
<a name="ln2070">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2071">    const float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2072">    float old_zoom_x, old_zoom_y;</a>
<a name="ln2073">    old_zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2074">    old_zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2075">    float zx = old_zoom_x - (1.0 / scale) * (x - ctl-&gt;button_x - offx) / procw;</a>
<a name="ln2076">    float zy = old_zoom_y - (1.0 / scale) * (y - ctl-&gt;button_y - offy) / proch;</a>
<a name="ln2077">    dt_dev_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, NULL, NULL);</a>
<a name="ln2078">    dt_control_set_dev_zoom_x(zx);</a>
<a name="ln2079">    dt_control_set_dev_zoom_y(zy);</a>
<a name="ln2080">    ctl-&gt;button_x = x - offx;</a>
<a name="ln2081">    ctl-&gt;button_y = y - offy;</a>
<a name="ln2082">    dt_dev_invalidate(dev);</a>
<a name="ln2083">    dt_control_queue_redraw();</a>
<a name="ln2084">  }</a>
<a name="ln2085">}</a>
<a name="ln2086"> </a>
<a name="ln2087"> </a>
<a name="ln2088">int button_released(dt_view_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln2089">{</a>
<a name="ln2090">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2091">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2092">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2093">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln2094">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2095">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2096">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln2097">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln2098"> </a>
<a name="ln2099">  int handled = 0;</a>
<a name="ln2100">  // masks</a>
<a name="ln2101">  if(dev-&gt;form_visible) handled = dt_masks_events_button_released(dev-&gt;gui_module, x, y, which, state);</a>
<a name="ln2102">  if(handled) return handled;</a>
<a name="ln2103">  // module</a>
<a name="ln2104">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;button_released)</a>
<a name="ln2105">    handled = dev-&gt;gui_module-&gt;button_released(dev-&gt;gui_module, x, y, which, state);</a>
<a name="ln2106">  if(handled) return handled;</a>
<a name="ln2107">  if(which == 1) dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln2108">  return 1;</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111"> </a>
<a name="ln2112">int button_pressed(dt_view_t *self, double x, double y, double pressure, int which, int type, uint32_t state)</a>
<a name="ln2113">{</a>
<a name="ln2114">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2115">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2116">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2117">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2118">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2119">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2120">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln2121">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln2122"> </a>
<a name="ln2123">  int handled = 0;</a>
<a name="ln2124">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;request_color_pick != DT_REQUEST_COLORPICK_OFF &amp;&amp; which == 1)</a>
<a name="ln2125">  {</a>
<a name="ln2126">    float zoom_x, zoom_y;</a>
<a name="ln2127">    dt_dev_get_pointer_zoom_pos(dev, x, y, &amp;zoom_x, &amp;zoom_y);</a>
<a name="ln2128">    if(darktable.lib-&gt;proxy.colorpicker.size)</a>
<a name="ln2129">    {</a>
<a name="ln2130">      dev-&gt;gui_module-&gt;color_picker_box[0] = .5f + zoom_x;</a>
<a name="ln2131">      dev-&gt;gui_module-&gt;color_picker_box[1] = .5f + zoom_y;</a>
<a name="ln2132">      dev-&gt;gui_module-&gt;color_picker_box[2] = .5f + zoom_x;</a>
<a name="ln2133">      dev-&gt;gui_module-&gt;color_picker_box[3] = .5f + zoom_y;</a>
<a name="ln2134">    }</a>
<a name="ln2135">    else</a>
<a name="ln2136">    {</a>
<a name="ln2137">      dev-&gt;gui_module-&gt;color_picker_point[0] = .5f + zoom_x;</a>
<a name="ln2138">      dev-&gt;gui_module-&gt;color_picker_point[1] = .5f + zoom_y;</a>
<a name="ln2139">      dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_SYNCH;</a>
<a name="ln2140">      dt_dev_invalidate_all(dev);</a>
<a name="ln2141">    }</a>
<a name="ln2142">    dt_control_queue_redraw();</a>
<a name="ln2143">    return 1;</a>
<a name="ln2144">  }</a>
<a name="ln2145">  // masks</a>
<a name="ln2146">  if(dev-&gt;form_visible)</a>
<a name="ln2147">    handled = dt_masks_events_button_pressed(dev-&gt;gui_module, x, y, pressure, which, type, state);</a>
<a name="ln2148">  if(handled) return handled;</a>
<a name="ln2149">  // module</a>
<a name="ln2150">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;button_pressed)</a>
<a name="ln2151">    handled = dev-&gt;gui_module-&gt;button_pressed(dev-&gt;gui_module, x, y, pressure, which, type, state);</a>
<a name="ln2152">  if(handled) return handled;</a>
<a name="ln2153"> </a>
<a name="ln2154">  if(which == 1 &amp;&amp; type == GDK_2BUTTON_PRESS) return 0;</a>
<a name="ln2155">  if(which == 1)</a>
<a name="ln2156">  {</a>
<a name="ln2157">    dt_control_change_cursor(GDK_HAND1);</a>
<a name="ln2158">    return 1;</a>
<a name="ln2159">  }</a>
<a name="ln2160">  if(which == 2)</a>
<a name="ln2161">  {</a>
<a name="ln2162">    // zoom to 1:1 2:1 and back</a>
<a name="ln2163">    dt_dev_zoom_t zoom;</a>
<a name="ln2164">    int closeup, procw, proch;</a>
<a name="ln2165">    float zoom_x, zoom_y;</a>
<a name="ln2166">    zoom = dt_control_get_dev_zoom();</a>
<a name="ln2167">    closeup = dt_control_get_dev_closeup();</a>
<a name="ln2168">    zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2169">    zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2170">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2171">    const float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2172">    zoom_x += (1.0 / scale) * (x - .5f * dev-&gt;width) / procw;</a>
<a name="ln2173">    zoom_y += (1.0 / scale) * (y - .5f * dev-&gt;height) / proch;</a>
<a name="ln2174">    if(zoom == DT_ZOOM_1)</a>
<a name="ln2175">    {</a>
<a name="ln2176">      if(!closeup)</a>
<a name="ln2177">        closeup = 1;</a>
<a name="ln2178">      else</a>
<a name="ln2179">      {</a>
<a name="ln2180">        zoom = DT_ZOOM_FIT;</a>
<a name="ln2181">        zoom_x = zoom_y = 0.0f;</a>
<a name="ln2182">        closeup = 0;</a>
<a name="ln2183">      }</a>
<a name="ln2184">    }</a>
<a name="ln2185">    else</a>
<a name="ln2186">      zoom = DT_ZOOM_1;</a>
<a name="ln2187">    dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln2188">    dt_control_set_dev_zoom(zoom);</a>
<a name="ln2189">    dt_control_set_dev_closeup(closeup);</a>
<a name="ln2190">    dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln2191">    dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln2192">    dt_dev_invalidate(dev);</a>
<a name="ln2193">    return 1;</a>
<a name="ln2194">  }</a>
<a name="ln2195">  return 0;</a>
<a name="ln2196">}</a>
<a name="ln2197"> </a>
<a name="ln2198">void scrollbar_changed(dt_view_t *self, double x, double y)</a>
<a name="ln2199">{</a>
<a name="ln2200">  dt_control_set_dev_zoom_x(x);</a>
<a name="ln2201">  dt_control_set_dev_zoom_y(y);</a>
<a name="ln2202"> </a>
<a name="ln2203">  /* redraw pipe */</a>
<a name="ln2204">  dt_dev_invalidate(darktable.develop);</a>
<a name="ln2205">  dt_control_queue_redraw();</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208">void scrolled(dt_view_t *self, double x, double y, int up, int state)</a>
<a name="ln2209">{</a>
<a name="ln2210">  const int32_t tb = DT_PIXEL_APPLY_DPI(dt_conf_get_int(&quot;plugins/darkroom/ui/border_size&quot;));</a>
<a name="ln2211">  const int32_t capwd = self-&gt;width  - 2*tb;</a>
<a name="ln2212">  const int32_t capht = self-&gt;height - 2*tb;</a>
<a name="ln2213">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2214">  const int32_t width_i = self-&gt;width;</a>
<a name="ln2215">  const int32_t height_i = self-&gt;height;</a>
<a name="ln2216">  if(width_i &gt; capwd) x += (capwd - width_i) * .5f;</a>
<a name="ln2217">  if(height_i &gt; capht) y += (capht - height_i) * .5f;</a>
<a name="ln2218"> </a>
<a name="ln2219">  int handled = 0;</a>
<a name="ln2220">  // masks</a>
<a name="ln2221">  if(dev-&gt;form_visible) handled = dt_masks_events_mouse_scrolled(dev-&gt;gui_module, x, y, up, state);</a>
<a name="ln2222">  if(handled) return;</a>
<a name="ln2223">  // module</a>
<a name="ln2224">  if(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;scrolled)</a>
<a name="ln2225">    handled = dev-&gt;gui_module-&gt;scrolled(dev-&gt;gui_module, x, y, up, state);</a>
<a name="ln2226">  if(handled) return;</a>
<a name="ln2227">  // free zoom</a>
<a name="ln2228">  dt_dev_zoom_t zoom;</a>
<a name="ln2229">  int closeup, procw, proch;</a>
<a name="ln2230">  float zoom_x, zoom_y;</a>
<a name="ln2231">  zoom = dt_control_get_dev_zoom();</a>
<a name="ln2232">  closeup = dt_control_get_dev_closeup();</a>
<a name="ln2233">  zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2234">  zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2235">  dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2236">  float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2237">  const float fitscale = dt_dev_get_zoom_scale(dev, DT_ZOOM_FIT, 1.0, 0);</a>
<a name="ln2238">  float oldscale = scale;</a>
<a name="ln2239"> </a>
<a name="ln2240">  // offset from center now (current zoom_{x,y} points there)</a>
<a name="ln2241">  float mouse_off_x = x - .5 * dev-&gt;width, mouse_off_y = y - .5 * dev-&gt;height;</a>
<a name="ln2242">  zoom_x += mouse_off_x / (procw * scale);</a>
<a name="ln2243">  zoom_y += mouse_off_y / (proch * scale);</a>
<a name="ln2244">  zoom = DT_ZOOM_FREE;</a>
<a name="ln2245">  closeup = 0;</a>
<a name="ln2246">  if(up)</a>
<a name="ln2247">  {</a>
<a name="ln2248">    if((scale == 1.0f || scale == 2.0f) &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)) return;</a>
<a name="ln2249">    if(scale &gt;= 16.0f)</a>
<a name="ln2250">      return;</a>
<a name="ln2251">    else if(scale &gt;= 8.0f)</a>
<a name="ln2252">      scale = 16.0;</a>
<a name="ln2253">    else if(scale &gt;= 4.0f)</a>
<a name="ln2254">      scale = 8.0;</a>
<a name="ln2255">    else if(scale &gt;= 2.0f)</a>
<a name="ln2256">      scale = 4.0;</a>
<a name="ln2257">    else if(scale &lt; fitscale)</a>
<a name="ln2258">      scale += .05f * (1.0f - fitscale);</a>
<a name="ln2259">    else</a>
<a name="ln2260">      scale += .1f * (1.0f - fitscale);</a>
<a name="ln2261">  }</a>
<a name="ln2262">  else</a>
<a name="ln2263">  {</a>
<a name="ln2264">    if(scale == fitscale &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK))</a>
<a name="ln2265">      return;</a>
<a name="ln2266">    else if(scale &lt; 0.5 * fitscale)</a>
<a name="ln2267">      return;</a>
<a name="ln2268">    else if(scale &lt;= fitscale)</a>
<a name="ln2269">      scale -= .05f * (1.0f - fitscale);</a>
<a name="ln2270">    else if(scale &lt;= 2.0f)</a>
<a name="ln2271">      scale -= .1f * (1.0f - fitscale);</a>
<a name="ln2272">    else if(scale &lt;= 4.0f)</a>
<a name="ln2273">      scale = 2.0f;</a>
<a name="ln2274">    else if(scale &lt;= 8.0f)</a>
<a name="ln2275">      scale = 4.0f;</a>
<a name="ln2276">    else</a>
<a name="ln2277">      scale = 8.0f;</a>
<a name="ln2278">  }</a>
<a name="ln2279">  // we want to be sure to stop at 1:1 and FIT levels</a>
<a name="ln2280">  if((scale - 1.0) * (oldscale - 1.0) &lt; 0) scale = 1.0f;</a>
<a name="ln2281">  if((scale - fitscale) * (oldscale - fitscale) &lt; 0) scale = fitscale;</a>
<a name="ln2282">  scale = fmaxf(fminf(scale, 16.0f), 0.5 * fitscale);</a>
<a name="ln2283"> </a>
<a name="ln2284">  // for 200% zoom we want pixel doubling instead of interpolation</a>
<a name="ln2285">  if(scale &gt; 15.9999f)</a>
<a name="ln2286">  {</a>
<a name="ln2287">    scale = 1.0f; // don't interpolate</a>
<a name="ln2288">    closeup = 4;  // enable closeup mode (pixel doubling)</a>
<a name="ln2289">  }</a>
<a name="ln2290">  else if(scale &gt; 7.9999f)</a>
<a name="ln2291">  {</a>
<a name="ln2292">    scale = 1.0f; // don't interpolate</a>
<a name="ln2293">    closeup = 3;  // enable closeup mode (pixel doubling)</a>
<a name="ln2294">  }</a>
<a name="ln2295">  else if(scale &gt; 3.9999f)</a>
<a name="ln2296">  {</a>
<a name="ln2297">    scale = 1.0f; // don't interpolate</a>
<a name="ln2298">    closeup = 2;  // enable closeup mode (pixel doubling)</a>
<a name="ln2299">  }</a>
<a name="ln2300">  else if(scale &gt; 1.9999f)</a>
<a name="ln2301">  {</a>
<a name="ln2302">    scale = 1.0f; // don't interpolate</a>
<a name="ln2303">    closeup = 1;  // enable closeup mode (pixel doubling)</a>
<a name="ln2304">  }</a>
<a name="ln2305"> </a>
<a name="ln2306">  if(fabsf(scale - 1.0f) &lt; 0.001f) zoom = DT_ZOOM_1;</a>
<a name="ln2307">  if(fabsf(scale - fitscale) &lt; 0.001f) zoom = DT_ZOOM_FIT;</a>
<a name="ln2308">  dt_control_set_dev_zoom_scale(scale);</a>
<a name="ln2309">  dt_control_set_dev_closeup(closeup);</a>
<a name="ln2310">  scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2311"> </a>
<a name="ln2312">  zoom_x -= mouse_off_x / (procw * scale);</a>
<a name="ln2313">  zoom_y -= mouse_off_y / (proch * scale);</a>
<a name="ln2314">  dt_dev_check_zoom_bounds(dev, &amp;zoom_x, &amp;zoom_y, zoom, closeup, NULL, NULL);</a>
<a name="ln2315">  dt_control_set_dev_zoom(zoom);</a>
<a name="ln2316">  dt_control_set_dev_zoom_x(zoom_x);</a>
<a name="ln2317">  dt_control_set_dev_zoom_y(zoom_y);</a>
<a name="ln2318"> </a>
<a name="ln2319">  dt_dev_invalidate(dev);</a>
<a name="ln2320"> </a>
<a name="ln2321">  dt_control_queue_redraw();</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324">int key_released(dt_view_t *self, guint key, guint state)</a>
<a name="ln2325">{</a>
<a name="ln2326">  const dt_control_accels_t *accels = &amp;darktable.control-&gt;accels;</a>
<a name="ln2327">  dt_develop_t *lib = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2328"> </a>
<a name="ln2329">  if(!darktable.control-&gt;key_accelerators_on)</a>
<a name="ln2330">    return 0;</a>
<a name="ln2331"> </a>
<a name="ln2332">  if(key == accels-&gt;darkroom_preview.accel_key &amp;&amp; state == accels-&gt;darkroom_preview.accel_mods &amp;&amp; lib-&gt;full_preview)</a>
<a name="ln2333">  {</a>
<a name="ln2334">    dt_ui_restore_panels(darktable.gui-&gt;ui);</a>
<a name="ln2335">    dt_control_set_dev_zoom(lib-&gt;full_preview_last_zoom);</a>
<a name="ln2336">    dt_control_set_dev_zoom_x(lib-&gt;full_preview_last_zoom_x);</a>
<a name="ln2337">    dt_control_set_dev_zoom_y(lib-&gt;full_preview_last_zoom_y);</a>
<a name="ln2338">    dt_control_set_dev_closeup(lib-&gt;full_preview_last_closeup);</a>
<a name="ln2339">    lib-&gt;full_preview = FALSE;</a>
<a name="ln2340">    dt_iop_request_focus(lib-&gt;full_preview_last_module);</a>
<a name="ln2341">    dt_masks_set_edit_mode(darktable.develop-&gt;gui_module, lib-&gt;full_preview_masks_state);</a>
<a name="ln2342">    dt_dev_invalidate(darktable.develop);</a>
<a name="ln2343">    dt_control_queue_redraw_center();</a>
<a name="ln2344">  }</a>
<a name="ln2345">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln2346">  if(key == accels-&gt;darkroom_skip_mouse_events.accel_key &amp;&amp; state == accels-&gt;darkroom_skip_mouse_events.accel_mods)</a>
<a name="ln2347">  {</a>
<a name="ln2348">    darktable.develop-&gt;darkroom_skip_mouse_events = FALSE;</a>
<a name="ln2349">  }</a>
<a name="ln2350"> </a>
<a name="ln2351">  return 1;</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354">int key_pressed(dt_view_t *self, guint key, guint state)</a>
<a name="ln2355">{</a>
<a name="ln2356">  const dt_control_accels_t *accels = &amp;darktable.control-&gt;accels;</a>
<a name="ln2357">  dt_develop_t *lib = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2358"> </a>
<a name="ln2359">  if(!darktable.control-&gt;key_accelerators_on)</a>
<a name="ln2360">    return 0;</a>
<a name="ln2361"> </a>
<a name="ln2362">  if(key == accels-&gt;darkroom_preview.accel_key &amp;&amp; state == accels-&gt;darkroom_preview.accel_mods)</a>
<a name="ln2363">  {</a>
<a name="ln2364">    if(!lib-&gt;full_preview)</a>
<a name="ln2365">    {</a>
<a name="ln2366">      lib-&gt;full_preview = TRUE;</a>
<a name="ln2367">      // we hide all panels</a>
<a name="ln2368">      for(int k = 0; k &lt; DT_UI_PANEL_SIZE; k++)</a>
<a name="ln2369">        dt_ui_panel_show(darktable.gui-&gt;ui, k, FALSE, FALSE);</a>
<a name="ln2370">      // we remember the masks edit state</a>
<a name="ln2371">      if(darktable.develop-&gt;gui_module)</a>
<a name="ln2372">      {</a>
<a name="ln2373">        dt_iop_gui_blend_data_t *bd = (dt_iop_gui_blend_data_t *)darktable.develop-&gt;gui_module-&gt;blend_data;</a>
<a name="ln2374">        if (bd) lib-&gt;full_preview_masks_state = bd-&gt;masks_shown;</a>
<a name="ln2375">      }</a>
<a name="ln2376">      // we set the zoom values to &quot;fit&quot;</a>
<a name="ln2377">      lib-&gt;full_preview_last_zoom = dt_control_get_dev_zoom();</a>
<a name="ln2378">      lib-&gt;full_preview_last_zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2379">      lib-&gt;full_preview_last_zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2380">      lib-&gt;full_preview_last_closeup = dt_control_get_dev_closeup();</a>
<a name="ln2381">      dt_control_set_dev_zoom(DT_ZOOM_FIT);</a>
<a name="ln2382">      dt_control_set_dev_zoom_x(0);</a>
<a name="ln2383">      dt_control_set_dev_zoom_y(0);</a>
<a name="ln2384">      dt_control_set_dev_closeup(0);</a>
<a name="ln2385">      // we quit the active iop if any</a>
<a name="ln2386">      lib-&gt;full_preview_last_module = darktable.develop-&gt;gui_module;</a>
<a name="ln2387">      dt_iop_request_focus(NULL);</a>
<a name="ln2388">      // and we redraw all</a>
<a name="ln2389">      dt_dev_invalidate(darktable.develop);</a>
<a name="ln2390">      dt_control_queue_redraw_center();</a>
<a name="ln2391">    }</a>
<a name="ln2392">    else</a>
<a name="ln2393">      return 0;</a>
<a name="ln2394">  }</a>
<a name="ln2395"> </a>
<a name="ln2396">  if(key == accels-&gt;global_zoom_in.accel_key &amp;&amp; state == accels-&gt;global_zoom_in.accel_mods)</a>
<a name="ln2397">  {</a>
<a name="ln2398">    dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2399"> </a>
<a name="ln2400">    scrolled(self, dev-&gt;width / 2, dev-&gt;height / 2, 1, state);</a>
<a name="ln2401">    return 1;</a>
<a name="ln2402">  }</a>
<a name="ln2403"> </a>
<a name="ln2404">  if(key == accels-&gt;global_zoom_out.accel_key &amp;&amp; state == accels-&gt;global_zoom_out.accel_mods)</a>
<a name="ln2405">  {</a>
<a name="ln2406">    dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2407"> </a>
<a name="ln2408">    scrolled(self, dev-&gt;width / 2, dev-&gt;height / 2, 0, state);</a>
<a name="ln2409">    return 1;</a>
<a name="ln2410">  }</a>
<a name="ln2411"> </a>
<a name="ln2412">  if(key == GDK_KEY_Left || key == GDK_KEY_Right || key == GDK_KEY_Up || key == GDK_KEY_Down)</a>
<a name="ln2413">  {</a>
<a name="ln2414">    dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2415">    dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln2416">    const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln2417">    float scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln2418">    int procw, proch;</a>
<a name="ln2419">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2420"> </a>
<a name="ln2421">    GdkModifierType modifiers;</a>
<a name="ln2422">    modifiers = gtk_accelerator_get_default_mod_mask();</a>
<a name="ln2423"> </a>
<a name="ln2424">    // For each cursor press, move one screen by default</a>
<a name="ln2425">    float step_changex = dev-&gt;width / (procw * scale);</a>
<a name="ln2426">    float step_changey = dev-&gt;height / (proch * scale);</a>
<a name="ln2427">    float factor = 0.2f;</a>
<a name="ln2428"> </a>
<a name="ln2429">    if((state &amp; modifiers) == GDK_MOD1_MASK) factor = 0.02f;</a>
<a name="ln2430">    if((state &amp; modifiers) == GDK_CONTROL_MASK) factor = 1.0f;</a>
<a name="ln2431"> </a>
<a name="ln2432">    float old_zoom_x, old_zoom_y;</a>
<a name="ln2433"> </a>
<a name="ln2434">    old_zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2435">    old_zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2436"> </a>
<a name="ln2437">    float zx = old_zoom_x;</a>
<a name="ln2438">    float zy = old_zoom_y;</a>
<a name="ln2439"> </a>
<a name="ln2440">    if(key == GDK_KEY_Left) zx = zx - step_changex * factor;</a>
<a name="ln2441">    if(key == GDK_KEY_Right) zx = zx + step_changex * factor;</a>
<a name="ln2442">    if(key == GDK_KEY_Up) zy = zy - step_changey * factor;</a>
<a name="ln2443">    if(key == GDK_KEY_Down) zy = zy + step_changey * factor;</a>
<a name="ln2444"> </a>
<a name="ln2445">    dt_dev_check_zoom_bounds(dev, &amp;zx, &amp;zy, zoom, closeup, NULL, NULL);</a>
<a name="ln2446">    dt_control_set_dev_zoom_x(zx);</a>
<a name="ln2447">    dt_control_set_dev_zoom_y(zy);</a>
<a name="ln2448"> </a>
<a name="ln2449">    dt_dev_invalidate(dev);</a>
<a name="ln2450">    dt_control_queue_redraw();</a>
<a name="ln2451"> </a>
<a name="ln2452">    return 1;</a>
<a name="ln2453">  }</a>
<a name="ln2454"> </a>
<a name="ln2455">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln2456">  if(key == accels-&gt;darkroom_skip_mouse_events.accel_key &amp;&amp; state == accels-&gt;darkroom_skip_mouse_events.accel_mods)</a>
<a name="ln2457">  {</a>
<a name="ln2458">    darktable.develop-&gt;darkroom_skip_mouse_events = TRUE;</a>
<a name="ln2459">    return 1;</a>
<a name="ln2460">  }</a>
<a name="ln2461"> </a>
<a name="ln2462">  return 1;</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465"> </a>
<a name="ln2466">void configure(dt_view_t *self, int wd, int ht)</a>
<a name="ln2467">{</a>
<a name="ln2468">  dt_develop_t *dev = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2469">  dt_dev_configure(dev, wd, ht);</a>
<a name="ln2470">}</a>
<a name="ln2471"> </a>
<a name="ln2472">void init_key_accels(dt_view_t *self)</a>
<a name="ln2473">{</a>
<a name="ln2474">  // Film strip shortcuts</a>
<a name="ln2475">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;toggle film strip&quot;), GDK_KEY_f, GDK_CONTROL_MASK);</a>
<a name="ln2476"> </a>
<a name="ln2477">  // Zoom shortcuts</a>
<a name="ln2478">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;zoom close-up&quot;), GDK_KEY_1, GDK_MOD1_MASK);</a>
<a name="ln2479">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;zoom fill&quot;), GDK_KEY_2, GDK_MOD1_MASK);</a>
<a name="ln2480">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;zoom fit&quot;), GDK_KEY_3, GDK_MOD1_MASK);</a>
<a name="ln2481"> </a>
<a name="ln2482">  // enable shortcut to export with current export settings:</a>
<a name="ln2483">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;export&quot;), GDK_KEY_e, GDK_CONTROL_MASK);</a>
<a name="ln2484"> </a>
<a name="ln2485">  // Shortcut to skip images</a>
<a name="ln2486">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;image forward&quot;), GDK_KEY_space, 0);</a>
<a name="ln2487">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;image back&quot;), GDK_KEY_BackSpace, 0);</a>
<a name="ln2488"> </a>
<a name="ln2489">  // toggle raw overexposure indication</a>
<a name="ln2490">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;raw overexposed&quot;), GDK_KEY_o, GDK_SHIFT_MASK);</a>
<a name="ln2491"> </a>
<a name="ln2492">  // toggle overexposure indication</a>
<a name="ln2493">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;overexposed&quot;), GDK_KEY_o, 0);</a>
<a name="ln2494"> </a>
<a name="ln2495">  // toggle softproofing</a>
<a name="ln2496">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;softproof&quot;), GDK_KEY_s, GDK_CONTROL_MASK);</a>
<a name="ln2497"> </a>
<a name="ln2498">  // toggle gamut check</a>
<a name="ln2499">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;gamut check&quot;), GDK_KEY_g, GDK_CONTROL_MASK);</a>
<a name="ln2500"> </a>
<a name="ln2501">  // brush size +/-</a>
<a name="ln2502">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;increase brush size&quot;), GDK_KEY_bracketright, 0);</a>
<a name="ln2503">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;decrease brush size&quot;), GDK_KEY_bracketleft, 0);</a>
<a name="ln2504"> </a>
<a name="ln2505">  // brush hardness +/-</a>
<a name="ln2506">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;increase brush hardness&quot;), GDK_KEY_braceright, 0);</a>
<a name="ln2507">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;decrease brush hardness&quot;), GDK_KEY_braceleft, 0);</a>
<a name="ln2508"> </a>
<a name="ln2509">  // brush opacity +/-</a>
<a name="ln2510">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;increase brush opacity&quot;), GDK_KEY_greater, 0);</a>
<a name="ln2511">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;decrease brush opacity&quot;), GDK_KEY_less, 0);</a>
<a name="ln2512"> </a>
<a name="ln2513">  // fullscreen view</a>
<a name="ln2514">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;full preview&quot;), GDK_KEY_z, 0);</a>
<a name="ln2515"> </a>
<a name="ln2516">  // undo/redo</a>
<a name="ln2517">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;undo&quot;), GDK_KEY_z, GDK_CONTROL_MASK);</a>
<a name="ln2518">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;redo&quot;), GDK_KEY_y, GDK_CONTROL_MASK);</a>
<a name="ln2519"> </a>
<a name="ln2520">  // add an option to allow skip mouse events while editing masks</a>
<a name="ln2521">  dt_accel_register_view(self, NC_(&quot;accel&quot;, &quot;allow to pan &amp; zoom while editing masks&quot;), GDK_KEY_a, 0);</a>
<a name="ln2522">}</a>
<a name="ln2523"> </a>
<a name="ln2524">static gboolean _darkroom_undo_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln2525">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln2526">{</a>
<a name="ln2527">  dt_undo_do_undo(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln2528">  return TRUE;</a>
<a name="ln2529">}</a>
<a name="ln2530"> </a>
<a name="ln2531">static gboolean _darkroom_redo_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln2532">                                        GdkModifierType modifier, gpointer data)</a>
<a name="ln2533">{</a>
<a name="ln2534">  dt_undo_do_redo(darktable.undo, DT_UNDO_DEVELOP);</a>
<a name="ln2535">  return TRUE;</a>
<a name="ln2536">}</a>
<a name="ln2537"> </a>
<a name="ln2538">void connect_key_accels(dt_view_t *self)</a>
<a name="ln2539">{</a>
<a name="ln2540">  GClosure *closure;</a>
<a name="ln2541">  dt_develop_t *data = (dt_develop_t *)self-&gt;data;</a>
<a name="ln2542"> </a>
<a name="ln2543">  // Film strip shortcuts</a>
<a name="ln2544">  closure = g_cclosure_new(G_CALLBACK(film_strip_key_accel), (gpointer)self, NULL);</a>
<a name="ln2545">  dt_accel_connect_view(self, &quot;toggle film strip&quot;, closure);</a>
<a name="ln2546"> </a>
<a name="ln2547">  // Zoom shortcuts</a>
<a name="ln2548">  closure = g_cclosure_new(G_CALLBACK(zoom_key_accel), GINT_TO_POINTER(1), NULL);</a>
<a name="ln2549">  dt_accel_connect_view(self, &quot;zoom close-up&quot;, closure);</a>
<a name="ln2550"> </a>
<a name="ln2551">  closure = g_cclosure_new(G_CALLBACK(zoom_key_accel), GINT_TO_POINTER(2), NULL);</a>
<a name="ln2552">  dt_accel_connect_view(self, &quot;zoom fill&quot;, closure);</a>
<a name="ln2553"> </a>
<a name="ln2554">  closure = g_cclosure_new(G_CALLBACK(zoom_key_accel), GINT_TO_POINTER(3), NULL);</a>
<a name="ln2555">  dt_accel_connect_view(self, &quot;zoom fit&quot;, closure);</a>
<a name="ln2556"> </a>
<a name="ln2557">  // enable shortcut to export with current export settings:</a>
<a name="ln2558">  closure = g_cclosure_new(G_CALLBACK(export_key_accel_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2559">  dt_accel_connect_view(self, &quot;export&quot;, closure);</a>
<a name="ln2560"> </a>
<a name="ln2561">  // Shortcut to skip images</a>
<a name="ln2562">  closure = g_cclosure_new(G_CALLBACK(skip_f_key_accel_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2563">  dt_accel_connect_view(self, &quot;image forward&quot;, closure);</a>
<a name="ln2564"> </a>
<a name="ln2565">  closure = g_cclosure_new(G_CALLBACK(skip_b_key_accel_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2566">  dt_accel_connect_view(self, &quot;image back&quot;, closure);</a>
<a name="ln2567"> </a>
<a name="ln2568">  // toggle raw overexposure indication</a>
<a name="ln2569">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;rawoverexposed.button, NULL);</a>
<a name="ln2570">  dt_accel_connect_view(self, &quot;raw overexposed&quot;, closure);</a>
<a name="ln2571"> </a>
<a name="ln2572">  // toggle overexposure indication</a>
<a name="ln2573">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;overexposed.button, NULL);</a>
<a name="ln2574">  dt_accel_connect_view(self, &quot;overexposed&quot;, closure);</a>
<a name="ln2575"> </a>
<a name="ln2576">  // toggle softproof indication</a>
<a name="ln2577">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;profile.softproof_button, NULL);</a>
<a name="ln2578">  dt_accel_connect_view(self, &quot;softproof&quot;, closure);</a>
<a name="ln2579"> </a>
<a name="ln2580">  // toggle gamut indication</a>
<a name="ln2581">  closure = g_cclosure_new(G_CALLBACK(_toolbox_toggle_callback), data-&gt;profile.gamut_button, NULL);</a>
<a name="ln2582">  dt_accel_connect_view(self, &quot;gamut check&quot;, closure);</a>
<a name="ln2583"> </a>
<a name="ln2584">  // brush size +/-</a>
<a name="ln2585">  closure = g_cclosure_new(G_CALLBACK(_brush_size_up_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2586">  dt_accel_connect_view(self, &quot;increase brush size&quot;, closure);</a>
<a name="ln2587">  closure = g_cclosure_new(G_CALLBACK(_brush_size_down_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2588">  dt_accel_connect_view(self, &quot;decrease brush size&quot;, closure);</a>
<a name="ln2589"> </a>
<a name="ln2590">  // brush hardness +/-</a>
<a name="ln2591">  closure = g_cclosure_new(G_CALLBACK(_brush_hardness_up_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2592">  dt_accel_connect_view(self, &quot;increase brush hardness&quot;, closure);</a>
<a name="ln2593">  closure = g_cclosure_new(G_CALLBACK(_brush_hardness_down_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2594">  dt_accel_connect_view(self, &quot;decrease brush hardness&quot;, closure);</a>
<a name="ln2595"> </a>
<a name="ln2596">  // brush opacity +/-</a>
<a name="ln2597">  closure = g_cclosure_new(G_CALLBACK(_brush_opacity_up_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2598">  dt_accel_connect_view(self, &quot;increase brush opacity&quot;, closure);</a>
<a name="ln2599">  closure = g_cclosure_new(G_CALLBACK(_brush_opacity_down_callback), (gpointer)self-&gt;data, NULL);</a>
<a name="ln2600">  dt_accel_connect_view(self, &quot;decrease brush opacity&quot;, closure);</a>
<a name="ln2601"> </a>
<a name="ln2602">  // undo/redo</a>
<a name="ln2603">  closure = g_cclosure_new(G_CALLBACK(_darkroom_undo_callback), (gpointer)self, NULL);</a>
<a name="ln2604">  dt_accel_connect_view(self, &quot;undo&quot;, closure);</a>
<a name="ln2605">  closure = g_cclosure_new(G_CALLBACK(_darkroom_redo_callback), (gpointer)self, NULL);</a>
<a name="ln2606">  dt_accel_connect_view(self, &quot;redo&quot;, closure);</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln2610">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln2611">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1039"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free_full' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
