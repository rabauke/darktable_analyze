
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010-2011 johannes hanika</a>
<a name="ln4">    copyright (c) 2010-2012 henrik andersson</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;control/jobs/control_jobs.h&quot;</a>
<a name="ln20">#include &quot;common/collection.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/debug.h&quot;</a>
<a name="ln23">#include &quot;common/exif.h&quot;</a>
<a name="ln24">#include &quot;common/film.h&quot;</a>
<a name="ln25">#include &quot;common/gpx.h&quot;</a>
<a name="ln26">#include &quot;common/history.h&quot;</a>
<a name="ln27">#include &quot;common/image.h&quot;</a>
<a name="ln28">#include &quot;common/image_cache.h&quot;</a>
<a name="ln29">#include &quot;common/imageio.h&quot;</a>
<a name="ln30">#include &quot;common/imageio_dng.h&quot;</a>
<a name="ln31">#include &quot;common/imageio_module.h&quot;</a>
<a name="ln32">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln33">#include &quot;common/tags.h&quot;</a>
<a name="ln34">#include &quot;control/conf.h&quot;</a>
<a name="ln35">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;gui/gtk.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gio/gio.h&gt;</a>
<a name="ln40">#include &lt;glib.h&gt;</a>
<a name="ln41">#include &lt;glib/gstdio.h&gt;</a>
<a name="ln42">#ifndef _WIN32</a>
<a name="ln43">#include &lt;glob.h&gt;</a>
<a name="ln44">#endif</a>
<a name="ln45">#ifdef __APPLE__</a>
<a name="ln46">#include &quot;osx/osx.h&quot;</a>
<a name="ln47">#endif</a>
<a name="ln48">#ifdef _WIN32</a>
<a name="ln49">#include &quot;win/dtwin.h&quot;</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">typedef struct dt_control_time_offset_t</a>
<a name="ln53">{</a>
<a name="ln54">  long int offset;</a>
<a name="ln55">} dt_control_time_offset_t;</a>
<a name="ln56"> </a>
<a name="ln57">typedef struct dt_control_gpx_apply_t</a>
<a name="ln58">{</a>
<a name="ln59">  gchar *filename;</a>
<a name="ln60">  gchar *tz;</a>
<a name="ln61">} dt_control_gpx_apply_t;</a>
<a name="ln62"> </a>
<a name="ln63">typedef struct dt_control_export_t</a>
<a name="ln64">{</a>
<a name="ln65">  int max_width, max_height, format_index, storage_index;</a>
<a name="ln66">  dt_imageio_module_data_t *sdata; // needed since the gui thread resets things like overwrite once the export</a>
<a name="ln67">  // is dispatched, but we have to keep that information</a>
<a name="ln68">  gboolean high_quality, upscale;</a>
<a name="ln69">  char style[128];</a>
<a name="ln70">  gboolean style_append;</a>
<a name="ln71">  dt_colorspaces_color_profile_type_t icc_type;</a>
<a name="ln72">  gchar *icc_filename;</a>
<a name="ln73">  dt_iop_color_intent_t icc_intent;</a>
<a name="ln74">} dt_control_export_t;</a>
<a name="ln75"> </a>
<a name="ln76">typedef struct dt_control_image_enumerator_t</a>
<a name="ln77">{</a>
<a name="ln78">  GList *index;</a>
<a name="ln79">  int flag;</a>
<a name="ln80">  gpointer data;</a>
<a name="ln81">} dt_control_image_enumerator_t;</a>
<a name="ln82"> </a>
<a name="ln83">/* enumerator of images from filmroll */</a>
<a name="ln84">static void dt_control_image_enumerator_job_film_init(dt_control_image_enumerator_t *t, int32_t filmid)</a>
<a name="ln85">{</a>
<a name="ln86">  g_list_free(t-&gt;index);</a>
<a name="ln87">  t-&gt;index = NULL;</a>
<a name="ln88"> </a>
<a name="ln89">  sqlite3_stmt *stmt;</a>
<a name="ln90">  /* get a list of images in filmroll */</a>
<a name="ln91">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT id FROM main.images WHERE film_id = ?1&quot;, -1,</a>
<a name="ln92">                              &amp;stmt, NULL);</a>
<a name="ln93">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, filmid);</a>
<a name="ln94"> </a>
<a name="ln95">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln96">  {</a>
<a name="ln97">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln98">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln99">  }</a>
<a name="ln100">  sqlite3_finalize(stmt);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">/* enumerator of selected images */</a>
<a name="ln104">static void dt_control_image_enumerator_job_selected_init(dt_control_image_enumerator_t *t)</a>
<a name="ln105">{</a>
<a name="ln106">  g_list_free(t-&gt;index);</a>
<a name="ln107">  t-&gt;index = NULL;</a>
<a name="ln108"> </a>
<a name="ln109">  int imgid = dt_view_get_image_to_act_on();</a>
<a name="ln110"> </a>
<a name="ln111">  if(imgid &lt; 0) /* get sorted list of selected images */</a>
<a name="ln112">    t-&gt;index = dt_collection_get_selected(darktable.collection, -1);</a>
<a name="ln113">  else</a>
<a name="ln114">    /* Create a list with only one image */</a>
<a name="ln115">    t-&gt;index = g_list_append(t-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">static int32_t _generic_dt_control_fileop_images_job_run(dt_job_t *job,</a>
<a name="ln119">                                                         int32_t (*fileop_callback)(const int32_t,</a>
<a name="ln120">                                                                                    const int32_t),</a>
<a name="ln121">                                                         const char *desc, const char *desc_pl)</a>
<a name="ln122">{</a>
<a name="ln123">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln124">  GList *t = params-&gt;index;</a>
<a name="ln125">  guint total = g_list_length(t);</a>
<a name="ln126">  char message[512] = { 0 };</a>
<a name="ln127">  double fraction = 0;</a>
<a name="ln128">  gchar *newdir = (gchar *)params-&gt;data;</a>
<a name="ln129"> </a>
<a name="ln130">  g_snprintf(message, sizeof(message), ngettext(desc, desc_pl, total), total);</a>
<a name="ln131">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln132"> </a>
<a name="ln133">  // create new film roll for the destination directory</a>
<a name="ln134">  dt_film_t new_film;</a>
<a name="ln135">  const int32_t film_id = dt_film_new(&amp;new_film, newdir);</a>
<a name="ln136">  g_free(newdir);</a>
<a name="ln137"> </a>
<a name="ln138">  if(film_id &lt;= 0)</a>
<a name="ln139">  {</a>
<a name="ln140">    dt_control_log(_(&quot;failed to create film roll for destination directory, aborting move..&quot;));</a>
<a name="ln141">    return -1;</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln145">  {</a>
<a name="ln146">    fileop_callback(GPOINTER_TO_INT(t-&gt;data), film_id);</a>
<a name="ln147">    t = g_list_delete_link(t, t);</a>
<a name="ln148">    fraction += 1.0 / total;</a>
<a name="ln149">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln150">  }</a>
<a name="ln151">  params-&gt;index = NULL;</a>
<a name="ln152"> </a>
<a name="ln153">  char collect[1024];</a>
<a name="ln154">  snprintf(collect, sizeof(collect), &quot;1:0:0:%s$&quot;, new_film.dirname);</a>
<a name="ln155">  dt_collection_deserialize(collect);</a>
<a name="ln156">  dt_film_remove_empty();</a>
<a name="ln157">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln158">  dt_control_queue_redraw_center();</a>
<a name="ln159">  return 0;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">static void *dt_control_image_enumerator_alloc()</a>
<a name="ln163">{</a>
<a name="ln164">  dt_control_image_enumerator_t *params = calloc(1, sizeof(dt_control_image_enumerator_t));</a>
<a name="ln165">  if(!params) return NULL;</a>
<a name="ln166"> </a>
<a name="ln167">  return params;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">static void dt_control_image_enumerator_cleanup(void *p)</a>
<a name="ln171">{</a>
<a name="ln172">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln173"> </a>
<a name="ln174">  g_list_free(params-&gt;index);</a>
<a name="ln175"> </a>
<a name="ln176">  free(params);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">typedef enum {PROGRESS_NONE, PROGRESS_SIMPLE, PROGRESS_CANCELLABLE} progress_type_t;</a>
<a name="ln180"> </a>
<a name="ln181">static dt_job_t *dt_control_generic_images_job_create(dt_job_execute_callback execute, const char *message,</a>
<a name="ln182">                                                      int flag, gpointer data, progress_type_t progress_type)</a>
<a name="ln183">{</a>
<a name="ln184">  dt_job_t *job = dt_control_job_create(execute, &quot;%s&quot;, message);</a>
<a name="ln185">  if(!job) return NULL;</a>
<a name="ln186">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln187">  if(!params)</a>
<a name="ln188">  {</a>
<a name="ln189">    dt_control_job_dispose(job);</a>
<a name="ln190">    return NULL;</a>
<a name="ln191">  }</a>
<a name="ln192">  if(progress_type != PROGRESS_NONE)</a>
<a name="ln193">    dt_control_job_add_progress(job, _(message), progress_type == PROGRESS_CANCELLABLE);</a>
<a name="ln194">  dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln195">  dt_control_job_set_params(job, params, dt_control_image_enumerator_cleanup);</a>
<a name="ln196"> </a>
<a name="ln197">  params-&gt;flag = flag;</a>
<a name="ln198">  params-&gt;data = data;</a>
<a name="ln199">  return job;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static int32_t dt_control_write_sidecar_files_job_run(dt_job_t *job)</a>
<a name="ln203">{</a>
<a name="ln204">  int imgid = -1;</a>
<a name="ln205">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln206">  GList *t = params-&gt;index;</a>
<a name="ln207">  sqlite3_stmt *stmt;</a>
<a name="ln208">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln209">                              &quot;UPDATE main.images SET write_timestamp = STRFTIME('%s', 'now') WHERE id = ?1&quot;, -1,</a>
<a name="ln210">                              &amp;stmt, NULL);</a>
<a name="ln211">  while(t)</a>
<a name="ln212">  {</a>
<a name="ln213">    gboolean from_cache = FALSE;</a>
<a name="ln214">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln215">    const dt_image_t *img = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln216">    char dtfilename[PATH_MAX] = { 0 };</a>
<a name="ln217">    dt_image_full_path(img-&gt;id, dtfilename, sizeof(dtfilename), &amp;from_cache);</a>
<a name="ln218">    dt_image_path_append_version(img-&gt;id, dtfilename, sizeof(dtfilename));</a>
<a name="ln219">    g_strlcat(dtfilename, &quot;.xmp&quot;, sizeof(dtfilename));</a>
<a name="ln220">    if(!dt_exif_xmp_write(imgid, dtfilename))</a>
<a name="ln221">    {</a>
<a name="ln222">      // put the timestamp into db. this can't be done in exif.cc since that code gets called</a>
<a name="ln223">      // for the copy exporter, too</a>
<a name="ln224">      DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln225">      sqlite3_step(stmt);</a>
<a name="ln226">      sqlite3_reset(stmt);</a>
<a name="ln227">      sqlite3_clear_bindings(stmt);</a>
<a name="ln228">    }</a>
<a name="ln229">    dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln230">    t = g_list_delete_link(t, t);</a>
<a name="ln231">  }</a>
<a name="ln232">  params-&gt;index = NULL;</a>
<a name="ln233">  sqlite3_finalize(stmt);</a>
<a name="ln234">  return 0;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">typedef struct dt_control_merge_hdr_t</a>
<a name="ln238">{</a>
<a name="ln239">  uint32_t first_imgid;</a>
<a name="ln240">  uint32_t first_filter;</a>
<a name="ln241">  uint8_t first_xtrans[6][6];</a>
<a name="ln242"> </a>
<a name="ln243">  float *pixels, *weight;</a>
<a name="ln244"> </a>
<a name="ln245">  int wd;</a>
<a name="ln246">  int ht;</a>
<a name="ln247">  dt_image_orientation_t orientation;</a>
<a name="ln248"> </a>
<a name="ln249">  float whitelevel;</a>
<a name="ln250">  float epsw;</a>
<a name="ln251"> </a>
<a name="ln252">  // 0 - ok; 1 - errors, abort</a>
<a name="ln253">  gboolean abort;</a>
<a name="ln254">} dt_control_merge_hdr_t;</a>
<a name="ln255"> </a>
<a name="ln256">typedef struct dt_control_merge_hdr_format_t</a>
<a name="ln257">{</a>
<a name="ln258">  dt_imageio_module_data_t parent;</a>
<a name="ln259">  dt_control_merge_hdr_t *d;</a>
<a name="ln260">} dt_control_merge_hdr_format_t;</a>
<a name="ln261"> </a>
<a name="ln262">static int dt_control_merge_hdr_bpp(dt_imageio_module_data_t *data)</a>
<a name="ln263">{</a>
<a name="ln264">  return 32;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">static int dt_control_merge_hdr_levels(dt_imageio_module_data_t *data)</a>
<a name="ln268">{</a>
<a name="ln269">  return IMAGEIO_RGB | IMAGEIO_FLOAT;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">static const char *dt_control_merge_hdr_mime(dt_imageio_module_data_t *data)</a>
<a name="ln273">{</a>
<a name="ln274">  return &quot;memory&quot;;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static float envelope(const float xx)</a>
<a name="ln278">{</a>
<a name="ln279">  const float x = CLAMPS(xx, 0.0f, 1.0f);</a>
<a name="ln280">  // const float alpha = 2.0f;</a>
<a name="ln281">  const float beta = 0.5f;</a>
<a name="ln282">  if(x &lt; beta)</a>
<a name="ln283">  {</a>
<a name="ln284">    // return 1.0f-fabsf(x/beta-1.0f)^2</a>
<a name="ln285">    const float tmp = fabsf(x / beta - 1.0f);</a>
<a name="ln286">    return 1.0f - tmp * tmp;</a>
<a name="ln287">  }</a>
<a name="ln288">  else</a>
<a name="ln289">  {</a>
<a name="ln290">    const float tmp1 = (1.0f - x) / (1.0f - beta);</a>
<a name="ln291">    const float tmp2 = tmp1 * tmp1;</a>
<a name="ln292">    const float tmp3 = tmp2 * tmp1;</a>
<a name="ln293">    return 3.0f * tmp2 - 2.0f * tmp3;</a>
<a name="ln294">  }</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">static int dt_control_merge_hdr_process(dt_imageio_module_data_t *datai, const char *filename,</a>
<a name="ln298">                                        const void *const ivoid,</a>
<a name="ln299">                                        dt_colorspaces_color_profile_type_t over_type, const char *over_filename,</a>
<a name="ln300">                                        void *exif, int exif_len, int imgid, int num, int total,</a>
<a name="ln301">                                        dt_dev_pixelpipe_t *pipe)</a>
<a name="ln302">{</a>
<a name="ln303">  dt_control_merge_hdr_format_t *data = (dt_control_merge_hdr_format_t *)datai;</a>
<a name="ln304">  dt_control_merge_hdr_t *d = data-&gt;d;</a>
<a name="ln305"> </a>
<a name="ln306">  // just take a copy. also do it after blocking read, so filters will make sense.</a>
<a name="ln307">  const dt_image_t *img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln308">  const dt_image_t image = *img;</a>
<a name="ln309">  dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln310"> </a>
<a name="ln311">  if(!d-&gt;pixels)</a>
<a name="ln312">  {</a>
<a name="ln313">    d-&gt;first_imgid = imgid;</a>
<a name="ln314">    d-&gt;first_filter = image.buf_dsc.filters;</a>
<a name="ln315">    // sensor layout is just passed on to be written to dng.</a>
<a name="ln316">    // we offset it to the crop of the image here, so we don't</a>
<a name="ln317">    // need to load in the FCxtrans dependency into the dng writer.</a>
<a name="ln318">    // for some stupid reason the dng needs this layout wrt cropped</a>
<a name="ln319">    // offsets, not globally.</a>
<a name="ln320">    dt_iop_roi_t roi = {0};</a>
<a name="ln321">    roi.x = image.crop_x;</a>
<a name="ln322">    roi.y = image.crop_y;</a>
<a name="ln323">    for(int j=0;j&lt;6;j++)</a>
<a name="ln324">      for(int i = 0; i &lt; 6; i++) d-&gt;first_xtrans[j][i] = FCxtrans(j, i, &amp;roi, image.buf_dsc.xtrans);</a>
<a name="ln325">    d-&gt;pixels = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln326">    d-&gt;weight = calloc(datai-&gt;width * datai-&gt;height, sizeof(float));</a>
<a name="ln327">    d-&gt;wd = datai-&gt;width;</a>
<a name="ln328">    d-&gt;ht = datai-&gt;height;</a>
<a name="ln329">    d-&gt;orientation = image.orientation;</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  if(image.buf_dsc.filters == 0u || image.buf_dsc.channels != 1 || image.buf_dsc.datatype != TYPE_UINT16)</a>
<a name="ln333">  {</a>
<a name="ln334">    dt_control_log(_(&quot;exposure bracketing only works on raw images.&quot;));</a>
<a name="ln335">    d-&gt;abort = TRUE;</a>
<a name="ln336">    return 1;</a>
<a name="ln337">  }</a>
<a name="ln338">  else if(datai-&gt;width != d-&gt;wd || datai-&gt;height != d-&gt;ht || d-&gt;first_filter != image.buf_dsc.filters</a>
<a name="ln339">          || d-&gt;orientation != image.orientation)</a>
<a name="ln340">  {</a>
<a name="ln341">    dt_control_log(_(&quot;images have to be of same size and orientation!&quot;));</a>
<a name="ln342">    d-&gt;abort = TRUE;</a>
<a name="ln343">    return 1;</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  // if no valid exif data can be found, assume peleng fisheye at f/16, 8mm, with half of the light lost in</a>
<a name="ln347">  // the system =&gt; f/22</a>
<a name="ln348">  const float eap = image.exif_aperture &gt; 0.0f ? image.exif_aperture : 22.0f;</a>
<a name="ln349">  const float efl = image.exif_focal_length &gt; 0.0f ? image.exif_focal_length : 8.0f;</a>
<a name="ln350">  const float rad = .5f * efl / eap;</a>
<a name="ln351">  const float aperture = M_PI * rad * rad;</a>
<a name="ln352">  const float iso = image.exif_iso &gt; 0.0f ? image.exif_iso : 100.0f;</a>
<a name="ln353">  const float exp = image.exif_exposure &gt; 0.0f ? image.exif_exposure : 1.0f;</a>
<a name="ln354">  const float cal = 100.0f / (aperture * exp * iso);</a>
<a name="ln355">  // about proportional to how many photons we can expect from this shot:</a>
<a name="ln356">  const float photoncnt = 100.0f * aperture * exp / iso;</a>
<a name="ln357">  float saturation = 1.0f;</a>
<a name="ln358">  d-&gt;whitelevel = fmaxf(d-&gt;whitelevel, saturation * cal);</a>
<a name="ln359">#ifdef _OPENMP</a>
<a name="ln360">#pragma omp parallel for schedule(static) default(none) shared(d, saturation)</a>
<a name="ln361">#endif</a>
<a name="ln362">  for(int y = 0; y &lt; d-&gt;ht; y++)</a>
<a name="ln363">    for(int x = 0; x &lt; d-&gt;wd; x++)</a>
<a name="ln364">    {</a>
<a name="ln365">      // read unclamped raw value with subtracted black and rescaled to 1.0 saturation.</a>
<a name="ln366">      // this is the output of the rawprepare iop.</a>
<a name="ln367">      const float in = ((float *)ivoid)[x + d-&gt;wd * y];</a>
<a name="ln368">      // weights based on siggraph 12 poster</a>
<a name="ln369">      // zijian zhu, zhengguo li, susanto rahardja, pasi fraenti</a>
<a name="ln370">      // 2d denoising factor for high dynamic range imaging</a>
<a name="ln371">      float w = photoncnt;</a>
<a name="ln372"> </a>
<a name="ln373">      // need some safety margin due to upsampling and 16-bit quantization + dithering?</a>
<a name="ln374">      float offset = 3000.0f / (float)UINT16_MAX;</a>
<a name="ln375"> </a>
<a name="ln376">      // cannot do an envelope based on single pixel values here, need to get</a>
<a name="ln377">      // maximum value of all color channels. to find that, go through the</a>
<a name="ln378">      // pattern block (we conservatively do a 3x3 for bayer or xtrans):</a>
<a name="ln379">      int xx = x &amp; ~1, yy = y &amp; ~1;</a>
<a name="ln380">      float M = 0.0f, m = FLT_MAX;</a>
<a name="ln381">      if(xx &lt; d-&gt;wd - 2 &amp;&amp; yy &lt; d-&gt;ht - 2)</a>
<a name="ln382">      {</a>
<a name="ln383">        for(int i = 0; i &lt; 3; i++)</a>
<a name="ln384">          for(int j = 0; j &lt; 3; j++)</a>
<a name="ln385">          {</a>
<a name="ln386">            M = MAX(M, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln387">            m = MIN(m, ((float *)ivoid)[xx + i + d-&gt;wd * (yy + j)]);</a>
<a name="ln388">          }</a>
<a name="ln389">        // move envelope a little to allow non-zero weight even for clipped regions.</a>
<a name="ln390">        // this is because even if the 2x2 block is clipped somewhere, the other channels</a>
<a name="ln391">        // might still prove useful. we'll check for individual channel saturation below.</a>
<a name="ln392">        w *= d-&gt;epsw + envelope((M + offset) / saturation);</a>
<a name="ln393">      }</a>
<a name="ln394"> </a>
<a name="ln395">      if(M + offset &gt;= saturation)</a>
<a name="ln396">      {</a>
<a name="ln397">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0f)</a>
<a name="ln398">        { // only consider saturated pixels in case we have nothing better:</a>
<a name="ln399">          if(d-&gt;weight[x + d-&gt;wd * y] == 0 || m &lt; -d-&gt;weight[x + d-&gt;wd * y])</a>
<a name="ln400">          {</a>
<a name="ln401">            if(m + offset &gt;= saturation)</a>
<a name="ln402">              d-&gt;pixels[x + d-&gt;wd * y] = 1.0f; // let's admit we were completely clipped, too</a>
<a name="ln403">            else</a>
<a name="ln404">              d-&gt;pixels[x + d-&gt;wd * y] = in * cal / d-&gt;whitelevel;</a>
<a name="ln405">            d-&gt;weight[x + d-&gt;wd * y]</a>
<a name="ln406">                = -m; // could use -cal here, but m is per pixel and safer for varying illumination conditions</a>
<a name="ln407">          }</a>
<a name="ln408">        }</a>
<a name="ln409">        // else silently ignore, others have filled in a better color here already</a>
<a name="ln410">      }</a>
<a name="ln411">      else</a>
<a name="ln412">      {</a>
<a name="ln413">        if(d-&gt;weight[x + d-&gt;wd * y] &lt;= 0.0)</a>
<a name="ln414">        { // cleanup potentially blown highlights from earlier images</a>
<a name="ln415">          d-&gt;pixels[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln416">          d-&gt;weight[x + d-&gt;wd * y] = 0.0f;</a>
<a name="ln417">        }</a>
<a name="ln418">        d-&gt;pixels[x + d-&gt;wd * y] += w * in * cal;</a>
<a name="ln419">        d-&gt;weight[x + d-&gt;wd * y] += w;</a>
<a name="ln420">      }</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">  return 0;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">static int32_t dt_control_merge_hdr_job_run(dt_job_t *job)</a>
<a name="ln427">{</a>
<a name="ln428">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln429">  GList *t = params-&gt;index;</a>
<a name="ln430">  const guint total = g_list_length(t);</a>
<a name="ln431">  char message[512] = { 0 };</a>
<a name="ln432">  double fraction = 0;</a>
<a name="ln433">  snprintf(message, sizeof(message), ngettext(&quot;merging %d image&quot;, &quot;merging %d images&quot;, total), total);</a>
<a name="ln434"> </a>
<a name="ln435">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln436"> </a>
<a name="ln437">  dt_control_merge_hdr_t d = (dt_control_merge_hdr_t){.epsw = 1e-8f, .abort = FALSE };</a>
<a name="ln438"> </a>
<a name="ln439">  dt_imageio_module_format_t buf = (dt_imageio_module_format_t){.mime = dt_control_merge_hdr_mime,</a>
<a name="ln440">                                                                .levels = dt_control_merge_hdr_levels,</a>
<a name="ln441">                                                                .bpp = dt_control_merge_hdr_bpp,</a>
<a name="ln442">                                                                .write_image = dt_control_merge_hdr_process };</a>
<a name="ln443"> </a>
<a name="ln444">  dt_control_merge_hdr_format_t dat = (dt_control_merge_hdr_format_t){.parent = { 0 }, .d = &amp;d };</a>
<a name="ln445"> </a>
<a name="ln446">  int num = 1;</a>
<a name="ln447">  while(t)</a>
<a name="ln448">  {</a>
<a name="ln449">    if(d.abort) goto end;</a>
<a name="ln450"> </a>
<a name="ln451">    const uint32_t imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln452"> </a>
<a name="ln453">    dt_imageio_export_with_flags(imgid, &quot;unused&quot;, &amp;buf, (dt_imageio_module_data_t *)&amp;dat, TRUE, FALSE, FALSE, TRUE,</a>
<a name="ln454">                                 FALSE, &quot;pre:rawprepare&quot;, FALSE, DT_COLORSPACE_NONE, NULL, DT_INTENT_LAST, NULL, NULL,</a>
<a name="ln455">                                 num, total);</a>
<a name="ln456"> </a>
<a name="ln457">    t = g_list_delete_link(t, t);</a>
<a name="ln458"> </a>
<a name="ln459">    /* update the progress bar */</a>
<a name="ln460">    fraction += 1.0 / (total + 1);</a>
<a name="ln461">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln462">    num++;</a>
<a name="ln463">  }</a>
<a name="ln464">  params-&gt;index = NULL;</a>
<a name="ln465"> </a>
<a name="ln466">  if(d.abort) goto end;</a>
<a name="ln467"> </a>
<a name="ln468">// normalize by white level to make clipping at 1.0 work as expected</a>
<a name="ln469"> </a>
<a name="ln470">#ifdef _OPENMP</a>
<a name="ln471">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln472">#endif</a>
<a name="ln473">  for(size_t k = 0; k &lt; (size_t)d.wd * d.ht; k++)</a>
<a name="ln474">  {</a>
<a name="ln475">    if(d.weight[k] &gt; 0.0) d.pixels[k] = fmaxf(0.0f, d.pixels[k] / (d.whitelevel * d.weight[k]));</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">  // output hdr as digital negative with exif data.</a>
<a name="ln479">  uint8_t *exif = NULL;</a>
<a name="ln480">  char pathname[PATH_MAX] = { 0 };</a>
<a name="ln481">  gboolean from_cache = TRUE;</a>
<a name="ln482">  dt_image_full_path(d.first_imgid, pathname, sizeof(pathname), &amp;from_cache);</a>
<a name="ln483"> </a>
<a name="ln484">  // last param is dng mode</a>
<a name="ln485">  const int exif_len = dt_exif_read_blob(&amp;exif, pathname, d.first_imgid, 0, d.wd, d.ht, 1);</a>
<a name="ln486">  char *c = pathname + strlen(pathname);</a>
<a name="ln487">  while(*c != '.' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln488">  g_strlcpy(c, &quot;-hdr.dng&quot;, sizeof(pathname) - (c - pathname));</a>
<a name="ln489">  dt_imageio_write_dng(pathname, d.pixels, d.wd, d.ht, exif, exif_len, d.first_filter, (const uint8_t (*)[6])d.first_xtrans, 1.0f);</a>
<a name="ln490">  free(exif);</a>
<a name="ln491"> </a>
<a name="ln492">  dt_control_job_set_progress(job, 1.0);</a>
<a name="ln493"> </a>
<a name="ln494">  while(*c != '/' &amp;&amp; c &gt; pathname) c--;</a>
<a name="ln495">  dt_control_log(_(&quot;wrote merged HDR `%s'&quot;), c + 1);</a>
<a name="ln496"> </a>
<a name="ln497">  // import new image</a>
<a name="ln498">  gchar *directory = g_path_get_dirname((const gchar *)pathname);</a>
<a name="ln499">  dt_film_t film;</a>
<a name="ln500">  const int filmid = dt_film_new(&amp;film, directory);</a>
<a name="ln501">  dt_image_import(filmid, pathname, TRUE);</a>
<a name="ln502">  g_free(directory);</a>
<a name="ln503"> </a>
<a name="ln504">end:</a>
<a name="ln505">  free(d.pixels);</a>
<a name="ln506">  free(d.weight);</a>
<a name="ln507"> </a>
<a name="ln508">  dt_control_queue_redraw_center();</a>
<a name="ln509">  return 0;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">static int32_t dt_control_duplicate_images_job_run(dt_job_t *job)</a>
<a name="ln513">{</a>
<a name="ln514">  int imgid = -1;</a>
<a name="ln515">  int newimgid = -1;</a>
<a name="ln516">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln517">  GList *t = params-&gt;index;</a>
<a name="ln518">  guint total = g_list_length(t);</a>
<a name="ln519">  char message[512] = { 0 };</a>
<a name="ln520">  double fraction = 0;</a>
<a name="ln521">  snprintf(message, sizeof(message), ngettext(&quot;duplicating %d image&quot;, &quot;duplicating %d images&quot;, total), total);</a>
<a name="ln522">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln523">  while(t)</a>
<a name="ln524">  {</a>
<a name="ln525">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln526">    newimgid = dt_image_duplicate(imgid);</a>
<a name="ln527">    if(newimgid != -1) dt_history_copy_and_paste_on_image(imgid, newimgid, FALSE, NULL);</a>
<a name="ln528">    t = g_list_delete_link(t, t);</a>
<a name="ln529">    fraction = 1.0 / total;</a>
<a name="ln530">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln531">  }</a>
<a name="ln532">  params-&gt;index = NULL;</a>
<a name="ln533">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln534">  dt_control_queue_redraw_center();</a>
<a name="ln535">  return 0;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">static int32_t dt_control_flip_images_job_run(dt_job_t *job)</a>
<a name="ln539">{</a>
<a name="ln540">  int imgid = -1;</a>
<a name="ln541">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln542">  const int cw = params-&gt;flag;</a>
<a name="ln543">  GList *t = params-&gt;index;</a>
<a name="ln544">  guint total = g_list_length(t);</a>
<a name="ln545">  double fraction = 0;</a>
<a name="ln546">  char message[512] = { 0 };</a>
<a name="ln547">  snprintf(message, sizeof(message), ngettext(&quot;flipping %d image&quot;, &quot;flipping %d images&quot;, total), total);</a>
<a name="ln548">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln549">  while(t)</a>
<a name="ln550">  {</a>
<a name="ln551">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln552">    dt_image_flip(imgid, cw);</a>
<a name="ln553">    t = g_list_delete_link(t, t);</a>
<a name="ln554">    fraction = 1.0 / total;</a>
<a name="ln555">    dt_image_set_aspect_ratio(imgid);</a>
<a name="ln556">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln557">  }</a>
<a name="ln558">  params-&gt;index = NULL;</a>
<a name="ln559">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_COLLECTION_CHANGED);</a>
<a name="ln560">  dt_control_queue_redraw_center();</a>
<a name="ln561">  return 0;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">static char *_get_image_list(GList *l)</a>
<a name="ln565">{</a>
<a name="ln566">  const guint size = g_list_length(l);</a>
<a name="ln567">  char num[8];</a>
<a name="ln568">  char *buffer = calloc(size, sizeof(num));</a>
<a name="ln569">  int imgid;</a>
<a name="ln570">  gboolean first = TRUE;</a>
<a name="ln571"> </a>
<a name="ln572">  buffer[0] = '\0';</a>
<a name="ln573"> </a>
<a name="ln574">  while(l)</a>
<a name="ln575">  {</a>
<a name="ln576">    imgid = GPOINTER_TO_INT(l-&gt;data);</a>
<a name="ln577">    snprintf(num, sizeof(num), &quot;%s%6d&quot;, first ? &quot;&quot; : &quot;,&quot;, imgid);</a>
<a name="ln578">    g_strlcat(buffer, num, size * sizeof(num));</a>
<a name="ln579">    l = g_list_next(l);</a>
<a name="ln580">    first = FALSE;</a>
<a name="ln581">  }</a>
<a name="ln582">  return buffer;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">static void _set_remove_flag(char *imgs)</a>
<a name="ln586">{</a>
<a name="ln587">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln588">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln589">                              &quot;UPDATE main.images SET flags = (flags|?1) WHERE id IN (?2)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln590">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_REMOVE);</a>
<a name="ln591">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln592">  sqlite3_step(stmt);</a>
<a name="ln593">  sqlite3_finalize(stmt);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static GList *_get_full_pathname(char *imgs)</a>
<a name="ln597">{</a>
<a name="ln598">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln599">  GList *list = NULL;</a>
<a name="ln600"> </a>
<a name="ln601">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT DISTINCT folder || '&quot; G_DIR_SEPARATOR_S &quot;' || filename FROM &quot;</a>
<a name="ln602">                                                             &quot;main.images i, main.film_rolls f &quot;</a>
<a name="ln603">                                                             &quot;ON i.film_id = f.id WHERE i.id IN (?1)&quot;,</a>
<a name="ln604">                              -1, &amp;stmt, NULL);</a>
<a name="ln605">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 1, imgs, -1, SQLITE_STATIC);</a>
<a name="ln606">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln607">  {</a>
<a name="ln608">    list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(stmt, 0)));</a>
<a name="ln609">  }</a>
<a name="ln610">  sqlite3_finalize(stmt);</a>
<a name="ln611">  return list;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">static int32_t dt_control_remove_images_job_run(dt_job_t *job)</a>
<a name="ln615">{</a>
<a name="ln616">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln617">  GList *t = params-&gt;index;</a>
<a name="ln618">  char *imgs = _get_image_list(t);</a>
<a name="ln619">  guint total = g_list_length(t);</a>
<a name="ln620">  char message[512] = { 0 };</a>
<a name="ln621">  double fraction = 0;</a>
<a name="ln622">  snprintf(message, sizeof(message), ngettext(&quot;removing %d image&quot;, &quot;removing %d images&quot;, total), total);</a>
<a name="ln623">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln624">  sqlite3_stmt *stmt = NULL;</a>
<a name="ln625"> </a>
<a name="ln626">  // check that we can safely remove the image</a>
<a name="ln627">  gboolean remove_ok = TRUE;</a>
<a name="ln628">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln629">                              &quot;SELECT id FROM main.images WHERE id IN (?2) AND flags&amp;?1=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln630">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, DT_IMAGE_LOCAL_COPY);</a>
<a name="ln631">  DT_DEBUG_SQLITE3_BIND_TEXT(stmt, 2, imgs, -1, SQLITE_STATIC);</a>
<a name="ln632"> </a>
<a name="ln633">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln634">  {</a>
<a name="ln635">    int imgid = sqlite3_column_int(stmt, 0);</a>
<a name="ln636">    if(!dt_image_safe_remove(imgid))</a>
<a name="ln637">    {</a>
<a name="ln638">      remove_ok = FALSE;</a>
<a name="ln639">      break;</a>
<a name="ln640">    }</a>
<a name="ln641">  }</a>
<a name="ln642">  sqlite3_finalize(stmt);</a>
<a name="ln643"> </a>
<a name="ln644">  if(!remove_ok)</a>
<a name="ln645">  {</a>
<a name="ln646">    dt_control_log(_(&quot;cannot remove local copy when the original file is not accessible.&quot;));</a>
<a name="ln647">    free(imgs);</a>
<a name="ln648">    return 0;</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  // update remove status</a>
<a name="ln652">  _set_remove_flag(imgs);</a>
<a name="ln653"> </a>
<a name="ln654">  dt_collection_update(darktable.collection);</a>
<a name="ln655"> </a>
<a name="ln656">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln657">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln658"> </a>
<a name="ln659">  free(imgs);</a>
<a name="ln660"> </a>
<a name="ln661">  while(t)</a>
<a name="ln662">  {</a>
<a name="ln663">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln664">    dt_image_remove(imgid);</a>
<a name="ln665">    t = g_list_delete_link(t, t);</a>
<a name="ln666">    fraction = 1.0 / total;</a>
<a name="ln667">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln668">  }</a>
<a name="ln669">  params-&gt;index = NULL;</a>
<a name="ln670"> </a>
<a name="ln671">  char *imgname;</a>
<a name="ln672">  while(list)</a>
<a name="ln673">  {</a>
<a name="ln674">    imgname = (char *)list-&gt;data;</a>
<a name="ln675">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln676">    list = g_list_delete_link(list, list);</a>
<a name="ln677">  }</a>
<a name="ln678">  dt_film_remove_empty();</a>
<a name="ln679">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln680">  dt_control_queue_redraw_center();</a>
<a name="ln681">  return 0;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">typedef struct _dt_delete_modal_dialog_t</a>
<a name="ln685">{</a>
<a name="ln686">  int send_to_trash;</a>
<a name="ln687">  const char *filename;</a>
<a name="ln688">  const char *error_message;</a>
<a name="ln689"> </a>
<a name="ln690">  gint dialog_result;</a>
<a name="ln691"> </a>
<a name="ln692">  dt_pthread_mutex_t mutex;</a>
<a name="ln693">  pthread_cond_t cond;</a>
<a name="ln694">} _dt_delete_modal_dialog_t;</a>
<a name="ln695"> </a>
<a name="ln696">enum _dt_delete_status</a>
<a name="ln697">{</a>
<a name="ln698">  _DT_DELETE_STATUS_UNKNOWN = 0,</a>
<a name="ln699">  _DT_DELETE_STATUS_OK_TO_REMOVE = 1,</a>
<a name="ln700">  _DT_DELETE_STATUS_SKIP_FILE = 2,</a>
<a name="ln701">  _DT_DELETE_STATUS_STOP_PROCESSING = 3</a>
<a name="ln702">};</a>
<a name="ln703"> </a>
<a name="ln704">enum _dt_delete_dialog_choice</a>
<a name="ln705">{</a>
<a name="ln706">  _DT_DELETE_DIALOG_CHOICE_DELETE = 1,</a>
<a name="ln707">  _DT_DELETE_DIALOG_CHOICE_DELETE_ALL = 2,</a>
<a name="ln708">  _DT_DELETE_DIALOG_CHOICE_REMOVE = 3,</a>
<a name="ln709">  _DT_DELETE_DIALOG_CHOICE_CONTINUE = 4,</a>
<a name="ln710">  _DT_DELETE_DIALOG_CHOICE_STOP = 5</a>
<a name="ln711">};</a>
<a name="ln712"> </a>
<a name="ln713">static gboolean _dt_delete_dialog_main_thread(gpointer user_data)</a>
<a name="ln714">{</a>
<a name="ln715">  _dt_delete_modal_dialog_t* modal_dialog = (_dt_delete_modal_dialog_t*)user_data;</a>
<a name="ln716">  dt_pthread_mutex_lock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln717"> </a>
<a name="ln718">  GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln719">      GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)),</a>
<a name="ln720">      GTK_DIALOG_DESTROY_WITH_PARENT,</a>
<a name="ln721">      GTK_MESSAGE_QUESTION,</a>
<a name="ln722">      GTK_BUTTONS_NONE,</a>
<a name="ln723">      modal_dialog-&gt;send_to_trash</a>
<a name="ln724">        ? _(&quot;could not send %s to trash%s%s&quot;)</a>
<a name="ln725">        : _(&quot;could not physically delete %s%s%s&quot;),</a>
<a name="ln726">      modal_dialog-&gt;filename,</a>
<a name="ln727">      modal_dialog-&gt;error_message != NULL ? &quot;: &quot; : &quot;&quot;,</a>
<a name="ln728">      modal_dialog-&gt;error_message != NULL ? modal_dialog-&gt;error_message : &quot;&quot;);</a>
<a name="ln729">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln730">  dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln731">#endif</a>
<a name="ln732"> </a>
<a name="ln733">  if (modal_dialog-&gt;send_to_trash)</a>
<a name="ln734">  {</a>
<a name="ln735">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE);</a>
<a name="ln736">    gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;physically delete all files&quot;), _DT_DELETE_DIALOG_CHOICE_DELETE_ALL);</a>
<a name="ln737">  }</a>
<a name="ln738">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;only remove from the collection&quot;), _DT_DELETE_DIALOG_CHOICE_REMOVE);</a>
<a name="ln739">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;skip to next file&quot;), _DT_DELETE_DIALOG_CHOICE_CONTINUE);</a>
<a name="ln740">  gtk_dialog_add_button(GTK_DIALOG(dialog), _(&quot;stop process&quot;), _DT_DELETE_DIALOG_CHOICE_STOP);</a>
<a name="ln741"> </a>
<a name="ln742">  gtk_window_set_title(</a>
<a name="ln743">      GTK_WINDOW(dialog),</a>
<a name="ln744">      modal_dialog-&gt;send_to_trash</a>
<a name="ln745">        ? _(&quot;trashing error&quot;)</a>
<a name="ln746">        : _(&quot;deletion error&quot;));</a>
<a name="ln747">  modal_dialog-&gt;dialog_result = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln748">  gtk_widget_destroy(dialog);</a>
<a name="ln749"> </a>
<a name="ln750">  pthread_cond_signal(&amp;modal_dialog-&gt;cond);</a>
<a name="ln751"> </a>
<a name="ln752">  dt_pthread_mutex_unlock(&amp;modal_dialog-&gt;mutex);</a>
<a name="ln753"> </a>
<a name="ln754">  // Don't call again on next idle time</a>
<a name="ln755">  return FALSE;</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">static gint _dt_delete_file_display_modal_dialog(int send_to_trash, const char *filename, const char *error_message)</a>
<a name="ln759">{</a>
<a name="ln760">  _dt_delete_modal_dialog_t modal_dialog;</a>
<a name="ln761">  modal_dialog.send_to_trash = send_to_trash;</a>
<a name="ln762">  modal_dialog.filename = filename;</a>
<a name="ln763">  modal_dialog.error_message = error_message;</a>
<a name="ln764"> </a>
<a name="ln765">  modal_dialog.dialog_result = GTK_RESPONSE_NONE;</a>
<a name="ln766"> </a>
<a name="ln767">  dt_pthread_mutex_init(&amp;modal_dialog.mutex, NULL);</a>
<a name="ln768">  pthread_cond_init(&amp;modal_dialog.cond, NULL);</a>
<a name="ln769"> </a>
<a name="ln770">  dt_pthread_mutex_lock(&amp;modal_dialog.mutex);</a>
<a name="ln771"> </a>
<a name="ln772">  gdk_threads_add_idle(_dt_delete_dialog_main_thread, &amp;modal_dialog);</a>
<a name="ln773">  while (modal_dialog.dialog_result == GTK_RESPONSE_NONE)</a>
<a name="ln774">    dt_pthread_cond_wait(&amp;modal_dialog.cond, &amp;modal_dialog.mutex);</a>
<a name="ln775"> </a>
<a name="ln776">  dt_pthread_mutex_unlock(&amp;modal_dialog.mutex);</a>
<a name="ln777">  dt_pthread_mutex_destroy(&amp;modal_dialog.mutex);</a>
<a name="ln778">  pthread_cond_destroy(&amp;modal_dialog.cond);</a>
<a name="ln779"> </a>
<a name="ln780">  return modal_dialog.dialog_result;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">static enum _dt_delete_status delete_file_from_disk(const char *filename, gboolean *delete_on_trash_error)</a>
<a name="ln784">{</a>
<a name="ln785">  enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln786"> </a>
<a name="ln787">  GFile *gfile = g_file_new_for_path(filename);</a>
<a name="ln788">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln789"> </a>
<a name="ln790">  while (delete_status == _DT_DELETE_STATUS_UNKNOWN)</a>
<a name="ln791">  {</a>
<a name="ln792">    gboolean delete_success = FALSE;</a>
<a name="ln793">    GError *gerror = NULL;</a>
<a name="ln794">    if (send_to_trash)</a>
<a name="ln795">    {</a>
<a name="ln796">#ifdef __APPLE__</a>
<a name="ln797">      delete_success = dt_osx_file_trash(filename, &amp;gerror);</a>
<a name="ln798">#elif defined(_WIN32)</a>
<a name="ln799">      delete_success = dt_win_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln800">#else</a>
<a name="ln801">      delete_success = g_file_trash(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln802">#endif</a>
<a name="ln803">    }</a>
<a name="ln804">    else</a>
<a name="ln805">    {</a>
<a name="ln806">      delete_success = g_file_delete(gfile, NULL /*cancellable*/, &amp;gerror);</a>
<a name="ln807">    }</a>
<a name="ln808"> </a>
<a name="ln809">    // Delete is a success or the file does not exists: OK to remove from collection</a>
<a name="ln810">    if (delete_success</a>
<a name="ln811">        || g_error_matches(gerror, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))</a>
<a name="ln812">    {</a>
<a name="ln813">      delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln814">    }</a>
<a name="ln815">    else if (send_to_trash &amp;&amp; *delete_on_trash_error)</a>
<a name="ln816">    {</a>
<a name="ln817">      // Loop again, this time delete instead of trashing</a>
<a name="ln818">      delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln819">      send_to_trash = FALSE;</a>
<a name="ln820">    }</a>
<a name="ln821">    else</a>
<a name="ln822">    {</a>
<a name="ln823">      const char *filename_display = NULL;</a>
<a name="ln824">      GFileInfo *gfileinfo = g_file_query_info(</a>
<a name="ln825">          gfile,</a>
<a name="ln826">          G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,</a>
<a name="ln827">          G_FILE_QUERY_INFO_NONE,</a>
<a name="ln828">          NULL /*cancellable*/,</a>
<a name="ln829">          NULL /*error*/);</a>
<a name="ln830">      if (gfileinfo != NULL)</a>
<a name="ln831">        filename_display = g_file_info_get_attribute_string(</a>
<a name="ln832">            gfileinfo,</a>
<a name="ln833">            G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME);</a>
<a name="ln834"> </a>
<a name="ln835">      gint res = _dt_delete_file_display_modal_dialog(</a>
<a name="ln836">          send_to_trash,</a>
<a name="ln837">          filename_display == NULL ? filename : filename_display,</a>
<a name="ln838">          gerror == NULL ? NULL : gerror-&gt;message);</a>
<a name="ln839"> </a>
<a name="ln840">      if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE)</a>
<a name="ln841">      {</a>
<a name="ln842">        // Loop again, this time delete instead of trashing</a>
<a name="ln843">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln844">        send_to_trash = FALSE;</a>
<a name="ln845">      }</a>
<a name="ln846">      else if (send_to_trash &amp;&amp; res == _DT_DELETE_DIALOG_CHOICE_DELETE_ALL)</a>
<a name="ln847">      {</a>
<a name="ln848">        // Loop again, this time delete instead of trashing</a>
<a name="ln849">        delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln850">        send_to_trash = FALSE;</a>
<a name="ln851">        *delete_on_trash_error = TRUE;</a>
<a name="ln852">      }</a>
<a name="ln853">      else if (res == _DT_DELETE_DIALOG_CHOICE_REMOVE)</a>
<a name="ln854">      {</a>
<a name="ln855">        delete_status = _DT_DELETE_STATUS_OK_TO_REMOVE;</a>
<a name="ln856">      }</a>
<a name="ln857">      else if (res == _DT_DELETE_DIALOG_CHOICE_CONTINUE)</a>
<a name="ln858">      {</a>
<a name="ln859">        delete_status = _DT_DELETE_STATUS_SKIP_FILE;</a>
<a name="ln860">      }</a>
<a name="ln861">      else</a>
<a name="ln862">      {</a>
<a name="ln863">        delete_status = _DT_DELETE_STATUS_STOP_PROCESSING;</a>
<a name="ln864">      }</a>
<a name="ln865">    }</a>
<a name="ln866">    if (gerror != NULL)</a>
<a name="ln867">      g_error_free(gerror);</a>
<a name="ln868">  }</a>
<a name="ln869"> </a>
<a name="ln870">  if (gfile != NULL)</a>
<a name="ln871">    g_object_unref(gfile);</a>
<a name="ln872"> </a>
<a name="ln873">  return delete_status;</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">static int32_t dt_control_delete_images_job_run(dt_job_t *job)</a>
<a name="ln878">{</a>
<a name="ln879">  int imgid = -1;</a>
<a name="ln880">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln881">  GList *t = params-&gt;index;</a>
<a name="ln882">  char *imgs = _get_image_list(t);</a>
<a name="ln883">  char imgidstr[25] = { 0 };</a>
<a name="ln884">  guint total = g_list_length(t);</a>
<a name="ln885">  char message[512] = { 0 };</a>
<a name="ln886">  double fraction = 0;</a>
<a name="ln887">  gboolean delete_on_trash_error = FALSE;</a>
<a name="ln888">  if (dt_conf_get_bool(&quot;send_to_trash&quot;))</a>
<a name="ln889">    snprintf(message, sizeof(message), ngettext(&quot;trashing %d image&quot;, &quot;trashing %d images&quot;, total), total);</a>
<a name="ln890">  else</a>
<a name="ln891">    snprintf(message, sizeof(message), ngettext(&quot;deleting %d image&quot;, &quot;deleting %d images&quot;, total), total);</a>
<a name="ln892">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln893"> </a>
<a name="ln894">  sqlite3_stmt *stmt;</a>
<a name="ln895"> </a>
<a name="ln896">  dt_collection_update(darktable.collection);</a>
<a name="ln897"> </a>
<a name="ln898">  // We need a list of files to regenerate .xmp files if there are duplicates</a>
<a name="ln899">  GList *list = _get_full_pathname(imgs);</a>
<a name="ln900"> </a>
<a name="ln901">  free(imgs);</a>
<a name="ln902"> </a>
<a name="ln903">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db),</a>
<a name="ln904">                              &quot;SELECT COUNT(*) FROM main.images WHERE filename IN (SELECT filename FROM &quot;</a>
<a name="ln905">                              &quot;main.images WHERE id = ?1) AND film_id IN (SELECT film_id FROM main.images WHERE &quot;</a>
<a name="ln906">                              &quot;id = ?1)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln907">  while(t)</a>
<a name="ln908">  {</a>
<a name="ln909">    enum _dt_delete_status delete_status = _DT_DELETE_STATUS_UNKNOWN;</a>
<a name="ln910">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln911">    char filename[PATH_MAX] = { 0 };</a>
<a name="ln912">    gboolean from_cache = FALSE;</a>
<a name="ln913">    dt_image_full_path(imgid, filename, sizeof(filename), &amp;from_cache);</a>
<a name="ln914"> </a>
<a name="ln915">#ifdef _WIN32</a>
<a name="ln916">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln917">#endif</a>
<a name="ln918"> </a>
<a name="ln919">    int duplicates = 0;</a>
<a name="ln920">    DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln921">    if(sqlite3_step(stmt) == SQLITE_ROW) duplicates = sqlite3_column_int(stmt, 0);</a>
<a name="ln922">    sqlite3_reset(stmt);</a>
<a name="ln923">    sqlite3_clear_bindings(stmt);</a>
<a name="ln924"> </a>
<a name="ln925">    // remove from disk:</a>
<a name="ln926">    if(duplicates == 1)</a>
<a name="ln927">    {</a>
<a name="ln928">      // first check for local copies, never delete a file whose original file is not accessible</a>
<a name="ln929">      if (dt_image_local_copy_reset(imgid))</a>
<a name="ln930">        goto delete_next_file;</a>
<a name="ln931"> </a>
<a name="ln932">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln933">      _set_remove_flag(imgidstr);</a>
<a name="ln934">      dt_image_remove(imgid);</a>
<a name="ln935"> </a>
<a name="ln936">      // there are no further duplicates so we can remove the source data file</a>
<a name="ln937">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln938">      if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln939">        goto delete_next_file;</a>
<a name="ln940"> </a>
<a name="ln941">      // all sidecar files - including left-overs - can be deleted;</a>
<a name="ln942">      // left-overs can result when previously duplicates have been REMOVED;</a>
<a name="ln943">      // no need to keep them as the source data file is gone.</a>
<a name="ln944">      gchar pattern[PATH_MAX] = { 0 };</a>
<a name="ln945"> </a>
<a name="ln946">      // NULL terminated list of glob patterns; should include &quot;&quot; and can be extended if needed</a>
<a name="ln947">      static const gchar *glob_patterns[]</a>
<a name="ln948">          = { &quot;&quot;, &quot;_[0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9]&quot;, &quot;_[0-9][0-9][0-9][0-9]&quot;, NULL };</a>
<a name="ln949"> </a>
<a name="ln950">      const gchar **glob_pattern = glob_patterns;</a>
<a name="ln951">      GList *files = NULL;</a>
<a name="ln952">      while(*glob_pattern)</a>
<a name="ln953">      {</a>
<a name="ln954">        snprintf(pattern, sizeof(pattern), &quot;%s&quot;, filename);</a>
<a name="ln955">        gchar *c1 = pattern + strlen(pattern);</a>
<a name="ln956">        while(*c1 != '.' &amp;&amp; c1 &gt; pattern) c1--;</a>
<a name="ln957">        snprintf(c1, pattern + sizeof(pattern) - c1, &quot;%s&quot;, *glob_pattern);</a>
<a name="ln958">        const gchar *c2 = filename + strlen(filename);</a>
<a name="ln959">        while(*c2 != '.' &amp;&amp; c2 &gt; filename) c2--;</a>
<a name="ln960">        snprintf(c1 + strlen(*glob_pattern), pattern + sizeof(pattern) - c1 - strlen(*glob_pattern), &quot;%s.xmp&quot;,</a>
<a name="ln961">                 c2);</a>
<a name="ln962"> </a>
<a name="ln963">#ifdef _WIN32</a>
<a name="ln964">        wchar_t *wpattern = g_utf8_to_utf16(pattern, -1, NULL, NULL, NULL);</a>
<a name="ln965">        WIN32_FIND_DATAW data;</a>
<a name="ln966">        HANDLE handle = FindFirstFileW(wpattern, &amp;data);</a>
<a name="ln967">        g_free(wpattern);</a>
<a name="ln968">        if(handle != INVALID_HANDLE_VALUE)</a>
<a name="ln969">        {</a>
<a name="ln970">          do</a>
<a name="ln971">          {</a>
<a name="ln972">            char *xmp_filename = g_utf16_to_utf8(data.cFileName, -1, NULL, NULL, NULL);</a>
<a name="ln973">            files = g_list_append(files, g_build_filename(dirname, xmp_filename, NULL));</a>
<a name="ln974">            g_free(xmp_filename);</a>
<a name="ln975">          }</a>
<a name="ln976">          while(FindNextFileW(handle, &amp;data));</a>
<a name="ln977">        }</a>
<a name="ln978">#else</a>
<a name="ln979">        glob_t globbuf;</a>
<a name="ln980">        if(!glob(pattern, 0, NULL, &amp;globbuf))</a>
<a name="ln981">        {</a>
<a name="ln982">          for(size_t i = 0; i &lt; globbuf.gl_pathc; i++)</a>
<a name="ln983">            files = g_list_append(files, g_strdup(globbuf.gl_pathv[i]));</a>
<a name="ln984">          globfree(&amp;globbuf);</a>
<a name="ln985">        }</a>
<a name="ln986">#endif</a>
<a name="ln987"> </a>
<a name="ln988">        glob_pattern++;</a>
<a name="ln989">      }</a>
<a name="ln990"> </a>
<a name="ln991">      GList *file_iter = g_list_first(files);</a>
<a name="ln992">      while(file_iter != NULL)</a>
<a name="ln993">      {</a>
<a name="ln994">        delete_status = delete_file_from_disk(file_iter-&gt;data, &amp;delete_on_trash_error);</a>
<a name="ln995">        if (delete_status != _DT_DELETE_STATUS_OK_TO_REMOVE)</a>
<a name="ln996">          break;</a>
<a name="ln997">        file_iter = g_list_next(file_iter);</a>
<a name="ln998">      }</a>
<a name="ln999"> </a>
<a name="ln1000">      g_list_free_full(files, g_free);</a>
<a name="ln1001">    }</a>
<a name="ln1002">    else</a>
<a name="ln1003">    {</a>
<a name="ln1004">      // don't remove the actual source data if there are further duplicates using it;</a>
<a name="ln1005">      // just delete the xmp file of the duplicate selected.</a>
<a name="ln1006"> </a>
<a name="ln1007">      dt_image_path_append_version(imgid, filename, sizeof(filename));</a>
<a name="ln1008">      g_strlcat(filename, &quot;.xmp&quot;, sizeof(filename));</a>
<a name="ln1009"> </a>
<a name="ln1010">      // remove image from db first ...</a>
<a name="ln1011">      snprintf(imgidstr, sizeof(imgidstr), &quot;%d&quot;, imgid);</a>
<a name="ln1012">      _set_remove_flag(imgidstr);</a>
<a name="ln1013">      dt_image_remove(imgid);</a>
<a name="ln1014"> </a>
<a name="ln1015">      // ... and delete afterwards because removing will re-write the XMP</a>
<a name="ln1016">      delete_status = delete_file_from_disk(filename, &amp;delete_on_trash_error);</a>
<a name="ln1017">    }</a>
<a name="ln1018"> </a>
<a name="ln1019">delete_next_file:</a>
<a name="ln1020">#ifdef _WIN32</a>
<a name="ln1021">    g_free(dirname);</a>
<a name="ln1022">#endif</a>
<a name="ln1023">    t = g_list_delete_link(t, t);</a>
<a name="ln1024">    fraction = 1.0 / total;</a>
<a name="ln1025">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1026">    if (delete_status == _DT_DELETE_STATUS_STOP_PROCESSING)</a>
<a name="ln1027">      break;</a>
<a name="ln1028">  }</a>
<a name="ln1029">  while (t)</a>
<a name="ln1030">    t = g_list_delete_link(t, t);</a>
<a name="ln1031">  params-&gt;index = NULL;</a>
<a name="ln1032">  sqlite3_finalize(stmt);</a>
<a name="ln1033"> </a>
<a name="ln1034">  char *imgname;</a>
<a name="ln1035">  while(list)</a>
<a name="ln1036">  {</a>
<a name="ln1037">    imgname = (char *)list-&gt;data;</a>
<a name="ln1038">    dt_image_synch_all_xmp(imgname);</a>
<a name="ln1039">    list = g_list_delete_link(list, list);</a>
<a name="ln1040">  }</a>
<a name="ln1041">  g_list_free(list);</a>
<a name="ln1042">  dt_film_remove_empty();</a>
<a name="ln1043">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1044">  dt_control_queue_redraw_center();</a>
<a name="ln1045">  return 0;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">static int32_t dt_control_gpx_apply_job_run(dt_job_t *job)</a>
<a name="ln1049">{</a>
<a name="ln1050">  dt_control_image_enumerator_t *params = dt_control_job_get_params(job);</a>
<a name="ln1051">  GList *t = params-&gt;index;</a>
<a name="ln1052">  struct dt_gpx_t *gpx = NULL;</a>
<a name="ln1053">  uint32_t cntr = 0;</a>
<a name="ln1054">  const dt_control_gpx_apply_t *d = params-&gt;data;</a>
<a name="ln1055">  const gchar *filename = d-&gt;filename;</a>
<a name="ln1056">  const gchar *tz = d-&gt;tz;</a>
<a name="ln1057"> </a>
<a name="ln1058">  /* do we have any selected images */</a>
<a name="ln1059">  if(!t) goto bail_out;</a>
<a name="ln1060"> </a>
<a name="ln1061">  /* try parse the gpx data */</a>
<a name="ln1062">  gpx = dt_gpx_new(filename);</a>
<a name="ln1063">  if(!gpx)</a>
<a name="ln1064">  {</a>
<a name="ln1065">    dt_control_log(_(&quot;failed to parse GPX file&quot;));</a>
<a name="ln1066">    goto bail_out;</a>
<a name="ln1067">  }</a>
<a name="ln1068"> </a>
<a name="ln1069">  GTimeZone *tz_camera = (tz == NULL) ? g_time_zone_new_utc() : g_time_zone_new(tz);</a>
<a name="ln1070">  if(!tz_camera) goto bail_out;</a>
<a name="ln1071">  GTimeZone *tz_utc = g_time_zone_new_utc();</a>
<a name="ln1072"> </a>
<a name="ln1073">  /* go thru each selected image and lookup location in gpx */</a>
<a name="ln1074">  do</a>
<a name="ln1075">  {</a>
<a name="ln1076">    GTimeVal timestamp;</a>
<a name="ln1077">    GDateTime *exif_time, *utc_time;</a>
<a name="ln1078">    gdouble lon, lat, ele;</a>
<a name="ln1079">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1080"> </a>
<a name="ln1081">    /* get image */</a>
<a name="ln1082">    const dt_image_t *cimg = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln1083">    if(!cimg) continue;</a>
<a name="ln1084"> </a>
<a name="ln1085">    /* convert exif datetime</a>
<a name="ln1086">       TODO: exiv2 dates should be iso8601 and we are probably doing some ugly</a>
<a name="ln1087">       conversion before inserting into database.</a>
<a name="ln1088">     */</a>
<a name="ln1089">    gint year;</a>
<a name="ln1090">    gint month;</a>
<a name="ln1091">    gint day;</a>
<a name="ln1092">    gint hour;</a>
<a name="ln1093">    gint minute;</a>
<a name="ln1094">    gint seconds;</a>
<a name="ln1095"> </a>
<a name="ln1096">    if(sscanf(cimg-&gt;exif_datetime_taken, &quot;%d:%d:%d %d:%d:%d&quot;, (int *)&amp;year, (int *)&amp;month, (int *)&amp;day,</a>
<a name="ln1097">              (int *)&amp;hour, (int *)&amp;minute, (int *)&amp;seconds) != 6)</a>
<a name="ln1098">    {</a>
<a name="ln1099">      fprintf(stderr, &quot;broken exif time in db, '%s'\n&quot;, cimg-&gt;exif_datetime_taken);</a>
<a name="ln1100">      dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1101">      continue;</a>
<a name="ln1102">    }</a>
<a name="ln1103"> </a>
<a name="ln1104">    /* release the lock */</a>
<a name="ln1105">    dt_image_cache_read_release(darktable.image_cache, cimg);</a>
<a name="ln1106"> </a>
<a name="ln1107">    exif_time = g_date_time_new(tz_camera, year, month, day, hour, minute, seconds);</a>
<a name="ln1108">    if(!exif_time) continue;</a>
<a name="ln1109">    utc_time = g_date_time_to_timezone(exif_time, tz_utc);</a>
<a name="ln1110">    g_date_time_unref(exif_time);</a>
<a name="ln1111">    if(!utc_time) continue;</a>
<a name="ln1112">    gboolean res = g_date_time_to_timeval(utc_time, &amp;timestamp);</a>
<a name="ln1113">    g_date_time_unref(utc_time);</a>
<a name="ln1114">    if(!res) continue;</a>
<a name="ln1115"> </a>
<a name="ln1116">    /* only update image location if time is within gpx tack range */</a>
<a name="ln1117">    if(dt_gpx_get_location(gpx, &amp;timestamp, &amp;lon, &amp;lat, &amp;ele))</a>
<a name="ln1118">    {</a>
<a name="ln1119">      dt_image_set_location_and_elevation(imgid, lon, lat, ele);</a>
<a name="ln1120">      cntr++;</a>
<a name="ln1121">    }</a>
<a name="ln1122"> </a>
<a name="ln1123">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1124"> </a>
<a name="ln1125">  dt_control_log(ngettext(&quot;applied matched GPX location onto %d image&quot;, &quot;applied matched GPX location onto %d images&quot;, cntr), cntr);</a>
<a name="ln1126"> </a>
<a name="ln1127">  g_time_zone_unref(tz_camera);</a>
<a name="ln1128">  g_time_zone_unref(tz_utc);</a>
<a name="ln1129">  dt_gpx_destroy(gpx);</a>
<a name="ln1130">  return 0;</a>
<a name="ln1131"> </a>
<a name="ln1132">bail_out:</a>
<a name="ln1133">  if(gpx) dt_gpx_destroy(gpx);</a>
<a name="ln1134"> </a>
<a name="ln1135">  return 1;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">static int32_t dt_control_move_images_job_run(dt_job_t *job)</a>
<a name="ln1139">{</a>
<a name="ln1140">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_move, _(&quot;moving %d image&quot;),</a>
<a name="ln1141">                                                   _(&quot;moving %d images&quot;));</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">static int32_t dt_control_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1145">{</a>
<a name="ln1146">  return _generic_dt_control_fileop_images_job_run(job, &amp;dt_image_copy, _(&quot;copying %d image&quot;),</a>
<a name="ln1147">                                                   _(&quot;copying %d images&quot;));</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150">static int32_t dt_control_local_copy_images_job_run(dt_job_t *job)</a>
<a name="ln1151">{</a>
<a name="ln1152">  int imgid = -1;</a>
<a name="ln1153">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1154">  GList *t = params-&gt;index;</a>
<a name="ln1155">  guint tagid = 0;</a>
<a name="ln1156">  const guint total = g_list_length(t);</a>
<a name="ln1157">  double fraction = 0;</a>
<a name="ln1158">  gboolean is_copy = params-&gt;flag == 1;</a>
<a name="ln1159">  char message[512] = { 0 };</a>
<a name="ln1160"> </a>
<a name="ln1161">  if(is_copy)</a>
<a name="ln1162">    snprintf(message, sizeof(message),</a>
<a name="ln1163">             ngettext(&quot;creating local copy of %d image&quot;, &quot;creating local copies of %d images&quot;, total), total);</a>
<a name="ln1164">  else</a>
<a name="ln1165">    snprintf(message, sizeof(message),</a>
<a name="ln1166">             ngettext(&quot;removing local copy of %d image&quot;, &quot;removing local copies of %d images&quot;, total), total);</a>
<a name="ln1167"> </a>
<a name="ln1168">  dt_control_log(&quot;%s&quot;, message);</a>
<a name="ln1169">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1170"> </a>
<a name="ln1171">  dt_tag_new(&quot;darktable|local-copy&quot;, &amp;tagid);</a>
<a name="ln1172"> </a>
<a name="ln1173">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1174">  {</a>
<a name="ln1175">    imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1176">    if(is_copy)</a>
<a name="ln1177">    {</a>
<a name="ln1178">      if (dt_image_local_copy_set(imgid) == 0)</a>
<a name="ln1179">        dt_tag_attach(tagid, imgid);</a>
<a name="ln1180">    }</a>
<a name="ln1181">    else</a>
<a name="ln1182">    {</a>
<a name="ln1183">      if (dt_image_local_copy_reset(imgid) == 0)</a>
<a name="ln1184">        dt_tag_detach(tagid, imgid);</a>
<a name="ln1185">    }</a>
<a name="ln1186">    t = g_list_delete_link(t, t);</a>
<a name="ln1187"> </a>
<a name="ln1188">    fraction += 1.0 / total;</a>
<a name="ln1189">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1190">  }</a>
<a name="ln1191">  params-&gt;index = NULL;</a>
<a name="ln1192"> </a>
<a name="ln1193">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_FILMROLLS_CHANGED);</a>
<a name="ln1194">  return 0;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">static int32_t dt_control_export_job_run(dt_job_t *job)</a>
<a name="ln1198">{</a>
<a name="ln1199">  int imgid = -1;</a>
<a name="ln1200">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1201">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1202">  GList *t = params-&gt;index;</a>
<a name="ln1203">  dt_imageio_module_format_t *mformat = dt_imageio_get_format_by_index(settings-&gt;format_index);</a>
<a name="ln1204">  g_assert(mformat);</a>
<a name="ln1205">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1206">  g_assert(mstorage);</a>
<a name="ln1207">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1208"> </a>
<a name="ln1209">  // get a thread-safe fdata struct (one jpeg struct per thread etc):</a>
<a name="ln1210">  dt_imageio_module_data_t *fdata = mformat-&gt;get_params(mformat);</a>
<a name="ln1211"> </a>
<a name="ln1212">  if(mstorage-&gt;initialize_store)</a>
<a name="ln1213">  {</a>
<a name="ln1214">    if(mstorage-&gt;initialize_store(mstorage, sdata, &amp;mformat, &amp;fdata, &amp;t, settings-&gt;high_quality, settings-&gt;upscale))</a>
<a name="ln1215">    {</a>
<a name="ln1216">      // bail out, something went wrong</a>
<a name="ln1217">      goto end;</a>
<a name="ln1218">    }</a>
<a name="ln1219">    mformat-&gt;set_params(mformat, fdata, mformat-&gt;params_size(mformat));</a>
<a name="ln1220">    mstorage-&gt;set_params(mstorage, sdata, mstorage-&gt;params_size(mstorage));</a>
<a name="ln1221">  }</a>
<a name="ln1222"> </a>
<a name="ln1223">  // Get max dimensions...</a>
<a name="ln1224">  uint32_t w, h, fw, fh, sw, sh;</a>
<a name="ln1225">  fw = fh = sw = sh = 0;</a>
<a name="ln1226">  mstorage-&gt;dimension(mstorage, sdata, &amp;sw, &amp;sh);</a>
<a name="ln1227">  mformat-&gt;dimension(mformat, fdata, &amp;fw, &amp;fh);</a>
<a name="ln1228"> </a>
<a name="ln1229">  if(sw == 0 || fw == 0)</a>
<a name="ln1230">    w = sw &gt; fw ? sw : fw;</a>
<a name="ln1231">  else</a>
<a name="ln1232">    w = sw &lt; fw ? sw : fw;</a>
<a name="ln1233"> </a>
<a name="ln1234">  if(sh == 0 || fh == 0)</a>
<a name="ln1235">    h = sh &gt; fh ? sh : fh;</a>
<a name="ln1236">  else</a>
<a name="ln1237">    h = sh &lt; fh ? sh : fh;</a>
<a name="ln1238"> </a>
<a name="ln1239">  const guint total = g_list_length(t);</a>
<a name="ln1240">  dt_control_log(ngettext(&quot;exporting %d image..&quot;, &quot;exporting %d images..&quot;, total), total);</a>
<a name="ln1241">  char message[512] = { 0 };</a>
<a name="ln1242">  snprintf(message, sizeof(message), ngettext(&quot;exporting %d image to %s&quot;, &quot;exporting %d images to %s&quot;, total),</a>
<a name="ln1243">           total, mstorage-&gt;name(mstorage));</a>
<a name="ln1244">  // update the message. initialize_store() might have changed the number of images</a>
<a name="ln1245">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1246"> </a>
<a name="ln1247">  double fraction = 0;</a>
<a name="ln1248"> </a>
<a name="ln1249">  // set up the fdata struct</a>
<a name="ln1250">  fdata-&gt;max_width = (settings-&gt;max_width != 0 &amp;&amp; w != 0) ? MIN(w, settings-&gt;max_width) : MAX(w, settings-&gt;max_width);</a>
<a name="ln1251">  fdata-&gt;max_height = (settings-&gt;max_height != 0 &amp;&amp; h != 0) ? MIN(h, settings-&gt;max_height) : MAX(h, settings-&gt;max_height);</a>
<a name="ln1252">  g_strlcpy(fdata-&gt;style, settings-&gt;style, sizeof(fdata-&gt;style));</a>
<a name="ln1253">  fdata-&gt;style_append = settings-&gt;style_append;</a>
<a name="ln1254">  guint num = 0;</a>
<a name="ln1255">  // Invariant: the tagid for 'darktable|changed' will not change while this function runs. Is this a</a>
<a name="ln1256">  // sensible assumption?</a>
<a name="ln1257">  guint tagid = 0, etagid = 0;</a>
<a name="ln1258">  dt_tag_new(&quot;darktable|changed&quot;, &amp;tagid);</a>
<a name="ln1259">  dt_tag_new(&quot;darktable|exported&quot;, &amp;etagid);</a>
<a name="ln1260"> </a>
<a name="ln1261">  while(t &amp;&amp; dt_control_job_get_state(job) != DT_JOB_STATE_CANCELLED)</a>
<a name="ln1262">  {</a>
<a name="ln1263">    if(!t)</a>
<a name="ln1264">      imgid = 0;</a>
<a name="ln1265">    else</a>
<a name="ln1266">    {</a>
<a name="ln1267">      imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1268">      t = g_list_delete_link(t, t);</a>
<a name="ln1269">      num = total - g_list_length(t);</a>
<a name="ln1270">    }</a>
<a name="ln1271"> </a>
<a name="ln1272">    // remove 'changed' tag from image</a>
<a name="ln1273">    dt_tag_detach(tagid, imgid);</a>
<a name="ln1274">    // make sure the 'exported' tag is set on the image</a>
<a name="ln1275">    dt_tag_attach(etagid, imgid);</a>
<a name="ln1276">    // check if image still exists:</a>
<a name="ln1277">    char imgfilename[PATH_MAX] = { 0 };</a>
<a name="ln1278">    const dt_image_t *image = dt_image_cache_get(darktable.image_cache, (int32_t)imgid, 'r');</a>
<a name="ln1279">    if(image)</a>
<a name="ln1280">    {</a>
<a name="ln1281">      gboolean from_cache = TRUE;</a>
<a name="ln1282">      dt_image_full_path(image-&gt;id, imgfilename, sizeof(imgfilename), &amp;from_cache);</a>
<a name="ln1283">      if(!g_file_test(imgfilename, G_FILE_TEST_IS_REGULAR))</a>
<a name="ln1284">      {</a>
<a name="ln1285">        dt_control_log(_(&quot;image `%s' is currently unavailable&quot;), image-&gt;filename);</a>
<a name="ln1286">        fprintf(stderr, &quot;image `%s' is currently unavailable\n&quot;, imgfilename);</a>
<a name="ln1287">        // dt_image_remove(imgid);</a>
<a name="ln1288">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1289">      }</a>
<a name="ln1290">      else</a>
<a name="ln1291">      {</a>
<a name="ln1292">        dt_image_cache_read_release(darktable.image_cache, image);</a>
<a name="ln1293">        if(mstorage-&gt;store(mstorage, sdata, imgid, mformat, fdata, num, total, settings-&gt;high_quality,</a>
<a name="ln1294">                           settings-&gt;upscale, settings-&gt;icc_type, settings-&gt;icc_filename, settings-&gt;icc_intent) != 0)</a>
<a name="ln1295">          dt_control_job_cancel(job);</a>
<a name="ln1296">      }</a>
<a name="ln1297">    }</a>
<a name="ln1298"> </a>
<a name="ln1299">    fraction += 1.0 / total;</a>
<a name="ln1300">    if(fraction &gt; 1.0) fraction = 1.0;</a>
<a name="ln1301">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1302">  }</a>
<a name="ln1303">  params-&gt;index = NULL;</a>
<a name="ln1304"> </a>
<a name="ln1305">  if(mstorage-&gt;finalize_store) mstorage-&gt;finalize_store(mstorage, sdata);</a>
<a name="ln1306"> </a>
<a name="ln1307">end:</a>
<a name="ln1308">  // all threads free their fdata</a>
<a name="ln1309">  mformat-&gt;free_params(mformat, fdata);</a>
<a name="ln1310"> </a>
<a name="ln1311">  // notify the user via the window manager</a>
<a name="ln1312">  dt_ui_notify_user();</a>
<a name="ln1313"> </a>
<a name="ln1314">  return 0;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">static dt_control_image_enumerator_t *dt_control_gpx_apply_alloc()</a>
<a name="ln1318">{</a>
<a name="ln1319">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1320">  if(!params) return NULL;</a>
<a name="ln1321"> </a>
<a name="ln1322">  params-&gt;data = calloc(1, sizeof(dt_control_gpx_apply_t));</a>
<a name="ln1323">  if(!params-&gt;data)</a>
<a name="ln1324">  {</a>
<a name="ln1325">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1326">    return NULL;</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  return params;</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">static void dt_control_gpx_apply_job_cleanup(void *p)</a>
<a name="ln1333">{</a>
<a name="ln1334">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1335"> </a>
<a name="ln1336">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1337">  g_free(data-&gt;filename);</a>
<a name="ln1338">  g_free(data-&gt;tz);</a>
<a name="ln1339"> </a>
<a name="ln1340">  free(data);</a>
<a name="ln1341"> </a>
<a name="ln1342">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345">static dt_job_t *dt_control_gpx_apply_job_create(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1346">{</a>
<a name="ln1347">  dt_job_t *job = dt_control_job_create(&amp;dt_control_gpx_apply_job_run, &quot;gpx apply&quot;);</a>
<a name="ln1348">  if(!job) return NULL;</a>
<a name="ln1349">  dt_control_image_enumerator_t *params = dt_control_gpx_apply_alloc();</a>
<a name="ln1350">  if(!params)</a>
<a name="ln1351">  {</a>
<a name="ln1352">    dt_control_job_dispose(job);</a>
<a name="ln1353">    return NULL;</a>
<a name="ln1354">  }</a>
<a name="ln1355">  dt_control_job_set_params(job, params, dt_control_gpx_apply_job_cleanup);</a>
<a name="ln1356"> </a>
<a name="ln1357">  if(filmid != -1)</a>
<a name="ln1358">    dt_control_image_enumerator_job_film_init(params, filmid);</a>
<a name="ln1359">  else</a>
<a name="ln1360">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1361"> </a>
<a name="ln1362">  dt_control_gpx_apply_t *data = params-&gt;data;</a>
<a name="ln1363">  data-&gt;filename = g_strdup(filename);</a>
<a name="ln1364">  data-&gt;tz = g_strdup(tz);</a>
<a name="ln1365"> </a>
<a name="ln1366">  return job;</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369">void dt_control_merge_hdr()</a>
<a name="ln1370">{</a>
<a name="ln1371">  dt_control_add_job(</a>
<a name="ln1372">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1373">      dt_control_generic_images_job_create(&amp;dt_control_merge_hdr_job_run, N_(&quot;merge hdr image&quot;), 0, NULL,</a>
<a name="ln1374">                                           PROGRESS_CANCELLABLE));</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">void dt_control_gpx_apply(const gchar *filename, int32_t filmid, const gchar *tz)</a>
<a name="ln1378">{</a>
<a name="ln1379">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1380">                     dt_control_gpx_apply_job_create(filename, filmid, tz));</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">void dt_control_duplicate_images()</a>
<a name="ln1384">{</a>
<a name="ln1385">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1386">                     dt_control_generic_images_job_create(&amp;dt_control_duplicate_images_job_run,</a>
<a name="ln1387">                                                          N_(&quot;duplicate images&quot;), 0, NULL, PROGRESS_SIMPLE));</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">void dt_control_flip_images(const int32_t cw)</a>
<a name="ln1391">{</a>
<a name="ln1392">  dt_control_add_job(</a>
<a name="ln1393">      darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1394">      dt_control_generic_images_job_create(&amp;dt_control_flip_images_job_run, N_(&quot;flip images&quot;), cw, NULL,</a>
<a name="ln1395">                                           PROGRESS_SIMPLE));</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">gboolean dt_control_remove_images()</a>
<a name="ln1399">{</a>
<a name="ln1400">  // get all selected images now, to avoid the set changing during ui interaction</a>
<a name="ln1401">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_remove_images_job_run, N_(&quot;remove images&quot;), 0, NULL,</a>
<a name="ln1402">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1403">  if(dt_conf_get_bool(&quot;ask_before_remove&quot;))</a>
<a name="ln1404">  {</a>
<a name="ln1405">    GtkWidget *dialog;</a>
<a name="ln1406">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1407"> </a>
<a name="ln1408">    int number;</a>
<a name="ln1409">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1410">      number = 1;</a>
<a name="ln1411">    else</a>
<a name="ln1412">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1413"> </a>
<a name="ln1414">    // Do not show the dialog if no image is selected:</a>
<a name="ln1415">    if(number == 0)</a>
<a name="ln1416">    {</a>
<a name="ln1417">      dt_control_job_dispose(job);</a>
<a name="ln1418">      return TRUE;</a>
<a name="ln1419">    }</a>
<a name="ln1420"> </a>
<a name="ln1421">    dialog = gtk_message_dialog_new(</a>
<a name="ln1422">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1423">        ngettext(&quot;do you really want to remove %d selected image from the collection?&quot;,</a>
<a name="ln1424">                 &quot;do you really want to remove %d selected images from the collection?&quot;, number),</a>
<a name="ln1425">        number);</a>
<a name="ln1426">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1427">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1428">#endif</a>
<a name="ln1429"> </a>
<a name="ln1430">    gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;remove images?&quot;));</a>
<a name="ln1431">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1432">    gtk_widget_destroy(dialog);</a>
<a name="ln1433">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1434">    {</a>
<a name="ln1435">      dt_control_job_dispose(job);</a>
<a name="ln1436">      return FALSE;</a>
<a name="ln1437">    }</a>
<a name="ln1438">  }</a>
<a name="ln1439">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1440">  return TRUE;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">void dt_control_delete_images()</a>
<a name="ln1444">{</a>
<a name="ln1445">  // first get all selected images, to avoid the set changing during ui interaction</a>
<a name="ln1446">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_delete_images_job_run, N_(&quot;delete images&quot;), 0, NULL,</a>
<a name="ln1447">                                                       PROGRESS_SIMPLE);</a>
<a name="ln1448">  int send_to_trash = dt_conf_get_bool(&quot;send_to_trash&quot;);</a>
<a name="ln1449">  if(dt_conf_get_bool(&quot;ask_before_delete&quot;))</a>
<a name="ln1450">  {</a>
<a name="ln1451">    GtkWidget *dialog;</a>
<a name="ln1452">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1453"> </a>
<a name="ln1454">    int number;</a>
<a name="ln1455">    if (dt_view_get_image_to_act_on() != -1)</a>
<a name="ln1456">      number = 1;</a>
<a name="ln1457">    else</a>
<a name="ln1458">      number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1459"> </a>
<a name="ln1460">    // Do not show the dialog if no image is selected:</a>
<a name="ln1461">    if(number == 0)</a>
<a name="ln1462">    {</a>
<a name="ln1463">      dt_control_job_dispose(job);</a>
<a name="ln1464">      return;</a>
<a name="ln1465">    }</a>
<a name="ln1466"> </a>
<a name="ln1467">    dialog = gtk_message_dialog_new(</a>
<a name="ln1468">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1469">        send_to_trash</a>
<a name="ln1470">        ? ngettext(&quot;do you really want to send %d selected image to trash?&quot;,</a>
<a name="ln1471">          &quot;do you really want to send %d selected images to trash?&quot;, number)</a>
<a name="ln1472">        : ngettext(&quot;do you really want to physically delete %d selected image from disk?&quot;,</a>
<a name="ln1473">          &quot;do you really want to physically delete %d selected images from disk?&quot;, number),</a>
<a name="ln1474">        number);</a>
<a name="ln1475">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1476">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1477">#endif</a>
<a name="ln1478"> </a>
<a name="ln1479">    gtk_window_set_title(GTK_WINDOW(dialog), send_to_trash ? _(&quot;trash images?&quot;) : _(&quot;delete images?&quot;));</a>
<a name="ln1480">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1481">    gtk_widget_destroy(dialog);</a>
<a name="ln1482">    if(res != GTK_RESPONSE_YES)</a>
<a name="ln1483">    {</a>
<a name="ln1484">      dt_control_job_dispose(job);</a>
<a name="ln1485">      return;</a>
<a name="ln1486">    }</a>
<a name="ln1487">  }</a>
<a name="ln1488">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">void dt_control_move_images()</a>
<a name="ln1492">{</a>
<a name="ln1493">  // Open file chooser dialog</a>
<a name="ln1494">  gchar *dir = NULL;</a>
<a name="ln1495">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1496">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1497"> </a>
<a name="ln1498">  // Do not show the dialog if no image is selected:</a>
<a name="ln1499">  if(number == 0) return;</a>
<a name="ln1500">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_move_images_job_run, N_(&quot;move images&quot;), 0, dir,</a>
<a name="ln1501">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1502"> </a>
<a name="ln1503">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1504">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1505">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1506">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1507">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1508">#endif</a>
<a name="ln1509"> </a>
<a name="ln1510">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1511">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1512">  {</a>
<a name="ln1513">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1514">  }</a>
<a name="ln1515">  gtk_widget_destroy(filechooser);</a>
<a name="ln1516"> </a>
<a name="ln1517">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1518"> </a>
<a name="ln1519">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1520">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1521"> </a>
<a name="ln1522">  if(dt_conf_get_bool(&quot;ask_before_move&quot;))</a>
<a name="ln1523">  {</a>
<a name="ln1524">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1525">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1526">        ngettext(&quot;do you really want to physically move the %d selected image to %s?\n&quot;</a>
<a name="ln1527">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1528">                 &quot;do you really want to physically move %d selected images to %s?\n&quot;</a>
<a name="ln1529">                 &quot;(all unselected duplicates will be moved along)&quot;,</a>
<a name="ln1530">                 number),</a>
<a name="ln1531">        number, dir);</a>
<a name="ln1532">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1533">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1534">#endif</a>
<a name="ln1535">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;move image?&quot;, &quot;move images?&quot;, number));</a>
<a name="ln1536"> </a>
<a name="ln1537">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1538">    gtk_widget_destroy(dialog);</a>
<a name="ln1539"> </a>
<a name="ln1540">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1544">  return;</a>
<a name="ln1545"> </a>
<a name="ln1546">abort:</a>
<a name="ln1547">  g_free(dir);</a>
<a name="ln1548">  dt_control_job_dispose(job);</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">void dt_control_copy_images()</a>
<a name="ln1552">{</a>
<a name="ln1553">  // Open file chooser dialog</a>
<a name="ln1554">  gchar *dir = NULL;</a>
<a name="ln1555">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln1556">  int number = dt_collection_get_selected_count(darktable.collection);</a>
<a name="ln1557"> </a>
<a name="ln1558">  // Do not show the dialog if no image is selected:</a>
<a name="ln1559">  if(number == 0) return;</a>
<a name="ln1560">  dt_job_t *job = dt_control_generic_images_job_create(&amp;dt_control_copy_images_job_run, N_(&quot;copy images&quot;), 0, dir,</a>
<a name="ln1561">                                                       PROGRESS_CANCELLABLE);</a>
<a name="ln1562"> </a>
<a name="ln1563">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(</a>
<a name="ln1564">      _(&quot;select directory&quot;), GTK_WINDOW(win), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _(&quot;_cancel&quot;),</a>
<a name="ln1565">      GTK_RESPONSE_CANCEL, _(&quot;_select as destination&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln1566">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1567">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln1568">#endif</a>
<a name="ln1569"> </a>
<a name="ln1570">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln1571">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln1572">  {</a>
<a name="ln1573">    dir = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln1574">  }</a>
<a name="ln1575">  gtk_widget_destroy(filechooser);</a>
<a name="ln1576"> </a>
<a name="ln1577">  if(!dir || !g_file_test(dir, G_FILE_TEST_IS_DIR)) goto abort;</a>
<a name="ln1578"> </a>
<a name="ln1579">  // ugly, but we need to set this after constructing the job:</a>
<a name="ln1580">  ((dt_control_image_enumerator_t *)dt_control_job_get_params(job))-&gt;data = dir;</a>
<a name="ln1581"> </a>
<a name="ln1582">  if(dt_conf_get_bool(&quot;ask_before_copy&quot;))</a>
<a name="ln1583">  {</a>
<a name="ln1584">    GtkWidget *dialog = gtk_message_dialog_new(</a>
<a name="ln1585">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln1586">        ngettext(&quot;do you really want to physically copy the %d selected image to %s?&quot;,</a>
<a name="ln1587">                 &quot;do you really want to physically copy %d selected images to %s?&quot;, number),</a>
<a name="ln1588">        number, dir);</a>
<a name="ln1589">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln1590">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln1591">#endif</a>
<a name="ln1592">    gtk_window_set_title(GTK_WINDOW(dialog), ngettext(&quot;copy image?&quot;, &quot;copy images?&quot;, number));</a>
<a name="ln1593"> </a>
<a name="ln1594">    gint res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln1595">    gtk_widget_destroy(dialog);</a>
<a name="ln1596"> </a>
<a name="ln1597">    if(res != GTK_RESPONSE_YES) goto abort;</a>
<a name="ln1598">  }</a>
<a name="ln1599"> </a>
<a name="ln1600">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG, job);</a>
<a name="ln1601">  return;</a>
<a name="ln1602"> </a>
<a name="ln1603">abort:</a>
<a name="ln1604">  g_free(dir);</a>
<a name="ln1605">  dt_control_job_dispose(job);</a>
<a name="ln1606">}</a>
<a name="ln1607"> </a>
<a name="ln1608">void dt_control_set_local_copy_images()</a>
<a name="ln1609">{</a>
<a name="ln1610">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1611">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1612">                                                          N_(&quot;local copy images&quot;), 1, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1613">}</a>
<a name="ln1614"> </a>
<a name="ln1615">void dt_control_reset_local_copy_images()</a>
<a name="ln1616">{</a>
<a name="ln1617">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1618">                     dt_control_generic_images_job_create(&amp;dt_control_local_copy_images_job_run,</a>
<a name="ln1619">                                                          N_(&quot;local copy images&quot;), 0, NULL, PROGRESS_CANCELLABLE));</a>
<a name="ln1620">}</a>
<a name="ln1621"> </a>
<a name="ln1622">static dt_control_image_enumerator_t *dt_control_export_alloc()</a>
<a name="ln1623">{</a>
<a name="ln1624">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1625">  if(!params) return NULL;</a>
<a name="ln1626"> </a>
<a name="ln1627">  params-&gt;data = calloc(1, sizeof(dt_control_export_t));</a>
<a name="ln1628">  if(!params-&gt;data)</a>
<a name="ln1629">  {</a>
<a name="ln1630">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1631">    return NULL;</a>
<a name="ln1632">  }</a>
<a name="ln1633"> </a>
<a name="ln1634">  return params;</a>
<a name="ln1635">}</a>
<a name="ln1636"> </a>
<a name="ln1637">static void dt_control_export_cleanup(void *p)</a>
<a name="ln1638">{</a>
<a name="ln1639">  dt_control_image_enumerator_t *params = p;</a>
<a name="ln1640"> </a>
<a name="ln1641">  dt_control_export_t *settings = (dt_control_export_t *)params-&gt;data;</a>
<a name="ln1642">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(settings-&gt;storage_index);</a>
<a name="ln1643">  dt_imageio_module_data_t *sdata = settings-&gt;sdata;</a>
<a name="ln1644"> </a>
<a name="ln1645">  mstorage-&gt;free_params(mstorage, sdata);</a>
<a name="ln1646"> </a>
<a name="ln1647">  g_free(settings-&gt;icc_filename);</a>
<a name="ln1648">  free(params-&gt;data);</a>
<a name="ln1649"> </a>
<a name="ln1650">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1651">}</a>
<a name="ln1652"> </a>
<a name="ln1653">void dt_control_export(GList *imgid_list, int max_width, int max_height, int format_index, int storage_index,</a>
<a name="ln1654">                       gboolean high_quality, gboolean upscale, char *style, gboolean style_append,</a>
<a name="ln1655">                       dt_colorspaces_color_profile_type_t icc_type, const gchar *icc_filename,</a>
<a name="ln1656">                       dt_iop_color_intent_t icc_intent)</a>
<a name="ln1657">{</a>
<a name="ln1658">  dt_job_t *job = dt_control_job_create(&amp;dt_control_export_job_run, &quot;export&quot;);</a>
<a name="ln1659">  if(!job) return;</a>
<a name="ln1660">  dt_control_image_enumerator_t *params = dt_control_export_alloc();</a>
<a name="ln1661">  if(!params)</a>
<a name="ln1662">  {</a>
<a name="ln1663">    dt_control_job_dispose(job);</a>
<a name="ln1664">    return;</a>
<a name="ln1665">  }</a>
<a name="ln1666">  dt_control_job_set_params(job, params, dt_control_export_cleanup);</a>
<a name="ln1667"> </a>
<a name="ln1668">  params-&gt;index = imgid_list;</a>
<a name="ln1669"> </a>
<a name="ln1670">  dt_control_export_t *data = params-&gt;data;</a>
<a name="ln1671">  data-&gt;max_width = max_width;</a>
<a name="ln1672">  data-&gt;max_height = max_height;</a>
<a name="ln1673">  data-&gt;format_index = format_index;</a>
<a name="ln1674">  data-&gt;storage_index = storage_index;</a>
<a name="ln1675">  dt_imageio_module_storage_t *mstorage = dt_imageio_get_storage_by_index(storage_index);</a>
<a name="ln1676">  g_assert(mstorage);</a>
<a name="ln1677">  // get shared storage param struct (global sequence counter, one picasa connection etc)</a>
<a name="ln1678">  dt_imageio_module_data_t *sdata = mstorage-&gt;get_params(mstorage);</a>
<a name="ln1679">  if(sdata == NULL)</a>
<a name="ln1680">  {</a>
<a name="ln1681">    dt_control_log(_(&quot;failed to get parameters from storage module `%s', aborting export..&quot;),</a>
<a name="ln1682">                   mstorage-&gt;name(mstorage));</a>
<a name="ln1683">    dt_control_job_dispose(job);</a>
<a name="ln1684">    return;</a>
<a name="ln1685">  }</a>
<a name="ln1686">  data-&gt;sdata = sdata;</a>
<a name="ln1687">  data-&gt;high_quality = high_quality;</a>
<a name="ln1688">  data-&gt;upscale = upscale;</a>
<a name="ln1689">  g_strlcpy(data-&gt;style, style, sizeof(data-&gt;style));</a>
<a name="ln1690">  data-&gt;style_append = style_append;</a>
<a name="ln1691">  data-&gt;icc_type = icc_type;</a>
<a name="ln1692">  data-&gt;icc_filename = g_strdup(icc_filename);</a>
<a name="ln1693">  data-&gt;icc_intent = icc_intent;</a>
<a name="ln1694"> </a>
<a name="ln1695">  dt_control_job_add_progress(job, _(&quot;export images&quot;), TRUE);</a>
<a name="ln1696">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_EXPORT, job);</a>
<a name="ln1697"> </a>
<a name="ln1698">  // tell the storage that we got its params for an export so it can reset itself to a safe state</a>
<a name="ln1699">  mstorage-&gt;export_dispatched(mstorage);</a>
<a name="ln1700">}</a>
<a name="ln1701"> </a>
<a name="ln1702">static int32_t dt_control_time_offset_job_run(dt_job_t *job)</a>
<a name="ln1703">{</a>
<a name="ln1704">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)dt_control_job_get_params(job);</a>
<a name="ln1705">  uint32_t cntr = 0;</a>
<a name="ln1706">  double fraction = 0.0;</a>
<a name="ln1707">  GList *t = params-&gt;index;</a>
<a name="ln1708">  const long int offset = ((dt_control_time_offset_t *)params-&gt;data)-&gt;offset;</a>
<a name="ln1709">  char message[512] = { 0 };</a>
<a name="ln1710"> </a>
<a name="ln1711">  /* do we have any selected images and is offset != 0 */</a>
<a name="ln1712">  if(!t || offset == 0)</a>
<a name="ln1713">  {</a>
<a name="ln1714">    return 1;</a>
<a name="ln1715">  }</a>
<a name="ln1716"> </a>
<a name="ln1717">  const guint total = g_list_length(t);</a>
<a name="ln1718"> </a>
<a name="ln1719">  snprintf(message, sizeof(message),</a>
<a name="ln1720">           ngettext(&quot;adding time offset to %d image&quot;, &quot;adding time offset to %d images&quot;, total), total);</a>
<a name="ln1721">  dt_control_job_set_progress_message(job, message);</a>
<a name="ln1722"> </a>
<a name="ln1723">  /* go thru each selected image and update datetime_taken */</a>
<a name="ln1724">  do</a>
<a name="ln1725">  {</a>
<a name="ln1726">    int imgid = GPOINTER_TO_INT(t-&gt;data);</a>
<a name="ln1727"> </a>
<a name="ln1728">    dt_image_add_time_offset(imgid, offset);</a>
<a name="ln1729">    cntr++;</a>
<a name="ln1730"> </a>
<a name="ln1731">    fraction = MAX(fraction, (1.0 * cntr) / total);</a>
<a name="ln1732">    dt_control_job_set_progress(job, fraction);</a>
<a name="ln1733">  } while((t = g_list_next(t)) != NULL);</a>
<a name="ln1734"> </a>
<a name="ln1735">  dt_control_log(ngettext(&quot;added time offset to %d image&quot;, &quot;added time offset to %d images&quot;, cntr), cntr);</a>
<a name="ln1736"> </a>
<a name="ln1737">  return 0;</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">static void *dt_control_time_offset_alloc()</a>
<a name="ln1741">{</a>
<a name="ln1742">  dt_control_image_enumerator_t *params = dt_control_image_enumerator_alloc();</a>
<a name="ln1743">  if(!params) return NULL;</a>
<a name="ln1744"> </a>
<a name="ln1745">  params-&gt;data = calloc(1, sizeof(dt_control_time_offset_t));</a>
<a name="ln1746">  if(!params-&gt;data)</a>
<a name="ln1747">  {</a>
<a name="ln1748">    dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1749">    return NULL;</a>
<a name="ln1750">  }</a>
<a name="ln1751"> </a>
<a name="ln1752">  return params;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755">static void dt_control_time_offset_job_cleanup(void *p)</a>
<a name="ln1756">{</a>
<a name="ln1757">  dt_control_image_enumerator_t *params = (dt_control_image_enumerator_t *)p;</a>
<a name="ln1758"> </a>
<a name="ln1759">  free(params-&gt;data);</a>
<a name="ln1760"> </a>
<a name="ln1761">  dt_control_image_enumerator_cleanup(params);</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">static dt_job_t *dt_control_time_offset_job_create(const long int offset, int imgid)</a>
<a name="ln1765">{</a>
<a name="ln1766">  dt_job_t *job = dt_control_job_create(&amp;dt_control_time_offset_job_run, &quot;time offset&quot;);</a>
<a name="ln1767">  if(!job) return NULL;</a>
<a name="ln1768">  dt_control_image_enumerator_t *params = dt_control_time_offset_alloc();</a>
<a name="ln1769">  if(!params)</a>
<a name="ln1770">  {</a>
<a name="ln1771">    dt_control_job_dispose(job);</a>
<a name="ln1772">    return NULL;</a>
<a name="ln1773">  }</a>
<a name="ln1774">  dt_control_job_add_progress(job, _(&quot;time offset&quot;), FALSE);</a>
<a name="ln1775">  dt_control_job_set_params(job, params, dt_control_time_offset_job_cleanup);</a>
<a name="ln1776"> </a>
<a name="ln1777">  if(imgid != -1)</a>
<a name="ln1778">    params-&gt;index = g_list_append(params-&gt;index, GINT_TO_POINTER(imgid));</a>
<a name="ln1779">  else</a>
<a name="ln1780">    dt_control_image_enumerator_job_selected_init(params);</a>
<a name="ln1781"> </a>
<a name="ln1782">  dt_control_time_offset_t *data = params-&gt;data;</a>
<a name="ln1783">  data-&gt;offset = offset;</a>
<a name="ln1784">  params-&gt;data = data;</a>
<a name="ln1785">  return job;</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">void dt_control_time_offset(const long int offset, int imgid)</a>
<a name="ln1789">{</a>
<a name="ln1790">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1791">                     dt_control_time_offset_job_create(offset, imgid));</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794">void dt_control_write_sidecar_files()</a>
<a name="ln1795">{</a>
<a name="ln1796">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln1797">                     dt_control_generic_images_job_create(&amp;dt_control_write_sidecar_files_job_run,</a>
<a name="ln1798">                                                          N_(&quot;write sidecar files&quot;), 0, NULL, PROGRESS_NONE));</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1802">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1803">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="572"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'buffer'. Check lines: 572, 568.</p></div>
<div class="balloon" rel="1041"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'g_list_free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="1263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!t' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
