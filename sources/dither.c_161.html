
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012--2013 Ulrich Pegelow</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#ifdef HAVE_CONFIG_H</a>
<a name="ln19">#include &quot;config.h&quot;</a>
<a name="ln20">#endif</a>
<a name="ln21">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln22">#include &quot;common/imageio.h&quot;</a>
<a name="ln23">#include &quot;common/opencl.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;develop/imageop.h&quot;</a>
<a name="ln27">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln28">#include &quot;develop/tiling.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/gradientslider.h&quot;</a>
<a name="ln30">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln31">#include &quot;gui/gtk.h&quot;</a>
<a name="ln32">#include &quot;gui/presets.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34">#include &lt;assert.h&gt;</a>
<a name="ln35">#include &lt;math.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln40">#include &lt;inttypes.h&gt;</a>
<a name="ln41">#if defined(__SSE__)</a>
<a name="ln42">#include &lt;xmmintrin.h&gt;</a>
<a name="ln43">#endif</a>
<a name="ln44"> </a>
<a name="ln45">#define CLIP(x) ((x &lt; 0) ? 0.0 : (x &gt; 1.0) ? 1.0 : x)</a>
<a name="ln46">#define TEA_ROUNDS 8</a>
<a name="ln47"> </a>
<a name="ln48">DT_MODULE_INTROSPECTION(1, dt_iop_dither_params_t)</a>
<a name="ln49"> </a>
<a name="ln50">typedef void(_find_nearest_color)(float *val, float *err, const float f, const float rf);</a>
<a name="ln51"> </a>
<a name="ln52">#if defined(__SSE__)</a>
<a name="ln53">typedef __m128(_find_nearest_color_sse)(float *val, const float f, const float rf);</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">typedef enum dt_iop_dither_type_t</a>
<a name="ln57">{</a>
<a name="ln58">  DITHER_RANDOM,</a>
<a name="ln59">  DITHER_FS1BIT,</a>
<a name="ln60">  DITHER_FS4BIT_GRAY,</a>
<a name="ln61">  DITHER_FS8BIT,</a>
<a name="ln62">  DITHER_FS16BIT,</a>
<a name="ln63">  DITHER_FSAUTO</a>
<a name="ln64">} dt_iop_dither_type_t;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">typedef struct dt_iop_dither_params_t</a>
<a name="ln68">{</a>
<a name="ln69">  dt_iop_dither_type_t dither_type;</a>
<a name="ln70">  int palette; // reserved for future extensions</a>
<a name="ln71">  struct</a>
<a name="ln72">  {</a>
<a name="ln73">    float radius;   // reserved for future extensions</a>
<a name="ln74">    float range[4]; // reserved for future extensions</a>
<a name="ln75">    float damping;</a>
<a name="ln76">  } random;</a>
<a name="ln77">} dt_iop_dither_params_t;</a>
<a name="ln78"> </a>
<a name="ln79">typedef struct dt_iop_dither_gui_data_t</a>
<a name="ln80">{</a>
<a name="ln81">  GtkWidget *dither_type;</a>
<a name="ln82">  GtkWidget *random;</a>
<a name="ln83">  GtkWidget *radius;</a>
<a name="ln84">  GtkWidget *range;</a>
<a name="ln85">  GtkWidget *range_label;</a>
<a name="ln86">  GtkWidget *damping;</a>
<a name="ln87">} dt_iop_dither_gui_data_t;</a>
<a name="ln88"> </a>
<a name="ln89">typedef struct dt_iop_dither_data_t</a>
<a name="ln90">{</a>
<a name="ln91">  dt_iop_dither_type_t dither_type;</a>
<a name="ln92">  struct</a>
<a name="ln93">  {</a>
<a name="ln94">    float radius;</a>
<a name="ln95">    float range[4];</a>
<a name="ln96">    float damping;</a>
<a name="ln97">  } random;</a>
<a name="ln98">} dt_iop_dither_data_t;</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">const char *name()</a>
<a name="ln102">{</a>
<a name="ln103">  return _(&quot;dithering&quot;);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">int default_group()</a>
<a name="ln107">{</a>
<a name="ln108">  return IOP_GROUP_CORRECT;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">int flags()</a>
<a name="ln112">{</a>
<a name="ln113">  return IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln117">{</a>
<a name="ln118">  return iop_cs_rgb;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">void init_presets(dt_iop_module_so_t *self)</a>
<a name="ln123">{</a>
<a name="ln124">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;BEGIN&quot;, NULL, NULL, NULL);</a>
<a name="ln125"> </a>
<a name="ln126">  dt_iop_dither_params_t tmp</a>
<a name="ln127">      = (dt_iop_dither_params_t){ DITHER_FSAUTO, 0, { 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }, -200.0f } };</a>
<a name="ln128">  // add the preset.</a>
<a name="ln129">  dt_gui_presets_add_generic(_(&quot;dither&quot;), self-&gt;op, self-&gt;version(), &amp;tmp, sizeof(dt_iop_dither_params_t), 1);</a>
<a name="ln130">  // make it auto-apply for all images:</a>
<a name="ln131">  // dt_gui_presets_update_autoapply(_(&quot;dither&quot;), self-&gt;op, self-&gt;version(), 1);</a>
<a name="ln132"> </a>
<a name="ln133">  DT_DEBUG_SQLITE3_EXEC(dt_database_get(darktable.db), &quot;COMMIT&quot;, NULL, NULL, NULL);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">// dither pixel into gray, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln138">static void _find_nearest_color_n_levels_gray(float *val, float *err, const float f, const float rf)</a>
<a name="ln139">{</a>
<a name="ln140">  const float in = 0.30f * val[0] + 0.59f * val[1] + 0.11f * val[2]; // RGB -&gt; GRAY</a>
<a name="ln141"> </a>
<a name="ln142">  float tmp = in * f;</a>
<a name="ln143">  int itmp = floorf(tmp);</a>
<a name="ln144"> </a>
<a name="ln145">  float new = (tmp - itmp &gt; 0.5f ? (float)(itmp + 1) : (float)itmp) * rf;</a>
<a name="ln146"> </a>
<a name="ln147">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln148">  {</a>
<a name="ln149">    err[c] = val[c] - new;</a>
<a name="ln150">    val[c] = new;</a>
<a name="ln151">  }</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">#if defined(__SSE2__)</a>
<a name="ln155">// dither pixel into gray, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln156">static __m128 _find_nearest_color_n_levels_gray_sse(float *val, const float f, const float rf)</a>
<a name="ln157">{</a>
<a name="ln158">  __m128 err;</a>
<a name="ln159">  __m128 new;</a>
<a name="ln160"> </a>
<a name="ln161">  const float in = 0.30f * val[0] + 0.59f * val[1] + 0.11f * val[2]; // RGB -&gt; GRAY</a>
<a name="ln162"> </a>
<a name="ln163">  float tmp = in * f;</a>
<a name="ln164">  int itmp = floorf(tmp);</a>
<a name="ln165"> </a>
<a name="ln166">  new = _mm_set1_ps(tmp - itmp &gt; 0.5f ? (float)(itmp + 1) * rf : (float)itmp * rf);</a>
<a name="ln167">  err = _mm_sub_ps(_mm_load_ps(val), new);</a>
<a name="ln168">  _mm_store_ps(val, new);</a>
<a name="ln169"> </a>
<a name="ln170">  return err;</a>
<a name="ln171">}</a>
<a name="ln172">#endif</a>
<a name="ln173"> </a>
<a name="ln174">// dither pixel into RGB, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln175">static void _find_nearest_color_n_levels_rgb(float *val, float *err, const float f, const float rf)</a>
<a name="ln176">{</a>
<a name="ln177">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln178">  {</a>
<a name="ln179">    float old = val[c];</a>
<a name="ln180">    float tmp = old * f;</a>
<a name="ln181">    float itmp = floorf(tmp);</a>
<a name="ln182">    float new = (tmp - itmp &gt; 0.5f ? itmp + 1 : itmp) * rf;</a>
<a name="ln183"> </a>
<a name="ln184">    val[c] = new;</a>
<a name="ln185">    err[c] = old - new;</a>
<a name="ln186">  }</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">#if defined(__SSE2__)</a>
<a name="ln190">// dither pixel into RGB, with f=levels-1 and rf=1/f, return err=old-new</a>
<a name="ln191">static __m128 _find_nearest_color_n_levels_rgb_sse2(float *val, const float f, const float rf)</a>
<a name="ln192">{</a>
<a name="ln193">  __m128 old = _mm_load_ps(val);</a>
<a name="ln194">  __m128 tmp = _mm_mul_ps(old, _mm_set1_ps(f));        // old * f</a>
<a name="ln195">  __m128 itmp = _mm_cvtepi32_ps(_mm_cvtps_epi32(tmp)); // floor(tmp)</a>
<a name="ln196">  __m128 new = _mm_mul_ps(</a>
<a name="ln197">      _mm_add_ps(itmp,</a>
<a name="ln198">                 _mm_and_ps(_mm_cmpgt_ps(_mm_sub_ps(tmp, itmp), // (tmp - itmp &gt; 0.5f ? itmp + 1 : itmp) * rf</a>
<a name="ln199">                                         _mm_set1_ps(0.5f)),</a>
<a name="ln200">                            _mm_set1_ps(1.0f))),</a>
<a name="ln201">      _mm_set1_ps(rf));</a>
<a name="ln202"> </a>
<a name="ln203">  _mm_store_ps(val, new);</a>
<a name="ln204"> </a>
<a name="ln205">  return _mm_sub_ps(old, new);</a>
<a name="ln206">}</a>
<a name="ln207">#endif</a>
<a name="ln208"> </a>
<a name="ln209">static inline void _diffuse_error(float *val, const float *err, const float factor)</a>
<a name="ln210">{</a>
<a name="ln211">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln212">  {</a>
<a name="ln213">    val[c] += err[c] * factor;</a>
<a name="ln214">  }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">#if defined(__SSE__)</a>
<a name="ln218">static inline void _diffuse_error_sse(float *val, const __m128 err, const float factor)</a>
<a name="ln219">{</a>
<a name="ln220">  _mm_store_ps(val,</a>
<a name="ln221">               _mm_add_ps(_mm_load_ps(val), _mm_mul_ps(err, _mm_set1_ps(factor)))); // *val += err * factor</a>
<a name="ln222">}</a>
<a name="ln223">#endif</a>
<a name="ln224"> </a>
<a name="ln225">static inline float clipnan(const float x)</a>
<a name="ln226">{</a>
<a name="ln227">  float r;</a>
<a name="ln228"> </a>
<a name="ln229">  if(isnan(x))</a>
<a name="ln230">    r = 0.5f;</a>
<a name="ln231">  else // normal number</a>
<a name="ln232">    r = (isless(x, 0.0f) ? 0.0f : (isgreater(x, 1.0f) ? 1.0f : x));</a>
<a name="ln233"> </a>
<a name="ln234">  return r;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">static void process_floyd_steinberg(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln238">                                    const void *const ivoid, void *const ovoid,</a>
<a name="ln239">                                    const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln240">{</a>
<a name="ln241">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln242"> </a>
<a name="ln243">  const int width = roi_in-&gt;width;</a>
<a name="ln244">  const int height = roi_in-&gt;height;</a>
<a name="ln245">  const int ch = piece-&gt;colors;</a>
<a name="ln246">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln247">  const int l1 = floorf(1.0f + dt_log2f(1.0f / scale));</a>
<a name="ln248"> </a>
<a name="ln249">  _find_nearest_color *nearest_color = NULL;</a>
<a name="ln250">  unsigned int levels = 1;</a>
<a name="ln251">  int bds = (piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT) ? l1 * l1 : 1;</a>
<a name="ln252"> </a>
<a name="ln253">  switch(data-&gt;dither_type)</a>
<a name="ln254">  {</a>
<a name="ln255">    case DITHER_FS1BIT:</a>
<a name="ln256">      nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln257">      levels = MAX(2, MIN(bds + 1, 256));</a>
<a name="ln258">      break;</a>
<a name="ln259">    case DITHER_FS4BIT_GRAY:</a>
<a name="ln260">      nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln261">      levels = MAX(16, MIN(15 * bds + 1, 256));</a>
<a name="ln262">      break;</a>
<a name="ln263">    case DITHER_FS8BIT:</a>
<a name="ln264">      nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln265">      levels = 256;</a>
<a name="ln266">      break;</a>
<a name="ln267">    case DITHER_FS16BIT:</a>
<a name="ln268">      nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln269">      levels = 65536;</a>
<a name="ln270">      break;</a>
<a name="ln271">    case DITHER_FSAUTO:</a>
<a name="ln272">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_CHANNEL_MASK)</a>
<a name="ln273">      {</a>
<a name="ln274">        case IMAGEIO_RGB:</a>
<a name="ln275">          nearest_color = _find_nearest_color_n_levels_rgb;</a>
<a name="ln276">          break;</a>
<a name="ln277">        case IMAGEIO_GRAY:</a>
<a name="ln278">          nearest_color = _find_nearest_color_n_levels_gray;</a>
<a name="ln279">          break;</a>
<a name="ln280">      }</a>
<a name="ln281"> </a>
<a name="ln282">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_PREC_MASK)</a>
<a name="ln283">      {</a>
<a name="ln284">        case IMAGEIO_INT8:</a>
<a name="ln285">          levels = 256;</a>
<a name="ln286">          break;</a>
<a name="ln287">        case IMAGEIO_INT12:</a>
<a name="ln288">          levels = 4096;</a>
<a name="ln289">          break;</a>
<a name="ln290">        case IMAGEIO_INT16:</a>
<a name="ln291">          levels = 65536;</a>
<a name="ln292">          break;</a>
<a name="ln293">        case IMAGEIO_BW:</a>
<a name="ln294">          levels = 2;</a>
<a name="ln295">          break;</a>
<a name="ln296">        case IMAGEIO_INT32:</a>
<a name="ln297">        case IMAGEIO_FLOAT:</a>
<a name="ln298">        default:</a>
<a name="ln299">          nearest_color = NULL;</a>
<a name="ln300">          break;</a>
<a name="ln301">      }</a>
<a name="ln302">      // no automatic dithering for preview and thumbnail</a>
<a name="ln303">      if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln304">        nearest_color = NULL;</a>
<a name="ln305">      break;</a>
<a name="ln306">    case DITHER_RANDOM:</a>
<a name="ln307">      // this function won't ever be called for that type</a>
<a name="ln308">      // instead, process_random() will be called</a>
<a name="ln309">      __builtin_unreachable();</a>
<a name="ln310">      break;</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">#ifdef _OPENMP</a>
<a name="ln314">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln315">#endif</a>
<a name="ln316">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln317">  {</a>
<a name="ln318">    const float *in = (const float *)ivoid + (size_t)ch * width * j;</a>
<a name="ln319">    float *out = (float *)ovoid + (size_t)ch * width * j;</a>
<a name="ln320">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln321">    {</a>
<a name="ln322">      out[0] = clipnan(in[0]);</a>
<a name="ln323">      out[1] = clipnan(in[1]);</a>
<a name="ln324">      out[2] = clipnan(in[2]);</a>
<a name="ln325">    }</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  if(nearest_color == NULL) return;</a>
<a name="ln329"> </a>
<a name="ln330">  const float f = levels - 1;</a>
<a name="ln331">  const float rf = 1.0 / f;</a>
<a name="ln332">  float err[4];</a>
<a name="ln333"> </a>
<a name="ln334">  // dither without error diffusion on very tiny images</a>
<a name="ln335">  if(width &lt; 3 || height &lt; 3)</a>
<a name="ln336">  {</a>
<a name="ln337">    for(int j = 0; j &lt; height; j++)</a>
<a name="ln338">    {</a>
<a name="ln339">      float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln340">      for(int i = 0; i &lt; width; i++) nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln341">    }</a>
<a name="ln342"> </a>
<a name="ln343">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln344">    return;</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  // floyd-steinberg dithering follows here</a>
<a name="ln348"> </a>
<a name="ln349">  // first height-1 rows</a>
<a name="ln350">  for(int j = 0; j &lt; height - 1; j++)</a>
<a name="ln351">  {</a>
<a name="ln352">    float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln353"> </a>
<a name="ln354">    // first column</a>
<a name="ln355">    nearest_color(out, err, f, rf);</a>
<a name="ln356">    _diffuse_error(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln357">    _diffuse_error(out + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln358">    _diffuse_error(out + ch * (width + 1), err, 1.0f / 16.0f);</a>
<a name="ln359"> </a>
<a name="ln360"> </a>
<a name="ln361">    // main part of image</a>
<a name="ln362">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln363">    {</a>
<a name="ln364">      nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln365">      _diffuse_error(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln366">      _diffuse_error(out + ch * (i - 1) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln367">      _diffuse_error(out + ch * i + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln368">      _diffuse_error(out + ch * (i + 1) + ch * width, err, 1.0f / 16.0f);</a>
<a name="ln369">    }</a>
<a name="ln370"> </a>
<a name="ln371">    // last column</a>
<a name="ln372">    nearest_color(out + ch * (width - 1), err, f, rf);</a>
<a name="ln373">    _diffuse_error(out + ch * (width - 2) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln374">    _diffuse_error(out + ch * (width - 1) + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  // last row</a>
<a name="ln378">  {</a>
<a name="ln379">    float *out = ((float *)ovoid) + (size_t)ch * (height - 1) * width;</a>
<a name="ln380"> </a>
<a name="ln381">    // lower left pixel</a>
<a name="ln382">    nearest_color(out, err, f, rf);</a>
<a name="ln383">    _diffuse_error(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln384"> </a>
<a name="ln385">    // main part of last row</a>
<a name="ln386">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln387">    {</a>
<a name="ln388">      nearest_color(out + ch * i, err, f, rf);</a>
<a name="ln389">      _diffuse_error(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">    // lower right pixel</a>
<a name="ln393">    nearest_color(out + ch * (width - 1), err, f, rf);</a>
<a name="ln394"> </a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  // copy alpha channel if needed</a>
<a name="ln398">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">#if defined(__SSE2__)</a>
<a name="ln402">static void process_floyd_steinberg_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln403">                                         const void *const ivoid, void *const ovoid,</a>
<a name="ln404">                                         const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln405">{</a>
<a name="ln406">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln407"> </a>
<a name="ln408">  const int width = roi_in-&gt;width;</a>
<a name="ln409">  const int height = roi_in-&gt;height;</a>
<a name="ln410">  const int ch = piece-&gt;colors;</a>
<a name="ln411">  const float scale = roi_in-&gt;scale / piece-&gt;iscale;</a>
<a name="ln412">  const int l1 = floorf(1.0f + dt_log2f(1.0f / scale));</a>
<a name="ln413"> </a>
<a name="ln414">  _find_nearest_color_sse *nearest_color = NULL;</a>
<a name="ln415">  unsigned int levels = 1;</a>
<a name="ln416">  int bds = (piece-&gt;pipe-&gt;type != DT_DEV_PIXELPIPE_EXPORT) ? l1 * l1 : 1;</a>
<a name="ln417"> </a>
<a name="ln418">  switch(data-&gt;dither_type)</a>
<a name="ln419">  {</a>
<a name="ln420">    case DITHER_FS1BIT:</a>
<a name="ln421">      nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln422">      levels = MAX(2, MIN(bds + 1, 256));</a>
<a name="ln423">      break;</a>
<a name="ln424">    case DITHER_FS4BIT_GRAY:</a>
<a name="ln425">      nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln426">      levels = MAX(16, MIN(15 * bds + 1, 256));</a>
<a name="ln427">      break;</a>
<a name="ln428">    case DITHER_FS8BIT:</a>
<a name="ln429">      nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln430">      levels = 256;</a>
<a name="ln431">      break;</a>
<a name="ln432">    case DITHER_FS16BIT:</a>
<a name="ln433">      nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln434">      levels = 65536;</a>
<a name="ln435">      break;</a>
<a name="ln436">    case DITHER_FSAUTO:</a>
<a name="ln437">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_CHANNEL_MASK)</a>
<a name="ln438">      {</a>
<a name="ln439">        case IMAGEIO_RGB:</a>
<a name="ln440">          nearest_color = _find_nearest_color_n_levels_rgb_sse2;</a>
<a name="ln441">          break;</a>
<a name="ln442">        case IMAGEIO_GRAY:</a>
<a name="ln443">          nearest_color = _find_nearest_color_n_levels_gray_sse;</a>
<a name="ln444">          break;</a>
<a name="ln445">      }</a>
<a name="ln446"> </a>
<a name="ln447">      switch(piece-&gt;pipe-&gt;levels &amp; IMAGEIO_PREC_MASK)</a>
<a name="ln448">      {</a>
<a name="ln449">        case IMAGEIO_INT8:</a>
<a name="ln450">          levels = 256;</a>
<a name="ln451">          break;</a>
<a name="ln452">        case IMAGEIO_INT12:</a>
<a name="ln453">          levels = 4096;</a>
<a name="ln454">          break;</a>
<a name="ln455">        case IMAGEIO_INT16:</a>
<a name="ln456">          levels = 65536;</a>
<a name="ln457">          break;</a>
<a name="ln458">        case IMAGEIO_BW:</a>
<a name="ln459">          levels = 2;</a>
<a name="ln460">          break;</a>
<a name="ln461">        case IMAGEIO_INT32:</a>
<a name="ln462">        case IMAGEIO_FLOAT:</a>
<a name="ln463">        default:</a>
<a name="ln464">          nearest_color = NULL;</a>
<a name="ln465">          break;</a>
<a name="ln466">      }</a>
<a name="ln467">      // no automatic dithering for preview and thumbnail</a>
<a name="ln468">      if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW || piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_THUMBNAIL)</a>
<a name="ln469">        nearest_color = NULL;</a>
<a name="ln470">      break;</a>
<a name="ln471">    case DITHER_RANDOM:</a>
<a name="ln472">      // this function won't ever be called for that type</a>
<a name="ln473">      // instead, process_random() will be called</a>
<a name="ln474">      __builtin_unreachable();</a>
<a name="ln475">      break;</a>
<a name="ln476">  }</a>
<a name="ln477"> </a>
<a name="ln478">#ifdef _OPENMP</a>
<a name="ln479">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln480">#endif</a>
<a name="ln481">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln482">  {</a>
<a name="ln483">    const float *in = (const float *)ivoid + (size_t)ch * width * j;</a>
<a name="ln484">    float *out = (float *)ovoid + (size_t)ch * width * j;</a>
<a name="ln485">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln486">    {</a>
<a name="ln487">      out[0] = clipnan(in[0]);</a>
<a name="ln488">      out[1] = clipnan(in[1]);</a>
<a name="ln489">      out[2] = clipnan(in[2]);</a>
<a name="ln490">    }</a>
<a name="ln491">  }</a>
<a name="ln492"> </a>
<a name="ln493">  if(nearest_color == NULL) return;</a>
<a name="ln494"> </a>
<a name="ln495">  const float f = levels - 1;</a>
<a name="ln496">  const float rf = 1.0 / f;</a>
<a name="ln497">  __m128 err;</a>
<a name="ln498"> </a>
<a name="ln499">  // dither without error diffusion on very tiny images</a>
<a name="ln500">  if(width &lt; 3 || height &lt; 3)</a>
<a name="ln501">  {</a>
<a name="ln502">    for(int j = 0; j &lt; height; j++)</a>
<a name="ln503">    {</a>
<a name="ln504">      float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln505">      for(int i = 0; i &lt; width; i++) (void)nearest_color(out + ch * i, f, rf);</a>
<a name="ln506">    }</a>
<a name="ln507"> </a>
<a name="ln508">    if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln509">    return;</a>
<a name="ln510">  }</a>
<a name="ln511"> </a>
<a name="ln512">  // floyd-steinberg dithering follows here</a>
<a name="ln513"> </a>
<a name="ln514">  // first height-1 rows</a>
<a name="ln515">  for(int j = 0; j &lt; height - 1; j++)</a>
<a name="ln516">  {</a>
<a name="ln517">    float *out = ((float *)ovoid) + (size_t)ch * j * width;</a>
<a name="ln518"> </a>
<a name="ln519">    // first column</a>
<a name="ln520">    err = nearest_color(out, f, rf);</a>
<a name="ln521">    _diffuse_error_sse(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln522">    _diffuse_error_sse(out + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln523">    _diffuse_error_sse(out + ch * (width + 1), err, 1.0f / 16.0f);</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">    // main part of image</a>
<a name="ln527">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln528">    {</a>
<a name="ln529">      err = nearest_color(out + ch * i, f, rf);</a>
<a name="ln530">      _diffuse_error_sse(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln531">      _diffuse_error_sse(out + ch * (i - 1) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln532">      _diffuse_error_sse(out + ch * i + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln533">      _diffuse_error_sse(out + ch * (i + 1) + ch * width, err, 1.0f / 16.0f);</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    // last column</a>
<a name="ln537">    err = nearest_color(out + ch * (width - 1), f, rf);</a>
<a name="ln538">    _diffuse_error_sse(out + ch * (width - 2) + ch * width, err, 3.0f / 16.0f);</a>
<a name="ln539">    _diffuse_error_sse(out + ch * (width - 1) + ch * width, err, 5.0f / 16.0f);</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  // last row</a>
<a name="ln543">  {</a>
<a name="ln544">    float *out = ((float *)ovoid) + (size_t)ch * (height - 1) * width;</a>
<a name="ln545"> </a>
<a name="ln546">    // lower left pixel</a>
<a name="ln547">    err = nearest_color(out, f, rf);</a>
<a name="ln548">    _diffuse_error_sse(out + ch, err, 7.0f / 16.0f);</a>
<a name="ln549"> </a>
<a name="ln550">    // main part of last row</a>
<a name="ln551">    for(int i = 1; i &lt; width - 1; i++)</a>
<a name="ln552">    {</a>
<a name="ln553">      err = nearest_color(out + ch * i, f, rf);</a>
<a name="ln554">      _diffuse_error_sse(out + ch * (i + 1), err, 7.0f / 16.0f);</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">    // lower right pixel</a>
<a name="ln558">    (void)nearest_color(out + ch * (width - 1), f, rf);</a>
<a name="ln559"> </a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  // copy alpha channel if needed</a>
<a name="ln563">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, roi_out-&gt;width, roi_out-&gt;height);</a>
<a name="ln564">}</a>
<a name="ln565">#endif</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">static void encrypt_tea(unsigned int *arg)</a>
<a name="ln569">{</a>
<a name="ln570">  const unsigned int key[] = { 0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e };</a>
<a name="ln571">  unsigned int v0 = arg[0], v1 = arg[1];</a>
<a name="ln572">  unsigned int sum = 0;</a>
<a name="ln573">  unsigned int delta = 0x9e3779b9;</a>
<a name="ln574">  for(int i = 0; i &lt; TEA_ROUNDS; i++)</a>
<a name="ln575">  {</a>
<a name="ln576">    sum += delta;</a>
<a name="ln577">    v0 += ((v1 &lt;&lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + key[1]);</a>
<a name="ln578">    v1 += ((v0 &lt;&lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + key[3]);</a>
<a name="ln579">  }</a>
<a name="ln580">  arg[0] = v0;</a>
<a name="ln581">  arg[1] = v1;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">static float tpdf(unsigned int urandom)</a>
<a name="ln586">{</a>
<a name="ln587">  float frandom = (float)urandom / 0xFFFFFFFFu;</a>
<a name="ln588"> </a>
<a name="ln589">  return (frandom &lt; 0.5f ? (sqrtf(2.0f * frandom) - 1.0f) : (1.0f - sqrtf(2.0f * (1.0f - frandom))));</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592"> </a>
<a name="ln593">static void process_random(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln594">                           const void *const ivoid, void *const ovoid, const dt_iop_roi_t *const roi_in,</a>
<a name="ln595">                           const dt_iop_roi_t *const roi_out)</a>
<a name="ln596">{</a>
<a name="ln597">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln598"> </a>
<a name="ln599">  const int width = roi_in-&gt;width;</a>
<a name="ln600">  const int height = roi_in-&gt;height;</a>
<a name="ln601">  const int ch = piece-&gt;colors;</a>
<a name="ln602"> </a>
<a name="ln603">  const float dither = powf(2.0f, data-&gt;random.damping / 10.0f);</a>
<a name="ln604"> </a>
<a name="ln605">  unsigned int *const tea_states = calloc(2 * dt_get_num_threads(), sizeof(unsigned int));</a>
<a name="ln606"> </a>
<a name="ln607">#ifdef _OPENMP</a>
<a name="ln608">#pragma omp parallel for default(none) schedule(static)</a>
<a name="ln609">#endif</a>
<a name="ln610">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln611">  {</a>
<a name="ln612">    const size_t k = (size_t)ch * width * j;</a>
<a name="ln613">    const float *in = (const float *)ivoid + k;</a>
<a name="ln614">    float *out = (float *)ovoid + k;</a>
<a name="ln615">    unsigned int *tea_state = tea_states + 2 * dt_get_thread_num();</a>
<a name="ln616">    tea_state[0] = j * height + dt_get_thread_num();</a>
<a name="ln617">    for(int i = 0; i &lt; width; i++, in += ch, out += ch)</a>
<a name="ln618">    {</a>
<a name="ln619">      encrypt_tea(tea_state);</a>
<a name="ln620">      float dith = dither * tpdf(tea_state[0]);</a>
<a name="ln621"> </a>
<a name="ln622">      out[0] = CLIP(in[0] + dith);</a>
<a name="ln623">      out[1] = CLIP(in[1] + dith);</a>
<a name="ln624">      out[2] = CLIP(in[2] + dith);</a>
<a name="ln625">    }</a>
<a name="ln626">  }</a>
<a name="ln627"> </a>
<a name="ln628">  free(tea_states);</a>
<a name="ln629"> </a>
<a name="ln630">  if(piece-&gt;pipe-&gt;mask_display &amp; DT_DEV_PIXELPIPE_DISPLAY_MASK) dt_iop_alpha_copy(ivoid, ovoid, width, height);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln635">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln636">{</a>
<a name="ln637">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln638"> </a>
<a name="ln639">  if(data-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln640">    process_random(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln641">  else</a>
<a name="ln642">    process_floyd_steinberg(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645">#if defined(__SSE2__)</a>
<a name="ln646">void process_sse2(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln647">                  void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln648">{</a>
<a name="ln649">  dt_iop_dither_data_t *data = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln650"> </a>
<a name="ln651">  if(data-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln652">    process_random(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln653">  else</a>
<a name="ln654">    process_floyd_steinberg_sse2(self, piece, ivoid, ovoid, roi_in, roi_out);</a>
<a name="ln655">}</a>
<a name="ln656">#endif</a>
<a name="ln657"> </a>
<a name="ln658">static void method_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln659">{</a>
<a name="ln660">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln661">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln662">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln663">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln664">  p-&gt;dither_type = dt_bauhaus_combobox_get(widget);</a>
<a name="ln665"> </a>
<a name="ln666">  if(p-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln667">    gtk_widget_show(GTK_WIDGET(g-&gt;random));</a>
<a name="ln668">  else</a>
<a name="ln669">    gtk_widget_hide(GTK_WIDGET(g-&gt;random));</a>
<a name="ln670"> </a>
<a name="ln671">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">#if 0</a>
<a name="ln675">static void</a>
<a name="ln676">radius_callback (GtkWidget *slider, gpointer user_data)</a>
<a name="ln677">{</a>
<a name="ln678">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln679">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln680">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln681">  p-&gt;random.radius = dt_bauhaus_slider_get(slider);</a>
<a name="ln682">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln683">}</a>
<a name="ln684">#endif</a>
<a name="ln685"> </a>
<a name="ln686">static void damping_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln687">{</a>
<a name="ln688">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln689">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln690">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln691">  p-&gt;random.damping = dt_bauhaus_slider_get(slider);</a>
<a name="ln692">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">#if 0</a>
<a name="ln696">static void</a>
<a name="ln697">range_callback (GtkWidget *slider, gpointer user_data)</a>
<a name="ln698">{</a>
<a name="ln699">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln700">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln701">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln702">  p-&gt;random.range[0] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 0);</a>
<a name="ln703">  p-&gt;random.range[1] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 1);</a>
<a name="ln704">  p-&gt;random.range[2] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 2);</a>
<a name="ln705">  p-&gt;random.range[3] = dtgtk_gradient_slider_multivalue_get_value(DTGTK_GRADIENT_SLIDER(slider), 3);</a>
<a name="ln706">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln707">}</a>
<a name="ln708">#endif</a>
<a name="ln709"> </a>
<a name="ln710">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln711">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln712">{</a>
<a name="ln713">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)p1;</a>
<a name="ln714">  dt_iop_dither_data_t *d = (dt_iop_dither_data_t *)piece-&gt;data;</a>
<a name="ln715"> </a>
<a name="ln716">  d-&gt;dither_type = p-&gt;dither_type;</a>
<a name="ln717">  memcpy(&amp;(d-&gt;random.range), &amp;(p-&gt;random.range), sizeof(p-&gt;random.range));</a>
<a name="ln718">  d-&gt;random.radius = p-&gt;random.radius;</a>
<a name="ln719">  d-&gt;random.damping = p-&gt;random.damping;</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln723">{</a>
<a name="ln724">  piece-&gt;data = malloc(sizeof(dt_iop_dither_data_t));</a>
<a name="ln725">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln729">{</a>
<a name="ln730">  free(piece-&gt;data);</a>
<a name="ln731">  piece-&gt;data = NULL;</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734"> </a>
<a name="ln735">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln736">{</a>
<a name="ln737">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln738">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln739">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)module-&gt;params;</a>
<a name="ln740">  dt_bauhaus_combobox_set(g-&gt;dither_type, p-&gt;dither_type);</a>
<a name="ln741">#if 0</a>
<a name="ln742">  dt_bauhaus_slider_set(g-&gt;radius, p-&gt;random.radius);</a>
<a name="ln743"> </a>
<a name="ln744">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[0], 0);</a>
<a name="ln745">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[1], 1);</a>
<a name="ln746">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[2], 2);</a>
<a name="ln747">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[3], 3);</a>
<a name="ln748">#endif</a>
<a name="ln749"> </a>
<a name="ln750">  dt_bauhaus_slider_set(g-&gt;damping, p-&gt;random.damping);</a>
<a name="ln751"> </a>
<a name="ln752">  if(p-&gt;dither_type == DITHER_RANDOM)</a>
<a name="ln753">    gtk_widget_show(GTK_WIDGET(g-&gt;random));</a>
<a name="ln754">  else</a>
<a name="ln755">    gtk_widget_hide(GTK_WIDGET(g-&gt;random));</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">void init(dt_iop_module_t *module)</a>
<a name="ln759">{</a>
<a name="ln760">  module-&gt;params = calloc(1, sizeof(dt_iop_dither_params_t));</a>
<a name="ln761">  module-&gt;default_params = calloc(1, sizeof(dt_iop_dither_params_t));</a>
<a name="ln762">  module-&gt;default_enabled = 0;</a>
<a name="ln763">  module-&gt;params_size = sizeof(dt_iop_dither_params_t);</a>
<a name="ln764">  module-&gt;gui_data = NULL;</a>
<a name="ln765">  dt_iop_dither_params_t tmp</a>
<a name="ln766">      = (dt_iop_dither_params_t){ DITHER_FSAUTO, 0, { 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }, -200.0f } };</a>
<a name="ln767">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_dither_params_t));</a>
<a name="ln768">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_dither_params_t));</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771"> </a>
<a name="ln772">void cleanup(dt_iop_module_t *module)</a>
<a name="ln773">{</a>
<a name="ln774">  free(module-&gt;params);</a>
<a name="ln775">  module-&gt;params = NULL;</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln779">{</a>
<a name="ln780">  self-&gt;gui_data = malloc(sizeof(dt_iop_dither_gui_data_t));</a>
<a name="ln781">  dt_iop_dither_gui_data_t *g = (dt_iop_dither_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln782">  dt_iop_dither_params_t *p = (dt_iop_dither_params_t *)self-&gt;params;</a>
<a name="ln783"> </a>
<a name="ln784">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln785">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln786">  g-&gt;random = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln787"> </a>
<a name="ln788">  g-&gt;dither_type = dt_bauhaus_combobox_new(self);</a>
<a name="ln789">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;random&quot;));</a>
<a name="ln790">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 1-bit B&amp;W&quot;));</a>
<a name="ln791">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 4-bit gray&quot;));</a>
<a name="ln792">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 8-bit RGB&quot;));</a>
<a name="ln793">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg 16-bit RGB&quot;));</a>
<a name="ln794">  dt_bauhaus_combobox_add(g-&gt;dither_type, _(&quot;floyd-steinberg auto&quot;));</a>
<a name="ln795">  dt_bauhaus_widget_set_label(g-&gt;dither_type, NULL, _(&quot;method&quot;));</a>
<a name="ln796"> </a>
<a name="ln797">#if 0</a>
<a name="ln798">  g-&gt;radius = dt_bauhaus_slider_new_with_range(self, 0.0, 200.0, 0.1, p-&gt;random.radius, 2);</a>
<a name="ln799">  gtk_widget_set_tooltip_text(g-&gt;radius, _(&quot;radius for blurring step&quot;));</a>
<a name="ln800">  dt_bauhaus_widget_set_label(g-&gt;radius, NULL, _(&quot;radius&quot;));</a>
<a name="ln801"> </a>
<a name="ln802">  g-&gt;range = dtgtk_gradient_slider_multivalue_new(4);</a>
<a name="ln803">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG, 0);</a>
<a name="ln804">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG, 1);</a>
<a name="ln805">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_UPPER_FILLED_BIG, 2);</a>
<a name="ln806">  dtgtk_gradient_slider_multivalue_set_marker(DTGTK_GRADIENT_SLIDER(g-&gt;range), GRADIENT_SLIDER_MARKER_LOWER_OPEN_BIG, 3);</a>
<a name="ln807">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[0], 0);</a>
<a name="ln808">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[1], 1);</a>
<a name="ln809">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[2], 2);</a>
<a name="ln810">  dtgtk_gradient_slider_multivalue_set_value(DTGTK_GRADIENT_SLIDER(g-&gt;range), p-&gt;random.range[3], 3);</a>
<a name="ln811">  gtk_widget_set_tooltip_text(g-&gt;range, _(&quot;the gradient range where to apply random dither&quot;));</a>
<a name="ln812">  g-&gt;range_label = gtk_label_new(_(&quot;gradient range&quot;));</a>
<a name="ln813"> </a>
<a name="ln814">  GtkWidget *rlabel = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0);</a>
<a name="ln815">  gtk_box_pack_start(GTK_BOX(rlabel), GTK_WIDGET(g-&gt;range_label), FALSE, FALSE, 0);</a>
<a name="ln816">#endif</a>
<a name="ln817"> </a>
<a name="ln818">  g-&gt;damping = dt_bauhaus_slider_new_with_range(self, -200.0, 0.0, 1.0, p-&gt;random.damping, 3);</a>
<a name="ln819">  gtk_widget_set_tooltip_text(g-&gt;damping, _(&quot;damping level of random dither&quot;));</a>
<a name="ln820">  dt_bauhaus_widget_set_label(g-&gt;damping, NULL, _(&quot;damping&quot;));</a>
<a name="ln821">  dt_bauhaus_slider_set_format(g-&gt;damping, &quot;%.0fdB&quot;);</a>
<a name="ln822"> </a>
<a name="ln823">#if 0</a>
<a name="ln824">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;radius, TRUE, TRUE, 0);</a>
<a name="ln825">  gtk_box_pack_start(GTK_BOX(g-&gt;random), rlabel, TRUE, TRUE, 0);</a>
<a name="ln826">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;range, TRUE, TRUE, 0);</a>
<a name="ln827">#endif</a>
<a name="ln828">  gtk_box_pack_start(GTK_BOX(g-&gt;random), g-&gt;damping, TRUE, TRUE, 0);</a>
<a name="ln829"> </a>
<a name="ln830">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;dither_type, TRUE, TRUE, 0);</a>
<a name="ln831">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;random, TRUE, TRUE, 0);</a>
<a name="ln832"> </a>
<a name="ln833">  g_signal_connect(G_OBJECT(g-&gt;dither_type), &quot;value-changed&quot;, G_CALLBACK(method_callback), self);</a>
<a name="ln834">#if 0</a>
<a name="ln835">  g_signal_connect (G_OBJECT (g-&gt;radius), &quot;value-changed&quot;,</a>
<a name="ln836">                    G_CALLBACK (radius_callback), self);</a>
<a name="ln837">  g_signal_connect (G_OBJECT (g-&gt;range), &quot;value-changed&quot;,</a>
<a name="ln838">                    G_CALLBACK (range_callback), self);</a>
<a name="ln839">#endif</a>
<a name="ln840">  g_signal_connect(G_OBJECT(g-&gt;damping), &quot;value-changed&quot;, G_CALLBACK(damping_callback), self);</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln844">{</a>
<a name="ln845">  free(self-&gt;gui_data);</a>
<a name="ln846">  self-&gt;gui_data = NULL;</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln850">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln851">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="615"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'tea_states' pointer in the 'tea_states + 2 * dt_get_thread_num()' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 615, 605.</p></div>
<div class="balloon" rel="767"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 767, 760.</p></div>
<div class="balloon" rel="768"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 768, 761.</p></div>
<div class="balloon" rel="786"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 786, 780.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
