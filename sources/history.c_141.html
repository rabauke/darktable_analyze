
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2011 Henrik Andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;common/darktable.h&quot;</a>
<a name="ln20">#include &quot;common/debug.h&quot;</a>
<a name="ln21">#include &quot;common/styles.h&quot;</a>
<a name="ln22">#include &quot;common/undo.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;develop/develop.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;gui/styles.h&quot;</a>
<a name="ln29">#include &quot;libs/lib.h&quot;</a>
<a name="ln30">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">DT_MODULE(1)</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">typedef struct dt_undo_history_t</a>
<a name="ln36">{</a>
<a name="ln37">  GList *snapshot;</a>
<a name="ln38">  int end;</a>
<a name="ln39">} dt_undo_history_t;</a>
<a name="ln40"> </a>
<a name="ln41">typedef struct dt_lib_history_t</a>
<a name="ln42">{</a>
<a name="ln43">  /* vbox with managed history items */</a>
<a name="ln44">  GtkWidget *history_box;</a>
<a name="ln45">  GtkWidget *create_button;</a>
<a name="ln46">//   GtkWidget *apply_button;</a>
<a name="ln47">  GtkWidget *compress_button;</a>
<a name="ln48">  gboolean record_undo;</a>
<a name="ln49">} dt_lib_history_t;</a>
<a name="ln50"> </a>
<a name="ln51">/* compress history stack */</a>
<a name="ln52">static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln53">static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln54">static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data);</a>
<a name="ln55">/* signal callback for history change */</a>
<a name="ln56">static void _lib_history_change_callback(gpointer instance, gpointer user_data);</a>
<a name="ln57">static void _lib_history_module_remove_callback(gpointer instance, dt_iop_module_t *module, gpointer user_data);</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">const char *name(dt_lib_module_t *self)</a>
<a name="ln62">{</a>
<a name="ln63">  return _(&quot;history&quot;);</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">const char **views(dt_lib_module_t *self)</a>
<a name="ln67">{</a>
<a name="ln68">  static const char *v[] = {&quot;darkroom&quot;, NULL};</a>
<a name="ln69">  return v;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln73">{</a>
<a name="ln74">  return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">int position()</a>
<a name="ln78">{</a>
<a name="ln79">  return 900;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln83">{</a>
<a name="ln84">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;create style from history&quot;), 0, 0);</a>
<a name="ln85">//   dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;apply style from popup menu&quot;), 0, 0);</a>
<a name="ln86">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;compress history stack&quot;), 0, 0);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln90">{</a>
<a name="ln91">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln92"> </a>
<a name="ln93">  dt_accel_connect_button_lib(self, &quot;create style from history&quot;, d-&gt;create_button);</a>
<a name="ln94">//   dt_accel_connect_button_lib(self, &quot;apply style from popup menu&quot;, d-&gt;apply_button);</a>
<a name="ln95">  dt_accel_connect_button_lib(self, &quot;compress history stack&quot;, d-&gt;compress_button);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">void gui_init(dt_lib_module_t *self)</a>
<a name="ln99">{</a>
<a name="ln100">  /* initialize ui widgets */</a>
<a name="ln101">  dt_lib_history_t *d = (dt_lib_history_t *)g_malloc0(sizeof(dt_lib_history_t));</a>
<a name="ln102">  self-&gt;data = (void *)d;</a>
<a name="ln103"> </a>
<a name="ln104">  d-&gt;record_undo = TRUE;</a>
<a name="ln105"> </a>
<a name="ln106">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln107">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln108">  gtk_widget_set_name(self-&gt;widget, &quot;history-ui&quot;);</a>
<a name="ln109">  d-&gt;history_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);</a>
<a name="ln110"> </a>
<a name="ln111">  GtkWidget *hhbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln112"> </a>
<a name="ln113">  d-&gt;compress_button = gtk_button_new_with_label(_(&quot;compress history stack&quot;));</a>
<a name="ln114">  gtk_label_set_xalign (GTK_LABEL(gtk_bin_get_child(GTK_BIN(d-&gt;compress_button))), 0.0f);</a>
<a name="ln115">  gtk_widget_set_tooltip_text(d-&gt;compress_button, _(&quot;create a minimal history stack which produces the same image&quot;));</a>
<a name="ln116">  g_signal_connect(G_OBJECT(d-&gt;compress_button), &quot;clicked&quot;, G_CALLBACK(_lib_history_compress_clicked_callback), NULL);</a>
<a name="ln117"> </a>
<a name="ln118">  /* add toolbar button for creating style */</a>
<a name="ln119">  d-&gt;create_button = dtgtk_button_new(dtgtk_cairo_paint_styles, CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln120">  gtk_widget_set_size_request(d-&gt;create_button, DT_PIXEL_APPLY_DPI(24), -1);</a>
<a name="ln121">  g_signal_connect(G_OBJECT(d-&gt;create_button), &quot;clicked&quot;,</a>
<a name="ln122">                   G_CALLBACK(_lib_history_create_style_button_clicked_callback), NULL);</a>
<a name="ln123">  gtk_widget_set_tooltip_text(d-&gt;create_button, _(&quot;create a style from the current history stack&quot;));</a>
<a name="ln124"> </a>
<a name="ln125">  /* add buttons to buttonbox */</a>
<a name="ln126">  gtk_box_pack_start(GTK_BOX(hhbox), d-&gt;compress_button, TRUE, TRUE, 0);</a>
<a name="ln127">  gtk_box_pack_start(GTK_BOX(hhbox), d-&gt;create_button, FALSE, FALSE, 0);</a>
<a name="ln128"> </a>
<a name="ln129">  /* add history list and buttonbox to widget */</a>
<a name="ln130">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), d-&gt;history_box, FALSE, FALSE, 0);</a>
<a name="ln131">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), hhbox, FALSE, FALSE, 0);</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">  gtk_widget_show_all(self-&gt;widget);</a>
<a name="ln135"> </a>
<a name="ln136">  /* connect to history change signal for updating the history view */</a>
<a name="ln137">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE,</a>
<a name="ln138">                            G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln139">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_MODULE_REMOVE,</a>
<a name="ln140">                            G_CALLBACK(_lib_history_module_remove_callback), self);</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln144">{</a>
<a name="ln145">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_change_callback), self);</a>
<a name="ln146">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_history_module_remove_callback), self);</a>
<a name="ln147">  g_free(self-&gt;data);</a>
<a name="ln148">  self-&gt;data = NULL;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static GtkWidget *_lib_history_create_button(dt_lib_module_t *self, int num, const char *label,</a>
<a name="ln152">                                             gboolean enabled, gboolean selected)</a>
<a name="ln153">{</a>
<a name="ln154">  /* create label */</a>
<a name="ln155">  GtkWidget *widget = NULL;</a>
<a name="ln156">  gchar numlabel[256];</a>
<a name="ln157">  if(num == -1)</a>
<a name="ln158">    g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s&quot;, num + 1, label);</a>
<a name="ln159">  else</a>
<a name="ln160">  {</a>
<a name="ln161">    if(enabled)</a>
<a name="ln162">      g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s&quot;, num + 1, label);</a>
<a name="ln163">    else</a>
<a name="ln164">      g_snprintf(numlabel, sizeof(numlabel), &quot;%d - %s (%s)&quot;, num + 1, label, _(&quot;off&quot;));</a>
<a name="ln165">  }</a>
<a name="ln166"> </a>
<a name="ln167">  /* create toggle button */</a>
<a name="ln168">  widget = gtk_toggle_button_new_with_label(numlabel);</a>
<a name="ln169">  gtk_widget_set_halign(gtk_bin_get_child(GTK_BIN(widget)), GTK_ALIGN_START);</a>
<a name="ln170">  g_object_set_data(G_OBJECT(widget), &quot;history_number&quot;, GINT_TO_POINTER(num + 1));</a>
<a name="ln171">  g_object_set_data(G_OBJECT(widget), &quot;label&quot;, (gpointer)label);</a>
<a name="ln172">  if(selected) gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), TRUE);</a>
<a name="ln173"> </a>
<a name="ln174">  /* set callback when clicked */</a>
<a name="ln175">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_lib_history_button_clicked_callback), self);</a>
<a name="ln176"> </a>
<a name="ln177">  /* associate the history number */</a>
<a name="ln178">  g_object_set_data(G_OBJECT(widget), &quot;history-number&quot;, GINT_TO_POINTER(num + 1));</a>
<a name="ln179"> </a>
<a name="ln180">  return widget;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static dt_iop_module_t *get_base_module(GList *iop_list, const char *op)</a>
<a name="ln184">{</a>
<a name="ln185">  dt_iop_module_t *result = NULL;</a>
<a name="ln186"> </a>
<a name="ln187">  GList *modules = g_list_first(iop_list);</a>
<a name="ln188">  while(modules)</a>
<a name="ln189">  {</a>
<a name="ln190">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln191">    if(strcmp(mod-&gt;op, op) == 0)</a>
<a name="ln192">    {</a>
<a name="ln193">      result = mod;</a>
<a name="ln194">      break;</a>
<a name="ln195">    }</a>
<a name="ln196">    modules = g_list_next(modules);</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  return result;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static GList *_duplicate_history(GList *hist)</a>
<a name="ln203">{</a>
<a name="ln204">  GList *result = NULL;</a>
<a name="ln205"> </a>
<a name="ln206">  GList *h = g_list_first(hist);</a>
<a name="ln207">  while(h)</a>
<a name="ln208">  {</a>
<a name="ln209">    const dt_dev_history_item_t *old = (dt_dev_history_item_t *)(h-&gt;data);</a>
<a name="ln210"> </a>
<a name="ln211">    dt_dev_history_item_t *new = (dt_dev_history_item_t *)malloc(sizeof(dt_dev_history_item_t));</a>
<a name="ln212"> </a>
<a name="ln213">    memcpy(new, old, sizeof(dt_dev_history_item_t));</a>
<a name="ln214"> </a>
<a name="ln215">    int32_t params_size = 0;</a>
<a name="ln216">    if(old-&gt;module)</a>
<a name="ln217">    {</a>
<a name="ln218">      params_size = old-&gt;module-&gt;params_size;</a>
<a name="ln219">    }</a>
<a name="ln220">    else</a>
<a name="ln221">    {</a>
<a name="ln222">      dt_iop_module_t *base = get_base_module(darktable.develop-&gt;iop, old-&gt;op_name);</a>
<a name="ln223">      if(base)</a>
<a name="ln224">      {</a>
<a name="ln225">        params_size = base-&gt;params_size;</a>
<a name="ln226">      }</a>
<a name="ln227">      else</a>
<a name="ln228">      {</a>
<a name="ln229">        // nothing else to do</a>
<a name="ln230">        fprintf(stderr, &quot;[_duplicate_history] can't find base module for %s\n&quot;, old-&gt;op_name);</a>
<a name="ln231">      }</a>
<a name="ln232">    }</a>
<a name="ln233"> </a>
<a name="ln234">    new-&gt;params = malloc(params_size);</a>
<a name="ln235">    new-&gt;blend_params = malloc(sizeof(dt_develop_blend_params_t));</a>
<a name="ln236"> </a>
<a name="ln237">    memcpy(new-&gt;params, old-&gt;params, params_size);</a>
<a name="ln238">    memcpy(new-&gt;blend_params, old-&gt;blend_params, sizeof(dt_develop_blend_params_t));</a>
<a name="ln239"> </a>
<a name="ln240">    result = g_list_append(result, new);</a>
<a name="ln241"> </a>
<a name="ln242">    h = g_list_next(h);</a>
<a name="ln243">  }</a>
<a name="ln244">  return result;</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">static void _reset_module_instance(GList *hist, dt_iop_module_t *module, int multi_priority)</a>
<a name="ln248">{</a>
<a name="ln249">  while (hist)</a>
<a name="ln250">  {</a>
<a name="ln251">    dt_dev_history_item_t *hit = (dt_dev_history_item_t *)hist-&gt;data;</a>
<a name="ln252"> </a>
<a name="ln253">    if(!hit-&gt;module &amp;&amp; strcmp(hit-&gt;op_name, module-&gt;op) == 0 &amp;&amp; hit-&gt;multi_priority == multi_priority)</a>
<a name="ln254">    {</a>
<a name="ln255">      hit-&gt;module = module;</a>
<a name="ln256">    }</a>
<a name="ln257">    hist = hist-&gt;next;</a>
<a name="ln258">  }</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">struct _cb_data</a>
<a name="ln262">{</a>
<a name="ln263">  dt_iop_module_t *module;</a>
<a name="ln264">  int multi_priority;</a>
<a name="ln265">};</a>
<a name="ln266"> </a>
<a name="ln267">static void _undo_items_cb(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *data)</a>
<a name="ln268">{</a>
<a name="ln269">  struct _cb_data *udata = (struct _cb_data *)user_data;</a>
<a name="ln270">  dt_undo_history_t *hdata = (dt_undo_history_t *)data;</a>
<a name="ln271">  _reset_module_instance(hdata-&gt;snapshot, udata-&gt;module, udata-&gt;multi_priority);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static void _history_invalidate_cb(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *item)</a>
<a name="ln275">{</a>
<a name="ln276">  dt_iop_module_t *module = (dt_iop_module_t *)user_data;</a>
<a name="ln277">  dt_undo_history_t *hist = (dt_undo_history_t *)item;</a>
<a name="ln278">  dt_dev_invalidate_history_module(hist-&gt;snapshot, module);</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static void _add_module_expander(GList *iop_list, dt_iop_module_t *module)</a>
<a name="ln282">{</a>
<a name="ln283">  // dt_dev_reload_history_items won't do this for base instances</a>
<a name="ln284">  // and it will call gui_init() for the rest</a>
<a name="ln285">  // so we do it here</a>
<a name="ln286">  if(!dt_iop_is_hidden(module) &amp;&amp; !module-&gt;expander)</a>
<a name="ln287">  {</a>
<a name="ln288">    // since multi_priority is in reverse order, we want the last one</a>
<a name="ln289">    // that is grather than this</a>
<a name="ln290">    dt_iop_module_t *base = NULL;</a>
<a name="ln291">    dt_iop_module_t *base_last = NULL;</a>
<a name="ln292">    GList *mods = g_list_last(iop_list);</a>
<a name="ln293">    while(mods)</a>
<a name="ln294">    {</a>
<a name="ln295">      dt_iop_module_t *mod = (dt_iop_module_t *)(mods-&gt;data);</a>
<a name="ln296"> </a>
<a name="ln297">      if(mod != module &amp;&amp; mod-&gt;instance == module-&gt;instance)</a>
<a name="ln298">      {</a>
<a name="ln299">        // we save the last one in case module is the last one</a>
<a name="ln300">        base_last = mod;</a>
<a name="ln301">        if(mod-&gt;multi_priority &gt; module-&gt;multi_priority)</a>
<a name="ln302">        {</a>
<a name="ln303">          base = mod;</a>
<a name="ln304">          break;</a>
<a name="ln305">        }</a>
<a name="ln306">      }</a>
<a name="ln307">      mods = g_list_previous(mods);</a>
<a name="ln308">    }</a>
<a name="ln309">    if(base == NULL)</a>
<a name="ln310">    {</a>
<a name="ln311">      base = base_last;</a>
<a name="ln312">      base_last = NULL;</a>
<a name="ln313">    }</a>
<a name="ln314">    if(base)</a>
<a name="ln315">    {</a>
<a name="ln316">      /* add module to right panel */</a>
<a name="ln317">      GtkWidget *expander = dt_iop_gui_get_expander(module);</a>
<a name="ln318">      dt_ui_container_add_widget(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER, expander);</a>
<a name="ln319">      dt_iop_gui_set_expanded(module, TRUE, FALSE);</a>
<a name="ln320">      dt_iop_gui_update_blending(module);</a>
<a name="ln321">    }</a>
<a name="ln322">    else</a>
<a name="ln323">      fprintf(stderr, &quot;[_add_module_expander] can't find base for module %s\n&quot;, module-&gt;op);</a>
<a name="ln324">  }</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">// return the 1st history entry that matches module</a>
<a name="ln328">static dt_dev_history_item_t *_search_history_by_module(GList *history_list, dt_iop_module_t *module)</a>
<a name="ln329">{</a>
<a name="ln330">  dt_dev_history_item_t *hist_ret = NULL;</a>
<a name="ln331"> </a>
<a name="ln332">  GList *history = g_list_first(history_list);</a>
<a name="ln333">  while(history)</a>
<a name="ln334">  {</a>
<a name="ln335">    dt_dev_history_item_t *hist_item = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln336"> </a>
<a name="ln337">    if(hist_item-&gt;module == module)</a>
<a name="ln338">    {</a>
<a name="ln339">      hist_ret = hist_item;</a>
<a name="ln340">      break;</a>
<a name="ln341">    }</a>
<a name="ln342"> </a>
<a name="ln343">    history = g_list_next(history);</a>
<a name="ln344">  }</a>
<a name="ln345">  return hist_ret;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">static int _check_deleted_instances(dt_develop_t *dev, GList **_iop_list, GList *history_list)</a>
<a name="ln349">{</a>
<a name="ln350">  GList *iop_list = *_iop_list;</a>
<a name="ln351">  int deleted_module_found = 0;</a>
<a name="ln352"> </a>
<a name="ln353">  // we will check on dev-&gt;iop if there's a module that is not in history</a>
<a name="ln354">  GList *modules = g_list_first(iop_list);</a>
<a name="ln355">  while(modules)</a>
<a name="ln356">  {</a>
<a name="ln357">    dt_iop_module_t *mod = (dt_iop_module_t *)modules-&gt;data;</a>
<a name="ln358"> </a>
<a name="ln359">    int delete_module = 0;</a>
<a name="ln360"> </a>
<a name="ln361">    // base modules are a special case</a>
<a name="ln362">    // most base modules won't be in history and must not be deleted</a>
<a name="ln363">    // but the user may have deleted a base instance of a multi-instance module</a>
<a name="ln364">    // and then undo and redo, so we will end up with two entries in dev-&gt;iop</a>
<a name="ln365">    // with multi_priority == 0, this can't happen and the extra one must be deleted</a>
<a name="ln366">    // dev-&gt;iop is sorted by (priority, multi_priority DESC), so if the next one is</a>
<a name="ln367">    // a base instance too, one must be deleted</a>
<a name="ln368">    if(mod-&gt;multi_priority == 0)</a>
<a name="ln369">    {</a>
<a name="ln370">      GList *modules_next = g_list_next(modules);</a>
<a name="ln371">      if(modules_next)</a>
<a name="ln372">      {</a>
<a name="ln373">        dt_iop_module_t *mod_next = (dt_iop_module_t *)modules_next-&gt;data;</a>
<a name="ln374">        if(strcmp(mod_next-&gt;op, mod-&gt;op) == 0 &amp;&amp; mod_next-&gt;multi_priority == 0)</a>
<a name="ln375">        {</a>
<a name="ln376">          // is the same one, check which one must be deleted</a>
<a name="ln377">          const int mod_in_history = (_search_history_by_module(history_list, mod) != NULL);</a>
<a name="ln378">          const int mod_next_in_history = (_search_history_by_module(history_list, mod_next) != NULL);</a>
<a name="ln379"> </a>
<a name="ln380">          // current is in history and next is not, delete next</a>
<a name="ln381">          if(mod_in_history &amp;&amp; !mod_next_in_history)</a>
<a name="ln382">          {</a>
<a name="ln383">            mod = mod_next;</a>
<a name="ln384">            modules = modules_next;</a>
<a name="ln385">            delete_module = 1;</a>
<a name="ln386">          }</a>
<a name="ln387">          // current is not in history and next is, delete current</a>
<a name="ln388">          else if(!mod_in_history &amp;&amp; mod_next_in_history)</a>
<a name="ln389">          {</a>
<a name="ln390">            delete_module = 1;</a>
<a name="ln391">          }</a>
<a name="ln392">          else</a>
<a name="ln393">          {</a>
<a name="ln394">            if(mod_in_history &amp;&amp; mod_next_in_history)</a>
<a name="ln395">              fprintf(</a>
<a name="ln396">                  stderr,</a>
<a name="ln397">                  &quot;[_check_deleted_instances] found duplicate module %s %s (%i) and %s %s (%i) both in history\n&quot;,</a>
<a name="ln398">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod_next-&gt;op, mod_next-&gt;multi_name,</a>
<a name="ln399">                  mod_next-&gt;multi_priority);</a>
<a name="ln400">            else</a>
<a name="ln401">              fprintf(</a>
<a name="ln402">                  stderr,</a>
<a name="ln403">                  &quot;[_check_deleted_instances] found duplicate module %s %s (%i) and %s %s (%i) none in history\n&quot;,</a>
<a name="ln404">                  mod-&gt;op, mod-&gt;multi_name, mod-&gt;multi_priority, mod_next-&gt;op, mod_next-&gt;multi_name,</a>
<a name="ln405">                  mod_next-&gt;multi_priority);</a>
<a name="ln406">          }</a>
<a name="ln407">        }</a>
<a name="ln408">      }</a>
<a name="ln409">    }</a>
<a name="ln410">    // this is a regular multi-instance and must be in history</a>
<a name="ln411">    else</a>
<a name="ln412">    {</a>
<a name="ln413">      delete_module = (_search_history_by_module(history_list, mod) == NULL);</a>
<a name="ln414">    }</a>
<a name="ln415"> </a>
<a name="ln416">    // if module is not in history we delete it</a>
<a name="ln417">    if(delete_module)</a>
<a name="ln418">    {</a>
<a name="ln419">      deleted_module_found = 1;</a>
<a name="ln420"> </a>
<a name="ln421">      if(darktable.develop-&gt;gui_module == mod) dt_iop_request_focus(NULL);</a>
<a name="ln422"> </a>
<a name="ln423">      const int reset = darktable.gui-&gt;reset;</a>
<a name="ln424">      darktable.gui-&gt;reset = 1;</a>
<a name="ln425"> </a>
<a name="ln426">      // we remove the plugin effectively</a>
<a name="ln427">      if(!dt_iop_is_hidden(mod))</a>
<a name="ln428">      {</a>
<a name="ln429">        // we just hide the module to avoid lots of gtk critical warnings</a>
<a name="ln430">        gtk_widget_hide(mod-&gt;expander);</a>
<a name="ln431"> </a>
<a name="ln432">        // this is copied from dt_iop_gui_delete_callback(), not sure why the above sentence...</a>
<a name="ln433">        gtk_widget_destroy(mod-&gt;widget);</a>
<a name="ln434">        dt_iop_gui_cleanup_module(mod);</a>
<a name="ln435">      }</a>
<a name="ln436"> </a>
<a name="ln437">      iop_list = g_list_remove_link(iop_list, modules);</a>
<a name="ln438"> </a>
<a name="ln439">      // remove it from all snapshots</a>
<a name="ln440">      dt_undo_iterate_internal(darktable.undo, DT_UNDO_HISTORY, mod, &amp;_history_invalidate_cb);</a>
<a name="ln441"> </a>
<a name="ln442">      // we cleanup the module</a>
<a name="ln443">      dt_accel_disconnect_list(mod-&gt;accel_closures);</a>
<a name="ln444">      dt_accel_cleanup_locals_iop(mod);</a>
<a name="ln445">      mod-&gt;accel_closures = NULL;</a>
<a name="ln446">      // don't delete the module, a pipe may still need it</a>
<a name="ln447">      dev-&gt;alliop = g_list_append(dev-&gt;alliop, mod);</a>
<a name="ln448"> </a>
<a name="ln449">      darktable.gui-&gt;reset = reset;</a>
<a name="ln450"> </a>
<a name="ln451">      // and reset the list</a>
<a name="ln452">      modules = g_list_first(iop_list);</a>
<a name="ln453">      continue;</a>
<a name="ln454">    }</a>
<a name="ln455"> </a>
<a name="ln456">    modules = g_list_next(modules);</a>
<a name="ln457">  }</a>
<a name="ln458">  if(deleted_module_found) iop_list = g_list_sort(iop_list, sort_plugins);</a>
<a name="ln459"> </a>
<a name="ln460">  *_iop_list = iop_list;</a>
<a name="ln461"> </a>
<a name="ln462">  return deleted_module_found;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">static void _reorder_gui_module_list(dt_develop_t *dev)</a>
<a name="ln466">{</a>
<a name="ln467">  int pos_module = 0;</a>
<a name="ln468">  GList *modules = g_list_last(dev-&gt;iop);</a>
<a name="ln469">  while(modules)</a>
<a name="ln470">  {</a>
<a name="ln471">    dt_iop_module_t *module = (dt_iop_module_t *)(modules-&gt;data);</a>
<a name="ln472"> </a>
<a name="ln473">    GtkWidget *expander = module-&gt;expander;</a>
<a name="ln474">    if(expander)</a>
<a name="ln475">    {</a>
<a name="ln476">      gtk_box_reorder_child(dt_ui_get_container(darktable.gui-&gt;ui, DT_UI_CONTAINER_PANEL_RIGHT_CENTER), expander,</a>
<a name="ln477">                            pos_module++);</a>
<a name="ln478">    }</a>
<a name="ln479"> </a>
<a name="ln480">    modules = g_list_previous(modules);</a>
<a name="ln481">  }</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">static int _rebuild_multi_priority(GList *history_list)</a>
<a name="ln485">{</a>
<a name="ln486">  int changed = 0;</a>
<a name="ln487">  GList *history = g_list_first(history_list);</a>
<a name="ln488">  while(history)</a>
<a name="ln489">  {</a>
<a name="ln490">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)history-&gt;data;</a>
<a name="ln491"> </a>
<a name="ln492">    // if multi_priority is different in history and dev-&gt;iop</a>
<a name="ln493">    // we keep the history version</a>
<a name="ln494">    if(hitem-&gt;module &amp;&amp; hitem-&gt;module-&gt;multi_priority != hitem-&gt;multi_priority)</a>
<a name="ln495">    {</a>
<a name="ln496">      dt_iop_update_multi_priority(hitem-&gt;module, hitem-&gt;multi_priority);</a>
<a name="ln497">      changed = 1;</a>
<a name="ln498">    }</a>
<a name="ln499"> </a>
<a name="ln500">    history = g_list_next(history);</a>
<a name="ln501">  }</a>
<a name="ln502">  return changed;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">static int _create_deleted_modules(GList **_iop_list, GList *history_list)</a>
<a name="ln506">{</a>
<a name="ln507">  GList *iop_list = *_iop_list;</a>
<a name="ln508">  int changed = 0;</a>
<a name="ln509">  gboolean done = FALSE;</a>
<a name="ln510"> </a>
<a name="ln511">  GList *l = g_list_first(history_list);</a>
<a name="ln512">  while(l)</a>
<a name="ln513">  {</a>
<a name="ln514">    GList *next = g_list_next(l);</a>
<a name="ln515">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)l-&gt;data;</a>
<a name="ln516"> </a>
<a name="ln517">    // this fixes the duplicate module when undo: hitem-&gt;multi_priority = 0;</a>
<a name="ln518">    if(hitem-&gt;module == NULL)</a>
<a name="ln519">    {</a>
<a name="ln520">      changed = 1;</a>
<a name="ln521"> </a>
<a name="ln522">      const dt_iop_module_t *base_module = get_base_module(iop_list, hitem-&gt;op_name);</a>
<a name="ln523">      if(base_module == NULL)</a>
<a name="ln524">      {</a>
<a name="ln525">        fprintf(stderr, &quot;[_create_deleted_modules] can't find base module for %s\n&quot;, hitem-&gt;op_name);</a>
<a name="ln526">        return changed;</a>
<a name="ln527">      }</a>
<a name="ln528"> </a>
<a name="ln529">      // from there we create a new module for this base instance. The goal is to do a very minimal setup of the</a>
<a name="ln530">      // new module to be able to write the history items. From there we reload the whole history back and this</a>
<a name="ln531">      // will recreate the proper module instances.</a>
<a name="ln532">      dt_iop_module_t *module = (dt_iop_module_t *)calloc(1, sizeof(dt_iop_module_t));</a>
<a name="ln533">      if(dt_iop_load_module(module, base_module-&gt;so, base_module-&gt;dev))</a>
<a name="ln534">      {</a>
<a name="ln535">        return changed;</a>
<a name="ln536">      }</a>
<a name="ln537">      module-&gt;instance = base_module-&gt;instance;</a>
<a name="ln538"> </a>
<a name="ln539">      if(!dt_iop_is_hidden(module))</a>
<a name="ln540">      {</a>
<a name="ln541">        module-&gt;gui_init(module);</a>
<a name="ln542">      }</a>
<a name="ln543"> </a>
<a name="ln544">      // adjust the multi_name of the new module</a>
<a name="ln545">      g_strlcpy(module-&gt;multi_name, hitem-&gt;multi_name, sizeof(module-&gt;multi_name));</a>
<a name="ln546">      dt_iop_update_multi_priority(module, hitem-&gt;multi_priority);</a>
<a name="ln547"> </a>
<a name="ln548">      // we insert this module into dev-&gt;iop</a>
<a name="ln549">      iop_list = g_list_insert_sorted(iop_list, module, sort_plugins);</a>
<a name="ln550"> </a>
<a name="ln551">      // add the expander, dt_dev_reload_history_items() don't work well without one</a>
<a name="ln552">      _add_module_expander(iop_list, module);</a>
<a name="ln553"> </a>
<a name="ln554">      // if not already done, set the module to all others same instance</a>
<a name="ln555">      if(!done)</a>
<a name="ln556">      {</a>
<a name="ln557">        _reset_module_instance(history_list, module, hitem-&gt;multi_priority);</a>
<a name="ln558"> </a>
<a name="ln559">        // and do that also in the undo/redo lists</a>
<a name="ln560">        struct _cb_data udata = { module, hitem-&gt;multi_priority };</a>
<a name="ln561">        dt_undo_iterate_internal(darktable.undo, DT_UNDO_HISTORY, &amp;udata, &amp;_undo_items_cb);</a>
<a name="ln562">        done = TRUE;</a>
<a name="ln563">      }</a>
<a name="ln564"> </a>
<a name="ln565">      hitem-&gt;module = module;</a>
<a name="ln566">    }</a>
<a name="ln567">    l = next;</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  *_iop_list = iop_list;</a>
<a name="ln571"> </a>
<a name="ln572">  return changed;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">static void _pop_undo(gpointer user_data, dt_undo_type_t type, dt_undo_data_t *data, dt_undo_action_t action)</a>
<a name="ln576">{</a>
<a name="ln577">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln578">  dt_develop_t *dev = darktable.develop;</a>
<a name="ln579"> </a>
<a name="ln580">  if(type == DT_UNDO_HISTORY)</a>
<a name="ln581">  {</a>
<a name="ln582">    dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln583">    dt_undo_history_t *hist = (dt_undo_history_t *)data;</a>
<a name="ln584"> </a>
<a name="ln585">    // we will work on a copy of history and modules</a>
<a name="ln586">    // when we're done we'll replace dev-&gt;history and dev-&gt;iop</a>
<a name="ln587">    GList *history_temp = _duplicate_history(hist-&gt;snapshot);</a>
<a name="ln588">    const int hist_end = hist-&gt;end;</a>
<a name="ln589">    GList *iop_temp = g_list_copy(dev-&gt;iop);</a>
<a name="ln590"> </a>
<a name="ln591">    // topology has changed?</a>
<a name="ln592">    int pipe_remove = 0;</a>
<a name="ln593"> </a>
<a name="ln594">    // we have to check if multi_priority has changed since history was saved</a>
<a name="ln595">    // we will adjust it here</a>
<a name="ln596">    if(_rebuild_multi_priority(history_temp))</a>
<a name="ln597">    {</a>
<a name="ln598">      pipe_remove = 1;</a>
<a name="ln599">      iop_temp = g_list_sort(iop_temp, sort_plugins);</a>
<a name="ln600">    }</a>
<a name="ln601"> </a>
<a name="ln602">    // check if this undo a delete module and re-create it</a>
<a name="ln603">    if(_create_deleted_modules(&amp;iop_temp, history_temp))</a>
<a name="ln604">    {</a>
<a name="ln605">      pipe_remove = 1;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    // check if this is a redo of a delete module or an undo of an add module</a>
<a name="ln609">    if(_check_deleted_instances(dev, &amp;iop_temp, history_temp))</a>
<a name="ln610">    {</a>
<a name="ln611">      pipe_remove = 1;</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">    // disable recording undo as the _lib_history_change_callback will be triggered by the calls below</a>
<a name="ln615">    d-&gt;record_undo = FALSE;</a>
<a name="ln616"> </a>
<a name="ln617">    dt_pthread_mutex_lock(&amp;dev-&gt;history_mutex);</a>
<a name="ln618"> </a>
<a name="ln619">    // set history and modules to dev</a>
<a name="ln620">    GList *history_temp2 = dev-&gt;history;</a>
<a name="ln621">    dev-&gt;history = history_temp;</a>
<a name="ln622">    dev-&gt;history_end = hist_end;</a>
<a name="ln623">    g_list_free_full(history_temp2, dt_dev_free_history_item);</a>
<a name="ln624">    GList *iop_temp2 = dev-&gt;iop;</a>
<a name="ln625">    dev-&gt;iop = iop_temp;</a>
<a name="ln626">    g_list_free(iop_temp2);</a>
<a name="ln627"> </a>
<a name="ln628">    // topology has changed</a>
<a name="ln629">    if(pipe_remove)</a>
<a name="ln630">    {</a>
<a name="ln631">      // we refresh the pipe</a>
<a name="ln632">      dev-&gt;pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln633">      dev-&gt;preview_pipe-&gt;changed |= DT_DEV_PIPE_REMOVE;</a>
<a name="ln634">      dev-&gt;pipe-&gt;cache_obsolete = 1;</a>
<a name="ln635">      dev-&gt;preview_pipe-&gt;cache_obsolete = 1;</a>
<a name="ln636"> </a>
<a name="ln637">      // invalidate buffers and force redraw of darkroom</a>
<a name="ln638">      dt_dev_invalidate_all(dev);</a>
<a name="ln639">    }</a>
<a name="ln640"> </a>
<a name="ln641">    dt_pthread_mutex_unlock(&amp;dev-&gt;history_mutex);</a>
<a name="ln642"> </a>
<a name="ln643">    // if dev-&gt;iop has changed reflect that on module list</a>
<a name="ln644">    if(pipe_remove) _reorder_gui_module_list(dev);</a>
<a name="ln645"> </a>
<a name="ln646">    // write new history and reload</a>
<a name="ln647">    dt_dev_write_history(dev);</a>
<a name="ln648">    dt_dev_reload_history_items(dev);</a>
<a name="ln649">  }</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">static void _history_undo_data_free(gpointer data)</a>
<a name="ln653">{</a>
<a name="ln654">  dt_undo_history_t *hist = (dt_undo_history_t *)data;</a>
<a name="ln655">  GList *snapshot = hist-&gt;snapshot;</a>
<a name="ln656">  g_list_free_full(snapshot, dt_dev_free_history_item);</a>
<a name="ln657">  free(data);</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">static void _lib_history_module_remove_callback(gpointer instance, dt_iop_module_t *module, gpointer user_data)</a>
<a name="ln661">{</a>
<a name="ln662">  dt_undo_iterate(darktable.undo, DT_UNDO_HISTORY, module, &amp;_history_invalidate_cb);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">static void _lib_history_change_callback(gpointer instance, gpointer user_data)</a>
<a name="ln666">{</a>
<a name="ln667">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln668">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln669"> </a>
<a name="ln670">  /* first destroy all buttons in list */</a>
<a name="ln671">  gtk_container_foreach(GTK_CONTAINER(d-&gt;history_box), (GtkCallback)gtk_widget_destroy, 0);</a>
<a name="ln672"> </a>
<a name="ln673">  /* add default which always should be */</a>
<a name="ln674">  int num = -1;</a>
<a name="ln675">  gtk_box_pack_start(GTK_BOX(d-&gt;history_box),</a>
<a name="ln676">                     _lib_history_create_button(self, num, _(&quot;original&quot;), FALSE, darktable.develop-&gt;history_end == 0),</a>
<a name="ln677">                     TRUE, TRUE, 0);</a>
<a name="ln678">  num++;</a>
<a name="ln679"> </a>
<a name="ln680">  if (d-&gt;record_undo == TRUE)</a>
<a name="ln681">  {</a>
<a name="ln682">    /* record undo/redo history snapshot */</a>
<a name="ln683">    dt_undo_history_t *hist = malloc(sizeof(dt_undo_history_t));</a>
<a name="ln684">    hist-&gt;snapshot = _duplicate_history(darktable.develop-&gt;history);</a>
<a name="ln685">    hist-&gt;end = darktable.develop-&gt;history_end;</a>
<a name="ln686"> </a>
<a name="ln687">    dt_undo_record(darktable.undo, self, DT_UNDO_HISTORY, (dt_undo_data_t *)hist,</a>
<a name="ln688">                   _pop_undo, _history_undo_data_free);</a>
<a name="ln689">  }</a>
<a name="ln690">  else</a>
<a name="ln691">    d-&gt;record_undo = TRUE;</a>
<a name="ln692"> </a>
<a name="ln693">  /* lock history mutex */</a>
<a name="ln694">  dt_pthread_mutex_lock(&amp;darktable.develop-&gt;history_mutex);</a>
<a name="ln695"> </a>
<a name="ln696">  /* iterate over history items and add them to list*/</a>
<a name="ln697">  GList *history = g_list_first(darktable.develop-&gt;history);</a>
<a name="ln698">  while(history)</a>
<a name="ln699">  {</a>
<a name="ln700">    dt_dev_history_item_t *hitem = (dt_dev_history_item_t *)(history-&gt;data);</a>
<a name="ln701"> </a>
<a name="ln702">    gchar *label;</a>
<a name="ln703">    if(!hitem-&gt;multi_name[0] || strcmp(hitem-&gt;multi_name, &quot;0&quot;) == 0)</a>
<a name="ln704">      label = g_strdup_printf(&quot;%s&quot;, hitem-&gt;module-&gt;name());</a>
<a name="ln705">    else</a>
<a name="ln706">      label = g_strdup_printf(&quot;%s %s&quot;, hitem-&gt;module-&gt;name(), hitem-&gt;multi_name);</a>
<a name="ln707"> </a>
<a name="ln708">    gboolean selected = (num == darktable.develop-&gt;history_end - 1);</a>
<a name="ln709">    GtkWidget *widget = _lib_history_create_button(self, num, label, hitem-&gt;enabled, selected);</a>
<a name="ln710">    g_free(label);</a>
<a name="ln711"> </a>
<a name="ln712">    gtk_box_pack_start(GTK_BOX(d-&gt;history_box), widget, TRUE, TRUE, 0);</a>
<a name="ln713">    gtk_box_reorder_child(GTK_BOX(d-&gt;history_box), widget, 0);</a>
<a name="ln714">    num++;</a>
<a name="ln715"> </a>
<a name="ln716">    history = g_list_next(history);</a>
<a name="ln717">  }</a>
<a name="ln718"> </a>
<a name="ln719">  /* show all widgets */</a>
<a name="ln720">  gtk_widget_show_all(d-&gt;history_box);</a>
<a name="ln721"> </a>
<a name="ln722">  dt_pthread_mutex_unlock(&amp;darktable.develop-&gt;history_mutex);</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">static void _lib_history_compress_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln726">{</a>
<a name="ln727">  const int imgid = darktable.develop-&gt;image_storage.id;</a>
<a name="ln728">  if(!imgid) return;</a>
<a name="ln729">  // make sure the right history is in there:</a>
<a name="ln730">  dt_dev_write_history(darktable.develop);</a>
<a name="ln731">  sqlite3_stmt *stmt;</a>
<a name="ln732"> </a>
<a name="ln733">  // compress history</a>
<a name="ln734">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;DELETE FROM main.history WHERE imgid = ?1 AND num &quot;</a>
<a name="ln735">                                                             &quot;NOT IN (SELECT MAX(num) FROM main.history WHERE &quot;</a>
<a name="ln736">                                                             &quot;imgid = ?1 AND num &lt; ?2 GROUP BY operation, &quot;</a>
<a name="ln737">                                                             &quot;multi_priority)&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln738">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln739">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop-&gt;history_end);</a>
<a name="ln740">  sqlite3_step(stmt);</a>
<a name="ln741">  sqlite3_finalize(stmt);</a>
<a name="ln742"> </a>
<a name="ln743">  // load new history and write it back to ensure that all history are properly numbered without a gap</a>
<a name="ln744">  dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln745">  dt_dev_write_history(darktable.develop);</a>
<a name="ln746"> </a>
<a name="ln747">  // then we can get the item to select in the new clean-up history retrieve the position of the module</a>
<a name="ln748">  // corresponding to the history end.</a>
<a name="ln749">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT IFNULL(MAX(num)+1, 0) FROM main.history &quot;</a>
<a name="ln750">                                                             &quot;WHERE imgid=?1&quot;, -1, &amp;stmt, NULL);</a>
<a name="ln751">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln752"> </a>
<a name="ln753">  if (sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln754">    darktable.develop-&gt;history_end = sqlite3_column_int(stmt, 0);</a>
<a name="ln755">  sqlite3_finalize(stmt);</a>
<a name="ln756"> </a>
<a name="ln757">  // select the new history end corresponding to the one before the history compression</a>
<a name="ln758">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;UPDATE main.images SET history_end=?2 WHERE id=?1&quot;,</a>
<a name="ln759">                              -1, &amp;stmt, NULL);</a>
<a name="ln760">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, imgid);</a>
<a name="ln761">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 2, darktable.develop-&gt;history_end);</a>
<a name="ln762">  sqlite3_step(stmt);</a>
<a name="ln763">  sqlite3_finalize(stmt);</a>
<a name="ln764"> </a>
<a name="ln765">  dt_dev_reload_history_items(darktable.develop);</a>
<a name="ln766">  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">static void _lib_history_button_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln770">{</a>
<a name="ln771">  static int reset = 0;</a>
<a name="ln772">  if(reset) return;</a>
<a name="ln773">  if(!gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) return;</a>
<a name="ln774"> </a>
<a name="ln775">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln776">  dt_lib_history_t *d = (dt_lib_history_t *)self-&gt;data;</a>
<a name="ln777">  reset = 1;</a>
<a name="ln778"> </a>
<a name="ln779">  /* inactivate all toggle buttons */</a>
<a name="ln780">  GList *children = gtk_container_get_children(GTK_CONTAINER(d-&gt;history_box));</a>
<a name="ln781">  for(GList *l = children; l != NULL; l = g_list_next(l))</a>
<a name="ln782">  {</a>
<a name="ln783">    GtkToggleButton *b = GTK_TOGGLE_BUTTON(l-&gt;data);</a>
<a name="ln784">    if(b != GTK_TOGGLE_BUTTON(widget)) g_object_set(G_OBJECT(b), &quot;active&quot;, FALSE, (gchar *)0);</a>
<a name="ln785">  }</a>
<a name="ln786">  g_list_free(children);</a>
<a name="ln787"> </a>
<a name="ln788">  reset = 0;</a>
<a name="ln789">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln790"> </a>
<a name="ln791">  /* revert to given history item. */</a>
<a name="ln792">  int num = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), &quot;history-number&quot;));</a>
<a name="ln793">  dt_dev_pop_history_items(darktable.develop, num);</a>
<a name="ln794">  /* signal history changed */</a>
<a name="ln795">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_DEVELOP_HISTORY_CHANGE);</a>
<a name="ln796">  dt_dev_modulegroups_set(darktable.develop, dt_dev_modulegroups_get(darktable.develop));</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">static void _lib_history_create_style_button_clicked_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln800">{</a>
<a name="ln801">  if(darktable.develop-&gt;image_storage.id)</a>
<a name="ln802">  {</a>
<a name="ln803">    dt_dev_write_history(darktable.develop);</a>
<a name="ln804">    dt_gui_styles_dialog_new(darktable.develop-&gt;image_storage.id);</a>
<a name="ln805">  }</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln809">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln810">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="213"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 213, 211.</p></div>
<div class="balloon" rel="237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 237, 234.</p></div>
<div class="balloon" rel="238"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 238, 235.</p></div>
<div class="balloon" rel="537"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'module'. Check lines: 537, 532.</p></div>
<div class="balloon" rel="684"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'hist'. Check lines: 684, 683.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
