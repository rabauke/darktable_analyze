
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2012 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#ifdef HAVE_CONFIG_H</a>
<a name="ln21">#include &quot;config.h&quot;</a>
<a name="ln22">#endif</a>
<a name="ln23">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln24">#include &quot;common/debug.h&quot;</a>
<a name="ln25">#include &quot;common/interpolation.h&quot;</a>
<a name="ln26">#include &quot;common/opencl.h&quot;</a>
<a name="ln27">#include &quot;control/conf.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29">#include &quot;develop/develop.h&quot;</a>
<a name="ln30">#include &quot;develop/imageop.h&quot;</a>
<a name="ln31">#include &quot;develop/tiling.h&quot;</a>
<a name="ln32">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln33">#include &quot;gui/gtk.h&quot;</a>
<a name="ln34">#include &quot;gui/guides.h&quot;</a>
<a name="ln35">#include &quot;gui/presets.h&quot;</a>
<a name="ln36">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;assert.h&gt;</a>
<a name="ln39">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln40">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln41">#include &lt;inttypes.h&gt;</a>
<a name="ln42">#include &lt;math.h&gt;</a>
<a name="ln43">#include &lt;stdlib.h&gt;</a>
<a name="ln44">#include &lt;string.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">DT_MODULE_INTROSPECTION(5, dt_iop_clipping_params_t)</a>
<a name="ln47"> </a>
<a name="ln48">#define CLAMPF(a, mn, mx) ((a) &lt; (mn) ? (mn) : ((a) &gt; (mx) ? (mx) : (a)))</a>
<a name="ln49"> </a>
<a name="ln50">/** flip H/V, rotate an image, then clip the buffer. */</a>
<a name="ln51">typedef enum dt_iop_clipping_flags_t</a>
<a name="ln52">{</a>
<a name="ln53">  FLAG_FLIP_HORIZONTAL = 1 &lt;&lt; 0,</a>
<a name="ln54">  FLAG_FLIP_VERTICAL = 1 &lt;&lt; 1</a>
<a name="ln55">} dt_iop_clipping_flags_t;</a>
<a name="ln56"> </a>
<a name="ln57">typedef struct dt_iop_clipping_aspect_t</a>
<a name="ln58">{</a>
<a name="ln59">  char *name;</a>
<a name="ln60">  int d, n;</a>
<a name="ln61">} dt_iop_clipping_aspect_t;</a>
<a name="ln62"> </a>
<a name="ln63">typedef struct dt_iop_clipping_params_t</a>
<a name="ln64">{</a>
<a name="ln65">  float angle, cx, cy, cw, ch, k_h, k_v;</a>
<a name="ln66">  float kxa, kya, kxb, kyb, kxc, kyc, kxd, kyd;</a>
<a name="ln67">  int k_type, k_sym;</a>
<a name="ln68">  int k_apply, crop_auto;</a>
<a name="ln69">  int ratio_n, ratio_d;</a>
<a name="ln70">} dt_iop_clipping_params_t;</a>
<a name="ln71"> </a>
<a name="ln72">typedef enum _grab_region_t</a>
<a name="ln73">{</a>
<a name="ln74">  GRAB_CENTER = 0,                                            // 0</a>
<a name="ln75">  GRAB_LEFT = 1 &lt;&lt; 0,                                         // 1</a>
<a name="ln76">  GRAB_TOP = 1 &lt;&lt; 1,                                          // 2</a>
<a name="ln77">  GRAB_RIGHT = 1 &lt;&lt; 2,                                        // 4</a>
<a name="ln78">  GRAB_BOTTOM = 1 &lt;&lt; 3,                                       // 8</a>
<a name="ln79">  GRAB_TOP_LEFT = GRAB_TOP | GRAB_LEFT,                       // 3</a>
<a name="ln80">  GRAB_TOP_RIGHT = GRAB_TOP | GRAB_RIGHT,                     // 6</a>
<a name="ln81">  GRAB_BOTTOM_RIGHT = GRAB_BOTTOM | GRAB_RIGHT,               // 12</a>
<a name="ln82">  GRAB_BOTTOM_LEFT = GRAB_BOTTOM | GRAB_LEFT,                 // 9</a>
<a name="ln83">  GRAB_HORIZONTAL = GRAB_LEFT | GRAB_RIGHT,                   // 5</a>
<a name="ln84">  GRAB_VERTICAL = GRAB_TOP | GRAB_BOTTOM,                     // 10</a>
<a name="ln85">  GRAB_ALL = GRAB_LEFT | GRAB_TOP | GRAB_RIGHT | GRAB_BOTTOM, // 15</a>
<a name="ln86">  GRAB_NONE = 1 &lt;&lt; 4                                          // 16</a>
<a name="ln87">} _grab_region_t;</a>
<a name="ln88"> </a>
<a name="ln89">/* calculate the aspect ratios for current image */</a>
<a name="ln90">static void keystone_type_populate(struct dt_iop_module_t *self, gboolean with_applied, int select);</a>
<a name="ln91"> </a>
<a name="ln92">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln93">                  void *new_params, const int new_version)</a>
<a name="ln94">{</a>
<a name="ln95">  if(new_version &lt;= old_version) return 1;</a>
<a name="ln96">  if(new_version != 5) return 1;</a>
<a name="ln97"> </a>
<a name="ln98">  dt_iop_clipping_params_t *n = (dt_iop_clipping_params_t *)new_params;</a>
<a name="ln99">  if(old_version == 2 &amp;&amp; new_version == 5)</a>
<a name="ln100">  {</a>
<a name="ln101">    union {</a>
<a name="ln102">        float f;</a>
<a name="ln103">        uint32_t u;</a>
<a name="ln104">    } k;</a>
<a name="ln105">    // old structure def</a>
<a name="ln106">    typedef struct old_params_t</a>
<a name="ln107">    {</a>
<a name="ln108">      float angle, cx, cy, cw, ch, k_h, k_v;</a>
<a name="ln109">    } old_params_t;</a>
<a name="ln110"> </a>
<a name="ln111">    old_params_t *o = (old_params_t *)old_params;</a>
<a name="ln112"> </a>
<a name="ln113">    k.f = o-&gt;k_h;</a>
<a name="ln114">    int is_horizontal;</a>
<a name="ln115">    if(k.u &amp; 0x40000000u)</a>
<a name="ln116">      is_horizontal = 1;</a>
<a name="ln117">    else</a>
<a name="ln118">      is_horizontal = 0;</a>
<a name="ln119">    k.u &amp;= ~0x40000000;</a>
<a name="ln120">    if(is_horizontal)</a>
<a name="ln121">    {</a>
<a name="ln122">      n-&gt;k_h = k.f;</a>
<a name="ln123">      n-&gt;k_v = 0.0f;</a>
<a name="ln124">    }</a>
<a name="ln125">    else</a>
<a name="ln126">    {</a>
<a name="ln127">      n-&gt;k_h = 0.0f;</a>
<a name="ln128">      n-&gt;k_v = k.f;</a>
<a name="ln129">    }</a>
<a name="ln130"> </a>
<a name="ln131">    n-&gt;angle = o-&gt;angle, n-&gt;cx = o-&gt;cx, n-&gt;cy = o-&gt;cy, n-&gt;cw = o-&gt;cw, n-&gt;ch = o-&gt;ch;</a>
<a name="ln132">    n-&gt;kxa = n-&gt;kxd = 0.2f;</a>
<a name="ln133">    n-&gt;kxc = n-&gt;kxb = 0.8f;</a>
<a name="ln134">    n-&gt;kya = n-&gt;kyb = 0.2f;</a>
<a name="ln135">    n-&gt;kyc = n-&gt;kyd = 0.8f;</a>
<a name="ln136">    if(n-&gt;k_h == 0 &amp;&amp; n-&gt;k_v == 0)</a>
<a name="ln137">      n-&gt;k_type = 0;</a>
<a name="ln138">    else</a>
<a name="ln139">      n-&gt;k_type = 4;</a>
<a name="ln140">    n-&gt;k_sym = 0;</a>
<a name="ln141">    n-&gt;k_apply = 0;</a>
<a name="ln142">    n-&gt;crop_auto = 1;</a>
<a name="ln143"> </a>
<a name="ln144">    // will be computed later, -2 here is used to detect uninitialized value, -1 is already used for no</a>
<a name="ln145">    // clipping.</a>
<a name="ln146">    n-&gt;ratio_d = n-&gt;ratio_n = -2;</a>
<a name="ln147">  }</a>
<a name="ln148">  if(old_version == 3 &amp;&amp; new_version == 5)</a>
<a name="ln149">  {</a>
<a name="ln150">    // old structure def</a>
<a name="ln151">    typedef struct old_params_t</a>
<a name="ln152">    {</a>
<a name="ln153">      float angle, cx, cy, cw, ch, k_h, k_v;</a>
<a name="ln154">    } old_params_t;</a>
<a name="ln155"> </a>
<a name="ln156">    old_params_t *o = (old_params_t *)old_params;</a>
<a name="ln157"> </a>
<a name="ln158">    n-&gt;angle = o-&gt;angle, n-&gt;cx = o-&gt;cx, n-&gt;cy = o-&gt;cy, n-&gt;cw = o-&gt;cw, n-&gt;ch = o-&gt;ch;</a>
<a name="ln159">    n-&gt;k_h = o-&gt;k_h, n-&gt;k_v = o-&gt;k_v;</a>
<a name="ln160">    n-&gt;kxa = n-&gt;kxd = 0.2f;</a>
<a name="ln161">    n-&gt;kxc = n-&gt;kxb = 0.8f;</a>
<a name="ln162">    n-&gt;kya = n-&gt;kyb = 0.2f;</a>
<a name="ln163">    n-&gt;kyc = n-&gt;kyd = 0.8f;</a>
<a name="ln164">    if(n-&gt;k_h == 0 &amp;&amp; n-&gt;k_v == 0)</a>
<a name="ln165">      n-&gt;k_type = 0;</a>
<a name="ln166">    else</a>
<a name="ln167">      n-&gt;k_type = 4;</a>
<a name="ln168">    n-&gt;k_sym = 0;</a>
<a name="ln169">    n-&gt;k_apply = 0;</a>
<a name="ln170">    n-&gt;crop_auto = 1;</a>
<a name="ln171"> </a>
<a name="ln172">    // will be computed later, -2 here is used to detect uninitialized value, -1 is already used for no</a>
<a name="ln173">    // clipping.</a>
<a name="ln174">    n-&gt;ratio_d = n-&gt;ratio_n = -2;</a>
<a name="ln175">  }</a>
<a name="ln176">  if(old_version == 4 &amp;&amp; new_version == 5)</a>
<a name="ln177">  {</a>
<a name="ln178">    typedef struct old_params_t</a>
<a name="ln179">    {</a>
<a name="ln180">      float angle, cx, cy, cw, ch, k_h, k_v;</a>
<a name="ln181">      float kxa, kya, kxb, kyb, kxc, kyc, kxd, kyd;</a>
<a name="ln182">      int k_type, k_sym;</a>
<a name="ln183">      int k_apply, crop_auto;</a>
<a name="ln184">    } old_params_t;</a>
<a name="ln185"> </a>
<a name="ln186">    old_params_t *o = (old_params_t *)old_params;</a>
<a name="ln187"> </a>
<a name="ln188">    n-&gt;angle = o-&gt;angle, n-&gt;cx = o-&gt;cx, n-&gt;cy = o-&gt;cy, n-&gt;cw = o-&gt;cw, n-&gt;ch = o-&gt;ch;</a>
<a name="ln189">    n-&gt;k_h = o-&gt;k_h, n-&gt;k_v = o-&gt;k_v;</a>
<a name="ln190">    n-&gt;kxa = o-&gt;kxa, n-&gt;kxb = o-&gt;kxb, n-&gt;kxc = o-&gt;kxc, n-&gt;kxd = o-&gt;kxd;</a>
<a name="ln191">    n-&gt;kya = o-&gt;kya, n-&gt;kyb = o-&gt;kyb, n-&gt;kyc = o-&gt;kyc, n-&gt;kyd = o-&gt;kyd;</a>
<a name="ln192">    n-&gt;k_type = o-&gt;k_type;</a>
<a name="ln193">    n-&gt;k_sym = o-&gt;k_sym;</a>
<a name="ln194">    n-&gt;k_apply = o-&gt;k_apply;</a>
<a name="ln195">    n-&gt;crop_auto = o-&gt;crop_auto;</a>
<a name="ln196"> </a>
<a name="ln197">    // will be computed later, -2 here is used to detect uninitialized value, -1 is already used for no</a>
<a name="ln198">    // clipping.</a>
<a name="ln199">    n-&gt;ratio_d = n-&gt;ratio_n = -2;</a>
<a name="ln200">  }</a>
<a name="ln201"> </a>
<a name="ln202">  return 0;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">typedef struct dt_iop_clipping_gui_data_t</a>
<a name="ln206">{</a>
<a name="ln207">  GtkWidget *angle;</a>
<a name="ln208">  GtkWidget *hvflip;</a>
<a name="ln209"> </a>
<a name="ln210">  GList *aspect_list;</a>
<a name="ln211">  GtkWidget *aspect_presets;</a>
<a name="ln212"> </a>
<a name="ln213">  GtkWidget *guide_lines;</a>
<a name="ln214">  GtkWidget *flip_guides;</a>
<a name="ln215">  GtkWidget *guides_widgets;</a>
<a name="ln216">  GList *guides_widgets_list;</a>
<a name="ln217"> </a>
<a name="ln218">  GtkWidget *keystone_type;</a>
<a name="ln219">  GtkWidget *crop_auto;</a>
<a name="ln220"> </a>
<a name="ln221">  float button_down_x, button_down_y;</a>
<a name="ln222">  float button_down_zoom_x, button_down_zoom_y,</a>
<a name="ln223">      button_down_angle; // position in image where the button has been pressed.</a>
<a name="ln224">  /* current clip box */</a>
<a name="ln225">  float clip_x, clip_y, clip_w, clip_h, handle_x, handle_y;</a>
<a name="ln226">  /* last box before change */</a>
<a name="ln227">  float prev_clip_x, prev_clip_y, prev_clip_w, prev_clip_h;</a>
<a name="ln228">  /* maximum clip box */</a>
<a name="ln229">  float clip_max_x, clip_max_y, clip_max_w, clip_max_h;</a>
<a name="ln230">  uint64_t clip_max_pipe_hash;</a>
<a name="ln231"> </a>
<a name="ln232">  int k_selected, k_show, k_selected_segment;</a>
<a name="ln233">  gboolean k_drag;</a>
<a name="ln234"> </a>
<a name="ln235">  int cropping, straightening, applied, center_lock;</a>
<a name="ln236">  int old_width, old_height;</a>
<a name="ln237">} dt_iop_clipping_gui_data_t;</a>
<a name="ln238"> </a>
<a name="ln239">typedef struct dt_iop_clipping_data_t</a>
<a name="ln240">{</a>
<a name="ln241">  float angle;              // rotation angle</a>
<a name="ln242">  float aspect;             // forced aspect ratio</a>
<a name="ln243">  float m[4];               // rot matrix</a>
<a name="ln244">  float ki_h, k_h;          // keystone correction, ki and corrected k</a>
<a name="ln245">  float ki_v, k_v;          // keystone correction, ki and corrected k</a>
<a name="ln246">  float tx, ty;             // rotation center</a>
<a name="ln247">  float cx, cy, cw, ch;     // crop window</a>
<a name="ln248">  float cix, ciy;           // crop window on roi_out 1.0 scale</a>
<a name="ln249">  uint32_t all_off;         // 1: v and h off, else one of them is used</a>
<a name="ln250">  uint32_t flags;           // flipping flags</a>
<a name="ln251">  uint32_t flip;            // flipped output buffer so more area would fit.</a>
<a name="ln252"> </a>
<a name="ln253">  float k_space[4]; // space for the &quot;destination&quot; rectangle of the keystone quadrilatere</a>
<a name="ln254">  float kxa, kya, kxb, kyb, kxc, kyc, kxd,</a>
<a name="ln255">      kyd; // point of the &quot;source&quot; quadrilatere (modified if keystone is not &quot;full&quot;)</a>
<a name="ln256">  float a, b, d, e, g, h; // value of the transformation matrix (c=f=0 &amp;&amp; i=1)</a>
<a name="ln257">  int k_apply;</a>
<a name="ln258">  int crop_auto;</a>
<a name="ln259">  float enlarge_x, enlarge_y;</a>
<a name="ln260">} dt_iop_clipping_data_t;</a>
<a name="ln261"> </a>
<a name="ln262">typedef struct dt_iop_clipping_global_data_t</a>
<a name="ln263">{</a>
<a name="ln264">  int kernel_clip_rotate_bilinear;</a>
<a name="ln265">  int kernel_clip_rotate_bicubic;</a>
<a name="ln266">  int kernel_clip_rotate_lanczos2;</a>
<a name="ln267">  int kernel_clip_rotate_lanczos3;</a>
<a name="ln268">} dt_iop_clipping_global_data_t;</a>
<a name="ln269"> </a>
<a name="ln270">static void commit_box(dt_iop_module_t *self, dt_iop_clipping_gui_data_t *g, dt_iop_clipping_params_t *p);</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">static inline void mul_mat_vec_2(const float *m, const float *p, float *o)</a>
<a name="ln274">{</a>
<a name="ln275">  o[0] = p[0] * m[0] + p[1] * m[1];</a>
<a name="ln276">  o[1] = p[0] * m[2] + p[1] * m[3];</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">// helper to count corners in for loops:</a>
<a name="ln280">static inline void get_corner(const float *aabb, const int i, float *p)</a>
<a name="ln281">{</a>
<a name="ln282">  for(int k = 0; k &lt; 2; k++) p[k] = aabb[2 * ((i &gt;&gt; k) &amp; 1) + k];</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">static inline void adjust_aabb(const float *p, float *aabb)</a>
<a name="ln286">{</a>
<a name="ln287">  aabb[0] = fminf(aabb[0], p[0]);</a>
<a name="ln288">  aabb[1] = fminf(aabb[1], p[1]);</a>
<a name="ln289">  aabb[2] = fmaxf(aabb[2], p[0]);</a>
<a name="ln290">  aabb[3] = fmaxf(aabb[3], p[1]);</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">const char *name()</a>
<a name="ln295">{</a>
<a name="ln296">  return _(&quot;crop and rotate&quot;);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">int default_group()</a>
<a name="ln300">{</a>
<a name="ln301">  return IOP_GROUP_BASIC;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">int flags()</a>
<a name="ln305">{</a>
<a name="ln306">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_TILING_FULL_ROI | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">int operation_tags()</a>
<a name="ln310">{</a>
<a name="ln311">  return IOP_TAG_DISTORT | IOP_TAG_CLIPPING;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">int operation_tags_filter()</a>
<a name="ln315">{</a>
<a name="ln316">  // switch off watermark, it gets confused.</a>
<a name="ln317">  return IOP_TAG_DECORATION;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln321">{</a>
<a name="ln322">  return iop_cs_rgb;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">static int gui_has_focus(struct dt_iop_module_t *self)</a>
<a name="ln327">{</a>
<a name="ln328">  return self-&gt;dev-&gt;gui_module == self;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">static void keystone_get_matrix(float *k_space, float kxa, float kxb, float kxc, float kxd, float kya,</a>
<a name="ln332">                                float kyb, float kyc, float kyd, float *a, float *b, float *d, float *e,</a>
<a name="ln333">                                float *g, float *h)</a>
<a name="ln334">{</a>
<a name="ln335">  *a = -((kxb * (kyd * kyd - kyc * kyd) - kxc * kyd * kyd + kyb * (kxc * kyd - kxd * kyd) + kxd * kyc * kyd)</a>
<a name="ln336">         * k_space[2])</a>
<a name="ln337">       / (kxb * (kxc * kyd * kyd - kxd * kyc * kyd) + kyb * (kxd * kxd * kyc - kxc * kxd * kyd));</a>
<a name="ln338">  *b = ((kxb * (kxd * kyd - kxd * kyc) - kxc * kxd * kyd + kxd * kxd * kyc + (kxc * kxd - kxd * kxd) * kyb)</a>
<a name="ln339">        * k_space[2])</a>
<a name="ln340">       / (kxb * (kxc * kyd * kyd - kxd * kyc * kyd) + kyb * (kxd * kxd * kyc - kxc * kxd * kyd));</a>
<a name="ln341">  *d = (kyb * (kxb * (kyd * k_space[3] - kyc * k_space[3]) - kxc * kyd * k_space[3] + kxd * kyc * k_space[3])</a>
<a name="ln342">        + kyb * kyb * (kxc * k_space[3] - kxd * k_space[3]))</a>
<a name="ln343">       / (kxb * kyb * (-kxc * kyd - kxd * kyc) + kxb * kxb * kyc * kyd + kxc * kxd * kyb * kyb);</a>
<a name="ln344">  *e = -(kxb * (kxd * kyc * k_space[3] - kxc * kyd * k_space[3])</a>
<a name="ln345">         + kxb * kxb * (kyd * k_space[3] - kyc * k_space[3])</a>
<a name="ln346">         + kxb * kyb * (kxc * k_space[3] - kxd * k_space[3]))</a>
<a name="ln347">       / (kxb * kyb * (-kxc * kyd - kxd * kyc) + kxb * kxb * kyc * kyd + kxc * kxd * kyb * kyb);</a>
<a name="ln348">  *g = -(kyb * (kxb * (2.0f * kxc * kyd * kyd - 2.0f * kxc * kyc * kyd) - kxc * kxc * kyd * kyd</a>
<a name="ln349">                + 2.0f * kxc * kxd * kyc * kyd - kxd * kxd * kyc * kyc)</a>
<a name="ln350">         + kxb * kxb * (kyc * kyc * kyd - kyc * kyd * kyd)</a>
<a name="ln351">         + kyb * kyb * (-2.0f * kxc * kxd * kyd + kxc * kxc * kyd + kxd * kxd * kyc))</a>
<a name="ln352">       / (kxb * kxb * (kxd * kyc * kyc * kyd - kxc * kyc * kyd * kyd)</a>
<a name="ln353">          + kxb * kyb * (kxc * kxc * kyd * kyd - kxd * kxd * kyc * kyc)</a>
<a name="ln354">          + kyb * kyb * (kxc * kxd * kxd * kyc - kxc * kxc * kxd * kyd));</a>
<a name="ln355">  *h = (kxb * (-kxc * kxc * kyd * kyd + 2.0f * kxc * kxd * kyc * kyd - kxd * kxd * kyc * kyc)</a>
<a name="ln356">        + kxb * kxb * (kxc * kyd * kyd - 2.0f * kxd * kyc * kyd + kxd * kyc * kyc)</a>
<a name="ln357">        + kxb * (2.0f * kxd * kxd - 2.0f * kxc * kxd) * kyb * kyc</a>
<a name="ln358">        + (kxc * kxc * kxd - kxc * kxd * kxd) * kyb * kyb)</a>
<a name="ln359">       / (kxb * kxb * (kxd * kyc * kyc * kyd - kxc * kyc * kyd * kyd)</a>
<a name="ln360">          + kxb * kyb * (kxc * kxc * kyd * kyd - kxd * kxd * kyc * kyc)</a>
<a name="ln361">          + kyb * kyb * (kxc * kxd * kxd * kyc - kxc * kxc * kxd * kyd));</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">static inline void keystone_backtransform(float *i, float *k_space, float a, float b, float d, float e, float g,</a>
<a name="ln365">                                          float h, float kxa, float kya)</a>
<a name="ln366">{</a>
<a name="ln367">  const float xx = i[0] - k_space[0];</a>
<a name="ln368">  const float yy = i[1] - k_space[1];</a>
<a name="ln369"> </a>
<a name="ln370">  const float div = ((d * xx - a * yy) * h + (b * yy - e * xx) * g + a * e - b * d);</a>
<a name="ln371"> </a>
<a name="ln372">  i[0] = (e * xx - b * yy) / div + kxa;</a>
<a name="ln373">  i[1] = -(d * xx - a * yy) / div + kya;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">static inline void keystone_transform(float *i, float *k_space, float a, float b, float d, float e, float g, float h,</a>
<a name="ln377">                                      float kxa, float kya)</a>
<a name="ln378">{</a>
<a name="ln379">  const float xx = i[0] - kxa;</a>
<a name="ln380">  const float yy = i[1] - kya;</a>
<a name="ln381"> </a>
<a name="ln382">  const float div = g * xx + h * yy + 1;</a>
<a name="ln383">  i[0] = (a * xx + b * yy) / div + k_space[0];</a>
<a name="ln384">  i[1] = (d * xx + e * yy) / div + k_space[1];</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">static inline void backtransform(float *x, float *o, const float *m, const float t_h, const float t_v)</a>
<a name="ln388">{</a>
<a name="ln389">  x[1] /= (1.0f + x[0] * t_h);</a>
<a name="ln390">  x[0] /= (1.0f + x[1] * t_v);</a>
<a name="ln391">  mul_mat_vec_2(m, x, o);</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">static inline void transform(float *x, float *o, const float *m, const float t_h, const float t_v)</a>
<a name="ln395">{</a>
<a name="ln396">  const float rt[] = { m[0], -m[1], -m[2], m[3] };</a>
<a name="ln397">  mul_mat_vec_2(rt, x, o);</a>
<a name="ln398">  o[1] *= 1.0f + o[0] * t_h;</a>
<a name="ln399">  o[0] *= 1.0f + o[1] * t_v;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402"> </a>
<a name="ln403">int distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln404">{</a>
<a name="ln405">  // as dt_iop_roi_t contain int values and not floats, we can have some rounding errors</a>
<a name="ln406">  // as a workaround, we use a factor for preview pipes</a>
<a name="ln407">  float factor = 1.0f;</a>
<a name="ln408">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW) factor = 100.0f;</a>
<a name="ln409">  // we first need to be sure that all data values are computed</a>
<a name="ln410">  // this is done in modify_roi_out fct, so we create tmp roi</a>
<a name="ln411">  dt_iop_roi_t roi_out, roi_in;</a>
<a name="ln412">  roi_in.width = piece-&gt;buf_in.width * factor;</a>
<a name="ln413">  roi_in.height = piece-&gt;buf_in.height * factor;</a>
<a name="ln414">  self-&gt;modify_roi_out(self, piece, &amp;roi_out, &amp;roi_in);</a>
<a name="ln415"> </a>
<a name="ln416">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln417"> </a>
<a name="ln418">  const float rx = piece-&gt;buf_in.width;</a>
<a name="ln419">  const float ry = piece-&gt;buf_in.height;</a>
<a name="ln420">  float k_space[4] = { d-&gt;k_space[0] * rx, d-&gt;k_space[1] * ry, d-&gt;k_space[2] * rx, d-&gt;k_space[3] * ry };</a>
<a name="ln421">  const float kxa = d-&gt;kxa * rx, kxb = d-&gt;kxb * rx, kxc = d-&gt;kxc * rx, kxd = d-&gt;kxd * rx;</a>
<a name="ln422">  const float kya = d-&gt;kya * ry, kyb = d-&gt;kyb * ry, kyc = d-&gt;kyc * ry, kyd = d-&gt;kyd * ry;</a>
<a name="ln423">  float ma, mb, md, me, mg, mh;</a>
<a name="ln424">  keystone_get_matrix(k_space, kxa, kxb, kxc, kxd, kya, kyb, kyc, kyd, &amp;ma, &amp;mb, &amp;md, &amp;me, &amp;mg, &amp;mh);</a>
<a name="ln425"> </a>
<a name="ln426">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln427">  {</a>
<a name="ln428">    float pi[2], po[2];</a>
<a name="ln429">    pi[0] = points[i];</a>
<a name="ln430">    pi[1] = points[i + 1];</a>
<a name="ln431"> </a>
<a name="ln432">    if(d-&gt;k_apply == 1) keystone_transform(pi, k_space, ma, mb, md, me, mg, mh, kxa, kya);</a>
<a name="ln433"> </a>
<a name="ln434">    pi[0] -= d-&gt;tx / factor;</a>
<a name="ln435">    pi[1] -= d-&gt;ty / factor;</a>
<a name="ln436">    // transform this point using matrix m</a>
<a name="ln437">    transform(pi, po, d-&gt;m, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln438"> </a>
<a name="ln439">    if(d-&gt;flip)</a>
<a name="ln440">    {</a>
<a name="ln441">      po[1] += d-&gt;tx / factor;</a>
<a name="ln442">      po[0] += d-&gt;ty / factor;</a>
<a name="ln443">    }</a>
<a name="ln444">    else</a>
<a name="ln445">    {</a>
<a name="ln446">      po[0] += d-&gt;tx / factor;</a>
<a name="ln447">      po[1] += d-&gt;ty / factor;</a>
<a name="ln448">    }</a>
<a name="ln449"> </a>
<a name="ln450">    points[i] = po[0] - (d-&gt;cix - d-&gt;enlarge_x) / factor;</a>
<a name="ln451">    points[i + 1] = po[1] - (d-&gt;ciy - d-&gt;enlarge_y) / factor;</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  // revert side-effects of the previous call to modify_roi_out</a>
<a name="ln455">  // TODO: this is just a quick hack. we need a major revamp of this module!</a>
<a name="ln456">  if(factor != 1.0f)</a>
<a name="ln457">  {</a>
<a name="ln458">    roi_in.width = piece-&gt;buf_in.width;</a>
<a name="ln459">    roi_in.height = piece-&gt;buf_in.height;</a>
<a name="ln460">    self-&gt;modify_roi_out(self, piece, &amp;roi_out, &amp;roi_in);</a>
<a name="ln461">  }</a>
<a name="ln462"> </a>
<a name="ln463">  return 1;</a>
<a name="ln464">}</a>
<a name="ln465">int distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points,</a>
<a name="ln466">                          size_t points_count)</a>
<a name="ln467">{</a>
<a name="ln468">  // as dt_iop_roi_t contain int values and not floats, we can have some rounding errors</a>
<a name="ln469">  // as a workaround, we use a factor for preview pipes</a>
<a name="ln470">  float factor = 1.0f;</a>
<a name="ln471">  if(piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW) factor = 100.0f;</a>
<a name="ln472">  // we first need to be sure that all data values are computed</a>
<a name="ln473">  // this is done in modify_roi_out fct, so we create tmp roi</a>
<a name="ln474">  dt_iop_roi_t roi_out, roi_in;</a>
<a name="ln475">  roi_in.width = piece-&gt;buf_in.width * factor;</a>
<a name="ln476">  roi_in.height = piece-&gt;buf_in.height * factor;</a>
<a name="ln477">  self-&gt;modify_roi_out(self, piece, &amp;roi_out, &amp;roi_in);</a>
<a name="ln478"> </a>
<a name="ln479">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln480"> </a>
<a name="ln481">  const float rx = piece-&gt;buf_in.width;</a>
<a name="ln482">  const float ry = piece-&gt;buf_in.height;</a>
<a name="ln483"> </a>
<a name="ln484">  float k_space[4] = { d-&gt;k_space[0] * rx, d-&gt;k_space[1] * ry, d-&gt;k_space[2] * rx, d-&gt;k_space[3] * ry };</a>
<a name="ln485">  const float kxa = d-&gt;kxa * rx, kxb = d-&gt;kxb * rx, kxc = d-&gt;kxc * rx, kxd = d-&gt;kxd * rx;</a>
<a name="ln486">  const float kya = d-&gt;kya * ry, kyb = d-&gt;kyb * ry, kyc = d-&gt;kyc * ry, kyd = d-&gt;kyd * ry;</a>
<a name="ln487">  float ma, mb, md, me, mg, mh;</a>
<a name="ln488">  keystone_get_matrix(k_space, kxa, kxb, kxc, kxd, kya, kyb, kyc, kyd, &amp;ma, &amp;mb, &amp;md, &amp;me, &amp;mg, &amp;mh);</a>
<a name="ln489"> </a>
<a name="ln490">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln491">  {</a>
<a name="ln492">    float pi[2], po[2];</a>
<a name="ln493">    pi[0] = -(d-&gt;enlarge_x - d-&gt;cix) / factor + points[i];</a>
<a name="ln494">    pi[1] = -(d-&gt;enlarge_y - d-&gt;ciy) / factor + points[i + 1];</a>
<a name="ln495"> </a>
<a name="ln496">    // transform this point using matrix m</a>
<a name="ln497">    if(d-&gt;flip)</a>
<a name="ln498">    {</a>
<a name="ln499">      pi[1] -= d-&gt;tx / factor;</a>
<a name="ln500">      pi[0] -= d-&gt;ty / factor;</a>
<a name="ln501">    }</a>
<a name="ln502">    else</a>
<a name="ln503">    {</a>
<a name="ln504">      pi[0] -= d-&gt;tx / factor;</a>
<a name="ln505">      pi[1] -= d-&gt;ty / factor;</a>
<a name="ln506">    }</a>
<a name="ln507"> </a>
<a name="ln508">    backtransform(pi, po, d-&gt;m, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln509">    po[0] += d-&gt;tx / factor;</a>
<a name="ln510">    po[1] += d-&gt;ty / factor;</a>
<a name="ln511">    if(d-&gt;k_apply == 1) keystone_backtransform(po, k_space, ma, mb, md, me, mg, mh, kxa, kya);</a>
<a name="ln512"> </a>
<a name="ln513">    points[i] = po[0];</a>
<a name="ln514">    points[i + 1] = po[1];</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  // revert side-effects of the previous call to modify_roi_out</a>
<a name="ln518">  // TODO: this is just a quick hack. we need a major revamp of this module!</a>
<a name="ln519">  if(factor != 1.0f)</a>
<a name="ln520">  {</a>
<a name="ln521">    roi_in.width = piece-&gt;buf_in.width;</a>
<a name="ln522">    roi_in.height = piece-&gt;buf_in.height;</a>
<a name="ln523">    self-&gt;modify_roi_out(self, piece, &amp;roi_out, &amp;roi_in);</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  return 1;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln530">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln531">{</a>
<a name="ln532">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln533"> </a>
<a name="ln534">  // only crop, no rot fast and sharp path:</a>
<a name="ln535">  if(!d-&gt;flags &amp;&amp; d-&gt;angle == 0.0 &amp;&amp; d-&gt;all_off &amp;&amp; roi_in-&gt;width == roi_out-&gt;width &amp;&amp; roi_in-&gt;height == roi_out-&gt;height)</a>
<a name="ln536">  {</a>
<a name="ln537">#ifdef _OPENMP</a>
<a name="ln538">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln539">#endif</a>
<a name="ln540">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln541">    {</a>
<a name="ln542">      const float *_in = in + (size_t)roi_out-&gt;width * j;</a>
<a name="ln543">      float *_out = out + (size_t)roi_out-&gt;width * j;</a>
<a name="ln544">      memcpy(_out, _in, sizeof(float) * roi_out-&gt;width);</a>
<a name="ln545">    }</a>
<a name="ln546">  }</a>
<a name="ln547">  else</a>
<a name="ln548">  {</a>
<a name="ln549">    const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln550">    const float rx = piece-&gt;buf_in.width * roi_in-&gt;scale;</a>
<a name="ln551">    const float ry = piece-&gt;buf_in.height * roi_in-&gt;scale;</a>
<a name="ln552">    float k_space[4] = { d-&gt;k_space[0] * rx, d-&gt;k_space[1] * ry, d-&gt;k_space[2] * rx, d-&gt;k_space[3] * ry };</a>
<a name="ln553">    const float kxa = d-&gt;kxa * rx, kxb = d-&gt;kxb * rx, kxc = d-&gt;kxc * rx, kxd = d-&gt;kxd * rx;</a>
<a name="ln554">    const float kya = d-&gt;kya * ry, kyb = d-&gt;kyb * ry, kyc = d-&gt;kyc * ry, kyd = d-&gt;kyd * ry;</a>
<a name="ln555">    float ma, mb, md, me, mg, mh;</a>
<a name="ln556">    keystone_get_matrix(k_space, kxa, kxb, kxc, kxd, kya, kyb, kyc, kyd, &amp;ma, &amp;mb, &amp;md, &amp;me, &amp;mg, &amp;mh);</a>
<a name="ln557"> </a>
<a name="ln558">#ifdef _OPENMP</a>
<a name="ln559">#pragma omp parallel for schedule(static) default(none) shared(d, interpolation, k_space, ma, mb, md, me, mg, mh)</a>
<a name="ln560">#endif</a>
<a name="ln561">    // (slow) point-by-point transformation.</a>
<a name="ln562">    // TODO: optimize with scanlines and linear steps between?</a>
<a name="ln563">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln564">    {</a>
<a name="ln565">      float *_out = out + (size_t)j * roi_out-&gt;width;</a>
<a name="ln566">      for(int i = 0; i &lt; roi_out-&gt;width; i++, _out++)</a>
<a name="ln567">      {</a>
<a name="ln568">        float pi[2], po[2];</a>
<a name="ln569"> </a>
<a name="ln570">        pi[0] = roi_out-&gt;x - roi_out-&gt;scale * d-&gt;enlarge_x + roi_out-&gt;scale * d-&gt;cix + i + 0.5f;</a>
<a name="ln571">        pi[1] = roi_out-&gt;y - roi_out-&gt;scale * d-&gt;enlarge_y + roi_out-&gt;scale * d-&gt;ciy + j + 0.5f;</a>
<a name="ln572"> </a>
<a name="ln573">        // transform this point using matrix m</a>
<a name="ln574">        if(d-&gt;flip)</a>
<a name="ln575">        {</a>
<a name="ln576">          pi[1] -= d-&gt;tx * roi_out-&gt;scale;</a>
<a name="ln577">          pi[0] -= d-&gt;ty * roi_out-&gt;scale;</a>
<a name="ln578">        }</a>
<a name="ln579">        else</a>
<a name="ln580">        {</a>
<a name="ln581">          pi[0] -= d-&gt;tx * roi_out-&gt;scale;</a>
<a name="ln582">          pi[1] -= d-&gt;ty * roi_out-&gt;scale;</a>
<a name="ln583">        }</a>
<a name="ln584">        pi[0] /= roi_out-&gt;scale;</a>
<a name="ln585">        pi[1] /= roi_out-&gt;scale;</a>
<a name="ln586">        backtransform(pi, po, d-&gt;m, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln587">        po[0] *= roi_in-&gt;scale;</a>
<a name="ln588">        po[1] *= roi_in-&gt;scale;</a>
<a name="ln589">        po[0] += d-&gt;tx * roi_in-&gt;scale;</a>
<a name="ln590">        po[1] += d-&gt;ty * roi_in-&gt;scale;</a>
<a name="ln591">        if(d-&gt;k_apply == 1) keystone_backtransform(po, k_space, ma, mb, md, me, mg, mh, kxa, kya);</a>
<a name="ln592">        po[0] -= roi_in-&gt;x + 0.5f;</a>
<a name="ln593">        po[1] -= roi_in-&gt;y + 0.5f;</a>
<a name="ln594"> </a>
<a name="ln595">        *_out = dt_interpolation_compute_sample(interpolation, in, po[0], po[1], roi_in-&gt;width, roi_in-&gt;height, 1,</a>
<a name="ln596">                                                roi_in-&gt;width);</a>
<a name="ln597">      }</a>
<a name="ln598">    }</a>
<a name="ln599">  }</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">static int _iop_clipping_set_max_clip(struct dt_iop_module_t *self)</a>
<a name="ln603">{</a>
<a name="ln604">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln605">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln606"> </a>
<a name="ln607">  if(g-&gt;clip_max_pipe_hash == self-&gt;dev-&gt;preview_pipe-&gt;backbuf_hash) return 1;</a>
<a name="ln608"> </a>
<a name="ln609">  // we want to know the size of the actual buffer</a>
<a name="ln610">  dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln611">  if(!piece) return 0;</a>
<a name="ln612"> </a>
<a name="ln613">  float wp = piece-&gt;buf_out.width, hp = piece-&gt;buf_out.height;</a>
<a name="ln614">  float points[8] = { 0.0, 0.0, wp, hp, p-&gt;cx * wp, p-&gt;cy * hp, fabsf(p-&gt;cw) * wp, fabsf(p-&gt;ch) * hp };</a>
<a name="ln615">  if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points, 4))</a>
<a name="ln616">    return 0;</a>
<a name="ln617"> </a>
<a name="ln618">  g-&gt;clip_max_x = points[0] / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln619">  g-&gt;clip_max_y = points[1] / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln620">  g-&gt;clip_max_w = (points[2] - points[0]) / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln621">  g-&gt;clip_max_h = (points[3] - points[1]) / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln622"> </a>
<a name="ln623">  // if clipping values are not null, this is undistorted values...</a>
<a name="ln624">  g-&gt;clip_x = points[4] / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln625">  g-&gt;clip_y = points[5] / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln626">  g-&gt;clip_w = (points[6] - points[4]) / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln627">  g-&gt;clip_h = (points[7] - points[5]) / self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln628">  g-&gt;clip_x = fmaxf(g-&gt;clip_x, g-&gt;clip_max_x);</a>
<a name="ln629">  g-&gt;clip_y = fmaxf(g-&gt;clip_y, g-&gt;clip_max_y);</a>
<a name="ln630">  g-&gt;clip_w = fminf(g-&gt;clip_w, g-&gt;clip_max_w);</a>
<a name="ln631">  g-&gt;clip_h = fminf(g-&gt;clip_h, g-&gt;clip_max_h);</a>
<a name="ln632">  g-&gt;clip_max_pipe_hash = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_hash;</a>
<a name="ln633">  return 1;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">// 1st pass: how large would the output be, given this input roi?</a>
<a name="ln637">// this is always called with the full buffer before processing.</a>
<a name="ln638">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln639">                    const dt_iop_roi_t *roi_in_orig)</a>
<a name="ln640">{</a>
<a name="ln641">  dt_iop_roi_t roi_in_d = *roi_in_orig;</a>
<a name="ln642">  dt_iop_roi_t *roi_in = &amp;roi_in_d;</a>
<a name="ln643"> </a>
<a name="ln644">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln645"> </a>
<a name="ln646">  // use whole-buffer roi information to create matrix and inverse.</a>
<a name="ln647">  float rt[] = { cosf(d-&gt;angle), sinf(d-&gt;angle), -sinf(d-&gt;angle), cosf(d-&gt;angle) };</a>
<a name="ln648">  if(d-&gt;angle == 0.0f)</a>
<a name="ln649">  {</a>
<a name="ln650">    rt[0] = rt[3] = 1.0;</a>
<a name="ln651">    rt[1] = rt[2] = 0.0f;</a>
<a name="ln652">  }</a>
<a name="ln653"> </a>
<a name="ln654">  for(int k = 0; k &lt; 4; k++) d-&gt;m[k] = rt[k];</a>
<a name="ln655">  if(d-&gt;flags &amp; FLAG_FLIP_HORIZONTAL)</a>
<a name="ln656">  {</a>
<a name="ln657">    d-&gt;m[0] = -rt[0];</a>
<a name="ln658">    d-&gt;m[2] = -rt[2];</a>
<a name="ln659">  }</a>
<a name="ln660">  if(d-&gt;flags &amp; FLAG_FLIP_VERTICAL)</a>
<a name="ln661">  {</a>
<a name="ln662">    d-&gt;m[1] = -rt[1];</a>
<a name="ln663">    d-&gt;m[3] = -rt[3];</a>
<a name="ln664">  }</a>
<a name="ln665"> </a>
<a name="ln666">  if(d-&gt;k_apply == 0 &amp;&amp; d-&gt;crop_auto == 1) // this is the old solution.</a>
<a name="ln667">  {</a>
<a name="ln668">    *roi_out = *roi_in;</a>
<a name="ln669"> </a>
<a name="ln670">    // correct keystone correction factors by resolution of this buffer</a>
<a name="ln671">    const float kc = 1.0f / fminf(roi_in-&gt;width, roi_in-&gt;height);</a>
<a name="ln672">    d-&gt;k_h = d-&gt;ki_h * kc;</a>
<a name="ln673">    d-&gt;k_v = d-&gt;ki_v * kc;</a>
<a name="ln674"> </a>
<a name="ln675">    float cropscale = -1.0f;</a>
<a name="ln676">    // check portrait/landscape orientation, whichever fits more area:</a>
<a name="ln677">    const float oaabb[4]</a>
<a name="ln678">        = { -.5f * roi_in-&gt;width, -.5f * roi_in-&gt;height, .5f * roi_in-&gt;width, .5f * roi_in-&gt;height };</a>
<a name="ln679">    for(int flip = 0; flip &lt; 2; flip++)</a>
<a name="ln680">    {</a>
<a name="ln681">      const float roi_in_width = flip ? roi_in-&gt;height : roi_in-&gt;width;</a>
<a name="ln682">      const float roi_in_height = flip ? roi_in-&gt;width : roi_in-&gt;height;</a>
<a name="ln683">      float newcropscale = 1.0f;</a>
<a name="ln684">      // fwd transform rotated points on corners and scale back inside roi_in bounds.</a>
<a name="ln685">      float p[2], o[2],</a>
<a name="ln686">          aabb[4] = { -.5f * roi_in_width, -.5f * roi_in_height, .5f * roi_in_width, .5f * roi_in_height };</a>
<a name="ln687">      for(int c = 0; c &lt; 4; c++)</a>
<a name="ln688">      {</a>
<a name="ln689">        get_corner(oaabb, c, p);</a>
<a name="ln690">        transform(p, o, rt, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln691">        for(int k = 0; k &lt; 2; k++)</a>
<a name="ln692">          if(fabsf(o[k]) &gt; 0.001f) newcropscale = fminf(newcropscale, aabb[(o[k] &gt; 0 ? 2 : 0) + k] / o[k]);</a>
<a name="ln693">      }</a>
<a name="ln694">      if(newcropscale &gt;= cropscale)</a>
<a name="ln695">      {</a>
<a name="ln696">        cropscale = newcropscale;</a>
<a name="ln697">        // remember rotation center in whole-buffer coordinates:</a>
<a name="ln698">        d-&gt;tx = roi_in-&gt;width * .5f;</a>
<a name="ln699">        d-&gt;ty = roi_in-&gt;height * .5f;</a>
<a name="ln700">        d-&gt;flip = flip;</a>
<a name="ln701"> </a>
<a name="ln702">        float ach = d-&gt;ch - d-&gt;cy, acw = d-&gt;cw - d-&gt;cx;</a>
<a name="ln703">        // rotate and clip to max extent</a>
<a name="ln704">        if(flip)</a>
<a name="ln705">        {</a>
<a name="ln706">          roi_out-&gt;y = d-&gt;tx - (.5f - d-&gt;cy) * cropscale * roi_in-&gt;width;</a>
<a name="ln707">          roi_out-&gt;x = d-&gt;ty - (.5f - d-&gt;cx) * cropscale * roi_in-&gt;height;</a>
<a name="ln708">          roi_out-&gt;height = ach * cropscale * roi_in-&gt;width;</a>
<a name="ln709">          roi_out-&gt;width = acw * cropscale * roi_in-&gt;height;</a>
<a name="ln710">        }</a>
<a name="ln711">        else</a>
<a name="ln712">        {</a>
<a name="ln713">          roi_out-&gt;x = d-&gt;tx - (.5f - d-&gt;cx) * cropscale * roi_in-&gt;width;</a>
<a name="ln714">          roi_out-&gt;y = d-&gt;ty - (.5f - d-&gt;cy) * cropscale * roi_in-&gt;height;</a>
<a name="ln715">          roi_out-&gt;width = acw * cropscale * roi_in-&gt;width;</a>
<a name="ln716">          roi_out-&gt;height = ach * cropscale * roi_in-&gt;height;</a>
<a name="ln717">        }</a>
<a name="ln718">      }</a>
<a name="ln719">    }</a>
<a name="ln720">  }</a>
<a name="ln721">  else</a>
<a name="ln722">  {</a>
<a name="ln723">    *roi_out = *roi_in;</a>
<a name="ln724">    // set roi_out values with rotation and keystone</a>
<a name="ln725">    // initial corners pos</a>
<a name="ln726">    float corn_x[4] = { 0.0f, roi_in-&gt;width, roi_in-&gt;width, 0.0f };</a>
<a name="ln727">    float corn_y[4] = { 0.0f, 0.0f, roi_in-&gt;height, roi_in-&gt;height };</a>
<a name="ln728">    // destination corner points</a>
<a name="ln729">    float corn_out_x[4] = { 0.0f };</a>
<a name="ln730">    float corn_out_y[4] = { 0.0f };</a>
<a name="ln731"> </a>
<a name="ln732">    // we don't test image flip as autocrop is not completely ok...</a>
<a name="ln733">    d-&gt;flip = 0;</a>
<a name="ln734"> </a>
<a name="ln735">    // we apply rotation and keystone to all those points</a>
<a name="ln736">    float p[2], o[2];</a>
<a name="ln737">    for(int c = 0; c &lt; 4; c++)</a>
<a name="ln738">    {</a>
<a name="ln739">      // keystone</a>
<a name="ln740">      o[0] = corn_x[c];</a>
<a name="ln741">      o[1] = corn_y[c];</a>
<a name="ln742">      if(d-&gt;k_apply == 1)</a>
<a name="ln743">      {</a>
<a name="ln744">        o[0] /= (float)roi_in-&gt;width;</a>
<a name="ln745">        o[1] /= (float)roi_in-&gt;height;</a>
<a name="ln746">        keystone_transform(o, d-&gt;k_space, d-&gt;a, d-&gt;b, d-&gt;d, d-&gt;e, d-&gt;g, d-&gt;h, d-&gt;kxa, d-&gt;kya);</a>
<a name="ln747">        o[0] *= roi_in-&gt;width;</a>
<a name="ln748">        o[1] *= roi_in-&gt;height;</a>
<a name="ln749">      }</a>
<a name="ln750">      // rotation</a>
<a name="ln751">      p[0] = o[0] - .5f * roi_in-&gt;width;</a>
<a name="ln752">      p[1] = o[1] - .5f * roi_in-&gt;height;</a>
<a name="ln753">      transform(p, o, d-&gt;m, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln754">      o[0] += .5f * roi_in-&gt;width;</a>
<a name="ln755">      o[1] += .5f * roi_in-&gt;height;</a>
<a name="ln756"> </a>
<a name="ln757">      // and we set the values</a>
<a name="ln758">      corn_out_x[c] = o[0];</a>
<a name="ln759">      corn_out_y[c] = o[1];</a>
<a name="ln760">    }</a>
<a name="ln761"> </a>
<a name="ln762">    float new_x = fminf(fminf(fminf(corn_out_x[0], corn_out_x[1]), corn_out_x[2]), corn_out_x[3]);</a>
<a name="ln763">    if(new_x + roi_in-&gt;width &lt; 0) new_x = -roi_in-&gt;width;</a>
<a name="ln764">    float new_y = fminf(fminf(fminf(corn_out_y[0], corn_out_y[1]), corn_out_y[2]), corn_out_y[3]);</a>
<a name="ln765">    if(new_y + roi_in-&gt;height &lt; 0) new_y = -roi_in-&gt;height;</a>
<a name="ln766"> </a>
<a name="ln767">    float new_sc_x = fmaxf(fmaxf(fmaxf(corn_out_x[0], corn_out_x[1]), corn_out_x[2]), corn_out_x[3]);</a>
<a name="ln768">    if(new_sc_x &gt; 2.0f * roi_in-&gt;width) new_sc_x = 2.0f * roi_in-&gt;width;</a>
<a name="ln769">    float new_sc_y = fmaxf(fmaxf(fmaxf(corn_out_y[0], corn_out_y[1]), corn_out_y[2]), corn_out_y[3]);</a>
<a name="ln770">    if(new_sc_y &gt; 2.0f * roi_in-&gt;height) new_sc_y = 2.0f * roi_in-&gt;height;</a>
<a name="ln771"> </a>
<a name="ln772">    // be careful, we don't want too small area here !</a>
<a name="ln773">    if(new_sc_x - new_x &lt; roi_in-&gt;width / 8.0f)</a>
<a name="ln774">    {</a>
<a name="ln775">      float f = (new_sc_x + new_x) / 2.0f;</a>
<a name="ln776">      if(f &lt; roi_in-&gt;width / 16.0f) f = roi_in-&gt;width / 16.0f;</a>
<a name="ln777">      if(f &gt;= roi_in-&gt;width * 15.0f / 16.0f) f = roi_in-&gt;width * 15.0f / 16.0f - 1.0f;</a>
<a name="ln778">      new_x = f - roi_in-&gt;width / 16.0f, new_sc_x = f + roi_in-&gt;width / 16.0f;</a>
<a name="ln779">    }</a>
<a name="ln780">    if(new_sc_y - new_y &lt; roi_in-&gt;height / 8.0f)</a>
<a name="ln781">    {</a>
<a name="ln782">      float f = (new_sc_y + new_y) / 2.0f;</a>
<a name="ln783">      if(f &lt; roi_in-&gt;height / 16.0f) f = roi_in-&gt;height / 16.0f;</a>
<a name="ln784">      if(f &gt;= roi_in-&gt;height * 15.0f / 16.0f) f = roi_in-&gt;height * 15.0f / 16.0f - 1.0f;</a>
<a name="ln785">      new_y = f - roi_in-&gt;height / 16.0f, new_sc_y = f + roi_in-&gt;height / 16.0f;</a>
<a name="ln786">    }</a>
<a name="ln787"> </a>
<a name="ln788">    new_sc_y = new_sc_y - new_y;</a>
<a name="ln789">    new_sc_x = new_sc_x - new_x;</a>
<a name="ln790"> </a>
<a name="ln791">    // now we apply the clipping</a>
<a name="ln792">    new_x += d-&gt;cx * new_sc_x;</a>
<a name="ln793">    new_y += d-&gt;cy * new_sc_y;</a>
<a name="ln794">    new_sc_x *= d-&gt;cw - d-&gt;cx;</a>
<a name="ln795">    new_sc_y *= d-&gt;ch - d-&gt;cy;</a>
<a name="ln796"> </a>
<a name="ln797">    d-&gt;enlarge_x = fmaxf(-new_x, 0.0f);</a>
<a name="ln798">    roi_out-&gt;x = fmaxf(new_x, 0.0f);</a>
<a name="ln799">    d-&gt;enlarge_y = fmaxf(-new_y, 0.0f);</a>
<a name="ln800">    roi_out-&gt;y = fmaxf(new_y, 0.0f);</a>
<a name="ln801"> </a>
<a name="ln802">    roi_out-&gt;width = new_sc_x;</a>
<a name="ln803">    roi_out-&gt;height = new_sc_y;</a>
<a name="ln804">    d-&gt;tx = roi_in-&gt;width * .5f;</a>
<a name="ln805">    d-&gt;ty = roi_in-&gt;height * .5f;</a>
<a name="ln806">  }</a>
<a name="ln807"> </a>
<a name="ln808">  // sanity check.</a>
<a name="ln809">  if(roi_out-&gt;x &lt; 0) roi_out-&gt;x = 0;</a>
<a name="ln810">  if(roi_out-&gt;y &lt; 0) roi_out-&gt;y = 0;</a>
<a name="ln811">  if(roi_out-&gt;width &lt; 1) roi_out-&gt;width = 1;</a>
<a name="ln812">  if(roi_out-&gt;height &lt; 1) roi_out-&gt;height = 1;</a>
<a name="ln813"> </a>
<a name="ln814">  // save rotation crop on output buffer in world scale:</a>
<a name="ln815">  d-&gt;cix = roi_out-&gt;x;</a>
<a name="ln816">  d-&gt;ciy = roi_out-&gt;y;</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">// 2nd pass: which roi would this operation need as input to fill the given output region?</a>
<a name="ln820">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln821">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln822">{</a>
<a name="ln823">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln824">  *roi_in = *roi_out;</a>
<a name="ln825">  // modify_roi_out took care of bounds checking for us. we hopefully do not get requests outside the clipping</a>
<a name="ln826">  // area.</a>
<a name="ln827">  // transform aabb back to roi_in</a>
<a name="ln828"> </a>
<a name="ln829">  // this aabb is set off by cx/cy</a>
<a name="ln830">  const float so = roi_out-&gt;scale;</a>
<a name="ln831">  const float kw = piece-&gt;buf_in.width * so, kh = piece-&gt;buf_in.height * so;</a>
<a name="ln832">  const float roi_out_x = roi_out-&gt;x - d-&gt;enlarge_x * so, roi_out_y = roi_out-&gt;y - d-&gt;enlarge_y * so;</a>
<a name="ln833">  float p[2], o[2],</a>
<a name="ln834">      aabb[4] = { roi_out_x + d-&gt;cix * so, roi_out_y + d-&gt;ciy * so, roi_out_x + d-&gt;cix * so + roi_out-&gt;width,</a>
<a name="ln835">                  roi_out_y + d-&gt;ciy * so + roi_out-&gt;height };</a>
<a name="ln836">  float aabb_in[4] = { INFINITY, INFINITY, -INFINITY, -INFINITY };</a>
<a name="ln837">  for(int c = 0; c &lt; 4; c++)</a>
<a name="ln838">  {</a>
<a name="ln839">    // get corner points of roi_out</a>
<a name="ln840">    get_corner(aabb, c, p);</a>
<a name="ln841"> </a>
<a name="ln842">    // backtransform aabb using m</a>
<a name="ln843">    if(d-&gt;flip)</a>
<a name="ln844">    {</a>
<a name="ln845">      p[1] -= d-&gt;tx * so;</a>
<a name="ln846">      p[0] -= d-&gt;ty * so;</a>
<a name="ln847">    }</a>
<a name="ln848">    else</a>
<a name="ln849">    {</a>
<a name="ln850">      p[0] -= d-&gt;tx * so;</a>
<a name="ln851">      p[1] -= d-&gt;ty * so;</a>
<a name="ln852">    }</a>
<a name="ln853">    p[0] *= 1.0 / so;</a>
<a name="ln854">    p[1] *= 1.0 / so;</a>
<a name="ln855">    backtransform(p, o, d-&gt;m, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln856">    o[0] *= so;</a>
<a name="ln857">    o[1] *= so;</a>
<a name="ln858">    o[0] += d-&gt;tx * so;</a>
<a name="ln859">    o[1] += d-&gt;ty * so;</a>
<a name="ln860">    o[0] /= kw;</a>
<a name="ln861">    o[1] /= kh;</a>
<a name="ln862">    if(d-&gt;k_apply == 1)</a>
<a name="ln863">      keystone_backtransform(o, d-&gt;k_space, d-&gt;a, d-&gt;b, d-&gt;d, d-&gt;e, d-&gt;g, d-&gt;h, d-&gt;kxa, d-&gt;kya);</a>
<a name="ln864">    o[0] *= kw;</a>
<a name="ln865">    o[1] *= kh;</a>
<a name="ln866">    // transform to roi_in space, get aabb.</a>
<a name="ln867">    adjust_aabb(o, aabb_in);</a>
<a name="ln868">  }</a>
<a name="ln869"> </a>
<a name="ln870">  // adjust roi_in to minimally needed region</a>
<a name="ln871">  roi_in-&gt;x = aabb_in[0] - 1;</a>
<a name="ln872">  roi_in-&gt;y = aabb_in[1] - 1;</a>
<a name="ln873">  roi_in-&gt;width = aabb_in[2] - aabb_in[0] + 2;</a>
<a name="ln874">  roi_in-&gt;height = aabb_in[3] - aabb_in[1] + 2;</a>
<a name="ln875"> </a>
<a name="ln876">  if(d-&gt;angle == 0.0f &amp;&amp; d-&gt;all_off)</a>
<a name="ln877">  {</a>
<a name="ln878">    // just crop: make sure everything is precise.</a>
<a name="ln879">    roi_in-&gt;x = aabb_in[0];</a>
<a name="ln880">    roi_in-&gt;y = aabb_in[1];</a>
<a name="ln881">    roi_in-&gt;width = roi_out-&gt;width;</a>
<a name="ln882">    roi_in-&gt;height = roi_out-&gt;height;</a>
<a name="ln883">  }</a>
<a name="ln884"> </a>
<a name="ln885">  // sanity check.</a>
<a name="ln886">  const float scwidth = piece-&gt;buf_in.width * so, scheight = piece-&gt;buf_in.height * so;</a>
<a name="ln887">  roi_in-&gt;x = CLAMP(roi_in-&gt;x, 0, (int)floorf(scwidth));</a>
<a name="ln888">  roi_in-&gt;y = CLAMP(roi_in-&gt;y, 0, (int)floorf(scheight));</a>
<a name="ln889">  roi_in-&gt;width = CLAMP(roi_in-&gt;width, 1, (int)ceilf(scwidth) - roi_in-&gt;x);</a>
<a name="ln890">  roi_in-&gt;height = CLAMP(roi_in-&gt;height, 1, (int)ceilf(scheight) - roi_in-&gt;y);</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">// 3rd (final) pass: you get this input region (may be different from what was requested above),</a>
<a name="ln894">// do your best to fill the output region!</a>
<a name="ln895">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln896">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln897">{</a>
<a name="ln898">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln899"> </a>
<a name="ln900">  const int ch = piece-&gt;colors;</a>
<a name="ln901">  const int ch_width = ch * roi_in-&gt;width;</a>
<a name="ln902"> </a>
<a name="ln903">  assert(ch == 4);</a>
<a name="ln904"> </a>
<a name="ln905">  // only crop, no rot fast and sharp path:</a>
<a name="ln906">  if(!d-&gt;flags &amp;&amp; d-&gt;angle == 0.0 &amp;&amp; d-&gt;all_off &amp;&amp; roi_in-&gt;width == roi_out-&gt;width</a>
<a name="ln907">     &amp;&amp; roi_in-&gt;height == roi_out-&gt;height)</a>
<a name="ln908">  {</a>
<a name="ln909">#ifdef _OPENMP</a>
<a name="ln910">#pragma omp parallel for schedule(static) default(none) shared(d)</a>
<a name="ln911">#endif</a>
<a name="ln912">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln913">    {</a>
<a name="ln914">      const float *in = ((float *)ivoid) + (size_t)ch * roi_out-&gt;width * j;</a>
<a name="ln915">      float *out = ((float *)ovoid) + (size_t)ch * roi_out-&gt;width * j;</a>
<a name="ln916">      for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln917">      {</a>
<a name="ln918">        for(int c = 0; c &lt; 4; c++) out[c] = in[c];</a>
<a name="ln919">        out += ch;</a>
<a name="ln920">        in += ch;</a>
<a name="ln921">      }</a>
<a name="ln922">    }</a>
<a name="ln923">  }</a>
<a name="ln924">  else</a>
<a name="ln925">  {</a>
<a name="ln926">    const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln927">    const float rx = piece-&gt;buf_in.width * roi_in-&gt;scale;</a>
<a name="ln928">    const float ry = piece-&gt;buf_in.height * roi_in-&gt;scale;</a>
<a name="ln929">    float k_space[4] = { d-&gt;k_space[0] * rx, d-&gt;k_space[1] * ry, d-&gt;k_space[2] * rx, d-&gt;k_space[3] * ry };</a>
<a name="ln930">    const float kxa = d-&gt;kxa * rx, kxb = d-&gt;kxb * rx, kxc = d-&gt;kxc * rx, kxd = d-&gt;kxd * rx;</a>
<a name="ln931">    const float kya = d-&gt;kya * ry, kyb = d-&gt;kyb * ry, kyc = d-&gt;kyc * ry, kyd = d-&gt;kyd * ry;</a>
<a name="ln932">    float ma, mb, md, me, mg, mh;</a>
<a name="ln933">    keystone_get_matrix(k_space, kxa, kxb, kxc, kxd, kya, kyb, kyc, kyd, &amp;ma, &amp;mb, &amp;md, &amp;me, &amp;mg, &amp;mh);</a>
<a name="ln934"> </a>
<a name="ln935">#ifdef _OPENMP</a>
<a name="ln936">#pragma omp parallel for schedule(static) default(none) shared(d, interpolation, k_space, ma, mb, md, me, mg, mh)</a>
<a name="ln937">#endif</a>
<a name="ln938">    // (slow) point-by-point transformation.</a>
<a name="ln939">    // TODO: optimize with scanlines and linear steps between?</a>
<a name="ln940">    for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln941">    {</a>
<a name="ln942">      float *out = ((float *)ovoid) + (size_t)ch * j * roi_out-&gt;width;</a>
<a name="ln943">      for(int i = 0; i &lt; roi_out-&gt;width; i++, out += ch)</a>
<a name="ln944">      {</a>
<a name="ln945">        float pi[2], po[2];</a>
<a name="ln946"> </a>
<a name="ln947">        pi[0] = roi_out-&gt;x - roi_out-&gt;scale * d-&gt;enlarge_x + roi_out-&gt;scale * d-&gt;cix + i + 0.5f;</a>
<a name="ln948">        pi[1] = roi_out-&gt;y - roi_out-&gt;scale * d-&gt;enlarge_y + roi_out-&gt;scale * d-&gt;ciy + j + 0.5f;</a>
<a name="ln949"> </a>
<a name="ln950">        // transform this point using matrix m</a>
<a name="ln951">        if(d-&gt;flip)</a>
<a name="ln952">        {</a>
<a name="ln953">          pi[1] -= d-&gt;tx * roi_out-&gt;scale;</a>
<a name="ln954">          pi[0] -= d-&gt;ty * roi_out-&gt;scale;</a>
<a name="ln955">        }</a>
<a name="ln956">        else</a>
<a name="ln957">        {</a>
<a name="ln958">          pi[0] -= d-&gt;tx * roi_out-&gt;scale;</a>
<a name="ln959">          pi[1] -= d-&gt;ty * roi_out-&gt;scale;</a>
<a name="ln960">        }</a>
<a name="ln961">        pi[0] /= roi_out-&gt;scale;</a>
<a name="ln962">        pi[1] /= roi_out-&gt;scale;</a>
<a name="ln963">        backtransform(pi, po, d-&gt;m, d-&gt;k_h, d-&gt;k_v);</a>
<a name="ln964">        po[0] *= roi_in-&gt;scale;</a>
<a name="ln965">        po[1] *= roi_in-&gt;scale;</a>
<a name="ln966">        po[0] += d-&gt;tx * roi_in-&gt;scale;</a>
<a name="ln967">        po[1] += d-&gt;ty * roi_in-&gt;scale;</a>
<a name="ln968">        if(d-&gt;k_apply == 1) keystone_backtransform(po, k_space, ma, mb, md, me, mg, mh, kxa, kya);</a>
<a name="ln969">        po[0] -= roi_in-&gt;x + 0.5f;</a>
<a name="ln970">        po[1] -= roi_in-&gt;y + 0.5f;</a>
<a name="ln971"> </a>
<a name="ln972">        dt_interpolation_compute_pixel4c(interpolation, (float *)ivoid, out, po[0], po[1], roi_in-&gt;width,</a>
<a name="ln973">                                         roi_in-&gt;height, ch_width);</a>
<a name="ln974">      }</a>
<a name="ln975">    }</a>
<a name="ln976">  }</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979"> </a>
<a name="ln980"> </a>
<a name="ln981">#ifdef HAVE_OPENCL</a>
<a name="ln982">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln983">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln984">{</a>
<a name="ln985">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln986">  dt_iop_clipping_global_data_t *gd = (dt_iop_clipping_global_data_t *)self-&gt;data;</a>
<a name="ln987"> </a>
<a name="ln988">  cl_int err = -999;</a>
<a name="ln989">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln990"> </a>
<a name="ln991">  const int width = roi_out-&gt;width;</a>
<a name="ln992">  const int height = roi_out-&gt;height;</a>
<a name="ln993"> </a>
<a name="ln994">  // only crop, no rot fast and sharp path:</a>
<a name="ln995">  if(!d-&gt;flags &amp;&amp; d-&gt;angle == 0.0 &amp;&amp; d-&gt;all_off &amp;&amp; roi_in-&gt;width == roi_out-&gt;width</a>
<a name="ln996">     &amp;&amp; roi_in-&gt;height == roi_out-&gt;height)</a>
<a name="ln997">  {</a>
<a name="ln998">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln999">    size_t region[] = { width, height, 1 };</a>
<a name="ln1000">    err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_out, origin, origin, region);</a>
<a name="ln1001">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln1002">  }</a>
<a name="ln1003">  else</a>
<a name="ln1004">  {</a>
<a name="ln1005">    int crkernel = -1;</a>
<a name="ln1006"> </a>
<a name="ln1007">    const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln1008"> </a>
<a name="ln1009">    switch(interpolation-&gt;id)</a>
<a name="ln1010">    {</a>
<a name="ln1011">      case DT_INTERPOLATION_BILINEAR:</a>
<a name="ln1012">        crkernel = gd-&gt;kernel_clip_rotate_bilinear;</a>
<a name="ln1013">        break;</a>
<a name="ln1014">      case DT_INTERPOLATION_BICUBIC:</a>
<a name="ln1015">        crkernel = gd-&gt;kernel_clip_rotate_bicubic;</a>
<a name="ln1016">        break;</a>
<a name="ln1017">      case DT_INTERPOLATION_LANCZOS2:</a>
<a name="ln1018">        crkernel = gd-&gt;kernel_clip_rotate_lanczos2;</a>
<a name="ln1019">        break;</a>
<a name="ln1020">      case DT_INTERPOLATION_LANCZOS3:</a>
<a name="ln1021">        crkernel = gd-&gt;kernel_clip_rotate_lanczos3;</a>
<a name="ln1022">        break;</a>
<a name="ln1023">      default:</a>
<a name="ln1024">        return FALSE;</a>
<a name="ln1025">    }</a>
<a name="ln1026"> </a>
<a name="ln1027">    int roi[2] = { roi_in-&gt;x, roi_in-&gt;y };</a>
<a name="ln1028">    float roo[2] = { roi_out-&gt;x - roi_out-&gt;scale * d-&gt;enlarge_x + roi_out-&gt;scale * d-&gt;cix,</a>
<a name="ln1029">                     roi_out-&gt;y - roi_out-&gt;scale * d-&gt;enlarge_y + roi_out-&gt;scale * d-&gt;ciy };</a>
<a name="ln1030">    float t[2] = { d-&gt;tx, d-&gt;ty };</a>
<a name="ln1031">    float k[2] = { d-&gt;k_h, d-&gt;k_v };</a>
<a name="ln1032">    float m[4] = { d-&gt;m[0], d-&gt;m[1], d-&gt;m[2], d-&gt;m[3] };</a>
<a name="ln1033"> </a>
<a name="ln1034">    float k_sizes[2] = { piece-&gt;buf_in.width * roi_in-&gt;scale, piece-&gt;buf_in.height * roi_in-&gt;scale };</a>
<a name="ln1035">    float k_space[4] = { d-&gt;k_space[0] * k_sizes[0], d-&gt;k_space[1] * k_sizes[1], d-&gt;k_space[2] * k_sizes[0],</a>
<a name="ln1036">                         d-&gt;k_space[3] * k_sizes[1] };</a>
<a name="ln1037">    if(d-&gt;k_apply == 0) k_space[2] = 0.0f;</a>
<a name="ln1038">    float ma, mb, md, me, mg, mh;</a>
<a name="ln1039">    keystone_get_matrix(k_space, d-&gt;kxa * k_sizes[0], d-&gt;kxb * k_sizes[0], d-&gt;kxc * k_sizes[0],</a>
<a name="ln1040">                        d-&gt;kxd * k_sizes[0], d-&gt;kya * k_sizes[1], d-&gt;kyb * k_sizes[1], d-&gt;kyc * k_sizes[1],</a>
<a name="ln1041">                        d-&gt;kyd * k_sizes[1], &amp;ma, &amp;mb, &amp;md, &amp;me, &amp;mg, &amp;mh);</a>
<a name="ln1042">    float ka[2] = { d-&gt;kxa * k_sizes[0], d-&gt;kya * k_sizes[1] };</a>
<a name="ln1043">    float maa[4] = { ma, mb, md, me };</a>
<a name="ln1044">    float mbb[2] = { mg, mh };</a>
<a name="ln1045"> </a>
<a name="ln1046">    size_t sizes[3];</a>
<a name="ln1047"> </a>
<a name="ln1048">    sizes[0] = ROUNDUPWD(width);</a>
<a name="ln1049">    sizes[1] = ROUNDUPHT(height);</a>
<a name="ln1050">    sizes[2] = 1;</a>
<a name="ln1051">    dt_opencl_set_kernel_arg(devid, crkernel, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln1052">    dt_opencl_set_kernel_arg(devid, crkernel, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln1053">    dt_opencl_set_kernel_arg(devid, crkernel, 2, sizeof(int), &amp;width);</a>
<a name="ln1054">    dt_opencl_set_kernel_arg(devid, crkernel, 3, sizeof(int), &amp;height);</a>
<a name="ln1055">    dt_opencl_set_kernel_arg(devid, crkernel, 4, sizeof(int), &amp;roi_in-&gt;width);</a>
<a name="ln1056">    dt_opencl_set_kernel_arg(devid, crkernel, 5, sizeof(int), &amp;roi_in-&gt;height);</a>
<a name="ln1057">    dt_opencl_set_kernel_arg(devid, crkernel, 6, 2 * sizeof(int), &amp;roi);</a>
<a name="ln1058">    dt_opencl_set_kernel_arg(devid, crkernel, 7, 2 * sizeof(float), &amp;roo);</a>
<a name="ln1059">    dt_opencl_set_kernel_arg(devid, crkernel, 8, sizeof(float), &amp;roi_in-&gt;scale);</a>
<a name="ln1060">    dt_opencl_set_kernel_arg(devid, crkernel, 9, sizeof(float), &amp;roi_out-&gt;scale);</a>
<a name="ln1061">    dt_opencl_set_kernel_arg(devid, crkernel, 10, sizeof(int), &amp;d-&gt;flip);</a>
<a name="ln1062">    dt_opencl_set_kernel_arg(devid, crkernel, 11, 2 * sizeof(float), &amp;t);</a>
<a name="ln1063">    dt_opencl_set_kernel_arg(devid, crkernel, 12, 2 * sizeof(float), &amp;k);</a>
<a name="ln1064">    dt_opencl_set_kernel_arg(devid, crkernel, 13, 4 * sizeof(float), &amp;m);</a>
<a name="ln1065">    dt_opencl_set_kernel_arg(devid, crkernel, 14, 4 * sizeof(float), &amp;k_space);</a>
<a name="ln1066">    dt_opencl_set_kernel_arg(devid, crkernel, 15, 2 * sizeof(float), &amp;ka);</a>
<a name="ln1067">    dt_opencl_set_kernel_arg(devid, crkernel, 16, 4 * sizeof(float), &amp;maa);</a>
<a name="ln1068">    dt_opencl_set_kernel_arg(devid, crkernel, 17, 2 * sizeof(float), &amp;mbb);</a>
<a name="ln1069">    err = dt_opencl_enqueue_kernel_2d(devid, crkernel, sizes);</a>
<a name="ln1070">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln1071">  }</a>
<a name="ln1072"> </a>
<a name="ln1073">  return TRUE;</a>
<a name="ln1074"> </a>
<a name="ln1075">error:</a>
<a name="ln1076">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_clipping] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln1077">  return FALSE;</a>
<a name="ln1078">}</a>
<a name="ln1079">#endif</a>
<a name="ln1080"> </a>
<a name="ln1081">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln1082">{</a>
<a name="ln1083">  const int program = 2; // basic.cl from programs.conf</a>
<a name="ln1084">  dt_iop_clipping_global_data_t *gd</a>
<a name="ln1085">      = (dt_iop_clipping_global_data_t *)malloc(sizeof(dt_iop_clipping_global_data_t));</a>
<a name="ln1086">  module-&gt;data = gd;</a>
<a name="ln1087">  gd-&gt;kernel_clip_rotate_bilinear = dt_opencl_create_kernel(program, &quot;clip_rotate_bilinear&quot;);</a>
<a name="ln1088">  gd-&gt;kernel_clip_rotate_bicubic = dt_opencl_create_kernel(program, &quot;clip_rotate_bicubic&quot;);</a>
<a name="ln1089">  gd-&gt;kernel_clip_rotate_lanczos2 = dt_opencl_create_kernel(program, &quot;clip_rotate_lanczos2&quot;);</a>
<a name="ln1090">  gd-&gt;kernel_clip_rotate_lanczos3 = dt_opencl_create_kernel(program, &quot;clip_rotate_lanczos3&quot;);</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093"> </a>
<a name="ln1094">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln1095">{</a>
<a name="ln1096">  dt_iop_clipping_global_data_t *gd = (dt_iop_clipping_global_data_t *)module-&gt;data;</a>
<a name="ln1097">  dt_opencl_free_kernel(gd-&gt;kernel_clip_rotate_bilinear);</a>
<a name="ln1098">  dt_opencl_free_kernel(gd-&gt;kernel_clip_rotate_bicubic);</a>
<a name="ln1099">  dt_opencl_free_kernel(gd-&gt;kernel_clip_rotate_lanczos2);</a>
<a name="ln1100">  dt_opencl_free_kernel(gd-&gt;kernel_clip_rotate_lanczos3);</a>
<a name="ln1101">  free(module-&gt;data);</a>
<a name="ln1102">  module-&gt;data = NULL;</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln1107">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1108">{</a>
<a name="ln1109">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)p1;</a>
<a name="ln1110">  dt_iop_clipping_data_t *d = (dt_iop_clipping_data_t *)piece-&gt;data;</a>
<a name="ln1111"> </a>
<a name="ln1112">  // reset all values to be sure everything is initialized</a>
<a name="ln1113">  d-&gt;m[0] = d-&gt;m[3] = 1.0f;</a>
<a name="ln1114">  d-&gt;m[1] = d-&gt;m[2] = 0.0f;</a>
<a name="ln1115">  d-&gt;ki_h = d-&gt;ki_v = d-&gt;k_h = d-&gt;k_v = 0.0f;</a>
<a name="ln1116">  d-&gt;tx = d-&gt;ty = 0.0f;</a>
<a name="ln1117">  d-&gt;cix = d-&gt;ciy = 0.0f;</a>
<a name="ln1118">  d-&gt;kxa = d-&gt;kxd = d-&gt;kya = d-&gt;kyb = 0.0f;</a>
<a name="ln1119">  d-&gt;kxb = d-&gt;kxc = d-&gt;kyc = d-&gt;kyd = 0.6f;</a>
<a name="ln1120">  d-&gt;k_space[0] = d-&gt;k_space[1] = 0.2f;</a>
<a name="ln1121">  d-&gt;k_space[2] = d-&gt;k_space[3] = 0.6f;</a>
<a name="ln1122">  d-&gt;k_apply = 0;</a>
<a name="ln1123">  d-&gt;enlarge_x = d-&gt;enlarge_y = 0.0f;</a>
<a name="ln1124">  d-&gt;flip = 0;</a>
<a name="ln1125">  d-&gt;angle = M_PI / 180.0 * p-&gt;angle;</a>
<a name="ln1126"> </a>
<a name="ln1127">  // image flip</a>
<a name="ln1128">  d-&gt;flags = (p-&gt;ch &lt; 0 ? FLAG_FLIP_VERTICAL : 0) | (p-&gt;cw &lt; 0 ? FLAG_FLIP_HORIZONTAL : 0);</a>
<a name="ln1129">  d-&gt;crop_auto = p-&gt;crop_auto;</a>
<a name="ln1130"> </a>
<a name="ln1131">  // keystones values computation</a>
<a name="ln1132">  if(p-&gt;k_type == 4)</a>
<a name="ln1133">  {</a>
<a name="ln1134">    // this is for old keystoning</a>
<a name="ln1135">    d-&gt;k_apply = 0;</a>
<a name="ln1136">    d-&gt;all_off = 1;</a>
<a name="ln1137">    if(fabsf(p-&gt;k_h) &gt;= .0001) d-&gt;all_off = 0;</a>
<a name="ln1138">    if(p-&gt;k_h &gt;= -1.0 &amp;&amp; p-&gt;k_h &lt;= 1.0)</a>
<a name="ln1139">      d-&gt;ki_h = p-&gt;k_h;</a>
<a name="ln1140">    else</a>
<a name="ln1141">      d-&gt;ki_h = 0.0f;</a>
<a name="ln1142">    if(fabsf(p-&gt;k_v) &gt;= .0001) d-&gt;all_off = 0;</a>
<a name="ln1143">    if(p-&gt;k_v &gt;= -1.0 &amp;&amp; p-&gt;k_v &lt;= 1.0)</a>
<a name="ln1144">      d-&gt;ki_v = p-&gt;k_v;</a>
<a name="ln1145">    else</a>
<a name="ln1146">      d-&gt;ki_v = 0.0f;</a>
<a name="ln1147">  }</a>
<a name="ln1148">  else if(p-&gt;k_type &gt;= 0 &amp;&amp; p-&gt;k_apply == 1)</a>
<a name="ln1149">  {</a>
<a name="ln1150">    // we reset old keystoning values</a>
<a name="ln1151">    d-&gt;ki_h = d-&gt;ki_v = 0;</a>
<a name="ln1152">    d-&gt;kxa = p-&gt;kxa;</a>
<a name="ln1153">    d-&gt;kxb = p-&gt;kxb;</a>
<a name="ln1154">    d-&gt;kxc = p-&gt;kxc;</a>
<a name="ln1155">    d-&gt;kxd = p-&gt;kxd;</a>
<a name="ln1156">    d-&gt;kya = p-&gt;kya;</a>
<a name="ln1157">    d-&gt;kyb = p-&gt;kyb;</a>
<a name="ln1158">    d-&gt;kyc = p-&gt;kyc;</a>
<a name="ln1159">    d-&gt;kyd = p-&gt;kyd;</a>
<a name="ln1160">    // we adjust the points if the keystoning is not in &quot;full&quot; mode</a>
<a name="ln1161">    if(p-&gt;k_type == 1) // we want horizontal points to be aligned</a>
<a name="ln1162">    {</a>
<a name="ln1163">      // line equations parameters</a>
<a name="ln1164">      float a1 = (d-&gt;kxd - d-&gt;kxa) / (d-&gt;kyd - d-&gt;kya);</a>
<a name="ln1165">      float b1 = d-&gt;kxa - a1 * d-&gt;kya;</a>
<a name="ln1166">      float a2 = (d-&gt;kxc - d-&gt;kxb) / (d-&gt;kyc - d-&gt;kyb);</a>
<a name="ln1167">      float b2 = d-&gt;kxb - a2 * d-&gt;kyb;</a>
<a name="ln1168"> </a>
<a name="ln1169">      if(d-&gt;kya &gt; d-&gt;kyb)</a>
<a name="ln1170">      {</a>
<a name="ln1171">        // we move kya to the level of kyb</a>
<a name="ln1172">        d-&gt;kya = d-&gt;kyb;</a>
<a name="ln1173">        d-&gt;kxa = a1 * d-&gt;kya + b1;</a>
<a name="ln1174">      }</a>
<a name="ln1175">      else</a>
<a name="ln1176">      {</a>
<a name="ln1177">        // we move kyb to the level of kya</a>
<a name="ln1178">        d-&gt;kyb = d-&gt;kya;</a>
<a name="ln1179">        d-&gt;kxb = a2 * d-&gt;kyb + b2;</a>
<a name="ln1180">      }</a>
<a name="ln1181"> </a>
<a name="ln1182">      if(d-&gt;kyc &gt; d-&gt;kyd)</a>
<a name="ln1183">      {</a>
<a name="ln1184">        // we move kyd to the level of kyc</a>
<a name="ln1185">        d-&gt;kyd = d-&gt;kyc;</a>
<a name="ln1186">        d-&gt;kxd = a1 * d-&gt;kyd + b1;</a>
<a name="ln1187">      }</a>
<a name="ln1188">      else</a>
<a name="ln1189">      {</a>
<a name="ln1190">        // we move kyc to the level of kyd</a>
<a name="ln1191">        d-&gt;kyc = d-&gt;kyd;</a>
<a name="ln1192">        d-&gt;kxc = a2 * d-&gt;kyc + b2;</a>
<a name="ln1193">      }</a>
<a name="ln1194">    }</a>
<a name="ln1195">    else if(p-&gt;k_type == 2) // we want vertical points to be aligned</a>
<a name="ln1196">    {</a>
<a name="ln1197">      // line equations parameters</a>
<a name="ln1198">      float a1 = (d-&gt;kyb - d-&gt;kya) / (d-&gt;kxb - d-&gt;kxa);</a>
<a name="ln1199">      float b1 = d-&gt;kya - a1 * d-&gt;kxa;</a>
<a name="ln1200">      float a2 = (d-&gt;kyc - d-&gt;kyd) / (d-&gt;kxc - d-&gt;kxd);</a>
<a name="ln1201">      float b2 = d-&gt;kyd - a2 * d-&gt;kxd;</a>
<a name="ln1202"> </a>
<a name="ln1203">      if(d-&gt;kxa &gt; d-&gt;kxd)</a>
<a name="ln1204">      {</a>
<a name="ln1205">        // we move kxa to the level of kxd</a>
<a name="ln1206">        d-&gt;kxa = d-&gt;kxd;</a>
<a name="ln1207">        d-&gt;kya = a1 * d-&gt;kxa + b1;</a>
<a name="ln1208">      }</a>
<a name="ln1209">      else</a>
<a name="ln1210">      {</a>
<a name="ln1211">        // we move kyb to the level of kya</a>
<a name="ln1212">        d-&gt;kxd = d-&gt;kxa;</a>
<a name="ln1213">        d-&gt;kyd = a2 * d-&gt;kxd + b2;</a>
<a name="ln1214">      }</a>
<a name="ln1215"> </a>
<a name="ln1216">      if(d-&gt;kxc &gt; d-&gt;kxb)</a>
<a name="ln1217">      {</a>
<a name="ln1218">        // we move kyd to the level of kyc</a>
<a name="ln1219">        d-&gt;kxb = d-&gt;kxc;</a>
<a name="ln1220">        d-&gt;kyb = a1 * d-&gt;kxb + b1;</a>
<a name="ln1221">      }</a>
<a name="ln1222">      else</a>
<a name="ln1223">      {</a>
<a name="ln1224">        // we move kyc to the level of kyd</a>
<a name="ln1225">        d-&gt;kxc = d-&gt;kxb;</a>
<a name="ln1226">        d-&gt;kyc = a2 * d-&gt;kxc + b2;</a>
<a name="ln1227">      }</a>
<a name="ln1228">    }</a>
<a name="ln1229">    d-&gt;k_space[0] = fabsf((d-&gt;kxa + d-&gt;kxd) / 2.0f);</a>
<a name="ln1230">    d-&gt;k_space[1] = fabsf((d-&gt;kya + d-&gt;kyb) / 2.0f);</a>
<a name="ln1231">    d-&gt;k_space[2] = fabsf((d-&gt;kxb + d-&gt;kxc) / 2.0f) - d-&gt;k_space[0];</a>
<a name="ln1232">    d-&gt;k_space[3] = fabsf((d-&gt;kyc + d-&gt;kyd) / 2.0f) - d-&gt;k_space[1];</a>
<a name="ln1233">    d-&gt;kxb = d-&gt;kxb - d-&gt;kxa;</a>
<a name="ln1234">    d-&gt;kxc = d-&gt;kxc - d-&gt;kxa;</a>
<a name="ln1235">    d-&gt;kxd = d-&gt;kxd - d-&gt;kxa;</a>
<a name="ln1236">    d-&gt;kyb = d-&gt;kyb - d-&gt;kya;</a>
<a name="ln1237">    d-&gt;kyc = d-&gt;kyc - d-&gt;kya;</a>
<a name="ln1238">    d-&gt;kyd = d-&gt;kyd - d-&gt;kya;</a>
<a name="ln1239">    keystone_get_matrix(d-&gt;k_space, d-&gt;kxa, d-&gt;kxb, d-&gt;kxc, d-&gt;kxd, d-&gt;kya, d-&gt;kyb, d-&gt;kyc, d-&gt;kyd, &amp;d-&gt;a,</a>
<a name="ln1240">                        &amp;d-&gt;b, &amp;d-&gt;d, &amp;d-&gt;e, &amp;d-&gt;g, &amp;d-&gt;h);</a>
<a name="ln1241"> </a>
<a name="ln1242">    d-&gt;k_apply = 1;</a>
<a name="ln1243">    d-&gt;all_off = 0;</a>
<a name="ln1244">    d-&gt;crop_auto = 0;</a>
<a name="ln1245">  }</a>
<a name="ln1246">  else</a>
<a name="ln1247">  {</a>
<a name="ln1248">    d-&gt;all_off = 1;</a>
<a name="ln1249">    d-&gt;k_apply = 0;</a>
<a name="ln1250">  }</a>
<a name="ln1251"> </a>
<a name="ln1252">  if(gui_has_focus(self))</a>
<a name="ln1253">  {</a>
<a name="ln1254">    d-&gt;cx = 0.0f;</a>
<a name="ln1255">    d-&gt;cy = 0.0f;</a>
<a name="ln1256">    d-&gt;cw = 1.0f;</a>
<a name="ln1257">    d-&gt;ch = 1.0f;</a>
<a name="ln1258">  }</a>
<a name="ln1259">  else</a>
<a name="ln1260">  {</a>
<a name="ln1261">    d-&gt;cx = p-&gt;cx;</a>
<a name="ln1262">    d-&gt;cy = p-&gt;cy;</a>
<a name="ln1263">    d-&gt;cw = fabsf(p-&gt;cw);</a>
<a name="ln1264">    d-&gt;ch = fabsf(p-&gt;ch);</a>
<a name="ln1265">  }</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln1269">{</a>
<a name="ln1270">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1271">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1272">  if(self-&gt;enabled)</a>
<a name="ln1273">  {</a>
<a name="ln1274">    if(in)</a>
<a name="ln1275">    {</a>
<a name="ln1276">      // got focus. make it redraw in full and grab stuff to gui:</a>
<a name="ln1277">      // need to get gui stuff for the first time for this image,</a>
<a name="ln1278">      // and advice the pipe to redraw in full:</a>
<a name="ln1279">      g-&gt;clip_x = p-&gt;cx;</a>
<a name="ln1280">      g-&gt;clip_w = fabsf(p-&gt;cw) - p-&gt;cx;</a>
<a name="ln1281">      g-&gt;clip_y = p-&gt;cy;</a>
<a name="ln1282">      g-&gt;clip_h = fabsf(p-&gt;ch) - p-&gt;cy;</a>
<a name="ln1283">      if(g-&gt;clip_x &gt; 0 || g-&gt;clip_y &gt; 0 || g-&gt;clip_h &lt; 1.0f || g-&gt;clip_w &lt; 1.0f)</a>
<a name="ln1284">      {</a>
<a name="ln1285">        g-&gt;old_width = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1286">        g-&gt;old_height = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1287">      }</a>
<a name="ln1288">      else</a>
<a name="ln1289">      {</a>
<a name="ln1290">        g-&gt;old_width = g-&gt;old_height = -1;</a>
<a name="ln1291">      }</a>
<a name="ln1292">      // make sure the cache is avoided:</a>
<a name="ln1293">      dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln1294">    }</a>
<a name="ln1295">    else</a>
<a name="ln1296">    {</a>
<a name="ln1297">      // lost focus, commit current params:</a>
<a name="ln1298">      // if the keystone setting is not finished, we discard it</a>
<a name="ln1299">      if(p-&gt;k_apply == 0 &amp;&amp; p-&gt;k_type &lt; 4 &amp;&amp; p-&gt;k_type &gt; 0)</a>
<a name="ln1300">      {</a>
<a name="ln1301">        keystone_type_populate(self, FALSE, 0);</a>
<a name="ln1302">      }</a>
<a name="ln1303">      commit_box(self, g, p);</a>
<a name="ln1304">      g-&gt;clip_max_pipe_hash = 0;</a>
<a name="ln1305">    }</a>
<a name="ln1306">  }</a>
<a name="ln1307">}</a>
<a name="ln1308"> </a>
<a name="ln1309"> </a>
<a name="ln1310">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1311">{</a>
<a name="ln1312">  piece-&gt;data = malloc(sizeof(dt_iop_clipping_data_t));</a>
<a name="ln1313">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln1317">{</a>
<a name="ln1318">  free(piece-&gt;data);</a>
<a name="ln1319">  piece-&gt;data = NULL;</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">static float _ratio_get_aspect(dt_iop_module_t *self)</a>
<a name="ln1323">{</a>
<a name="ln1324">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1325"> </a>
<a name="ln1326">  // we want to know the size of the actual buffer</a>
<a name="ln1327">  dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln1328">  if(!piece) return 0;</a>
<a name="ln1329"> </a>
<a name="ln1330">  const int iwd = piece-&gt;buf_in.width, iht = piece-&gt;buf_in.height;</a>
<a name="ln1331"> </a>
<a name="ln1332">  // if we do not have yet computed the aspect ratio, let's do it now</a>
<a name="ln1333">  if(p-&gt;ratio_d == -2 &amp;&amp; p-&gt;ratio_n == -2)</a>
<a name="ln1334">  {</a>
<a name="ln1335">    if(fabsf(p-&gt;cw) == 1.0 &amp;&amp; p-&gt;cx == 0.0 &amp;&amp; fabsf(p-&gt;ch) == 1.0 &amp;&amp; p-&gt;cy == 0.0)</a>
<a name="ln1336">    {</a>
<a name="ln1337">      p-&gt;ratio_d = -1;</a>
<a name="ln1338">      p-&gt;ratio_n = -1;</a>
<a name="ln1339">    }</a>
<a name="ln1340">    else</a>
<a name="ln1341">    {</a>
<a name="ln1342">      const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln1343">      float whratio = ((float)(iwd - 2 * interpolation-&gt;width) * (fabsf(p-&gt;cw) - p-&gt;cx))</a>
<a name="ln1344">                      / ((float)(iht - 2 * interpolation-&gt;width) * (fabsf(p-&gt;ch) - p-&gt;cy));</a>
<a name="ln1345">      float ri = (float)iwd / (float)iht;</a>
<a name="ln1346"> </a>
<a name="ln1347">      float prec = 0.0003f;</a>
<a name="ln1348">      if(fabsf(whratio - 3.0f / 2.0f) &lt; prec)</a>
<a name="ln1349">      {</a>
<a name="ln1350">        p-&gt;ratio_d = 3;</a>
<a name="ln1351">        p-&gt;ratio_n = 2;</a>
<a name="ln1352">      }</a>
<a name="ln1353">      else if(fabsf(whratio - 2.0f / 1.0f) &lt; prec)</a>
<a name="ln1354">      {</a>
<a name="ln1355">        p-&gt;ratio_d = 2;</a>
<a name="ln1356">        p-&gt;ratio_n = 1;</a>
<a name="ln1357">      }</a>
<a name="ln1358">      else if(fabsf(whratio - 7.0f / 5.0f) &lt; prec)</a>
<a name="ln1359">      {</a>
<a name="ln1360">        p-&gt;ratio_d = 7;</a>
<a name="ln1361">        p-&gt;ratio_n = 5;</a>
<a name="ln1362">      }</a>
<a name="ln1363">      else if(fabsf(whratio - 4.0f / 3.0f) &lt; prec)</a>
<a name="ln1364">      {</a>
<a name="ln1365">        p-&gt;ratio_d = 4;</a>
<a name="ln1366">        p-&gt;ratio_n = 3;</a>
<a name="ln1367">      }</a>
<a name="ln1368">      else if(fabsf(whratio - 5.0f / 4.0f) &lt; prec)</a>
<a name="ln1369">      {</a>
<a name="ln1370">        p-&gt;ratio_d = 5;</a>
<a name="ln1371">        p-&gt;ratio_n = 4;</a>
<a name="ln1372">      }</a>
<a name="ln1373">      else if(fabsf(whratio - 1.0f / 1.0f) &lt; prec)</a>
<a name="ln1374">      {</a>
<a name="ln1375">        p-&gt;ratio_d = 1;</a>
<a name="ln1376">        p-&gt;ratio_n = 1;</a>
<a name="ln1377">      }</a>
<a name="ln1378">      else if(fabsf(whratio - 16.0f / 9.0f) &lt; prec)</a>
<a name="ln1379">      {</a>
<a name="ln1380">        p-&gt;ratio_d = 16;</a>
<a name="ln1381">        p-&gt;ratio_n = 9;</a>
<a name="ln1382">      }</a>
<a name="ln1383">      else if(fabsf(whratio - 16.0f / 10.0f) &lt; prec)</a>
<a name="ln1384">      {</a>
<a name="ln1385">        p-&gt;ratio_d = 16;</a>
<a name="ln1386">        p-&gt;ratio_n = 10;</a>
<a name="ln1387">      }</a>
<a name="ln1388">      else if(fabsf(whratio - 244.5f / 203.2f) &lt; prec)</a>
<a name="ln1389">      {</a>
<a name="ln1390">        p-&gt;ratio_d = 2445;</a>
<a name="ln1391">        p-&gt;ratio_n = 2032;</a>
<a name="ln1392">      }</a>
<a name="ln1393">      else if(fabsf(whratio - sqrtf(2.0f)) &lt; prec)</a>
<a name="ln1394">      {</a>
<a name="ln1395">        p-&gt;ratio_d = 14142136;</a>
<a name="ln1396">        p-&gt;ratio_n = 10000000;</a>
<a name="ln1397">      }</a>
<a name="ln1398">      else if(fabsf(whratio - PHI) &lt; prec)</a>
<a name="ln1399">      {</a>
<a name="ln1400">        p-&gt;ratio_d = 16180340;</a>
<a name="ln1401">        p-&gt;ratio_n = 10000000;</a>
<a name="ln1402">      }</a>
<a name="ln1403">      else if(fabsf(whratio - ri) &lt; prec)</a>
<a name="ln1404">      {</a>
<a name="ln1405">        p-&gt;ratio_d = 1;</a>
<a name="ln1406">        p-&gt;ratio_n = 0;</a>
<a name="ln1407">      }</a>
<a name="ln1408">      else</a>
<a name="ln1409">      {</a>
<a name="ln1410">        p-&gt;ratio_d = 0;</a>
<a name="ln1411">        p-&gt;ratio_n = 0;</a>
<a name="ln1412">      }</a>
<a name="ln1413">    }</a>
<a name="ln1414">  }</a>
<a name="ln1415"> </a>
<a name="ln1416">  if(p-&gt;ratio_d == 0 &amp;&amp; p-&gt;ratio_n == 0) return -1.0f;</a>
<a name="ln1417">  float d = 1.0f, n = 1.0f;</a>
<a name="ln1418">  if(p-&gt;ratio_n == 0)</a>
<a name="ln1419">  {</a>
<a name="ln1420">    d = copysignf(iwd, p-&gt;ratio_d);</a>
<a name="ln1421">    n = iht;</a>
<a name="ln1422">  }</a>
<a name="ln1423">  else</a>
<a name="ln1424">  {</a>
<a name="ln1425">    d = p-&gt;ratio_d;</a>
<a name="ln1426">    n = p-&gt;ratio_n;</a>
<a name="ln1427">  }</a>
<a name="ln1428"> </a>
<a name="ln1429">  // make aspect ratios like 3:2 and 2:3 to be the same thing</a>
<a name="ln1430">  const float dn = copysignf(MAX(fabsf(d), fabsf(n)), d);</a>
<a name="ln1431">  const float nn = copysignf(MIN(fabsf(d), fabsf(n)), n);</a>
<a name="ln1432"> </a>
<a name="ln1433">  if(dn &lt; 0)</a>
<a name="ln1434">    return -nn / dn;</a>
<a name="ln1435">  else</a>
<a name="ln1436">    return dn / nn;</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">static void apply_box_aspect(dt_iop_module_t *self, _grab_region_t grab)</a>
<a name="ln1440">{</a>
<a name="ln1441">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1442"> </a>
<a name="ln1443">  int iwd, iht;</a>
<a name="ln1444">  dt_dev_get_processed_size(darktable.develop, &amp;iwd, &amp;iht);</a>
<a name="ln1445"> </a>
<a name="ln1446">  // enforce aspect ratio.</a>
<a name="ln1447">  float aspect = _ratio_get_aspect(self);</a>
<a name="ln1448"> </a>
<a name="ln1449">  // since one rarely changes between portrait and landscape by cropping,</a>
<a name="ln1450">  // long side of the crop box should match the long side of the image.</a>
<a name="ln1451">  if(iwd &lt; iht) aspect = 1.0f / aspect;</a>
<a name="ln1452"> </a>
<a name="ln1453">  if(aspect &gt; 0)</a>
<a name="ln1454">  {</a>
<a name="ln1455">    // if only one side changed, force aspect by two adjacent in equal parts</a>
<a name="ln1456">    // 1 2 4 8 : x y w h</a>
<a name="ln1457">    double clip_x = g-&gt;clip_x, clip_y = g-&gt;clip_y, clip_w = g-&gt;clip_w, clip_h = g-&gt;clip_h;</a>
<a name="ln1458"> </a>
<a name="ln1459">    // if we only modified one dim, respectively, we wanted these values:</a>
<a name="ln1460">    const double target_h = (double)iwd * g-&gt;clip_w / ((double)iht * aspect);</a>
<a name="ln1461">    const double target_w = (double)iht * g-&gt;clip_h * aspect / (double)iwd;</a>
<a name="ln1462">    // i.e. target_w/h = w/target_h = aspect</a>
<a name="ln1463">    // first fix aspect ratio:</a>
<a name="ln1464"> </a>
<a name="ln1465">    // corners: move two adjacent</a>
<a name="ln1466">    if(grab == GRAB_TOP_LEFT)</a>
<a name="ln1467">    {</a>
<a name="ln1468">      // move x y</a>
<a name="ln1469">      clip_x = clip_x + clip_w - (target_w + clip_w) * .5;</a>
<a name="ln1470">      clip_y = clip_y + clip_h - (target_h + clip_h) * .5;</a>
<a name="ln1471">      clip_w = (target_w + clip_w) * .5;</a>
<a name="ln1472">      clip_h = (target_h + clip_h) * .5;</a>
<a name="ln1473">    }</a>
<a name="ln1474">    else if(grab == GRAB_TOP_RIGHT) // move y w</a>
<a name="ln1475">    {</a>
<a name="ln1476">      clip_y = clip_y + clip_h - (target_h + clip_h) * .5;</a>
<a name="ln1477">      clip_w = (target_w + clip_w) * .5;</a>
<a name="ln1478">      clip_h = (target_h + clip_h) * .5;</a>
<a name="ln1479">    }</a>
<a name="ln1480">    else if(grab == GRAB_BOTTOM_RIGHT) // move w h</a>
<a name="ln1481">    {</a>
<a name="ln1482">      clip_w = (target_w + clip_w) * .5;</a>
<a name="ln1483">      clip_h = (target_h + clip_h) * .5;</a>
<a name="ln1484">    }</a>
<a name="ln1485">    else if(grab == GRAB_BOTTOM_LEFT) // move h x</a>
<a name="ln1486">    {</a>
<a name="ln1487">      clip_h = (target_h + clip_h) * .5;</a>
<a name="ln1488">      clip_x = clip_x + clip_w - (target_w + clip_w) * .5;</a>
<a name="ln1489">      clip_w = (target_w + clip_w) * .5;</a>
<a name="ln1490">    }</a>
<a name="ln1491">    else if(grab &amp; GRAB_HORIZONTAL) // dragged either x or w (1 4)</a>
<a name="ln1492">    {</a>
<a name="ln1493">      // change h and move y, h equally</a>
<a name="ln1494">      const double off = target_h - clip_h;</a>
<a name="ln1495">      clip_h = clip_h + off;</a>
<a name="ln1496">      clip_y = clip_y - .5 * off;</a>
<a name="ln1497">    }</a>
<a name="ln1498">    else if(grab &amp; GRAB_VERTICAL) // dragged either y or h (2 8)</a>
<a name="ln1499">    {</a>
<a name="ln1500">      // change w and move x, w equally</a>
<a name="ln1501">      const double off = target_w - clip_w;</a>
<a name="ln1502">      clip_w = clip_w + off;</a>
<a name="ln1503">      clip_x = clip_x - .5 * off;</a>
<a name="ln1504">    }</a>
<a name="ln1505"> </a>
<a name="ln1506">    // now fix outside boxes:</a>
<a name="ln1507">    if(clip_x &lt; g-&gt;clip_max_x)</a>
<a name="ln1508">    {</a>
<a name="ln1509">      double prev_clip_h = clip_h;</a>
<a name="ln1510">      clip_h *= (clip_w + clip_x - g-&gt;clip_max_x) / clip_w;</a>
<a name="ln1511">      clip_w = clip_w + clip_x - g-&gt;clip_max_x;</a>
<a name="ln1512">      clip_x = g-&gt;clip_max_x;</a>
<a name="ln1513">      if(grab &amp; GRAB_TOP) clip_y += prev_clip_h - clip_h;</a>
<a name="ln1514">    }</a>
<a name="ln1515">    if(clip_y &lt; g-&gt;clip_max_y)</a>
<a name="ln1516">    {</a>
<a name="ln1517">      double prev_clip_w = clip_w;</a>
<a name="ln1518">      clip_w *= (clip_h + clip_y - g-&gt;clip_max_y) / clip_h;</a>
<a name="ln1519">      clip_h = clip_h + clip_y - g-&gt;clip_max_y;</a>
<a name="ln1520">      clip_y = g-&gt;clip_max_y;</a>
<a name="ln1521">      if(grab &amp; GRAB_LEFT) clip_x += prev_clip_w - clip_w;</a>
<a name="ln1522">    }</a>
<a name="ln1523">    if(clip_x + clip_w &gt; g-&gt;clip_max_x + g-&gt;clip_max_w)</a>
<a name="ln1524">    {</a>
<a name="ln1525">      double prev_clip_h = clip_h;</a>
<a name="ln1526">      clip_h *= (g-&gt;clip_max_x + g-&gt;clip_max_w - clip_x) / clip_w;</a>
<a name="ln1527">      clip_w = g-&gt;clip_max_x + g-&gt;clip_max_w - clip_x;</a>
<a name="ln1528">      if(grab &amp; GRAB_TOP) clip_y += prev_clip_h - clip_h;</a>
<a name="ln1529">    }</a>
<a name="ln1530">    if(clip_y + clip_h &gt; g-&gt;clip_max_y + g-&gt;clip_max_h)</a>
<a name="ln1531">    {</a>
<a name="ln1532">      double prev_clip_w = clip_w;</a>
<a name="ln1533">      clip_w *= (g-&gt;clip_max_y + g-&gt;clip_max_h - clip_y) / clip_h;</a>
<a name="ln1534">      clip_h = g-&gt;clip_max_y + g-&gt;clip_max_h - clip_y;</a>
<a name="ln1535">      if(grab &amp; GRAB_LEFT) clip_x += prev_clip_w - clip_w;</a>
<a name="ln1536">    }</a>
<a name="ln1537">    g-&gt;clip_x = clip_x;</a>
<a name="ln1538">    g-&gt;clip_y = clip_y;</a>
<a name="ln1539">    g-&gt;clip_w = clip_w;</a>
<a name="ln1540">    g-&gt;clip_h = clip_h;</a>
<a name="ln1541">  }</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">void reload_defaults(dt_iop_module_t *self)</a>
<a name="ln1545">{</a>
<a name="ln1546">  dt_iop_clipping_params_t tmp</a>
<a name="ln1547">      = (dt_iop_clipping_params_t){ 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f,  0.2f, 0.2f, 0.8f, 0.2f,</a>
<a name="ln1548">                                    0.8f, 0.8f, 0.2f, 0.8f, 0,    0,    FALSE, TRUE, -1,   -1 };</a>
<a name="ln1549">  memcpy(self-&gt;params, &amp;tmp, sizeof(dt_iop_clipping_params_t));</a>
<a name="ln1550">  memcpy(self-&gt;default_params, &amp;tmp, sizeof(dt_iop_clipping_params_t));</a>
<a name="ln1551">  self-&gt;default_enabled = 0;</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">static void aspect_presets_changed(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1555">{</a>
<a name="ln1556">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1557">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1558">  int which = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1559">  int d = p-&gt;ratio_d, n = p-&gt;ratio_n;</a>
<a name="ln1560">  const char *text = dt_bauhaus_combobox_get_text(combo);</a>
<a name="ln1561">  if(which &lt; 0)</a>
<a name="ln1562">  {</a>
<a name="ln1563">    if(text)</a>
<a name="ln1564">    {</a>
<a name="ln1565">      const char *c = text;</a>
<a name="ln1566">      const char *end = text + strlen(text);</a>
<a name="ln1567">      while(*c != ':' &amp;&amp; *c != '/' &amp;&amp; c &lt; end) c++;</a>
<a name="ln1568">      if(c &lt; end - 1)</a>
<a name="ln1569">      {</a>
<a name="ln1570">        c++;</a>
<a name="ln1571">        int dd = atoi(text);</a>
<a name="ln1572">        int nn = atoi(c);</a>
<a name="ln1573">        // some sanity check</a>
<a name="ln1574">        if(nn == 0 || dd == 0)</a>
<a name="ln1575">        {</a>
<a name="ln1576">          dt_control_log(_(&quot;invalid ratio format. it should be \&quot;number:number\&quot;&quot;));</a>
<a name="ln1577">          dt_bauhaus_combobox_set(combo, 0);</a>
<a name="ln1578">          return;</a>
<a name="ln1579">        }</a>
<a name="ln1580">        d = dd;</a>
<a name="ln1581">        n = nn;</a>
<a name="ln1582">      }</a>
<a name="ln1583">    }</a>
<a name="ln1584">  }</a>
<a name="ln1585">  else</a>
<a name="ln1586">  {</a>
<a name="ln1587">    d = n = 0;</a>
<a name="ln1588"> </a>
<a name="ln1589">    GList *iter = g-&gt;aspect_list;</a>
<a name="ln1590">    while(iter != NULL)</a>
<a name="ln1591">    {</a>
<a name="ln1592">      const dt_iop_clipping_aspect_t *aspect = iter-&gt;data;</a>
<a name="ln1593">      if(g_strcmp0(aspect-&gt;name, text) == 0)</a>
<a name="ln1594">      {</a>
<a name="ln1595">        d = aspect-&gt;d;</a>
<a name="ln1596">        n = aspect-&gt;n;</a>
<a name="ln1597">        break;</a>
<a name="ln1598">      }</a>
<a name="ln1599">      iter = g_list_next(iter);</a>
<a name="ln1600">    }</a>
<a name="ln1601">  }</a>
<a name="ln1602"> </a>
<a name="ln1603">  // now we save all that if it has changed</a>
<a name="ln1604">  if(d != abs(p-&gt;ratio_d) || n != p-&gt;ratio_n)</a>
<a name="ln1605">  {</a>
<a name="ln1606">    p-&gt;ratio_d = d;</a>
<a name="ln1607">    p-&gt;ratio_n = n;</a>
<a name="ln1608">    dt_conf_set_int(&quot;plugins/darkroom/clipping/ratio_d&quot;, abs(p-&gt;ratio_d));</a>
<a name="ln1609">    dt_conf_set_int(&quot;plugins/darkroom/clipping/ratio_n&quot;, p-&gt;ratio_n);</a>
<a name="ln1610">    if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1611">    apply_box_aspect(self, GRAB_HORIZONTAL);</a>
<a name="ln1612">    dt_control_queue_redraw_center();</a>
<a name="ln1613">  }</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">static void angle_callback(GtkWidget *slider, dt_iop_module_t *self)</a>
<a name="ln1617">{</a>
<a name="ln1618">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1619">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1620">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1621">  p-&gt;angle = -dt_bauhaus_slider_get(slider);</a>
<a name="ln1622">  commit_box(self, g, p);</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">void gui_reset(struct dt_iop_module_t *self)</a>
<a name="ln1626">{</a>
<a name="ln1627">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1628">  /* reset aspect preset to default */</a>
<a name="ln1629">  dt_conf_set_int(&quot;plugins/darkroom/clipping/ratio_d&quot;, 0);</a>
<a name="ln1630">  dt_conf_set_int(&quot;plugins/darkroom/clipping/ratio_n&quot;, 0);</a>
<a name="ln1631">  g-&gt;k_show = -1;</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">static void keystone_type_changed(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1635">{</a>
<a name="ln1636">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1637">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1638">  int which = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1639">  if((which == 5) || (which == 4 &amp;&amp; p-&gt;k_h == 0 &amp;&amp; p-&gt;k_v == 0))</a>
<a name="ln1640">  {</a>
<a name="ln1641">    // if the keystone is applied,autocrop must be disabled !</a>
<a name="ln1642">    gtk_widget_set_sensitive(g-&gt;crop_auto, FALSE);</a>
<a name="ln1643">    gtk_widget_set_sensitive(g-&gt;aspect_presets, TRUE);</a>
<a name="ln1644">    return;</a>
<a name="ln1645">  }</a>
<a name="ln1646">  // we recreate the list to be sure that the &quot;already applied&quot; entry is not display</a>
<a name="ln1647">  if(g-&gt;k_show == 2)</a>
<a name="ln1648">  {</a>
<a name="ln1649">    if(which == 0 || which == 4)</a>
<a name="ln1650">      g-&gt;k_show = 0;</a>
<a name="ln1651">    else</a>
<a name="ln1652">      g-&gt;k_show = 1;</a>
<a name="ln1653">    keystone_type_populate(self, FALSE, which);</a>
<a name="ln1654">  }</a>
<a name="ln1655"> </a>
<a name="ln1656">  // we set the params</a>
<a name="ln1657">  p-&gt;k_apply = 0;</a>
<a name="ln1658">  p-&gt;k_type = which;</a>
<a name="ln1659">  if(which == 0 || which == 4)</a>
<a name="ln1660">    g-&gt;k_show = 0;</a>
<a name="ln1661">  else</a>
<a name="ln1662">    g-&gt;k_show = 1;</a>
<a name="ln1663"> </a>
<a name="ln1664">  // we can enable autocrop</a>
<a name="ln1665">  gtk_widget_set_sensitive(g-&gt;crop_auto, (g-&gt;k_show == 0));</a>
<a name="ln1666">  gtk_widget_set_sensitive(g-&gt;aspect_presets, (g-&gt;k_show == 0));</a>
<a name="ln1667"> </a>
<a name="ln1668">  commit_box(self, g, p);</a>
<a name="ln1669">  dt_control_queue_redraw_center();</a>
<a name="ln1670">}</a>
<a name="ln1671"> </a>
<a name="ln1672">static void keystone_type_populate(struct dt_iop_module_t *self, gboolean with_applied, int select)</a>
<a name="ln1673">{</a>
<a name="ln1674">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1675">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1676">  dt_bauhaus_combobox_clear(g-&gt;keystone_type);</a>
<a name="ln1677">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;none&quot;));</a>
<a name="ln1678">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;vertical&quot;));</a>
<a name="ln1679">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;horizontal&quot;));</a>
<a name="ln1680">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;full&quot;));</a>
<a name="ln1681">  if(p-&gt;k_h != 0 || p-&gt;k_v != 0) dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;old system&quot;));</a>
<a name="ln1682">  if(with_applied) dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;correction applied&quot;));</a>
<a name="ln1683"> </a>
<a name="ln1684">  if(select &lt; 0) return;</a>
<a name="ln1685">  int sel = 0;</a>
<a name="ln1686">  if(select &gt; 10 &amp;&amp; p-&gt;k_h == 0 &amp;&amp; p-&gt;k_v == 0)</a>
<a name="ln1687">    sel = 4;</a>
<a name="ln1688">  else if(select &gt; 10)</a>
<a name="ln1689">    sel = 5;</a>
<a name="ln1690">  else</a>
<a name="ln1691">    sel = select;</a>
<a name="ln1692"> </a>
<a name="ln1693">  dt_bauhaus_combobox_set(g-&gt;keystone_type, sel);</a>
<a name="ln1694">  // we have to be sure that the event is called...</a>
<a name="ln1695">  keystone_type_changed(g-&gt;keystone_type, self);</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln1699">{</a>
<a name="ln1700">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1701">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1702"> </a>
<a name="ln1703">  /* update ui elements */</a>
<a name="ln1704">  dt_bauhaus_slider_set(g-&gt;angle, -p-&gt;angle);</a>
<a name="ln1705">  int hvflip = 0;</a>
<a name="ln1706">  if(p-&gt;cw &lt; 0)</a>
<a name="ln1707">  {</a>
<a name="ln1708">    if(p-&gt;ch &lt; 0)</a>
<a name="ln1709">      hvflip = 3;</a>
<a name="ln1710">    else</a>
<a name="ln1711">      hvflip = 1;</a>
<a name="ln1712">  }</a>
<a name="ln1713">  else</a>
<a name="ln1714">  {</a>
<a name="ln1715">    if(p-&gt;ch &lt; 0)</a>
<a name="ln1716">      hvflip = 2;</a>
<a name="ln1717">    else</a>
<a name="ln1718">      hvflip = 0;</a>
<a name="ln1719">  }</a>
<a name="ln1720">  dt_bauhaus_combobox_set(g-&gt;hvflip, hvflip);</a>
<a name="ln1721"> </a>
<a name="ln1722">  //  set aspect ratio based on the current image, if not found let's default</a>
<a name="ln1723">  //  to free aspect.</a>
<a name="ln1724"> </a>
<a name="ln1725">  if(p-&gt;ratio_d == -2 &amp;&amp; p-&gt;ratio_n == -2) _ratio_get_aspect(self);</a>
<a name="ln1726"> </a>
<a name="ln1727">  if(p-&gt;ratio_d == -1 &amp;&amp; p-&gt;ratio_n == -1)</a>
<a name="ln1728">  {</a>
<a name="ln1729">    p-&gt;ratio_d = dt_conf_get_int(&quot;plugins/darkroom/clipping/ratio_d&quot;);</a>
<a name="ln1730">    p-&gt;ratio_n = dt_conf_get_int(&quot;plugins/darkroom/clipping/ratio_n&quot;);</a>
<a name="ln1731">  }</a>
<a name="ln1732">  const int d = abs(p-&gt;ratio_d), n = p-&gt;ratio_n;</a>
<a name="ln1733"> </a>
<a name="ln1734">  int act = -1, i = 0;</a>
<a name="ln1735"> </a>
<a name="ln1736">  GList *iter = g-&gt;aspect_list;</a>
<a name="ln1737">  while(iter != NULL)</a>
<a name="ln1738">  {</a>
<a name="ln1739">    const dt_iop_clipping_aspect_t *aspect = iter-&gt;data;</a>
<a name="ln1740">    if((aspect-&gt;d == d) &amp;&amp; (aspect-&gt;n == n))</a>
<a name="ln1741">    {</a>
<a name="ln1742">      act = i;</a>
<a name="ln1743">      break;</a>
<a name="ln1744">    }</a>
<a name="ln1745">    i++;</a>
<a name="ln1746">    iter = g_list_next(iter);</a>
<a name="ln1747">  }</a>
<a name="ln1748"> </a>
<a name="ln1749">  // keystone :</a>
<a name="ln1750">  if(p-&gt;k_apply == 1) g-&gt;k_show = 2; // needed to initialise correctly the combobox</a>
<a name="ln1751">  else g-&gt;k_show = -1;</a>
<a name="ln1752"> </a>
<a name="ln1753">  if(g-&gt;k_show == 2)</a>
<a name="ln1754">  {</a>
<a name="ln1755">    keystone_type_populate(self, TRUE, 99);</a>
<a name="ln1756">  }</a>
<a name="ln1757">  else if(g-&gt;k_show == -1)</a>
<a name="ln1758">  {</a>
<a name="ln1759">    keystone_type_populate(self, FALSE, p-&gt;k_type);</a>
<a name="ln1760">  }</a>
<a name="ln1761"> </a>
<a name="ln1762"> </a>
<a name="ln1763">  /* special handling the combobox when current act is already selected</a>
<a name="ln1764">     callback is not called, let do it our self then..</a>
<a name="ln1765">   */</a>
<a name="ln1766">  if(act == -1)</a>
<a name="ln1767">  {</a>
<a name="ln1768">    char str[128];</a>
<a name="ln1769">    snprintf(str, sizeof(str), &quot;%d:%d&quot;, abs(p-&gt;ratio_d), p-&gt;ratio_n);</a>
<a name="ln1770">    dt_bauhaus_combobox_set_text(g-&gt;aspect_presets, str);</a>
<a name="ln1771">  }</a>
<a name="ln1772">  if(dt_bauhaus_combobox_get(g-&gt;aspect_presets) == act)</a>
<a name="ln1773">    aspect_presets_changed(g-&gt;aspect_presets, self);</a>
<a name="ln1774">  else</a>
<a name="ln1775">    dt_bauhaus_combobox_set(g-&gt;aspect_presets, act);</a>
<a name="ln1776"> </a>
<a name="ln1777">  // reset gui draw box to what we have in the parameters:</a>
<a name="ln1778">  g-&gt;applied = 1;</a>
<a name="ln1779">  g-&gt;clip_x = p-&gt;cx;</a>
<a name="ln1780">  g-&gt;clip_w = fabsf(p-&gt;cw) - p-&gt;cx;</a>
<a name="ln1781">  g-&gt;clip_y = p-&gt;cy;</a>
<a name="ln1782">  g-&gt;clip_h = fabsf(p-&gt;ch) - p-&gt;cy;</a>
<a name="ln1783"> </a>
<a name="ln1784">  dt_bauhaus_combobox_set(g-&gt;crop_auto, p-&gt;crop_auto);</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">void init(dt_iop_module_t *module)</a>
<a name="ln1788">{</a>
<a name="ln1789">  // module-&gt;data = malloc(sizeof(dt_iop_clipping_data_t));</a>
<a name="ln1790">  module-&gt;params = calloc(1, sizeof(dt_iop_clipping_params_t));</a>
<a name="ln1791">  module-&gt;default_params = calloc(1, sizeof(dt_iop_clipping_params_t));</a>
<a name="ln1792">  module-&gt;default_enabled = 0;</a>
<a name="ln1793">  module-&gt;params_size = sizeof(dt_iop_clipping_params_t);</a>
<a name="ln1794">  module-&gt;gui_data = NULL;</a>
<a name="ln1795">}</a>
<a name="ln1796"> </a>
<a name="ln1797">void cleanup(dt_iop_module_t *module)</a>
<a name="ln1798">{</a>
<a name="ln1799">  free(module-&gt;params);</a>
<a name="ln1800">  module-&gt;params = NULL;</a>
<a name="ln1801">}</a>
<a name="ln1802"> </a>
<a name="ln1803">static void hvflip_callback(GtkWidget *widget, dt_iop_module_t *self)</a>
<a name="ln1804">{</a>
<a name="ln1805">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln1806">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1807">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1808">  const int flip = dt_bauhaus_combobox_get(widget);</a>
<a name="ln1809">  p-&gt;cw = copysignf(p-&gt;cw, (flip &amp; 1) ? -1.0 : 1.0);</a>
<a name="ln1810">  p-&gt;ch = copysignf(p-&gt;ch, (flip &amp; 2) ? -1.0 : 1.0);</a>
<a name="ln1811">  commit_box(self, g, p);</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814">static void key_swap_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1815">                              GdkModifierType modifier, gpointer d)</a>
<a name="ln1816">{</a>
<a name="ln1817">  (void)accel_group;</a>
<a name="ln1818">  (void)acceleratable;</a>
<a name="ln1819">  (void)keyval;</a>
<a name="ln1820">  (void)modifier;</a>
<a name="ln1821">  dt_iop_module_t *self = (dt_iop_module_t *)d;</a>
<a name="ln1822">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1823">  p-&gt;ratio_d = -p-&gt;ratio_d;</a>
<a name="ln1824">  apply_box_aspect(self, GRAB_HORIZONTAL);</a>
<a name="ln1825">  dt_control_queue_redraw_center();</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828">static gboolean key_commit_callback(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln1829">                                    GdkModifierType modifier, gpointer data)</a>
<a name="ln1830">{</a>
<a name="ln1831">  dt_iop_module_t *self = (dt_iop_module_t *)data;</a>
<a name="ln1832">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1833">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1834">  commit_box(self, g, p);</a>
<a name="ln1835">  return TRUE;</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">static void aspect_flip(GtkWidget *button, dt_iop_module_t *self)</a>
<a name="ln1839">{</a>
<a name="ln1840">  key_swap_callback(NULL, NULL, 0, 0, self);</a>
<a name="ln1841">}</a>
<a name="ln1842"> </a>
<a name="ln1843">// TODO once we depend on GTK3 &gt;= 3.12 use the name as in 2f491cf8355a81554b98de538fe862d6ad9b62e5</a>
<a name="ln1844">static void guides_presets_set_visibility(dt_iop_clipping_gui_data_t *g, int which)</a>
<a name="ln1845">{</a>
<a name="ln1846">  if(which == 0)</a>
<a name="ln1847">  {</a>
<a name="ln1848">    gtk_widget_set_no_show_all(g-&gt;guides_widgets, TRUE);</a>
<a name="ln1849">    gtk_widget_hide(g-&gt;guides_widgets);</a>
<a name="ln1850">    gtk_widget_set_no_show_all(g-&gt;flip_guides, TRUE);</a>
<a name="ln1851">    gtk_widget_hide(g-&gt;flip_guides);</a>
<a name="ln1852">  }</a>
<a name="ln1853">  else</a>
<a name="ln1854">  {</a>
<a name="ln1855">    GtkWidget *widget = g_list_nth_data(g-&gt;guides_widgets_list, which - 1);</a>
<a name="ln1856">    if(widget)</a>
<a name="ln1857">    {</a>
<a name="ln1858">      gtk_widget_set_no_show_all(g-&gt;guides_widgets, FALSE);</a>
<a name="ln1859">      gtk_widget_show_all(g-&gt;guides_widgets);</a>
<a name="ln1860">      gtk_stack_set_visible_child(GTK_STACK(g-&gt;guides_widgets), widget);</a>
<a name="ln1861">    }</a>
<a name="ln1862">    else</a>
<a name="ln1863">    {</a>
<a name="ln1864">      gtk_widget_set_no_show_all(g-&gt;guides_widgets, TRUE);</a>
<a name="ln1865">      gtk_widget_hide(g-&gt;guides_widgets);</a>
<a name="ln1866">    }</a>
<a name="ln1867">    gtk_widget_set_no_show_all(g-&gt;flip_guides, FALSE);</a>
<a name="ln1868">    gtk_widget_show_all(g-&gt;flip_guides);</a>
<a name="ln1869">  }</a>
<a name="ln1870"> </a>
<a name="ln1871">  // TODO: add a support_flip flag to guides to hide the flip gui?</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">static void guides_presets_changed(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1875">{</a>
<a name="ln1876">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1877">  int which = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1878">  guides_presets_set_visibility(g, which);</a>
<a name="ln1879"> </a>
<a name="ln1880">  // remember setting</a>
<a name="ln1881">  dt_conf_set_int(&quot;plugins/darkroom/clipping/guide&quot;, which);</a>
<a name="ln1882"> </a>
<a name="ln1883">  dt_control_queue_redraw_center();</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886">static void guides_flip_changed(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1887">{</a>
<a name="ln1888">  int flip = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1889"> </a>
<a name="ln1890">  // remember setting</a>
<a name="ln1891">  dt_conf_set_int(&quot;plugins/darkroom/clipping/flip_guides&quot;, flip);</a>
<a name="ln1892"> </a>
<a name="ln1893">  dt_control_queue_redraw_center();</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">static void crop_auto_changed(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln1897">{</a>
<a name="ln1898">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1899">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1900"> </a>
<a name="ln1901">  if(dt_bauhaus_combobox_get(combo) == p-&gt;crop_auto) return; // no change</a>
<a name="ln1902">  p-&gt;crop_auto = dt_bauhaus_combobox_get(combo);</a>
<a name="ln1903">  commit_box(self, g, p);</a>
<a name="ln1904">  dt_control_queue_redraw_center();</a>
<a name="ln1905">}</a>
<a name="ln1906"> </a>
<a name="ln1907">static gint _aspect_ratio_cmp(const dt_iop_clipping_aspect_t *a, const dt_iop_clipping_aspect_t *b)</a>
<a name="ln1908">{</a>
<a name="ln1909">  // want most square at the end, and the most non-square at the beginning</a>
<a name="ln1910"> </a>
<a name="ln1911">  if((a-&gt;d == 0 || a-&gt;d == 1) &amp;&amp; a-&gt;n == 0) return -1;</a>
<a name="ln1912"> </a>
<a name="ln1913">  const float ad = MAX(a-&gt;d, a-&gt;n);</a>
<a name="ln1914">  const float an = MIN(a-&gt;d, a-&gt;n);</a>
<a name="ln1915">  const float bd = MAX(b-&gt;d, b-&gt;n);</a>
<a name="ln1916">  const float bn = MIN(b-&gt;d, b-&gt;n);</a>
<a name="ln1917">  const float aratio = ad / an;</a>
<a name="ln1918">  const float bratio = bd / bn;</a>
<a name="ln1919"> </a>
<a name="ln1920">  if(aratio &lt; bratio) return -1;</a>
<a name="ln1921"> </a>
<a name="ln1922">  float prec = 0.0003f;</a>
<a name="ln1923">  if(fabsf(aratio - bratio) &lt; prec) return 0;</a>
<a name="ln1924"> </a>
<a name="ln1925">  return 1;</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928"> </a>
<a name="ln1929">static gchar *format_aspect(gchar *original, int adim, int bdim)</a>
<a name="ln1930">{</a>
<a name="ln1931">  // Special ratios:  freehand, original image</a>
<a name="ln1932">  if ( bdim == 0 ) return g_strdup(original);</a>
<a name="ln1933"> </a>
<a name="ln1934">  return g_strdup_printf(&quot;%s  %4.2f&quot;, original, (float)adim / (float)bdim);</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937"> </a>
<a name="ln1938">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln1939">{</a>
<a name="ln1940">  self-&gt;gui_data = calloc(1, sizeof(dt_iop_clipping_gui_data_t));</a>
<a name="ln1941">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln1942">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln1943"> </a>
<a name="ln1944">  g-&gt;aspect_list = NULL;</a>
<a name="ln1945">  g-&gt;clip_x = g-&gt;clip_y = g-&gt;handle_x = g-&gt;handle_y = 0.0;</a>
<a name="ln1946">  g-&gt;clip_w = g-&gt;clip_h = 1.0;</a>
<a name="ln1947">  g-&gt;clip_max_x = g-&gt;clip_max_y = 0.0;</a>
<a name="ln1948">  g-&gt;clip_max_w = g-&gt;clip_max_h = 1.0;</a>
<a name="ln1949">  g-&gt;clip_max_pipe_hash = 0;</a>
<a name="ln1950">  g-&gt;cropping = 0;</a>
<a name="ln1951">  g-&gt;straightening = 0;</a>
<a name="ln1952">  g-&gt;applied = 1;</a>
<a name="ln1953">  g-&gt;center_lock = 0;</a>
<a name="ln1954">  g-&gt;k_drag = FALSE;</a>
<a name="ln1955">  g-&gt;k_show = -1;</a>
<a name="ln1956">  g-&gt;k_selected = -1;</a>
<a name="ln1957">  g-&gt;old_width = g-&gt;old_height = -1;</a>
<a name="ln1958"> </a>
<a name="ln1959">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln1960">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln1961">  g-&gt;hvflip = dt_bauhaus_combobox_new(self);</a>
<a name="ln1962">  dt_bauhaus_widget_set_label(g-&gt;hvflip, NULL, _(&quot;flip&quot;));</a>
<a name="ln1963">  dt_bauhaus_combobox_add(g-&gt;hvflip, _(&quot;none&quot;));</a>
<a name="ln1964">  dt_bauhaus_combobox_add(g-&gt;hvflip, _(&quot;horizontal&quot;));</a>
<a name="ln1965">  dt_bauhaus_combobox_add(g-&gt;hvflip, _(&quot;vertical&quot;));</a>
<a name="ln1966">  dt_bauhaus_combobox_add(g-&gt;hvflip, _(&quot;both&quot;));</a>
<a name="ln1967">  g_signal_connect(G_OBJECT(g-&gt;hvflip), &quot;value-changed&quot;, G_CALLBACK(hvflip_callback), self);</a>
<a name="ln1968">  gtk_widget_set_tooltip_text(g-&gt;hvflip, _(&quot;mirror image horizontally and/or vertically&quot;));</a>
<a name="ln1969">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;hvflip, TRUE, TRUE, 0);</a>
<a name="ln1970"> </a>
<a name="ln1971"> </a>
<a name="ln1972">  g-&gt;angle = dt_bauhaus_slider_new_with_range(self, -180.0, 180.0, 0.25, p-&gt;angle, 2);</a>
<a name="ln1973">  dt_bauhaus_widget_set_label(g-&gt;angle, NULL, _(&quot;angle&quot;));</a>
<a name="ln1974">  dt_bauhaus_slider_set_format(g-&gt;angle, &quot;%.02f°&quot;);</a>
<a name="ln1975">  g_signal_connect(G_OBJECT(g-&gt;angle), &quot;value-changed&quot;, G_CALLBACK(angle_callback), self);</a>
<a name="ln1976">  gtk_widget_set_tooltip_text(g-&gt;angle, _(&quot;right-click and drag a line on the image to drag a straight line&quot;));</a>
<a name="ln1977">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;angle, TRUE, TRUE, 0);</a>
<a name="ln1978"> </a>
<a name="ln1979">  g-&gt;keystone_type = dt_bauhaus_combobox_new(self);</a>
<a name="ln1980">  dt_bauhaus_widget_set_label(g-&gt;keystone_type, NULL, _(&quot;keystone&quot;));</a>
<a name="ln1981">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;none&quot;));</a>
<a name="ln1982">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;vertical&quot;));</a>
<a name="ln1983">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;horizontal&quot;));</a>
<a name="ln1984">  dt_bauhaus_combobox_add(g-&gt;keystone_type, _(&quot;full&quot;));</a>
<a name="ln1985">  gtk_widget_set_tooltip_text(g-&gt;keystone_type, _(&quot;set perspective correction for your image&quot;));</a>
<a name="ln1986">  g_signal_connect(G_OBJECT(g-&gt;keystone_type), &quot;value-changed&quot;, G_CALLBACK(keystone_type_changed), self);</a>
<a name="ln1987">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;keystone_type, TRUE, TRUE, 0);</a>
<a name="ln1988"> </a>
<a name="ln1989">  g-&gt;crop_auto = dt_bauhaus_combobox_new(self);</a>
<a name="ln1990">  dt_bauhaus_widget_set_label(g-&gt;crop_auto, NULL, _(&quot;automatic cropping&quot;));</a>
<a name="ln1991">  dt_bauhaus_combobox_add(g-&gt;crop_auto, _(&quot;no&quot;));</a>
<a name="ln1992">  dt_bauhaus_combobox_add(g-&gt;crop_auto, _(&quot;yes&quot;));</a>
<a name="ln1993">  gtk_widget_set_tooltip_text(g-&gt;crop_auto, _(&quot;automatically crop to avoid black edges&quot;));</a>
<a name="ln1994">  g_signal_connect(G_OBJECT(g-&gt;crop_auto), &quot;value-changed&quot;, G_CALLBACK(crop_auto_changed), self);</a>
<a name="ln1995">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;crop_auto, TRUE, TRUE, 0);</a>
<a name="ln1996"> </a>
<a name="ln1997">  dt_iop_clipping_aspect_t aspects[] = { { _(&quot;freehand&quot;), 0, 0 },</a>
<a name="ln1998">                                         { _(&quot;original image&quot;), 1, 0 },</a>
<a name="ln1999">                                         { _(&quot;square&quot;), 1, 1 },</a>
<a name="ln2000">                                         { _(&quot;10:8 in print&quot;), 2445, 2032 },</a>
<a name="ln2001">                                         { _(&quot;5:4, 4x5, 8x10&quot;), 5, 4 },</a>
<a name="ln2002">                                         { _(&quot;11x14&quot;), 14, 11 },</a>
<a name="ln2003">                                         { _(&quot;8.5x11, letter&quot;), 110, 85 },</a>
<a name="ln2004">                                         { _(&quot;4:3, VGA, TV&quot;), 4, 3 },</a>
<a name="ln2005">                                         { _(&quot;5x7&quot;), 7, 5 },</a>
<a name="ln2006">                                         { _(&quot;ISO 216, DIN 476, A4&quot;), 14142136, 10000000 },</a>
<a name="ln2007">                                         { _(&quot;3:2, 4x6, 35mm&quot;), 3, 2 },</a>
<a name="ln2008">                                         { _(&quot;16:10, 8x5&quot;), 16, 10 },</a>
<a name="ln2009">                                         { _(&quot;golden cut&quot;), 16180340, 10000000 },</a>
<a name="ln2010">                                         { _(&quot;16:9, HDTV&quot;), 16, 9 },</a>
<a name="ln2011">                                         { _(&quot;widescreen&quot;), 185, 100 },</a>
<a name="ln2012">                                         { _(&quot;2:1, univisium&quot;), 2, 1 },</a>
<a name="ln2013">                                         { _(&quot;cinemascope&quot;), 235, 100 },</a>
<a name="ln2014">                                         { _(&quot;21:9&quot;), 237, 100 },</a>
<a name="ln2015">                                         { _(&quot;anamorphic&quot;), 239, 100 },</a>
<a name="ln2016">                                         { _(&quot;3:1, panorama&quot;), 300, 100 },</a>
<a name="ln2017">  };</a>
<a name="ln2018"> </a>
<a name="ln2019">  const int aspects_count = sizeof(aspects) / sizeof(dt_iop_clipping_aspect_t);</a>
<a name="ln2020"> </a>
<a name="ln2021">  for(int i = 0; i &lt; aspects_count; i++)</a>
<a name="ln2022">  {</a>
<a name="ln2023">    dt_iop_clipping_aspect_t *aspect = g_malloc(sizeof(dt_iop_clipping_aspect_t));</a>
<a name="ln2024">    aspect-&gt;name = format_aspect(aspects[i].name, aspects[i].d, aspects[i].n);</a>
<a name="ln2025">    aspect-&gt;d = aspects[i].d;</a>
<a name="ln2026">    aspect-&gt;n = aspects[i].n;</a>
<a name="ln2027">    g-&gt;aspect_list = g_list_append(g-&gt;aspect_list, aspect);</a>
<a name="ln2028">  }</a>
<a name="ln2029"> </a>
<a name="ln2030">  // add custom presets from config to the list</a>
<a name="ln2031">  GSList *custom_aspects = dt_conf_all_string_entries(&quot;plugins/darkroom/clipping/extra_aspect_ratios&quot;);</a>
<a name="ln2032">  for(GSList *iter = custom_aspects; iter; iter = g_slist_next(iter))</a>
<a name="ln2033">  {</a>
<a name="ln2034">    dt_conf_string_entry_t *nv = (dt_conf_string_entry_t *)iter-&gt;data;</a>
<a name="ln2035"> </a>
<a name="ln2036">    const char *c = nv-&gt;value;</a>
<a name="ln2037">    const char *end = nv-&gt;value + strlen(nv-&gt;value);</a>
<a name="ln2038">    while(*c != ':' &amp;&amp; *c != '/' &amp;&amp; c &lt; end) c++;</a>
<a name="ln2039">    if(c &lt; end - 1)</a>
<a name="ln2040">    {</a>
<a name="ln2041">      c++;</a>
<a name="ln2042">      int d = atoi(nv-&gt;value);</a>
<a name="ln2043">      int n = atoi(c);</a>
<a name="ln2044">      // some sanity check</a>
<a name="ln2045">      if(n == 0 || d == 0)</a>
<a name="ln2046">      {</a>
<a name="ln2047">        fprintf(stderr, &quot;invalid ratio format for `%s'. it should be \&quot;number:number\&quot;\n&quot;, nv-&gt;key);</a>
<a name="ln2048">        dt_control_log(_(&quot;invalid ratio format for `%s'. it should be \&quot;number:number\&quot;&quot;), nv-&gt;key);</a>
<a name="ln2049">        continue;</a>
<a name="ln2050">      }</a>
<a name="ln2051">      dt_iop_clipping_aspect_t *aspect = g_malloc(sizeof(dt_iop_clipping_aspect_t));</a>
<a name="ln2052">      aspect-&gt;name = format_aspect(nv-&gt;key, d, n);</a>
<a name="ln2053">      aspect-&gt;d = d;</a>
<a name="ln2054">      aspect-&gt;n = n;</a>
<a name="ln2055">      g-&gt;aspect_list = g_list_append(g-&gt;aspect_list, aspect);</a>
<a name="ln2056">    }</a>
<a name="ln2057">    else</a>
<a name="ln2058">    {</a>
<a name="ln2059">      fprintf(stderr, &quot;invalid ratio format for `%s'. it should be \&quot;number:number\&quot;\n&quot;, nv-&gt;key);</a>
<a name="ln2060">      dt_control_log(_(&quot;invalid ratio format for `%s'. it should be \&quot;number:number\&quot;&quot;), nv-&gt;key);</a>
<a name="ln2061">      continue;</a>
<a name="ln2062">    }</a>
<a name="ln2063"> </a>
<a name="ln2064">  }</a>
<a name="ln2065">  g_slist_free_full(custom_aspects, dt_conf_string_entry_free);</a>
<a name="ln2066"> </a>
<a name="ln2067"> </a>
<a name="ln2068">  g-&gt;aspect_list = g_list_sort(g-&gt;aspect_list, (GCompareFunc)_aspect_ratio_cmp);</a>
<a name="ln2069"> </a>
<a name="ln2070">  // remove duplicates from the aspect ratio list</a>
<a name="ln2071">  int d = ((dt_iop_clipping_aspect_t *)g-&gt;aspect_list-&gt;data)-&gt;d + 1,</a>
<a name="ln2072">      n = ((dt_iop_clipping_aspect_t *)g-&gt;aspect_list-&gt;data)-&gt;n + 1;</a>
<a name="ln2073">  for(GList *iter = g-&gt;aspect_list; iter; iter = g_list_next(iter))</a>
<a name="ln2074">  {</a>
<a name="ln2075">    dt_iop_clipping_aspect_t *aspect = (dt_iop_clipping_aspect_t *)iter-&gt;data;</a>
<a name="ln2076">    int dd = MIN(aspect-&gt;d, aspect-&gt;n);</a>
<a name="ln2077">    int nn = MAX(aspect-&gt;d, aspect-&gt;n);</a>
<a name="ln2078">    if(dd == d &amp;&amp; nn == n)</a>
<a name="ln2079">    {</a>
<a name="ln2080">      // same as the last one, remove this entry</a>
<a name="ln2081">      g_free(aspect-&gt;name);</a>
<a name="ln2082">      GList *prev = g_list_previous(iter);</a>
<a name="ln2083">      g-&gt;aspect_list = g_list_delete_link(g-&gt;aspect_list, iter);</a>
<a name="ln2084">      // it should never be NULL as the 1st element can't be a duplicate, but better safe than sorry</a>
<a name="ln2085">      iter = prev ? prev : g-&gt;aspect_list;</a>
<a name="ln2086">    }</a>
<a name="ln2087">    else</a>
<a name="ln2088">    {</a>
<a name="ln2089">      d = dd;</a>
<a name="ln2090">      n = nn;</a>
<a name="ln2091">    }</a>
<a name="ln2092">  }</a>
<a name="ln2093"> </a>
<a name="ln2094">  g-&gt;aspect_presets = dt_bauhaus_combobox_new(self);</a>
<a name="ln2095">  dt_bauhaus_combobox_set_editable(g-&gt;aspect_presets, 1);</a>
<a name="ln2096">  dt_bauhaus_widget_set_label(g-&gt;aspect_presets, NULL, _(&quot;aspect&quot;));</a>
<a name="ln2097"> </a>
<a name="ln2098">  for(GList *iter = g-&gt;aspect_list; iter; iter = g_list_next(iter))</a>
<a name="ln2099">  {</a>
<a name="ln2100">    const dt_iop_clipping_aspect_t *aspect = iter-&gt;data;</a>
<a name="ln2101">    dt_bauhaus_combobox_add(g-&gt;aspect_presets, aspect-&gt;name);</a>
<a name="ln2102">  }</a>
<a name="ln2103"> </a>
<a name="ln2104">  dt_bauhaus_combobox_set(g-&gt;aspect_presets, 0);</a>
<a name="ln2105"> </a>
<a name="ln2106">  g_signal_connect(G_OBJECT(g-&gt;aspect_presets), &quot;value-changed&quot;, G_CALLBACK(aspect_presets_changed), self);</a>
<a name="ln2107">  gtk_widget_set_tooltip_text(g-&gt;aspect_presets, _(&quot;set the aspect ratio\n&quot;</a>
<a name="ln2108">                                                   &quot;the list is sorted: from most square to least square&quot;));</a>
<a name="ln2109">  dt_bauhaus_widget_set_quad_paint(g-&gt;aspect_presets, dtgtk_cairo_paint_aspectflip, 0, NULL);</a>
<a name="ln2110">  g_signal_connect(G_OBJECT(g-&gt;aspect_presets), &quot;quad-pressed&quot;, G_CALLBACK(aspect_flip), self);</a>
<a name="ln2111">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;aspect_presets, TRUE, TRUE, 0);</a>
<a name="ln2112"> </a>
<a name="ln2113">  g-&gt;guide_lines = dt_bauhaus_combobox_new(self);</a>
<a name="ln2114">  dt_bauhaus_widget_set_label(g-&gt;guide_lines, NULL, _(&quot;guides&quot;));</a>
<a name="ln2115">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;guide_lines, TRUE, TRUE, 0);</a>
<a name="ln2116"> </a>
<a name="ln2117">  g-&gt;guides_widgets = gtk_stack_new();</a>
<a name="ln2118">  gtk_stack_set_homogeneous(GTK_STACK(g-&gt;guides_widgets), FALSE);</a>
<a name="ln2119">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;guides_widgets, TRUE, TRUE, 0);</a>
<a name="ln2120"> </a>
<a name="ln2121">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;none&quot;));</a>
<a name="ln2122">  int i = 0;</a>
<a name="ln2123">  for(GList *iter = darktable.guides; iter; iter = g_list_next(iter), i++)</a>
<a name="ln2124">  {</a>
<a name="ln2125">    GtkWidget *widget = NULL;</a>
<a name="ln2126">    dt_guides_t *guide = (dt_guides_t *)iter-&gt;data;</a>
<a name="ln2127">    dt_bauhaus_combobox_add(g-&gt;guide_lines, _(guide-&gt;name));</a>
<a name="ln2128">    if(guide-&gt;widget)</a>
<a name="ln2129">    {</a>
<a name="ln2130">      // generate some unique name so that we can have the same name several times</a>
<a name="ln2131">      char name[5];</a>
<a name="ln2132">      snprintf(name, sizeof(name), &quot;%d&quot;, i);</a>
<a name="ln2133">      widget = guide-&gt;widget(self, guide-&gt;user_data);</a>
<a name="ln2134">      gtk_widget_show_all(widget);</a>
<a name="ln2135">      gtk_stack_add_named(GTK_STACK(g-&gt;guides_widgets), widget, name);</a>
<a name="ln2136">    }</a>
<a name="ln2137">    g-&gt;guides_widgets_list = g_list_append(g-&gt;guides_widgets_list, widget);</a>
<a name="ln2138">  }</a>
<a name="ln2139"> </a>
<a name="ln2140">  int guide = dt_conf_get_int(&quot;plugins/darkroom/clipping/guide&quot;);</a>
<a name="ln2141">  dt_bauhaus_combobox_set(g-&gt;guide_lines, guide);</a>
<a name="ln2142"> </a>
<a name="ln2143">  gtk_widget_set_tooltip_text(g-&gt;guide_lines, _(&quot;display guide lines to help compose your photograph&quot;));</a>
<a name="ln2144">  g_signal_connect(G_OBJECT(g-&gt;guide_lines), &quot;value-changed&quot;, G_CALLBACK(guides_presets_changed), self);</a>
<a name="ln2145"> </a>
<a name="ln2146">  g-&gt;flip_guides = dt_bauhaus_combobox_new(self);</a>
<a name="ln2147">  dt_bauhaus_widget_set_label(g-&gt;flip_guides, NULL, _(&quot;flip guides&quot;));</a>
<a name="ln2148">  dt_bauhaus_combobox_add(g-&gt;flip_guides, _(&quot;none&quot;));</a>
<a name="ln2149">  dt_bauhaus_combobox_add(g-&gt;flip_guides, _(&quot;horizontally&quot;));</a>
<a name="ln2150">  dt_bauhaus_combobox_add(g-&gt;flip_guides, _(&quot;vertically&quot;));</a>
<a name="ln2151">  dt_bauhaus_combobox_add(g-&gt;flip_guides, _(&quot;both&quot;));</a>
<a name="ln2152">  gtk_widget_set_tooltip_text(g-&gt;flip_guides, _(&quot;flip guides&quot;));</a>
<a name="ln2153">  g_signal_connect(G_OBJECT(g-&gt;flip_guides), &quot;value-changed&quot;, G_CALLBACK(guides_flip_changed), self);</a>
<a name="ln2154">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;flip_guides, TRUE, TRUE, 0);</a>
<a name="ln2155">  dt_bauhaus_combobox_set(g-&gt;flip_guides, dt_conf_get_int(&quot;plugins/darkroom/clipping/flip_guides&quot;));</a>
<a name="ln2156"> </a>
<a name="ln2157">  guides_presets_set_visibility(g, guide);</a>
<a name="ln2158">}</a>
<a name="ln2159"> </a>
<a name="ln2160">static void free_aspect(gpointer data)</a>
<a name="ln2161">{</a>
<a name="ln2162">  dt_iop_clipping_aspect_t *aspect = (dt_iop_clipping_aspect_t *)data;</a>
<a name="ln2163">  g_free(aspect-&gt;name);</a>
<a name="ln2164">  aspect-&gt;name = NULL;</a>
<a name="ln2165">  g_free(aspect);</a>
<a name="ln2166">}</a>
<a name="ln2167"> </a>
<a name="ln2168">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln2169">{</a>
<a name="ln2170">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2171">  g_list_free_full(g-&gt;aspect_list, free_aspect);</a>
<a name="ln2172">  g-&gt;aspect_list = NULL;</a>
<a name="ln2173">  free(self-&gt;gui_data);</a>
<a name="ln2174">  self-&gt;gui_data = NULL;</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">static _grab_region_t get_grab(float pzx, float pzy, dt_iop_clipping_gui_data_t *g, const float border,</a>
<a name="ln2178">                               const float wd, const float ht)</a>
<a name="ln2179">{</a>
<a name="ln2180">  _grab_region_t grab = GRAB_NONE;</a>
<a name="ln2181">  if(!(pzx &lt; g-&gt;clip_x || pzx &gt; g-&gt;clip_x + g-&gt;clip_w || pzy &lt; g-&gt;clip_y || pzy &gt; g-&gt;clip_y + g-&gt;clip_h))</a>
<a name="ln2182">  {</a>
<a name="ln2183">    // we are inside the crop box</a>
<a name="ln2184">    grab = GRAB_CENTER;</a>
<a name="ln2185">    if(pzx &gt;= g-&gt;clip_x &amp;&amp; pzx * wd &lt; g-&gt;clip_x * wd + border) grab |= GRAB_LEFT; // left border</a>
<a name="ln2186">    if(pzy &gt;= g-&gt;clip_y &amp;&amp; pzy * ht &lt; g-&gt;clip_y * ht + border) grab |= GRAB_TOP;  // top border</a>
<a name="ln2187">    if(pzx &lt;= g-&gt;clip_x + g-&gt;clip_w &amp;&amp; pzx * wd &gt; (g-&gt;clip_w + g-&gt;clip_x) * wd - border)</a>
<a name="ln2188">      grab |= GRAB_RIGHT; // right border</a>
<a name="ln2189">    if(pzy &lt;= g-&gt;clip_y + g-&gt;clip_h &amp;&amp; pzy * ht &gt; (g-&gt;clip_h + g-&gt;clip_y) * ht - border)</a>
<a name="ln2190">      grab |= GRAB_BOTTOM; // bottom border</a>
<a name="ln2191">  }</a>
<a name="ln2192">  return grab;</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">// draw rounded rectangle</a>
<a name="ln2196">static void gui_draw_rounded_rectangle(cairo_t *cr, int width, int height, int x, int y)</a>
<a name="ln2197">{</a>
<a name="ln2198">  float radius = height / 5.0f;</a>
<a name="ln2199">  float degrees = M_PI / 180.0;</a>
<a name="ln2200">  cairo_new_sub_path(cr);</a>
<a name="ln2201">  cairo_arc(cr, x + width - radius, y + radius, radius, -90 * degrees, 0 * degrees);</a>
<a name="ln2202">  cairo_arc(cr, x + width - radius, y + height - radius, radius, 0 * degrees, 90 * degrees);</a>
<a name="ln2203">  cairo_arc(cr, x + radius, y + height - radius, radius, 90 * degrees, 180 * degrees);</a>
<a name="ln2204">  cairo_arc(cr, x + radius, y + radius, radius, 180 * degrees, 270 * degrees);</a>
<a name="ln2205">  cairo_close_path(cr);</a>
<a name="ln2206">  cairo_fill(cr);</a>
<a name="ln2207">}</a>
<a name="ln2208">// draw symmetry signs</a>
<a name="ln2209">static void gui_draw_sym(cairo_t *cr, float x, float y, gboolean active)</a>
<a name="ln2210">{</a>
<a name="ln2211">  PangoLayout *layout;</a>
<a name="ln2212">  PangoRectangle ink;</a>
<a name="ln2213">  PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln2214">  pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln2215">  pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(16) * PANGO_SCALE);</a>
<a name="ln2216">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln2217">  pango_layout_set_font_description(layout, desc);</a>
<a name="ln2218">  pango_layout_set_text(layout, &quot;ꝏ&quot;, -1);</a>
<a name="ln2219">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln2220">  cairo_set_source_rgba(cr, .5, .5, .5, .7);</a>
<a name="ln2221">  gui_draw_rounded_rectangle(</a>
<a name="ln2222">      cr, ink.width + DT_PIXEL_APPLY_DPI(4), ink.height + DT_PIXEL_APPLY_DPI(8),</a>
<a name="ln2223">      x - ink.width / 2.0f - DT_PIXEL_APPLY_DPI(2), y - ink.height / 2.0f - DT_PIXEL_APPLY_DPI(4));</a>
<a name="ln2224">  cairo_move_to(cr, x - ink.width / 2.0f, y - 3.0 * ink.height / 4.0f - DT_PIXEL_APPLY_DPI(4));</a>
<a name="ln2225">  if(active)</a>
<a name="ln2226">    cairo_set_source_rgba(cr, 1.0, 0.0, 0.0, .9);</a>
<a name="ln2227">  else</a>
<a name="ln2228">    cairo_set_source_rgba(cr, .2, .2, .2, .9);</a>
<a name="ln2229">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln2230">  pango_font_description_free(desc);</a>
<a name="ln2231">  g_object_unref(layout);</a>
<a name="ln2232">}</a>
<a name="ln2233"> </a>
<a name="ln2234">// draw guides and handles over the image</a>
<a name="ln2235">void gui_post_expose(struct dt_iop_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln2236">                     int32_t pointerx, int32_t pointery)</a>
<a name="ln2237">{</a>
<a name="ln2238">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln2239">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2240">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln2241"> </a>
<a name="ln2242">  // we don't do anything if the image is not ready</a>
<a name="ln2243">  if(self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width == g-&gt;old_width</a>
<a name="ln2244">     &amp;&amp; self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height == g-&gt;old_height)</a>
<a name="ln2245">    return;</a>
<a name="ln2246">  g-&gt;old_width = g-&gt;old_height = -1;</a>
<a name="ln2247"> </a>
<a name="ln2248">  // reapply box aspect to be sure that the ratio has not been modified by the keystone transform</a>
<a name="ln2249">  apply_box_aspect(self, GRAB_HORIZONTAL);</a>
<a name="ln2250"> </a>
<a name="ln2251">  float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2252">  float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2253">  float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln2254">  float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln2255">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln2256">  int closeup = dt_control_get_dev_closeup();</a>
<a name="ln2257">  float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln2258"> </a>
<a name="ln2259">  cairo_translate(cr, width / 2.0, height / 2.0f);</a>
<a name="ln2260">  cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln2261">  cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln2262"> </a>
<a name="ln2263">  double dashes = DT_PIXEL_APPLY_DPI(5.0) / zoom_scale;</a>
<a name="ln2264"> </a>
<a name="ln2265">  // draw cropping window</a>
<a name="ln2266">  float pzx, pzy;</a>
<a name="ln2267">  dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln2268">  pzx += 0.5f;</a>
<a name="ln2269">  pzy += 0.5f;</a>
<a name="ln2270">  if(_iop_clipping_set_max_clip(self))</a>
<a name="ln2271">  {</a>
<a name="ln2272">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln2273">    cairo_set_source_rgba(cr, .2, .2, .2, .8);</a>
<a name="ln2274">    cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln2275">    cairo_rectangle(cr, g-&gt;clip_max_x * wd - 1.0f, g-&gt;clip_max_y * ht - 1.0f, g-&gt;clip_max_w * wd + 1.0f,</a>
<a name="ln2276">                    g-&gt;clip_max_h * ht + 1.0f);</a>
<a name="ln2277">    cairo_rectangle(cr, g-&gt;clip_x * wd, g-&gt;clip_y * ht, g-&gt;clip_w * wd, g-&gt;clip_h * ht);</a>
<a name="ln2278">    cairo_fill(cr);</a>
<a name="ln2279">  }</a>
<a name="ln2280">  if(g-&gt;clip_x &gt; .0f || g-&gt;clip_y &gt; .0f || g-&gt;clip_w &lt; 1.0f || g-&gt;clip_h &lt; 1.0f)</a>
<a name="ln2281">  {</a>
<a name="ln2282">    cairo_set_line_width(cr, dashes / 2.0);</a>
<a name="ln2283">    cairo_rectangle(cr, g-&gt;clip_x * wd, g-&gt;clip_y * ht, g-&gt;clip_w * wd, g-&gt;clip_h * ht);</a>
<a name="ln2284">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln2285">    cairo_stroke(cr);</a>
<a name="ln2286">  }</a>
<a name="ln2287"> </a>
<a name="ln2288">  // draw cropping window dimensions if first mouse button is pressed</a>
<a name="ln2289">  if(darktable.control-&gt;button_down &amp;&amp; darktable.control-&gt;button_down_which == 1 &amp;&amp; g-&gt;k_show != 1)</a>
<a name="ln2290">  {</a>
<a name="ln2291">    char dimensions[16];</a>
<a name="ln2292">    dimensions[0] = '\0';</a>
<a name="ln2293">    PangoLayout *layout;</a>
<a name="ln2294">    PangoRectangle ink;</a>
<a name="ln2295">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln2296">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln2297">    pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(16) * PANGO_SCALE / zoom_scale);</a>
<a name="ln2298">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln2299">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln2300"> </a>
<a name="ln2301">    int procw, proch;</a>
<a name="ln2302">    dt_dev_get_processed_size(dev, &amp;procw, &amp;proch);</a>
<a name="ln2303">    snprintf(dimensions, sizeof(dimensions), &quot;%.0fx%.0f&quot;, (float)procw * g-&gt;clip_w, (float)proch * g-&gt;clip_h);</a>
<a name="ln2304"> </a>
<a name="ln2305">    pango_layout_set_text(layout, dimensions, -1);</a>
<a name="ln2306">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln2307">    cairo_move_to(cr, (g-&gt;clip_x + g-&gt;clip_w / 2) * wd - ink.width * .5f,</a>
<a name="ln2308">                  (g-&gt;clip_y + g-&gt;clip_h / 2) * ht - ink.height * .5f);</a>
<a name="ln2309">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln2310">    pango_font_description_free(desc);</a>
<a name="ln2311">    g_object_unref(layout);</a>
<a name="ln2312">  }</a>
<a name="ln2313"> </a>
<a name="ln2314">  // draw crop area guides</a>
<a name="ln2315">  int guide_flip = dt_bauhaus_combobox_get(g-&gt;flip_guides);</a>
<a name="ln2316">  float left = g-&gt;clip_x * wd;</a>
<a name="ln2317">  float top = g-&gt;clip_y * ht;</a>
<a name="ln2318">  float cwidth = g-&gt;clip_w * wd;</a>
<a name="ln2319">  float cheight = g-&gt;clip_h * ht;</a>
<a name="ln2320"> </a>
<a name="ln2321">  // save context</a>
<a name="ln2322">  cairo_save(cr);</a>
<a name="ln2323">  cairo_rectangle(cr, left, top, cwidth, cheight);</a>
<a name="ln2324">  cairo_clip(cr);</a>
<a name="ln2325">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0) / zoom_scale);</a>
<a name="ln2326">  cairo_set_source_rgb(cr, .8, .8, .8);</a>
<a name="ln2327">  cairo_set_dash(cr, &amp;dashes, 1, 0);</a>
<a name="ln2328"> </a>
<a name="ln2329">  // Move coordinates to local center selection.</a>
<a name="ln2330">  cairo_translate(cr, (cwidth / 2 + left), (cheight / 2 + top));</a>
<a name="ln2331"> </a>
<a name="ln2332">  // Flip horizontal.</a>
<a name="ln2333">  if(guide_flip &amp; FLAG_FLIP_HORIZONTAL) cairo_scale(cr, -1, 1);</a>
<a name="ln2334">  // Flip vertical.</a>
<a name="ln2335">  if(guide_flip &amp; FLAG_FLIP_VERTICAL) cairo_scale(cr, 1, -1);</a>
<a name="ln2336"> </a>
<a name="ln2337">  int which = dt_bauhaus_combobox_get(g-&gt;guide_lines);</a>
<a name="ln2338">  dt_guides_t *guide = (dt_guides_t *)g_list_nth_data(darktable.guides, which - 1);</a>
<a name="ln2339">  if(guide)</a>
<a name="ln2340">  {</a>
<a name="ln2341">    guide-&gt;draw(cr, -cwidth / 2, -cheight / 2, cwidth, cheight, zoom_scale, guide-&gt;user_data);</a>
<a name="ln2342">    cairo_stroke_preserve(cr);</a>
<a name="ln2343">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln2344">    cairo_set_source_rgba(cr, 0.3, .3, .3, .8);</a>
<a name="ln2345">    cairo_stroke(cr);</a>
<a name="ln2346">  }</a>
<a name="ln2347">  cairo_restore(cr);</a>
<a name="ln2348"> </a>
<a name="ln2349">  cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0) / zoom_scale);</a>
<a name="ln2350">  cairo_set_source_rgb(cr, .3, .3, .3);</a>
<a name="ln2351">  const int border = DT_PIXEL_APPLY_DPI(30.0) / zoom_scale;</a>
<a name="ln2352">  if(g-&gt;straightening)</a>
<a name="ln2353">  {</a>
<a name="ln2354">    PangoRectangle ink;</a>
<a name="ln2355">    PangoLayout *layout;</a>
<a name="ln2356">    PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln2357">    pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln2358">    pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(16) * PANGO_SCALE / zoom_scale);</a>
<a name="ln2359">    layout = pango_cairo_create_layout(cr);</a>
<a name="ln2360">    pango_layout_set_font_description(layout, desc);</a>
<a name="ln2361">    float bzx = g-&gt;button_down_zoom_x + .5f, bzy = g-&gt;button_down_zoom_y + .5f;</a>
<a name="ln2362">    cairo_arc(cr, bzx * wd, bzy * ht, DT_PIXEL_APPLY_DPI(3), 0, 2.0 * M_PI);</a>
<a name="ln2363">    cairo_stroke(cr);</a>
<a name="ln2364">    cairo_arc(cr, pzx * wd, pzy * ht, DT_PIXEL_APPLY_DPI(3), 0, 2.0 * M_PI);</a>
<a name="ln2365">    cairo_stroke(cr);</a>
<a name="ln2366">    cairo_move_to(cr, bzx * wd, bzy * ht);</a>
<a name="ln2367">    cairo_line_to(cr, pzx * wd, pzy * ht);</a>
<a name="ln2368">    cairo_stroke(cr);</a>
<a name="ln2369"> </a>
<a name="ln2370">    // show rotation angle</a>
<a name="ln2371">    float dx = pzx * wd - bzx * wd, dy = pzy * ht - bzy * ht;</a>
<a name="ln2372">    if(dx &lt; 0)</a>
<a name="ln2373">    {</a>
<a name="ln2374">      dx = -dx;</a>
<a name="ln2375">      dy = -dy;</a>
<a name="ln2376">    }</a>
<a name="ln2377">    float angle = atan2f(dy, dx);</a>
<a name="ln2378">    angle = angle * 180 / M_PI;</a>
<a name="ln2379">    if(angle &gt; 45.0) angle -= 90;</a>
<a name="ln2380">    if(angle &lt; -45.0) angle += 90;</a>
<a name="ln2381"> </a>
<a name="ln2382">    char view_angle[16];</a>
<a name="ln2383">    view_angle[0] = '\0';</a>
<a name="ln2384">    snprintf(view_angle, sizeof(view_angle), &quot;%.2f°&quot;, angle);</a>
<a name="ln2385">    pango_layout_set_text(layout, view_angle, -1);</a>
<a name="ln2386">    pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln2387">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln2388">    cairo_move_to(cr, pzx * wd + DT_PIXEL_APPLY_DPI(20) / zoom_scale, pzy * ht - ink.height);</a>
<a name="ln2389">    pango_cairo_show_layout(cr, layout);</a>
<a name="ln2390">    pango_font_description_free(desc);</a>
<a name="ln2391">    g_object_unref(layout);</a>
<a name="ln2392">  }</a>
<a name="ln2393">  else if(g-&gt;k_show != 1)</a>
<a name="ln2394">  {</a>
<a name="ln2395">    _grab_region_t grab = g-&gt;cropping ? g-&gt;cropping : get_grab(pzx, pzy, g, border, wd, ht);</a>
<a name="ln2396">    if(grab == GRAB_LEFT) cairo_rectangle(cr, g-&gt;clip_x * wd, g-&gt;clip_y * ht, border, g-&gt;clip_h * ht);</a>
<a name="ln2397">    if(grab == GRAB_TOP) cairo_rectangle(cr, g-&gt;clip_x * wd, g-&gt;clip_y * ht, g-&gt;clip_w * wd, border);</a>
<a name="ln2398">    if(grab == GRAB_TOP_LEFT) cairo_rectangle(cr, g-&gt;clip_x * wd, g-&gt;clip_y * ht, border, border);</a>
<a name="ln2399">    if(grab == GRAB_RIGHT)</a>
<a name="ln2400">      cairo_rectangle(cr, (g-&gt;clip_x + g-&gt;clip_w) * wd - border, g-&gt;clip_y * ht, border, g-&gt;clip_h * ht);</a>
<a name="ln2401">    if(grab == GRAB_BOTTOM)</a>
<a name="ln2402">      cairo_rectangle(cr, g-&gt;clip_x * wd, (g-&gt;clip_y + g-&gt;clip_h) * ht - border, g-&gt;clip_w * wd, border);</a>
<a name="ln2403">    if(grab == GRAB_BOTTOM_RIGHT)</a>
<a name="ln2404">      cairo_rectangle(cr, (g-&gt;clip_x + g-&gt;clip_w) * wd - border, (g-&gt;clip_y + g-&gt;clip_h) * ht - border,</a>
<a name="ln2405">                      border, border);</a>
<a name="ln2406">    if(grab == GRAB_TOP_RIGHT)</a>
<a name="ln2407">      cairo_rectangle(cr, (g-&gt;clip_x + g-&gt;clip_w) * wd - border, g-&gt;clip_y * ht, border, border);</a>
<a name="ln2408">    if(grab == GRAB_BOTTOM_LEFT)</a>
<a name="ln2409">      cairo_rectangle(cr, g-&gt;clip_x * wd, (g-&gt;clip_y + g-&gt;clip_h) * ht - border, border, border);</a>
<a name="ln2410">    cairo_stroke(cr);</a>
<a name="ln2411">  }</a>
<a name="ln2412"> </a>
<a name="ln2413">  // draw keystone points and lines</a>
<a name="ln2414">  if(g-&gt;k_show == 1 &amp;&amp; p-&gt;k_type &gt; 0)</a>
<a name="ln2415">  {</a>
<a name="ln2416">    // points in screen space</a>
<a name="ln2417">    dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln2418">    if(!piece) return;</a>
<a name="ln2419"> </a>
<a name="ln2420">    float wp = piece-&gt;buf_out.width, hp = piece-&gt;buf_out.height;</a>
<a name="ln2421">    float pts[8] = { p-&gt;kxa * wp, p-&gt;kya * hp, p-&gt;kxb * wp, p-&gt;kyb * hp,</a>
<a name="ln2422">                     p-&gt;kxc * wp, p-&gt;kyc * hp, p-&gt;kxd * wp, p-&gt;kyd * hp };</a>
<a name="ln2423">    if(dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, pts, 4))</a>
<a name="ln2424">    {</a>
<a name="ln2425">      if(p-&gt;k_type == 3)</a>
<a name="ln2426">      {</a>
<a name="ln2427">        // determine extremity of the lines</a>
<a name="ln2428">        int v1t = pts[0] - (pts[6] - pts[0]) * pts[1] / (pts[7] - pts[1]);</a>
<a name="ln2429">        int v1b = (pts[6] - pts[0]) * ht / (pts[7] - pts[1]) + v1t;</a>
<a name="ln2430">        int v2t = pts[2] - (pts[4] - pts[2]) * pts[3] / (pts[5] - pts[3]);</a>
<a name="ln2431">        int v2b = (pts[4] - pts[2]) * ht / (pts[5] - pts[3]) + v2t;</a>
<a name="ln2432">        int h1l = pts[1] - (pts[3] - pts[1]) * pts[0] / (pts[2] - pts[0]);</a>
<a name="ln2433">        int h1r = (pts[3] - pts[1]) * wd / (pts[2] - pts[0]) + h1l;</a>
<a name="ln2434">        int h2l = pts[7] - (pts[5] - pts[7]) * pts[6] / (pts[4] - pts[6]);</a>
<a name="ln2435">        int h2r = (pts[5] - pts[7]) * wd / (pts[4] - pts[6]) + h2l;</a>
<a name="ln2436"> </a>
<a name="ln2437">        // draw the lines</a>
<a name="ln2438">        cairo_move_to(cr, v1t, 0);</a>
<a name="ln2439">        cairo_line_to(cr, v1b, ht);</a>
<a name="ln2440">        cairo_stroke(cr);</a>
<a name="ln2441">        cairo_move_to(cr, v2t, 0);</a>
<a name="ln2442">        cairo_line_to(cr, v2b, ht);</a>
<a name="ln2443">        cairo_stroke(cr);</a>
<a name="ln2444">        cairo_move_to(cr, 0, h1l);</a>
<a name="ln2445">        cairo_line_to(cr, wd, h1r);</a>
<a name="ln2446">        cairo_stroke(cr);</a>
<a name="ln2447">        cairo_move_to(cr, 0, h2l);</a>
<a name="ln2448">        cairo_line_to(cr, wd, h2r);</a>
<a name="ln2449">        cairo_stroke(cr);</a>
<a name="ln2450">        // redraw selected one</a>
<a name="ln2451">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2452">        if(g-&gt;k_selected_segment == 0)</a>
<a name="ln2453">        {</a>
<a name="ln2454">          cairo_move_to(cr, pts[0], pts[1]);</a>
<a name="ln2455">          cairo_line_to(cr, pts[2], pts[3]);</a>
<a name="ln2456">          cairo_stroke(cr);</a>
<a name="ln2457">        }</a>
<a name="ln2458">        else if(g-&gt;k_selected_segment == 1)</a>
<a name="ln2459">        {</a>
<a name="ln2460">          cairo_move_to(cr, pts[4], pts[5]);</a>
<a name="ln2461">          cairo_line_to(cr, pts[2], pts[3]);</a>
<a name="ln2462">          cairo_stroke(cr);</a>
<a name="ln2463">        }</a>
<a name="ln2464">        else if(g-&gt;k_selected_segment == 2)</a>
<a name="ln2465">        {</a>
<a name="ln2466">          cairo_move_to(cr, pts[4], pts[5]);</a>
<a name="ln2467">          cairo_line_to(cr, pts[6], pts[7]);</a>
<a name="ln2468">          cairo_stroke(cr);</a>
<a name="ln2469">        }</a>
<a name="ln2470">        else if(g-&gt;k_selected_segment == 3)</a>
<a name="ln2471">        {</a>
<a name="ln2472">          cairo_move_to(cr, pts[0], pts[1]);</a>
<a name="ln2473">          cairo_line_to(cr, pts[6], pts[7]);</a>
<a name="ln2474">          cairo_stroke(cr);</a>
<a name="ln2475">        }</a>
<a name="ln2476">      }</a>
<a name="ln2477">      else if(p-&gt;k_type == 2)</a>
<a name="ln2478">      {</a>
<a name="ln2479">        // determine extremity of the lines</a>
<a name="ln2480">        int h1l = pts[1] - (pts[3] - pts[1]) * pts[0] / (pts[2] - pts[0]);</a>
<a name="ln2481">        int h1r = (pts[3] - pts[1]) * wd / (pts[2] - pts[0]) + h1l;</a>
<a name="ln2482">        int h2l = pts[7] - (pts[5] - pts[7]) * pts[6] / (pts[4] - pts[6]);</a>
<a name="ln2483">        int h2r = (pts[5] - pts[7]) * wd / (pts[4] - pts[6]) + h2l;</a>
<a name="ln2484"> </a>
<a name="ln2485">        // draw the lines</a>
<a name="ln2486">        cairo_move_to(cr, 0, h1l);</a>
<a name="ln2487">        cairo_line_to(cr, wd, h1r);</a>
<a name="ln2488">        cairo_stroke(cr);</a>
<a name="ln2489">        cairo_move_to(cr, 0, h2l);</a>
<a name="ln2490">        cairo_line_to(cr, wd, h2r);</a>
<a name="ln2491">        cairo_stroke(cr);</a>
<a name="ln2492">        // redraw selected one</a>
<a name="ln2493">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2494">        if(g-&gt;k_selected_segment == 1)</a>
<a name="ln2495">        {</a>
<a name="ln2496">          cairo_move_to(cr, pts[4], pts[5]);</a>
<a name="ln2497">          cairo_line_to(cr, pts[2], pts[3]);</a>
<a name="ln2498">          cairo_stroke(cr);</a>
<a name="ln2499">        }</a>
<a name="ln2500">        else if(g-&gt;k_selected_segment == 3)</a>
<a name="ln2501">        {</a>
<a name="ln2502">          cairo_move_to(cr, pts[0], pts[1]);</a>
<a name="ln2503">          cairo_line_to(cr, pts[6], pts[7]);</a>
<a name="ln2504">          cairo_stroke(cr);</a>
<a name="ln2505">        }</a>
<a name="ln2506">      }</a>
<a name="ln2507">      else if(p-&gt;k_type == 1)</a>
<a name="ln2508">      {</a>
<a name="ln2509">        // determine extremity of the lines</a>
<a name="ln2510">        int v1t = pts[0] - (pts[6] - pts[0]) * pts[1] / (pts[7] - pts[1]);</a>
<a name="ln2511">        int v1b = (pts[6] - pts[0]) * ht / (pts[7] - pts[1]) + v1t;</a>
<a name="ln2512">        int v2t = pts[2] - (pts[4] - pts[2]) * pts[3] / (pts[5] - pts[3]);</a>
<a name="ln2513">        int v2b = (pts[4] - pts[2]) * ht / (pts[5] - pts[3]) + v2t;</a>
<a name="ln2514"> </a>
<a name="ln2515">        // draw the lines</a>
<a name="ln2516">        cairo_move_to(cr, v1t, 0);</a>
<a name="ln2517">        cairo_line_to(cr, v1b, ht);</a>
<a name="ln2518">        cairo_stroke(cr);</a>
<a name="ln2519">        cairo_move_to(cr, v2t, 0);</a>
<a name="ln2520">        cairo_line_to(cr, v2b, ht);</a>
<a name="ln2521">        cairo_stroke(cr);</a>
<a name="ln2522">        // redraw selected one</a>
<a name="ln2523">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2524">        if(g-&gt;k_selected_segment == 0)</a>
<a name="ln2525">        {</a>
<a name="ln2526">          cairo_move_to(cr, pts[0], pts[1]);</a>
<a name="ln2527">          cairo_line_to(cr, pts[2], pts[3]);</a>
<a name="ln2528">          cairo_stroke(cr);</a>
<a name="ln2529">        }</a>
<a name="ln2530">        else if(g-&gt;k_selected_segment == 2)</a>
<a name="ln2531">        {</a>
<a name="ln2532">          cairo_move_to(cr, pts[4], pts[5]);</a>
<a name="ln2533">          cairo_line_to(cr, pts[6], pts[7]);</a>
<a name="ln2534">          cairo_stroke(cr);</a>
<a name="ln2535">        }</a>
<a name="ln2536">      }</a>
<a name="ln2537"> </a>
<a name="ln2538">      // draw the points</a>
<a name="ln2539">      if(g-&gt;k_selected == 0) // point 1</a>
<a name="ln2540">      {</a>
<a name="ln2541">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2542">        cairo_set_source_rgba(cr, 1.0, 0, 0, .8);</a>
<a name="ln2543">      }</a>
<a name="ln2544">      else</a>
<a name="ln2545">      {</a>
<a name="ln2546">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0) / zoom_scale);</a>
<a name="ln2547">        cairo_set_source_rgba(cr, 1.0, 0, 0, .5);</a>
<a name="ln2548">      }</a>
<a name="ln2549">      cairo_arc(cr, pts[0], pts[1], DT_PIXEL_APPLY_DPI(5.0) / zoom_scale, 0, 2.0 * M_PI);</a>
<a name="ln2550">      cairo_stroke(cr);</a>
<a name="ln2551">      if(g-&gt;k_selected == 1) // point 2</a>
<a name="ln2552">      {</a>
<a name="ln2553">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2554">        cairo_set_source_rgba(cr, 1.0, 0, 0, .8);</a>
<a name="ln2555">      }</a>
<a name="ln2556">      else</a>
<a name="ln2557">      {</a>
<a name="ln2558">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0) / zoom_scale);</a>
<a name="ln2559">        cairo_set_source_rgba(cr, 1.0, 0, 0, .5);</a>
<a name="ln2560">      }</a>
<a name="ln2561">      cairo_arc(cr, pts[2], pts[3], DT_PIXEL_APPLY_DPI(5.0) / zoom_scale, 0, 2.0 * M_PI);</a>
<a name="ln2562">      cairo_stroke(cr);</a>
<a name="ln2563">      if(g-&gt;k_selected == 2) // point 3</a>
<a name="ln2564">      {</a>
<a name="ln2565">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2566">        cairo_set_source_rgba(cr, 1.0, 0, 0, .8);</a>
<a name="ln2567">      }</a>
<a name="ln2568">      else</a>
<a name="ln2569">      {</a>
<a name="ln2570">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0) / zoom_scale);</a>
<a name="ln2571">        cairo_set_source_rgba(cr, 1.0, 0, 0, .5);</a>
<a name="ln2572">      }</a>
<a name="ln2573">      cairo_arc(cr, pts[4], pts[5], DT_PIXEL_APPLY_DPI(5.0) / zoom_scale, 0, 2.0 * M_PI);</a>
<a name="ln2574">      cairo_stroke(cr);</a>
<a name="ln2575">      if(g-&gt;k_selected == 3) // point 4</a>
<a name="ln2576">      {</a>
<a name="ln2577">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(4.0) / zoom_scale);</a>
<a name="ln2578">        cairo_set_source_rgba(cr, 1.0, 0, 0, .8);</a>
<a name="ln2579">      }</a>
<a name="ln2580">      else</a>
<a name="ln2581">      {</a>
<a name="ln2582">        cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(2.0) / zoom_scale);</a>
<a name="ln2583">        cairo_set_source_rgba(cr, 1.0, 0, 0, .5);</a>
<a name="ln2584">      }</a>
<a name="ln2585">      cairo_arc(cr, pts[6], pts[7], DT_PIXEL_APPLY_DPI(5.0) / zoom_scale, 0, 2.0 * M_PI);</a>
<a name="ln2586">      cairo_stroke(cr);</a>
<a name="ln2587"> </a>
<a name="ln2588">      // draw the apply &quot;button&quot;</a>
<a name="ln2589">      PangoLayout *layout;</a>
<a name="ln2590">      PangoRectangle ink;</a>
<a name="ln2591">      PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln2592">      pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln2593">      pango_font_description_set_absolute_size(desc, DT_PIXEL_APPLY_DPI(16) * PANGO_SCALE);</a>
<a name="ln2594">      layout = pango_cairo_create_layout(cr);</a>
<a name="ln2595">      pango_layout_set_font_description(layout, desc);</a>
<a name="ln2596">      cairo_set_font_size(cr, DT_PIXEL_APPLY_DPI(16));</a>
<a name="ln2597">      pango_layout_set_text(layout, &quot;ok&quot;, -1);</a>
<a name="ln2598">      pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln2599">      int c[2] = { (MIN(pts[4], pts[2]) + MAX(pts[0], pts[6])) / 2.0f,</a>
<a name="ln2600">                   (MIN(pts[5], pts[7]) + MAX(pts[1], pts[3])) / 2.0f };</a>
<a name="ln2601">      cairo_set_source_rgba(cr, .5, .5, .5, .9);</a>
<a name="ln2602">      gui_draw_rounded_rectangle(cr, ink.width + DT_PIXEL_APPLY_DPI(8),</a>
<a name="ln2603">                                 ink.height + DT_PIXEL_APPLY_DPI(12),</a>
<a name="ln2604">                                 c[0] - ink.width / 2.0f - DT_PIXEL_APPLY_DPI(4),</a>
<a name="ln2605">                                 c[1] - ink.height / 2.0f - DT_PIXEL_APPLY_DPI(6));</a>
<a name="ln2606">      cairo_move_to(cr, c[0] - ink.width / 2.0f, c[1] - 3.0 * ink.height / 4.0f);</a>
<a name="ln2607">      cairo_set_source_rgba(cr, .2, .2, .2, .9);</a>
<a name="ln2608">      pango_cairo_show_layout(cr, layout);</a>
<a name="ln2609">      pango_font_description_free(desc);</a>
<a name="ln2610">      g_object_unref(layout);</a>
<a name="ln2611"> </a>
<a name="ln2612">      // draw the symmetry buttons</a>
<a name="ln2613">      gboolean sym = FALSE;</a>
<a name="ln2614">      if(p-&gt;k_type == 1 || p-&gt;k_type == 3)</a>
<a name="ln2615">      {</a>
<a name="ln2616">        if(p-&gt;k_sym == 1 || p-&gt;k_sym == 3) sym = TRUE;</a>
<a name="ln2617">        gui_draw_sym(cr, (pts[0] + pts[6]) / 2.0f, (pts[1] + pts[7]) / 2.0f, sym);</a>
<a name="ln2618">        gui_draw_sym(cr, (pts[2] + pts[4]) / 2.0f, (pts[3] + pts[5]) / 2.0f, sym);</a>
<a name="ln2619">      }</a>
<a name="ln2620">      if(p-&gt;k_type == 2 || p-&gt;k_type == 3)</a>
<a name="ln2621">      {</a>
<a name="ln2622">        sym = (p-&gt;k_sym &gt;= 2);</a>
<a name="ln2623">        gui_draw_sym(cr, (pts[0] + pts[2]) / 2.0f, (pts[1] + pts[3]) / 2.0f, sym);</a>
<a name="ln2624">        gui_draw_sym(cr, (pts[6] + pts[4]) / 2.0f, (pts[7] + pts[5]) / 2.0f, sym);</a>
<a name="ln2625">      }</a>
<a name="ln2626">    }</a>
<a name="ln2627">  }</a>
<a name="ln2628">}</a>
<a name="ln2629"> </a>
<a name="ln2630">// determine the distance between the segment [(xa,ya)(xb,yb)] and the point (xc,yc)</a>
<a name="ln2631">static float dist_seg(float xa, float ya, float xb, float yb, float xc, float yc)</a>
<a name="ln2632">{</a>
<a name="ln2633">  if(xa == xb &amp;&amp; ya == yb) return (xc - xa) * (xc - xa) + (yc - ya) * (yc - ya);</a>
<a name="ln2634"> </a>
<a name="ln2635">  float sx = xb - xa;</a>
<a name="ln2636">  float sy = yb - ya;</a>
<a name="ln2637"> </a>
<a name="ln2638">  float ux = xc - xa;</a>
<a name="ln2639">  float uy = yc - ya;</a>
<a name="ln2640"> </a>
<a name="ln2641">  float dp = sx * ux + sy * uy;</a>
<a name="ln2642">  if(dp &lt; 0) return (xc - xa) * (xc - xa) + (yc - ya) * (yc - ya);</a>
<a name="ln2643"> </a>
<a name="ln2644">  float sn2 = sx * sx + sy * sy;</a>
<a name="ln2645">  if(dp &gt; sn2) return (xc - xb) * (xc - xb) + (yc - yb) * (yc - yb);</a>
<a name="ln2646"> </a>
<a name="ln2647">  float ah2 = dp * dp / sn2;</a>
<a name="ln2648">  float un2 = ux * ux + uy * uy;</a>
<a name="ln2649">  return un2 - ah2;</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">int mouse_moved(struct dt_iop_module_t *self, double x, double y, double pressure, int which)</a>
<a name="ln2653">{</a>
<a name="ln2654">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2655">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln2656"> </a>
<a name="ln2657">  // we don't do anything if the image is not ready</a>
<a name="ln2658">  if((self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width == g-&gt;old_width</a>
<a name="ln2659">      &amp;&amp; self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height == g-&gt;old_height)</a>
<a name="ln2660">    ||self-&gt;dev-&gt;preview_loading</a>
<a name="ln2661">    )</a>
<a name="ln2662">    return 0;</a>
<a name="ln2663">  g-&gt;old_width = g-&gt;old_height = -1;</a>
<a name="ln2664"> </a>
<a name="ln2665">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2666">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2667">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln2668">  int closeup = dt_control_get_dev_closeup();</a>
<a name="ln2669">  float zoom_scale = dt_dev_get_zoom_scale(self-&gt;dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln2670">  float pzx, pzy;</a>
<a name="ln2671">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln2672">  pzx += 0.5f;</a>
<a name="ln2673">  pzy += 0.5f;</a>
<a name="ln2674">  static int old_grab = -1;</a>
<a name="ln2675">  _iop_clipping_set_max_clip(self);</a>
<a name="ln2676">  _grab_region_t grab = get_grab(pzx, pzy, g, DT_PIXEL_APPLY_DPI(30.0) / zoom_scale, wd, ht);</a>
<a name="ln2677"> </a>
<a name="ln2678">  if(darktable.control-&gt;button_down &amp;&amp; darktable.control-&gt;button_down_which == 3 &amp;&amp; g-&gt;k_show != 1)</a>
<a name="ln2679">  {</a>
<a name="ln2680">    // second mouse button, straighten activated:</a>
<a name="ln2681">    g-&gt;straightening = 1;</a>
<a name="ln2682">    dt_control_change_cursor(GDK_CROSSHAIR);</a>
<a name="ln2683">    dt_control_queue_redraw_center();</a>
<a name="ln2684">  }</a>
<a name="ln2685">  else if(darktable.control-&gt;button_down &amp;&amp; darktable.control-&gt;button_down_which == 1)</a>
<a name="ln2686">  {</a>
<a name="ln2687">    // case when we drag a point for keystone</a>
<a name="ln2688">    if(g-&gt;k_drag == TRUE &amp;&amp; g-&gt;k_selected &gt;= 0)</a>
<a name="ln2689">    {</a>
<a name="ln2690">      float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln2691">      dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, pts, 1);</a>
<a name="ln2692">      dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln2693">      float xx = pts[0] / (float)piece-&gt;buf_out.width, yy = pts[1] / (float)piece-&gt;buf_out.height;</a>
<a name="ln2694">      if(g-&gt;k_selected == 0)</a>
<a name="ln2695">      {</a>
<a name="ln2696">        if(p-&gt;k_sym == 1 || p-&gt;k_sym == 3)</a>
<a name="ln2697">          p-&gt;kxa = fminf(xx, (p-&gt;kxc + p-&gt;kxd - 0.01f) / 2.0f), p-&gt;kxb = p-&gt;kxc - p-&gt;kxa + p-&gt;kxd;</a>
<a name="ln2698">        else</a>
<a name="ln2699">          p-&gt;kxa = fminf(xx, p-&gt;kxb - 0.01f);</a>
<a name="ln2700">        if(p-&gt;k_sym &gt; 1)</a>
<a name="ln2701">          p-&gt;kya = fminf(yy, (p-&gt;kyc + p-&gt;kyb - 0.01f) / 2.0f), p-&gt;kyd = p-&gt;kyc - p-&gt;kya + p-&gt;kyb;</a>
<a name="ln2702">        else</a>
<a name="ln2703">          p-&gt;kya = fminf(yy, p-&gt;kyd - 0.01f);</a>
<a name="ln2704">      }</a>
<a name="ln2705">      else if(g-&gt;k_selected == 1)</a>
<a name="ln2706">      {</a>
<a name="ln2707">        if(p-&gt;k_sym == 1 || p-&gt;k_sym == 3)</a>
<a name="ln2708">          p-&gt;kxb = fmaxf(xx, (p-&gt;kxc + p-&gt;kxd + 0.01f) / 2.0f), p-&gt;kxa = p-&gt;kxc - p-&gt;kxb + p-&gt;kxd;</a>
<a name="ln2709">        else</a>
<a name="ln2710">          p-&gt;kxb = fmaxf(xx, p-&gt;kxa + 0.01f);</a>
<a name="ln2711">        if(p-&gt;k_sym &gt; 1)</a>
<a name="ln2712">          p-&gt;kyb = fminf(yy, (p-&gt;kya + p-&gt;kyd - 0.01f) / 2.0f), p-&gt;kyc = p-&gt;kya - p-&gt;kyb + p-&gt;kyd;</a>
<a name="ln2713">        else</a>
<a name="ln2714">          p-&gt;kyb = fminf(yy, p-&gt;kyc - 0.01f);</a>
<a name="ln2715">      }</a>
<a name="ln2716">      else if(g-&gt;k_selected == 2)</a>
<a name="ln2717">      {</a>
<a name="ln2718">        if(p-&gt;k_sym == 1 || p-&gt;k_sym == 3)</a>
<a name="ln2719">          p-&gt;kxc = fmaxf(xx, (p-&gt;kxa + p-&gt;kxb + 0.01f) / 2.0f), p-&gt;kxd = p-&gt;kxa - p-&gt;kxc + p-&gt;kxb;</a>
<a name="ln2720">        else</a>
<a name="ln2721">          p-&gt;kxc = fmaxf(xx, p-&gt;kxd + 0.01f);</a>
<a name="ln2722">        if(p-&gt;k_sym &gt; 1)</a>
<a name="ln2723">          p-&gt;kyc = fmaxf(yy, (p-&gt;kya + p-&gt;kyd + 0.01f) / 2.0f), p-&gt;kyb = p-&gt;kya - p-&gt;kyc + p-&gt;kyd;</a>
<a name="ln2724">        else</a>
<a name="ln2725">          p-&gt;kyc = fmaxf(yy, p-&gt;kyb + 0.01f);</a>
<a name="ln2726">      }</a>
<a name="ln2727">      else if(g-&gt;k_selected == 3)</a>
<a name="ln2728">      {</a>
<a name="ln2729">        if(p-&gt;k_sym == 1 || p-&gt;k_sym == 3)</a>
<a name="ln2730">          p-&gt;kxd = fminf(xx, (p-&gt;kxa + p-&gt;kxb - 0.01f) / 2.0f), p-&gt;kxc = p-&gt;kxa - p-&gt;kxd + p-&gt;kxb;</a>
<a name="ln2731">        else</a>
<a name="ln2732">          p-&gt;kxd = fminf(xx, p-&gt;kxc - 0.01f);</a>
<a name="ln2733">        if(p-&gt;k_sym &gt; 1)</a>
<a name="ln2734">          p-&gt;kyd = fmaxf(yy, (p-&gt;kyc + p-&gt;kyb + 0.01f) / 2.0f), p-&gt;kya = p-&gt;kyc - p-&gt;kyd + p-&gt;kyb;</a>
<a name="ln2735">        else</a>
<a name="ln2736">          p-&gt;kyd = fmaxf(yy, p-&gt;kya + 0.01f);</a>
<a name="ln2737">      }</a>
<a name="ln2738">      dt_control_queue_redraw_center();</a>
<a name="ln2739">      return 1;</a>
<a name="ln2740">    }</a>
<a name="ln2741">    // case when we drag a segment for keystone</a>
<a name="ln2742">    if(g-&gt;k_drag == TRUE &amp;&amp; g-&gt;k_selected_segment &gt;= 0)</a>
<a name="ln2743">    {</a>
<a name="ln2744">      float decalx = pzx - g-&gt;button_down_zoom_x;</a>
<a name="ln2745">      float decaly = pzy - g-&gt;button_down_zoom_y;</a>
<a name="ln2746">      if(g-&gt;k_selected_segment == 0 &amp;&amp; (p-&gt;k_type == 1 || p-&gt;k_type == 3))</a>
<a name="ln2747">      {</a>
<a name="ln2748">        decaly = fminf(decaly, p-&gt;kyd - p-&gt;kya);</a>
<a name="ln2749">        decaly = fminf(decaly, p-&gt;kyc - p-&gt;kyb);</a>
<a name="ln2750">        p-&gt;kxa += decalx;</a>
<a name="ln2751">        p-&gt;kya += decaly;</a>
<a name="ln2752">        p-&gt;kxb += decalx;</a>
<a name="ln2753">        p-&gt;kyb += decaly;</a>
<a name="ln2754">      }</a>
<a name="ln2755">      else if(g-&gt;k_selected_segment == 1 &amp;&amp; (p-&gt;k_type == 2 || p-&gt;k_type == 3))</a>
<a name="ln2756">      {</a>
<a name="ln2757">        decalx = fmaxf(decalx, p-&gt;kxa - p-&gt;kxb);</a>
<a name="ln2758">        decalx = fmaxf(decalx, p-&gt;kxd - p-&gt;kxc);</a>
<a name="ln2759">        p-&gt;kxc += decalx;</a>
<a name="ln2760">        p-&gt;kyc += decaly;</a>
<a name="ln2761">        p-&gt;kxb += decalx;</a>
<a name="ln2762">        p-&gt;kyb += decaly;</a>
<a name="ln2763">      }</a>
<a name="ln2764">      else if(g-&gt;k_selected_segment == 2 &amp;&amp; (p-&gt;k_type == 1 || p-&gt;k_type == 3))</a>
<a name="ln2765">      {</a>
<a name="ln2766">        decaly = fmaxf(decaly, p-&gt;kya - p-&gt;kyd);</a>
<a name="ln2767">        decaly = fmaxf(decaly, p-&gt;kyb - p-&gt;kyc);</a>
<a name="ln2768">        p-&gt;kxc += decalx;</a>
<a name="ln2769">        p-&gt;kyc += decaly;</a>
<a name="ln2770">        p-&gt;kxd += decalx;</a>
<a name="ln2771">        p-&gt;kyd += decaly;</a>
<a name="ln2772">      }</a>
<a name="ln2773">      else if(g-&gt;k_selected_segment == 3 &amp;&amp; (p-&gt;k_type == 2 || p-&gt;k_type == 3))</a>
<a name="ln2774">      {</a>
<a name="ln2775">        decalx = fminf(decalx, p-&gt;kxb - p-&gt;kxa);</a>
<a name="ln2776">        decalx = fminf(decalx, p-&gt;kxc - p-&gt;kxd);</a>
<a name="ln2777">        p-&gt;kxa += decalx;</a>
<a name="ln2778">        p-&gt;kya += decaly;</a>
<a name="ln2779">        p-&gt;kxd += decalx;</a>
<a name="ln2780">        p-&gt;kyd += decaly;</a>
<a name="ln2781">      }</a>
<a name="ln2782">      g-&gt;button_down_zoom_x = pzx;</a>
<a name="ln2783">      g-&gt;button_down_zoom_y = pzy;</a>
<a name="ln2784">      dt_control_queue_redraw_center();</a>
<a name="ln2785">      return 1;</a>
<a name="ln2786">    }</a>
<a name="ln2787">    // draw a light gray frame, to show it's not stored yet:</a>
<a name="ln2788">    g-&gt;applied = 0;</a>
<a name="ln2789">    // first mouse button, adjust cropping frame, but what do we do?</a>
<a name="ln2790">    float bzx = g-&gt;button_down_zoom_x + .5f, bzy = g-&gt;button_down_zoom_y + .5f;</a>
<a name="ln2791">    if(g-&gt;cropping == GRAB_CENTER &amp;&amp; !g-&gt;straightening &amp;&amp; g-&gt;k_show != 1)</a>
<a name="ln2792">    {</a>
<a name="ln2793">      g-&gt;cropping = grab;</a>
<a name="ln2794">      if(grab == GRAB_CENTER)</a>
<a name="ln2795">      {</a>
<a name="ln2796">        g-&gt;cropping = GRAB_ALL;</a>
<a name="ln2797">        g-&gt;handle_x = g-&gt;clip_x;</a>
<a name="ln2798">        g-&gt;handle_y = g-&gt;clip_y;</a>
<a name="ln2799">      }</a>
<a name="ln2800">      if(grab &amp; GRAB_LEFT) g-&gt;handle_x = bzx - g-&gt;clip_x;</a>
<a name="ln2801">      if(grab &amp; GRAB_TOP) g-&gt;handle_y = bzy - g-&gt;clip_y;</a>
<a name="ln2802">      if(grab &amp; GRAB_RIGHT) g-&gt;handle_x = bzx - (g-&gt;clip_w + g-&gt;clip_x);</a>
<a name="ln2803">      if(grab &amp; GRAB_BOTTOM) g-&gt;handle_y = bzy - (g-&gt;clip_h + g-&gt;clip_y);</a>
<a name="ln2804">      if(!grab &amp;&amp; darktable.control-&gt;button_down_which == 3) g-&gt;straightening = 1;</a>
<a name="ln2805">    }</a>
<a name="ln2806">    if(!g-&gt;straightening &amp;&amp; darktable.control-&gt;button_down_which == 1 &amp;&amp; g-&gt;k_show != 1)</a>
<a name="ln2807">    {</a>
<a name="ln2808">      grab = g-&gt;cropping;</a>
<a name="ln2809"> </a>
<a name="ln2810">      if(grab == GRAB_ALL)</a>
<a name="ln2811">      {</a>
<a name="ln2812">        /* moving the crop window */</a>
<a name="ln2813">        g-&gt;clip_x</a>
<a name="ln2814">            = fminf(g-&gt;clip_max_w + g-&gt;clip_max_x - g-&gt;clip_w, fmaxf(g-&gt;clip_max_x, g-&gt;handle_x + pzx - bzx));</a>
<a name="ln2815">        g-&gt;clip_y</a>
<a name="ln2816">            = fminf(g-&gt;clip_max_h + g-&gt;clip_max_y - g-&gt;clip_h, fmaxf(g-&gt;clip_max_y, g-&gt;handle_y + pzy - bzy));</a>
<a name="ln2817">      }</a>
<a name="ln2818">      else</a>
<a name="ln2819">      {</a>
<a name="ln2820">        /* changing the crop window */</a>
<a name="ln2821">        if(g-&gt;center_lock)</a>
<a name="ln2822">        {</a>
<a name="ln2823">          /* the center is locked, scale crop radial with locked ratio */</a>
<a name="ln2824">          gboolean flag = FALSE;</a>
<a name="ln2825">          float length = 0.0f;</a>
<a name="ln2826">          float xx = 0.0f;</a>
<a name="ln2827">          float yy = 0.0f;</a>
<a name="ln2828"> </a>
<a name="ln2829">          if(grab &amp; GRAB_LEFT || grab &amp; GRAB_RIGHT) xx = (grab &amp; GRAB_LEFT) ? (pzx - bzx) : (bzx - pzx);</a>
<a name="ln2830">          if(grab &amp; GRAB_TOP || grab &amp; GRAB_BOTTOM) yy = (grab &amp; GRAB_TOP) ? (pzy - bzy) : (bzy - pzy);</a>
<a name="ln2831"> </a>
<a name="ln2832">          length = (fabsf(xx) &gt; fabsf(yy)) ? xx : yy;</a>
<a name="ln2833"> </a>
<a name="ln2834">          if((g-&gt;prev_clip_w - (length + length)) &lt; 0.1 || (g-&gt;prev_clip_h - (length + length)) &lt; 0.1)</a>
<a name="ln2835">            flag = TRUE;</a>
<a name="ln2836"> </a>
<a name="ln2837">          g-&gt;clip_x = flag ? g-&gt;clip_x : g-&gt;prev_clip_x + length;</a>
<a name="ln2838">          g-&gt;clip_y = flag ? g-&gt;clip_y : g-&gt;prev_clip_y + length;</a>
<a name="ln2839">          g-&gt;clip_w = fmaxf(0.1f, g-&gt;prev_clip_w - (length + length));</a>
<a name="ln2840">          g-&gt;clip_h = fmaxf(0.1f, g-&gt;prev_clip_h - (length + length));</a>
<a name="ln2841">        }</a>
<a name="ln2842">        else</a>
<a name="ln2843">        {</a>
<a name="ln2844"> </a>
<a name="ln2845">          if(grab &amp; GRAB_LEFT)</a>
<a name="ln2846">          {</a>
<a name="ln2847">            const float old_clip_x = g-&gt;clip_x;</a>
<a name="ln2848">            g-&gt;clip_x = fmaxf(g-&gt;clip_max_x, pzx - g-&gt;handle_x);</a>
<a name="ln2849">            g-&gt;clip_w = fmaxf(0.1, old_clip_x + g-&gt;clip_w - g-&gt;clip_x);</a>
<a name="ln2850">          }</a>
<a name="ln2851">          if(grab &amp; GRAB_TOP)</a>
<a name="ln2852">          {</a>
<a name="ln2853">            const float old_clip_y = g-&gt;clip_y;</a>
<a name="ln2854">            g-&gt;clip_y = fmaxf(g-&gt;clip_max_y, pzy - g-&gt;handle_y);</a>
<a name="ln2855">            g-&gt;clip_h = fmaxf(0.1, old_clip_y + g-&gt;clip_h - g-&gt;clip_y);</a>
<a name="ln2856">          }</a>
<a name="ln2857">          if(grab &amp; GRAB_RIGHT)</a>
<a name="ln2858">            g-&gt;clip_w = fmaxf(0.1, fminf(g-&gt;clip_max_w + g-&gt;clip_max_x, pzx - g-&gt;clip_x - g-&gt;handle_x));</a>
<a name="ln2859">          if(grab &amp; GRAB_BOTTOM)</a>
<a name="ln2860">            g-&gt;clip_h = fmaxf(0.1, fminf(g-&gt;clip_max_h + g-&gt;clip_max_y, pzy - g-&gt;clip_y - g-&gt;handle_y));</a>
<a name="ln2861">        }</a>
<a name="ln2862"> </a>
<a name="ln2863">        if(g-&gt;clip_x + g-&gt;clip_w &gt; g-&gt;clip_max_w + g-&gt;clip_max_x)</a>
<a name="ln2864">          g-&gt;clip_w = g-&gt;clip_max_w + g-&gt;clip_max_x - g-&gt;clip_x;</a>
<a name="ln2865">        if(g-&gt;clip_y + g-&gt;clip_h &gt; g-&gt;clip_max_h + g-&gt;clip_max_y)</a>
<a name="ln2866">          g-&gt;clip_h = g-&gt;clip_max_h + g-&gt;clip_max_y - g-&gt;clip_y;</a>
<a name="ln2867">      }</a>
<a name="ln2868">      apply_box_aspect(self, grab);</a>
<a name="ln2869">      // we save crop params too</a>
<a name="ln2870">      float points[4]</a>
<a name="ln2871">          = { g-&gt;clip_x * wd, g-&gt;clip_y * ht, (g-&gt;clip_x + g-&gt;clip_w) * wd, (g-&gt;clip_y + g-&gt;clip_h) * ht };</a>
<a name="ln2872">      if(dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points, 2))</a>
<a name="ln2873">      {</a>
<a name="ln2874">        dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln2875">        if(piece)</a>
<a name="ln2876">        {</a>
<a name="ln2877">          p-&gt;cx = points[0] / (float)piece-&gt;buf_out.width;</a>
<a name="ln2878">          p-&gt;cy = points[1] / (float)piece-&gt;buf_out.height;</a>
<a name="ln2879">          p-&gt;cw = copysignf(points[2] / (float)piece-&gt;buf_out.width, p-&gt;cw);</a>
<a name="ln2880">          p-&gt;ch = copysignf(points[3] / (float)piece-&gt;buf_out.height, p-&gt;ch);</a>
<a name="ln2881">        }</a>
<a name="ln2882">      }</a>
<a name="ln2883">    }</a>
<a name="ln2884">    dt_control_queue_redraw_center();</a>
<a name="ln2885">    return 1;</a>
<a name="ln2886">  }</a>
<a name="ln2887">  else if(grab &amp;&amp; g-&gt;k_show != 1)</a>
<a name="ln2888">  {</a>
<a name="ln2889">    // hover over active borders, no button pressed</a>
<a name="ln2890">    if(old_grab != grab)</a>
<a name="ln2891">    {</a>
<a name="ln2892">      // change mouse pointer</a>
<a name="ln2893">      if(grab == GRAB_LEFT)</a>
<a name="ln2894">        dt_control_change_cursor(GDK_LEFT_SIDE);</a>
<a name="ln2895">      else if(grab == GRAB_TOP)</a>
<a name="ln2896">        dt_control_change_cursor(GDK_TOP_SIDE);</a>
<a name="ln2897">      else if(grab == GRAB_RIGHT)</a>
<a name="ln2898">        dt_control_change_cursor(GDK_RIGHT_SIDE);</a>
<a name="ln2899">      else if(grab == GRAB_BOTTOM)</a>
<a name="ln2900">        dt_control_change_cursor(GDK_BOTTOM_SIDE);</a>
<a name="ln2901">      else if(grab == GRAB_TOP_LEFT)</a>
<a name="ln2902">        dt_control_change_cursor(GDK_TOP_LEFT_CORNER);</a>
<a name="ln2903">      else if(grab == GRAB_TOP_RIGHT)</a>
<a name="ln2904">        dt_control_change_cursor(GDK_TOP_RIGHT_CORNER);</a>
<a name="ln2905">      else if(grab == GRAB_BOTTOM_RIGHT)</a>
<a name="ln2906">        dt_control_change_cursor(GDK_BOTTOM_RIGHT_CORNER);</a>
<a name="ln2907">      else if(grab == GRAB_BOTTOM_LEFT)</a>
<a name="ln2908">        dt_control_change_cursor(GDK_BOTTOM_LEFT_CORNER);</a>
<a name="ln2909">      else if(grab == GRAB_NONE)</a>
<a name="ln2910">        dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln2911">    }</a>
<a name="ln2912">    dt_control_queue_redraw_center();</a>
<a name="ln2913">  }</a>
<a name="ln2914">  else</a>
<a name="ln2915">  {</a>
<a name="ln2916">    // somewhere besides borders. maybe rotate?</a>
<a name="ln2917">    if(old_grab != grab) dt_control_change_cursor(GDK_FLEUR);</a>
<a name="ln2918">    g-&gt;straightening = g-&gt;cropping = 0;</a>
<a name="ln2919">    // or maybe keystone</a>
<a name="ln2920">    float ext = DT_PIXEL_APPLY_DPI(0.005f) / zoom_scale;</a>
<a name="ln2921">    if(g-&gt;k_show == 1 &amp;&amp; g-&gt;k_drag == FALSE)</a>
<a name="ln2922">    {</a>
<a name="ln2923">      float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln2924">      dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, pts, 1);</a>
<a name="ln2925">      dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln2926">      float xx = pts[0] / (float)piece-&gt;buf_out.width, yy = pts[1] / (float)piece-&gt;buf_out.height;</a>
<a name="ln2927">      // are we near a keystone point ?</a>
<a name="ln2928">      g-&gt;k_selected = -1;</a>
<a name="ln2929">      g-&gt;k_selected_segment = -1;</a>
<a name="ln2930">      if(xx &lt; p-&gt;kxa + ext &amp;&amp; xx &gt; p-&gt;kxa - ext &amp;&amp; yy &lt; p-&gt;kya + ext &amp;&amp; yy &gt; p-&gt;kya - ext) g-&gt;k_selected = 0;</a>
<a name="ln2931">      if(xx &lt; p-&gt;kxb + ext &amp;&amp; xx &gt; p-&gt;kxb - ext &amp;&amp; yy &lt; p-&gt;kyb + ext &amp;&amp; yy &gt; p-&gt;kyb - ext) g-&gt;k_selected = 1;</a>
<a name="ln2932">      if(xx &lt; p-&gt;kxc + ext &amp;&amp; xx &gt; p-&gt;kxc - ext &amp;&amp; yy &lt; p-&gt;kyc + ext &amp;&amp; yy &gt; p-&gt;kyc - ext) g-&gt;k_selected = 2;</a>
<a name="ln2933">      if(xx &lt; p-&gt;kxd + ext &amp;&amp; xx &gt; p-&gt;kxd - ext &amp;&amp; yy &lt; p-&gt;kyd + ext &amp;&amp; yy &gt; p-&gt;kyd - ext) g-&gt;k_selected = 3;</a>
<a name="ln2934">      // or near a keystone segment</a>
<a name="ln2935">      if(g-&gt;k_selected &lt; 0)</a>
<a name="ln2936">      {</a>
<a name="ln2937">        if(p-&gt;k_type == 1 || p-&gt;k_type == 3)</a>
<a name="ln2938">        {</a>
<a name="ln2939">          if(dist_seg(p-&gt;kxa, p-&gt;kya, p-&gt;kxb, p-&gt;kyb, xx, yy) &lt; ext * ext)</a>
<a name="ln2940">            g-&gt;k_selected_segment = 0;</a>
<a name="ln2941">          else if(dist_seg(p-&gt;kxd, p-&gt;kyd, p-&gt;kxc, p-&gt;kyc, xx, yy) &lt; ext * ext)</a>
<a name="ln2942">            g-&gt;k_selected_segment = 2;</a>
<a name="ln2943">          if(dist_seg(p-&gt;kxb, p-&gt;kyb, p-&gt;kxc, p-&gt;kyc, xx, yy) &lt; ext * ext)</a>
<a name="ln2944">            g-&gt;k_selected_segment = 1;</a>
<a name="ln2945">          else if(dist_seg(p-&gt;kxd, p-&gt;kyd, p-&gt;kxa, p-&gt;kya, xx, yy) &lt; ext * ext)</a>
<a name="ln2946">            g-&gt;k_selected_segment = 3;</a>
<a name="ln2947">        }</a>
<a name="ln2948">      }</a>
<a name="ln2949">      if(g-&gt;k_selected &gt;= 0)</a>
<a name="ln2950">        dt_control_change_cursor(GDK_CROSS);</a>
<a name="ln2951">      else</a>
<a name="ln2952">        dt_control_change_cursor(GDK_FLEUR);</a>
<a name="ln2953">    }</a>
<a name="ln2954">    dt_control_queue_redraw_center();</a>
<a name="ln2955">  }</a>
<a name="ln2956">  old_grab = grab;</a>
<a name="ln2957">  return 0;</a>
<a name="ln2958">}</a>
<a name="ln2959"> </a>
<a name="ln2960">static void commit_box(dt_iop_module_t *self, dt_iop_clipping_gui_data_t *g, dt_iop_clipping_params_t *p)</a>
<a name="ln2961">{</a>
<a name="ln2962">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln2963">  g-&gt;cropping = 0;</a>
<a name="ln2964">  if(!self-&gt;enabled)</a>
<a name="ln2965">  {</a>
<a name="ln2966">    // first time crop, if any data is stored in p, it's obsolete:</a>
<a name="ln2967">    p-&gt;cx = p-&gt;cy = 0.0f;</a>
<a name="ln2968">    p-&gt;cw = p-&gt;ch = 1.0f;</a>
<a name="ln2969">  }</a>
<a name="ln2970">  // we want value in iop space</a>
<a name="ln2971">  float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln2972">  float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln2973">  float points[4]</a>
<a name="ln2974">      = { g-&gt;clip_x * wd, g-&gt;clip_y * ht, (g-&gt;clip_x + g-&gt;clip_w) * wd, (g-&gt;clip_y + g-&gt;clip_h) * ht };</a>
<a name="ln2975">  if(dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points, 2))</a>
<a name="ln2976">  {</a>
<a name="ln2977">    dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln2978">    if(piece)</a>
<a name="ln2979">    {</a>
<a name="ln2980">      p-&gt;cx = points[0] / (float)piece-&gt;buf_out.width;</a>
<a name="ln2981">      p-&gt;cy = points[1] / (float)piece-&gt;buf_out.height;</a>
<a name="ln2982">      p-&gt;cw = copysignf(points[2] / (float)piece-&gt;buf_out.width, p-&gt;cw);</a>
<a name="ln2983">      p-&gt;ch = copysignf(points[3] / (float)piece-&gt;buf_out.height, p-&gt;ch);</a>
<a name="ln2984">      // verify that the crop area stay in the image area</a>
<a name="ln2985">      if(p-&gt;cx &gt;= 1.0f) p-&gt;cx = 0.5f;</a>
<a name="ln2986">      if(p-&gt;cy &gt;= 1.0f) p-&gt;cy = 0.5f;</a>
<a name="ln2987">      p-&gt;cw = CLAMPF(p-&gt;cw, -1.0f, 1.0f);</a>
<a name="ln2988">      p-&gt;ch = CLAMPF(p-&gt;ch, -1.0f, 1.0f);</a>
<a name="ln2989">    }</a>
<a name="ln2990">  }</a>
<a name="ln2991">  g-&gt;applied = 1;</a>
<a name="ln2992">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln2993">}</a>
<a name="ln2994"> </a>
<a name="ln2995">int button_released(struct dt_iop_module_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln2996">{</a>
<a name="ln2997">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2998">  // we don't do anything if the image is not ready</a>
<a name="ln2999">  if(self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width == g-&gt;old_width</a>
<a name="ln3000">     &amp;&amp; self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height == g-&gt;old_height)</a>
<a name="ln3001">    return 0;</a>
<a name="ln3002">  g-&gt;old_width = g-&gt;old_height = -1;</a>
<a name="ln3003"> </a>
<a name="ln3004">  if(g-&gt;straightening)</a>
<a name="ln3005">  {</a>
<a name="ln3006">    float dx = x - g-&gt;button_down_x, dy = y - g-&gt;button_down_y;</a>
<a name="ln3007">    if(dx &lt; 0)</a>
<a name="ln3008">    {</a>
<a name="ln3009">      dx = -dx;</a>
<a name="ln3010">      dy = -dy;</a>
<a name="ln3011">    }</a>
<a name="ln3012">    float angle = atan2f(dy, dx);</a>
<a name="ln3013">    if(!(angle &gt;= -M_PI / 2.0 &amp;&amp; angle &lt;= M_PI / 2.0)) angle = 0.0f;</a>
<a name="ln3014">    float close = angle;</a>
<a name="ln3015">    if(close &gt; M_PI / 4.0)</a>
<a name="ln3016">      close = M_PI / 2.0 - close;</a>
<a name="ln3017">    else if(close &lt; -M_PI / 4.0)</a>
<a name="ln3018">      close = -M_PI / 2.0 - close;</a>
<a name="ln3019">    else</a>
<a name="ln3020">      close = -close;</a>
<a name="ln3021">    float a = 180.0 / M_PI * close + g-&gt;button_down_angle;</a>
<a name="ln3022">    if(a &lt; -180.0) a += 360.0;</a>
<a name="ln3023">    if(a &gt; 180.0) a -= 360.0;</a>
<a name="ln3024">    dt_bauhaus_slider_set(g-&gt;angle, -a);</a>
<a name="ln3025">    dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3026">  }</a>
<a name="ln3027">  if(g-&gt;k_drag) g-&gt;k_drag = FALSE;</a>
<a name="ln3028"> </a>
<a name="ln3029">  /* reset internal ui states*/</a>
<a name="ln3030">  g-&gt;center_lock = g-&gt;straightening = g-&gt;cropping = 0;</a>
<a name="ln3031">  return 1;</a>
<a name="ln3032">}</a>
<a name="ln3033"> </a>
<a name="ln3034">int button_pressed(struct dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln3035">                   uint32_t state)</a>
<a name="ln3036">{</a>
<a name="ln3037"> </a>
<a name="ln3038">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3039">  dt_iop_clipping_params_t *p = (dt_iop_clipping_params_t *)self-&gt;params;</a>
<a name="ln3040">  // we don't do anything if the image is not ready</a>
<a name="ln3041">  if(self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width == g-&gt;old_width</a>
<a name="ln3042">     &amp;&amp; self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height == g-&gt;old_height)</a>
<a name="ln3043">    return 0;</a>
<a name="ln3044">  g-&gt;old_width = g-&gt;old_height = -1;</a>
<a name="ln3045"> </a>
<a name="ln3046">  // avoid unexpected back to lt mode:</a>
<a name="ln3047">  if(type == GDK_2BUTTON_PRESS &amp;&amp; which == 1)</a>
<a name="ln3048">  {</a>
<a name="ln3049">    dt_iop_request_focus(NULL);</a>
<a name="ln3050">    commit_box(self, g, p);</a>
<a name="ln3051">    return 1;</a>
<a name="ln3052">  }</a>
<a name="ln3053">  if(which == 3 || which == 1)</a>
<a name="ln3054">  {</a>
<a name="ln3055">    // switch module on already, other code depends in this:</a>
<a name="ln3056">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3057"> </a>
<a name="ln3058">    if(g-&gt;k_show == 1)</a>
<a name="ln3059">    {</a>
<a name="ln3060">      if(g-&gt;k_selected &gt;= 0)</a>
<a name="ln3061">        g-&gt;k_drag = TRUE; // if a keystone point is selected then we start to drag it</a>
<a name="ln3062">      else // if we click to the apply button</a>
<a name="ln3063">      {</a>
<a name="ln3064">        dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3065">        int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3066">        float zoom_scale = dt_dev_get_zoom_scale(self-&gt;dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln3067">        float pzx, pzy;</a>
<a name="ln3068">        dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3069">        pzx += 0.5f;</a>
<a name="ln3070">        pzy += 0.5f;</a>
<a name="ln3071"> </a>
<a name="ln3072">        dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln3073">        float wp = piece-&gt;buf_out.width, hp = piece-&gt;buf_out.height;</a>
<a name="ln3074">        float pts[8] = { p-&gt;kxa * wp, p-&gt;kya * hp, p-&gt;kxb * wp, p-&gt;kyb * hp,</a>
<a name="ln3075">                         p-&gt;kxc * wp, p-&gt;kyc * hp, p-&gt;kxd * wp, p-&gt;kyd * hp };</a>
<a name="ln3076">        dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, pts, 4);</a>
<a name="ln3077"> </a>
<a name="ln3078">        float xx = pzx * self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width,</a>
<a name="ln3079">              yy = pzy * self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3080">        float c[2] = { (MIN(pts[4], pts[2]) + MAX(pts[0], pts[6])) / 2.0f,</a>
<a name="ln3081">                       (MIN(pts[5], pts[7]) + MAX(pts[1], pts[3])) / 2.0f };</a>
<a name="ln3082">        float ext = DT_PIXEL_APPLY_DPI(10.0) / (zoom_scale);</a>
<a name="ln3083">        // Apply button</a>
<a name="ln3084">        if(xx &gt; c[0] - ext &amp;&amp; xx &lt; c[0] + ext &amp;&amp; yy &gt; c[1] - ext &amp;&amp; yy &lt; c[1] + ext)</a>
<a name="ln3085">        {</a>
<a name="ln3086">          // add an entry to the combo box and select it</a>
<a name="ln3087">          keystone_type_populate(self, TRUE, 99);</a>
<a name="ln3088">          // reset gui settings</a>
<a name="ln3089">          g-&gt;k_show = 2;</a>
<a name="ln3090">          g-&gt;k_selected = -1;</a>
<a name="ln3091">          g-&gt;k_drag = FALSE;</a>
<a name="ln3092">          // do the changes</a>
<a name="ln3093">          p-&gt;k_apply = 1;</a>
<a name="ln3094">          commit_box(self, g, p);</a>
<a name="ln3095">        }</a>
<a name="ln3096">        else</a>
<a name="ln3097">        {</a>
<a name="ln3098">          // Horizontal symmetry button (1)</a>
<a name="ln3099">          c[0] = (pts[0] + pts[6]) / 2.0f, c[1] = (pts[1] + pts[7]) / 2.0f;</a>
<a name="ln3100">          if(xx &gt; c[0] - ext &amp;&amp; xx &lt; c[0] + ext &amp;&amp; yy &gt; c[1] - ext &amp;&amp; yy &lt; c[1] + ext</a>
<a name="ln3101">             &amp;&amp; (p-&gt;k_type == 1 || p-&gt;k_type == 3))</a>
<a name="ln3102">          {</a>
<a name="ln3103">            if(p-&gt;k_sym == 0)</a>
<a name="ln3104">              p-&gt;k_sym = 1;</a>
<a name="ln3105">            else if(p-&gt;k_sym == 1)</a>
<a name="ln3106">              p-&gt;k_sym = 0;</a>
<a name="ln3107">            else if(p-&gt;k_sym == 2)</a>
<a name="ln3108">              p-&gt;k_sym = 3;</a>
<a name="ln3109">            else</a>
<a name="ln3110">              p-&gt;k_sym = 2;</a>
<a name="ln3111">          }</a>
<a name="ln3112">          else</a>
<a name="ln3113">          {</a>
<a name="ln3114">            // Horizontal symmetry button (2)</a>
<a name="ln3115">            c[0] = (pts[2] + pts[4]) / 2.0f, c[1] = (pts[3] + pts[5]) / 2.0f;</a>
<a name="ln3116">            if(xx &gt; c[0] - ext &amp;&amp; xx &lt; c[0] + ext &amp;&amp; yy &gt; c[1] - ext &amp;&amp; yy &lt; c[1] + ext</a>
<a name="ln3117">               &amp;&amp; (p-&gt;k_type == 1 || p-&gt;k_type == 3))</a>
<a name="ln3118">            {</a>
<a name="ln3119">              if(p-&gt;k_sym == 0)</a>
<a name="ln3120">                p-&gt;k_sym = 1;</a>
<a name="ln3121">              else if(p-&gt;k_sym == 1)</a>
<a name="ln3122">                p-&gt;k_sym = 0;</a>
<a name="ln3123">              else if(p-&gt;k_sym == 2)</a>
<a name="ln3124">                p-&gt;k_sym = 3;</a>
<a name="ln3125">              else</a>
<a name="ln3126">                p-&gt;k_sym = 2;</a>
<a name="ln3127">            }</a>
<a name="ln3128">            else</a>
<a name="ln3129">            {</a>
<a name="ln3130">              // vertical symmetry button (1)</a>
<a name="ln3131">              c[0] = (pts[2] + pts[0]) / 2.0f, c[1] = (pts[3] + pts[1]) / 2.0f;</a>
<a name="ln3132">              if(xx &gt; c[0] - ext &amp;&amp; xx &lt; c[0] + ext &amp;&amp; yy &gt; c[1] - ext &amp;&amp; yy &lt; c[1] + ext</a>
<a name="ln3133">                 &amp;&amp; (p-&gt;k_type == 2 || p-&gt;k_type == 3))</a>
<a name="ln3134">              {</a>
<a name="ln3135">                if(p-&gt;k_sym == 0)</a>
<a name="ln3136">                  p-&gt;k_sym = 2;</a>
<a name="ln3137">                else if(p-&gt;k_sym == 1)</a>
<a name="ln3138">                  p-&gt;k_sym = 3;</a>
<a name="ln3139">                else if(p-&gt;k_sym == 2)</a>
<a name="ln3140">                  p-&gt;k_sym = 0;</a>
<a name="ln3141">                else</a>
<a name="ln3142">                  p-&gt;k_sym = 1;</a>
<a name="ln3143">              }</a>
<a name="ln3144">              else</a>
<a name="ln3145">              {</a>
<a name="ln3146">                // vertical symmetry button (2)</a>
<a name="ln3147">                c[0] = (pts[4] + pts[6]) / 2.0f, c[1] = (pts[5] + pts[7]) / 2.0f;</a>
<a name="ln3148">                if(xx &gt; c[0] - ext &amp;&amp; xx &lt; c[0] + ext &amp;&amp; yy &gt; c[1] - ext &amp;&amp; yy &lt; c[1] + ext</a>
<a name="ln3149">                   &amp;&amp; (p-&gt;k_type == 2 || p-&gt;k_type == 3))</a>
<a name="ln3150">                {</a>
<a name="ln3151">                  if(p-&gt;k_sym == 0)</a>
<a name="ln3152">                    p-&gt;k_sym = 2;</a>
<a name="ln3153">                  else if(p-&gt;k_sym == 1)</a>
<a name="ln3154">                    p-&gt;k_sym = 3;</a>
<a name="ln3155">                  else if(p-&gt;k_sym == 2)</a>
<a name="ln3156">                    p-&gt;k_sym = 0;</a>
<a name="ln3157">                  else</a>
<a name="ln3158">                    p-&gt;k_sym = 1;</a>
<a name="ln3159">                }</a>
<a name="ln3160">                else</a>
<a name="ln3161">                {</a>
<a name="ln3162">                  // dragging a border ?</a>
<a name="ln3163">                  if(g-&gt;k_selected_segment &gt;= 0)</a>
<a name="ln3164">                  {</a>
<a name="ln3165">                    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;g-&gt;button_down_zoom_x,</a>
<a name="ln3166">                                                &amp;g-&gt;button_down_zoom_y);</a>
<a name="ln3167">                    g-&gt;button_down_zoom_x += 0.5;</a>
<a name="ln3168">                    g-&gt;button_down_zoom_y += 0.5;</a>
<a name="ln3169">                    g-&gt;k_drag = TRUE;</a>
<a name="ln3170">                  }</a>
<a name="ln3171">                }</a>
<a name="ln3172">              }</a>
<a name="ln3173">            }</a>
<a name="ln3174">          }</a>
<a name="ln3175">        }</a>
<a name="ln3176">      }</a>
<a name="ln3177">    }</a>
<a name="ln3178">    else</a>
<a name="ln3179">    {</a>
<a name="ln3180">      g-&gt;button_down_x = x;</a>
<a name="ln3181">      g-&gt;button_down_y = y;</a>
<a name="ln3182">      dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;g-&gt;button_down_zoom_x, &amp;g-&gt;button_down_zoom_y);</a>
<a name="ln3183">      g-&gt;button_down_angle = p-&gt;angle;</a>
<a name="ln3184"> </a>
<a name="ln3185">      /* update prev clip box with current */</a>
<a name="ln3186">      g-&gt;prev_clip_x = g-&gt;clip_x;</a>
<a name="ln3187">      g-&gt;prev_clip_y = g-&gt;clip_y;</a>
<a name="ln3188">      g-&gt;prev_clip_w = g-&gt;clip_w;</a>
<a name="ln3189">      g-&gt;prev_clip_h = g-&gt;clip_h;</a>
<a name="ln3190"> </a>
<a name="ln3191">      /* if shift is pressed, then lock crop on center */</a>
<a name="ln3192">      if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK) g-&gt;center_lock = 1;</a>
<a name="ln3193">    }</a>
<a name="ln3194"> </a>
<a name="ln3195">    return 1;</a>
<a name="ln3196">  }</a>
<a name="ln3197">  else</a>
<a name="ln3198">    return 0;</a>
<a name="ln3199">}</a>
<a name="ln3200"> </a>
<a name="ln3201">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln3202">{</a>
<a name="ln3203">  dt_accel_register_iop(self, TRUE, NC_(&quot;accel&quot;, &quot;commit&quot;), GDK_KEY_Return, 0);</a>
<a name="ln3204">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;angle&quot;));</a>
<a name="ln3205">}</a>
<a name="ln3206"> </a>
<a name="ln3207">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln3208">{</a>
<a name="ln3209">  dt_iop_clipping_gui_data_t *g = (dt_iop_clipping_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3210">  GClosure *closure;</a>
<a name="ln3211"> </a>
<a name="ln3212">  closure = g_cclosure_new(G_CALLBACK(key_commit_callback), (gpointer)self, NULL);</a>
<a name="ln3213">  dt_accel_connect_iop(self, &quot;commit&quot;, closure);</a>
<a name="ln3214"> </a>
<a name="ln3215">  dt_accel_connect_slider_iop(self, &quot;angle&quot;, GTK_WIDGET(g-&gt;angle));</a>
<a name="ln3216">}</a>
<a name="ln3217"> </a>
<a name="ln3218">#undef PHI</a>
<a name="ln3219">#undef INVPHI</a>
<a name="ln3220"> </a>
<a name="ln3221">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln3222">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln3223">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="99"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: new_version == 5.</p></div>
<div class="balloon" rel="148"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: new_version == 5.</p></div>
<div class="balloon" rel="176"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: new_version == 5.</p></div>
<div class="balloon" rel="331"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v751/" target="_blank">V751</a> Parameter 'kxa' is not used inside function body.</p></div>
<div class="balloon" rel="331"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v751/" target="_blank">V751</a> Parameter 'kya' is not used inside function body.</p></div>
<div class="balloon" rel="1087"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 1087, 1085.</p></div>
<div class="balloon" rel="1944"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 1944, 1940.</p></div>
<div class="balloon" rel="2804"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'grab' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="2804"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="2806"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="2887"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v768/" target="_blank">V768</a> The variable 'grab' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
