
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/colorspaces.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/interpolation.h&quot;</a>
<a name="ln24">#include &quot;common/opencl.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;develop/develop.h&quot;</a>
<a name="ln28">#include &quot;develop/imageop.h&quot;</a>
<a name="ln29">#include &quot;develop/imageop_math.h&quot;</a>
<a name="ln30">#include &quot;develop/tiling.h&quot;</a>
<a name="ln31">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln32">#include &quot;gui/gtk.h&quot;</a>
<a name="ln33">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;complex.h&gt;</a>
<a name="ln36">#include &lt;glib.h&gt;</a>
<a name="ln37">#include &lt;math.h&gt;</a>
<a name="ln38">#include &lt;memory.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;string.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">// we assume people have -msee support.</a>
<a name="ln43">#if defined(__SSE__)</a>
<a name="ln44">#include &lt;xmmintrin.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">DT_MODULE_INTROSPECTION(3, dt_iop_demosaic_params_t)</a>
<a name="ln48"> </a>
<a name="ln49">#define DEMOSAIC_XTRANS 1024 // masks for non-Bayer demosaic ops</a>
<a name="ln50">#define REDUCESIZE 64</a>
<a name="ln51"> </a>
<a name="ln52">typedef enum dt_iop_demosaic_method_t</a>
<a name="ln53">{</a>
<a name="ln54">  // methods for Bayer images</a>
<a name="ln55">  DT_IOP_DEMOSAIC_PPG = 0,</a>
<a name="ln56">  DT_IOP_DEMOSAIC_AMAZE = 1,</a>
<a name="ln57">  DT_IOP_DEMOSAIC_VNG4 = 2,</a>
<a name="ln58">  DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME = 3,</a>
<a name="ln59">  // methods for x-trans images</a>
<a name="ln60">  DT_IOP_DEMOSAIC_VNG = DEMOSAIC_XTRANS | 0,</a>
<a name="ln61">  DT_IOP_DEMOSAIC_MARKESTEIJN = DEMOSAIC_XTRANS | 1,</a>
<a name="ln62">  DT_IOP_DEMOSAIC_MARKESTEIJN_3 = DEMOSAIC_XTRANS | 2,</a>
<a name="ln63">  DT_IOP_DEMOSAIC_FDC = DEMOSAIC_XTRANS | 4</a>
<a name="ln64">} dt_iop_demosaic_method_t;</a>
<a name="ln65"> </a>
<a name="ln66">typedef enum dt_iop_demosaic_greeneq_t</a>
<a name="ln67">{</a>
<a name="ln68">  DT_IOP_GREEN_EQ_NO = 0,</a>
<a name="ln69">  DT_IOP_GREEN_EQ_LOCAL = 1,</a>
<a name="ln70">  DT_IOP_GREEN_EQ_FULL = 2,</a>
<a name="ln71">  DT_IOP_GREEN_EQ_BOTH = 3</a>
<a name="ln72">} dt_iop_demosaic_greeneq_t;</a>
<a name="ln73"> </a>
<a name="ln74">typedef enum dt_iop_demosaic_qual_flags_t</a>
<a name="ln75">{</a>
<a name="ln76">  // either perform full scale demosaicing or choose simple half scale</a>
<a name="ln77">  // or third scale interpolation instead</a>
<a name="ln78">  DEMOSAIC_FULL_SCALE              = 1 &lt;&lt; 0,</a>
<a name="ln79">  DEMOSAIC_ONLY_VNG_LINEAR         = 1 &lt;&lt; 1,</a>
<a name="ln80">  DEMOSAIC_XTRANS_FULL             = 1 &lt;&lt; 2,</a>
<a name="ln81">  DEMOSAIC_MEDIUM_QUAL             = 1 &lt;&lt; 3</a>
<a name="ln82">} dt_iop_demosaic_qual_flags_t;</a>
<a name="ln83"> </a>
<a name="ln84">typedef struct dt_iop_demosaic_params_t</a>
<a name="ln85">{</a>
<a name="ln86">  dt_iop_demosaic_greeneq_t green_eq;</a>
<a name="ln87">  float median_thrs;</a>
<a name="ln88">  uint32_t color_smoothing;</a>
<a name="ln89">  dt_iop_demosaic_method_t demosaicing_method;</a>
<a name="ln90">  uint32_t yet_unused_data_specific_to_demosaicing_method;</a>
<a name="ln91">} dt_iop_demosaic_params_t;</a>
<a name="ln92"> </a>
<a name="ln93">typedef struct dt_iop_demosaic_gui_data_t</a>
<a name="ln94">{</a>
<a name="ln95">  GtkWidget *box_raw;</a>
<a name="ln96">  GtkWidget *median_thrs;</a>
<a name="ln97">  GtkWidget *greeneq;</a>
<a name="ln98">  GtkWidget *color_smoothing;</a>
<a name="ln99">  GtkWidget *demosaic_method_bayer;</a>
<a name="ln100">  GtkWidget *demosaic_method_xtrans;</a>
<a name="ln101">  GtkWidget *label_non_raw;</a>
<a name="ln102">} dt_iop_demosaic_gui_data_t;</a>
<a name="ln103"> </a>
<a name="ln104">typedef struct dt_iop_demosaic_global_data_t</a>
<a name="ln105">{</a>
<a name="ln106">  // demosaic pattern</a>
<a name="ln107">  int kernel_green_eq_lavg;</a>
<a name="ln108">  int kernel_green_eq_favg_reduce_first;</a>
<a name="ln109">  int kernel_green_eq_favg_reduce_second;</a>
<a name="ln110">  int kernel_green_eq_favg_apply;</a>
<a name="ln111">  int kernel_pre_median;</a>
<a name="ln112">  int kernel_passthrough_monochrome;</a>
<a name="ln113">  int kernel_ppg_green;</a>
<a name="ln114">  int kernel_ppg_redblue;</a>
<a name="ln115">  int kernel_zoom_half_size;</a>
<a name="ln116">  int kernel_downsample;</a>
<a name="ln117">  int kernel_border_interpolate;</a>
<a name="ln118">  int kernel_color_smoothing;</a>
<a name="ln119">  int kernel_zoom_passthrough_monochrome;</a>
<a name="ln120">  int kernel_vng_border_interpolate;</a>
<a name="ln121">  int kernel_vng_lin_interpolate;</a>
<a name="ln122">  int kernel_zoom_third_size;</a>
<a name="ln123">  int kernel_vng_green_equilibrate;</a>
<a name="ln124">  int kernel_vng_interpolate;</a>
<a name="ln125">  int kernel_markesteijn_initial_copy;</a>
<a name="ln126">  int kernel_markesteijn_green_minmax;</a>
<a name="ln127">  int kernel_markesteijn_interpolate_green;</a>
<a name="ln128">  int kernel_markesteijn_solitary_green;</a>
<a name="ln129">  int kernel_markesteijn_recalculate_green;</a>
<a name="ln130">  int kernel_markesteijn_red_and_blue;</a>
<a name="ln131">  int kernel_markesteijn_interpolate_twoxtwo;</a>
<a name="ln132">  int kernel_markesteijn_convert_yuv;</a>
<a name="ln133">  int kernel_markesteijn_differentiate;</a>
<a name="ln134">  int kernel_markesteijn_homo_threshold;</a>
<a name="ln135">  int kernel_markesteijn_homo_set;</a>
<a name="ln136">  int kernel_markesteijn_homo_sum;</a>
<a name="ln137">  int kernel_markesteijn_homo_max;</a>
<a name="ln138">  int kernel_markesteijn_homo_max_corr;</a>
<a name="ln139">  int kernel_markesteijn_homo_quench;</a>
<a name="ln140">  int kernel_markesteijn_zero;</a>
<a name="ln141">  int kernel_markesteijn_accu;</a>
<a name="ln142">  int kernel_markesteijn_final;</a>
<a name="ln143">} dt_iop_demosaic_global_data_t;</a>
<a name="ln144"> </a>
<a name="ln145">typedef struct dt_iop_demosaic_data_t</a>
<a name="ln146">{</a>
<a name="ln147">  uint32_t green_eq;</a>
<a name="ln148">  uint32_t color_smoothing;</a>
<a name="ln149">  uint32_t demosaicing_method;</a>
<a name="ln150">  uint32_t yet_unused_data_specific_to_demosaicing_method;</a>
<a name="ln151">  float median_thrs;</a>
<a name="ln152">  double CAM_to_RGB[3][4];</a>
<a name="ln153">} dt_iop_demosaic_data_t;</a>
<a name="ln154"> </a>
<a name="ln155">void amaze_demosaic_RT(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln156">                       float *out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln157">                       const uint32_t filters);</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">const char *name()</a>
<a name="ln161">{</a>
<a name="ln162">  return _(&quot;demosaic&quot;);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">int default_group()</a>
<a name="ln166">{</a>
<a name="ln167">  return IOP_GROUP_BASIC;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">int flags()</a>
<a name="ln171">{</a>
<a name="ln172">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_ONE_INSTANCE | IOP_FLAGS_FENCE;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln176">{</a>
<a name="ln177">  return iop_cs_RAW;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln181">{</a>
<a name="ln182">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;edge threshold&quot;));</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln186">{</a>
<a name="ln187">  dt_accel_connect_slider_iop(self, &quot;edge threshold&quot;,</a>
<a name="ln188">                              GTK_WIDGET(((dt_iop_demosaic_gui_data_t *)self-&gt;gui_data)-&gt;median_thrs));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln192">                  void *new_params, const int new_version)</a>
<a name="ln193">{</a>
<a name="ln194">  if(old_version == 2 &amp;&amp; new_version == 3)</a>
<a name="ln195">  {</a>
<a name="ln196">    dt_iop_demosaic_params_t *o = (dt_iop_demosaic_params_t *)old_params;</a>
<a name="ln197">    dt_iop_demosaic_params_t *n = (dt_iop_demosaic_params_t *)new_params;</a>
<a name="ln198">    n-&gt;green_eq = o-&gt;green_eq;</a>
<a name="ln199">    n-&gt;median_thrs = o-&gt;median_thrs;</a>
<a name="ln200">    n-&gt;color_smoothing = 0;</a>
<a name="ln201">    n-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PPG;</a>
<a name="ln202">    n-&gt;yet_unused_data_specific_to_demosaicing_method = 0;</a>
<a name="ln203">    return 0;</a>
<a name="ln204">  }</a>
<a name="ln205">  return 1;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">int input_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln209">                     dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln210">{</a>
<a name="ln211">  return iop_cs_RAW;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">int output_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln215">                      dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln216">{</a>
<a name="ln217">  return iop_cs_rgb;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">#ifdef HAVE_OPENCL</a>
<a name="ln221">static const char* method2string(dt_iop_demosaic_method_t method)</a>
<a name="ln222">{</a>
<a name="ln223">  const char *string;</a>
<a name="ln224"> </a>
<a name="ln225">  switch(method)</a>
<a name="ln226">  {</a>
<a name="ln227">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln228">      string = &quot;PPG&quot;;</a>
<a name="ln229">      break;</a>
<a name="ln230">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln231">      string = &quot;AMaZE&quot;;</a>
<a name="ln232">      break;</a>
<a name="ln233">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln234">      string = &quot;VNG4&quot;;</a>
<a name="ln235">      break;</a>
<a name="ln236">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln237">      string = &quot;passthrough monochrome&quot;;</a>
<a name="ln238">      break;</a>
<a name="ln239">    case DT_IOP_DEMOSAIC_VNG:</a>
<a name="ln240">      string = &quot;VNG (xtrans)&quot;;</a>
<a name="ln241">      break;</a>
<a name="ln242">    case DT_IOP_DEMOSAIC_MARKESTEIJN:</a>
<a name="ln243">      string = &quot;Markesteijn-1 (xtrans)&quot;;</a>
<a name="ln244">      break;</a>
<a name="ln245">    case DT_IOP_DEMOSAIC_MARKESTEIJN_3:</a>
<a name="ln246">      string = &quot;Markesteijn-3 (xtrans)&quot;;</a>
<a name="ln247">      break;</a>
<a name="ln248">    case DT_IOP_DEMOSAIC_FDC:</a>
<a name="ln249">      string = &quot;Frequency Domain Chroma (xtrans)&quot;;</a>
<a name="ln250">      break;</a>
<a name="ln251">    default:</a>
<a name="ln252">      string = &quot;(unknown method)&quot;;</a>
<a name="ln253">  }</a>
<a name="ln254">  return string;</a>
<a name="ln255">}</a>
<a name="ln256">#endif</a>
<a name="ln257"> </a>
<a name="ln258">#define SWAP(a, b)                                                                                           \</a>
<a name="ln259">  {                                                                                                          \</a>
<a name="ln260">    const float tmp = (b);                                                                                   \</a>
<a name="ln261">    (b) = (a);                                                                                               \</a>
<a name="ln262">    (a) = tmp;                                                                                               \</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">static void pre_median_b(float *out, const float *const in, const dt_iop_roi_t *const roi, const uint32_t filters,</a>
<a name="ln266">                         const int num_passes, const float threshold)</a>
<a name="ln267">{</a>
<a name="ln268">#if 1</a>
<a name="ln269">  memcpy(out, in, (size_t)roi-&gt;width * roi-&gt;height * sizeof(float));</a>
<a name="ln270">#else</a>
<a name="ln271">  // colors:</a>
<a name="ln272">  const float thrsc = 2 * threshold;</a>
<a name="ln273">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln274">  {</a>
<a name="ln275">    for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln276">    {</a>
<a name="ln277">      int rows = 3;</a>
<a name="ln278">      if(FC(rows, 3, filters) != c &amp;&amp; FC(rows, 4, filters) != c) rows++;</a>
<a name="ln279">#ifdef _OPENMP</a>
<a name="ln280">#pragma omp parallel for default(none) shared(rows, c, out) schedule(static)</a>
<a name="ln281">#endif</a>
<a name="ln282">      for(int row = rows; row &lt; roi-&gt;height - 3; row += 2)</a>
<a name="ln283">      {</a>
<a name="ln284">        float med[9];</a>
<a name="ln285">        int col = 3;</a>
<a name="ln286">        if(FC(row, col, filters) != c) col++;</a>
<a name="ln287">        float *pixo = out + (size_t)roi-&gt;width * row + col;</a>
<a name="ln288">        const float *pixi = in + (size_t)roi-&gt;width * row + col;</a>
<a name="ln289">        for(; col &lt; roi-&gt;width - 3; col += 2)</a>
<a name="ln290">        {</a>
<a name="ln291">          int cnt = 0;</a>
<a name="ln292">          for(int k = 0, i = -2 * roi-&gt;width; i &lt;= 2 * roi-&gt;width; i += 2 * roi-&gt;width)</a>
<a name="ln293">          {</a>
<a name="ln294">            for(int j = i - 2; j &lt;= i + 2; j += 2)</a>
<a name="ln295">            {</a>
<a name="ln296">              if(fabsf(pixi[j] - pixi[0]) &lt; thrsc)</a>
<a name="ln297">              {</a>
<a name="ln298">                med[k++] = pixi[j];</a>
<a name="ln299">                cnt++;</a>
<a name="ln300">              }</a>
<a name="ln301">              else</a>
<a name="ln302">                med[k++] = 64.0f + pixi[j];</a>
<a name="ln303">            }</a>
<a name="ln304">          }</a>
<a name="ln305">          for(int i = 0; i &lt; 8; i++)</a>
<a name="ln306">            for(int ii = i + 1; ii &lt; 9; ii++)</a>
<a name="ln307">              if(med[i] &gt; med[ii]) SWAP(med[i], med[ii]);</a>
<a name="ln308">#if 0</a>
<a name="ln309">          // cnt == 1 and no small edge in greens.</a>
<a name="ln310">          if(fabsf(pixi[-roi-&gt;width] - pixi[+roi-&gt;width]) + fabsf(pixi[-1] - pixi[+1])</a>
<a name="ln311">              + fabsf(pixi[-roi-&gt;width] - pixi[+1]) + fabsf(pixi[-1] - pixi[+roi-&gt;width])</a>
<a name="ln312">              + fabsf(pixi[+roi-&gt;width] - pixi[+1]) + fabsf(pixi[-1] - pixi[-roi-&gt;width])</a>
<a name="ln313">              &gt; 0.06)</a>
<a name="ln314">            pixo[0] = med[(cnt-1)/2];</a>
<a name="ln315">          else</a>
<a name="ln316">#endif</a>
<a name="ln317">          pixo[0] = (cnt == 1 ? med[4] - 64.0f : med[(cnt - 1) / 2]);</a>
<a name="ln318">          pixo += 2;</a>
<a name="ln319">          pixi += 2;</a>
<a name="ln320">        }</a>
<a name="ln321">      }</a>
<a name="ln322">    }</a>
<a name="ln323">  }</a>
<a name="ln324">#endif</a>
<a name="ln325"> </a>
<a name="ln326">  // now green:</a>
<a name="ln327">  const int lim[5] = { 0, 1, 2, 1, 0 };</a>
<a name="ln328">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln329">  {</a>
<a name="ln330">#ifdef _OPENMP</a>
<a name="ln331">#pragma omp parallel for default(none) \</a>
<a name="ln332">    dt_omp_firstprivate(filters, in, lim, roi, threshold) \</a>
<a name="ln333">    shared(out) \</a>
<a name="ln334">    schedule(static)</a>
<a name="ln335">#endif</a>
<a name="ln336">    for(int row = 3; row &lt; roi-&gt;height - 3; row++)</a>
<a name="ln337">    {</a>
<a name="ln338">      float med[9];</a>
<a name="ln339">      int col = 3;</a>
<a name="ln340">      if(FC(row, col, filters) != 1 &amp;&amp; FC(row, col, filters) != 3) col++;</a>
<a name="ln341">      float *pixo = out + (size_t)roi-&gt;width * row + col;</a>
<a name="ln342">      const float *pixi = in + (size_t)roi-&gt;width * row + col;</a>
<a name="ln343">      for(; col &lt; roi-&gt;width - 3; col += 2)</a>
<a name="ln344">      {</a>
<a name="ln345">        int cnt = 0;</a>
<a name="ln346">        for(int k = 0, i = 0; i &lt; 5; i++)</a>
<a name="ln347">        {</a>
<a name="ln348">          for(int j = -lim[i]; j &lt;= lim[i]; j += 2)</a>
<a name="ln349">          {</a>
<a name="ln350">            if(fabsf(pixi[roi-&gt;width * (i - 2) + j] - pixi[0]) &lt; threshold)</a>
<a name="ln351">            {</a>
<a name="ln352">              med[k++] = pixi[roi-&gt;width * (i - 2) + j];</a>
<a name="ln353">              cnt++;</a>
<a name="ln354">            }</a>
<a name="ln355">            else</a>
<a name="ln356">              med[k++] = 64.0f + pixi[roi-&gt;width * (i - 2) + j];</a>
<a name="ln357">          }</a>
<a name="ln358">        }</a>
<a name="ln359">        for(int i = 0; i &lt; 8; i++)</a>
<a name="ln360">          for(int ii = i + 1; ii &lt; 9; ii++)</a>
<a name="ln361">            if(med[i] &gt; med[ii]) SWAP(med[i], med[ii]);</a>
<a name="ln362">        pixo[0] = (cnt == 1 ? med[4] - 64.0f : med[(cnt - 1) / 2]);</a>
<a name="ln363">        // pixo[0] = med[(cnt-1)/2];</a>
<a name="ln364">        pixo += 2;</a>
<a name="ln365">        pixi += 2;</a>
<a name="ln366">      }</a>
<a name="ln367">    }</a>
<a name="ln368">  }</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">static void pre_median(float *out, const float *const in, const dt_iop_roi_t *const roi, const uint32_t filters,</a>
<a name="ln372">                       const int num_passes, const float threshold)</a>
<a name="ln373">{</a>
<a name="ln374">  pre_median_b(out, in, roi, filters, num_passes, threshold);</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">#define SWAPmed(I, J)                                                                                        \</a>
<a name="ln378">  if(med[I] &gt; med[J]) SWAP(med[I], med[J])</a>
<a name="ln379"> </a>
<a name="ln380">static void color_smoothing(float *out, const dt_iop_roi_t *const roi_out, const int num_passes)</a>
<a name="ln381">{</a>
<a name="ln382">  const int width4 = 4 * roi_out-&gt;width;</a>
<a name="ln383"> </a>
<a name="ln384">  for(int pass = 0; pass &lt; num_passes; pass++)</a>
<a name="ln385">  {</a>
<a name="ln386">    for(int c = 0; c &lt; 3; c += 2)</a>
<a name="ln387">    {</a>
<a name="ln388">      {</a>
<a name="ln389">        float *outp = out;</a>
<a name="ln390">        for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln391">          for(int i = 0; i &lt; roi_out-&gt;width; i++, outp += 4) outp[3] = outp[c];</a>
<a name="ln392">      }</a>
<a name="ln393">#ifdef _OPENMP</a>
<a name="ln394">#pragma omp parallel for default(none) \</a>
<a name="ln395">      dt_omp_firstprivate(roi_out, width4) \</a>
<a name="ln396">      shared(out, c) \</a>
<a name="ln397">      schedule(static)</a>
<a name="ln398">#endif</a>
<a name="ln399">      for(int j = 1; j &lt; roi_out-&gt;height - 1; j++)</a>
<a name="ln400">      {</a>
<a name="ln401">        float *outp = out + (size_t)4 * j * roi_out-&gt;width + 4;</a>
<a name="ln402">        for(int i = 1; i &lt; roi_out-&gt;width - 1; i++, outp += 4)</a>
<a name="ln403">        {</a>
<a name="ln404">          float med[9] = {</a>
<a name="ln405">            outp[-width4 - 4 + 3] - outp[-width4 - 4 + 1], outp[-width4 + 0 + 3] - outp[-width4 + 0 + 1],</a>
<a name="ln406">            outp[-width4 + 4 + 3] - outp[-width4 + 4 + 1], outp[-4 + 3] - outp[-4 + 1],</a>
<a name="ln407">            outp[+0 + 3] - outp[+0 + 1], outp[+4 + 3] - outp[+4 + 1],</a>
<a name="ln408">            outp[+width4 - 4 + 3] - outp[+width4 - 4 + 1], outp[+width4 + 0 + 3] - outp[+width4 + 0 + 1],</a>
<a name="ln409">            outp[+width4 + 4 + 3] - outp[+width4 + 4 + 1],</a>
<a name="ln410">          };</a>
<a name="ln411">          /* optimal 9-element median search */</a>
<a name="ln412">          SWAPmed(1, 2);</a>
<a name="ln413">          SWAPmed(4, 5);</a>
<a name="ln414">          SWAPmed(7, 8);</a>
<a name="ln415">          SWAPmed(0, 1);</a>
<a name="ln416">          SWAPmed(3, 4);</a>
<a name="ln417">          SWAPmed(6, 7);</a>
<a name="ln418">          SWAPmed(1, 2);</a>
<a name="ln419">          SWAPmed(4, 5);</a>
<a name="ln420">          SWAPmed(7, 8);</a>
<a name="ln421">          SWAPmed(0, 3);</a>
<a name="ln422">          SWAPmed(5, 8);</a>
<a name="ln423">          SWAPmed(4, 7);</a>
<a name="ln424">          SWAPmed(3, 6);</a>
<a name="ln425">          SWAPmed(1, 4);</a>
<a name="ln426">          SWAPmed(2, 5);</a>
<a name="ln427">          SWAPmed(4, 7);</a>
<a name="ln428">          SWAPmed(4, 2);</a>
<a name="ln429">          SWAPmed(6, 4);</a>
<a name="ln430">          SWAPmed(4, 2);</a>
<a name="ln431">          outp[c] = fmaxf(med[4] + outp[1], 0.0f);</a>
<a name="ln432">        }</a>
<a name="ln433">      }</a>
<a name="ln434">    }</a>
<a name="ln435">  }</a>
<a name="ln436">}</a>
<a name="ln437">#undef SWAP</a>
<a name="ln438"> </a>
<a name="ln439">static void green_equilibration_lavg(float *out, const float *const in, const int width, const int height,</a>
<a name="ln440">                                     const uint32_t filters, const int x, const int y, const float thr)</a>
<a name="ln441">{</a>
<a name="ln442">  const float maximum = 1.0f;</a>
<a name="ln443"> </a>
<a name="ln444">  int oj = 2, oi = 2;</a>
<a name="ln445">  if(FC(oj + y, oi + x, filters) != 1) oj++;</a>
<a name="ln446">  if(FC(oj + y, oi + x, filters) != 1) oi++;</a>
<a name="ln447">  if(FC(oj + y, oi + x, filters) != 1) oj--;</a>
<a name="ln448"> </a>
<a name="ln449">  memcpy(out, in, height * width * sizeof(float));</a>
<a name="ln450"> </a>
<a name="ln451">#ifdef _OPENMP</a>
<a name="ln452">#pragma omp parallel for default(none) \</a>
<a name="ln453">  dt_omp_firstprivate(height, in, thr, width, maximum) \</a>
<a name="ln454">  shared(out, oi, oj) \</a>
<a name="ln455">  schedule(static)</a>
<a name="ln456">#endif</a>
<a name="ln457">  for(size_t j = oj; j &lt; height - 2; j += 2)</a>
<a name="ln458">  {</a>
<a name="ln459">    for(size_t i = oi; i &lt; width - 2; i += 2)</a>
<a name="ln460">    {</a>
<a name="ln461">      const float o1_1 = in[(j - 1) * width + i - 1];</a>
<a name="ln462">      const float o1_2 = in[(j - 1) * width + i + 1];</a>
<a name="ln463">      const float o1_3 = in[(j + 1) * width + i - 1];</a>
<a name="ln464">      const float o1_4 = in[(j + 1) * width + i + 1];</a>
<a name="ln465">      const float o2_1 = in[(j - 2) * width + i];</a>
<a name="ln466">      const float o2_2 = in[(j + 2) * width + i];</a>
<a name="ln467">      const float o2_3 = in[j * width + i - 2];</a>
<a name="ln468">      const float o2_4 = in[j * width + i + 2];</a>
<a name="ln469"> </a>
<a name="ln470">      const float m1 = (o1_1 + o1_2 + o1_3 + o1_4) / 4.0f;</a>
<a name="ln471">      const float m2 = (o2_1 + o2_2 + o2_3 + o2_4) / 4.0f;</a>
<a name="ln472"> </a>
<a name="ln473">      // prevent divide by zero and ...</a>
<a name="ln474">      // guard against m1/m2 becoming too large (due to m2 being too small) which results in hot pixels</a>
<a name="ln475">      if(m2 &gt; 0.0f &amp;&amp; m1 / m2 &lt; maximum * 2.0f)</a>
<a name="ln476">      {</a>
<a name="ln477">        const float c1 = (fabsf(o1_1 - o1_2) + fabsf(o1_1 - o1_3) + fabsf(o1_1 - o1_4) + fabsf(o1_2 - o1_3)</a>
<a name="ln478">                          + fabsf(o1_3 - o1_4) + fabsf(o1_2 - o1_4)) / 6.0f;</a>
<a name="ln479">        const float c2 = (fabsf(o2_1 - o2_2) + fabsf(o2_1 - o2_3) + fabsf(o2_1 - o2_4) + fabsf(o2_2 - o2_3)</a>
<a name="ln480">                          + fabsf(o2_3 - o2_4) + fabsf(o2_2 - o2_4)) / 6.0f;</a>
<a name="ln481">        if((in[j * width + i] &lt; maximum * 0.95f) &amp;&amp; (c1 &lt; maximum * thr) &amp;&amp; (c2 &lt; maximum * thr))</a>
<a name="ln482">        {</a>
<a name="ln483">          out[j * width + i] = in[j * width + i] * m1 / m2;</a>
<a name="ln484">        }</a>
<a name="ln485">      }</a>
<a name="ln486">    }</a>
<a name="ln487">  }</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">static void green_equilibration_favg(float *out, const float *const in, const int width, const int height,</a>
<a name="ln491">                                     const uint32_t filters, const int x, const int y)</a>
<a name="ln492">{</a>
<a name="ln493">  int oj = 0, oi = 0;</a>
<a name="ln494">  // const float ratio_max = 1.1f;</a>
<a name="ln495">  double sum1 = 0.0, sum2 = 0.0, gr_ratio;</a>
<a name="ln496"> </a>
<a name="ln497">  if((FC(oj + y, oi + x, filters) &amp; 1) != 1) oi++;</a>
<a name="ln498">  const int g2_offset = oi ? -1 : 1;</a>
<a name="ln499">  memcpy(out, in, (size_t)height * width * sizeof(float));</a>
<a name="ln500">#ifdef _OPENMP</a>
<a name="ln501">#pragma omp parallel for default(none) \</a>
<a name="ln502">  dt_omp_firstprivate(g2_offset, height, in, width) \</a>
<a name="ln503">  reduction(+ : sum1, sum2) \</a>
<a name="ln504">  shared(oi, oj) \</a>
<a name="ln505">  schedule(static)</a>
<a name="ln506">#endif</a>
<a name="ln507">  for(size_t j = oj; j &lt; (height - 1); j += 2)</a>
<a name="ln508">  {</a>
<a name="ln509">    for(size_t i = oi; i &lt; (width - 1 - g2_offset); i += 2)</a>
<a name="ln510">    {</a>
<a name="ln511">      sum1 += in[j * width + i];</a>
<a name="ln512">      sum2 += in[(j + 1) * width + i + g2_offset];</a>
<a name="ln513">    }</a>
<a name="ln514">  }</a>
<a name="ln515"> </a>
<a name="ln516">  if(sum1 &gt; 0.0 &amp;&amp; sum2 &gt; 0.0)</a>
<a name="ln517">    gr_ratio = sum2 / sum1;</a>
<a name="ln518">  else</a>
<a name="ln519">    return;</a>
<a name="ln520"> </a>
<a name="ln521">#ifdef _OPENMP</a>
<a name="ln522">#pragma omp parallel for default(none) \</a>
<a name="ln523">  dt_omp_firstprivate(g2_offset, height, in, width) \</a>
<a name="ln524">  shared(out, oi, oj, gr_ratio) \</a>
<a name="ln525">  schedule(static)</a>
<a name="ln526">#endif</a>
<a name="ln527">  for(int j = oj; j &lt; (height - 1); j += 2)</a>
<a name="ln528">  {</a>
<a name="ln529">    for(int i = oi; i &lt; (width - 1 - g2_offset); i += 2)</a>
<a name="ln530">    {</a>
<a name="ln531">      out[(size_t)j * width + i] = in[(size_t)j * width + i] * gr_ratio;</a>
<a name="ln532">    }</a>
<a name="ln533">  }</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">//</a>
<a name="ln538">// x-trans specific demosaicing algorithms</a>
<a name="ln539">//</a>
<a name="ln540"> </a>
<a name="ln541">// xtrans_interpolate adapted from dcraw 9.20</a>
<a name="ln542"> </a>
<a name="ln543">#define SQR(x) ((x) * (x))</a>
<a name="ln544">// tile size, optimized to keep data in L2 cache</a>
<a name="ln545">#define TS 122</a>
<a name="ln546"> </a>
<a name="ln547">/** Lookup for allhex[], making sure that row/col aren't negative **/</a>
<a name="ln548">static inline const short * hexmap(const int row, const int col, short (*const allhex)[3][8])</a>
<a name="ln549">{</a>
<a name="ln550">  // Row and column offsets may be negative, but C's modulo function</a>
<a name="ln551">  // is not useful here with a negative dividend. To be safe, add a</a>
<a name="ln552">  // fairly large multiple of 3. In current code row and col will</a>
<a name="ln553">  // never be less than -9 (1-pass) or -14 (3-pass).</a>
<a name="ln554">  int irow = row + 600;</a>
<a name="ln555">  int icol = col + 600;</a>
<a name="ln556">  assert(irow &gt;= 0 &amp;&amp; icol &gt;= 0);</a>
<a name="ln557">  return allhex[irow % 3][icol % 3];</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">/*</a>
<a name="ln561">   Frank Markesteijn's algorithm for Fuji X-Trans sensors</a>
<a name="ln562"> */</a>
<a name="ln563">static void xtrans_markesteijn_interpolate(float *out, const float *const in,</a>
<a name="ln564">                                           const dt_iop_roi_t *const roi_out,</a>
<a name="ln565">                                           const dt_iop_roi_t *const roi_in,</a>
<a name="ln566">                                           const uint8_t (*const xtrans)[6], const int passes)</a>
<a name="ln567">{</a>
<a name="ln568">  static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln569">                     patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln570">                                     { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } },</a>
<a name="ln571">                     dir[4] = { 1, TS, TS + 1, TS - 1 };</a>
<a name="ln572"> </a>
<a name="ln573">  short allhex[3][3][8];</a>
<a name="ln574">  // sgrow/sgcol is the offset in the sensor matrix of the solitary</a>
<a name="ln575">  // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln576">  unsigned short sgrow = 0, sgcol = 0;</a>
<a name="ln577"> </a>
<a name="ln578">  const int width = roi_out-&gt;width;</a>
<a name="ln579">  const int height = roi_out-&gt;height;</a>
<a name="ln580">  const int ndir = 4 &lt;&lt; (passes &gt; 1);</a>
<a name="ln581"> </a>
<a name="ln582">  const size_t buffer_size = (size_t)TS * TS * (ndir * 4 + 3) * sizeof(float);</a>
<a name="ln583">  char *const all_buffers = (char *)dt_alloc_align(64, dt_get_num_threads() * buffer_size);</a>
<a name="ln584">  if(!all_buffers)</a>
<a name="ln585">  {</a>
<a name="ln586">    printf(&quot;[demosaic] not able to allocate Markesteijn buffers\n&quot;);</a>
<a name="ln587">    return;</a>
<a name="ln588">  }</a>
<a name="ln589"> </a>
<a name="ln590">  /* Map a green hexagon around each non-green pixel and vice versa:    */</a>
<a name="ln591">  for(int row = 0; row &lt; 3; row++)</a>
<a name="ln592">    for(int col = 0; col &lt; 3; col++)</a>
<a name="ln593">      for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln594">      {</a>
<a name="ln595">        int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln596">        if(FCxtrans(row + orth[d], col + orth[d + 2], NULL, xtrans) == 1)</a>
<a name="ln597">          ng = 0;</a>
<a name="ln598">        else</a>
<a name="ln599">          ng++;</a>
<a name="ln600">        // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln601">        // directions, this is the solitary green pixel</a>
<a name="ln602">        if(ng == 4)</a>
<a name="ln603">        {</a>
<a name="ln604">          sgrow = row;</a>
<a name="ln605">          sgcol = col;</a>
<a name="ln606">        }</a>
<a name="ln607">        if(ng == g + 1)</a>
<a name="ln608">          for(int c = 0; c &lt; 8; c++)</a>
<a name="ln609">          {</a>
<a name="ln610">            int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln611">            int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln612">            // offset within TSxTS buffer</a>
<a name="ln613">            allhex[row][col][c ^ (g * 2 &amp; d)] = h + v * TS;</a>
<a name="ln614">          }</a>
<a name="ln615">      }</a>
<a name="ln616"> </a>
<a name="ln617">  // extra passes propagates out errors at edges, hence need more padding</a>
<a name="ln618">  const int pad_tile = (passes == 1) ? 12 : 17;</a>
<a name="ln619">#ifdef _OPENMP</a>
<a name="ln620">#pragma omp parallel for default(none) \</a>
<a name="ln621">  dt_omp_firstprivate(all_buffers, buffer_size, dir, height, in, ndir, pad_tile, passes, roi_in, width, xtrans) \</a>
<a name="ln622">  shared(sgrow, sgcol, allhex, out) \</a>
<a name="ln623">  schedule(dynamic)</a>
<a name="ln624">#endif</a>
<a name="ln625">  // step through TSxTS cells of image, each tile overlapping the</a>
<a name="ln626">  // prior as interpolation needs a substantial border</a>
<a name="ln627">  for(int top = -pad_tile; top &lt; height - pad_tile; top += TS - (pad_tile*2))</a>
<a name="ln628">  {</a>
<a name="ln629">    char *const buffer = all_buffers + dt_get_thread_num() * buffer_size;</a>
<a name="ln630">    // rgb points to ndir TSxTS tiles of 3 channels (R, G, and B)</a>
<a name="ln631">    float(*rgb)[TS][TS][3] = (float(*)[TS][TS][3])buffer;</a>
<a name="ln632">    // yuv points to 3 channel (Y, u, and v) TSxTS tiles</a>
<a name="ln633">    // note that channels come before tiles to allow for a</a>
<a name="ln634">    // vectorization optimization when building drv[] from yuv[]</a>
<a name="ln635">    float (*const yuv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln636">    // drv points to ndir TSxTS tiles, each a single channel of derivatives</a>
<a name="ln637">    float (*const drv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3 + 3) * sizeof(float));</a>
<a name="ln638">    // gmin and gmax reuse memory which is used later by yuv buffer;</a>
<a name="ln639">    // each points to a TSxTS tile of single channel data</a>
<a name="ln640">    float (*const gmin)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln641">    float (*const gmax)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3 + 1) * sizeof(float));</a>
<a name="ln642">    // homo and homosum reuse memory which is used earlier in the</a>
<a name="ln643">    // loop; each points to ndir single-channel TSxTS tiles</a>
<a name="ln644">    uint8_t (*const homo)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln645">    uint8_t (*const homosum)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float)</a>
<a name="ln646">                                                            + TS * TS * ndir * sizeof(uint8_t));</a>
<a name="ln647"> </a>
<a name="ln648">    for(int left = -pad_tile; left &lt; width - pad_tile; left += TS - (pad_tile*2))</a>
<a name="ln649">    {</a>
<a name="ln650">      int mrow = MIN(top + TS, height + pad_tile);</a>
<a name="ln651">      int mcol = MIN(left + TS, width + pad_tile);</a>
<a name="ln652"> </a>
<a name="ln653">      // Copy current tile from in to image buffer. If border goes</a>
<a name="ln654">      // beyond edges of image, fill with mirrored/interpolated edges.</a>
<a name="ln655">      // The extra border avoids discontinuities at image edges.</a>
<a name="ln656">      for(int row = top; row &lt; mrow; row++)</a>
<a name="ln657">        for(int col = left; col &lt; mcol; col++)</a>
<a name="ln658">        {</a>
<a name="ln659">          float(*const pix) = rgb[0][row - top][col - left];</a>
<a name="ln660">          if((col &gt;= 0) &amp;&amp; (row &gt;= 0) &amp;&amp; (col &lt; width) &amp;&amp; (row &lt; height))</a>
<a name="ln661">          {</a>
<a name="ln662">            const int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln663">            for(int c = 0; c &lt; 3; c++) pix[c] = (c == f) ? in[roi_in-&gt;width * row + col] : 0.f;</a>
<a name="ln664">          }</a>
<a name="ln665">          else</a>
<a name="ln666">          {</a>
<a name="ln667">            // mirror a border pixel if beyond image edge</a>
<a name="ln668">            const int c = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln669">            for(int cc = 0; cc &lt; 3; cc++)</a>
<a name="ln670">              if(cc != c)</a>
<a name="ln671">                pix[cc] = 0.0f;</a>
<a name="ln672">              else</a>
<a name="ln673">              {</a>
<a name="ln674">#define TRANSLATE(n, size) ((n &gt;= size) ? (2 * size - n - 2) : abs(n))</a>
<a name="ln675">                const int cy = TRANSLATE(row, height), cx = TRANSLATE(col, width);</a>
<a name="ln676">                if(c == FCxtrans(cy, cx, roi_in, xtrans))</a>
<a name="ln677">                  pix[c] = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln678">                else</a>
<a name="ln679">                {</a>
<a name="ln680">                  // interpolate if mirror pixel is a different color</a>
<a name="ln681">                  float sum = 0.0f;</a>
<a name="ln682">                  uint8_t count = 0;</a>
<a name="ln683">                  for(int y = row - 1; y &lt;= row + 1; y++)</a>
<a name="ln684">                    for(int x = col - 1; x &lt;= col + 1; x++)</a>
<a name="ln685">                    {</a>
<a name="ln686">                      const int yy = TRANSLATE(y, height), xx = TRANSLATE(x, width);</a>
<a name="ln687">                      const int ff = FCxtrans(yy, xx, roi_in, xtrans);</a>
<a name="ln688">                      if(ff == c)</a>
<a name="ln689">                      {</a>
<a name="ln690">                        sum += in[roi_in-&gt;width * yy + xx];</a>
<a name="ln691">                        count++;</a>
<a name="ln692">                      }</a>
<a name="ln693">                    }</a>
<a name="ln694">                  pix[c] = sum / count;</a>
<a name="ln695">                }</a>
<a name="ln696">              }</a>
<a name="ln697">          }</a>
<a name="ln698">        }</a>
<a name="ln699"> </a>
<a name="ln700">      // duplicate rgb[0] to rgb[1], rgb[2], and rgb[3]</a>
<a name="ln701">      for(int c = 1; c &lt;= 3; c++) memcpy(rgb[c], rgb[0], sizeof(*rgb));</a>
<a name="ln702"> </a>
<a name="ln703">      // note that successive calculations are inset within the tile</a>
<a name="ln704">      // so as to give enough border data, and there needs to be a 6</a>
<a name="ln705">      // pixel border initially to allow allhex to find neighboring</a>
<a name="ln706">      // pixels</a>
<a name="ln707"> </a>
<a name="ln708">      /* Set green1 and green3 to the minimum and maximum allowed values:   */</a>
<a name="ln709">      // Run through each red/blue or blue/red pair, setting their g1</a>
<a name="ln710">      // and g3 values to the min/max of green pixels surrounding the</a>
<a name="ln711">      // pair. Use a 3 pixel border as gmin/gmax is used by</a>
<a name="ln712">      // interpolate green which has a 3 pixel border.</a>
<a name="ln713">      const int pad_g1_g3 = 3;</a>
<a name="ln714">      for(int row = top + pad_g1_g3; row &lt; mrow - pad_g1_g3; row++)</a>
<a name="ln715">      {</a>
<a name="ln716">        // setting max to 0.0f signifies that this is a new pair, which</a>
<a name="ln717">        // requires a new min/max calculation of its neighboring greens</a>
<a name="ln718">        float min = FLT_MAX, max = 0.0f;</a>
<a name="ln719">        for(int col = left + pad_g1_g3; col &lt; mcol - pad_g1_g3; col++)</a>
<a name="ln720">        {</a>
<a name="ln721">          // if in row of horizontal red &amp; blue pairs (or processing</a>
<a name="ln722">          // vertical red &amp; blue pairs near image bottom), reset min/max</a>
<a name="ln723">          // between each pair</a>
<a name="ln724">          if(FCxtrans(row, col, roi_in, xtrans) == 1)</a>
<a name="ln725">          {</a>
<a name="ln726">            min = FLT_MAX, max = 0.0f;</a>
<a name="ln727">            continue;</a>
<a name="ln728">          }</a>
<a name="ln729">          // if at start of red &amp; blue pair, calculate min/max of green</a>
<a name="ln730">          // pixels surrounding it; note that while normally using == to</a>
<a name="ln731">          // compare floats is suspect, here the check is if 0.0f has</a>
<a name="ln732">          // explicitly been assigned to max (which signifies a new</a>
<a name="ln733">          // red/blue pair)</a>
<a name="ln734">          if(max == 0.0f)</a>
<a name="ln735">          {</a>
<a name="ln736">            float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln737">            const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln738">            for(int c = 0; c &lt; 6; c++)</a>
<a name="ln739">            {</a>
<a name="ln740">              const float val = pix[hex[c]][1];</a>
<a name="ln741">              if(min &gt; val) min = val;</a>
<a name="ln742">              if(max &lt; val) max = val;</a>
<a name="ln743">            }</a>
<a name="ln744">          }</a>
<a name="ln745">          gmin[row - top][col - left] = min;</a>
<a name="ln746">          gmax[row - top][col - left] = max;</a>
<a name="ln747">          // handle vertical red/blue pairs</a>
<a name="ln748">          switch((row - sgrow) % 3)</a>
<a name="ln749">          {</a>
<a name="ln750">            // hop down a row to second pixel in vertical pair</a>
<a name="ln751">            case 1:</a>
<a name="ln752">              if(row &lt; mrow - 4) row++, col--;</a>
<a name="ln753">              break;</a>
<a name="ln754">            // then if not done with the row hop up and right to next</a>
<a name="ln755">            // vertical red/blue pair, resetting min/max</a>
<a name="ln756">            case 2:</a>
<a name="ln757">              min = FLT_MAX, max = 0.0f;</a>
<a name="ln758">              if((col += 2) &lt; mcol - 4 &amp;&amp; row &gt; top + 3) row--;</a>
<a name="ln759">          }</a>
<a name="ln760">        }</a>
<a name="ln761">      }</a>
<a name="ln762"> </a>
<a name="ln763">      /* Interpolate green horizontally, vertically, and along both diagonals: */</a>
<a name="ln764">      // need a 3 pixel border here as 3*hex[] can have a 3 unit offset</a>
<a name="ln765">      const int pad_g_interp = 3;</a>
<a name="ln766">      for(int row = top + pad_g_interp; row &lt; mrow - pad_g_interp; row++)</a>
<a name="ln767">        for(int col = left + pad_g_interp; col &lt; mcol - pad_g_interp; col++)</a>
<a name="ln768">        {</a>
<a name="ln769">          float color[8];</a>
<a name="ln770">          int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln771">          if(f == 1) continue;</a>
<a name="ln772">          float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln773">          const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln774">          // TODO: these constants come from integer math constants in</a>
<a name="ln775">          // dcraw -- calculate them instead from interpolation math</a>
<a name="ln776">          color[0] = 0.6796875f * (pix[hex[1]][1] + pix[hex[0]][1])</a>
<a name="ln777">                     - 0.1796875f * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);</a>
<a name="ln778">          color[1] = 0.87109375f * pix[hex[3]][1] + pix[hex[2]][1] * 0.13f</a>
<a name="ln779">                     + 0.359375f * (pix[0][f] - pix[-hex[2]][f]);</a>
<a name="ln780">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln781">            color[2 + c] = 0.640625f * pix[hex[4 + c]][1] + 0.359375f * pix[-2 * hex[4 + c]][1]</a>
<a name="ln782">                           + 0.12890625f * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);</a>
<a name="ln783">          for(int c = 0; c &lt; 4; c++)</a>
<a name="ln784">            rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1]</a>
<a name="ln785">                = CLAMPS(color[c], gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln786">        }</a>
<a name="ln787"> </a>
<a name="ln788">      for(int pass = 0; pass &lt; passes; pass++)</a>
<a name="ln789">      {</a>
<a name="ln790">        if(pass == 1)</a>
<a name="ln791">        {</a>
<a name="ln792">          // if on second pass, copy rgb[0] to [3] into rgb[4] to [7],</a>
<a name="ln793">          // and process that second set of buffers</a>
<a name="ln794">          memcpy(rgb + 4, rgb, (size_t)4 * sizeof(*rgb));</a>
<a name="ln795">          rgb += 4;</a>
<a name="ln796">        }</a>
<a name="ln797"> </a>
<a name="ln798">        /* Recalculate green from interpolated values of closer pixels: */</a>
<a name="ln799">        if(pass)</a>
<a name="ln800">        {</a>
<a name="ln801">          const int pad_g_recalc = 6;</a>
<a name="ln802">          for(int row = top + pad_g_recalc; row &lt; mrow - pad_g_recalc; row++)</a>
<a name="ln803">            for(int col = left + pad_g_recalc; col &lt; mcol - pad_g_recalc; col++)</a>
<a name="ln804">            {</a>
<a name="ln805">              int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln806">              if(f == 1) continue;</a>
<a name="ln807">              const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln808">              for(int d = 3; d &lt; 6; d++)</a>
<a name="ln809">              {</a>
<a name="ln810">                float(*rfx)[3] = &amp;rgb[(d - 2) ^ !((row - sgrow) % 3)][row - top][col - left];</a>
<a name="ln811">                float val = rfx[-2 * hex[d]][1] + 2 * rfx[hex[d]][1] - rfx[-2 * hex[d]][f]</a>
<a name="ln812">                            - 2 * rfx[hex[d]][f] + 3 * rfx[0][f];</a>
<a name="ln813">                rfx[0][1] = CLAMPS(val / 3.0f, gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln814">              }</a>
<a name="ln815">            }</a>
<a name="ln816">        }</a>
<a name="ln817"> </a>
<a name="ln818">        /* Interpolate red and blue values for solitary green pixels:   */</a>
<a name="ln819">        const int pad_rb_g = (passes == 1) ? 6 : 5;</a>
<a name="ln820">        for(int row = (top - sgrow + pad_rb_g + 2) / 3 * 3 + sgrow; row &lt; mrow - pad_rb_g; row += 3)</a>
<a name="ln821">          for(int col = (left - sgcol + pad_rb_g + 2) / 3 * 3 + sgcol; col &lt; mcol - pad_rb_g; col += 3)</a>
<a name="ln822">          {</a>
<a name="ln823">            float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln824">            int h = FCxtrans(row, col + 1, roi_in, xtrans);</a>
<a name="ln825">            float diff[6] = { 0.0f };</a>
<a name="ln826">            // interplated color: first index is red/blue, second is</a>
<a name="ln827">            // pass, is double actual result</a>
<a name="ln828">            float color[2][6];</a>
<a name="ln829">            // Six passes, alternating hori/vert interp (i),</a>
<a name="ln830">            // starting with R or B (h) depending on which is closest.</a>
<a name="ln831">            // Passes 0,1 to rgb[0], rgb[1] of hori/vert interp. Pass</a>
<a name="ln832">            // 3,5 to rgb[2], rgb[3] of best of interp hori/vert</a>
<a name="ln833">            // results. Each pass which outputs moves on to the next</a>
<a name="ln834">            // rgb[] for input of interp greens.</a>
<a name="ln835">            for(int i = 1, d = 0; d &lt; 6; d++, i ^= TS ^ 1, h ^= 2)</a>
<a name="ln836">            {</a>
<a name="ln837">              // look 1 and 2 pixels distance from solitary green to</a>
<a name="ln838">              // red then blue or blue then red</a>
<a name="ln839">              for(int c = 0; c &lt; 2; c++, h ^= 2)</a>
<a name="ln840">              {</a>
<a name="ln841">                // rate of change in greens between current pixel and</a>
<a name="ln842">                // interpolated pixels 1 or 2 distant: a quick</a>
<a name="ln843">                // derivative which will be divided by two later to be</a>
<a name="ln844">                // rate of luminance change for red/blue between known</a>
<a name="ln845">                // red/blue neighbors and the current unknown pixel</a>
<a name="ln846">                float g = 2 * rfx[0][1] - rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1];</a>
<a name="ln847">                // color is halved before being stored in rgb, hence</a>
<a name="ln848">                // this becomes green rate of change plus the average</a>
<a name="ln849">                // of the near red or blue pixels on current axis</a>
<a name="ln850">                color[h != 0][d] = g + rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h];</a>
<a name="ln851">                // Note that diff will become the slope for both red</a>
<a name="ln852">                // and blue differentials in the current direction.</a>
<a name="ln853">                // For 2nd and 3rd hori+vert passes, create a sum of</a>
<a name="ln854">                // steepness for both cardinal directions.</a>
<a name="ln855">                if(d &gt; 1)</a>
<a name="ln856">                  diff[d] += SQR(rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1] - rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h])</a>
<a name="ln857">                             + SQR(g);</a>
<a name="ln858">              }</a>
<a name="ln859">              if((d &lt; 2) || (d &amp; 1))</a>
<a name="ln860">              { // output for passes 0, 1, 3, 5</a>
<a name="ln861">                // for 0, 1 just use hori/vert, for 3, 5 use best of x/y dir</a>
<a name="ln862">                const int d_out = d - ((d &gt; 1) &amp;&amp; (diff[d-1] &lt; diff[d]));</a>
<a name="ln863">                rfx[0][0] = color[0][d_out] / 2.f;</a>
<a name="ln864">                rfx[0][2] = color[1][d_out] / 2.f;</a>
<a name="ln865">                rfx += TS * TS;</a>
<a name="ln866">              }</a>
<a name="ln867">            }</a>
<a name="ln868">          }</a>
<a name="ln869"> </a>
<a name="ln870">        /* Interpolate red for blue pixels and vice versa:              */</a>
<a name="ln871">        const int pad_rb_br = (passes == 1) ? 6 : 5;</a>
<a name="ln872">        for(int row = top + pad_rb_br; row &lt; mrow - pad_rb_br; row++)</a>
<a name="ln873">          for(int col = left + pad_rb_br; col &lt; mcol - pad_rb_br; col++)</a>
<a name="ln874">          {</a>
<a name="ln875">            int f = 2 - FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln876">            if(f == 1) continue;</a>
<a name="ln877">            float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln878">            int c = (row - sgrow) % 3 ? TS : 1;</a>
<a name="ln879">            int h = 3 * (c ^ TS ^ 1);</a>
<a name="ln880">            for(int d = 0; d &lt; 4; d++, rfx += TS * TS)</a>
<a name="ln881">            {</a>
<a name="ln882">              int i = d &gt; 1 || ((d ^ c) &amp; 1) ||</a>
<a name="ln883">                ((fabsf(rfx[0][1]-rfx[c][1]) + fabsf(rfx[0][1]-rfx[-c][1])) &lt;</a>
<a name="ln884">                 2.f*(fabsf(rfx[0][1]-rfx[h][1]) + fabsf(rfx[0][1]-rfx[-h][1]))) ? c:h;</a>
<a name="ln885">              rfx[0][f] = (rfx[i][f] + rfx[-i][f] + 2.f * rfx[0][1] - rfx[i][1] - rfx[-i][1]) / 2.f;</a>
<a name="ln886">            }</a>
<a name="ln887">          }</a>
<a name="ln888"> </a>
<a name="ln889">        /* Fill in red and blue for 2x2 blocks of green:                */</a>
<a name="ln890">        const int pad_g22 = (passes == 1) ? 8 : 4;</a>
<a name="ln891">        for(int row = top + pad_g22; row &lt; mrow - pad_g22; row++)</a>
<a name="ln892">          if((row - sgrow) % 3)</a>
<a name="ln893">            for(int col = left + pad_g22; col &lt; mcol - pad_g22; col++)</a>
<a name="ln894">              if((col - sgcol) % 3)</a>
<a name="ln895">              {</a>
<a name="ln896">                float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln897">                const short *const hex = hexmap(row,col,allhex);</a>
<a name="ln898">                for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln899">                  if(hex[d] + hex[d + 1])</a>
<a name="ln900">                  {</a>
<a name="ln901">                    float g = 3.f * rfx[0][1] - 2.f * rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln902">                    for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln903">                      rfx[0][c] = (g + 2.f * rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 3.f;</a>
<a name="ln904">                  }</a>
<a name="ln905">                  else</a>
<a name="ln906">                  {</a>
<a name="ln907">                    float g = 2.f * rfx[0][1] - rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln908">                    for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln909">                      rfx[0][c] = (g + rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 2.f;</a>
<a name="ln910">                  }</a>
<a name="ln911">              }</a>
<a name="ln912">      } // end of multipass loop</a>
<a name="ln913"> </a>
<a name="ln914">      // jump back to the first set of rgb buffers (this is a nop</a>
<a name="ln915">      // unless on the second pass)</a>
<a name="ln916">      rgb = (float(*)[TS][TS][3])buffer;</a>
<a name="ln917">      // from here on out, mainly are working within the current tile</a>
<a name="ln918">      // rather than in reference to the image, so don't offset</a>
<a name="ln919">      // mrow/mcol by top/left of tile</a>
<a name="ln920">      mrow -= top;</a>
<a name="ln921">      mcol -= left;</a>
<a name="ln922"> </a>
<a name="ln923">      /* Convert to perceptual colorspace and differentiate in all directions:  */</a>
<a name="ln924">      // Original dcraw algorithm uses CIELab as perceptual space</a>
<a name="ln925">      // (presumably coming from original AHD) and converts taking</a>
<a name="ln926">      // camera matrix into account. Now use YPbPr which requires much</a>
<a name="ln927">      // less code and is nearly indistinguishable. It assumes the</a>
<a name="ln928">      // camera RGB is roughly linear.</a>
<a name="ln929">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln930">      {</a>
<a name="ln931">        const int pad_yuv = (passes == 1) ? 8 : 13;</a>
<a name="ln932">        for(int row = pad_yuv; row &lt; mrow - pad_yuv; row++)</a>
<a name="ln933">          for(int col = pad_yuv; col &lt; mcol - pad_yuv; col++)</a>
<a name="ln934">          {</a>
<a name="ln935">            float *rx = rgb[d][row][col];</a>
<a name="ln936">            // use ITU-R BT.2020 YPbPr, which is great, but could use</a>
<a name="ln937">            // a better/simpler choice? note that imageop.h provides</a>
<a name="ln938">            // dt_iop_RGB_to_YCbCr which uses Rec. 601 conversion,</a>
<a name="ln939">            // which appears less good with specular highlights</a>
<a name="ln940">            float y = 0.2627f * rx[0] + 0.6780f * rx[1] + 0.0593f * rx[2];</a>
<a name="ln941">            yuv[0][row][col] = y;</a>
<a name="ln942">            yuv[1][row][col] = (rx[2] - y) * 0.56433f;</a>
<a name="ln943">            yuv[2][row][col] = (rx[0] - y) * 0.67815f;</a>
<a name="ln944">          }</a>
<a name="ln945">        // Note that f can offset by a column (-1 or +1) and by a row</a>
<a name="ln946">        // (-TS or TS). The row-wise offsets cause the undefined</a>
<a name="ln947">        // behavior sanitizer to warn of an out of bounds index, but</a>
<a name="ln948">        // as yfx is multi-dimensional and there is sufficient</a>
<a name="ln949">        // padding, that is not actually so.</a>
<a name="ln950">        const int f = dir[d &amp; 3];</a>
<a name="ln951">        const int pad_drv = (passes == 1) ? 9 : 14;</a>
<a name="ln952">        for(int row = pad_drv; row &lt; mrow - pad_drv; row++)</a>
<a name="ln953">          for(int col = pad_drv; col &lt; mcol - pad_drv; col++)</a>
<a name="ln954">          {</a>
<a name="ln955">            float(*yfx)[TS][TS] = (float(*)[TS][TS]) &amp; yuv[0][row][col];</a>
<a name="ln956">            drv[d][row][col] = SQR(2 * yfx[0][0][0] - yfx[0][0][f] - yfx[0][0][-f])</a>
<a name="ln957">                               + SQR(2 * yfx[1][0][0] - yfx[1][0][f] - yfx[1][0][-f])</a>
<a name="ln958">                               + SQR(2 * yfx[2][0][0] - yfx[2][0][f] - yfx[2][0][-f]);</a>
<a name="ln959">          }</a>
<a name="ln960">      }</a>
<a name="ln961"> </a>
<a name="ln962">      /* Build homogeneity maps from the derivatives:                   */</a>
<a name="ln963">      memset(homo, 0, (size_t)ndir * TS * TS * sizeof(uint8_t));</a>
<a name="ln964">      const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln965">      for(int row = pad_homo; row &lt; mrow - pad_homo; row++)</a>
<a name="ln966">        for(int col = pad_homo; col &lt; mcol - pad_homo; col++)</a>
<a name="ln967">        {</a>
<a name="ln968">          float tr = FLT_MAX;</a>
<a name="ln969">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln970">            if(tr &gt; drv[d][row][col]) tr = drv[d][row][col];</a>
<a name="ln971">          tr *= 8;</a>
<a name="ln972">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln973">            for(int v = -1; v &lt;= 1; v++)</a>
<a name="ln974">              for(int h = -1; h &lt;= 1; h++) homo[d][row][col] += ((drv[d][row + v][col + h] &lt;= tr) ? 1 : 0);</a>
<a name="ln975">        }</a>
<a name="ln976"> </a>
<a name="ln977">      /* Build 5x5 sum of homogeneity maps for each pixel &amp; direction */</a>
<a name="ln978">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln979">        for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln980">        {</a>
<a name="ln981">          // start before first column where homo[d][row][col+2] != 0,</a>
<a name="ln982">          // so can know v5sum and homosum[d][row][col] will be 0</a>
<a name="ln983">          int col = pad_tile-5;</a>
<a name="ln984">          uint8_t v5sum[5] = { 0 };</a>
<a name="ln985">          homosum[d][row][col] = 0;</a>
<a name="ln986">          // calculate by rolling through column sums</a>
<a name="ln987">          for(col++; col &lt; mcol - pad_tile; col++)</a>
<a name="ln988">          {</a>
<a name="ln989">            uint8_t colsum = 0;</a>
<a name="ln990">            for(int v = -2; v &lt;= 2; v++) colsum += homo[d][row + v][col + 2];</a>
<a name="ln991">            homosum[d][row][col] = homosum[d][row][col - 1] - v5sum[col % 5] + colsum;</a>
<a name="ln992">            v5sum[col % 5] = colsum;</a>
<a name="ln993">          }</a>
<a name="ln994">        }</a>
<a name="ln995"> </a>
<a name="ln996">      /* Average the most homogeneous pixels for the final result:       */</a>
<a name="ln997">      for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln998">        for(int col = pad_tile; col &lt; mcol - pad_tile; col++)</a>
<a name="ln999">        {</a>
<a name="ln1000">          uint8_t hm[8] = { 0 };</a>
<a name="ln1001">          uint8_t maxval = 0;</a>
<a name="ln1002">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1003">          {</a>
<a name="ln1004">            hm[d] = homosum[d][row][col];</a>
<a name="ln1005">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln1006">          }</a>
<a name="ln1007">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln1008">          for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln1009">            if(hm[d] &lt; hm[d + 4])</a>
<a name="ln1010">              hm[d] = 0;</a>
<a name="ln1011">            else if(hm[d] &gt; hm[d + 4])</a>
<a name="ln1012">              hm[d + 4] = 0;</a>
<a name="ln1013">          float avg[4] = { 0.0f };</a>
<a name="ln1014">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1015">            if(hm[d] &gt;= maxval)</a>
<a name="ln1016">            {</a>
<a name="ln1017">              for(int c = 0; c &lt; 3; c++) avg[c] += rgb[d][row][col][c];</a>
<a name="ln1018">              avg[3]++;</a>
<a name="ln1019">            }</a>
<a name="ln1020">          for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1021">            out[4 * (width * (row + top) + col + left) + c] =</a>
<a name="ln1022">              avg[c]/avg[3];</a>
<a name="ln1023">        }</a>
<a name="ln1024">    }</a>
<a name="ln1025">  }</a>
<a name="ln1026">  dt_free_align(all_buffers);</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">#undef TS</a>
<a name="ln1030"> </a>
<a name="ln1031">#define TS 122</a>
<a name="ln1032">static void xtrans_fdc_interpolate(struct dt_iop_module_t *self, float *out, const float *const in,</a>
<a name="ln1033">                                   const dt_iop_roi_t *const roi_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln1034">                                   const uint8_t (*const xtrans)[6])</a>
<a name="ln1035">{</a>
<a name="ln1036"> </a>
<a name="ln1037">  static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln1038">                     patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln1039">                                     { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } },</a>
<a name="ln1040">                     dir[4] = { 1, TS, TS + 1, TS - 1 };</a>
<a name="ln1041"> </a>
<a name="ln1042">  static const float directionality[8] = { 1.0f, 0.0f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f };</a>
<a name="ln1043"> </a>
<a name="ln1044">  short allhex[3][3][8];</a>
<a name="ln1045">  // sgrow/sgcol is the offset in the sensor matrix of the solitary</a>
<a name="ln1046">  // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln1047">  unsigned short sgrow = 0, sgcol = 0;</a>
<a name="ln1048"> </a>
<a name="ln1049">  const int width = roi_out-&gt;width;</a>
<a name="ln1050">  const int height = roi_out-&gt;height;</a>
<a name="ln1051">  static const int ndir = 4;</a>
<a name="ln1052"> </a>
<a name="ln1053">  static const float complex Minv[3][8] = {</a>
<a name="ln1054">    { 1.000000e+00f, 2.500000e-01f - 4.330127e-01f * _Complex_I, -2.500000e-01f - 4.330127e-01f * _Complex_I,</a>
<a name="ln1055">      -1.000000e+00f, 7.500000e-01f - 1.299038e+00f * _Complex_I, -2.500000e-01f + 4.330127e-01f * _Complex_I,</a>
<a name="ln1056">      7.500000e-01f + 1.299038e+00f * _Complex_I, 2.500000e-01f + 4.330127e-01f * _Complex_I },</a>
<a name="ln1057">    { 1.000000e+00f, -2.000000e-01f + 3.464102e-01f * _Complex_I, 2.000000e-01f + 3.464102e-01f * _Complex_I,</a>
<a name="ln1058">      8.000000e-01f, 0.0f, 2.000000e-01f - 3.464102e-01f * _Complex_I, 0.0f,</a>
<a name="ln1059">      -2.000000e-01f - 3.464102e-01f * _Complex_I },</a>
<a name="ln1060">    { 1.000000e+00f, 2.500000e-01f - 4.330127e-01f * _Complex_I, -2.500000e-01f - 4.330127e-01f * _Complex_I,</a>
<a name="ln1061">      -1.000000e+00f, -7.500000e-01f + 1.299038e+00f * _Complex_I, -2.500000e-01f + 4.330127e-01f * _Complex_I,</a>
<a name="ln1062">      -7.500000e-01f - 1.299038e+00f * _Complex_I, 2.500000e-01f + 4.330127e-01f * _Complex_I },</a>
<a name="ln1063">  };</a>
<a name="ln1064"> </a>
<a name="ln1065">  static const float complex modarr[6][6][8] = {</a>
<a name="ln1066">    { { 1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1067">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1068">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1069">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1070">      { -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1071">        -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1072">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1073">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1074">      { 1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1075">        1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1076">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1077">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1078">      { -1.000000e+00f - 3.673940e-16f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1079">        -1.000000e+00f - 3.673940e-16f * _Complex_I, -1.000000e+00f - 1.224647e-16f * _Complex_I,</a>
<a name="ln1080">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1081">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f + 2.449294e-16f * _Complex_I },</a>
<a name="ln1082">      { 1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1083">        1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1084">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1085">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1086">      { -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1087">        -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1088">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1089">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I } },</a>
<a name="ln1090">    { { 5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1091">        5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1092">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1093">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1094">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1095">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1096">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1097">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1098">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1099">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1100">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1101">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1102">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1103">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1104">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1105">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1106">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1107">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1108">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1109">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 2.449294e-16f * _Complex_I },</a>
<a name="ln1110">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1111">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1112">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1113">        1.000000e+00f - 2.266216e-15f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I } },</a>
<a name="ln1114">    { { -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1115">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1116">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1117">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1118">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1119">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1120">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1121">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1122">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1123">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1124">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1125">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1126">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1127">        5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 1.224647e-16f * _Complex_I,</a>
<a name="ln1128">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1129">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1130">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1131">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1132">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1133">        1.000000e+00f - 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1134">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1135">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1136">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1137">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 1.133108e-15f * _Complex_I } },</a>
<a name="ln1138">    { { -1.000000e+00f + 1.224647e-16f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1139">        -1.000000e+00f - 1.224647e-16f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1140">        1.000000e+00f + 0.000000e+00f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1141">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I },</a>
<a name="ln1142">      { 1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1143">        1.000000e+00f + 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1144">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1145">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1146">      { -1.000000e+00f - 1.224647e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1147">        -1.000000e+00f - 3.673940e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1148">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1149">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1150">      { 1.000000e+00f + 2.449294e-16f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1151">        1.000000e+00f + 4.898587e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1152">        1.000000e+00f - 2.449294e-16f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1153">        1.000000e+00f - 4.898587e-16f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1154">      { -1.000000e+00f - 3.673940e-16f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1155">        -1.000000e+00f - 6.123234e-16f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1156">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1157">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1158">      { 1.000000e+00f + 4.898587e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1159">        1.000000e+00f + 7.347881e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1160">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I,</a>
<a name="ln1161">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I } },</a>
<a name="ln1162">    { { -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1163">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1164">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1165">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1166">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1167">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1168">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1169">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 2.449294e-16f * _Complex_I },</a>
<a name="ln1170">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1171">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1172">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1173">        1.000000e+00f - 4.898587e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1174">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1175">        5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 3.673940e-16f * _Complex_I,</a>
<a name="ln1176">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1177">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1178">      { -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1179">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1180">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1181">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1182">      { 5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1183">        5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1184">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1185">        1.000000e+00f - 7.347881e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I } },</a>
<a name="ln1186">    { { 5.000000e-01f - 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1187">        5.000000e-01f + 8.660254e-01f * _Complex_I, -1.000000e+00f + 6.123234e-16f * _Complex_I,</a>
<a name="ln1188">        1.000000e+00f + 0.000000e+00f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1189">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1190">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1191">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1192">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1193">        1.000000e+00f - 2.266216e-15f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1194">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1195">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1196">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1197">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 1.133108e-15f * _Complex_I },</a>
<a name="ln1198">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f - 7.347881e-16f * _Complex_I,</a>
<a name="ln1199">        -5.000000e-01f - 8.660254e-01f * _Complex_I, 1.000000e+00f - 4.898587e-16f * _Complex_I,</a>
<a name="ln1200">        1.000000e+00f - 2.449294e-16f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1201">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I },</a>
<a name="ln1202">      { 5.000000e-01f - 8.660254e-01f * _Complex_I, 5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1203">        5.000000e-01f + 8.660254e-01f * _Complex_I, 5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1204">        -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1205">        1.000000e+00f - 7.347881e-16f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I },</a>
<a name="ln1206">      { -5.000000e-01f + 8.660254e-01f * _Complex_I, -5.000000e-01f + 8.660254e-01f * _Complex_I,</a>
<a name="ln1207">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1208">        -5.000000e-01f - 8.660254e-01f * _Complex_I, -5.000000e-01f - 8.660254e-01f * _Complex_I,</a>
<a name="ln1209">        -5.000000e-01f + 8.660254e-01f * _Complex_I, 1.000000e+00f + 0.000000e+00f * _Complex_I } },</a>
<a name="ln1210">  };</a>
<a name="ln1211"> </a>
<a name="ln1212">  static const float complex harr[4][13][13]</a>
<a name="ln1213">      = { { { 1.326343e-03f - 1.299441e-18f * _Complex_I, 7.091837e-04f - 1.228342e-03f * _Complex_I,</a>
<a name="ln1214">              -6.278557e-04f - 1.087478e-03f * _Complex_I, -1.157216e-03f + 9.920263e-19f * _Complex_I,</a>
<a name="ln1215">              -4.887166e-04f + 8.464820e-04f * _Complex_I, 5.758687e-04f + 9.974338e-04f * _Complex_I,</a>
<a name="ln1216">              1.225183e-03f - 9.002496e-19f * _Complex_I, 5.758687e-04f - 9.974338e-04f * _Complex_I,</a>
<a name="ln1217">              -4.887166e-04f - 8.464820e-04f * _Complex_I, -1.157216e-03f + 7.085902e-19f * _Complex_I,</a>
<a name="ln1218">              -6.278557e-04f + 1.087478e-03f * _Complex_I, 7.091837e-04f + 1.228342e-03f * _Complex_I,</a>
<a name="ln1219">              1.326343e-03f - 6.497206e-19f * _Complex_I },</a>
<a name="ln1220">            { -1.980815e-03f + 1.698059e-18f * _Complex_I, -1.070384e-03f + 1.853959e-03f * _Complex_I,</a>
<a name="ln1221">              7.924697e-04f + 1.372598e-03f * _Complex_I, 1.876584e-03f - 1.378892e-18f * _Complex_I,</a>
<a name="ln1222">              1.225866e-03f - 2.123262e-03f * _Complex_I, -1.569320e-03f - 2.718142e-03f * _Complex_I,</a>
<a name="ln1223">              -3.273971e-03f + 2.004729e-18f * _Complex_I, -1.569320e-03f + 2.718142e-03f * _Complex_I,</a>
<a name="ln1224">              1.225866e-03f + 2.123262e-03f * _Complex_I, 1.876584e-03f - 9.192611e-19f * _Complex_I,</a>
<a name="ln1225">              7.924697e-04f - 1.372598e-03f * _Complex_I, -1.070384e-03f - 1.853959e-03f * _Complex_I,</a>
<a name="ln1226">              -1.980815e-03f + 7.277398e-19f * _Complex_I },</a>
<a name="ln1227">            { 1.457023e-03f - 1.070603e-18f * _Complex_I, 8.487143e-04f - 1.470016e-03f * _Complex_I,</a>
<a name="ln1228">              -6.873776e-04f - 1.190573e-03f * _Complex_I, -2.668335e-03f + 1.633884e-18f * _Complex_I,</a>
<a name="ln1229">              -2.459813e-03f + 4.260521e-03f * _Complex_I, 3.238772e-03f + 5.609717e-03f * _Complex_I,</a>
<a name="ln1230">              7.074895e-03f - 3.465699e-18f * _Complex_I, 3.238772e-03f - 5.609717e-03f * _Complex_I,</a>
<a name="ln1231">              -2.459813e-03f - 4.260521e-03f * _Complex_I, -2.668335e-03f + 9.803302e-19f * _Complex_I,</a>
<a name="ln1232">              -6.873776e-04f + 1.190573e-03f * _Complex_I, 8.487143e-04f + 1.470016e-03f * _Complex_I,</a>
<a name="ln1233">              1.457023e-03f - 3.568678e-19f * _Complex_I },</a>
<a name="ln1234">            { -1.017660e-03f + 6.231370e-19f * _Complex_I, -5.415171e-04f + 9.379351e-04f * _Complex_I,</a>
<a name="ln1235">              7.255109e-04f + 1.256622e-03f * _Complex_I, 3.699792e-03f - 1.812375e-18f * _Complex_I,</a>
<a name="ln1236">              4.090356e-03f - 7.084704e-03f * _Complex_I, -6.006283e-03f - 1.040319e-02f * _Complex_I,</a>
<a name="ln1237">              -1.391431e-02f + 5.112034e-18f * _Complex_I, -6.006283e-03f + 1.040319e-02f * _Complex_I,</a>
<a name="ln1238">              4.090356e-03f + 7.084704e-03f * _Complex_I, 3.699792e-03f - 9.061876e-19f * _Complex_I,</a>
<a name="ln1239">              7.255109e-04f - 1.256622e-03f * _Complex_I, -5.415171e-04f - 9.379351e-04f * _Complex_I,</a>
<a name="ln1240">              -1.017660e-03f + 1.246274e-19f * _Complex_I },</a>
<a name="ln1241">            { 9.198983e-04f - 4.506202e-19f * _Complex_I, 6.815900e-04f - 1.180548e-03f * _Complex_I,</a>
<a name="ln1242">              -1.287335e-03f - 2.229729e-03f * _Complex_I, -5.023856e-03f + 1.845735e-18f * _Complex_I,</a>
<a name="ln1243">              -5.499048e-03f + 9.524630e-03f * _Complex_I, 9.797672e-03f + 1.697006e-02f * _Complex_I,</a>
<a name="ln1244">              2.504795e-02f - 6.134977e-18f * _Complex_I, 9.797672e-03f - 1.697006e-02f * _Complex_I,</a>
<a name="ln1245">              -5.499048e-03f - 9.524630e-03f * _Complex_I, -5.023856e-03f + 6.152449e-19f * _Complex_I,</a>
<a name="ln1246">              -1.287335e-03f + 2.229729e-03f * _Complex_I, 6.815900e-04f + 1.180548e-03f * _Complex_I,</a>
<a name="ln1247">              9.198983e-04f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1248">            { -7.972663e-04f + 2.929109e-19f * _Complex_I, -1.145605e-03f + 1.984247e-03f * _Complex_I,</a>
<a name="ln1249">              1.983334e-03f + 3.435235e-03f * _Complex_I, 6.730096e-03f - 1.648398e-18f * _Complex_I,</a>
<a name="ln1250">              6.782033e-03f - 1.174683e-02f * _Complex_I, -1.392077e-02f - 2.411147e-02f * _Complex_I,</a>
<a name="ln1251">              -3.906939e-02f + 4.784620e-18f * _Complex_I, -1.392077e-02f + 2.411147e-02f * _Complex_I,</a>
<a name="ln1252">              6.782033e-03f + 1.174683e-02f * _Complex_I, 6.730096e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1253">              1.983334e-03f - 3.435235e-03f * _Complex_I, -1.145605e-03f - 1.984247e-03f * _Complex_I,</a>
<a name="ln1254">              -7.972663e-04f - 9.763696e-20f * _Complex_I },</a>
<a name="ln1255">            { 8.625458e-04f - 2.112628e-19f * _Complex_I, 1.431113e-03f - 2.478760e-03f * _Complex_I,</a>
<a name="ln1256">              -2.310309e-03f - 4.001572e-03f * _Complex_I, -7.706486e-03f + 9.437723e-19f * _Complex_I,</a>
<a name="ln1257">              -7.220186e-03f + 1.250573e-02f * _Complex_I, 1.587118e-02f + 2.748969e-02f * _Complex_I,</a>
<a name="ln1258">              4.765675e-02f + 0.000000e+00f * _Complex_I, 1.587118e-02f - 2.748969e-02f * _Complex_I,</a>
<a name="ln1259">              -7.220186e-03f - 1.250573e-02f * _Complex_I, -7.706486e-03f - 9.437723e-19f * _Complex_I,</a>
<a name="ln1260">              -2.310309e-03f + 4.001572e-03f * _Complex_I, 1.431113e-03f + 2.478760e-03f * _Complex_I,</a>
<a name="ln1261">              8.625458e-04f + 2.112628e-19f * _Complex_I },</a>
<a name="ln1262">            { -7.972663e-04f + 9.763696e-20f * _Complex_I, -1.145605e-03f + 1.984247e-03f * _Complex_I,</a>
<a name="ln1263">              1.983334e-03f + 3.435235e-03f * _Complex_I, 6.730096e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1264">              6.782033e-03f - 1.174683e-02f * _Complex_I, -1.392077e-02f - 2.411147e-02f * _Complex_I,</a>
<a name="ln1265">              -3.906939e-02f - 4.784620e-18f * _Complex_I, -1.392077e-02f + 2.411147e-02f * _Complex_I,</a>
<a name="ln1266">              6.782033e-03f + 1.174683e-02f * _Complex_I, 6.730096e-03f + 1.648398e-18f * _Complex_I,</a>
<a name="ln1267">              1.983334e-03f - 3.435235e-03f * _Complex_I, -1.145605e-03f - 1.984247e-03f * _Complex_I,</a>
<a name="ln1268">              -7.972663e-04f - 2.929109e-19f * _Complex_I },</a>
<a name="ln1269">            { 9.198983e-04f + 0.000000e+00f * _Complex_I, 6.815900e-04f - 1.180548e-03f * _Complex_I,</a>
<a name="ln1270">              -1.287335e-03f - 2.229729e-03f * _Complex_I, -5.023856e-03f - 6.152449e-19f * _Complex_I,</a>
<a name="ln1271">              -5.499048e-03f + 9.524630e-03f * _Complex_I, 9.797672e-03f + 1.697006e-02f * _Complex_I,</a>
<a name="ln1272">              2.504795e-02f + 6.134977e-18f * _Complex_I, 9.797672e-03f - 1.697006e-02f * _Complex_I,</a>
<a name="ln1273">              -5.499048e-03f - 9.524630e-03f * _Complex_I, -5.023856e-03f - 1.845735e-18f * _Complex_I,</a>
<a name="ln1274">              -1.287335e-03f + 2.229729e-03f * _Complex_I, 6.815900e-04f + 1.180548e-03f * _Complex_I,</a>
<a name="ln1275">              9.198983e-04f + 4.506202e-19f * _Complex_I },</a>
<a name="ln1276">            { -1.017660e-03f - 1.246274e-19f * _Complex_I, -5.415171e-04f + 9.379351e-04f * _Complex_I,</a>
<a name="ln1277">              7.255109e-04f + 1.256622e-03f * _Complex_I, 3.699792e-03f + 9.061876e-19f * _Complex_I,</a>
<a name="ln1278">              4.090356e-03f - 7.084704e-03f * _Complex_I, -6.006283e-03f - 1.040319e-02f * _Complex_I,</a>
<a name="ln1279">              -1.391431e-02f - 5.112034e-18f * _Complex_I, -6.006283e-03f + 1.040319e-02f * _Complex_I,</a>
<a name="ln1280">              4.090356e-03f + 7.084704e-03f * _Complex_I, 3.699792e-03f + 1.812375e-18f * _Complex_I,</a>
<a name="ln1281">              7.255109e-04f - 1.256622e-03f * _Complex_I, -5.415171e-04f - 9.379351e-04f * _Complex_I,</a>
<a name="ln1282">              -1.017660e-03f - 6.231370e-19f * _Complex_I },</a>
<a name="ln1283">            { 1.457023e-03f + 3.568678e-19f * _Complex_I, 8.487143e-04f - 1.470016e-03f * _Complex_I,</a>
<a name="ln1284">              -6.873776e-04f - 1.190573e-03f * _Complex_I, -2.668335e-03f - 9.803302e-19f * _Complex_I,</a>
<a name="ln1285">              -2.459813e-03f + 4.260521e-03f * _Complex_I, 3.238772e-03f + 5.609717e-03f * _Complex_I,</a>
<a name="ln1286">              7.074895e-03f + 3.465699e-18f * _Complex_I, 3.238772e-03f - 5.609717e-03f * _Complex_I,</a>
<a name="ln1287">              -2.459813e-03f - 4.260521e-03f * _Complex_I, -2.668335e-03f - 1.633884e-18f * _Complex_I,</a>
<a name="ln1288">              -6.873776e-04f + 1.190573e-03f * _Complex_I, 8.487143e-04f + 1.470016e-03f * _Complex_I,</a>
<a name="ln1289">              1.457023e-03f + 1.070603e-18f * _Complex_I },</a>
<a name="ln1290">            { -1.980815e-03f - 7.277398e-19f * _Complex_I, -1.070384e-03f + 1.853959e-03f * _Complex_I,</a>
<a name="ln1291">              7.924697e-04f + 1.372598e-03f * _Complex_I, 1.876584e-03f + 9.192611e-19f * _Complex_I,</a>
<a name="ln1292">              1.225866e-03f - 2.123262e-03f * _Complex_I, -1.569320e-03f - 2.718142e-03f * _Complex_I,</a>
<a name="ln1293">              -3.273971e-03f - 2.004729e-18f * _Complex_I, -1.569320e-03f + 2.718142e-03f * _Complex_I,</a>
<a name="ln1294">              1.225866e-03f + 2.123262e-03f * _Complex_I, 1.876584e-03f + 1.378892e-18f * _Complex_I,</a>
<a name="ln1295">              7.924697e-04f - 1.372598e-03f * _Complex_I, -1.070384e-03f - 1.853959e-03f * _Complex_I,</a>
<a name="ln1296">              -1.980815e-03f - 1.698059e-18f * _Complex_I },</a>
<a name="ln1297">            { 1.326343e-03f + 6.497206e-19f * _Complex_I, 7.091837e-04f - 1.228342e-03f * _Complex_I,</a>
<a name="ln1298">              -6.278557e-04f - 1.087478e-03f * _Complex_I, -1.157216e-03f - 7.085902e-19f * _Complex_I,</a>
<a name="ln1299">              -4.887166e-04f + 8.464820e-04f * _Complex_I, 5.758687e-04f + 9.974338e-04f * _Complex_I,</a>
<a name="ln1300">              1.225183e-03f + 9.002496e-19f * _Complex_I, 5.758687e-04f - 9.974338e-04f * _Complex_I,</a>
<a name="ln1301">              -4.887166e-04f - 8.464820e-04f * _Complex_I, -1.157216e-03f - 9.920263e-19f * _Complex_I,</a>
<a name="ln1302">              -6.278557e-04f + 1.087478e-03f * _Complex_I, 7.091837e-04f + 1.228342e-03f * _Complex_I,</a>
<a name="ln1303">              1.326343e-03f + 1.299441e-18f * _Complex_I } },</a>
<a name="ln1304">          { { 9.129120e-04f - 8.943958e-19f * _Complex_I, -5.925973e-04f - 1.026409e-03f * _Complex_I,</a>
<a name="ln1305">              -5.989682e-04f + 1.037443e-03f * _Complex_I, 1.158755e-03f - 8.514393e-19f * _Complex_I,</a>
<a name="ln1306">              -8.992493e-04f - 1.557545e-03f * _Complex_I, -1.283187e-03f + 2.222546e-03f * _Complex_I,</a>
<a name="ln1307">              2.730635e-03f - 1.337625e-18f * _Complex_I, -1.283187e-03f - 2.222546e-03f * _Complex_I,</a>
<a name="ln1308">              -8.992493e-04f + 1.557545e-03f * _Complex_I, 1.158755e-03f - 2.838131e-19f * _Complex_I,</a>
<a name="ln1309">              -5.989682e-04f - 1.037443e-03f * _Complex_I, -5.925973e-04f + 1.026409e-03f * _Complex_I,</a>
<a name="ln1310">              9.129120e-04f + 0.000000e+00f * _Complex_I },</a>
<a name="ln1311">            { -5.588854e-04f - 9.680179e-04f * _Complex_I, -6.474856e-04f + 1.121478e-03f * _Complex_I,</a>
<a name="ln1312">              1.536588e-03f - 1.129066e-18f * _Complex_I, -9.123802e-04f - 1.580289e-03f * _Complex_I,</a>
<a name="ln1313">              -1.541434e-03f + 2.669842e-03f * _Complex_I, 4.379825e-03f - 9.925627e-18f * _Complex_I,</a>
<a name="ln1314">              -2.394173e-03f - 4.146830e-03f * _Complex_I, -2.189912e-03f + 3.793039e-03f * _Complex_I,</a>
<a name="ln1315">              3.082869e-03f - 3.493222e-18f * _Complex_I, -9.123802e-04f - 1.580289e-03f * _Complex_I,</a>
<a name="ln1316">              -7.682939e-04f + 1.330724e-03f * _Complex_I, 1.294971e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1317">              -5.588854e-04f - 9.680179e-04f * _Complex_I },</a>
<a name="ln1318">            { -5.883876e-04f + 1.019117e-03f * _Complex_I, 1.714796e-03f - 1.260012e-18f * _Complex_I,</a>
<a name="ln1319">              -1.180365e-03f - 2.044451e-03f * _Complex_I, -1.483082e-03f + 2.568774e-03f * _Complex_I,</a>
<a name="ln1320">              4.933362e-03f - 2.416651e-18f * _Complex_I, -3.296542e-03f - 5.709779e-03f * _Complex_I,</a>
<a name="ln1321">              -3.546477e-03f + 6.142678e-03f * _Complex_I, 6.593085e-03f - 1.614840e-18f * _Complex_I,</a>
<a name="ln1322">              -2.466681e-03f - 4.272417e-03f * _Complex_I, -1.483082e-03f + 2.568774e-03f * _Complex_I,</a>
<a name="ln1323">              2.360729e-03f + 0.000000e+00f * _Complex_I, -8.573982e-04f - 1.485057e-03f * _Complex_I,</a>
<a name="ln1324">              -5.883876e-04f + 1.019117e-03f * _Complex_I },</a>
<a name="ln1325">            { 1.483526e-03f - 1.090077e-18f * _Complex_I, -1.074793e-03f - 1.861596e-03f * _Complex_I,</a>
<a name="ln1326">              -1.447448e-03f + 2.507053e-03f * _Complex_I, 3.952416e-03f - 1.936126e-18f * _Complex_I,</a>
<a name="ln1327">              -3.496688e-03f - 6.056441e-03f * _Complex_I, -4.898024e-03f + 8.483627e-03f * _Complex_I,</a>
<a name="ln1328">              1.070518e-02f - 2.622012e-18f * _Complex_I, -4.898024e-03f - 8.483627e-03f * _Complex_I,</a>
<a name="ln1329">              -3.496688e-03f + 6.056441e-03f * _Complex_I, 3.952416e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1330">              -1.447448e-03f - 2.507053e-03f * _Complex_I, -1.074793e-03f + 1.861596e-03f * _Complex_I,</a>
<a name="ln1331">              1.483526e-03f + 3.633590e-19f * _Complex_I },</a>
<a name="ln1332">            { -9.966429e-04f - 1.726236e-03f * _Complex_I, -1.478281e-03f + 2.560458e-03f * _Complex_I,</a>
<a name="ln1333">              4.306274e-03f - 2.109466e-18f * _Complex_I, -3.294955e-03f - 5.707029e-03f * _Complex_I,</a>
<a name="ln1334">              -5.436890e-03f + 9.416970e-03f * _Complex_I, 1.556418e-02f - 3.812124e-18f * _Complex_I,</a>
<a name="ln1335">              -8.842875e-03f - 1.531631e-02f * _Complex_I, -7.782088e-03f + 1.347897e-02f * _Complex_I,</a>
<a name="ln1336">              1.087378e-02f + 0.000000e+00f * _Complex_I, -3.294955e-03f - 5.707029e-03f * _Complex_I,</a>
<a name="ln1337">              -2.153137e-03f + 3.729342e-03f * _Complex_I, 2.956562e-03f + 3.350104e-18f * _Complex_I,</a>
<a name="ln1338">              -9.966429e-04f - 1.726236e-03f * _Complex_I },</a>
<a name="ln1339">            { -1.291288e-03f + 2.236576e-03f * _Complex_I, 3.942788e-03f - 8.935208e-18f * _Complex_I,</a>
<a name="ln1340">              -2.798347e-03f - 4.846880e-03f * _Complex_I, -4.448869e-03f + 7.705666e-03f * _Complex_I,</a>
<a name="ln1341">              1.522441e-02f - 3.728906e-18f * _Complex_I, -1.175443e-02f - 2.035927e-02f * _Complex_I,</a>
<a name="ln1342">              -1.417872e-02f + 2.455826e-02f * _Complex_I, 2.350886e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1343">              -7.612206e-03f - 1.318473e-02f * _Complex_I, -4.448869e-03f + 7.705666e-03f * _Complex_I,</a>
<a name="ln1344">              5.596695e-03f + 1.370795e-18f * _Complex_I, -1.971394e-03f - 3.414555e-03f * _Complex_I,</a>
<a name="ln1345">              -1.291288e-03f + 2.236576e-03f * _Complex_I },</a>
<a name="ln1346">            { 2.779286e-03f - 1.361458e-18f * _Complex_I, -2.194126e-03f - 3.800338e-03f * _Complex_I,</a>
<a name="ln1347">              -3.057720e-03f + 5.296126e-03f * _Complex_I, 9.725261e-03f - 2.382002e-18f * _Complex_I,</a>
<a name="ln1348">              -8.649261e-03f - 1.498096e-02f * _Complex_I, -1.417667e-02f + 2.455472e-02f * _Complex_I,</a>
<a name="ln1349">              3.552610e-02f + 0.000000e+00f * _Complex_I, -1.417667e-02f - 2.455472e-02f * _Complex_I,</a>
<a name="ln1350">              -8.649261e-03f + 1.498096e-02f * _Complex_I, 9.725261e-03f + 2.382002e-18f * _Complex_I,</a>
<a name="ln1351">              -3.057720e-03f - 5.296126e-03f * _Complex_I, -2.194126e-03f + 3.800338e-03f * _Complex_I,</a>
<a name="ln1352">              2.779286e-03f + 1.361458e-18f * _Complex_I },</a>
<a name="ln1353">            { -1.291288e-03f - 2.236576e-03f * _Complex_I, -1.971394e-03f + 3.414555e-03f * _Complex_I,</a>
<a name="ln1354">              5.596695e-03f - 1.370795e-18f * _Complex_I, -4.448869e-03f - 7.705666e-03f * _Complex_I,</a>
<a name="ln1355">              -7.612206e-03f + 1.318473e-02f * _Complex_I, 2.350886e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1356">              -1.417872e-02f - 2.455826e-02f * _Complex_I, -1.175443e-02f + 2.035927e-02f * _Complex_I,</a>
<a name="ln1357">              1.522441e-02f + 3.728906e-18f * _Complex_I, -4.448869e-03f - 7.705666e-03f * _Complex_I,</a>
<a name="ln1358">              -2.798347e-03f + 4.846880e-03f * _Complex_I, 3.942788e-03f + 8.935208e-18f * _Complex_I,</a>
<a name="ln1359">              -1.291288e-03f - 2.236576e-03f * _Complex_I },</a>
<a name="ln1360">            { -9.966429e-04f + 1.726236e-03f * _Complex_I, 2.956562e-03f - 3.350104e-18f * _Complex_I,</a>
<a name="ln1361">              -2.153137e-03f - 3.729342e-03f * _Complex_I, -3.294955e-03f + 5.707029e-03f * _Complex_I,</a>
<a name="ln1362">              1.087378e-02f + 0.000000e+00f * _Complex_I, -7.782088e-03f - 1.347897e-02f * _Complex_I,</a>
<a name="ln1363">              -8.842875e-03f + 1.531631e-02f * _Complex_I, 1.556418e-02f + 3.812124e-18f * _Complex_I,</a>
<a name="ln1364">              -5.436890e-03f - 9.416970e-03f * _Complex_I, -3.294955e-03f + 5.707029e-03f * _Complex_I,</a>
<a name="ln1365">              4.306274e-03f + 2.109466e-18f * _Complex_I, -1.478281e-03f - 2.560458e-03f * _Complex_I,</a>
<a name="ln1366">              -9.966429e-04f + 1.726236e-03f * _Complex_I },</a>
<a name="ln1367">            { 1.483526e-03f - 3.633590e-19f * _Complex_I, -1.074793e-03f - 1.861596e-03f * _Complex_I,</a>
<a name="ln1368">              -1.447448e-03f + 2.507053e-03f * _Complex_I, 3.952416e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1369">              -3.496688e-03f - 6.056441e-03f * _Complex_I, -4.898024e-03f + 8.483627e-03f * _Complex_I,</a>
<a name="ln1370">              1.070518e-02f + 2.622012e-18f * _Complex_I, -4.898024e-03f - 8.483627e-03f * _Complex_I,</a>
<a name="ln1371">              -3.496688e-03f + 6.056441e-03f * _Complex_I, 3.952416e-03f + 1.936126e-18f * _Complex_I,</a>
<a name="ln1372">              -1.447448e-03f - 2.507053e-03f * _Complex_I, -1.074793e-03f + 1.861596e-03f * _Complex_I,</a>
<a name="ln1373">              1.483526e-03f + 1.090077e-18f * _Complex_I },</a>
<a name="ln1374">            { -5.883876e-04f - 1.019117e-03f * _Complex_I, -8.573982e-04f + 1.485057e-03f * _Complex_I,</a>
<a name="ln1375">              2.360729e-03f + 0.000000e+00f * _Complex_I, -1.483082e-03f - 2.568774e-03f * _Complex_I,</a>
<a name="ln1376">              -2.466681e-03f + 4.272417e-03f * _Complex_I, 6.593085e-03f + 1.614840e-18f * _Complex_I,</a>
<a name="ln1377">              -3.546477e-03f - 6.142678e-03f * _Complex_I, -3.296542e-03f + 5.709779e-03f * _Complex_I,</a>
<a name="ln1378">              4.933362e-03f + 2.416651e-18f * _Complex_I, -1.483082e-03f - 2.568774e-03f * _Complex_I,</a>
<a name="ln1379">              -1.180365e-03f + 2.044451e-03f * _Complex_I, 1.714796e-03f + 1.260012e-18f * _Complex_I,</a>
<a name="ln1380">              -5.883876e-04f - 1.019117e-03f * _Complex_I },</a>
<a name="ln1381">            { -5.588854e-04f + 9.680179e-04f * _Complex_I, 1.294971e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1382">              -7.682939e-04f - 1.330724e-03f * _Complex_I, -9.123802e-04f + 1.580289e-03f * _Complex_I,</a>
<a name="ln1383">              3.082869e-03f + 3.493222e-18f * _Complex_I, -2.189912e-03f - 3.793039e-03f * _Complex_I,</a>
<a name="ln1384">              -2.394173e-03f + 4.146830e-03f * _Complex_I, 4.379825e-03f + 9.925627e-18f * _Complex_I,</a>
<a name="ln1385">              -1.541434e-03f - 2.669842e-03f * _Complex_I, -9.123802e-04f + 1.580289e-03f * _Complex_I,</a>
<a name="ln1386">              1.536588e-03f + 1.129066e-18f * _Complex_I, -6.474856e-04f - 1.121478e-03f * _Complex_I,</a>
<a name="ln1387">              -5.588854e-04f + 9.680179e-04f * _Complex_I },</a>
<a name="ln1388">            { 9.129120e-04f + 0.000000e+00f * _Complex_I, -5.925973e-04f - 1.026409e-03f * _Complex_I,</a>
<a name="ln1389">              -5.989682e-04f + 1.037443e-03f * _Complex_I, 1.158755e-03f + 2.838131e-19f * _Complex_I,</a>
<a name="ln1390">              -8.992493e-04f - 1.557545e-03f * _Complex_I, -1.283187e-03f + 2.222546e-03f * _Complex_I,</a>
<a name="ln1391">              2.730635e-03f + 1.337625e-18f * _Complex_I, -1.283187e-03f - 2.222546e-03f * _Complex_I,</a>
<a name="ln1392">              -8.992493e-04f + 1.557545e-03f * _Complex_I, 1.158755e-03f + 8.514393e-19f * _Complex_I,</a>
<a name="ln1393">              -5.989682e-04f - 1.037443e-03f * _Complex_I, -5.925973e-04f + 1.026409e-03f * _Complex_I,</a>
<a name="ln1394">              9.129120e-04f + 8.943958e-19f * _Complex_I } },</a>
<a name="ln1395">          { { 8.228091e-04f + 0.000000e+00f * _Complex_I, -5.365069e-04f + 9.292572e-04f * _Complex_I,</a>
<a name="ln1396">              -6.011501e-04f - 1.041223e-03f * _Complex_I, 1.249890e-03f - 3.061346e-19f * _Complex_I,</a>
<a name="ln1397">              -7.632708e-04f + 1.322024e-03f * _Complex_I, -9.846035e-04f - 1.705383e-03f * _Complex_I,</a>
<a name="ln1398">              2.080486e-03f - 1.019144e-18f * _Complex_I, -9.846035e-04f + 1.705383e-03f * _Complex_I,</a>
<a name="ln1399">              -7.632708e-04f - 1.322024e-03f * _Complex_I, 1.249890e-03f - 9.184039e-19f * _Complex_I,</a>
<a name="ln1400">              -6.011501e-04f + 1.041223e-03f * _Complex_I, -5.365069e-04f - 9.292572e-04f * _Complex_I,</a>
<a name="ln1401">              8.228091e-04f - 8.061204e-19f * _Complex_I },</a>
<a name="ln1402">            { -5.616336e-04f - 9.727779e-04f * _Complex_I, 1.382894e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1403">              -8.694311e-04f + 1.505899e-03f * _Complex_I, -9.721139e-04f - 1.683751e-03f * _Complex_I,</a>
<a name="ln1404">              2.446785e-03f - 2.772471e-18f * _Complex_I, -1.605471e-03f + 2.780758e-03f * _Complex_I,</a>
<a name="ln1405">              -1.832781e-03f - 3.174469e-03f * _Complex_I, 3.210942e-03f - 7.276687e-18f * _Complex_I,</a>
<a name="ln1406">              -1.223392e-03f + 2.118978e-03f * _Complex_I, -9.721139e-04f - 1.683751e-03f * _Complex_I,</a>
<a name="ln1407">              1.738862e-03f - 1.277695e-18f * _Complex_I, -6.914471e-04f + 1.197621e-03f * _Complex_I,</a>
<a name="ln1408">              -5.616336e-04f - 9.727779e-04f * _Complex_I },</a>
<a name="ln1409">            { -5.723872e-04f + 9.914038e-04f * _Complex_I, -8.302721e-04f - 1.438073e-03f * _Complex_I,</a>
<a name="ln1410">              2.445280e-03f + 0.000000e+00f * _Complex_I, -1.378399e-03f + 2.387458e-03f * _Complex_I,</a>
<a name="ln1411">              -1.882898e-03f - 3.261274e-03f * _Complex_I, 4.921549e-03f - 1.205432e-18f * _Complex_I,</a>
<a name="ln1412">              -2.760152e-03f + 4.780723e-03f * _Complex_I, -2.460774e-03f - 4.262186e-03f * _Complex_I,</a>
<a name="ln1413">              3.765795e-03f - 1.844708e-18f * _Complex_I, -1.378399e-03f + 2.387458e-03f * _Complex_I,</a>
<a name="ln1414">              -1.222640e-03f - 2.117675e-03f * _Complex_I, 1.660544e-03f - 1.220148e-18f * _Complex_I,</a>
<a name="ln1415">              -5.723872e-04f + 9.914038e-04f * _Complex_I },</a>
<a name="ln1416">            { 1.226482e-03f + 3.004015e-19f * _Complex_I, -9.600816e-04f + 1.662910e-03f * _Complex_I,</a>
<a name="ln1417">              -1.495900e-03f - 2.590974e-03f * _Complex_I, 3.833507e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1418">              -3.167257e-03f + 5.485850e-03f * _Complex_I, -4.303595e-03f - 7.454046e-03f * _Complex_I,</a>
<a name="ln1419">              9.412791e-03f - 2.305469e-18f * _Complex_I, -4.303595e-03f + 7.454046e-03f * _Complex_I,</a>
<a name="ln1420">              -3.167257e-03f - 5.485850e-03f * _Complex_I, 3.833507e-03f - 1.877877e-18f * _Complex_I,</a>
<a name="ln1421">              -1.495900e-03f + 2.590974e-03f * _Complex_I, -9.600816e-04f - 1.662910e-03f * _Complex_I,</a>
<a name="ln1422">              1.226482e-03f - 9.012046e-19f * _Complex_I },</a>
<a name="ln1423">            { -9.898007e-04f - 1.714385e-03f * _Complex_I, 3.215120e-03f + 3.643077e-18f * _Complex_I,</a>
<a name="ln1424">              -2.507621e-03f + 4.343327e-03f * _Complex_I, -3.557798e-03f - 6.162286e-03f * _Complex_I,</a>
<a name="ln1425">              1.105198e-02f + 0.000000e+00f * _Complex_I, -7.691179e-03f + 1.332151e-02f * _Complex_I,</a>
<a name="ln1426">              -8.705793e-03f - 1.507888e-02f * _Complex_I, 1.538236e-02f - 3.767591e-18f * _Complex_I,</a>
<a name="ln1427">              -5.525988e-03f + 9.571292e-03f * _Complex_I, -3.557798e-03f - 6.162286e-03f * _Complex_I,</a>
<a name="ln1428">              5.015242e-03f - 2.456760e-18f * _Complex_I, -1.607560e-03f + 2.784375e-03f * _Complex_I,</a>
<a name="ln1429">              -9.898007e-04f - 1.714385e-03f * _Complex_I },</a>
<a name="ln1430">            { -1.414655e-03f + 2.450254e-03f * _Complex_I, -2.341263e-03f - 4.055186e-03f * _Complex_I,</a>
<a name="ln1431">              6.915775e-03f + 1.693876e-18f * _Complex_I, -5.086403e-03f + 8.809908e-03f * _Complex_I,</a>
<a name="ln1432">              -8.062191e-03f - 1.396412e-02f * _Complex_I, 2.415333e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1433">              -1.451128e-02f + 2.513428e-02f * _Complex_I, -1.207667e-02f - 2.091740e-02f * _Complex_I,</a>
<a name="ln1434">              1.612438e-02f - 3.949335e-18f * _Complex_I, -5.086403e-03f + 8.809908e-03f * _Complex_I,</a>
<a name="ln1435">              -3.457887e-03f - 5.989237e-03f * _Complex_I, 4.682526e-03f - 1.061161e-17f * _Complex_I,</a>
<a name="ln1436">              -1.414655e-03f + 2.450254e-03f * _Complex_I },</a>
<a name="ln1437">            { 3.039574e-03f + 1.488962e-18f * _Complex_I, -2.598226e-03f + 4.500260e-03f * _Complex_I,</a>
<a name="ln1438">              -3.750909e-03f - 6.496765e-03f * _Complex_I, 1.119776e-02f + 2.742661e-18f * _Complex_I,</a>
<a name="ln1439">              -9.210579e-03f + 1.595319e-02f * _Complex_I, -1.464762e-02f - 2.537042e-02f * _Complex_I,</a>
<a name="ln1440">              3.672076e-02f + 0.000000e+00f * _Complex_I, -1.464762e-02f + 2.537042e-02f * _Complex_I,</a>
<a name="ln1441">              -9.210579e-03f - 1.595319e-02f * _Complex_I, 1.119776e-02f - 2.742661e-18f * _Complex_I,</a>
<a name="ln1442">              -3.750909e-03f + 6.496765e-03f * _Complex_I, -2.598226e-03f - 4.500260e-03f * _Complex_I,</a>
<a name="ln1443">              3.039574e-03f - 1.488962e-18f * _Complex_I },</a>
<a name="ln1444">            { -1.414655e-03f - 2.450254e-03f * _Complex_I, 4.682526e-03f + 1.061161e-17f * _Complex_I,</a>
<a name="ln1445">              -3.457887e-03f + 5.989237e-03f * _Complex_I, -5.086403e-03f - 8.809908e-03f * _Complex_I,</a>
<a name="ln1446">              1.612438e-02f + 3.949335e-18f * _Complex_I, -1.207667e-02f + 2.091740e-02f * _Complex_I,</a>
<a name="ln1447">              -1.451128e-02f - 2.513428e-02f * _Complex_I, 2.415333e-02f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1448">              -8.062191e-03f + 1.396412e-02f * _Complex_I, -5.086403e-03f - 8.809908e-03f * _Complex_I,</a>
<a name="ln1449">              6.915775e-03f - 1.693876e-18f * _Complex_I, -2.341263e-03f + 4.055186e-03f * _Complex_I,</a>
<a name="ln1450">              -1.414655e-03f - 2.450254e-03f * _Complex_I },</a>
<a name="ln1451">            { -9.898007e-04f + 1.714385e-03f * _Complex_I, -1.607560e-03f - 2.784375e-03f * _Complex_I,</a>
<a name="ln1452">              5.015242e-03f + 2.456760e-18f * _Complex_I, -3.557798e-03f + 6.162286e-03f * _Complex_I,</a>
<a name="ln1453">              -5.525988e-03f - 9.571292e-03f * _Complex_I, 1.538236e-02f + 3.767591e-18f * _Complex_I,</a>
<a name="ln1454">              -8.705793e-03f + 1.507888e-02f * _Complex_I, -7.691179e-03f - 1.332151e-02f * _Complex_I,</a>
<a name="ln1455">              1.105198e-02f + 0.000000e+00f * _Complex_I, -3.557798e-03f + 6.162286e-03f * _Complex_I,</a>
<a name="ln1456">              -2.507621e-03f - 4.343327e-03f * _Complex_I, 3.215120e-03f - 3.643077e-18f * _Complex_I,</a>
<a name="ln1457">              -9.898007e-04f + 1.714385e-03f * _Complex_I },</a>
<a name="ln1458">            { 1.226482e-03f + 9.012046e-19f * _Complex_I, -9.600816e-04f + 1.662910e-03f * _Complex_I,</a>
<a name="ln1459">              -1.495900e-03f - 2.590974e-03f * _Complex_I, 3.833507e-03f + 1.877877e-18f * _Complex_I,</a>
<a name="ln1460">              -3.167257e-03f + 5.485850e-03f * _Complex_I, -4.303595e-03f - 7.454046e-03f * _Complex_I,</a>
<a name="ln1461">              9.412791e-03f + 2.305469e-18f * _Complex_I, -4.303595e-03f + 7.454046e-03f * _Complex_I,</a>
<a name="ln1462">              -3.167257e-03f - 5.485850e-03f * _Complex_I, 3.833507e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1463">              -1.495900e-03f + 2.590974e-03f * _Complex_I, -9.600816e-04f - 1.662910e-03f * _Complex_I,</a>
<a name="ln1464">              1.226482e-03f - 3.004015e-19f * _Complex_I },</a>
<a name="ln1465">            { -5.723872e-04f - 9.914038e-04f * _Complex_I, 1.660544e-03f + 1.220148e-18f * _Complex_I,</a>
<a name="ln1466">              -1.222640e-03f + 2.117675e-03f * _Complex_I, -1.378399e-03f - 2.387458e-03f * _Complex_I,</a>
<a name="ln1467">              3.765795e-03f + 1.844708e-18f * _Complex_I, -2.460774e-03f + 4.262186e-03f * _Complex_I,</a>
<a name="ln1468">              -2.760152e-03f - 4.780723e-03f * _Complex_I, 4.921549e-03f + 1.205432e-18f * _Complex_I,</a>
<a name="ln1469">              -1.882898e-03f + 3.261274e-03f * _Complex_I, -1.378399e-03f - 2.387458e-03f * _Complex_I,</a>
<a name="ln1470">              2.445280e-03f + 0.000000e+00f * _Complex_I, -8.302721e-04f + 1.438073e-03f * _Complex_I,</a>
<a name="ln1471">              -5.723872e-04f - 9.914038e-04f * _Complex_I },</a>
<a name="ln1472">            { -5.616336e-04f + 9.727779e-04f * _Complex_I, -6.914471e-04f - 1.197621e-03f * _Complex_I,</a>
<a name="ln1473">              1.738862e-03f + 1.277695e-18f * _Complex_I, -9.721139e-04f + 1.683751e-03f * _Complex_I,</a>
<a name="ln1474">              -1.223392e-03f - 2.118978e-03f * _Complex_I, 3.210942e-03f + 7.276687e-18f * _Complex_I,</a>
<a name="ln1475">              -1.832781e-03f + 3.174469e-03f * _Complex_I, -1.605471e-03f - 2.780758e-03f * _Complex_I,</a>
<a name="ln1476">              2.446785e-03f + 2.772471e-18f * _Complex_I, -9.721139e-04f + 1.683751e-03f * _Complex_I,</a>
<a name="ln1477">              -8.694311e-04f - 1.505899e-03f * _Complex_I, 1.382894e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1478">              -5.616336e-04f + 9.727779e-04f * _Complex_I },</a>
<a name="ln1479">            { 8.228091e-04f + 8.061204e-19f * _Complex_I, -5.365069e-04f + 9.292572e-04f * _Complex_I,</a>
<a name="ln1480">              -6.011501e-04f - 1.041223e-03f * _Complex_I, 1.249890e-03f + 9.184039e-19f * _Complex_I,</a>
<a name="ln1481">              -7.632708e-04f + 1.322024e-03f * _Complex_I, -9.846035e-04f - 1.705383e-03f * _Complex_I,</a>
<a name="ln1482">              2.080486e-03f + 1.019144e-18f * _Complex_I, -9.846035e-04f + 1.705383e-03f * _Complex_I,</a>
<a name="ln1483">              -7.632708e-04f - 1.322024e-03f * _Complex_I, 1.249890e-03f + 3.061346e-19f * _Complex_I,</a>
<a name="ln1484">              -6.011501e-04f + 1.041223e-03f * _Complex_I, -5.365069e-04f - 9.292572e-04f * _Complex_I,</a>
<a name="ln1485">              8.228091e-04f + 0.000000e+00f * _Complex_I } },</a>
<a name="ln1486">          { { 1.221201e-03f + 5.982162e-19f * _Complex_I, -1.773498e-03f - 6.515727e-19f * _Complex_I,</a>
<a name="ln1487">              1.246697e-03f + 3.053526e-19f * _Complex_I, -8.215306e-04f - 1.006085e-19f * _Complex_I,</a>
<a name="ln1488">              7.609372e-04f + 0.000000e+00f * _Complex_I, -4.863927e-04f + 5.956592e-20f * _Complex_I,</a>
<a name="ln1489">              4.882100e-04f - 1.195770e-19f * _Complex_I, -4.863927e-04f + 1.786978e-19f * _Complex_I,</a>
<a name="ln1490">              7.609372e-04f - 3.727517e-19f * _Complex_I, -8.215306e-04f + 5.030424e-19f * _Complex_I,</a>
<a name="ln1491">              1.246697e-03f - 9.160579e-19f * _Complex_I, -1.773498e-03f + 1.520336e-18f * _Complex_I,</a>
<a name="ln1492">              1.221201e-03f - 1.196432e-18f * _Complex_I },</a>
<a name="ln1493">            { 7.406884e-04f - 1.282910e-03f * _Complex_I, -1.025411e-03f + 1.776065e-03f * _Complex_I,</a>
<a name="ln1494">              7.186273e-04f - 1.244699e-03f * _Complex_I, -4.025606e-04f + 6.972554e-04f * _Complex_I,</a>
<a name="ln1495">              5.908383e-04f - 1.023362e-03f * _Complex_I, -1.125190e-03f + 1.948886e-03f * _Complex_I,</a>
<a name="ln1496">              1.432695e-03f - 2.481501e-03f * _Complex_I, -1.125190e-03f + 1.948886e-03f * _Complex_I,</a>
<a name="ln1497">              5.908383e-04f - 1.023362e-03f * _Complex_I, -4.025606e-04f + 6.972554e-04f * _Complex_I,</a>
<a name="ln1498">              7.186273e-04f - 1.244699e-03f * _Complex_I, -1.025411e-03f + 1.776065e-03f * _Complex_I,</a>
<a name="ln1499">              7.406884e-04f - 1.282910e-03f * _Complex_I },</a>
<a name="ln1500">            { -7.162255e-04f - 1.240539e-03f * _Complex_I, 8.961176e-04f + 1.552121e-03f * _Complex_I,</a>
<a name="ln1501">              -6.705589e-04f - 1.161442e-03f * _Complex_I, 6.187140e-04f + 1.071644e-03f * _Complex_I,</a>
<a name="ln1502">              -1.165433e-03f - 2.018589e-03f * _Complex_I, 1.948120e-03f + 3.374242e-03f * _Complex_I,</a>
<a name="ln1503">              -2.297663e-03f - 3.979669e-03f * _Complex_I, 1.948120e-03f + 3.374242e-03f * _Complex_I,</a>
<a name="ln1504">              -1.165433e-03f - 2.018589e-03f * _Complex_I, 6.187140e-04f + 1.071644e-03f * _Complex_I,</a>
<a name="ln1505">              -6.705589e-04f - 1.161442e-03f * _Complex_I, 8.961176e-04f + 1.552121e-03f * _Complex_I,</a>
<a name="ln1506">              -7.162255e-04f - 1.240539e-03f * _Complex_I },</a>
<a name="ln1507">            { -1.280260e-03f - 7.839331e-19f * _Complex_I, 1.987108e-03f + 9.734024e-19f * _Complex_I,</a>
<a name="ln1508">              -2.614019e-03f - 9.603749e-19f * _Complex_I, 3.635167e-03f + 8.903590e-19f * _Complex_I,</a>
<a name="ln1509">              -4.954867e-03f - 6.067962e-19f * _Complex_I, 6.653220e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1510">              -7.600546e-03f + 9.307984e-19f * _Complex_I, 6.653220e-03f - 1.629569e-18f * _Complex_I,</a>
<a name="ln1511">              -4.954867e-03f + 1.820389e-18f * _Complex_I, 3.635167e-03f - 1.780718e-18f * _Complex_I,</a>
<a name="ln1512">              -2.614019e-03f + 1.600625e-18f * _Complex_I, 1.987108e-03f - 1.460104e-18f * _Complex_I,</a>
<a name="ln1513">              -1.280260e-03f + 1.097506e-18f * _Complex_I },</a>
<a name="ln1514">            { -5.756945e-04f + 9.971322e-04f * _Complex_I, 1.268614e-03f - 2.197304e-03f * _Complex_I,</a>
<a name="ln1515">              -2.421407e-03f + 4.194000e-03f * _Complex_I, 4.045715e-03f - 7.007384e-03f * _Complex_I,</a>
<a name="ln1516">              -5.527367e-03f + 9.573681e-03f * _Complex_I, 6.837207e-03f - 1.184239e-02f * _Complex_I,</a>
<a name="ln1517">              -7.288212e-03f + 1.262355e-02f * _Complex_I, 6.837207e-03f - 1.184239e-02f * _Complex_I,</a>
<a name="ln1518">              -5.527367e-03f + 9.573681e-03f * _Complex_I, 4.045715e-03f - 7.007384e-03f * _Complex_I,</a>
<a name="ln1519">              -2.421407e-03f + 4.194000e-03f * _Complex_I, 1.268614e-03f - 2.197304e-03f * _Complex_I,</a>
<a name="ln1520">              -5.756945e-04f + 9.971322e-04f * _Complex_I },</a>
<a name="ln1521">            { 7.349896e-04f + 1.273039e-03f * _Complex_I, -1.748057e-03f - 3.027723e-03f * _Complex_I,</a>
<a name="ln1522">              3.332671e-03f + 5.772355e-03f * _Complex_I, -6.051736e-03f - 1.048191e-02f * _Complex_I,</a>
<a name="ln1523">              9.842376e-03f + 1.704749e-02f * _Complex_I, -1.401169e-02f - 2.426897e-02f * _Complex_I,</a>
<a name="ln1524">              1.598601e-02f + 2.768858e-02f * _Complex_I, -1.401169e-02f - 2.426897e-02f * _Complex_I,</a>
<a name="ln1525">              9.842376e-03f + 1.704749e-02f * _Complex_I, -6.051736e-03f - 1.048191e-02f * _Complex_I,</a>
<a name="ln1526">              3.332671e-03f + 5.772355e-03f * _Complex_I, -1.748057e-03f - 3.027723e-03f * _Complex_I,</a>
<a name="ln1527">              7.349896e-04f + 1.273039e-03f * _Complex_I },</a>
<a name="ln1528">            { 1.400383e-03f + 1.028985e-18f * _Complex_I, -3.545886e-03f - 2.171229e-18f * _Complex_I,</a>
<a name="ln1529">              7.289370e-03f + 3.570761e-18f * _Complex_I, -1.418908e-02f - 5.212982e-18f * _Complex_I,</a>
<a name="ln1530">              2.520839e-02f + 6.174275e-18f * _Complex_I, -3.934772e-02f - 4.818706e-18f * _Complex_I,</a>
<a name="ln1531">              4.797481e-02f + 0.000000e+00f * _Complex_I, -3.934772e-02f + 4.818706e-18f * _Complex_I,</a>
<a name="ln1532">              2.520839e-02f - 6.174275e-18f * _Complex_I, -1.418908e-02f + 5.212982e-18f * _Complex_I,</a>
<a name="ln1533">              7.289370e-03f - 3.570761e-18f * _Complex_I, -3.545886e-03f + 2.171229e-18f * _Complex_I,</a>
<a name="ln1534">              1.400383e-03f - 1.028985e-18f * _Complex_I },</a>
<a name="ln1535">            { 7.349896e-04f - 1.273039e-03f * _Complex_I, -1.748057e-03f + 3.027723e-03f * _Complex_I,</a>
<a name="ln1536">              3.332671e-03f - 5.772355e-03f * _Complex_I, -6.051736e-03f + 1.048191e-02f * _Complex_I,</a>
<a name="ln1537">              9.842376e-03f - 1.704749e-02f * _Complex_I, -1.401169e-02f + 2.426897e-02f * _Complex_I,</a>
<a name="ln1538">              1.598601e-02f - 2.768858e-02f * _Complex_I, -1.401169e-02f + 2.426897e-02f * _Complex_I,</a>
<a name="ln1539">              9.842376e-03f - 1.704749e-02f * _Complex_I, -6.051736e-03f + 1.048191e-02f * _Complex_I,</a>
<a name="ln1540">              3.332671e-03f - 5.772355e-03f * _Complex_I, -1.748057e-03f + 3.027723e-03f * _Complex_I,</a>
<a name="ln1541">              7.349896e-04f - 1.273039e-03f * _Complex_I },</a>
<a name="ln1542">            { -5.756945e-04f - 9.971322e-04f * _Complex_I, 1.268614e-03f + 2.197304e-03f * _Complex_I,</a>
<a name="ln1543">              -2.421407e-03f - 4.194000e-03f * _Complex_I, 4.045715e-03f + 7.007384e-03f * _Complex_I,</a>
<a name="ln1544">              -5.527367e-03f - 9.573681e-03f * _Complex_I, 6.837207e-03f + 1.184239e-02f * _Complex_I,</a>
<a name="ln1545">              -7.288212e-03f - 1.262355e-02f * _Complex_I, 6.837207e-03f + 1.184239e-02f * _Complex_I,</a>
<a name="ln1546">              -5.527367e-03f - 9.573681e-03f * _Complex_I, 4.045715e-03f + 7.007384e-03f * _Complex_I,</a>
<a name="ln1547">              -2.421407e-03f - 4.194000e-03f * _Complex_I, 1.268614e-03f + 2.197304e-03f * _Complex_I,</a>
<a name="ln1548">              -5.756945e-04f - 9.971322e-04f * _Complex_I },</a>
<a name="ln1549">            { -1.280260e-03f - 1.097506e-18f * _Complex_I, 1.987108e-03f + 1.460104e-18f * _Complex_I,</a>
<a name="ln1550">              -2.614019e-03f - 1.600625e-18f * _Complex_I, 3.635167e-03f + 1.780718e-18f * _Complex_I,</a>
<a name="ln1551">              -4.954867e-03f - 1.820389e-18f * _Complex_I, 6.653220e-03f + 1.629569e-18f * _Complex_I,</a>
<a name="ln1552">              -7.600546e-03f - 9.307984e-19f * _Complex_I, 6.653220e-03f + 0.000000e+00f * _Complex_I,</a>
<a name="ln1553">              -4.954867e-03f + 6.067962e-19f * _Complex_I, 3.635167e-03f - 8.903590e-19f * _Complex_I,</a>
<a name="ln1554">              -2.614019e-03f + 9.603749e-19f * _Complex_I, 1.987108e-03f - 9.734024e-19f * _Complex_I,</a>
<a name="ln1555">              -1.280260e-03f + 7.839331e-19f * _Complex_I },</a>
<a name="ln1556">            { -7.162255e-04f + 1.240539e-03f * _Complex_I, 8.961176e-04f - 1.552121e-03f * _Complex_I,</a>
<a name="ln1557">              -6.705589e-04f + 1.161442e-03f * _Complex_I, 6.187140e-04f - 1.071644e-03f * _Complex_I,</a>
<a name="ln1558">              -1.165433e-03f + 2.018589e-03f * _Complex_I, 1.948120e-03f - 3.374242e-03f * _Complex_I,</a>
<a name="ln1559">              -2.297663e-03f + 3.979669e-03f * _Complex_I, 1.948120e-03f - 3.374242e-03f * _Complex_I,</a>
<a name="ln1560">              -1.165433e-03f + 2.018589e-03f * _Complex_I, 6.187140e-04f - 1.071644e-03f * _Complex_I,</a>
<a name="ln1561">              -6.705589e-04f + 1.161442e-03f * _Complex_I, 8.961176e-04f - 1.552121e-03f * _Complex_I,</a>
<a name="ln1562">              -7.162255e-04f + 1.240539e-03f * _Complex_I },</a>
<a name="ln1563">            { 7.406884e-04f + 1.282910e-03f * _Complex_I, -1.025411e-03f - 1.776065e-03f * _Complex_I,</a>
<a name="ln1564">              7.186273e-04f + 1.244699e-03f * _Complex_I, -4.025606e-04f - 6.972554e-04f * _Complex_I,</a>
<a name="ln1565">              5.908383e-04f + 1.023362e-03f * _Complex_I, -1.125190e-03f - 1.948886e-03f * _Complex_I,</a>
<a name="ln1566">              1.432695e-03f + 2.481501e-03f * _Complex_I, -1.125190e-03f - 1.948886e-03f * _Complex_I,</a>
<a name="ln1567">              5.908383e-04f + 1.023362e-03f * _Complex_I, -4.025606e-04f - 6.972554e-04f * _Complex_I,</a>
<a name="ln1568">              7.186273e-04f + 1.244699e-03f * _Complex_I, -1.025411e-03f - 1.776065e-03f * _Complex_I,</a>
<a name="ln1569">              7.406884e-04f + 1.282910e-03f * _Complex_I },</a>
<a name="ln1570">            { 1.221201e-03f + 1.196432e-18f * _Complex_I, -1.773498e-03f - 1.520336e-18f * _Complex_I,</a>
<a name="ln1571">              1.246697e-03f + 9.160579e-19f * _Complex_I, -8.215306e-04f - 5.030424e-19f * _Complex_I,</a>
<a name="ln1572">              7.609372e-04f + 3.727517e-19f * _Complex_I, -4.863927e-04f - 1.786978e-19f * _Complex_I,</a>
<a name="ln1573">              4.882100e-04f + 1.195770e-19f * _Complex_I, -4.863927e-04f - 5.956592e-20f * _Complex_I,</a>
<a name="ln1574">              7.609372e-04f + 0.000000e+00f * _Complex_I, -8.215306e-04f + 1.006085e-19f * _Complex_I,</a>
<a name="ln1575">              1.246697e-03f - 3.053526e-19f * _Complex_I, -1.773498e-03f + 6.515727e-19f * _Complex_I,</a>
<a name="ln1576">              1.221201e-03f - 5.982162e-19f * _Complex_I } } };</a>
<a name="ln1577"> </a>
<a name="ln1578">  const size_t buffer_size = (size_t)TS * TS * (ndir * 4 + 7) * sizeof(float);</a>
<a name="ln1579">  char *const all_buffers = (char *)dt_alloc_align(64, dt_get_num_threads() * buffer_size);</a>
<a name="ln1580">  if(!all_buffers)</a>
<a name="ln1581">  {</a>
<a name="ln1582">    fprintf(stderr, &quot;[demosaic] not able to allocate FDC base buffers\n&quot;);</a>
<a name="ln1583">    return;</a>
<a name="ln1584">  }</a>
<a name="ln1585"> </a>
<a name="ln1586">  /* Map a green hexagon around each non-green pixel and vice versa:    */</a>
<a name="ln1587">  for(int row = 0; row &lt; 3; row++)</a>
<a name="ln1588">    for(int col = 0; col &lt; 3; col++)</a>
<a name="ln1589">      for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln1590">      {</a>
<a name="ln1591">        int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln1592">        if(FCxtrans(row + orth[d], col + orth[d + 2], NULL, xtrans) == 1)</a>
<a name="ln1593">          ng = 0;</a>
<a name="ln1594">        else</a>
<a name="ln1595">          ng++;</a>
<a name="ln1596">        // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln1597">        // directions, this is the solitary green pixel</a>
<a name="ln1598">        if(ng == 4)</a>
<a name="ln1599">        {</a>
<a name="ln1600">          sgrow = row;</a>
<a name="ln1601">          sgcol = col;</a>
<a name="ln1602">        }</a>
<a name="ln1603">        if(ng == g + 1)</a>
<a name="ln1604">          for(int c = 0; c &lt; 8; c++)</a>
<a name="ln1605">          {</a>
<a name="ln1606">            int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln1607">            int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln1608">            // offset within TSxTS buffer</a>
<a name="ln1609">            allhex[row][col][c ^ (g * 2 &amp; d)] = h + v * TS;</a>
<a name="ln1610">          }</a>
<a name="ln1611">      }</a>
<a name="ln1612"> </a>
<a name="ln1613">  // extra passes propagates out errors at edges, hence need more padding</a>
<a name="ln1614">  const int pad_tile = 13;</a>
<a name="ln1615"> </a>
<a name="ln1616">  // calculate offsets for this roi</a>
<a name="ln1617">  int rowoffset = 0;</a>
<a name="ln1618">  int coloffset = 0;</a>
<a name="ln1619">  for(int row = 0; row &lt; 6; row++)</a>
<a name="ln1620">  {</a>
<a name="ln1621">    if(!((row - sgrow) % 3))</a>
<a name="ln1622">    {</a>
<a name="ln1623">      for(int col = 0; col &lt; 6; col++)</a>
<a name="ln1624">      {</a>
<a name="ln1625">        if(!((col - sgcol) % 3) &amp;&amp; (FCxtrans(row, col + 1, roi_in, xtrans) == 0))</a>
<a name="ln1626">        {</a>
<a name="ln1627">          rowoffset = 37 - row - pad_tile; // 1 plus a generous multiple of 6</a>
<a name="ln1628">          coloffset = 37 - col - pad_tile; // to avoid that this value gets negative</a>
<a name="ln1629">          break;</a>
<a name="ln1630">        }</a>
<a name="ln1631">      }</a>
<a name="ln1632">      break;</a>
<a name="ln1633">    }</a>
<a name="ln1634">  }</a>
<a name="ln1635"> </a>
<a name="ln1636">  // depending on the iso, use either a hybrid approach for chroma, or pure fdc</a>
<a name="ln1637">  float hybrid_fdc[2] = { 1.0f, 0.0f };</a>
<a name="ln1638">  const int xover_iso = dt_conf_get_int(&quot;plugins/darkroom/demosaic/fdc_xover_iso&quot;);</a>
<a name="ln1639">  int iso = self-&gt;dev-&gt;image_storage.exif_iso;</a>
<a name="ln1640">  if(iso &gt; xover_iso)</a>
<a name="ln1641">  {</a>
<a name="ln1642">    hybrid_fdc[0] = 0.0f;</a>
<a name="ln1643">    hybrid_fdc[1] = 1.0f;</a>
<a name="ln1644">  }</a>
<a name="ln1645"> </a>
<a name="ln1646">#ifdef _OPENMP</a>
<a name="ln1647">#pragma omp parallel for default(none)                                                                            \</a>
<a name="ln1648">    dt_omp_firstprivate(ndir, all_buffers, dir, directionality, harr, height, in, Minv, modarr, roi_in, width,    \</a>
<a name="ln1649">                        xtrans, pad_tile, buffer_size)                                                            \</a>
<a name="ln1650">        shared(sgrow, sgcol, allhex, out, rowoffset, coloffset, hybrid_fdc) schedule(dynamic)</a>
<a name="ln1651">#endif</a>
<a name="ln1652">  // step through TSxTS cells of image, each tile overlapping the</a>
<a name="ln1653">  // prior as interpolation needs a substantial border</a>
<a name="ln1654">  for(int top = -pad_tile; top &lt; height - pad_tile; top += TS - (pad_tile * 2))</a>
<a name="ln1655">  {</a>
<a name="ln1656">    char *const buffer = all_buffers + dt_get_thread_num() * buffer_size;</a>
<a name="ln1657">    // rgb points to ndir TSxTS tiles of 3 channels (R, G, and B)</a>
<a name="ln1658">    float(*rgb)[TS][TS][3] = (float(*)[TS][TS][3])buffer;</a>
<a name="ln1659">    // yuv points to 3 channel (Y, u, and v) TSxTS tiles</a>
<a name="ln1660">    // note that channels come before tiles to allow for a</a>
<a name="ln1661">    // vectorization optimization when building drv[] from yuv[]</a>
<a name="ln1662">    float (*const yuv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1663">    // drv points to ndir TSxTS tiles, each a single channel of derivatives</a>
<a name="ln1664">    float (*const drv)[TS][TS] = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 3 + 3) * sizeof(float));</a>
<a name="ln1665">    // gmin and gmax reuse memory which is used later by yuv buffer;</a>
<a name="ln1666">    // each points to a TSxTS tile of single channel data</a>
<a name="ln1667">    float (*const gmin)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1668">    float (*const gmax)[TS] = (float(*)[TS])(buffer + TS * TS * (ndir * 3 + 1) * sizeof(float));</a>
<a name="ln1669">    // homo and homosum reuse memory which is used earlier in the</a>
<a name="ln1670">    // loop; each points to ndir single-channel TSxTS tiles</a>
<a name="ln1671">    uint8_t (*const homo)[TS][TS] = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float));</a>
<a name="ln1672">    uint8_t (*const homosum)[TS][TS]</a>
<a name="ln1673">        = (uint8_t(*)[TS][TS])(buffer + TS * TS * (ndir * 3) * sizeof(float) + TS * TS * ndir * sizeof(uint8_t));</a>
<a name="ln1674">    // append all fdc related buffers</a>
<a name="ln1675">    float complex *fdc_buf_start = (float complex *)(buffer + TS * TS * (ndir * 4 + 3) * sizeof(float));</a>
<a name="ln1676">    const int fdc_buf_size = TS * TS;</a>
<a name="ln1677">    float(*const i_src) = (float *)fdc_buf_start;</a>
<a name="ln1678">    float complex(*const o_src) = fdc_buf_start + fdc_buf_size;</a>
<a name="ln1679">    // by the time the chroma values are calculated, o_src can be overwritten.</a>
<a name="ln1680">    float(*const fdc_chroma) = (float *)o_src;</a>
<a name="ln1681"> </a>
<a name="ln1682">    for(int left = -pad_tile; left &lt; width - pad_tile; left += TS - (pad_tile * 2))</a>
<a name="ln1683">    {</a>
<a name="ln1684">      int mrow = MIN(top + TS, height + pad_tile);</a>
<a name="ln1685">      int mcol = MIN(left + TS, width + pad_tile);</a>
<a name="ln1686"> </a>
<a name="ln1687">      // Copy current tile from in to image buffer. If border goes</a>
<a name="ln1688">      // beyond edges of image, fill with mirrored/interpolated edges.</a>
<a name="ln1689">      // The extra border avoids discontinuities at image edges.</a>
<a name="ln1690">      for(int row = top; row &lt; mrow; row++)</a>
<a name="ln1691">        for(int col = left; col &lt; mcol; col++)</a>
<a name="ln1692">        {</a>
<a name="ln1693">          float(*const pix) = rgb[0][row - top][col - left];</a>
<a name="ln1694">          if((col &gt;= 0) &amp;&amp; (row &gt;= 0) &amp;&amp; (col &lt; width) &amp;&amp; (row &lt; height))</a>
<a name="ln1695">          {</a>
<a name="ln1696">            const int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1697">            for(int c = 0; c &lt; 3; c++) pix[c] = (c == f) ? in[roi_in-&gt;width * row + col] : 0.f;</a>
<a name="ln1698">            *(i_src + TS * (row - top) + (col - left)) = in[roi_in-&gt;width * row + col];</a>
<a name="ln1699">          }</a>
<a name="ln1700">          else</a>
<a name="ln1701">          {</a>
<a name="ln1702">            // mirror a border pixel if beyond image edge</a>
<a name="ln1703">            const int c = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1704">            for(int cc = 0; cc &lt; 3; cc++)</a>
<a name="ln1705">              if(cc != c)</a>
<a name="ln1706">                pix[cc] = 0.0f;</a>
<a name="ln1707">              else</a>
<a name="ln1708">              {</a>
<a name="ln1709">#define TRANSLATE(n, size) ((n &gt;= size) ? (2 * size - n - 2) : abs(n))</a>
<a name="ln1710">                const int cy = TRANSLATE(row, height), cx = TRANSLATE(col, width);</a>
<a name="ln1711">                if(c == FCxtrans(cy, cx, roi_in, xtrans))</a>
<a name="ln1712">                {</a>
<a name="ln1713">                  pix[c] = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln1714">                  *(i_src + TS * (row - top) + (col - left)) = in[roi_in-&gt;width * cy + cx];</a>
<a name="ln1715">                }</a>
<a name="ln1716">                else</a>
<a name="ln1717">                {</a>
<a name="ln1718">                  // interpolate if mirror pixel is a different color</a>
<a name="ln1719">                  float sum = 0.0f;</a>
<a name="ln1720">                  uint8_t count = 0;</a>
<a name="ln1721">                  for(int y = row - 1; y &lt;= row + 1; y++)</a>
<a name="ln1722">                    for(int x = col - 1; x &lt;= col + 1; x++)</a>
<a name="ln1723">                    {</a>
<a name="ln1724">                      const int yy = TRANSLATE(y, height), xx = TRANSLATE(x, width);</a>
<a name="ln1725">                      const int ff = FCxtrans(yy, xx, roi_in, xtrans);</a>
<a name="ln1726">                      if(ff == c)</a>
<a name="ln1727">                      {</a>
<a name="ln1728">                        sum += in[roi_in-&gt;width * yy + xx];</a>
<a name="ln1729">                        count++;</a>
<a name="ln1730">                      }</a>
<a name="ln1731">                    }</a>
<a name="ln1732">                  pix[c] = sum / count;</a>
<a name="ln1733">                  *(i_src + TS * (row - top) + (col - left)) = pix[c];</a>
<a name="ln1734">                }</a>
<a name="ln1735">              }</a>
<a name="ln1736">          }</a>
<a name="ln1737">        }</a>
<a name="ln1738"> </a>
<a name="ln1739">      // duplicate rgb[0] to rgb[1], rgb[2], and rgb[3]</a>
<a name="ln1740">      for(int c = 1; c &lt;= 3; c++) memcpy(rgb[c], rgb[0], sizeof(*rgb));</a>
<a name="ln1741"> </a>
<a name="ln1742">      // note that successive calculations are inset within the tile</a>
<a name="ln1743">      // so as to give enough border data, and there needs to be a 6</a>
<a name="ln1744">      // pixel border initially to allow allhex to find neighboring</a>
<a name="ln1745">      // pixels</a>
<a name="ln1746"> </a>
<a name="ln1747">      /* Set green1 and green3 to the minimum and maximum allowed values:   */</a>
<a name="ln1748">      // Run through each red/blue or blue/red pair, setting their g1</a>
<a name="ln1749">      // and g3 values to the min/max of green pixels surrounding the</a>
<a name="ln1750">      // pair. Use a 3 pixel border as gmin/gmax is used by</a>
<a name="ln1751">      // interpolate green which has a 3 pixel border.</a>
<a name="ln1752">      const int pad_g1_g3 = 3;</a>
<a name="ln1753">      for(int row = top + pad_g1_g3; row &lt; mrow - pad_g1_g3; row++)</a>
<a name="ln1754">      {</a>
<a name="ln1755">        // setting max to 0.0f signifies that this is a new pair, which</a>
<a name="ln1756">        // requires a new min/max calculation of its neighboring greens</a>
<a name="ln1757">        float min = FLT_MAX, max = 0.0f;</a>
<a name="ln1758">        for(int col = left + pad_g1_g3; col &lt; mcol - pad_g1_g3; col++)</a>
<a name="ln1759">        {</a>
<a name="ln1760">          // if in row of horizontal red &amp; blue pairs (or processing</a>
<a name="ln1761">          // vertical red &amp; blue pairs near image bottom), reset min/max</a>
<a name="ln1762">          // between each pair</a>
<a name="ln1763">          if(FCxtrans(row, col, roi_in, xtrans) == 1)</a>
<a name="ln1764">          {</a>
<a name="ln1765">            min = FLT_MAX, max = 0.0f;</a>
<a name="ln1766">            continue;</a>
<a name="ln1767">          }</a>
<a name="ln1768">          // if at start of red &amp; blue pair, calculate min/max of green</a>
<a name="ln1769">          // pixels surrounding it; note that while normally using == to</a>
<a name="ln1770">          // compare floats is suspect, here the check is if 0.0f has</a>
<a name="ln1771">          // explicitly been assigned to max (which signifies a new</a>
<a name="ln1772">          // red/blue pair)</a>
<a name="ln1773">          if(max == 0.0f)</a>
<a name="ln1774">          {</a>
<a name="ln1775">            float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1776">            const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1777">            for(int c = 0; c &lt; 6; c++)</a>
<a name="ln1778">            {</a>
<a name="ln1779">              const float val = pix[hex[c]][1];</a>
<a name="ln1780">              if(min &gt; val) min = val;</a>
<a name="ln1781">              if(max &lt; val) max = val;</a>
<a name="ln1782">            }</a>
<a name="ln1783">          }</a>
<a name="ln1784">          gmin[row - top][col - left] = min;</a>
<a name="ln1785">          gmax[row - top][col - left] = max;</a>
<a name="ln1786">          // handle vertical red/blue pairs</a>
<a name="ln1787">          switch((row - sgrow) % 3)</a>
<a name="ln1788">          {</a>
<a name="ln1789">            // hop down a row to second pixel in vertical pair</a>
<a name="ln1790">            case 1:</a>
<a name="ln1791">              if(row &lt; mrow - 4) row++, col--;</a>
<a name="ln1792">              break;</a>
<a name="ln1793">            // then if not done with the row hop up and right to next</a>
<a name="ln1794">            // vertical red/blue pair, resetting min/max</a>
<a name="ln1795">            case 2:</a>
<a name="ln1796">              min = FLT_MAX, max = 0.0f;</a>
<a name="ln1797">              if((col += 2) &lt; mcol - 4 &amp;&amp; row &gt; top + 3) row--;</a>
<a name="ln1798">          }</a>
<a name="ln1799">        }</a>
<a name="ln1800">      }</a>
<a name="ln1801"> </a>
<a name="ln1802">      /* Interpolate green horizontally, vertically, and along both diagonals: */</a>
<a name="ln1803">      // need a 3 pixel border here as 3*hex[] can have a 3 unit offset</a>
<a name="ln1804">      const int pad_g_interp = 3;</a>
<a name="ln1805">      for(int row = top + pad_g_interp; row &lt; mrow - pad_g_interp; row++)</a>
<a name="ln1806">        for(int col = left + pad_g_interp; col &lt; mcol - pad_g_interp; col++)</a>
<a name="ln1807">        {</a>
<a name="ln1808">          float color[8];</a>
<a name="ln1809">          int f = FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1810">          if(f == 1) continue;</a>
<a name="ln1811">          float (*const pix)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1812">          const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1813">          // TODO: these constants come from integer math constants in</a>
<a name="ln1814">          // dcraw -- calculate them instead from interpolation math</a>
<a name="ln1815">          color[0] = 0.6796875f * (pix[hex[1]][1] + pix[hex[0]][1])</a>
<a name="ln1816">                     - 0.1796875f * (pix[2 * hex[1]][1] + pix[2 * hex[0]][1]);</a>
<a name="ln1817">          color[1] = 0.87109375f * pix[hex[3]][1] + pix[hex[2]][1] * 0.13f</a>
<a name="ln1818">                     + 0.359375f * (pix[0][f] - pix[-hex[2]][f]);</a>
<a name="ln1819">          for(int c = 0; c &lt; 2; c++)</a>
<a name="ln1820">            color[2 + c] = 0.640625f * pix[hex[4 + c]][1] + 0.359375f * pix[-2 * hex[4 + c]][1]</a>
<a name="ln1821">                           + 0.12890625f * (2 * pix[0][f] - pix[3 * hex[4 + c]][f] - pix[-3 * hex[4 + c]][f]);</a>
<a name="ln1822">          for(int c = 0; c &lt; 4; c++)</a>
<a name="ln1823">            rgb[c ^ !((row - sgrow) % 3)][row - top][col - left][1]</a>
<a name="ln1824">                = CLAMPS(color[c], gmin[row - top][col - left], gmax[row - top][col - left]);</a>
<a name="ln1825">        }</a>
<a name="ln1826"> </a>
<a name="ln1827">      /* Interpolate red and blue values for solitary green pixels:   */</a>
<a name="ln1828">      const int pad_rb_g = 6;</a>
<a name="ln1829">      for(int row = (top - sgrow + pad_rb_g + 2) / 3 * 3 + sgrow; row &lt; mrow - pad_rb_g; row += 3)</a>
<a name="ln1830">        for(int col = (left - sgcol + pad_rb_g + 2) / 3 * 3 + sgcol; col &lt; mcol - pad_rb_g; col += 3)</a>
<a name="ln1831">        {</a>
<a name="ln1832">          float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1833">          int h = FCxtrans(row, col + 1, roi_in, xtrans);</a>
<a name="ln1834">          float diff[6] = { 0.0f };</a>
<a name="ln1835">          float color[3][8];</a>
<a name="ln1836">          for(int i = 1, d = 0; d &lt; 6; d++, i ^= TS ^ 1, h ^= 2)</a>
<a name="ln1837">          {</a>
<a name="ln1838">            for(int c = 0; c &lt; 2; c++, h ^= 2)</a>
<a name="ln1839">            {</a>
<a name="ln1840">              float g = 2 * rfx[0][1] - rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1];</a>
<a name="ln1841">              color[h][d] = g + rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h];</a>
<a name="ln1842">              if(d &gt; 1)</a>
<a name="ln1843">                diff[d] += SQR(rfx[i &lt;&lt; c][1] - rfx[-(i &lt;&lt; c)][1] - rfx[i &lt;&lt; c][h] + rfx[-(i &lt;&lt; c)][h]) + SQR(g);</a>
<a name="ln1844">            }</a>
<a name="ln1845">            if(d &gt; 1 &amp;&amp; (d &amp; 1))</a>
<a name="ln1846">              if(diff[d - 1] &lt; diff[d])</a>
<a name="ln1847">                for(int c = 0; c &lt; 2; c++) color[c * 2][d] = color[c * 2][d - 1];</a>
<a name="ln1848">            if(d &lt; 2 || (d &amp; 1))</a>
<a name="ln1849">            {</a>
<a name="ln1850">              for(int c = 0; c &lt; 2; c++) rfx[0][c * 2] = color[c * 2][d] / 2.f;</a>
<a name="ln1851">              rfx += TS * TS;</a>
<a name="ln1852">            }</a>
<a name="ln1853">          }</a>
<a name="ln1854">        }</a>
<a name="ln1855"> </a>
<a name="ln1856">      /* Interpolate red for blue pixels and vice versa:              */</a>
<a name="ln1857">      const int pad_rb_br = 6;</a>
<a name="ln1858">      for(int row = top + pad_rb_br; row &lt; mrow - pad_rb_br; row++)</a>
<a name="ln1859">        for(int col = left + pad_rb_br; col &lt; mcol - pad_rb_br; col++)</a>
<a name="ln1860">        {</a>
<a name="ln1861">          int f = 2 - FCxtrans(row, col, roi_in, xtrans);</a>
<a name="ln1862">          if(f == 1) continue;</a>
<a name="ln1863">          float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1864">          int c = (row - sgrow) % 3 ? TS : 1;</a>
<a name="ln1865">          int h = 3 * (c ^ TS ^ 1);</a>
<a name="ln1866">          for(int d = 0; d &lt; 4; d++, rfx += TS * TS)</a>
<a name="ln1867">          {</a>
<a name="ln1868">            int i = d &gt; 1 || ((d ^ c) &amp; 1)</a>
<a name="ln1869">                            || ((fabsf(rfx[0][1] - rfx[c][1]) + fabsf(rfx[0][1] - rfx[-c][1]))</a>
<a name="ln1870">                                &lt; 2.f * (fabsf(rfx[0][1] - rfx[h][1]) + fabsf(rfx[0][1] - rfx[-h][1]))) ? c : h;</a>
<a name="ln1871">            rfx[0][f] = (rfx[i][f] + rfx[-i][f] + 2.f * rfx[0][1] - rfx[i][1] - rfx[-i][1]) / 2.f;</a>
<a name="ln1872">          }</a>
<a name="ln1873">        }</a>
<a name="ln1874"> </a>
<a name="ln1875">      /* Fill in red and blue for 2x2 blocks of green:                */</a>
<a name="ln1876">      const int pad_g22 = 8;</a>
<a name="ln1877">      for(int row = top + pad_g22; row &lt; mrow - pad_g22; row++)</a>
<a name="ln1878">        if((row - sgrow) % 3)</a>
<a name="ln1879">          for(int col = left + pad_g22; col &lt; mcol - pad_g22; col++)</a>
<a name="ln1880">            if((col - sgcol) % 3)</a>
<a name="ln1881">            {</a>
<a name="ln1882">              float redblue[3][3];</a>
<a name="ln1883">              float(*rfx)[3] = &amp;rgb[0][row - top][col - left];</a>
<a name="ln1884">              const short *const hex = hexmap(row, col, allhex);</a>
<a name="ln1885">              for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln1886">                if(hex[d] + hex[d + 1])</a>
<a name="ln1887">                {</a>
<a name="ln1888">                  float g = 3.f * rfx[0][1] - 2.f * rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln1889">                  for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln1890">                  {</a>
<a name="ln1891">                    rfx[0][c] = (g + 2.f * rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 3.f;</a>
<a name="ln1892">                    redblue[d][c] = rfx[0][c];</a>
<a name="ln1893">                  }</a>
<a name="ln1894">                }</a>
<a name="ln1895">                else</a>
<a name="ln1896">                {</a>
<a name="ln1897">                  float g = 2.f * rfx[0][1] - rfx[hex[d]][1] - rfx[hex[d + 1]][1];</a>
<a name="ln1898">                  for(int c = 0; c &lt; 4; c += 2)</a>
<a name="ln1899">                  {</a>
<a name="ln1900">                    rfx[0][c] = (g + rfx[hex[d]][c] + rfx[hex[d + 1]][c]) / 2.f;</a>
<a name="ln1901">                    redblue[d][c] = rfx[0][c];</a>
<a name="ln1902">                  }</a>
<a name="ln1903">                }</a>
<a name="ln1904">              // to fill in red and blue also for diagonal directions</a>
<a name="ln1905">              for(int d = 0; d &lt; ndir; d += 2, rfx += TS * TS)</a>
<a name="ln1906">                for(int c = 0; c &lt; 4; c += 2) rfx[0][c] = (redblue[0][c] + redblue[2][c]) * 0.5f;</a>
<a name="ln1907">           }</a>
<a name="ln1908"> </a>
<a name="ln1909">      // jump back to the first set of rgb buffers (this is a nop</a>
<a name="ln1910">      // unless on the second pass)</a>
<a name="ln1911">      rgb = (float(*)[TS][TS][3])buffer;</a>
<a name="ln1912">      // from here on out, mainly are working within the current tile</a>
<a name="ln1913">      // rather than in reference to the image, so don't offset</a>
<a name="ln1914">      // mrow/mcol by top/left of tile</a>
<a name="ln1915">      mrow -= top;</a>
<a name="ln1916">      mcol -= left;</a>
<a name="ln1917"> </a>
<a name="ln1918">      /* Convert to perceptual colorspace and differentiate in all directions:  */</a>
<a name="ln1919">      // Original dcraw algorithm uses CIELab as perceptual space</a>
<a name="ln1920">      // (presumably coming from original AHD) and converts taking</a>
<a name="ln1921">      // camera matrix into account. Now use YPbPr which requires much</a>
<a name="ln1922">      // less code and is nearly indistinguishable. It assumes the</a>
<a name="ln1923">      // camera RGB is roughly linear.</a>
<a name="ln1924">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1925">      {</a>
<a name="ln1926">        const int pad_yuv = 8;</a>
<a name="ln1927">        for(int row = pad_yuv; row &lt; mrow - pad_yuv; row++)</a>
<a name="ln1928">          for(int col = pad_yuv; col &lt; mcol - pad_yuv; col++)</a>
<a name="ln1929">          {</a>
<a name="ln1930">            float *rx = rgb[d][row][col];</a>
<a name="ln1931">            // use ITU-R BT.2020 YPbPr, which is great, but could use</a>
<a name="ln1932">            // a better/simpler choice? note that imageop.h provides</a>
<a name="ln1933">            // dt_iop_RGB_to_YCbCr which uses Rec. 601 conversion,</a>
<a name="ln1934">            // which appears less good with specular highlights</a>
<a name="ln1935">            float y = 0.2627f * rx[0] + 0.6780f * rx[1] + 0.0593f * rx[2];</a>
<a name="ln1936">            yuv[0][row][col] = y;</a>
<a name="ln1937">            yuv[1][row][col] = (rx[2] - y) * 0.56433f;</a>
<a name="ln1938">            yuv[2][row][col] = (rx[0] - y) * 0.67815f;</a>
<a name="ln1939">          }</a>
<a name="ln1940">        // Note that f can offset by a column (-1 or +1) and by a row</a>
<a name="ln1941">        // (-TS or TS). The row-wise offsets cause the undefined</a>
<a name="ln1942">        // behavior sanitizer to warn of an out of bounds index, but</a>
<a name="ln1943">        // as yfx is multi-dimensional and there is sufficient</a>
<a name="ln1944">        // padding, that is not actually so.</a>
<a name="ln1945">        const int f = dir[d &amp; 3];</a>
<a name="ln1946">        const int pad_drv = 9;</a>
<a name="ln1947">        for(int row = pad_drv; row &lt; mrow - pad_drv; row++)</a>
<a name="ln1948">          for(int col = pad_drv; col &lt; mcol - pad_drv; col++)</a>
<a name="ln1949">          {</a>
<a name="ln1950">            float(*yfx)[TS][TS] = (float(*)[TS][TS]) &amp; yuv[0][row][col];</a>
<a name="ln1951">            drv[d][row][col] = SQR(2 * yfx[0][0][0] - yfx[0][0][f] - yfx[0][0][-f])</a>
<a name="ln1952">                               + SQR(2 * yfx[1][0][0] - yfx[1][0][f] - yfx[1][0][-f])</a>
<a name="ln1953">                               + SQR(2 * yfx[2][0][0] - yfx[2][0][f] - yfx[2][0][-f]);</a>
<a name="ln1954">          }</a>
<a name="ln1955">      }</a>
<a name="ln1956"> </a>
<a name="ln1957">      /* Build homogeneity maps from the derivatives:                   */</a>
<a name="ln1958">      memset(homo, 0, (size_t)ndir * TS * TS * sizeof(uint8_t));</a>
<a name="ln1959">      const int pad_homo = 10;</a>
<a name="ln1960">      for(int row = pad_homo; row &lt; mrow - pad_homo; row++)</a>
<a name="ln1961">        for(int col = pad_homo; col &lt; mcol - pad_homo; col++)</a>
<a name="ln1962">        {</a>
<a name="ln1963">          float tr = FLT_MAX;</a>
<a name="ln1964">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1965">            if(tr &gt; drv[d][row][col]) tr = drv[d][row][col];</a>
<a name="ln1966">          tr *= 8;</a>
<a name="ln1967">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1968">            for(int v = -1; v &lt;= 1; v++)</a>
<a name="ln1969">              for(int h = -1; h &lt;= 1; h++) homo[d][row][col] += ((drv[d][row + v][col + h] &lt;= tr) ? 1 : 0);</a>
<a name="ln1970">        }</a>
<a name="ln1971"> </a>
<a name="ln1972">      /* Build 5x5 sum of homogeneity maps for each pixel &amp; direction */</a>
<a name="ln1973">      for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln1974">        for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln1975">        {</a>
<a name="ln1976">          // start before first column where homo[d][row][col+2] != 0,</a>
<a name="ln1977">          // so can know v5sum and homosum[d][row][col] will be 0</a>
<a name="ln1978">          int col = pad_tile - 5;</a>
<a name="ln1979">          uint8_t v5sum[5] = { 0 };</a>
<a name="ln1980">          homosum[d][row][col] = 0;</a>
<a name="ln1981">          // calculate by rolling through column sums</a>
<a name="ln1982">          for(col++; col &lt; mcol - pad_tile; col++)</a>
<a name="ln1983">          {</a>
<a name="ln1984">            uint8_t colsum = 0;</a>
<a name="ln1985">            for(int v = -2; v &lt;= 2; v++) colsum += homo[d][row + v][col + 2];</a>
<a name="ln1986">            homosum[d][row][col] = homosum[d][row][col - 1] - v5sum[col % 5] + colsum;</a>
<a name="ln1987">            v5sum[col % 5] = colsum;</a>
<a name="ln1988">          }</a>
<a name="ln1989">        }</a>
<a name="ln1990"> </a>
<a name="ln1991">      /* Calculate chroma values in fdc:       */</a>
<a name="ln1992">      const int pad_fdc = 6;</a>
<a name="ln1993">      for(int row = pad_fdc; row &lt; mrow - pad_fdc; row++)</a>
<a name="ln1994">        for(int col = pad_fdc; col &lt; mcol - pad_fdc; col++)</a>
<a name="ln1995">        {</a>
<a name="ln1996">          int myrow, mycol;</a>
<a name="ln1997">          uint8_t hm[8] = { 0 };</a>
<a name="ln1998">          uint8_t maxval = 0;</a>
<a name="ln1999">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2000">          {</a>
<a name="ln2001">            hm[d] = homosum[d][row][col];</a>
<a name="ln2002">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln2003">          }</a>
<a name="ln2004">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln2005">          float dircount = 0;</a>
<a name="ln2006">          float dirsum = 0.f;</a>
<a name="ln2007">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2008">            if(hm[d] &gt;= maxval)</a>
<a name="ln2009">            {</a>
<a name="ln2010">              dircount++;</a>
<a name="ln2011">              dirsum += directionality[d];</a>
<a name="ln2012">            }</a>
<a name="ln2013">          float w = dirsum / (float)dircount;</a>
<a name="ln2014">          int fdc_row, fdc_col;</a>
<a name="ln2015">          float complex C2m, C5m, C7m, C10m;</a>
<a name="ln2016">#define CONV_FILT(VAR, FILT)                                                                                      \</a>
<a name="ln2017">  VAR = 0.0f + 0.0f * _Complex_I;                                                                                 \</a>
<a name="ln2018">  for(fdc_row = 0, myrow = row - 6; fdc_row &lt; 13; fdc_row++, myrow++)                                             \</a>
<a name="ln2019">    for(fdc_col = 0, mycol = col - 6; fdc_col &lt; 13; fdc_col++, mycol++)                                           \</a>
<a name="ln2020">      VAR += FILT[12 - fdc_row][12 - fdc_col] * *(i_src + TS * myrow + mycol);</a>
<a name="ln2021">          CONV_FILT(C2m, harr[0])</a>
<a name="ln2022">          CONV_FILT(C5m, harr[1])</a>
<a name="ln2023">          CONV_FILT(C7m, harr[2])</a>
<a name="ln2024">          CONV_FILT(C10m, harr[3])</a>
<a name="ln2025">#undef CONV_FILT</a>
<a name="ln2026">          // build the q vector components</a>
<a name="ln2027">          myrow = (row + rowoffset) % 6;</a>
<a name="ln2028">          mycol = (col + coloffset) % 6;</a>
<a name="ln2029">          float complex modulator[8];</a>
<a name="ln2030">          for(int c = 0; c &lt; 8; c++) modulator[c] = modarr[myrow][mycol][c];</a>
<a name="ln2031">          float complex qmat[8];</a>
<a name="ln2032">          qmat[4] = w * C10m * modulator[0] - (1.0f - w) * C2m * modulator[1];</a>
<a name="ln2033">          qmat[6] = conjf(qmat[4]);</a>
<a name="ln2034">          qmat[1] = C5m * modulator[6];</a>
<a name="ln2035">          qmat[2] = conjf(-0.5f * qmat[1]);</a>
<a name="ln2036">          qmat[5] = conjf(qmat[2]);</a>
<a name="ln2037">          qmat[3] = C7m * modulator[7];</a>
<a name="ln2038">          qmat[7] = conjf(qmat[1]);</a>
<a name="ln2039">          // get L</a>
<a name="ln2040">          C2m = qmat[4] * (conjf(modulator[0]) - conjf(modulator[1]));</a>
<a name="ln2041">          float complex C3m = qmat[6] * (modulator[2] - modulator[3]);</a>
<a name="ln2042">          float complex C6m = qmat[2] * (conjf(modulator[4]) + conjf(modulator[5]));</a>
<a name="ln2043">          float complex C12m = qmat[5] * (modulator[4] + modulator[5]);</a>
<a name="ln2044">          float complex C18m = qmat[7] * modulator[6];</a>
<a name="ln2045">          qmat[0] = *(i_src + row * TS + col) - C2m - C3m - C5m - C6m - 2.0f * C7m - C12m - C18m;</a>
<a name="ln2046">          // get the rgb components from fdc</a>
<a name="ln2047">          float rgbpix[3] = { 0.f, 0.f, 0.f };</a>
<a name="ln2048">          // multiply with the inverse matrix of M</a>
<a name="ln2049">          for(int color = 0; color &lt; 3; color++)</a>
<a name="ln2050">            for(int c = 0; c &lt; 8; c++)</a>
<a name="ln2051">            {</a>
<a name="ln2052">              rgbpix[color] += Minv[color][c] * qmat[c];</a>
<a name="ln2053">            }</a>
<a name="ln2054">          // now separate luma and chroma for</a>
<a name="ln2055">          // frequency domain chroma</a>
<a name="ln2056">          // and store it in fdc_chroma</a>
<a name="ln2057">          float uv[2];</a>
<a name="ln2058">          float y = 0.2627f * rgbpix[0] + 0.6780f * rgbpix[1] + 0.0593f * rgbpix[2];</a>
<a name="ln2059">          uv[0] = (rgbpix[2] - y) * 0.56433f;</a>
<a name="ln2060">          uv[1] = (rgbpix[0] - y) * 0.67815f;</a>
<a name="ln2061">          for(int c = 0; c &lt; 2; c++) *(fdc_chroma + c * TS * TS + row * TS + col) = uv[c];</a>
<a name="ln2062">        }</a>
<a name="ln2063"> </a>
<a name="ln2064">      /* Average the most homogeneous pixels for the final result:       */</a>
<a name="ln2065">      for(int row = pad_tile; row &lt; mrow - pad_tile; row++)</a>
<a name="ln2066">        for(int col = pad_tile; col &lt; mcol - pad_tile; col++)</a>
<a name="ln2067">        {</a>
<a name="ln2068">          uint8_t hm[8] = { 0 };</a>
<a name="ln2069">          uint8_t maxval = 0;</a>
<a name="ln2070">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2071">          {</a>
<a name="ln2072">            hm[d] = homosum[d][row][col];</a>
<a name="ln2073">            maxval = (maxval &lt; hm[d] ? hm[d] : maxval);</a>
<a name="ln2074">          }</a>
<a name="ln2075">          maxval -= maxval &gt;&gt; 3;</a>
<a name="ln2076">          for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln2077">            if(hm[d] &lt; hm[d + 4])</a>
<a name="ln2078">              hm[d] = 0;</a>
<a name="ln2079">            else if(hm[d] &gt; hm[d + 4])</a>
<a name="ln2080">              hm[d + 4] = 0;</a>
<a name="ln2081">          float avg[4] = { 0.f };</a>
<a name="ln2082">          for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln2083">            if(hm[d] &gt;= maxval)</a>
<a name="ln2084">            {</a>
<a name="ln2085">              for(int c = 0; c &lt; 3; c++) avg[c] += rgb[d][row][col][c];</a>
<a name="ln2086">              avg[3]++;</a>
<a name="ln2087">            }</a>
<a name="ln2088">          float rgbpix[3];</a>
<a name="ln2089">          for(int c = 0; c &lt; 3; c++) rgbpix[c] = avg[c] / avg[3];</a>
<a name="ln2090">          // preserve all components of Markesteijn for this pixel</a>
<a name="ln2091">          float y = 0.2627f * rgbpix[0] + 0.6780f * rgbpix[1] + 0.0593f * rgbpix[2];</a>
<a name="ln2092">          float um = (rgbpix[2] - y) * 0.56433f;</a>
<a name="ln2093">          float vm = (rgbpix[0] - y) * 0.67815f;</a>
<a name="ln2094">          float uvf[2];</a>
<a name="ln2095">          // macros for fast meadian filtering</a>
<a name="ln2096">#define PIX_SWAP(a, b)                                                                                            \</a>
<a name="ln2097">  {                                                                                                               \</a>
<a name="ln2098">    tempf = (a);                                                                                                  \</a>
<a name="ln2099">    (a) = (b);                                                                                                    \</a>
<a name="ln2100">    (b) = tempf;                                                                                                  \</a>
<a name="ln2101">  }</a>
<a name="ln2102">#define PIX_SORT(a, b)                                                                                            \</a>
<a name="ln2103">  {                                                                                                               \</a>
<a name="ln2104">    if((a) &gt; (b)) PIX_SWAP((a), (b));                                                                             \</a>
<a name="ln2105">  }</a>
<a name="ln2106">          // instead of merely reading the values, perform 5 pixel median filter</a>
<a name="ln2107">          // one median filter is required to avoid textile artifacts</a>
<a name="ln2108">          for(int chrm = 0; chrm &lt; 2; chrm++)</a>
<a name="ln2109">          {</a>
<a name="ln2110">            float temp[5];</a>
<a name="ln2111">            float tempf;</a>
<a name="ln2112">            // load the window into temp</a>
<a name="ln2113">            memcpy(&amp;temp[0], fdc_chroma + chrm * TS * TS + (row - 1) * TS + (col), 1 * sizeof(float));</a>
<a name="ln2114">            memcpy(&amp;temp[1], fdc_chroma + chrm * TS * TS + (row)*TS + (col - 1), 3 * sizeof(float));</a>
<a name="ln2115">            memcpy(&amp;temp[4], fdc_chroma + chrm * TS * TS + (row + 1) * TS + (col), 1 * sizeof(float));</a>
<a name="ln2116">            PIX_SORT(temp[0], temp[1]);</a>
<a name="ln2117">            PIX_SORT(temp[3], temp[4]);</a>
<a name="ln2118">            PIX_SORT(temp[0], temp[3]);</a>
<a name="ln2119">            PIX_SORT(temp[1], temp[4]);</a>
<a name="ln2120">            PIX_SORT(temp[1], temp[2]);</a>
<a name="ln2121">            PIX_SORT(temp[2], temp[3]);</a>
<a name="ln2122">            PIX_SORT(temp[1], temp[2]);</a>
<a name="ln2123">            uvf[chrm] = temp[2];</a>
<a name="ln2124">          }</a>
<a name="ln2125">          // use hybrid or pure fdc, depending on what was set above.</a>
<a name="ln2126">          // in case of hybrid, use the chroma that has the smallest</a>
<a name="ln2127">          // absolute value</a>
<a name="ln2128">          float uv[2];</a>
<a name="ln2129">          uv[0] = (((ABS(uvf[0]) &lt; ABS(um)) &amp; (ABS(uvf[1]) &lt; (1.02f * ABS(vm)))) ? uvf[0] : um) * hybrid_fdc[0] + uvf[0] * hybrid_fdc[1];</a>
<a name="ln2130">          uv[1] = (((ABS(uvf[1]) &lt; ABS(vm)) &amp; (ABS(uvf[0]) &lt; (1.02f * ABS(vm)))) ? uvf[1] : vm) * hybrid_fdc[0] + uvf[1] * hybrid_fdc[1];</a>
<a name="ln2131">          // combine the luma from Markesteijn with the chroma from above</a>
<a name="ln2132">          rgbpix[0] = y + 1.474600014746f * uv[1];</a>
<a name="ln2133">          rgbpix[1] = y - 0.15498578286403f * uv[0] - 0.571353132557189f * uv[1];</a>
<a name="ln2134">          rgbpix[2] = y + 1.77201282937288f * uv[0];</a>
<a name="ln2135">          for(int c = 0; c &lt; 3; c++) out[4 * (width * (row + top) + col + left) + c] = rgbpix[c];</a>
<a name="ln2136">        }</a>
<a name="ln2137">    }</a>
<a name="ln2138">  }</a>
<a name="ln2139">  dt_free_align(all_buffers);</a>
<a name="ln2140">}</a>
<a name="ln2141"> </a>
<a name="ln2142">#undef PIX_SWAP</a>
<a name="ln2143">#undef PIX_SORT</a>
<a name="ln2144">#undef CCLIP</a>
<a name="ln2145">#undef TS</a>
<a name="ln2146"> </a>
<a name="ln2147">/* taken from dcraw and demosaic_ppg below */</a>
<a name="ln2148"> </a>
<a name="ln2149">static void lin_interpolate(float *out, const float *const in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln2150">                            const dt_iop_roi_t *const roi_in, const uint32_t filters,</a>
<a name="ln2151">                            const uint8_t (*const xtrans)[6])</a>
<a name="ln2152">{</a>
<a name="ln2153">  const int colors = (filters == 9) ? 3 : 4;</a>
<a name="ln2154"> </a>
<a name="ln2155">// border interpolate</a>
<a name="ln2156">#ifdef _OPENMP</a>
<a name="ln2157">#pragma omp parallel for default(none) \</a>
<a name="ln2158">  dt_omp_firstprivate(colors, filters, in, roi_in, roi_out, xtrans) \</a>
<a name="ln2159">  shared(out) \</a>
<a name="ln2160">  schedule(static)</a>
<a name="ln2161">#endif</a>
<a name="ln2162">  for(int row = 0; row &lt; roi_out-&gt;height; row++)</a>
<a name="ln2163">    for(int col = 0; col &lt; roi_out-&gt;width; col++)</a>
<a name="ln2164">    {</a>
<a name="ln2165">      float sum[4] = { 0.0f };</a>
<a name="ln2166">      uint8_t count[4] = { 0 };</a>
<a name="ln2167">      if(col == 1 &amp;&amp; row &gt;= 1 &amp;&amp; row &lt; roi_out-&gt;height - 1) col = roi_out-&gt;width - 1;</a>
<a name="ln2168">      // average all the adjoining pixels inside image by color</a>
<a name="ln2169">      for(int y = row - 1; y != row + 2; y++)</a>
<a name="ln2170">        for(int x = col - 1; x != col + 2; x++)</a>
<a name="ln2171">          if(y &gt;= 0 &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; roi_in-&gt;height &amp;&amp; x &lt; roi_in-&gt;width)</a>
<a name="ln2172">          {</a>
<a name="ln2173">            const int f = fcol(y + roi_in-&gt;y, x + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2174">            sum[f] += in[y * roi_in-&gt;width + x];</a>
<a name="ln2175">            count[f]++;</a>
<a name="ln2176">          }</a>
<a name="ln2177">      const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2178">      // for current cell, copy the current sensor's color data,</a>
<a name="ln2179">      // interpolate the other two colors from surrounding pixels of</a>
<a name="ln2180">      // their color</a>
<a name="ln2181">      for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2182">      {</a>
<a name="ln2183">        if(c != f &amp;&amp; count[c] != 0)</a>
<a name="ln2184">          out[4 * (row * roi_out-&gt;width + col) + c] = sum[c] / count[c];</a>
<a name="ln2185">        else</a>
<a name="ln2186">          out[4 * (row * roi_out-&gt;width + col) + c] = in[row * roi_in-&gt;width + col];</a>
<a name="ln2187">      }</a>
<a name="ln2188">    }</a>
<a name="ln2189"> </a>
<a name="ln2190">  // build interpolation lookup table which for a given offset in the sensor</a>
<a name="ln2191">  // lists neighboring pixels from which to interpolate:</a>
<a name="ln2192">  // NUM_PIXELS                 # of neighboring pixels to read</a>
<a name="ln2193">  // for (1..NUM_PIXELS):</a>
<a name="ln2194">  //   OFFSET                   # in bytes from current pixel</a>
<a name="ln2195">  //   WEIGHT                   # how much weight to give this neighbor</a>
<a name="ln2196">  //   COLOR                    # sensor color</a>
<a name="ln2197">  // # weights of adjoining pixels not of this pixel's color</a>
<a name="ln2198">  // COLORA TOT_WEIGHT</a>
<a name="ln2199">  // COLORB TOT_WEIGHT</a>
<a name="ln2200">  // COLORPIX                   # color of center pixel</a>
<a name="ln2201"> </a>
<a name="ln2202">  int(*const lookup)[16][32] = malloc((size_t)16 * 16 * 32 * sizeof(int));</a>
<a name="ln2203"> </a>
<a name="ln2204">  const int size = (filters == 9) ? 6 : 16;</a>
<a name="ln2205">  for(int row = 0; row &lt; size; row++)</a>
<a name="ln2206">    for(int col = 0; col &lt; size; col++)</a>
<a name="ln2207">    {</a>
<a name="ln2208">      int *ip = lookup[row][col] + 1;</a>
<a name="ln2209">      int sum[4] = { 0 };</a>
<a name="ln2210">      const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2211">      // make list of adjoining pixel offsets by weight &amp; color</a>
<a name="ln2212">      for(int y = -1; y &lt;= 1; y++)</a>
<a name="ln2213">        for(int x = -1; x &lt;= 1; x++)</a>
<a name="ln2214">        {</a>
<a name="ln2215">          int weight = 1 &lt;&lt; ((y == 0) + (x == 0));</a>
<a name="ln2216">          const int color = fcol(row + y + roi_in-&gt;y, col + x + roi_in-&gt;x, filters, xtrans);</a>
<a name="ln2217">          if(color == f) continue;</a>
<a name="ln2218">          *ip++ = (roi_in-&gt;width * y + x);</a>
<a name="ln2219">          *ip++ = weight;</a>
<a name="ln2220">          *ip++ = color;</a>
<a name="ln2221">          sum[color] += weight;</a>
<a name="ln2222">        }</a>
<a name="ln2223">      lookup[row][col][0] = (ip - lookup[row][col]) / 3; /* # of neighboring pixels found */</a>
<a name="ln2224">      for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2225">        if(c != f)</a>
<a name="ln2226">        {</a>
<a name="ln2227">          *ip++ = c;</a>
<a name="ln2228">          *ip++ = sum[c];</a>
<a name="ln2229">        }</a>
<a name="ln2230">      *ip = f;</a>
<a name="ln2231">    }</a>
<a name="ln2232"> </a>
<a name="ln2233">#ifdef _OPENMP</a>
<a name="ln2234">#pragma omp parallel for default(none) \</a>
<a name="ln2235">  dt_omp_firstprivate(colors, in, lookup, roi_in, roi_out, size) \</a>
<a name="ln2236">  shared(out) \</a>
<a name="ln2237">  schedule(static)</a>
<a name="ln2238">#endif</a>
<a name="ln2239">  for(int row = 1; row &lt; roi_out-&gt;height - 1; row++)</a>
<a name="ln2240">  {</a>
<a name="ln2241">    float *buf = out + 4 * roi_out-&gt;width * row + 4;</a>
<a name="ln2242">    const float *buf_in = in + roi_in-&gt;width * row + 1;</a>
<a name="ln2243">    for(int col = 1; col &lt; roi_out-&gt;width - 1; col++)</a>
<a name="ln2244">    {</a>
<a name="ln2245">      float sum[4] = { 0.0f };</a>
<a name="ln2246">      int *ip = lookup[row % size][col % size];</a>
<a name="ln2247">      // for each adjoining pixel not of this pixel's color, sum up its weighted values</a>
<a name="ln2248">      for(int i = *ip++; i--; ip += 3) sum[ip[2]] += buf_in[ip[0]] * ip[1];</a>
<a name="ln2249">      // for each interpolated color, load it into the pixel</a>
<a name="ln2250">      for(int i = colors; --i; ip += 2) buf[*ip] = sum[ip[0]] / ip[1];</a>
<a name="ln2251">      buf[*ip] = *buf_in;</a>
<a name="ln2252">      buf += 4;</a>
<a name="ln2253">      buf_in++;</a>
<a name="ln2254">    }</a>
<a name="ln2255">  }</a>
<a name="ln2256"> </a>
<a name="ln2257">  free(lookup);</a>
<a name="ln2258">}</a>
<a name="ln2259"> </a>
<a name="ln2260"> </a>
<a name="ln2261">// VNG interpolate adapted from dcraw 9.20</a>
<a name="ln2262"> </a>
<a name="ln2263">/*</a>
<a name="ln2264">   This algorithm is officially called:</a>
<a name="ln2265"> </a>
<a name="ln2266">   &quot;Interpolation using a Threshold-based variable number of gradients&quot;</a>
<a name="ln2267"> </a>
<a name="ln2268">   described in http://scien.stanford.edu/pages/labsite/1999/psych221/projects/99/tingchen/algodep/vargra.html</a>
<a name="ln2269"> </a>
<a name="ln2270">   I've extended the basic idea to work with non-Bayer filter arrays.</a>
<a name="ln2271">   Gradients are numbered clockwise from NW=0 to W=7.</a>
<a name="ln2272"> */</a>
<a name="ln2273">static void vng_interpolate(float *out, const float *const in,</a>
<a name="ln2274">                            const dt_iop_roi_t *const roi_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln2275">                            const uint32_t filters, const uint8_t (*const xtrans)[6], const int only_vng_linear)</a>
<a name="ln2276">{</a>
<a name="ln2277">  static const signed char terms[]</a>
<a name="ln2278">      = { -2, -2, +0, -1, 1, 0x01, -2, -2, +0, +0, 2, 0x01, -2, -1, -1, +0, 1, 0x01, -2, -1, +0, -1, 1, 0x02,</a>
<a name="ln2279">          -2, -1, +0, +0, 1, 0x03, -2, -1, +0, +1, 2, 0x01, -2, +0, +0, -1, 1, 0x06, -2, +0, +0, +0, 2, 0x02,</a>
<a name="ln2280">          -2, +0, +0, +1, 1, 0x03, -2, +1, -1, +0, 1, 0x04, -2, +1, +0, -1, 2, 0x04, -2, +1, +0, +0, 1, 0x06,</a>
<a name="ln2281">          -2, +1, +0, +1, 1, 0x02, -2, +2, +0, +0, 2, 0x04, -2, +2, +0, +1, 1, 0x04, -1, -2, -1, +0, 1, 0x80,</a>
<a name="ln2282">          -1, -2, +0, -1, 1, 0x01, -1, -2, +1, -1, 1, 0x01, -1, -2, +1, +0, 2, 0x01, -1, -1, -1, +1, 1, 0x88,</a>
<a name="ln2283">          -1, -1, +1, -2, 1, 0x40, -1, -1, +1, -1, 1, 0x22, -1, -1, +1, +0, 1, 0x33, -1, -1, +1, +1, 2, 0x11,</a>
<a name="ln2284">          -1, +0, -1, +2, 1, 0x08, -1, +0, +0, -1, 1, 0x44, -1, +0, +0, +1, 1, 0x11, -1, +0, +1, -2, 2, 0x40,</a>
<a name="ln2285">          -1, +0, +1, -1, 1, 0x66, -1, +0, +1, +0, 2, 0x22, -1, +0, +1, +1, 1, 0x33, -1, +0, +1, +2, 2, 0x10,</a>
<a name="ln2286">          -1, +1, +1, -1, 2, 0x44, -1, +1, +1, +0, 1, 0x66, -1, +1, +1, +1, 1, 0x22, -1, +1, +1, +2, 1, 0x10,</a>
<a name="ln2287">          -1, +2, +0, +1, 1, 0x04, -1, +2, +1, +0, 2, 0x04, -1, +2, +1, +1, 1, 0x04, +0, -2, +0, +0, 2, 0x80,</a>
<a name="ln2288">          +0, -1, +0, +1, 2, 0x88, +0, -1, +1, -2, 1, 0x40, +0, -1, +1, +0, 1, 0x11, +0, -1, +2, -2, 1, 0x40,</a>
<a name="ln2289">          +0, -1, +2, -1, 1, 0x20, +0, -1, +2, +0, 1, 0x30, +0, -1, +2, +1, 2, 0x10, +0, +0, +0, +2, 2, 0x08,</a>
<a name="ln2290">          +0, +0, +2, -2, 2, 0x40, +0, +0, +2, -1, 1, 0x60, +0, +0, +2, +0, 2, 0x20, +0, +0, +2, +1, 1, 0x30,</a>
<a name="ln2291">          +0, +0, +2, +2, 2, 0x10, +0, +1, +1, +0, 1, 0x44, +0, +1, +1, +2, 1, 0x10, +0, +1, +2, -1, 2, 0x40,</a>
<a name="ln2292">          +0, +1, +2, +0, 1, 0x60, +0, +1, +2, +1, 1, 0x20, +0, +1, +2, +2, 1, 0x10, +1, -2, +1, +0, 1, 0x80,</a>
<a name="ln2293">          +1, -1, +1, +1, 1, 0x88, +1, +0, +1, +2, 1, 0x08, +1, +0, +2, -1, 1, 0x40, +1, +0, +2, +1, 1, 0x10 },</a>
<a name="ln2294">      chood[] = { -1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1 };</a>
<a name="ln2295">  int *ip, *code[16][16];</a>
<a name="ln2296">  // ring buffer pointing to three most recent rows processed (brow[3]</a>
<a name="ln2297">  // is only used for rotating the buffer</a>
<a name="ln2298">  float(*brow[4])[4];</a>
<a name="ln2299">  const int width = roi_out-&gt;width, height = roi_out-&gt;height;</a>
<a name="ln2300">  const int prow = (filters == 9) ? 6 : 8;</a>
<a name="ln2301">  const int pcol = (filters == 9) ? 6 : 2;</a>
<a name="ln2302">  const int colors = (filters == 9) ? 3 : 4;</a>
<a name="ln2303"> </a>
<a name="ln2304">  // separate out G1 and G2 in RGGB Bayer patterns</a>
<a name="ln2305">  uint32_t filters4 = filters;</a>
<a name="ln2306">  if(filters == 9 || FILTERS_ARE_4BAYER(filters)) // x-trans or CYGM/RGBE</a>
<a name="ln2307">    filters4 = filters;</a>
<a name="ln2308">  else if((filters &amp; 3) == 1)</a>
<a name="ln2309">    filters4 = filters | 0x03030303u;</a>
<a name="ln2310">  else</a>
<a name="ln2311">    filters4 = filters | 0x0c0c0c0cu;</a>
<a name="ln2312"> </a>
<a name="ln2313">  lin_interpolate(out, in, roi_out, roi_in, filters4, xtrans);</a>
<a name="ln2314"> </a>
<a name="ln2315">  // if only linear interpolation is requested we can stop it here</a>
<a name="ln2316">  if(only_vng_linear) return;</a>
<a name="ln2317"> </a>
<a name="ln2318">  char *buffer</a>
<a name="ln2319">      = (char *)dt_alloc_align(64, (size_t)sizeof(**brow) * width * 3 + sizeof(*ip) * prow * pcol * 320);</a>
<a name="ln2320">  if(!buffer)</a>
<a name="ln2321">  {</a>
<a name="ln2322">    fprintf(stderr, &quot;[demosaic] not able to allocate VNG buffer\n&quot;);</a>
<a name="ln2323">    return;</a>
<a name="ln2324">  }</a>
<a name="ln2325">  for(int row = 0; row &lt; 3; row++) brow[row] = (float(*)[4])buffer + row * width;</a>
<a name="ln2326">  ip = (int *)(buffer + (size_t)sizeof(**brow) * width * 3);</a>
<a name="ln2327"> </a>
<a name="ln2328">  for(int row = 0; row &lt; prow; row++) /* Precalculate for VNG */</a>
<a name="ln2329">    for(int col = 0; col &lt; pcol; col++)</a>
<a name="ln2330">    {</a>
<a name="ln2331">      code[row][col] = ip;</a>
<a name="ln2332">      const signed char *cp = terms;</a>
<a name="ln2333">      for(int t = 0; t &lt; 64; t++)</a>
<a name="ln2334">      {</a>
<a name="ln2335">        int y1 = *cp++, x1 = *cp++;</a>
<a name="ln2336">        int y2 = *cp++, x2 = *cp++;</a>
<a name="ln2337">        int weight = *cp++;</a>
<a name="ln2338">        int grads = *cp++;</a>
<a name="ln2339">        int color = fcol(row + y1, col + x1, filters4, xtrans);</a>
<a name="ln2340">        if(fcol(row + y2, col + x2, filters4, xtrans) != color) continue;</a>
<a name="ln2341">        int diag</a>
<a name="ln2342">            = (fcol(row, col + 1, filters4, xtrans) == color &amp;&amp; fcol(row + 1, col, filters4, xtrans) == color)</a>
<a name="ln2343">                  ? 2</a>
<a name="ln2344">                  : 1;</a>
<a name="ln2345">        if(abs(y1 - y2) == diag &amp;&amp; abs(x1 - x2) == diag) continue;</a>
<a name="ln2346">        *ip++ = (y1 * width + x1) * 4 + color;</a>
<a name="ln2347">        *ip++ = (y2 * width + x2) * 4 + color;</a>
<a name="ln2348">        *ip++ = weight;</a>
<a name="ln2349">        for(int g = 0; g &lt; 8; g++)</a>
<a name="ln2350">          if(grads &amp; 1 &lt;&lt; g) *ip++ = g;</a>
<a name="ln2351">        *ip++ = -1;</a>
<a name="ln2352">      }</a>
<a name="ln2353">      *ip++ = INT_MAX;</a>
<a name="ln2354">      cp = chood;</a>
<a name="ln2355">      for(int g = 0; g &lt; 8; g++)</a>
<a name="ln2356">      {</a>
<a name="ln2357">        int y = *cp++, x = *cp++;</a>
<a name="ln2358">        *ip++ = (y * width + x) * 4;</a>
<a name="ln2359">        int color = fcol(row, col, filters4, xtrans);</a>
<a name="ln2360">        if(fcol(row + y, col + x, filters4, xtrans) != color</a>
<a name="ln2361">           &amp;&amp; fcol(row + y * 2, col + x * 2, filters4, xtrans) == color)</a>
<a name="ln2362">          *ip++ = (y * width + x) * 8 + color;</a>
<a name="ln2363">        else</a>
<a name="ln2364">          *ip++ = 0;</a>
<a name="ln2365">      }</a>
<a name="ln2366">    }</a>
<a name="ln2367"> </a>
<a name="ln2368">  for(int row = 2; row &lt; height - 2; row++) /* Do VNG interpolation */</a>
<a name="ln2369">  {</a>
<a name="ln2370">#ifdef _OPENMP</a>
<a name="ln2371">#pragma omp parallel for default(none) \</a>
<a name="ln2372">    dt_omp_firstprivate(colors, pcol, prow, roi_in, width, xtrans) \</a>
<a name="ln2373">    shared(row, code, brow, out, filters4) \</a>
<a name="ln2374">    private(ip) \</a>
<a name="ln2375">    schedule(static)</a>
<a name="ln2376">#endif</a>
<a name="ln2377">    for(int col = 2; col &lt; width - 2; col++)</a>
<a name="ln2378">    {</a>
<a name="ln2379">      int g;</a>
<a name="ln2380">      float gval[8] = { 0.0f };</a>
<a name="ln2381">      float *pix = out + 4 * (row * width + col);</a>
<a name="ln2382">      ip = code[(row + roi_in-&gt;y) % prow][(col + roi_in-&gt;x) % pcol];</a>
<a name="ln2383">      while((g = ip[0]) != INT_MAX) /* Calculate gradients */</a>
<a name="ln2384">      {</a>
<a name="ln2385">        float diff = fabsf(pix[g] - pix[ip[1]]) * ip[2];</a>
<a name="ln2386">        gval[ip[3]] += diff;</a>
<a name="ln2387">        ip += 5;</a>
<a name="ln2388">        if((g = ip[-1]) == -1) continue;</a>
<a name="ln2389">        gval[g] += diff;</a>
<a name="ln2390">        while((g = *ip++) != -1) gval[g] += diff;</a>
<a name="ln2391">      }</a>
<a name="ln2392">      ip++;</a>
<a name="ln2393">      float gmin = gval[0], gmax = gval[0]; /* Choose a threshold */</a>
<a name="ln2394">      for(g = 1; g &lt; 8; g++)</a>
<a name="ln2395">      {</a>
<a name="ln2396">        if(gmin &gt; gval[g]) gmin = gval[g];</a>
<a name="ln2397">        if(gmax &lt; gval[g]) gmax = gval[g];</a>
<a name="ln2398">      }</a>
<a name="ln2399">      if(gmax == 0)</a>
<a name="ln2400">      {</a>
<a name="ln2401">        memcpy(brow[2][col], pix, (size_t)4 * sizeof(*out));</a>
<a name="ln2402">        continue;</a>
<a name="ln2403">      }</a>
<a name="ln2404">      float thold = gmin + (gmax * 0.5f);</a>
<a name="ln2405">      float sum[4] = { 0.0f };</a>
<a name="ln2406">      int color = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln2407">      int num = 0;</a>
<a name="ln2408">      for(g = 0; g &lt; 8; g++, ip += 2) /* Average the neighbors */</a>
<a name="ln2409">      {</a>
<a name="ln2410">        if(gval[g] &lt;= thold)</a>
<a name="ln2411">        {</a>
<a name="ln2412">          for(int c = 0; c &lt; colors; c++)</a>
<a name="ln2413">            if(c == color &amp;&amp; ip[1])</a>
<a name="ln2414">              sum[c] += (pix[c] + pix[ip[1]]) * 0.5f;</a>
<a name="ln2415">            else</a>
<a name="ln2416">              sum[c] += pix[ip[0] + c];</a>
<a name="ln2417">          num++;</a>
<a name="ln2418">        }</a>
<a name="ln2419">      }</a>
<a name="ln2420">      for(int c = 0; c &lt; colors; c++) /* Save to buffer */</a>
<a name="ln2421">      {</a>
<a name="ln2422">        float tot = pix[color];</a>
<a name="ln2423">        if(c != color) tot += (sum[c] - sum[color]) / num;</a>
<a name="ln2424">        brow[2][col][c] = tot;</a>
<a name="ln2425">      }</a>
<a name="ln2426">    }</a>
<a name="ln2427">    if(row &gt; 3) /* Write buffer to image */</a>
<a name="ln2428">      memcpy(out + 4 * ((row - 2) * width + 2), brow[0] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2429">    // rotate ring buffer</a>
<a name="ln2430">    for(int g = 0; g &lt; 4; g++) brow[(g - 1) &amp; 3] = brow[g];</a>
<a name="ln2431">  }</a>
<a name="ln2432">  // copy the final two rows to the image</a>
<a name="ln2433">  memcpy(out + (4 * ((height - 4) * width + 2)), brow[0] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2434">  memcpy(out + (4 * ((height - 3) * width + 2)), brow[1] + 2, (size_t)(width - 4) * 4 * sizeof(*out));</a>
<a name="ln2435">  dt_free_align(buffer);</a>
<a name="ln2436"> </a>
<a name="ln2437">  if(filters != 9 &amp;&amp; !FILTERS_ARE_4BAYER(filters)) // x-trans or CYGM/RGBE</a>
<a name="ln2438">// for Bayer mix the two greens to make VNG4</a>
<a name="ln2439">#ifdef _OPENMP</a>
<a name="ln2440">#pragma omp parallel for default(none) \</a>
<a name="ln2441">    dt_omp_firstprivate(height, width) \</a>
<a name="ln2442">    shared(out) \</a>
<a name="ln2443">    schedule(static)</a>
<a name="ln2444">#endif</a>
<a name="ln2445">    for(int i = 0; i &lt; height * width; i++) out[i * 4 + 1] = (out[i * 4 + 1] + out[i * 4 + 3]) / 2.0f;</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448">/** 1:1 demosaic from in to out, in is full buf, out is translated/cropped (scale == 1.0!) */</a>
<a name="ln2449">static void passthrough_monochrome(float *out, const float *const in, dt_iop_roi_t *const roi_out,</a>
<a name="ln2450">                                   const dt_iop_roi_t *const roi_in)</a>
<a name="ln2451">{</a>
<a name="ln2452">  // we never want to access the input out of bounds though:</a>
<a name="ln2453">  assert(roi_in-&gt;width &gt;= roi_out-&gt;width);</a>
<a name="ln2454">  assert(roi_in-&gt;height &gt;= roi_out-&gt;height);</a>
<a name="ln2455"> </a>
<a name="ln2456">#ifdef _OPENMP</a>
<a name="ln2457">#pragma omp parallel for default(none) \</a>
<a name="ln2458">  dt_omp_firstprivate(in, roi_out, roi_in) \</a>
<a name="ln2459">  shared(out) \</a>
<a name="ln2460">  schedule(static)</a>
<a name="ln2461">#endif</a>
<a name="ln2462">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2463">  {</a>
<a name="ln2464">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2465">    {</a>
<a name="ln2466">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2467">      {</a>
<a name="ln2468">        out[(size_t)4 * ((size_t)j * roi_out-&gt;width + i) + c]</a>
<a name="ln2469">            = in[(size_t)((size_t)j + roi_out-&gt;y) * roi_in-&gt;width + i + roi_out-&gt;x];</a>
<a name="ln2470">      }</a>
<a name="ln2471">    }</a>
<a name="ln2472">  }</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475">/** 1:1 demosaic from in to out, in is full buf, out is translated/cropped (scale == 1.0!) */</a>
<a name="ln2476">static void demosaic_ppg(float *const out, const float *const in, const dt_iop_roi_t *const roi_out,</a>
<a name="ln2477">                         const dt_iop_roi_t *const roi_in, const uint32_t filters, const float thrs)</a>
<a name="ln2478">{</a>
<a name="ln2479">  // offsets only where the buffer ends:</a>
<a name="ln2480">  const int offx = 3; // MAX(0, 3 - roi_out-&gt;x);</a>
<a name="ln2481">  const int offy = 3; // MAX(0, 3 - roi_out-&gt;y);</a>
<a name="ln2482">  const int offX = 3; // MAX(0, 3 - (roi_in-&gt;width  - (roi_out-&gt;x + roi_out-&gt;width)));</a>
<a name="ln2483">  const int offY = 3; // MAX(0, 3 - (roi_in-&gt;height - (roi_out-&gt;y + roi_out-&gt;height)));</a>
<a name="ln2484"> </a>
<a name="ln2485">  // these may differ a little, if you're unlucky enough to split a bayer block with cropping or similar.</a>
<a name="ln2486">  // we never want to access the input out of bounds though:</a>
<a name="ln2487">  assert(roi_in-&gt;width &gt;= roi_out-&gt;width);</a>
<a name="ln2488">  assert(roi_in-&gt;height &gt;= roi_out-&gt;height);</a>
<a name="ln2489">  // border interpolate</a>
<a name="ln2490">  float sum[8];</a>
<a name="ln2491">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2492">    for(int i = 0; i &lt; roi_out-&gt;width; i++)</a>
<a name="ln2493">    {</a>
<a name="ln2494">      if(i == offx &amp;&amp; j &gt;= offy &amp;&amp; j &lt; roi_out-&gt;height - offY) i = roi_out-&gt;width - offX;</a>
<a name="ln2495">      if(i == roi_out-&gt;width) break;</a>
<a name="ln2496">      memset(sum, 0, sizeof(float) * 8);</a>
<a name="ln2497">      for(int y = j - 1; y != j + 2; y++)</a>
<a name="ln2498">        for(int x = i - 1; x != i + 2; x++)</a>
<a name="ln2499">        {</a>
<a name="ln2500">          const int yy = y + roi_out-&gt;y, xx = x + roi_out-&gt;x;</a>
<a name="ln2501">          if(yy &gt;= 0 &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; roi_in-&gt;height &amp;&amp; xx &lt; roi_in-&gt;width)</a>
<a name="ln2502">          {</a>
<a name="ln2503">            int f = FC(y, x, filters);</a>
<a name="ln2504">            sum[f] += in[(size_t)yy * roi_in-&gt;width + xx];</a>
<a name="ln2505">            sum[f + 4]++;</a>
<a name="ln2506">          }</a>
<a name="ln2507">        }</a>
<a name="ln2508">      int f = FC(j, i, filters);</a>
<a name="ln2509">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln2510">      {</a>
<a name="ln2511">        if(c != f &amp;&amp; sum[c + 4] &gt; 0.0f)</a>
<a name="ln2512">          out[4 * ((size_t)j * roi_out-&gt;width + i) + c] = sum[c] / sum[c + 4];</a>
<a name="ln2513">        else</a>
<a name="ln2514">          out[4 * ((size_t)j * roi_out-&gt;width + i) + c]</a>
<a name="ln2515">              = in[((size_t)j + roi_out-&gt;y) * roi_in-&gt;width + i + roi_out-&gt;x];</a>
<a name="ln2516">      }</a>
<a name="ln2517">    }</a>
<a name="ln2518">  const int median = thrs &gt; 0.0f;</a>
<a name="ln2519">  // if(median) fbdd_green(out, in, roi_out, roi_in, filters);</a>
<a name="ln2520">  const float *input = in;</a>
<a name="ln2521">  if(median)</a>
<a name="ln2522">  {</a>
<a name="ln2523">    float *med_in = (float *)dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2524">    pre_median(med_in, in, roi_in, filters, 1, thrs);</a>
<a name="ln2525">    input = med_in;</a>
<a name="ln2526">  }</a>
<a name="ln2527">// for all pixels: interpolate green into float array, or copy color.</a>
<a name="ln2528">#ifdef _OPENMP</a>
<a name="ln2529">#pragma omp parallel for default(none) \</a>
<a name="ln2530">  dt_omp_firstprivate(filters, out, roi_in, roi_out, offx, offy, offX, offY) \</a>
<a name="ln2531">  shared(input) \</a>
<a name="ln2532">  schedule(static)</a>
<a name="ln2533">#endif</a>
<a name="ln2534">  for(int j = offy; j &lt; roi_out-&gt;height - offY; j++)</a>
<a name="ln2535">  {</a>
<a name="ln2536">    float *buf = out + (size_t)4 * roi_out-&gt;width * j + 4 * offx;</a>
<a name="ln2537">    const float *buf_in = input + (size_t)roi_in-&gt;width * (j + roi_out-&gt;y) + offx + roi_out-&gt;x;</a>
<a name="ln2538">    for(int i = offx; i &lt; roi_out-&gt;width - offX; i++)</a>
<a name="ln2539">    {</a>
<a name="ln2540">      const int c = FC(j, i, filters);</a>
<a name="ln2541">#if defined(__SSE__)</a>
<a name="ln2542">      // prefetch what we need soon (load to cpu caches)</a>
<a name="ln2543">      _mm_prefetch((char *)buf_in + 256, _MM_HINT_NTA); // TODO: try HINT_T0-3</a>
<a name="ln2544">      _mm_prefetch((char *)buf_in + roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2545">      _mm_prefetch((char *)buf_in + 2 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2546">      _mm_prefetch((char *)buf_in + 3 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2547">      _mm_prefetch((char *)buf_in - roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2548">      _mm_prefetch((char *)buf_in - 2 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2549">      _mm_prefetch((char *)buf_in - 3 * roi_in-&gt;width + 256, _MM_HINT_NTA);</a>
<a name="ln2550">#endif</a>
<a name="ln2551"> </a>
<a name="ln2552">#if defined(__SSE__)</a>
<a name="ln2553">      __m128 col = _mm_load_ps(buf);</a>
<a name="ln2554">      float *color = (float *)&amp;col;</a>
<a name="ln2555">#else</a>
<a name="ln2556">      float color[4] = { buf[0], buf[1], buf[2], buf[3] };</a>
<a name="ln2557">#endif</a>
<a name="ln2558">      const float pc = buf_in[0];</a>
<a name="ln2559">      // if(__builtin_expect(c == 0 || c == 2, 1))</a>
<a name="ln2560">      if(c == 0 || c == 2)</a>
<a name="ln2561">      {</a>
<a name="ln2562">        color[c] = pc;</a>
<a name="ln2563">        // get stuff (hopefully from cache)</a>
<a name="ln2564">        const float pym = buf_in[-roi_in-&gt;width * 1];</a>
<a name="ln2565">        const float pym2 = buf_in[-roi_in-&gt;width * 2];</a>
<a name="ln2566">        const float pym3 = buf_in[-roi_in-&gt;width * 3];</a>
<a name="ln2567">        const float pyM = buf_in[+roi_in-&gt;width * 1];</a>
<a name="ln2568">        const float pyM2 = buf_in[+roi_in-&gt;width * 2];</a>
<a name="ln2569">        const float pyM3 = buf_in[+roi_in-&gt;width * 3];</a>
<a name="ln2570">        const float pxm = buf_in[-1];</a>
<a name="ln2571">        const float pxm2 = buf_in[-2];</a>
<a name="ln2572">        const float pxm3 = buf_in[-3];</a>
<a name="ln2573">        const float pxM = buf_in[+1];</a>
<a name="ln2574">        const float pxM2 = buf_in[+2];</a>
<a name="ln2575">        const float pxM3 = buf_in[+3];</a>
<a name="ln2576"> </a>
<a name="ln2577">        const float guessx = (pxm + pc + pxM) * 2.0f - pxM2 - pxm2;</a>
<a name="ln2578">        const float diffx = (fabsf(pxm2 - pc) + fabsf(pxM2 - pc) + fabsf(pxm - pxM)) * 3.0f</a>
<a name="ln2579">                            + (fabsf(pxM3 - pxM) + fabsf(pxm3 - pxm)) * 2.0f;</a>
<a name="ln2580">        const float guessy = (pym + pc + pyM) * 2.0f - pyM2 - pym2;</a>
<a name="ln2581">        const float diffy = (fabsf(pym2 - pc) + fabsf(pyM2 - pc) + fabsf(pym - pyM)) * 3.0f</a>
<a name="ln2582">                            + (fabsf(pyM3 - pyM) + fabsf(pym3 - pym)) * 2.0f;</a>
<a name="ln2583">        if(diffx &gt; diffy)</a>
<a name="ln2584">        {</a>
<a name="ln2585">          // use guessy</a>
<a name="ln2586">          const float m = fminf(pym, pyM);</a>
<a name="ln2587">          const float M = fmaxf(pym, pyM);</a>
<a name="ln2588">          color[1] = fmaxf(fminf(guessy * .25f, M), m);</a>
<a name="ln2589">        }</a>
<a name="ln2590">        else</a>
<a name="ln2591">        {</a>
<a name="ln2592">          const float m = fminf(pxm, pxM);</a>
<a name="ln2593">          const float M = fmaxf(pxm, pxM);</a>
<a name="ln2594">          color[1] = fmaxf(fminf(guessx * .25f, M), m);</a>
<a name="ln2595">        }</a>
<a name="ln2596">      }</a>
<a name="ln2597">      else</a>
<a name="ln2598">        color[1] = pc;</a>
<a name="ln2599"> </a>
<a name="ln2600">      // write using MOVNTPS (write combine omitting caches)</a>
<a name="ln2601">      // _mm_stream_ps(buf, col);</a>
<a name="ln2602">      memcpy(buf, color, 4 * sizeof(float));</a>
<a name="ln2603">      buf += 4;</a>
<a name="ln2604">      buf_in++;</a>
<a name="ln2605">    }</a>
<a name="ln2606">  }</a>
<a name="ln2607">// SFENCE (make sure stuff is stored now)</a>
<a name="ln2608">// _mm_sfence();</a>
<a name="ln2609"> </a>
<a name="ln2610">// for all pixels: interpolate colors into float array</a>
<a name="ln2611">#ifdef _OPENMP</a>
<a name="ln2612">#pragma omp parallel for default(none) \</a>
<a name="ln2613">  dt_omp_firstprivate(filters, out, roi_out) \</a>
<a name="ln2614">  schedule(static)</a>
<a name="ln2615">#endif</a>
<a name="ln2616">  for(int j = 1; j &lt; roi_out-&gt;height - 1; j++)</a>
<a name="ln2617">  {</a>
<a name="ln2618">    float *buf = out + (size_t)4 * roi_out-&gt;width * j + 4;</a>
<a name="ln2619">    for(int i = 1; i &lt; roi_out-&gt;width - 1; i++)</a>
<a name="ln2620">    {</a>
<a name="ln2621">      // also prefetch direct nbs top/bottom</a>
<a name="ln2622">#if defined(__SSE__)</a>
<a name="ln2623">      _mm_prefetch((char *)buf + 256, _MM_HINT_NTA);</a>
<a name="ln2624">      _mm_prefetch((char *)buf - roi_out-&gt;width * 4 * sizeof(float) + 256, _MM_HINT_NTA);</a>
<a name="ln2625">      _mm_prefetch((char *)buf + roi_out-&gt;width * 4 * sizeof(float) + 256, _MM_HINT_NTA);</a>
<a name="ln2626">#endif</a>
<a name="ln2627"> </a>
<a name="ln2628">      const int c = FC(j, i, filters);</a>
<a name="ln2629">#if defined(__SSE__)</a>
<a name="ln2630">      __m128 col = _mm_load_ps(buf);</a>
<a name="ln2631">      float *color = (float *)&amp;col;</a>
<a name="ln2632">#else</a>
<a name="ln2633">      float color[4] = { buf[0], buf[1], buf[2], buf[3] };</a>
<a name="ln2634">#endif</a>
<a name="ln2635">      // fill all four pixels with correctly interpolated stuff: r/b for green1/2</a>
<a name="ln2636">      // b for r and r for b</a>
<a name="ln2637">      if(__builtin_expect(c &amp; 1, 1)) // c == 1 || c == 3)</a>
<a name="ln2638">      {</a>
<a name="ln2639">        // calculate red and blue for green pixels:</a>
<a name="ln2640">        // need 4-nbhood:</a>
<a name="ln2641">        const float *nt = buf - 4 * roi_out-&gt;width;</a>
<a name="ln2642">        const float *nb = buf + 4 * roi_out-&gt;width;</a>
<a name="ln2643">        const float *nl = buf - 4;</a>
<a name="ln2644">        const float *nr = buf + 4;</a>
<a name="ln2645">        if(FC(j, i + 1, filters) == 0) // red nb in same row</a>
<a name="ln2646">        {</a>
<a name="ln2647">          color[2] = (nt[2] + nb[2] + 2.0f * color[1] - nt[1] - nb[1]) * .5f;</a>
<a name="ln2648">          color[0] = (nl[0] + nr[0] + 2.0f * color[1] - nl[1] - nr[1]) * .5f;</a>
<a name="ln2649">        }</a>
<a name="ln2650">        else</a>
<a name="ln2651">        {</a>
<a name="ln2652">          // blue nb</a>
<a name="ln2653">          color[0] = (nt[0] + nb[0] + 2.0f * color[1] - nt[1] - nb[1]) * .5f;</a>
<a name="ln2654">          color[2] = (nl[2] + nr[2] + 2.0f * color[1] - nl[1] - nr[1]) * .5f;</a>
<a name="ln2655">        }</a>
<a name="ln2656">      }</a>
<a name="ln2657">      else</a>
<a name="ln2658">      {</a>
<a name="ln2659">        // get 4-star-nbhood:</a>
<a name="ln2660">        const float *ntl = buf - 4 - 4 * roi_out-&gt;width;</a>
<a name="ln2661">        const float *ntr = buf + 4 - 4 * roi_out-&gt;width;</a>
<a name="ln2662">        const float *nbl = buf - 4 + 4 * roi_out-&gt;width;</a>
<a name="ln2663">        const float *nbr = buf + 4 + 4 * roi_out-&gt;width;</a>
<a name="ln2664"> </a>
<a name="ln2665">        if(c == 0)</a>
<a name="ln2666">        {</a>
<a name="ln2667">          // red pixel, fill blue:</a>
<a name="ln2668">          const float diff1 = fabsf(ntl[2] - nbr[2]) + fabsf(ntl[1] - color[1]) + fabsf(nbr[1] - color[1]);</a>
<a name="ln2669">          const float guess1 = ntl[2] + nbr[2] + 2.0f * color[1] - ntl[1] - nbr[1];</a>
<a name="ln2670">          const float diff2 = fabsf(ntr[2] - nbl[2]) + fabsf(ntr[1] - color[1]) + fabsf(nbl[1] - color[1]);</a>
<a name="ln2671">          const float guess2 = ntr[2] + nbl[2] + 2.0f * color[1] - ntr[1] - nbl[1];</a>
<a name="ln2672">          if(diff1 &gt; diff2)</a>
<a name="ln2673">            color[2] = guess2 * .5f;</a>
<a name="ln2674">          else if(diff1 &lt; diff2)</a>
<a name="ln2675">            color[2] = guess1 * .5f;</a>
<a name="ln2676">          else</a>
<a name="ln2677">            color[2] = (guess1 + guess2) * .25f;</a>
<a name="ln2678">        }</a>
<a name="ln2679">        else // c == 2, blue pixel, fill red:</a>
<a name="ln2680">        {</a>
<a name="ln2681">          const float diff1 = fabsf(ntl[0] - nbr[0]) + fabsf(ntl[1] - color[1]) + fabsf(nbr[1] - color[1]);</a>
<a name="ln2682">          const float guess1 = ntl[0] + nbr[0] + 2.0f * color[1] - ntl[1] - nbr[1];</a>
<a name="ln2683">          const float diff2 = fabsf(ntr[0] - nbl[0]) + fabsf(ntr[1] - color[1]) + fabsf(nbl[1] - color[1]);</a>
<a name="ln2684">          const float guess2 = ntr[0] + nbl[0] + 2.0f * color[1] - ntr[1] - nbl[1];</a>
<a name="ln2685">          if(diff1 &gt; diff2)</a>
<a name="ln2686">            color[0] = guess2 * .5f;</a>
<a name="ln2687">          else if(diff1 &lt; diff2)</a>
<a name="ln2688">            color[0] = guess1 * .5f;</a>
<a name="ln2689">          else</a>
<a name="ln2690">            color[0] = (guess1 + guess2) * .25f;</a>
<a name="ln2691">        }</a>
<a name="ln2692">      }</a>
<a name="ln2693">      // _mm_stream_ps(buf, col);</a>
<a name="ln2694">      memcpy(buf, color, 4 * sizeof(float));</a>
<a name="ln2695">      buf += 4;</a>
<a name="ln2696">    }</a>
<a name="ln2697">  }</a>
<a name="ln2698">  // _mm_sfence();</a>
<a name="ln2699">  if(median) dt_free_align((float *)input);</a>
<a name="ln2700">}</a>
<a name="ln2701"> </a>
<a name="ln2702">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln2703">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2704">{</a>
<a name="ln2705">  const struct dt_interpolation *itor = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln2706">  dt_interpolation_resample_roi_1c(itor, out, roi_out, roi_out-&gt;width * sizeof(float), in, roi_in,</a>
<a name="ln2707">                                   roi_in-&gt;width * sizeof(float));</a>
<a name="ln2708">}</a>
<a name="ln2709"> </a>
<a name="ln2710">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln2711">                    const dt_iop_roi_t *const roi_in)</a>
<a name="ln2712">{</a>
<a name="ln2713">  *roi_out = *roi_in;</a>
<a name="ln2714"> </a>
<a name="ln2715">  // snap to start of mosaic block:</a>
<a name="ln2716">  roi_out-&gt;x = 0; // MAX(0, roi_out-&gt;x &amp; ~1);</a>
<a name="ln2717">  roi_out-&gt;y = 0; // MAX(0, roi_out-&gt;y &amp; ~1);</a>
<a name="ln2718">}</a>
<a name="ln2719"> </a>
<a name="ln2720">// which roi input is needed to process to this output?</a>
<a name="ln2721">// roi_out is unchanged, full buffer in is full buffer out.</a>
<a name="ln2722">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln2723">                   const dt_iop_roi_t *roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln2724">{</a>
<a name="ln2725">  // this op is disabled for preview pipe/filters == 0</a>
<a name="ln2726"> </a>
<a name="ln2727">  *roi_in = *roi_out;</a>
<a name="ln2728">  // need 1:1, demosaic and then sub-sample. or directly sample half-size</a>
<a name="ln2729">  roi_in-&gt;x /= roi_out-&gt;scale;</a>
<a name="ln2730">  roi_in-&gt;y /= roi_out-&gt;scale;</a>
<a name="ln2731">  roi_in-&gt;width /= roi_out-&gt;scale;</a>
<a name="ln2732">  roi_in-&gt;height /= roi_out-&gt;scale;</a>
<a name="ln2733">  roi_in-&gt;scale = 1.0f;</a>
<a name="ln2734">  // clamp to even x/y, to make demosaic pattern still hold..</a>
<a name="ln2735">  if(piece-&gt;pipe-&gt;dsc.filters != 9u)</a>
<a name="ln2736">  {</a>
<a name="ln2737">    roi_in-&gt;x = MAX(0, roi_in-&gt;x &amp; ~1);</a>
<a name="ln2738">    roi_in-&gt;y = MAX(0, roi_in-&gt;y &amp; ~1);</a>
<a name="ln2739">  }</a>
<a name="ln2740">  else</a>
<a name="ln2741">  {</a>
<a name="ln2742">    // Markesteijn needs factors of 3</a>
<a name="ln2743">    roi_in-&gt;x = MAX(0, roi_in-&gt;x - (roi_in-&gt;x % 3));</a>
<a name="ln2744">    roi_in-&gt;y = MAX(0, roi_in-&gt;y - (roi_in-&gt;y % 3));</a>
<a name="ln2745">  }</a>
<a name="ln2746"> </a>
<a name="ln2747">  // clamp numeric inaccuracies to full buffer, to avoid scaling/copying in pixelpipe:</a>
<a name="ln2748">  if(abs(piece-&gt;pipe-&gt;image.width - roi_in-&gt;width) &lt; MAX(ceilf(1.0f / roi_out-&gt;scale), 10))</a>
<a name="ln2749">    roi_in-&gt;width = piece-&gt;pipe-&gt;image.width;</a>
<a name="ln2750"> </a>
<a name="ln2751">  if(abs(piece-&gt;pipe-&gt;image.height - roi_in-&gt;height) &lt; MAX(ceilf(1.0f / roi_out-&gt;scale), 10))</a>
<a name="ln2752">    roi_in-&gt;height = piece-&gt;pipe-&gt;image.height;</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755">static int get_quality()</a>
<a name="ln2756">{</a>
<a name="ln2757">  int qual = 1;</a>
<a name="ln2758">  gchar *quality = dt_conf_get_string(&quot;plugins/darkroom/demosaic/quality&quot;);</a>
<a name="ln2759">  if(quality)</a>
<a name="ln2760">  {</a>
<a name="ln2761">    if(!strcmp(quality, &quot;always bilinear (fast)&quot;))</a>
<a name="ln2762">      qual = 0;</a>
<a name="ln2763">    else if(!strcmp(quality, &quot;full (possibly slow)&quot;))</a>
<a name="ln2764">      qual = 2;</a>
<a name="ln2765">    g_free(quality);</a>
<a name="ln2766">  }</a>
<a name="ln2767">  return qual;</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770">static int get_thumb_quality(int width, int height)</a>
<a name="ln2771">{</a>
<a name="ln2772">  // we check if we need ultra-high quality thumbnail for this size</a>
<a name="ln2773">  char *min = dt_conf_get_string(&quot;plugins/lighttable/thumbnail_hq_min_level&quot;);</a>
<a name="ln2774"> </a>
<a name="ln2775">  int level = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, width, height);</a>
<a name="ln2776">  int res = 0;</a>
<a name="ln2777">  if (strcmp(min, &quot;always&quot;)==0) res = 1;</a>
<a name="ln2778">  else if (strcmp(min, &quot;small&quot;)==0) res = ( level &gt;= 1 );</a>
<a name="ln2779">  else if (strcmp(min, &quot;VGA&quot;)==0) res = ( level &gt;= 2 );</a>
<a name="ln2780">  else if (strcmp(min, &quot;720p&quot;)==0) res = ( level &gt;= 3 );</a>
<a name="ln2781">  else if (strcmp(min, &quot;1080p&quot;)==0) res = ( level &gt;= 4 );</a>
<a name="ln2782">  else if (strcmp(min, &quot;WQXGA&quot;)==0) res = ( level &gt;= 5 );</a>
<a name="ln2783">  else if (strcmp(min, &quot;4k&quot;)==0) res = ( level &gt;= 6 );</a>
<a name="ln2784">  else if (strcmp(min, &quot;5K&quot;)==0) res = ( level &gt;= 7 );</a>
<a name="ln2785"> </a>
<a name="ln2786">  g_free(min);</a>
<a name="ln2787">  return res;</a>
<a name="ln2788">}</a>
<a name="ln2789"> </a>
<a name="ln2790">// set flags for demosaic quality based on factors besides demosaic</a>
<a name="ln2791">// method (e.g. config, scale, pixelpipe type)</a>
<a name="ln2792">static int demosaic_qual_flags(const dt_dev_pixelpipe_iop_t *const piece,</a>
<a name="ln2793">                               const dt_image_t *const img,</a>
<a name="ln2794">                               const dt_iop_roi_t *const roi_out)</a>
<a name="ln2795">{</a>
<a name="ln2796">  int flags = 0;</a>
<a name="ln2797">  switch (piece-&gt;pipe-&gt;type)</a>
<a name="ln2798">  {</a>
<a name="ln2799">    case DT_DEV_PIXELPIPE_FULL:</a>
<a name="ln2800">    case DT_DEV_PIXELPIPE_PREVIEW2:</a>
<a name="ln2801">      {</a>
<a name="ln2802">        const int qual = get_quality();</a>
<a name="ln2803">        if (qual &gt; 0) flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2804">        if (qual &gt; 1) flags |= DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2805">        if ((qual &lt; 2) &amp;&amp; (roi_out-&gt;scale &lt;= .99999f))</a>
<a name="ln2806">          flags |= DEMOSAIC_MEDIUM_QUAL;</a>
<a name="ln2807">      }</a>
<a name="ln2808">      break;</a>
<a name="ln2809">    case DT_DEV_PIXELPIPE_EXPORT:</a>
<a name="ln2810">      flags |= DEMOSAIC_FULL_SCALE | DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2811">      break;</a>
<a name="ln2812">    case DT_DEV_PIXELPIPE_THUMBNAIL:</a>
<a name="ln2813">      // we check if we need ultra-high quality thumbnail for this size</a>
<a name="ln2814">      if (get_thumb_quality(roi_out-&gt;width, roi_out-&gt;height))</a>
<a name="ln2815">      {</a>
<a name="ln2816">        flags |= DEMOSAIC_FULL_SCALE | DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2817">      }</a>
<a name="ln2818">      break;</a>
<a name="ln2819">    default: // make C not complain about missing enum members</a>
<a name="ln2820">      break;</a>
<a name="ln2821">  }</a>
<a name="ln2822"> </a>
<a name="ln2823">  // For sufficiently small scaling, one or more repetitition of the</a>
<a name="ln2824">  // CFA pattern can be merged into a single pixel, hence it is</a>
<a name="ln2825">  // possible to skip the full demosaic and perform a quick downscale.</a>
<a name="ln2826">  // Note even though the X-Trans CFA is 6x6, for this purposes we can</a>
<a name="ln2827">  // see each 6x6 tile as four fairly similar 3x3 tiles</a>
<a name="ln2828">  if (roi_out-&gt;scale &gt; (piece-&gt;pipe-&gt;dsc.filters == 9u ? 0.333f : 0.5f))</a>
<a name="ln2829">  {</a>
<a name="ln2830">    flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2831">  }</a>
<a name="ln2832">  // half_size_f doesn't support 4bayer images</a>
<a name="ln2833">  if (img-&gt;flags &amp; DT_IMAGE_4BAYER) flags |= DEMOSAIC_FULL_SCALE;</a>
<a name="ln2834">  // we use full Markesteijn demosaicing on xtrans sensors if maximum</a>
<a name="ln2835">  // quality is required</a>
<a name="ln2836">  if (roi_out-&gt;scale &gt; 0.667f)</a>
<a name="ln2837">  {</a>
<a name="ln2838">    flags |= DEMOSAIC_XTRANS_FULL;</a>
<a name="ln2839">  }</a>
<a name="ln2840"> </a>
<a name="ln2841">  // we check if we can stop at the linear interpolation step in VNG</a>
<a name="ln2842">  // instead of going the full way</a>
<a name="ln2843">  if ((flags &amp; DEMOSAIC_FULL_SCALE) &amp;&amp;</a>
<a name="ln2844">      (roi_out-&gt;scale &lt; (piece-&gt;pipe-&gt;dsc.filters == 9u ? 0.5f : 0.667f)))</a>
<a name="ln2845">  {</a>
<a name="ln2846">    flags |= DEMOSAIC_ONLY_VNG_LINEAR;</a>
<a name="ln2847">  }</a>
<a name="ln2848"> </a>
<a name="ln2849">  return flags;</a>
<a name="ln2850">}</a>
<a name="ln2851"> </a>
<a name="ln2852">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const i, void *const o,</a>
<a name="ln2853">             const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2854">{</a>
<a name="ln2855">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln2856">  const float threshold = 0.0001f * img-&gt;exif_iso;</a>
<a name="ln2857"> </a>
<a name="ln2858">  dt_iop_roi_t roi = *roi_in;</a>
<a name="ln2859">  dt_iop_roi_t roo = *roi_out;</a>
<a name="ln2860">  roo.x = roo.y = 0;</a>
<a name="ln2861">  // roi_out-&gt;scale = global scale: (iscale == 1.0, always when demosaic is on)</a>
<a name="ln2862"> </a>
<a name="ln2863">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln2864"> </a>
<a name="ln2865">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2866"> </a>
<a name="ln2867">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln2868">  int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln2869">  if((qual_flags &amp; DEMOSAIC_MEDIUM_QUAL)</a>
<a name="ln2870">     &amp;&amp; // only overwrite setting if quality &lt;&lt; requested and in dr mode</a>
<a name="ln2871">     (demosaicing_method != DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)) // do not touch this special method</a>
<a name="ln2872">    demosaicing_method = (piece-&gt;pipe-&gt;dsc.filters != 9u) ? DT_IOP_DEMOSAIC_PPG : DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln2873"> </a>
<a name="ln2874">  const float *const pixels = (float *)i;</a>
<a name="ln2875"> </a>
<a name="ln2876">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln2877">  {</a>
<a name="ln2878">    // Full demosaic and then scaling if needed</a>
<a name="ln2879">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln2880">    float *tmp = (float *) o;</a>
<a name="ln2881">    if(scaled)</a>
<a name="ln2882">    {</a>
<a name="ln2883">      // demosaic and then clip and zoom</a>
<a name="ln2884">      // we demosaic at 1:1 the size of input roi, so make sure</a>
<a name="ln2885">      // we fit these bounds exactly, to avoid crashes..</a>
<a name="ln2886">      roo.width = roi_in-&gt;width;</a>
<a name="ln2887">      roo.height = roi_in-&gt;height;</a>
<a name="ln2888">      roo.scale = 1.0f;</a>
<a name="ln2889">      tmp = (float *)dt_alloc_align(64, (size_t)roo.width * roo.height * 4 * sizeof(float));</a>
<a name="ln2890">    }</a>
<a name="ln2891"> </a>
<a name="ln2892">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln2893">    {</a>
<a name="ln2894">      passthrough_monochrome(tmp, pixels, &amp;roo, &amp;roi);</a>
<a name="ln2895">    }</a>
<a name="ln2896">    else if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2897">    {</a>
<a name="ln2898">      if(demosaicing_method == DT_IOP_DEMOSAIC_FDC &amp;&amp; (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln2899">        xtrans_fdc_interpolate(self, tmp, pixels, &amp;roo, &amp;roi, xtrans);</a>
<a name="ln2900">      else if(demosaicing_method &gt;= DT_IOP_DEMOSAIC_MARKESTEIJN &amp;&amp; (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln2901">        xtrans_markesteijn_interpolate(tmp, pixels, &amp;roo, &amp;roi, xtrans,</a>
<a name="ln2902">                                       1 + (demosaicing_method - DT_IOP_DEMOSAIC_MARKESTEIJN) * 2);</a>
<a name="ln2903">      else</a>
<a name="ln2904">        vng_interpolate(tmp, pixels, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters, xtrans, qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR);</a>
<a name="ln2905">    }</a>
<a name="ln2906">    else</a>
<a name="ln2907">    {</a>
<a name="ln2908">      float *in = (float *)pixels;</a>
<a name="ln2909">      float *aux;</a>
<a name="ln2910"> </a>
<a name="ln2911">      if(!(img-&gt;flags &amp; DT_IMAGE_4BAYER) &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln2912">      {</a>
<a name="ln2913">        in = (float *)dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2914">        switch(data-&gt;green_eq)</a>
<a name="ln2915">        {</a>
<a name="ln2916">          case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln2917">            green_equilibration_favg(in, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2918">                                     roi_in-&gt;x, roi_in-&gt;y);</a>
<a name="ln2919">            break;</a>
<a name="ln2920">          case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln2921">            green_equilibration_lavg(in, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2922">                                     roi_in-&gt;x, roi_in-&gt;y, threshold);</a>
<a name="ln2923">            break;</a>
<a name="ln2924">          case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln2925">            aux = dt_alloc_align(64, (size_t)roi_in-&gt;height * roi_in-&gt;width * sizeof(float));</a>
<a name="ln2926">            green_equilibration_favg(aux, pixels, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2927">                                     roi_in-&gt;x, roi_in-&gt;y);</a>
<a name="ln2928">            green_equilibration_lavg(in, aux, roi_in-&gt;width, roi_in-&gt;height, piece-&gt;pipe-&gt;dsc.filters, roi_in-&gt;x,</a>
<a name="ln2929">                                     roi_in-&gt;y, threshold);</a>
<a name="ln2930">            dt_free_align(aux);</a>
<a name="ln2931">            break;</a>
<a name="ln2932">        }</a>
<a name="ln2933">      }</a>
<a name="ln2934"> </a>
<a name="ln2935">      if(demosaicing_method == DT_IOP_DEMOSAIC_VNG4 || (img-&gt;flags &amp; DT_IMAGE_4BAYER))</a>
<a name="ln2936">      {</a>
<a name="ln2937">        vng_interpolate(tmp, in, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters, xtrans, qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR);</a>
<a name="ln2938">        if (img-&gt;flags &amp; DT_IMAGE_4BAYER)</a>
<a name="ln2939">        {</a>
<a name="ln2940">          dt_colorspaces_cygm_to_rgb(tmp, roo.width*roo.height, data-&gt;CAM_to_RGB);</a>
<a name="ln2941">          dt_colorspaces_cygm_to_rgb(piece-&gt;pipe-&gt;dsc.processed_maximum, 1, data-&gt;CAM_to_RGB);</a>
<a name="ln2942">        }</a>
<a name="ln2943">      }</a>
<a name="ln2944">      else if(demosaicing_method != DT_IOP_DEMOSAIC_AMAZE)</a>
<a name="ln2945">        demosaic_ppg(tmp, in, &amp;roo, &amp;roi, piece-&gt;pipe-&gt;dsc.filters,</a>
<a name="ln2946">                     data-&gt;median_thrs); // wanted ppg or zoomed out a lot and quality is limited to 1</a>
<a name="ln2947">      else</a>
<a name="ln2948">        amaze_demosaic_RT(self, piece, in, tmp, &amp;roi, &amp;roo, piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln2949"> </a>
<a name="ln2950">      if(!(img-&gt;flags &amp; DT_IMAGE_4BAYER) &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO) dt_free_align(in);</a>
<a name="ln2951">    }</a>
<a name="ln2952"> </a>
<a name="ln2953">    if(scaled)</a>
<a name="ln2954">    {</a>
<a name="ln2955">      roi = *roi_out;</a>
<a name="ln2956">      dt_iop_clip_and_zoom_roi((float *)o, tmp, &amp;roi, &amp;roo, roi.width, roo.width);</a>
<a name="ln2957">      dt_free_align(tmp);</a>
<a name="ln2958">    }</a>
<a name="ln2959">  }</a>
<a name="ln2960">  else</a>
<a name="ln2961">  {</a>
<a name="ln2962">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln2963">      dt_iop_clip_and_zoom_demosaic_passthrough_monochrome_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width);</a>
<a name="ln2964">    else // sample half-size raw (Bayer) or 1/3-size raw (X-Trans)</a>
<a name="ln2965">        if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln2966">      dt_iop_clip_and_zoom_demosaic_third_size_xtrans_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width,</a>
<a name="ln2967">                                                        xtrans);</a>
<a name="ln2968">    else</a>
<a name="ln2969">      dt_iop_clip_and_zoom_demosaic_half_size_f((float *)o, pixels, &amp;roo, &amp;roi, roo.width, roi.width,</a>
<a name="ln2970">                                                piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln2971">  }</a>
<a name="ln2972">  if(data-&gt;color_smoothing) color_smoothing(o, roi_out, data-&gt;color_smoothing);</a>
<a name="ln2973">}</a>
<a name="ln2974"> </a>
<a name="ln2975">#ifdef HAVE_OPENCL</a>
<a name="ln2976">// color smoothing step by multiple passes of median filtering</a>
<a name="ln2977">static int color_smoothing_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln2978">                              cl_mem dev_out, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2979">{</a>
<a name="ln2980">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln2981">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;global_data;</a>
<a name="ln2982"> </a>
<a name="ln2983">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2984">  const int width = roi_out-&gt;width;</a>
<a name="ln2985">  const int height = roi_out-&gt;height;</a>
<a name="ln2986"> </a>
<a name="ln2987">  cl_int err = -999;</a>
<a name="ln2988"> </a>
<a name="ln2989">  cl_mem dev_tmp = dt_opencl_alloc_device(devid, width, height, 4 * sizeof(float));</a>
<a name="ln2990">  if(dev_tmp == NULL) goto error;</a>
<a name="ln2991"> </a>
<a name="ln2992">  dt_opencl_local_buffer_t locopt</a>
<a name="ln2993">    = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln2994">                                  .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln2995">                                  .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln2996"> </a>
<a name="ln2997">  if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_color_smoothing, &amp;locopt))</a>
<a name="ln2998">    goto error;</a>
<a name="ln2999"> </a>
<a name="ln3000">  // two buffer references for our ping-pong</a>
<a name="ln3001">  cl_mem dev_t1 = dev_out;</a>
<a name="ln3002">  cl_mem dev_t2 = dev_tmp;</a>
<a name="ln3003"> </a>
<a name="ln3004">  for(int pass = 0; pass &lt; data-&gt;color_smoothing; pass++)</a>
<a name="ln3005">  {</a>
<a name="ln3006">    size_t sizes[] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3007">    size_t local[] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3008">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 0, sizeof(cl_mem), &amp;dev_t1);</a>
<a name="ln3009">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 1, sizeof(cl_mem), &amp;dev_t2);</a>
<a name="ln3010">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 2, sizeof(int), &amp;width);</a>
<a name="ln3011">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 3, sizeof(int), &amp;height);</a>
<a name="ln3012">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_color_smoothing, 4,</a>
<a name="ln3013">                               (locopt.sizex + 2) * (locopt.sizey + 2) * 4 * sizeof(float), NULL);</a>
<a name="ln3014">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_color_smoothing, sizes, local);</a>
<a name="ln3015">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3016"> </a>
<a name="ln3017">    // swap dev_t1 and dev_t2</a>
<a name="ln3018">    cl_mem t = dev_t1;</a>
<a name="ln3019">    dev_t1 = dev_t2;</a>
<a name="ln3020">    dev_t2 = t;</a>
<a name="ln3021">  }</a>
<a name="ln3022"> </a>
<a name="ln3023">  // after last step we find final output in dev_t1.</a>
<a name="ln3024">  // let's see if this is in dev_tmp1 and needs to be copied to dev_out</a>
<a name="ln3025">  if(dev_t1 == dev_tmp)</a>
<a name="ln3026">  {</a>
<a name="ln3027">    // copy data from dev_tmp -&gt; dev_out</a>
<a name="ln3028">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3029">    size_t region[] = { width, height, 1 };</a>
<a name="ln3030">    err = dt_opencl_enqueue_copy_image(devid, dev_tmp, dev_out, origin, origin, region);</a>
<a name="ln3031">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3032">  }</a>
<a name="ln3033"> </a>
<a name="ln3034">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3035">  return TRUE;</a>
<a name="ln3036"> </a>
<a name="ln3037">error:</a>
<a name="ln3038">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3039">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic_color_smoothing] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3040">  return FALSE;</a>
<a name="ln3041">}</a>
<a name="ln3042"> </a>
<a name="ln3043">static int green_equilibration_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3044">                                  cl_mem dev_out, const dt_iop_roi_t *const roi_in)</a>
<a name="ln3045">{</a>
<a name="ln3046">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3047">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;global_data;</a>
<a name="ln3048"> </a>
<a name="ln3049">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3050">  const int width = roi_in-&gt;width;</a>
<a name="ln3051">  const int height = roi_in-&gt;height;</a>
<a name="ln3052"> </a>
<a name="ln3053">  cl_mem dev_tmp = NULL;</a>
<a name="ln3054">  cl_mem dev_m = NULL;</a>
<a name="ln3055">  cl_mem dev_r = NULL;</a>
<a name="ln3056">  cl_mem dev_in1 = NULL;</a>
<a name="ln3057">  cl_mem dev_out1 = NULL;</a>
<a name="ln3058">  cl_mem dev_in2 = NULL;</a>
<a name="ln3059">  cl_mem dev_out2 = NULL;</a>
<a name="ln3060">  float *sumsum = NULL;</a>
<a name="ln3061"> </a>
<a name="ln3062">  cl_int err = -999;</a>
<a name="ln3063"> </a>
<a name="ln3064">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3065">  {</a>
<a name="ln3066">    dev_tmp = dt_opencl_alloc_device(devid, width, height, sizeof(float));</a>
<a name="ln3067">    if(dev_tmp == NULL) goto error;</a>
<a name="ln3068">  }</a>
<a name="ln3069"> </a>
<a name="ln3070">  switch(data-&gt;green_eq)</a>
<a name="ln3071">  {</a>
<a name="ln3072">    case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln3073">      dev_in1 = dev_in;</a>
<a name="ln3074">      dev_out1 = dev_out;</a>
<a name="ln3075">      break;</a>
<a name="ln3076">    case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln3077">      dev_in2 = dev_in;</a>
<a name="ln3078">      dev_out2 = dev_out;</a>
<a name="ln3079">      break;</a>
<a name="ln3080">    case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln3081">      dev_in1 = dev_in;</a>
<a name="ln3082">      dev_out1 = dev_tmp;</a>
<a name="ln3083">      dev_in2 = dev_tmp;</a>
<a name="ln3084">      dev_out2 = dev_out;</a>
<a name="ln3085">      break;</a>
<a name="ln3086">    case DT_IOP_GREEN_EQ_NO:</a>
<a name="ln3087">    default:</a>
<a name="ln3088">      goto error;</a>
<a name="ln3089">  }</a>
<a name="ln3090"> </a>
<a name="ln3091">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_FULL || data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3092">  {</a>
<a name="ln3093">    dt_opencl_local_buffer_t flocopt</a>
<a name="ln3094">      = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln3095">                                    .cellsize = 2 * sizeof(float), .overhead = 0,</a>
<a name="ln3096">                                    .sizex = 1 &lt;&lt; 4, .sizey = 1 &lt;&lt; 4 };</a>
<a name="ln3097"> </a>
<a name="ln3098">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_favg_reduce_first, &amp;flocopt))</a>
<a name="ln3099">      goto error;</a>
<a name="ln3100"> </a>
<a name="ln3101">    const size_t bwidth = ROUNDUP(width, flocopt.sizex);</a>
<a name="ln3102">    const size_t bheight = ROUNDUP(height, flocopt.sizey);</a>
<a name="ln3103"> </a>
<a name="ln3104">    const int bufsize = (bwidth / flocopt.sizex) * (bheight / flocopt.sizey);</a>
<a name="ln3105"> </a>
<a name="ln3106">    dev_m = dt_opencl_alloc_device_buffer(devid, (size_t)bufsize * 2 * sizeof(float));</a>
<a name="ln3107">    if(dev_m == NULL) goto error;</a>
<a name="ln3108"> </a>
<a name="ln3109">    size_t fsizes[3] = { bwidth, bheight, 1 };</a>
<a name="ln3110">    size_t flocal[3] = { flocopt.sizex, flocopt.sizey, 1 };</a>
<a name="ln3111">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 0, sizeof(cl_mem), &amp;dev_in1);</a>
<a name="ln3112">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 1, sizeof(int), &amp;width);</a>
<a name="ln3113">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 2, sizeof(int), &amp;height);</a>
<a name="ln3114">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 3, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln3115">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3116">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3117">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3118">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_first, 7,</a>
<a name="ln3119">                             flocopt.sizex * flocopt.sizey * 2 * sizeof(float), NULL);</a>
<a name="ln3120">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_favg_reduce_first, fsizes,</a>
<a name="ln3121">                                                 flocal);</a>
<a name="ln3122">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3123"> </a>
<a name="ln3124">    dt_opencl_local_buffer_t slocopt</a>
<a name="ln3125">      = (dt_opencl_local_buffer_t){ .xoffset = 0, .xfactor = 1, .yoffset = 0, .yfactor = 1,</a>
<a name="ln3126">                                    .cellsize = 2 * sizeof(float), .overhead = 0,</a>
<a name="ln3127">                                    .sizex = 1 &lt;&lt; 16, .sizey = 1 };</a>
<a name="ln3128"> </a>
<a name="ln3129">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_favg_reduce_second, &amp;slocopt))</a>
<a name="ln3130">      goto error;</a>
<a name="ln3131"> </a>
<a name="ln3132">    const int reducesize = MIN(REDUCESIZE, ROUNDUP(bufsize, slocopt.sizex) / slocopt.sizex);</a>
<a name="ln3133"> </a>
<a name="ln3134">    dev_r = dt_opencl_alloc_device_buffer(devid, (size_t)reducesize * 2 * sizeof(float));</a>
<a name="ln3135">    if(dev_r == NULL) goto error;</a>
<a name="ln3136"> </a>
<a name="ln3137">    size_t ssizes[3] = { reducesize * slocopt.sizex, 1, 1 };</a>
<a name="ln3138">    size_t slocal[3] = { slocopt.sizex, 1, 1 };</a>
<a name="ln3139">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 0, sizeof(cl_mem), &amp;dev_m);</a>
<a name="ln3140">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 1, sizeof(cl_mem), &amp;dev_r);</a>
<a name="ln3141">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 2, sizeof(int), &amp;bufsize);</a>
<a name="ln3142">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_reduce_second, 3, slocopt.sizex * 2 * sizeof(float), NULL);</a>
<a name="ln3143">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_favg_reduce_second, ssizes,</a>
<a name="ln3144">                                                 slocal);</a>
<a name="ln3145">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3146"> </a>
<a name="ln3147">    sumsum = dt_alloc_align(64, (size_t)reducesize * 2 * sizeof(float));</a>
<a name="ln3148">    if(sumsum == NULL) goto error;</a>
<a name="ln3149">    err = dt_opencl_read_buffer_from_device(devid, (void *)sumsum, dev_r, 0,</a>
<a name="ln3150">                                            (size_t)reducesize * 2 * sizeof(float), CL_TRUE);</a>
<a name="ln3151">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3152"> </a>
<a name="ln3153">    float sum1 = 0.0f, sum2 = 0.0f;</a>
<a name="ln3154">    for(int k = 0; k &lt; reducesize; k++)</a>
<a name="ln3155">    {</a>
<a name="ln3156">      sum1 += sumsum[2 * k];</a>
<a name="ln3157">      sum2 += sumsum[2 * k + 1];</a>
<a name="ln3158">    }</a>
<a name="ln3159"> </a>
<a name="ln3160">    const float gr_ratio = (sum1 &gt; 0.0f &amp;&amp; sum2 &gt; 0.0f) ? sum2 / sum1 : 1.0f;</a>
<a name="ln3161"> </a>
<a name="ln3162">    size_t asizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3163">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 0, sizeof(cl_mem), &amp;dev_in1);</a>
<a name="ln3164">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 1, sizeof(cl_mem), &amp;dev_out1);</a>
<a name="ln3165">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 2, sizeof(int), &amp;width);</a>
<a name="ln3166">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 3, sizeof(int), &amp;height);</a>
<a name="ln3167">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3168">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3169">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3170">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_favg_apply, 7, sizeof(float), &amp;gr_ratio);</a>
<a name="ln3171">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_green_eq_favg_apply, asizes);</a>
<a name="ln3172">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3173">  }</a>
<a name="ln3174"> </a>
<a name="ln3175">  if(data-&gt;green_eq == DT_IOP_GREEN_EQ_LOCAL || data-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH)</a>
<a name="ln3176">  {</a>
<a name="ln3177">    const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3178">    const float threshold = 0.0001f * img-&gt;exif_iso;</a>
<a name="ln3179"> </a>
<a name="ln3180">    dt_opencl_local_buffer_t locopt</a>
<a name="ln3181">      = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3182">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3183">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3184"> </a>
<a name="ln3185">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_green_eq_lavg, &amp;locopt))</a>
<a name="ln3186">      goto error;</a>
<a name="ln3187"> </a>
<a name="ln3188">    size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3189">    size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3190">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 0, sizeof(cl_mem), &amp;dev_in2);</a>
<a name="ln3191">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 1, sizeof(cl_mem), &amp;dev_out2);</a>
<a name="ln3192">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 2, sizeof(int), &amp;width);</a>
<a name="ln3193">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 3, sizeof(int), &amp;height);</a>
<a name="ln3194">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 4, sizeof(uint32_t), (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3195">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 5, sizeof(int), &amp;roi_in-&gt;x);</a>
<a name="ln3196">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 6, sizeof(int), &amp;roi_in-&gt;y);</a>
<a name="ln3197">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 7, sizeof(float), (void *)&amp;threshold);</a>
<a name="ln3198">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_green_eq_lavg, 8,</a>
<a name="ln3199">                           (locopt.sizex + 4) * (locopt.sizey + 4) * sizeof(float), NULL);</a>
<a name="ln3200">    err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_green_eq_lavg, sizes, local);</a>
<a name="ln3201">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3202">  }</a>
<a name="ln3203"> </a>
<a name="ln3204">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3205">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3206">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln3207">  dt_free_align(sumsum);</a>
<a name="ln3208">  return TRUE;</a>
<a name="ln3209"> </a>
<a name="ln3210">error:</a>
<a name="ln3211">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3212">  dt_opencl_release_mem_object(dev_m);</a>
<a name="ln3213">  dt_opencl_release_mem_object(dev_r);</a>
<a name="ln3214">  dt_free_align(sumsum);</a>
<a name="ln3215">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic_green_equilibration] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3216">  return FALSE;</a>
<a name="ln3217">}</a>
<a name="ln3218"> </a>
<a name="ln3219"> </a>
<a name="ln3220">static int process_default_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3221">                              cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln3222">                              const dt_iop_roi_t *const roi_out)</a>
<a name="ln3223">{</a>
<a name="ln3224">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3225">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;global_data;</a>
<a name="ln3226">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3227"> </a>
<a name="ln3228">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3229">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln3230">  const int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln3231"> </a>
<a name="ln3232">  cl_mem dev_aux = NULL;</a>
<a name="ln3233">  cl_mem dev_tmp = NULL;</a>
<a name="ln3234">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3235">  cl_int err = -999;</a>
<a name="ln3236"> </a>
<a name="ln3237"> </a>
<a name="ln3238">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3239">  {</a>
<a name="ln3240">    // Full demosaic and then scaling if needed</a>
<a name="ln3241">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3242"> </a>
<a name="ln3243">    int width = roi_out-&gt;width;</a>
<a name="ln3244">    int height = roi_out-&gt;height;</a>
<a name="ln3245"> </a>
<a name="ln3246">    // green equilibration</a>
<a name="ln3247">    if(data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln3248">    {</a>
<a name="ln3249">      dev_green_eq = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, sizeof(float));</a>
<a name="ln3250">      if(dev_green_eq == NULL) goto error;</a>
<a name="ln3251"> </a>
<a name="ln3252">      if(!green_equilibration_cl(self, piece, dev_in, dev_green_eq, roi_in))</a>
<a name="ln3253">        goto error;</a>
<a name="ln3254"> </a>
<a name="ln3255">      dev_in = dev_green_eq;</a>
<a name="ln3256">    }</a>
<a name="ln3257"> </a>
<a name="ln3258">    // need to reserve scaled auxiliary buffer or use dev_out</a>
<a name="ln3259">    if(scaled)</a>
<a name="ln3260">    {</a>
<a name="ln3261">      dev_aux = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3262">      if(dev_aux == NULL) goto error;</a>
<a name="ln3263">      width = roi_in-&gt;width;</a>
<a name="ln3264">      height = roi_in-&gt;height;</a>
<a name="ln3265">    }</a>
<a name="ln3266">    else</a>
<a name="ln3267">      dev_aux = dev_out;</a>
<a name="ln3268"> </a>
<a name="ln3269">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln3270">    {</a>
<a name="ln3271">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3272">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3273">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3274">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 2, sizeof(int), &amp;width);</a>
<a name="ln3275">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_passthrough_monochrome, 3, sizeof(int), &amp;height);</a>
<a name="ln3276">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_passthrough_monochrome, sizes);</a>
<a name="ln3277">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3278">    }</a>
<a name="ln3279">    else if(demosaicing_method == DT_IOP_DEMOSAIC_PPG)</a>
<a name="ln3280">    {</a>
<a name="ln3281">      if(data-&gt;median_thrs &gt; 0.0f)</a>
<a name="ln3282">      {</a>
<a name="ln3283">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3284">          = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3285">                                        .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3286">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3287"> </a>
<a name="ln3288">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_pre_median, &amp;locopt))</a>
<a name="ln3289">        goto error;</a>
<a name="ln3290"> </a>
<a name="ln3291">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3292">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3293">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3294">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3295">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 2, sizeof(int), &amp;width);</a>
<a name="ln3296">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 3, sizeof(int), &amp;height);</a>
<a name="ln3297">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 4, sizeof(uint32_t),</a>
<a name="ln3298">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3299">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 5, sizeof(float), (void *)&amp;data-&gt;median_thrs);</a>
<a name="ln3300">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_pre_median, 6,</a>
<a name="ln3301">                             (locopt.sizex + 4) * (locopt.sizey + 4) * sizeof(float), NULL);</a>
<a name="ln3302">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_pre_median, sizes, local);</a>
<a name="ln3303">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3304">        dev_in = dev_aux;</a>
<a name="ln3305">      }</a>
<a name="ln3306"> </a>
<a name="ln3307">      dev_tmp = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3308">      if(dev_tmp == NULL) goto error;</a>
<a name="ln3309"> </a>
<a name="ln3310">      {</a>
<a name="ln3311">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3312">          = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln3313">                                        .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3314">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3315"> </a>
<a name="ln3316">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_ppg_green, &amp;locopt))</a>
<a name="ln3317">        goto error;</a>
<a name="ln3318"> </a>
<a name="ln3319">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3320">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3321">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3322">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 1, sizeof(cl_mem), &amp;dev_tmp);</a>
<a name="ln3323">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 2, sizeof(int), &amp;width);</a>
<a name="ln3324">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 3, sizeof(int), &amp;height);</a>
<a name="ln3325">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 4, sizeof(uint32_t),</a>
<a name="ln3326">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3327">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_green, 5,</a>
<a name="ln3328">                             (locopt.sizex + 2*3) * (locopt.sizey + 2*3) * sizeof(float), NULL);</a>
<a name="ln3329"> </a>
<a name="ln3330">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_ppg_green, sizes, local);</a>
<a name="ln3331">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3332">      }</a>
<a name="ln3333"> </a>
<a name="ln3334">      {</a>
<a name="ln3335">        dt_opencl_local_buffer_t locopt</a>
<a name="ln3336">          = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln3337">                                        .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3338">                                        .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3339"> </a>
<a name="ln3340">        if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_ppg_redblue, &amp;locopt))</a>
<a name="ln3341">        goto error;</a>
<a name="ln3342"> </a>
<a name="ln3343">        size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3344">        size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3345">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 0, sizeof(cl_mem), &amp;dev_tmp);</a>
<a name="ln3346">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3347">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 2, sizeof(int), &amp;width);</a>
<a name="ln3348">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 3, sizeof(int), &amp;height);</a>
<a name="ln3349">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 4, sizeof(uint32_t),</a>
<a name="ln3350">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3351">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_ppg_redblue, 5,</a>
<a name="ln3352">                             (locopt.sizex + 2) * (locopt.sizey + 2) * 4 * sizeof(float), NULL);</a>
<a name="ln3353"> </a>
<a name="ln3354">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_ppg_redblue, sizes, local);</a>
<a name="ln3355">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3356">      }</a>
<a name="ln3357"> </a>
<a name="ln3358">      {</a>
<a name="ln3359">        // manage borders</a>
<a name="ln3360">        size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3361">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln3362">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 1, sizeof(cl_mem), &amp;dev_aux);</a>
<a name="ln3363">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3364">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3365">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_border_interpolate, 4, sizeof(uint32_t),</a>
<a name="ln3366">                                 (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3367">        err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_border_interpolate, sizes);</a>
<a name="ln3368">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln3369">      }</a>
<a name="ln3370">    }</a>
<a name="ln3371"> </a>
<a name="ln3372">    if(scaled)</a>
<a name="ln3373">    {</a>
<a name="ln3374">      // scale aux buffer to output buffer</a>
<a name="ln3375">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_aux, roi_out, roi_in);</a>
<a name="ln3376">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3377">    }</a>
<a name="ln3378">  }</a>
<a name="ln3379">  else</a>
<a name="ln3380">  {</a>
<a name="ln3381">    if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln3382">    {</a>
<a name="ln3383">      // sample image:</a>
<a name="ln3384">      const int zero = 0;</a>
<a name="ln3385">      cl_mem dev_pix = dev_in;</a>
<a name="ln3386">      const int width = roi_out-&gt;width;</a>
<a name="ln3387">      const int height = roi_out-&gt;height;</a>
<a name="ln3388"> </a>
<a name="ln3389">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3390">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 0, sizeof(cl_mem), &amp;dev_pix);</a>
<a name="ln3391">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln3392">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 2, sizeof(int), &amp;width);</a>
<a name="ln3393">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 3, sizeof(int), &amp;height);</a>
<a name="ln3394">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3395">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3396">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 6, sizeof(int),</a>
<a name="ln3397">                               (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3398">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 7, sizeof(int),</a>
<a name="ln3399">                               (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3400">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 8, sizeof(float),</a>
<a name="ln3401">                               (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3402">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_passthrough_monochrome, 9, sizeof(uint32_t),</a>
<a name="ln3403">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3404">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_passthrough_monochrome, sizes);</a>
<a name="ln3405">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3406">    }</a>
<a name="ln3407">    else</a>
<a name="ln3408">    {</a>
<a name="ln3409">      // sample half-size image:</a>
<a name="ln3410">      const int zero = 0;</a>
<a name="ln3411">      cl_mem dev_pix = dev_in;</a>
<a name="ln3412">      const int width = roi_out-&gt;width;</a>
<a name="ln3413">      const int height = roi_out-&gt;height;</a>
<a name="ln3414"> </a>
<a name="ln3415">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3416">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 0, sizeof(cl_mem), &amp;dev_pix);</a>
<a name="ln3417">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln3418">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 2, sizeof(int), &amp;width);</a>
<a name="ln3419">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 3, sizeof(int), &amp;height);</a>
<a name="ln3420">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3421">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3422">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3423">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3424">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3425">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 9, sizeof(uint32_t),</a>
<a name="ln3426">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3427">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_half_size, sizes);</a>
<a name="ln3428">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3429">    }</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3433">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3434">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3435">  dev_aux = dev_green_eq = dev_tmp = NULL;</a>
<a name="ln3436"> </a>
<a name="ln3437">  // color smoothing</a>
<a name="ln3438">  if(data-&gt;color_smoothing)</a>
<a name="ln3439">  {</a>
<a name="ln3440">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln3441">      goto error;</a>
<a name="ln3442">  }</a>
<a name="ln3443"> </a>
<a name="ln3444">  return TRUE;</a>
<a name="ln3445"> </a>
<a name="ln3446">error:</a>
<a name="ln3447">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3448">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3449">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3450">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3451">  return FALSE;</a>
<a name="ln3452">}</a>
<a name="ln3453"> </a>
<a name="ln3454">static int process_vng_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3455">                          cl_mem dev_out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln3456">{</a>
<a name="ln3457">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3458">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;global_data;</a>
<a name="ln3459">  const dt_image_t *img = &amp;self-&gt;dev-&gt;image_storage;</a>
<a name="ln3460"> </a>
<a name="ln3461">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln3462"> </a>
<a name="ln3463">  // separate out G1 and G2 in Bayer patterns</a>
<a name="ln3464">  uint32_t filters4;</a>
<a name="ln3465">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3466">    filters4 = piece-&gt;pipe-&gt;dsc.filters;</a>
<a name="ln3467">  else if((piece-&gt;pipe-&gt;dsc.filters &amp; 3) == 1)</a>
<a name="ln3468">    filters4 = piece-&gt;pipe-&gt;dsc.filters | 0x03030303u;</a>
<a name="ln3469">  else</a>
<a name="ln3470">    filters4 = piece-&gt;pipe-&gt;dsc.filters | 0x0c0c0c0cu;</a>
<a name="ln3471"> </a>
<a name="ln3472">  const int size = (filters4 == 9u) ? 6 : 16;</a>
<a name="ln3473">  const int colors = (filters4 == 9u) ? 3 : 4;</a>
<a name="ln3474">  const int prow = (filters4 == 9u) ? 6 : 8;</a>
<a name="ln3475">  const int pcol = (filters4 == 9u) ? 6 : 2;</a>
<a name="ln3476">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3477"> </a>
<a name="ln3478">  const float processed_maximum[4]</a>
<a name="ln3479">      = { piece-&gt;pipe-&gt;dsc.processed_maximum[0], piece-&gt;pipe-&gt;dsc.processed_maximum[1],</a>
<a name="ln3480">          piece-&gt;pipe-&gt;dsc.processed_maximum[2], 1.0f };</a>
<a name="ln3481"> </a>
<a name="ln3482">  const int qual_flags = demosaic_qual_flags(piece, img, roi_out);</a>
<a name="ln3483"> </a>
<a name="ln3484">  int *ips = NULL;</a>
<a name="ln3485"> </a>
<a name="ln3486">  cl_mem dev_tmp = NULL;</a>
<a name="ln3487">  cl_mem dev_aux = NULL;</a>
<a name="ln3488">  cl_mem dev_xtrans = NULL;</a>
<a name="ln3489">  cl_mem dev_lookup = NULL;</a>
<a name="ln3490">  cl_mem dev_code = NULL;</a>
<a name="ln3491">  cl_mem dev_ips = NULL;</a>
<a name="ln3492">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3493">  cl_int err = -999;</a>
<a name="ln3494"> </a>
<a name="ln3495">  int32_t(*lookup)[16][32] = NULL;</a>
<a name="ln3496"> </a>
<a name="ln3497">  if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3498">  {</a>
<a name="ln3499">    dev_xtrans</a>
<a name="ln3500">        = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln3501">    if(dev_xtrans == NULL) goto error;</a>
<a name="ln3502">  }</a>
<a name="ln3503"> </a>
<a name="ln3504">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3505">  {</a>
<a name="ln3506">    // Full demosaic and then scaling if needed</a>
<a name="ln3507">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3508"> </a>
<a name="ln3509">    // build interpolation lookup table for linear interpolation which for a given offset in the sensor</a>
<a name="ln3510">    // lists neighboring pixels from which to interpolate:</a>
<a name="ln3511">    // NUM_PIXELS                 # of neighboring pixels to read</a>
<a name="ln3512">    // for (1..NUM_PIXELS):</a>
<a name="ln3513">    //   OFFSET                   # in bytes from current pixel</a>
<a name="ln3514">    //   WEIGHT                   # how much weight to give this neighbor</a>
<a name="ln3515">    //   COLOR                    # sensor color</a>
<a name="ln3516">    // # weights of adjoining pixels not of this pixel's color</a>
<a name="ln3517">    // COLORA TOT_WEIGHT</a>
<a name="ln3518">    // COLORB TOT_WEIGHT</a>
<a name="ln3519">    // COLORPIX                   # color of center pixel</a>
<a name="ln3520">    const size_t lookup_size = (size_t)16 * 16 * 32 * sizeof(int32_t);</a>
<a name="ln3521">    lookup = malloc(lookup_size);</a>
<a name="ln3522"> </a>
<a name="ln3523">    for(int row = 0; row &lt; size; row++)</a>
<a name="ln3524">      for(int col = 0; col &lt; size; col++)</a>
<a name="ln3525">      {</a>
<a name="ln3526">        int32_t *ip = lookup[row][col] + 1;</a>
<a name="ln3527">        int sum[4] = { 0 };</a>
<a name="ln3528">        const int f = fcol(row + roi_in-&gt;y, col + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln3529">        // make list of adjoining pixel offsets by weight &amp; color</a>
<a name="ln3530">        for(int y = -1; y &lt;= 1; y++)</a>
<a name="ln3531">          for(int x = -1; x &lt;= 1; x++)</a>
<a name="ln3532">          {</a>
<a name="ln3533">            int weight = 1 &lt;&lt; ((y == 0) + (x == 0));</a>
<a name="ln3534">            const int color = fcol(row + y + roi_in-&gt;y, col + x + roi_in-&gt;x, filters4, xtrans);</a>
<a name="ln3535">            if(color == f) continue;</a>
<a name="ln3536">            *ip++ = (y &lt;&lt; 16) | (x &amp; 0xffffu);</a>
<a name="ln3537">            *ip++ = weight;</a>
<a name="ln3538">            *ip++ = color;</a>
<a name="ln3539">            sum[color] += weight;</a>
<a name="ln3540">          }</a>
<a name="ln3541">        lookup[row][col][0] = (ip - lookup[row][col]) / 3; /* # of neighboring pixels found */</a>
<a name="ln3542">        for(int c = 0; c &lt; colors; c++)</a>
<a name="ln3543">          if(c != f)</a>
<a name="ln3544">          {</a>
<a name="ln3545">            *ip++ = c;</a>
<a name="ln3546">            *ip++ = sum[c];</a>
<a name="ln3547">          }</a>
<a name="ln3548">        *ip = f;</a>
<a name="ln3549">      }</a>
<a name="ln3550"> </a>
<a name="ln3551">    // Precalculate for VNG</a>
<a name="ln3552">    static const signed char terms[]</a>
<a name="ln3553">      = { -2, -2, +0, -1, 1, 0x01, -2, -2, +0, +0, 2, 0x01, -2, -1, -1, +0, 1, 0x01, -2, -1, +0, -1, 1, 0x02,</a>
<a name="ln3554">          -2, -1, +0, +0, 1, 0x03, -2, -1, +0, +1, 2, 0x01, -2, +0, +0, -1, 1, 0x06, -2, +0, +0, +0, 2, 0x02,</a>
<a name="ln3555">          -2, +0, +0, +1, 1, 0x03, -2, +1, -1, +0, 1, 0x04, -2, +1, +0, -1, 2, 0x04, -2, +1, +0, +0, 1, 0x06,</a>
<a name="ln3556">          -2, +1, +0, +1, 1, 0x02, -2, +2, +0, +0, 2, 0x04, -2, +2, +0, +1, 1, 0x04, -1, -2, -1, +0, 1, 0x80,</a>
<a name="ln3557">          -1, -2, +0, -1, 1, 0x01, -1, -2, +1, -1, 1, 0x01, -1, -2, +1, +0, 2, 0x01, -1, -1, -1, +1, 1, 0x88,</a>
<a name="ln3558">          -1, -1, +1, -2, 1, 0x40, -1, -1, +1, -1, 1, 0x22, -1, -1, +1, +0, 1, 0x33, -1, -1, +1, +1, 2, 0x11,</a>
<a name="ln3559">          -1, +0, -1, +2, 1, 0x08, -1, +0, +0, -1, 1, 0x44, -1, +0, +0, +1, 1, 0x11, -1, +0, +1, -2, 2, 0x40,</a>
<a name="ln3560">          -1, +0, +1, -1, 1, 0x66, -1, +0, +1, +0, 2, 0x22, -1, +0, +1, +1, 1, 0x33, -1, +0, +1, +2, 2, 0x10,</a>
<a name="ln3561">          -1, +1, +1, -1, 2, 0x44, -1, +1, +1, +0, 1, 0x66, -1, +1, +1, +1, 1, 0x22, -1, +1, +1, +2, 1, 0x10,</a>
<a name="ln3562">          -1, +2, +0, +1, 1, 0x04, -1, +2, +1, +0, 2, 0x04, -1, +2, +1, +1, 1, 0x04, +0, -2, +0, +0, 2, 0x80,</a>
<a name="ln3563">          +0, -1, +0, +1, 2, 0x88, +0, -1, +1, -2, 1, 0x40, +0, -1, +1, +0, 1, 0x11, +0, -1, +2, -2, 1, 0x40,</a>
<a name="ln3564">          +0, -1, +2, -1, 1, 0x20, +0, -1, +2, +0, 1, 0x30, +0, -1, +2, +1, 2, 0x10, +0, +0, +0, +2, 2, 0x08,</a>
<a name="ln3565">          +0, +0, +2, -2, 2, 0x40, +0, +0, +2, -1, 1, 0x60, +0, +0, +2, +0, 2, 0x20, +0, +0, +2, +1, 1, 0x30,</a>
<a name="ln3566">          +0, +0, +2, +2, 2, 0x10, +0, +1, +1, +0, 1, 0x44, +0, +1, +1, +2, 1, 0x10, +0, +1, +2, -1, 2, 0x40,</a>
<a name="ln3567">          +0, +1, +2, +0, 1, 0x60, +0, +1, +2, +1, 1, 0x20, +0, +1, +2, +2, 1, 0x10, +1, -2, +1, +0, 1, 0x80,</a>
<a name="ln3568">          +1, -1, +1, +1, 1, 0x88, +1, +0, +1, +2, 1, 0x08, +1, +0, +2, -1, 1, 0x40, +1, +0, +2, +1, 1, 0x10 };</a>
<a name="ln3569">    static const signed char chood[]</a>
<a name="ln3570">      = { -1, -1, -1, 0, -1, +1, 0, +1, +1, +1, +1, 0, +1, -1, 0, -1 };</a>
<a name="ln3571"> </a>
<a name="ln3572">    const size_t ips_size = (size_t)prow * pcol * 352 * sizeof(int);</a>
<a name="ln3573">    ips = malloc(ips_size);</a>
<a name="ln3574"> </a>
<a name="ln3575">    int *ip = ips;</a>
<a name="ln3576">    int code[16][16];</a>
<a name="ln3577"> </a>
<a name="ln3578">    for(int row = 0; row &lt; prow; row++)</a>
<a name="ln3579">      for(int col = 0; col &lt; pcol; col++)</a>
<a name="ln3580">      {</a>
<a name="ln3581">        code[row][col] = ip - ips;</a>
<a name="ln3582">        const signed char *cp = terms;</a>
<a name="ln3583">        for(int t = 0; t &lt; 64; t++)</a>
<a name="ln3584">        {</a>
<a name="ln3585">          int y1 = *cp++, x1 = *cp++;</a>
<a name="ln3586">          int y2 = *cp++, x2 = *cp++;</a>
<a name="ln3587">          int weight = *cp++;</a>
<a name="ln3588">          int grads = *cp++;</a>
<a name="ln3589">          int color = fcol(row + y1, col + x1, filters4, xtrans);</a>
<a name="ln3590">          if(fcol(row + y2, col + x2, filters4, xtrans) != color) continue;</a>
<a name="ln3591">          int diag</a>
<a name="ln3592">              = (fcol(row, col + 1, filters4, xtrans) == color &amp;&amp; fcol(row + 1, col, filters4, xtrans) == color)</a>
<a name="ln3593">                    ? 2</a>
<a name="ln3594">                    : 1;</a>
<a name="ln3595">          if(abs(y1 - y2) == diag &amp;&amp; abs(x1 - x2) == diag) continue;</a>
<a name="ln3596">          *ip++ = (y1 &lt;&lt; 16) | (x1 &amp; 0xffffu);</a>
<a name="ln3597">          *ip++ = (y2 &lt;&lt; 16) | (x2 &amp; 0xffffu);</a>
<a name="ln3598">          *ip++ = (color &lt;&lt; 16) | (weight &amp; 0xffffu);</a>
<a name="ln3599">          for(int g = 0; g &lt; 8; g++)</a>
<a name="ln3600">            if(grads &amp; 1 &lt;&lt; g) *ip++ = g;</a>
<a name="ln3601">          *ip++ = -1;</a>
<a name="ln3602">        }</a>
<a name="ln3603">        *ip++ = INT_MAX;</a>
<a name="ln3604">        cp = chood;</a>
<a name="ln3605">        for(int g = 0; g &lt; 8; g++)</a>
<a name="ln3606">        {</a>
<a name="ln3607">          int y = *cp++, x = *cp++;</a>
<a name="ln3608">          *ip++ = (y &lt;&lt; 16) | (x &amp; 0xffffu);</a>
<a name="ln3609">          int color = fcol(row, col, filters4, xtrans);</a>
<a name="ln3610">          if(fcol(row + y, col + x, filters4, xtrans) != color</a>
<a name="ln3611">             &amp;&amp; fcol(row + y * 2, col + x * 2, filters4, xtrans) == color)</a>
<a name="ln3612">          {</a>
<a name="ln3613">            *ip++ = (2*y &lt;&lt; 16) | (2*x &amp; 0xffffu);</a>
<a name="ln3614">            *ip++ = color;</a>
<a name="ln3615">          }</a>
<a name="ln3616">          else</a>
<a name="ln3617">          {</a>
<a name="ln3618">            *ip++ = 0;</a>
<a name="ln3619">            *ip++ = 0;</a>
<a name="ln3620">          }</a>
<a name="ln3621">        }</a>
<a name="ln3622">      }</a>
<a name="ln3623"> </a>
<a name="ln3624"> </a>
<a name="ln3625">    dev_lookup = dt_opencl_copy_host_to_device_constant(devid, lookup_size, lookup);</a>
<a name="ln3626">    if(dev_lookup == NULL) goto error;</a>
<a name="ln3627"> </a>
<a name="ln3628">    dev_code = dt_opencl_copy_host_to_device_constant(devid, sizeof(code), code);</a>
<a name="ln3629">    if(dev_code == NULL) goto error;</a>
<a name="ln3630"> </a>
<a name="ln3631">    dev_ips = dt_opencl_copy_host_to_device_constant(devid, ips_size, ips);</a>
<a name="ln3632">    if(dev_ips == NULL) goto error;</a>
<a name="ln3633"> </a>
<a name="ln3634">    // green equilibration for Bayer sensors</a>
<a name="ln3635">    if(piece-&gt;pipe-&gt;dsc.filters != 9u &amp;&amp; data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)</a>
<a name="ln3636">    {</a>
<a name="ln3637">      dev_green_eq = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, sizeof(float));</a>
<a name="ln3638">      if(dev_green_eq == NULL) goto error;</a>
<a name="ln3639"> </a>
<a name="ln3640">      if(!green_equilibration_cl(self, piece, dev_in, dev_green_eq, roi_in))</a>
<a name="ln3641">        goto error;</a>
<a name="ln3642"> </a>
<a name="ln3643">      dev_in = dev_green_eq;</a>
<a name="ln3644">    }</a>
<a name="ln3645"> </a>
<a name="ln3646">    int width = roi_out-&gt;width;</a>
<a name="ln3647">    int height = roi_out-&gt;height;</a>
<a name="ln3648"> </a>
<a name="ln3649">    // need to reserve scaled auxiliary buffer or use dev_out</a>
<a name="ln3650">    if(scaled)</a>
<a name="ln3651">    {</a>
<a name="ln3652">      dev_aux = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3653">      if(dev_aux == NULL) goto error;</a>
<a name="ln3654">      width = roi_in-&gt;width;</a>
<a name="ln3655">      height = roi_in-&gt;height;</a>
<a name="ln3656">    }</a>
<a name="ln3657">    else</a>
<a name="ln3658">      dev_aux = dev_out;</a>
<a name="ln3659"> </a>
<a name="ln3660">    dev_tmp = dt_opencl_alloc_device(devid, roi_in-&gt;width, roi_in-&gt;height, 4 * sizeof(float));</a>
<a name="ln3661">    if(dev_tmp == NULL) goto error;</a>
<a name="ln3662"> </a>
<a name="ln3663">    {</a>
<a name="ln3664">      // manage borders for linear interpolation part</a>
<a name="ln3665">      const int border = 1;</a>
<a name="ln3666"> </a>
<a name="ln3667">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3668">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3669">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3670">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3671">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3672">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 4, sizeof(int), (void *)&amp;border);</a>
<a name="ln3673">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3674">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3675">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 7, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3676">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3677">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_border_interpolate, sizes);</a>
<a name="ln3678">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3679">    }</a>
<a name="ln3680"> </a>
<a name="ln3681">    {</a>
<a name="ln3682">      // do linear interpolation</a>
<a name="ln3683">      dt_opencl_local_buffer_t locopt</a>
<a name="ln3684">        = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln3685">                                      .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln3686">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3687"> </a>
<a name="ln3688">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_vng_lin_interpolate, &amp;locopt))</a>
<a name="ln3689">        goto error;</a>
<a name="ln3690"> </a>
<a name="ln3691">      size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3692">      size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3693">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3694">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3695">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3696">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3697">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 4, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3698">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 5, sizeof(cl_mem), (void *)&amp;dev_lookup);</a>
<a name="ln3699">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_lin_interpolate, 6,</a>
<a name="ln3700">                               (locopt.sizex + 2) * (locopt.sizey + 2) * sizeof(float), NULL);</a>
<a name="ln3701">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_vng_lin_interpolate, sizes, local);</a>
<a name="ln3702">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3703">    }</a>
<a name="ln3704"> </a>
<a name="ln3705"> </a>
<a name="ln3706">    if(qual_flags &amp; DEMOSAIC_ONLY_VNG_LINEAR)</a>
<a name="ln3707">    {</a>
<a name="ln3708">      // leave it at linear interpolation and skip VNG</a>
<a name="ln3709">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3710">      size_t region[] = { width, height, 1 };</a>
<a name="ln3711">      err = dt_opencl_enqueue_copy_image(devid, dev_tmp, dev_aux, origin, origin, region);</a>
<a name="ln3712">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3713">    }</a>
<a name="ln3714">    else</a>
<a name="ln3715">    {</a>
<a name="ln3716">      // do full VNG interpolation</a>
<a name="ln3717">      dt_opencl_local_buffer_t locopt</a>
<a name="ln3718">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln3719">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln3720">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln3721"> </a>
<a name="ln3722">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_vng_interpolate, &amp;locopt))</a>
<a name="ln3723">        goto error;</a>
<a name="ln3724"> </a>
<a name="ln3725">      size_t sizes[3] = { ROUNDUP(width, locopt.sizex), ROUNDUP(height, locopt.sizey), 1 };</a>
<a name="ln3726">      size_t local[3] = { locopt.sizex, locopt.sizey, 1 };</a>
<a name="ln3727">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3728">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3729">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3730">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3731">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3732">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3733">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 6, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3734">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 7, 4*sizeof(float), (void *)processed_maximum);</a>
<a name="ln3735">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3736">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 9, sizeof(cl_mem), (void *)&amp;dev_ips);</a>
<a name="ln3737">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 10, sizeof(cl_mem), (void *)&amp;dev_code);</a>
<a name="ln3738">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_interpolate, 11, (locopt.sizex + 4) * (locopt.sizey + 4) * 4 * sizeof(float), NULL);</a>
<a name="ln3739">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_vng_interpolate, sizes, local);</a>
<a name="ln3740">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3741">    }</a>
<a name="ln3742"> </a>
<a name="ln3743">    {</a>
<a name="ln3744">      // manage borders</a>
<a name="ln3745">      const int border = 2;</a>
<a name="ln3746"> </a>
<a name="ln3747">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3748">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3749">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3750">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3751">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3752">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 4, sizeof(int), (void *)&amp;border);</a>
<a name="ln3753">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3754">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3755">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 7, sizeof(uint32_t), (void *)&amp;filters4);</a>
<a name="ln3756">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_border_interpolate, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3757">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_border_interpolate, sizes);</a>
<a name="ln3758">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3759">    }</a>
<a name="ln3760"> </a>
<a name="ln3761">    if(filters4 != 9)</a>
<a name="ln3762">    {</a>
<a name="ln3763">      // for Bayer sensors mix the two green channels</a>
<a name="ln3764">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3765">      size_t region[] = { width, height, 1 };</a>
<a name="ln3766">      err = dt_opencl_enqueue_copy_image(devid, dev_aux, dev_tmp, origin, origin, region);</a>
<a name="ln3767">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3768"> </a>
<a name="ln3769">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3770">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln3771">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln3772">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3773">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_vng_green_equilibrate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3774">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_vng_green_equilibrate, sizes);</a>
<a name="ln3775">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3776">    }</a>
<a name="ln3777"> </a>
<a name="ln3778">    if(scaled)</a>
<a name="ln3779">    {</a>
<a name="ln3780">      // scale temp buffer to output buffer</a>
<a name="ln3781">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_aux, roi_out, roi_in);</a>
<a name="ln3782">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3783">    }</a>
<a name="ln3784">  }</a>
<a name="ln3785">  else</a>
<a name="ln3786">  {</a>
<a name="ln3787">    // sample half-size or third-size image</a>
<a name="ln3788">    if(piece-&gt;pipe-&gt;dsc.filters == 9u)</a>
<a name="ln3789">    {</a>
<a name="ln3790">      const int width = roi_out-&gt;width;</a>
<a name="ln3791">      const int height = roi_out-&gt;height;</a>
<a name="ln3792"> </a>
<a name="ln3793">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3794">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3795">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3796">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3797">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3798">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln3799">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln3800">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3801">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3802">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3803">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 9, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln3804">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_third_size, sizes);</a>
<a name="ln3805">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3806">    }</a>
<a name="ln3807">    else</a>
<a name="ln3808">    {</a>
<a name="ln3809">      const int zero = 0;</a>
<a name="ln3810">      const int width = roi_out-&gt;width;</a>
<a name="ln3811">      const int height = roi_out-&gt;height;</a>
<a name="ln3812"> </a>
<a name="ln3813">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3814">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3815">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3816">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3817">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3818">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 4, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3819">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 5, sizeof(int), (void *)&amp;zero);</a>
<a name="ln3820">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln3821">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln3822">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln3823">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_half_size, 9, sizeof(uint32_t),</a>
<a name="ln3824">                               (void *)&amp;piece-&gt;pipe-&gt;dsc.filters);</a>
<a name="ln3825">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_half_size, sizes);</a>
<a name="ln3826">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln3827">    }</a>
<a name="ln3828">  }</a>
<a name="ln3829"> </a>
<a name="ln3830"> </a>
<a name="ln3831">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3832">  dev_aux = NULL;</a>
<a name="ln3833"> </a>
<a name="ln3834">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3835">  dev_tmp = NULL;</a>
<a name="ln3836"> </a>
<a name="ln3837">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln3838">  dev_xtrans = NULL;</a>
<a name="ln3839"> </a>
<a name="ln3840">  dt_opencl_release_mem_object(dev_lookup);</a>
<a name="ln3841">  dev_lookup = NULL;</a>
<a name="ln3842"> </a>
<a name="ln3843">  free(lookup);</a>
<a name="ln3844"> </a>
<a name="ln3845">  dt_opencl_release_mem_object(dev_code);</a>
<a name="ln3846">  dev_code = NULL;</a>
<a name="ln3847"> </a>
<a name="ln3848">  dt_opencl_release_mem_object(dev_ips);</a>
<a name="ln3849">  dev_ips = NULL;</a>
<a name="ln3850"> </a>
<a name="ln3851">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3852">  dev_green_eq = NULL;</a>
<a name="ln3853"> </a>
<a name="ln3854">  free(ips);</a>
<a name="ln3855">  ips = NULL;</a>
<a name="ln3856"> </a>
<a name="ln3857">  // color smoothing</a>
<a name="ln3858">  if(data-&gt;color_smoothing)</a>
<a name="ln3859">  {</a>
<a name="ln3860">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln3861">      goto error;</a>
<a name="ln3862">  }</a>
<a name="ln3863"> </a>
<a name="ln3864">  return TRUE;</a>
<a name="ln3865"> </a>
<a name="ln3866">error:</a>
<a name="ln3867">  if(dev_aux != dev_out) dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln3868">  dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln3869">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln3870">  dt_opencl_release_mem_object(dev_lookup);</a>
<a name="ln3871">  free(lookup);</a>
<a name="ln3872">  dt_opencl_release_mem_object(dev_code);</a>
<a name="ln3873">  dt_opencl_release_mem_object(dev_ips);</a>
<a name="ln3874">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln3875">  free(ips);</a>
<a name="ln3876">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3877">  return FALSE;</a>
<a name="ln3878">}</a>
<a name="ln3879"> </a>
<a name="ln3880">static int process_markesteijn_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in,</a>
<a name="ln3881">                                  cl_mem dev_out, const dt_iop_roi_t *const roi_in,</a>
<a name="ln3882">                                  const dt_iop_roi_t *const roi_out)</a>
<a name="ln3883">{</a>
<a name="ln3884">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln3885">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)self-&gt;global_data;</a>
<a name="ln3886"> </a>
<a name="ln3887">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln3888">  const uint8_t(*const xtrans)[6] = (const uint8_t(*const)[6])piece-&gt;pipe-&gt;dsc.xtrans;</a>
<a name="ln3889"> </a>
<a name="ln3890">  const float processed_maximum[4]</a>
<a name="ln3891">      = { piece-&gt;pipe-&gt;dsc.processed_maximum[0], piece-&gt;pipe-&gt;dsc.processed_maximum[1],</a>
<a name="ln3892">          piece-&gt;pipe-&gt;dsc.processed_maximum[2], 1.0f };</a>
<a name="ln3893"> </a>
<a name="ln3894">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln3895"> </a>
<a name="ln3896">  cl_mem dev_tmp = NULL;</a>
<a name="ln3897">  cl_mem dev_tmptmp = NULL;</a>
<a name="ln3898">  cl_mem dev_xtrans = NULL;</a>
<a name="ln3899">  cl_mem dev_green_eq = NULL;</a>
<a name="ln3900">  cl_mem dev_rgbv[8] = { NULL };</a>
<a name="ln3901">  cl_mem dev_drv[8] = { NULL };</a>
<a name="ln3902">  cl_mem dev_homo[8] = { NULL };</a>
<a name="ln3903">  cl_mem dev_homosum[8] = { NULL };</a>
<a name="ln3904">  cl_mem dev_gminmax = NULL;</a>
<a name="ln3905">  cl_mem dev_allhex = NULL;</a>
<a name="ln3906">  cl_mem dev_aux = NULL;</a>
<a name="ln3907">  cl_mem dev_edge_in = NULL;</a>
<a name="ln3908">  cl_mem dev_edge_out = NULL;</a>
<a name="ln3909">  cl_int err = -999;</a>
<a name="ln3910"> </a>
<a name="ln3911">  cl_mem *dev_rgb = dev_rgbv;</a>
<a name="ln3912"> </a>
<a name="ln3913">  dev_xtrans</a>
<a name="ln3914">      = dt_opencl_copy_host_to_device_constant(devid, sizeof(piece-&gt;pipe-&gt;dsc.xtrans), piece-&gt;pipe-&gt;dsc.xtrans);</a>
<a name="ln3915">  if(dev_xtrans == NULL) goto error;</a>
<a name="ln3916"> </a>
<a name="ln3917">  if(qual_flags &amp; DEMOSAIC_FULL_SCALE)</a>
<a name="ln3918">  {</a>
<a name="ln3919">    // Full demosaic and then scaling if needed</a>
<a name="ln3920">    const int scaled = (roi_out-&gt;width != roi_in-&gt;width || roi_out-&gt;height != roi_in-&gt;height);</a>
<a name="ln3921"> </a>
<a name="ln3922">    int width = roi_in-&gt;width;</a>
<a name="ln3923">    int height = roi_in-&gt;height;</a>
<a name="ln3924">    const int passes = (data-&gt;demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 3 : 1;</a>
<a name="ln3925">    const int ndir = 4 &lt;&lt; (passes &gt; 1);</a>
<a name="ln3926">    const int pad_tile = (passes == 1) ? 12 : 17;</a>
<a name="ln3927"> </a>
<a name="ln3928">    static const short orth[12] = { 1, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 1 },</a>
<a name="ln3929">                       patt[2][16] = { { 0, 1, 0, -1, 2, 0, -1, 0, 1, 1, 1, -1, 0, 0, 0, 0 },</a>
<a name="ln3930">                                       { 0, 1, 0, -2, 1, 0, -2, 0, 1, 1, -2, -2, 1, -1, -1, 1 } };</a>
<a name="ln3931"> </a>
<a name="ln3932">    // allhex contains the offset coordinates (x,y) of a green hexagon around each</a>
<a name="ln3933">    // non-green pixel and vice versa</a>
<a name="ln3934">    char allhex[3][3][8][2];</a>
<a name="ln3935">    // sgreen is the offset in the sensor matrix of the solitary</a>
<a name="ln3936">    // green pixels (initialized here only to avoid compiler warning)</a>
<a name="ln3937">    char sgreen[2] = { 0 };</a>
<a name="ln3938"> </a>
<a name="ln3939">    // Map a green hexagon around each non-green pixel and vice versa:</a>
<a name="ln3940">    for(int row = 0; row &lt; 3; row++)</a>
<a name="ln3941">      for(int col = 0; col &lt; 3; col++)</a>
<a name="ln3942">        for(int ng = 0, d = 0; d &lt; 10; d += 2)</a>
<a name="ln3943">        {</a>
<a name="ln3944">          int g = FCxtrans(row, col, NULL, xtrans) == 1;</a>
<a name="ln3945">          if(FCxtrans(row + orth[d] + 6, col + orth[d + 2] + 6, NULL, xtrans) == 1)</a>
<a name="ln3946">            ng = 0;</a>
<a name="ln3947">          else</a>
<a name="ln3948">            ng++;</a>
<a name="ln3949">          // if there are four non-green pixels adjacent in cardinal</a>
<a name="ln3950">          // directions, this is the solitary green pixel</a>
<a name="ln3951">          if(ng == 4)</a>
<a name="ln3952">          {</a>
<a name="ln3953">            sgreen[0] = col;</a>
<a name="ln3954">            sgreen[1] = row;</a>
<a name="ln3955">          }</a>
<a name="ln3956">          if(ng == g + 1)</a>
<a name="ln3957">            for(int c = 0; c &lt; 8; c++)</a>
<a name="ln3958">            {</a>
<a name="ln3959">              int v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];</a>
<a name="ln3960">              int h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];</a>
<a name="ln3961"> </a>
<a name="ln3962">              allhex[row][col][c ^ (g * 2 &amp; d)][0] = h;</a>
<a name="ln3963">              allhex[row][col][c ^ (g * 2 &amp; d)][1] = v;</a>
<a name="ln3964">            }</a>
<a name="ln3965">        }</a>
<a name="ln3966"> </a>
<a name="ln3967">    dev_allhex = dt_opencl_copy_host_to_device_constant(devid, sizeof(allhex), allhex);</a>
<a name="ln3968">    if(dev_allhex == NULL) goto error;</a>
<a name="ln3969"> </a>
<a name="ln3970">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln3971">    {</a>
<a name="ln3972">      dev_rgbv[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3973">      if(dev_rgbv[n] == NULL) goto error;</a>
<a name="ln3974">    }</a>
<a name="ln3975"> </a>
<a name="ln3976">    dev_gminmax = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 2 * sizeof(float));</a>
<a name="ln3977">    if(dev_gminmax == NULL) goto error;</a>
<a name="ln3978"> </a>
<a name="ln3979">    dev_aux = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln3980">    if(dev_aux == NULL) goto error;</a>
<a name="ln3981"> </a>
<a name="ln3982">    if(scaled)</a>
<a name="ln3983">    {</a>
<a name="ln3984">      // need to scale to right res</a>
<a name="ln3985">      dev_tmp = dt_opencl_alloc_device(devid, (size_t)width, height, 4 * sizeof(float));</a>
<a name="ln3986">      if(dev_tmp == NULL) goto error;</a>
<a name="ln3987">    }</a>
<a name="ln3988">    else</a>
<a name="ln3989">    {</a>
<a name="ln3990">      // scaling factor 1.0 --&gt; we can directly process into the output buffer</a>
<a name="ln3991">      dev_tmp = dev_out;</a>
<a name="ln3992">    }</a>
<a name="ln3993"> </a>
<a name="ln3994">    {</a>
<a name="ln3995">      // copy from dev_in to first rgb image buffer.</a>
<a name="ln3996">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3997">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3998">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln3999">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4000">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4001">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4002">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4003">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_initial_copy, 6, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4004">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_initial_copy, sizes);</a>
<a name="ln4005">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4006">    }</a>
<a name="ln4007"> </a>
<a name="ln4008"> </a>
<a name="ln4009">    // duplicate dev_rgb[0] to dev_rgb[1], dev_rgb[2], and dev_rgb[3]</a>
<a name="ln4010">    for(int c = 1; c &lt;= 3; c++)</a>
<a name="ln4011">    {</a>
<a name="ln4012">      err = dt_opencl_enqueue_copy_buffer_to_buffer(devid, dev_rgb[0], dev_rgb[c], 0, 0,</a>
<a name="ln4013">                                                    (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln4014">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4015">    }</a>
<a name="ln4016"> </a>
<a name="ln4017">    // find minimum and maximum allowed green values of red/blue pixel pairs</a>
<a name="ln4018">    const int pad_g1_g3 = 3;</a>
<a name="ln4019">    dt_opencl_local_buffer_t locopt_g1_g3</a>
<a name="ln4020">      = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln4021">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4022">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4023"> </a>
<a name="ln4024">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_green_minmax, &amp;locopt_g1_g3))</a>
<a name="ln4025">      goto error;</a>
<a name="ln4026"> </a>
<a name="ln4027">    {</a>
<a name="ln4028">      size_t sizes[3] = { ROUNDUP(width, locopt_g1_g3.sizex), ROUNDUP(height, locopt_g1_g3.sizey), 1 };</a>
<a name="ln4029">      size_t local[3] = { locopt_g1_g3.sizex, locopt_g1_g3.sizey, 1 };</a>
<a name="ln4030">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4031">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 1, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4032">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4033">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4034">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 4, sizeof(int), (void *)&amp;pad_g1_g3);</a>
<a name="ln4035">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4036">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4037">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4038">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4039">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 9, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4040">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_green_minmax, 10,</a>
<a name="ln4041">                               (locopt_g1_g3.sizex + 2*3) * (locopt_g1_g3.sizey + 2*3) * sizeof(float), NULL);</a>
<a name="ln4042">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_green_minmax, sizes, local);</a>
<a name="ln4043">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4044">    }</a>
<a name="ln4045"> </a>
<a name="ln4046">    // interpolate green horizontally, vertically, and along both diagonals</a>
<a name="ln4047">    const int pad_g_interp = 3;</a>
<a name="ln4048">    dt_opencl_local_buffer_t locopt_g_interp</a>
<a name="ln4049">      = (dt_opencl_local_buffer_t){ .xoffset = 2*6, .xfactor = 1, .yoffset = 2*6, .yfactor = 1,</a>
<a name="ln4050">                                    .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4051">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4052"> </a>
<a name="ln4053">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_interpolate_green, &amp;locopt_g_interp))</a>
<a name="ln4054">      goto error;</a>
<a name="ln4055"> </a>
<a name="ln4056">    {</a>
<a name="ln4057">      size_t sizes[3] = { ROUNDUP(width, locopt_g_interp.sizex), ROUNDUP(height, locopt_g_interp.sizey), 1 };</a>
<a name="ln4058">      size_t local[3] = { locopt_g_interp.sizex, locopt_g_interp.sizey, 1 };</a>
<a name="ln4059">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4060">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[1]);</a>
<a name="ln4061">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 2, sizeof(cl_mem), (void *)&amp;dev_rgb[2]);</a>
<a name="ln4062">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 3, sizeof(cl_mem), (void *)&amp;dev_rgb[3]);</a>
<a name="ln4063">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 4, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4064">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4065">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4066">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 7, sizeof(int), (void *)&amp;pad_g_interp);</a>
<a name="ln4067">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 8, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4068">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 9, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4069">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4070">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4071">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 12, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4072">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_green, 13,</a>
<a name="ln4073">                               (locopt_g_interp.sizex + 2*6) * (locopt_g_interp.sizey + 2*6) * 4 * sizeof(float), NULL);</a>
<a name="ln4074">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_interpolate_green, sizes, local);</a>
<a name="ln4075">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4076">    }</a>
<a name="ln4077"> </a>
<a name="ln4078">    // multi-pass loop: one pass for Markesteijn-1 and three passes for Markesteijn-3</a>
<a name="ln4079">    for(int pass = 0; pass &lt; passes; pass++)</a>
<a name="ln4080">    {</a>
<a name="ln4081"> </a>
<a name="ln4082">      // if on second pass, copy rgb[0] to [3] into rgb[4] to [7] ....</a>
<a name="ln4083">      if(pass == 1)</a>
<a name="ln4084">      {</a>
<a name="ln4085">        for(int c = 0; c &lt; 4; c++)</a>
<a name="ln4086">        {</a>
<a name="ln4087">          err = dt_opencl_enqueue_copy_buffer_to_buffer(devid, dev_rgb[c], dev_rgb[c + 4], 0, 0,</a>
<a name="ln4088">                                                        (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln4089">          if(err != CL_SUCCESS) goto error;</a>
<a name="ln4090">        }</a>
<a name="ln4091">        // ... and process that second set of buffers</a>
<a name="ln4092">        dev_rgb += 4;</a>
<a name="ln4093">      }</a>
<a name="ln4094"> </a>
<a name="ln4095">      // second and third pass (only Markesteijn-3)</a>
<a name="ln4096">      if(pass)</a>
<a name="ln4097">      {</a>
<a name="ln4098">        // recalculate green from interpolated values of closer pixels</a>
<a name="ln4099">        const int pad_g_recalc = 6;</a>
<a name="ln4100">        size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4101">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[0]);</a>
<a name="ln4102">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 1, sizeof(cl_mem), (void *)&amp;dev_rgb[1]);</a>
<a name="ln4103">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 2, sizeof(cl_mem), (void *)&amp;dev_rgb[2]);</a>
<a name="ln4104">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 3, sizeof(cl_mem), (void *)&amp;dev_rgb[3]);</a>
<a name="ln4105">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 4, sizeof(cl_mem), (void *)&amp;dev_gminmax);</a>
<a name="ln4106">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4107">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4108">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 7, sizeof(int), (void *)&amp;pad_g_recalc);</a>
<a name="ln4109">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 8, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4110">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 9, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4111">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4112">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4113">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_recalculate_green, 12, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4114">        err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_recalculate_green, sizes);</a>
<a name="ln4115">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4116">      }</a>
<a name="ln4117"> </a>
<a name="ln4118">      // interpolate red and blue values for solitary green pixels</a>
<a name="ln4119">      const int pad_rb_g = (passes == 1) ? 6 : 5;</a>
<a name="ln4120">      dt_opencl_local_buffer_t locopt_rb_g</a>
<a name="ln4121">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4122">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4123">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4124"> </a>
<a name="ln4125">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_solitary_green, &amp;locopt_rb_g))</a>
<a name="ln4126">      goto error;</a>
<a name="ln4127"> </a>
<a name="ln4128">      cl_mem *dev_trgb = dev_rgb;</a>
<a name="ln4129">      for(int d = 0, i = 1, h = 0; d &lt; 6; d++, i ^= 1, h ^= 2)</a>
<a name="ln4130">      {</a>
<a name="ln4131">        const char dir[2] = { i, i ^ 1 };</a>
<a name="ln4132"> </a>
<a name="ln4133">        // we use dev_aux to transport intermediate results from one loop run to the next</a>
<a name="ln4134">        size_t sizes[3] = { ROUNDUP(width, locopt_rb_g.sizex), ROUNDUP(height, locopt_rb_g.sizey), 1 };</a>
<a name="ln4135">        size_t local[3] = { locopt_rb_g.sizex, locopt_rb_g.sizey, 1 };</a>
<a name="ln4136">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 0, sizeof(cl_mem), (void *)&amp;dev_trgb[0]);</a>
<a name="ln4137">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4138">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4139">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4140">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 4, sizeof(int), (void *)&amp;pad_rb_g);</a>
<a name="ln4141">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 5, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4142">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 6, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4143">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 7, sizeof(int), (void *)&amp;d);</a>
<a name="ln4144">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 8, 2 * sizeof(char), (void *)dir);</a>
<a name="ln4145">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 9, sizeof(int), (void *)&amp;h);</a>
<a name="ln4146">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 10, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4147">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 11, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4148">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_solitary_green, 12,</a>
<a name="ln4149">                                (locopt_rb_g.sizex + 2*2) * (locopt_rb_g.sizey + 2*2) * 4 * sizeof(float), NULL);</a>
<a name="ln4150">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_solitary_green, sizes, local);</a>
<a name="ln4151">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4152"> </a>
<a name="ln4153">        if((d &lt; 2) || (d &amp; 1)) dev_trgb++;</a>
<a name="ln4154">      }</a>
<a name="ln4155"> </a>
<a name="ln4156">      // interpolate red for blue pixels and vice versa</a>
<a name="ln4157">      const int pad_rb_br = (passes == 1) ? 6 : 5;</a>
<a name="ln4158">      dt_opencl_local_buffer_t locopt_rb_br</a>
<a name="ln4159">        = (dt_opencl_local_buffer_t){ .xoffset = 2*3, .xfactor = 1, .yoffset = 2*3, .yfactor = 1,</a>
<a name="ln4160">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4161">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4162"> </a>
<a name="ln4163">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_red_and_blue, &amp;locopt_rb_br))</a>
<a name="ln4164">      goto error;</a>
<a name="ln4165"> </a>
<a name="ln4166">      for(int d = 0; d &lt; 4; d++)</a>
<a name="ln4167">      {</a>
<a name="ln4168">        size_t sizes[3] = { ROUNDUP(width, locopt_rb_br.sizex), ROUNDUP(height, locopt_rb_br.sizey), 1 };</a>
<a name="ln4169">        size_t local[3] = { locopt_rb_br.sizex, locopt_rb_br.sizey, 1 };</a>
<a name="ln4170">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[d]);</a>
<a name="ln4171">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4172">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4173">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 3, sizeof(int), (void *)&amp;pad_rb_br);</a>
<a name="ln4174">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4175">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4176">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 6, sizeof(int), (void *)&amp;d);</a>
<a name="ln4177">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4178">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4179">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_red_and_blue, 9,</a>
<a name="ln4180">                                (locopt_rb_br.sizex + 2*3) * (locopt_rb_br.sizey + 2*3) * 4 * sizeof(float), NULL);</a>
<a name="ln4181">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_red_and_blue, sizes, local);</a>
<a name="ln4182">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4183">      }</a>
<a name="ln4184"> </a>
<a name="ln4185">      // interpolate red and blue for 2x2 blocks of green</a>
<a name="ln4186">      const int pad_g22 = (passes == 1) ? 8 : 4;</a>
<a name="ln4187">      dt_opencl_local_buffer_t locopt_g22</a>
<a name="ln4188">        = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4189">                                      .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4190">                                      .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4191"> </a>
<a name="ln4192">      if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, &amp;locopt_g22))</a>
<a name="ln4193">      goto error;</a>
<a name="ln4194"> </a>
<a name="ln4195">      for(int d = 0, n = 0; d &lt; ndir; d += 2, n++)</a>
<a name="ln4196">      {</a>
<a name="ln4197">        size_t sizes[3] = { ROUNDUP(width, locopt_g22.sizex), ROUNDUP(height, locopt_g22.sizey), 1 };</a>
<a name="ln4198">        size_t local[3] = { locopt_g22.sizex, locopt_g22.sizey, 1 };</a>
<a name="ln4199">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[n]);</a>
<a name="ln4200">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4201">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4202">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 3, sizeof(int), (void *)&amp;pad_g22);</a>
<a name="ln4203">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4204">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4205">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 6, sizeof(int), (void *)&amp;d);</a>
<a name="ln4206">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 7, 2 * sizeof(char), (void *)sgreen);</a>
<a name="ln4207">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 8, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4208">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 9, sizeof(cl_mem), (void *)&amp;dev_allhex);</a>
<a name="ln4209">        dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, 10,</a>
<a name="ln4210">                                (locopt_g22.sizex + 2*2) * (locopt_g22.sizey + 2*2) * 4 * sizeof(float), NULL);</a>
<a name="ln4211">        err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_interpolate_twoxtwo, sizes, local);</a>
<a name="ln4212">        if(err != CL_SUCCESS) goto error;</a>
<a name="ln4213">      }</a>
<a name="ln4214">    }</a>
<a name="ln4215">    // end of multi pass</a>
<a name="ln4216"> </a>
<a name="ln4217">    // gminmax data no longer needed</a>
<a name="ln4218">    dt_opencl_release_mem_object(dev_gminmax);</a>
<a name="ln4219">    dev_gminmax = NULL;</a>
<a name="ln4220"> </a>
<a name="ln4221">    // jump back to the first set of rgb buffers (this is a noop for Markesteijn-1)</a>
<a name="ln4222">    dev_rgb = dev_rgbv;</a>
<a name="ln4223"> </a>
<a name="ln4224">    // prepare derivatives buffers</a>
<a name="ln4225">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln4226">    {</a>
<a name="ln4227">      dev_drv[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(float));</a>
<a name="ln4228">      if(dev_drv[n] == NULL) goto error;</a>
<a name="ln4229">    }</a>
<a name="ln4230"> </a>
<a name="ln4231">    // convert to perceptual colorspace and differentiate in all directions</a>
<a name="ln4232">    const int pad_yuv = (passes == 1) ? 8 : 13;</a>
<a name="ln4233">    dt_opencl_local_buffer_t locopt_diff</a>
<a name="ln4234">      = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln4235">                                    .cellsize = 4 * sizeof(float), .overhead = 0,</a>
<a name="ln4236">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4237"> </a>
<a name="ln4238">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_differentiate, &amp;locopt_diff))</a>
<a name="ln4239">    goto error;</a>
<a name="ln4240"> </a>
<a name="ln4241">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4242">    {</a>
<a name="ln4243">      // convert to perceptual YPbPr colorspace</a>
<a name="ln4244">      size_t sizes_yuv[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4245">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 0, sizeof(cl_mem), (void *)&amp;dev_rgb[d]);</a>
<a name="ln4246">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4247">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4248">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4249">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_convert_yuv, 4, sizeof(int), (void *)&amp;pad_yuv);</a>
<a name="ln4250">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_convert_yuv, sizes_yuv);</a>
<a name="ln4251">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4252"> </a>
<a name="ln4253"> </a>
<a name="ln4254">      // differentiate in all directions</a>
<a name="ln4255">      size_t sizes_diff[3] = { ROUNDUP(width, locopt_diff.sizex), ROUNDUP(height, locopt_diff.sizey), 1 };</a>
<a name="ln4256">      size_t local_diff[3] = { locopt_diff.sizex, locopt_diff.sizey, 1 };</a>
<a name="ln4257">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 0, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4258">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 1, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4259">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4260">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4261">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 4, sizeof(int), (void *)&amp;pad_yuv);</a>
<a name="ln4262">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4263">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_differentiate, 6,</a>
<a name="ln4264">                              (locopt_diff.sizex + 2*1) * (locopt_diff.sizey + 2*1) * 4 * sizeof(float), NULL);</a>
<a name="ln4265">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_differentiate, sizes_diff, local_diff);</a>
<a name="ln4266">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4267">    }</a>
<a name="ln4268"> </a>
<a name="ln4269">    // reserve buffers for homogeneity maps and sum maps</a>
<a name="ln4270">    for(int n = 0; n &lt; ndir; n++)</a>
<a name="ln4271">    {</a>
<a name="ln4272">      dev_homo[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(unsigned char));</a>
<a name="ln4273">      if(dev_homo[n] == NULL) goto error;</a>
<a name="ln4274"> </a>
<a name="ln4275">      dev_homosum[n] = dt_opencl_alloc_device_buffer(devid, (size_t)width * height * sizeof(unsigned char));</a>
<a name="ln4276">      if(dev_homosum[n] == NULL) goto error;</a>
<a name="ln4277">    }</a>
<a name="ln4278"> </a>
<a name="ln4279">    // get thresholds for homogeneity map (store them in dev_aux)</a>
<a name="ln4280">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4281">    {</a>
<a name="ln4282">      const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln4283">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4284">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 0, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4285">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4286">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4287">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4288">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 4, sizeof(int), (void *)&amp;pad_homo);</a>
<a name="ln4289">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_threshold, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4290">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_threshold, sizes);</a>
<a name="ln4291">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4292">    }</a>
<a name="ln4293"> </a>
<a name="ln4294">    // set homogeneity maps</a>
<a name="ln4295">    const int pad_homo = (passes == 1) ? 10 : 15;</a>
<a name="ln4296">    dt_opencl_local_buffer_t locopt_homo</a>
<a name="ln4297">      = (dt_opencl_local_buffer_t){ .xoffset = 2*1, .xfactor = 1, .yoffset = 2*1, .yfactor = 1,</a>
<a name="ln4298">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4299">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4300"> </a>
<a name="ln4301">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_homo_set, &amp;locopt_homo))</a>
<a name="ln4302">    goto error;</a>
<a name="ln4303"> </a>
<a name="ln4304">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4305">    {</a>
<a name="ln4306">      size_t sizes[3] = { ROUNDUP(width, locopt_homo.sizex),ROUNDUP(height, locopt_homo.sizey), 1 };</a>
<a name="ln4307">      size_t local[3] = { locopt_homo.sizex, locopt_homo.sizey, 1 };</a>
<a name="ln4308">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 0, sizeof(cl_mem), (void *)&amp;dev_drv[d]);</a>
<a name="ln4309">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4310">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 2, sizeof(cl_mem), (void *)&amp;dev_homo[d]);</a>
<a name="ln4311">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 3, sizeof(int), (void *)&amp;width);</a>
<a name="ln4312">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 4, sizeof(int), (void *)&amp;height);</a>
<a name="ln4313">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 5, sizeof(int), (void *)&amp;pad_homo);</a>
<a name="ln4314">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_set, 6,</a>
<a name="ln4315">                              (locopt_homo.sizex + 2*1) * (locopt_homo.sizey + 2*1) * sizeof(float), NULL);</a>
<a name="ln4316">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_homo_set, sizes, local);</a>
<a name="ln4317">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4318">    }</a>
<a name="ln4319"> </a>
<a name="ln4320">    // get rid of dev_drv buffers</a>
<a name="ln4321">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4322">    {</a>
<a name="ln4323">      dt_opencl_release_mem_object(dev_drv[n]);</a>
<a name="ln4324">      dev_drv[n] = NULL;</a>
<a name="ln4325">    }</a>
<a name="ln4326"> </a>
<a name="ln4327">    // build 5x5 sum of homogeneity maps for each pixel and direction</a>
<a name="ln4328">    dt_opencl_local_buffer_t locopt_homo_sum</a>
<a name="ln4329">      = (dt_opencl_local_buffer_t){ .xoffset = 2*2, .xfactor = 1, .yoffset = 2*2, .yfactor = 1,</a>
<a name="ln4330">                                    .cellsize = 1 * sizeof(float), .overhead = 0,</a>
<a name="ln4331">                                    .sizex = 1 &lt;&lt; 8, .sizey = 1 &lt;&lt; 8 };</a>
<a name="ln4332"> </a>
<a name="ln4333">    if(!dt_opencl_local_buffer_opt(devid, gd-&gt;kernel_markesteijn_homo_sum, &amp;locopt_homo_sum))</a>
<a name="ln4334">    goto error;</a>
<a name="ln4335"> </a>
<a name="ln4336">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4337">    {</a>
<a name="ln4338">      size_t sizes[3] = { ROUNDUP(width, locopt_homo_sum.sizex), ROUNDUP(height, locopt_homo_sum.sizey), 1 };</a>
<a name="ln4339">      size_t local[3] = { locopt_homo_sum.sizex, locopt_homo_sum.sizey, 1 };</a>
<a name="ln4340">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 0, sizeof(cl_mem), (void *)&amp;dev_homo[d]);</a>
<a name="ln4341">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 1, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4342">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4343">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4344">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4345">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_sum, 5,</a>
<a name="ln4346">                              (locopt_homo_sum.sizex + 2*2) * (locopt_homo_sum.sizey + 2*2) * sizeof(char), NULL);</a>
<a name="ln4347">      err = dt_opencl_enqueue_kernel_2d_with_local(devid, gd-&gt;kernel_markesteijn_homo_sum, sizes, local);</a>
<a name="ln4348">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4349">    }</a>
<a name="ln4350"> </a>
<a name="ln4351">    // get maximum of homogeneity maps (store in dev_aux)</a>
<a name="ln4352">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4353">    {</a>
<a name="ln4354">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4355">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 0, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4356">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 1, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4357">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4358">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4359">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4360">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max, 5, sizeof(int), (void *)&amp;d);</a>
<a name="ln4361">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_max, sizes);</a>
<a name="ln4362">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4363">    }</a>
<a name="ln4364"> </a>
<a name="ln4365">    {</a>
<a name="ln4366">      // adjust maximum value</a>
<a name="ln4367">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4368">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 0, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4369">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4370">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4371">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_max_corr, 3, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4372">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_max_corr, sizes);</a>
<a name="ln4373">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4374">    }</a>
<a name="ln4375"> </a>
<a name="ln4376">    // for Markesteijn-3: use only one of two directions if there is a difference in homogeneity</a>
<a name="ln4377">    for(int d = 0; d &lt; ndir - 4; d++)</a>
<a name="ln4378">    {</a>
<a name="ln4379">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4380">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 0, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4381">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 1, sizeof(cl_mem), (void *)&amp;dev_homosum[d + 4]);</a>
<a name="ln4382">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4383">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4384">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_homo_quench, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4385">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_homo_quench, sizes);</a>
<a name="ln4386">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4387">    }</a>
<a name="ln4388"> </a>
<a name="ln4389">    {</a>
<a name="ln4390">      // initialize output buffer to zero</a>
<a name="ln4391">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4392">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 0, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln4393">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 1, sizeof(int), (void *)&amp;width);</a>
<a name="ln4394">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 2, sizeof(int), (void *)&amp;height);</a>
<a name="ln4395">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_zero, 3, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4396">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_zero, sizes);</a>
<a name="ln4397">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4398">    }</a>
<a name="ln4399"> </a>
<a name="ln4400">    // need to get another temp buffer for the output image (may use the space of dev_drv[] freed earlier)</a>
<a name="ln4401">    dev_tmptmp = dt_opencl_alloc_device(devid, (size_t)width, height, 4 * sizeof(float));</a>
<a name="ln4402">    if(dev_tmptmp == NULL) goto error;</a>
<a name="ln4403"> </a>
<a name="ln4404">    cl_mem dev_t1 = dev_tmp;</a>
<a name="ln4405">    cl_mem dev_t2 = dev_tmptmp;</a>
<a name="ln4406"> </a>
<a name="ln4407">    // accumulate all contributions</a>
<a name="ln4408">    for(int d = 0; d &lt; ndir; d++)</a>
<a name="ln4409">    {</a>
<a name="ln4410">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4411">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 0, sizeof(cl_mem), (void *)&amp;dev_t1);</a>
<a name="ln4412">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 1, sizeof(cl_mem), (void *)&amp;dev_t2);</a>
<a name="ln4413">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 2, sizeof(cl_mem), (void *)&amp;dev_rgbv[d]);</a>
<a name="ln4414">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 3, sizeof(cl_mem), (void *)&amp;dev_homosum[d]);</a>
<a name="ln4415">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 4, sizeof(cl_mem), (void *)&amp;dev_aux);</a>
<a name="ln4416">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 5, sizeof(int), (void *)&amp;width);</a>
<a name="ln4417">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 6, sizeof(int), (void *)&amp;height);</a>
<a name="ln4418">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_accu, 7, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4419">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_accu, sizes);</a>
<a name="ln4420">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4421"> </a>
<a name="ln4422">      // swap buffers</a>
<a name="ln4423">      cl_mem dev_t = dev_t2;</a>
<a name="ln4424">      dev_t2 = dev_t1;</a>
<a name="ln4425">      dev_t1 = dev_t;</a>
<a name="ln4426">    }</a>
<a name="ln4427"> </a>
<a name="ln4428">    // copy output to dev_tmptmp (if not already there)</a>
<a name="ln4429">    // note: we need to take swap of buffers into account, so current output lies in dev_t1</a>
<a name="ln4430">    if(dev_t1 != dev_tmptmp)</a>
<a name="ln4431">    {</a>
<a name="ln4432">      size_t origin[] = { 0, 0, 0 };</a>
<a name="ln4433">      size_t region[] = { width, height, 1 };</a>
<a name="ln4434">      err = dt_opencl_enqueue_copy_image(devid, dev_t1, dev_tmptmp, origin, origin, region);</a>
<a name="ln4435">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4436">    }</a>
<a name="ln4437"> </a>
<a name="ln4438">    {</a>
<a name="ln4439">      // process the final image</a>
<a name="ln4440">      size_t sizes[3] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln4441">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 0, sizeof(cl_mem), (void *)&amp;dev_tmptmp);</a>
<a name="ln4442">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 1, sizeof(cl_mem), (void *)&amp;dev_tmp);</a>
<a name="ln4443">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln4444">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln4445">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 4, sizeof(int), (void *)&amp;pad_tile);</a>
<a name="ln4446">      dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_markesteijn_final, 5, 4*sizeof(float), (void *)processed_maximum);</a>
<a name="ln4447">      err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_markesteijn_final, sizes);</a>
<a name="ln4448">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4449">    }</a>
<a name="ln4450"> </a>
<a name="ln4451">    // now it's time to get rid of most of the temporary buffers (except of dev_tmp and dev_xtrans)</a>
<a name="ln4452">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4453">    {</a>
<a name="ln4454">      dt_opencl_release_mem_object(dev_rgbv[n]);</a>
<a name="ln4455">      dev_rgbv[n] = NULL;</a>
<a name="ln4456">    }</a>
<a name="ln4457"> </a>
<a name="ln4458">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4459">    {</a>
<a name="ln4460">      dt_opencl_release_mem_object(dev_homo[n]);</a>
<a name="ln4461">      dev_homo[n] = NULL;</a>
<a name="ln4462">    }</a>
<a name="ln4463"> </a>
<a name="ln4464">    for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4465">    {</a>
<a name="ln4466">      dt_opencl_release_mem_object(dev_homosum[n]);</a>
<a name="ln4467">      dev_homosum[n] = NULL;</a>
<a name="ln4468">    }</a>
<a name="ln4469"> </a>
<a name="ln4470">    dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln4471">    dev_aux = NULL;</a>
<a name="ln4472"> </a>
<a name="ln4473">    dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4474">    dev_xtrans = NULL;</a>
<a name="ln4475"> </a>
<a name="ln4476">    dt_opencl_release_mem_object(dev_allhex);</a>
<a name="ln4477">    dev_allhex = NULL;</a>
<a name="ln4478"> </a>
<a name="ln4479">    dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln4480">    dev_green_eq = NULL;</a>
<a name="ln4481"> </a>
<a name="ln4482">    dt_opencl_release_mem_object(dev_tmptmp);</a>
<a name="ln4483">    dev_tmptmp = NULL;</a>
<a name="ln4484"> </a>
<a name="ln4485">    // take care of image borders. the algorithm above leaves an unprocessed border of pad_tile pixels.</a>
<a name="ln4486">    // strategy: take the four edges and process them each with process_vng_cl(). as VNG produces</a>
<a name="ln4487">    // an image with a border with only linear interpolation we process edges of pad_tile+3px and</a>
<a name="ln4488">    // drop 3px on the inner side if possible</a>
<a name="ln4489"> </a>
<a name="ln4490">    // take care of some degenerate cases (which might happen if we are called in a tiling context)</a>
<a name="ln4491">    const int wd = (width &gt; pad_tile+3) ? pad_tile+3 : width;</a>
<a name="ln4492">    const int ht = (height &gt; pad_tile+3) ? pad_tile+3 : height;</a>
<a name="ln4493">    const int wdc = (wd &gt;= pad_tile+3) ? 3 : 0;</a>
<a name="ln4494">    const int htc = (ht &gt;= pad_tile+3) ? 3 : 0;</a>
<a name="ln4495"> </a>
<a name="ln4496">    // the data of all four edges:</a>
<a name="ln4497">    // total edge: x-offset, y-offset, width, height,</a>
<a name="ln4498">    // after dropping: x-offset adjust, y-offset adjust, width adjust, height adjust</a>
<a name="ln4499">    const int edges[4][8] = { { 0, 0, wd, height, 0, 0, -wdc, 0 },</a>
<a name="ln4500">                              { 0, 0, width, ht, 0, 0, 0, -htc },</a>
<a name="ln4501">                              { width - wd, 0, wd, height, wdc, 0, -wdc, 0 },</a>
<a name="ln4502">                              { 0, height - ht, width, ht, 0, htc, 0, -htc } };</a>
<a name="ln4503"> </a>
<a name="ln4504">    for(int n = 0; n &lt; 4; n++)</a>
<a name="ln4505">    {</a>
<a name="ln4506">      dt_iop_roi_t roi = { roi_in-&gt;x + edges[n][0], roi_in-&gt;y + edges[n][1], edges[n][2], edges[n][3], 1.0f };</a>
<a name="ln4507"> </a>
<a name="ln4508">      size_t iorigin[] = { edges[n][0], edges[n][1], 0 };</a>
<a name="ln4509">      size_t oorigin[] = { 0, 0, 0 };</a>
<a name="ln4510">      size_t region[] = { edges[n][2], edges[n][3], 1 };</a>
<a name="ln4511"> </a>
<a name="ln4512">      // reserve input buffer for image edge</a>
<a name="ln4513">      dev_edge_in = dt_opencl_alloc_device(devid, edges[n][2], edges[n][3], sizeof(float));</a>
<a name="ln4514">      if(dev_edge_in == NULL) goto error;</a>
<a name="ln4515"> </a>
<a name="ln4516">      // reserve output buffer for VNG processing of edge</a>
<a name="ln4517">      dev_edge_out = dt_opencl_alloc_device(devid, edges[n][2], edges[n][3], 4 * sizeof(float));</a>
<a name="ln4518">      if(dev_edge_out == NULL) goto error;</a>
<a name="ln4519"> </a>
<a name="ln4520">      // copy edge to input buffer</a>
<a name="ln4521">      err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_edge_in, iorigin, oorigin, region);</a>
<a name="ln4522">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4523"> </a>
<a name="ln4524">      // VNG processing</a>
<a name="ln4525">      if(!process_vng_cl(self, piece, dev_edge_in, dev_edge_out, &amp;roi, &amp;roi))</a>
<a name="ln4526">        goto error;</a>
<a name="ln4527"> </a>
<a name="ln4528">      // adjust for &quot;good&quot; part, dropping linear border where possible</a>
<a name="ln4529">      iorigin[0] += edges[n][4];</a>
<a name="ln4530">      iorigin[1] += edges[n][5];</a>
<a name="ln4531">      oorigin[0] += edges[n][4];</a>
<a name="ln4532">      oorigin[1] += edges[n][5];</a>
<a name="ln4533">      region[0] += edges[n][6];</a>
<a name="ln4534">      region[1] += edges[n][7];</a>
<a name="ln4535"> </a>
<a name="ln4536">      // copy output</a>
<a name="ln4537">      err = dt_opencl_enqueue_copy_image(devid, dev_edge_out, dev_tmp, oorigin, iorigin, region);</a>
<a name="ln4538">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4539"> </a>
<a name="ln4540">      // release intermediate buffers</a>
<a name="ln4541">      dt_opencl_release_mem_object(dev_edge_in);</a>
<a name="ln4542">      dt_opencl_release_mem_object(dev_edge_out);</a>
<a name="ln4543">      dev_edge_in = dev_edge_out = NULL;</a>
<a name="ln4544">    }</a>
<a name="ln4545"> </a>
<a name="ln4546"> </a>
<a name="ln4547">    if(scaled)</a>
<a name="ln4548">    {</a>
<a name="ln4549">      // scale temp buffer to output buffer</a>
<a name="ln4550">      err = dt_iop_clip_and_zoom_roi_cl(devid, dev_out, dev_tmp, roi_out, roi_in);</a>
<a name="ln4551">      if(err != CL_SUCCESS) goto error;</a>
<a name="ln4552">    }</a>
<a name="ln4553">  }</a>
<a name="ln4554">  else</a>
<a name="ln4555">  {</a>
<a name="ln4556">    // sample third-size image</a>
<a name="ln4557">    const int width = roi_out-&gt;width;</a>
<a name="ln4558">    const int height = roi_out-&gt;height;</a>
<a name="ln4559"> </a>
<a name="ln4560">    size_t sizes[2] = { ROUNDUPWD(width), ROUNDUPHT(height) };</a>
<a name="ln4561">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 0, sizeof(cl_mem), &amp;dev_in);</a>
<a name="ln4562">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 1, sizeof(cl_mem), &amp;dev_out);</a>
<a name="ln4563">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 2, sizeof(int), &amp;width);</a>
<a name="ln4564">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 3, sizeof(int), &amp;height);</a>
<a name="ln4565">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 4, sizeof(int), (void *)&amp;roi_in-&gt;x);</a>
<a name="ln4566">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 5, sizeof(int), (void *)&amp;roi_in-&gt;y);</a>
<a name="ln4567">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 6, sizeof(int), (void *)&amp;roi_in-&gt;width);</a>
<a name="ln4568">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 7, sizeof(int), (void *)&amp;roi_in-&gt;height);</a>
<a name="ln4569">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 8, sizeof(float), (void *)&amp;roi_out-&gt;scale);</a>
<a name="ln4570">    dt_opencl_set_kernel_arg(devid, gd-&gt;kernel_zoom_third_size, 9, sizeof(cl_mem), (void *)&amp;dev_xtrans);</a>
<a name="ln4571">    err = dt_opencl_enqueue_kernel_2d(devid, gd-&gt;kernel_zoom_third_size, sizes);</a>
<a name="ln4572">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln4573">  }</a>
<a name="ln4574"> </a>
<a name="ln4575">  // free remaining temporary buffers</a>
<a name="ln4576">  if(dev_tmp != dev_out) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln4577">  dev_tmp = NULL;</a>
<a name="ln4578"> </a>
<a name="ln4579">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4580">  dev_xtrans = NULL;</a>
<a name="ln4581"> </a>
<a name="ln4582"> </a>
<a name="ln4583">  // color smoothing</a>
<a name="ln4584">  if(data-&gt;color_smoothing)</a>
<a name="ln4585">  {</a>
<a name="ln4586">    if(!color_smoothing_cl(self, piece, dev_out, dev_out, roi_out))</a>
<a name="ln4587">      goto error;</a>
<a name="ln4588">  }</a>
<a name="ln4589"> </a>
<a name="ln4590">  return TRUE;</a>
<a name="ln4591"> </a>
<a name="ln4592">error:</a>
<a name="ln4593">  if(dev_tmp != dev_out) dt_opencl_release_mem_object(dev_tmp);</a>
<a name="ln4594"> </a>
<a name="ln4595">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4596">    dt_opencl_release_mem_object(dev_rgbv[n]);</a>
<a name="ln4597">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4598">    dt_opencl_release_mem_object(dev_drv[n]);</a>
<a name="ln4599">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4600">    dt_opencl_release_mem_object(dev_homo[n]);</a>
<a name="ln4601">  for(int n = 0; n &lt; 8; n++)</a>
<a name="ln4602">    dt_opencl_release_mem_object(dev_homosum[n]);</a>
<a name="ln4603">  dt_opencl_release_mem_object(dev_gminmax);</a>
<a name="ln4604">  dt_opencl_release_mem_object(dev_tmptmp);</a>
<a name="ln4605">  dt_opencl_release_mem_object(dev_xtrans);</a>
<a name="ln4606">  dt_opencl_release_mem_object(dev_allhex);</a>
<a name="ln4607">  dt_opencl_release_mem_object(dev_green_eq);</a>
<a name="ln4608">  dt_opencl_release_mem_object(dev_aux);</a>
<a name="ln4609">  dt_opencl_release_mem_object(dev_edge_in);</a>
<a name="ln4610">  dt_opencl_release_mem_object(dev_edge_out);</a>
<a name="ln4611">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln4612">  return FALSE;</a>
<a name="ln4613">}</a>
<a name="ln4614"> </a>
<a name="ln4615">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln4616">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln4617">{</a>
<a name="ln4618">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4619">  const int demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln4620">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln4621"> </a>
<a name="ln4622">  if(demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME || demosaicing_method == DT_IOP_DEMOSAIC_PPG)</a>
<a name="ln4623">  {</a>
<a name="ln4624">    return process_default_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4625">  }</a>
<a name="ln4626">  else if(demosaicing_method ==  DT_IOP_DEMOSAIC_VNG4 || demosaicing_method == DT_IOP_DEMOSAIC_VNG)</a>
<a name="ln4627">  {</a>
<a name="ln4628">    return process_vng_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4629">  }</a>
<a name="ln4630">  else if((demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN || demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) &amp;&amp;</a>
<a name="ln4631">    !(qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln4632">  {</a>
<a name="ln4633">    return process_vng_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4634">  }</a>
<a name="ln4635">  else if(demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN || demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3)</a>
<a name="ln4636">  {</a>
<a name="ln4637">    return process_markesteijn_cl(self, piece, dev_in, dev_out, roi_in, roi_out);</a>
<a name="ln4638">  }</a>
<a name="ln4639">  else</a>
<a name="ln4640">  {</a>
<a name="ln4641">    dt_print(DT_DEBUG_OPENCL, &quot;[opencl_demosaic] demosaicing method '%s' not yet supported by opencl code\n&quot;, method2string(demosaicing_method));</a>
<a name="ln4642">    return FALSE;</a>
<a name="ln4643">  }</a>
<a name="ln4644">}</a>
<a name="ln4645">#endif</a>
<a name="ln4646"> </a>
<a name="ln4647">void tiling_callback(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln4648">                     const dt_iop_roi_t *roi_in, const dt_iop_roi_t *roi_out,</a>
<a name="ln4649">                     struct dt_develop_tiling_t *tiling)</a>
<a name="ln4650">{</a>
<a name="ln4651">  dt_iop_demosaic_data_t *data = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4652"> </a>
<a name="ln4653">  const float ioratio = (float)roi_out-&gt;width * roi_out-&gt;height / ((float)roi_in-&gt;width * roi_in-&gt;height);</a>
<a name="ln4654">  const float smooth = data-&gt;color_smoothing ? ioratio : 0.0f;</a>
<a name="ln4655">  const float greeneq</a>
<a name="ln4656">      = ((piece-&gt;pipe-&gt;dsc.filters != 9u) &amp;&amp; (data-&gt;green_eq != DT_IOP_GREEN_EQ_NO)) ? 0.25f : 0.0f;</a>
<a name="ln4657">  const dt_iop_demosaic_method_t demosaicing_method = data-&gt;demosaicing_method;</a>
<a name="ln4658"> </a>
<a name="ln4659">  const int qual_flags = demosaic_qual_flags(piece, &amp;self-&gt;dev-&gt;image_storage, roi_out);</a>
<a name="ln4660">  const int full_scale_demosaicing = qual_flags &amp; DEMOSAIC_FULL_SCALE;</a>
<a name="ln4661"> </a>
<a name="ln4662">  // check if output buffer has same dimension as input buffer (thus avoiding one</a>
<a name="ln4663">  // additional temporary buffer)</a>
<a name="ln4664">  const int unscaled = (roi_out-&gt;width == roi_in-&gt;width &amp;&amp; roi_out-&gt;height == roi_in-&gt;height);</a>
<a name="ln4665"> </a>
<a name="ln4666">  if((demosaicing_method == DT_IOP_DEMOSAIC_PPG) ||</a>
<a name="ln4667">      (demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME) ||</a>
<a name="ln4668">      (demosaicing_method == DT_IOP_DEMOSAIC_AMAZE))</a>
<a name="ln4669">  {</a>
<a name="ln4670">    // Bayer pattern with PPG, Monochrome and Amaze</a>
<a name="ln4671">    tiling-&gt;factor = 1.0f + ioratio;         // in + out</a>
<a name="ln4672"> </a>
<a name="ln4673">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4674">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);  // + tmp + geeneq | + smooth</a>
<a name="ln4675">    else if(full_scale_demosaicing)</a>
<a name="ln4676">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);  // + tmp + aux + greeneq | + smooth</a>
<a name="ln4677">    else</a>
<a name="ln4678">      tiling-&gt;factor += smooth;                        // + smooth</a>
<a name="ln4679"> </a>
<a name="ln4680">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4681">    tiling-&gt;overhead = 0;</a>
<a name="ln4682">    tiling-&gt;xalign = 2;</a>
<a name="ln4683">    tiling-&gt;yalign = 2;</a>
<a name="ln4684">    tiling-&gt;overlap = 5; // take care of border handling</a>
<a name="ln4685">  }</a>
<a name="ln4686">  else if(((demosaicing_method ==  DT_IOP_DEMOSAIC_MARKESTEIJN) ||</a>
<a name="ln4687">           (demosaicing_method ==  DT_IOP_DEMOSAIC_MARKESTEIJN_3) ||</a>
<a name="ln4688">           (demosaicing_method == DT_IOP_DEMOSAIC_FDC)) &amp;&amp;</a>
<a name="ln4689">          (qual_flags &amp; DEMOSAIC_XTRANS_FULL))</a>
<a name="ln4690">  {</a>
<a name="ln4691">    // X-Trans pattern full Markesteijn processing</a>
<a name="ln4692">    const int ndir = (demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 8 : 4;</a>
<a name="ln4693">    const int overlap = (demosaicing_method == DT_IOP_DEMOSAIC_MARKESTEIJN_3) ? 17 : 12;</a>
<a name="ln4694"> </a>
<a name="ln4695">    tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln4696">    tiling-&gt;factor += ndir * 1.0f      // rgb</a>
<a name="ln4697">                      + ndir * 0.25f   // drv</a>
<a name="ln4698">                      + ndir * 0.125f  // homo + homosum</a>
<a name="ln4699">                      + 1.0f;          // aux</a>
<a name="ln4700"> </a>
<a name="ln4701">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4702">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);</a>
<a name="ln4703">    else if(full_scale_demosaicing)</a>
<a name="ln4704">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);</a>
<a name="ln4705">    else</a>
<a name="ln4706">      tiling-&gt;factor += smooth;</a>
<a name="ln4707"> </a>
<a name="ln4708">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4709">    tiling-&gt;overhead = 0;</a>
<a name="ln4710">    tiling-&gt;xalign = 3;</a>
<a name="ln4711">    tiling-&gt;yalign = 3;</a>
<a name="ln4712">    tiling-&gt;overlap = overlap;</a>
<a name="ln4713">  }</a>
<a name="ln4714">  else</a>
<a name="ln4715">  {</a>
<a name="ln4716">    // VNG</a>
<a name="ln4717">    tiling-&gt;factor = 1.0f + ioratio;</a>
<a name="ln4718"> </a>
<a name="ln4719">    if(full_scale_demosaicing &amp;&amp; unscaled)</a>
<a name="ln4720">      tiling-&gt;factor += fmax(1.0f + greeneq, smooth);</a>
<a name="ln4721">    else if(full_scale_demosaicing)</a>
<a name="ln4722">      tiling-&gt;factor += fmax(2.0f + greeneq, smooth);</a>
<a name="ln4723">    else</a>
<a name="ln4724">      tiling-&gt;factor += smooth;</a>
<a name="ln4725"> </a>
<a name="ln4726">    tiling-&gt;maxbuf = 1.0f;</a>
<a name="ln4727">    tiling-&gt;overhead = 0;</a>
<a name="ln4728">    tiling-&gt;xalign = 6; // covering Bayer pattern for VNG4 as well as xtrans for VNG</a>
<a name="ln4729">    tiling-&gt;yalign = 6; // covering Bayer pattern for VNG4 as well as xtrans for VNG</a>
<a name="ln4730">    tiling-&gt;overlap = 6;</a>
<a name="ln4731">  }</a>
<a name="ln4732">  return;</a>
<a name="ln4733">}</a>
<a name="ln4734"> </a>
<a name="ln4735"> </a>
<a name="ln4736"> </a>
<a name="ln4737">void init(dt_iop_module_t *module)</a>
<a name="ln4738">{</a>
<a name="ln4739">  module-&gt;params = calloc(1, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4740">  module-&gt;default_params = calloc(1, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln4741">  module-&gt;default_enabled = 1;</a>
<a name="ln4742">  module-&gt;hide_enable_button = 1;</a>
<a name="ln4743">  module-&gt;params_size = sizeof(dt_iop_demosaic_params_t);</a>
<a name="ln4744">  module-&gt;gui_data = NULL;</a>
<a name="ln4745">}</a>
<a name="ln4746"> </a>
<a name="ln4747">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln4748">{</a>
<a name="ln4749">  const int program = 0; // from programs.conf</a>
<a name="ln4750">  dt_iop_demosaic_global_data_t *gd</a>
<a name="ln4751">      = (dt_iop_demosaic_global_data_t *)malloc(sizeof(dt_iop_demosaic_global_data_t));</a>
<a name="ln4752">  module-&gt;data = gd;</a>
<a name="ln4753">  gd-&gt;kernel_zoom_half_size = dt_opencl_create_kernel(program, &quot;clip_and_zoom_demosaic_half_size&quot;);</a>
<a name="ln4754">  gd-&gt;kernel_ppg_green = dt_opencl_create_kernel(program, &quot;ppg_demosaic_green&quot;);</a>
<a name="ln4755">  gd-&gt;kernel_green_eq_lavg = dt_opencl_create_kernel(program, &quot;green_equilibration_lavg&quot;);</a>
<a name="ln4756">  gd-&gt;kernel_green_eq_favg_reduce_first = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_reduce_first&quot;);</a>
<a name="ln4757">  gd-&gt;kernel_green_eq_favg_reduce_second = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_reduce_second&quot;);</a>
<a name="ln4758">  gd-&gt;kernel_green_eq_favg_apply = dt_opencl_create_kernel(program, &quot;green_equilibration_favg_apply&quot;);</a>
<a name="ln4759">  gd-&gt;kernel_pre_median = dt_opencl_create_kernel(program, &quot;pre_median&quot;);</a>
<a name="ln4760">  gd-&gt;kernel_ppg_redblue = dt_opencl_create_kernel(program, &quot;ppg_demosaic_redblue&quot;);</a>
<a name="ln4761">  gd-&gt;kernel_downsample = dt_opencl_create_kernel(program, &quot;clip_and_zoom&quot;);</a>
<a name="ln4762">  gd-&gt;kernel_border_interpolate = dt_opencl_create_kernel(program, &quot;border_interpolate&quot;);</a>
<a name="ln4763">  gd-&gt;kernel_color_smoothing = dt_opencl_create_kernel(program, &quot;color_smoothing&quot;);</a>
<a name="ln4764"> </a>
<a name="ln4765">  const int other = 14; // from programs.conf</a>
<a name="ln4766">  gd-&gt;kernel_passthrough_monochrome = dt_opencl_create_kernel(other, &quot;passthrough_monochrome&quot;);</a>
<a name="ln4767">  gd-&gt;kernel_zoom_passthrough_monochrome</a>
<a name="ln4768">      = dt_opencl_create_kernel(other, &quot;clip_and_zoom_demosaic_passthrough_monochrome&quot;);</a>
<a name="ln4769"> </a>
<a name="ln4770">  const int vng = 15; // from programs.conf</a>
<a name="ln4771">  gd-&gt;kernel_vng_border_interpolate = dt_opencl_create_kernel(vng, &quot;vng_border_interpolate&quot;);</a>
<a name="ln4772">  gd-&gt;kernel_vng_lin_interpolate = dt_opencl_create_kernel(vng, &quot;vng_lin_interpolate&quot;);</a>
<a name="ln4773">  gd-&gt;kernel_zoom_third_size = dt_opencl_create_kernel(vng, &quot;clip_and_zoom_demosaic_third_size_xtrans&quot;);</a>
<a name="ln4774">  gd-&gt;kernel_vng_green_equilibrate = dt_opencl_create_kernel(vng, &quot;vng_green_equilibrate&quot;);</a>
<a name="ln4775">  gd-&gt;kernel_vng_interpolate = dt_opencl_create_kernel(vng, &quot;vng_interpolate&quot;);</a>
<a name="ln4776"> </a>
<a name="ln4777">  const int markesteijn = 16; // from programs.conf</a>
<a name="ln4778">  gd-&gt;kernel_markesteijn_initial_copy = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_initial_copy&quot;);</a>
<a name="ln4779">  gd-&gt;kernel_markesteijn_green_minmax = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_green_minmax&quot;);</a>
<a name="ln4780">  gd-&gt;kernel_markesteijn_interpolate_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_interpolate_green&quot;);</a>
<a name="ln4781">  gd-&gt;kernel_markesteijn_solitary_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_solitary_green&quot;);</a>
<a name="ln4782">  gd-&gt;kernel_markesteijn_recalculate_green = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_recalculate_green&quot;);</a>
<a name="ln4783">  gd-&gt;kernel_markesteijn_red_and_blue = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_red_and_blue&quot;);</a>
<a name="ln4784">  gd-&gt;kernel_markesteijn_interpolate_twoxtwo = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_interpolate_twoxtwo&quot;);</a>
<a name="ln4785">  gd-&gt;kernel_markesteijn_convert_yuv = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_convert_yuv&quot;);</a>
<a name="ln4786">  gd-&gt;kernel_markesteijn_differentiate = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_differentiate&quot;);</a>
<a name="ln4787">  gd-&gt;kernel_markesteijn_homo_threshold = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_threshold&quot;);</a>
<a name="ln4788">  gd-&gt;kernel_markesteijn_homo_set = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_set&quot;);</a>
<a name="ln4789">  gd-&gt;kernel_markesteijn_homo_sum = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_sum&quot;);</a>
<a name="ln4790">  gd-&gt;kernel_markesteijn_homo_max = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_max&quot;);</a>
<a name="ln4791">  gd-&gt;kernel_markesteijn_homo_max_corr = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_max_corr&quot;);</a>
<a name="ln4792">  gd-&gt;kernel_markesteijn_homo_quench = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_homo_quench&quot;);</a>
<a name="ln4793">  gd-&gt;kernel_markesteijn_zero = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_zero&quot;);</a>
<a name="ln4794">  gd-&gt;kernel_markesteijn_accu = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_accu&quot;);</a>
<a name="ln4795">  gd-&gt;kernel_markesteijn_final = dt_opencl_create_kernel(markesteijn, &quot;markesteijn_final&quot;);</a>
<a name="ln4796">}</a>
<a name="ln4797"> </a>
<a name="ln4798">void cleanup(dt_iop_module_t *module)</a>
<a name="ln4799">{</a>
<a name="ln4800">  free(module-&gt;params);</a>
<a name="ln4801">  module-&gt;params = NULL;</a>
<a name="ln4802">}</a>
<a name="ln4803"> </a>
<a name="ln4804">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln4805">{</a>
<a name="ln4806">  dt_iop_demosaic_global_data_t *gd = (dt_iop_demosaic_global_data_t *)module-&gt;data;</a>
<a name="ln4807">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_half_size);</a>
<a name="ln4808">  dt_opencl_free_kernel(gd-&gt;kernel_ppg_green);</a>
<a name="ln4809">  dt_opencl_free_kernel(gd-&gt;kernel_pre_median);</a>
<a name="ln4810">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_lavg);</a>
<a name="ln4811">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_reduce_first);</a>
<a name="ln4812">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_reduce_second);</a>
<a name="ln4813">  dt_opencl_free_kernel(gd-&gt;kernel_green_eq_favg_apply);</a>
<a name="ln4814">  dt_opencl_free_kernel(gd-&gt;kernel_ppg_redblue);</a>
<a name="ln4815">  dt_opencl_free_kernel(gd-&gt;kernel_downsample);</a>
<a name="ln4816">  dt_opencl_free_kernel(gd-&gt;kernel_border_interpolate);</a>
<a name="ln4817">  dt_opencl_free_kernel(gd-&gt;kernel_color_smoothing);</a>
<a name="ln4818">  dt_opencl_free_kernel(gd-&gt;kernel_passthrough_monochrome);</a>
<a name="ln4819">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_passthrough_monochrome);</a>
<a name="ln4820">  dt_opencl_free_kernel(gd-&gt;kernel_vng_border_interpolate);</a>
<a name="ln4821">  dt_opencl_free_kernel(gd-&gt;kernel_vng_lin_interpolate);</a>
<a name="ln4822">  dt_opencl_free_kernel(gd-&gt;kernel_zoom_third_size);</a>
<a name="ln4823">  dt_opencl_free_kernel(gd-&gt;kernel_vng_green_equilibrate);</a>
<a name="ln4824">  dt_opencl_free_kernel(gd-&gt;kernel_vng_interpolate);</a>
<a name="ln4825">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_initial_copy);</a>
<a name="ln4826">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_green_minmax);</a>
<a name="ln4827">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_interpolate_green);</a>
<a name="ln4828">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_solitary_green);</a>
<a name="ln4829">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_recalculate_green);</a>
<a name="ln4830">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_red_and_blue);</a>
<a name="ln4831">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_interpolate_twoxtwo);</a>
<a name="ln4832">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_convert_yuv);</a>
<a name="ln4833">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_differentiate);</a>
<a name="ln4834">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_threshold);</a>
<a name="ln4835">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_set);</a>
<a name="ln4836">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_sum);</a>
<a name="ln4837">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_max);</a>
<a name="ln4838">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_max_corr);</a>
<a name="ln4839">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_homo_quench);</a>
<a name="ln4840">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_zero);</a>
<a name="ln4841">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_accu);</a>
<a name="ln4842">  dt_opencl_free_kernel(gd-&gt;kernel_markesteijn_final);</a>
<a name="ln4843">  free(module-&gt;data);</a>
<a name="ln4844">  module-&gt;data = NULL;</a>
<a name="ln4845">}</a>
<a name="ln4846"> </a>
<a name="ln4847">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *params, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln4848">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4849">{</a>
<a name="ln4850">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)params;</a>
<a name="ln4851">  dt_iop_demosaic_data_t *d = (dt_iop_demosaic_data_t *)piece-&gt;data;</a>
<a name="ln4852">  if(!(pipe-&gt;image.flags &amp; DT_IMAGE_RAW)) piece-&gt;enabled = 0;</a>
<a name="ln4853">  d-&gt;green_eq = p-&gt;green_eq;</a>
<a name="ln4854">  d-&gt;color_smoothing = p-&gt;color_smoothing;</a>
<a name="ln4855">  d-&gt;median_thrs = p-&gt;median_thrs;</a>
<a name="ln4856">  d-&gt;demosaicing_method = p-&gt;demosaicing_method;</a>
<a name="ln4857"> </a>
<a name="ln4858">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME</a>
<a name="ln4859">     || p-&gt;demosaicing_method == (DEMOSAIC_XTRANS | DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME))</a>
<a name="ln4860">  {</a>
<a name="ln4861">    d-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln4862">    d-&gt;green_eq = DT_IOP_GREEN_EQ_NO;</a>
<a name="ln4863">    d-&gt;color_smoothing = 0;</a>
<a name="ln4864">    d-&gt;median_thrs = 0.0f;</a>
<a name="ln4865">  }</a>
<a name="ln4866"> </a>
<a name="ln4867">  if(d-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE)</a>
<a name="ln4868">  {</a>
<a name="ln4869">    d-&gt;median_thrs = 0.0f;</a>
<a name="ln4870">  }</a>
<a name="ln4871"> </a>
<a name="ln4872">  // OpenCL only supported by some of the demosaicing methods</a>
<a name="ln4873">  switch(d-&gt;demosaicing_method)</a>
<a name="ln4874">  {</a>
<a name="ln4875">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln4876">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4877">      break;</a>
<a name="ln4878">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln4879">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4880">      break;</a>
<a name="ln4881">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln4882">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4883">      break;</a>
<a name="ln4884">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln4885">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4886">      break;</a>
<a name="ln4887">    case DT_IOP_DEMOSAIC_VNG:</a>
<a name="ln4888">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4889">      break;</a>
<a name="ln4890">    case DT_IOP_DEMOSAIC_MARKESTEIJN:</a>
<a name="ln4891">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4892">      break;</a>
<a name="ln4893">    case DT_IOP_DEMOSAIC_MARKESTEIJN_3:</a>
<a name="ln4894">      piece-&gt;process_cl_ready = 1;</a>
<a name="ln4895">      break;</a>
<a name="ln4896">    case DT_IOP_DEMOSAIC_FDC:</a>
<a name="ln4897">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4898">      break;</a>
<a name="ln4899">    default:</a>
<a name="ln4900">      piece-&gt;process_cl_ready = 0;</a>
<a name="ln4901">  }</a>
<a name="ln4902"> </a>
<a name="ln4903">  // green-equilibrate over full image excludes tiling</a>
<a name="ln4904">  if(d-&gt;green_eq == DT_IOP_GREEN_EQ_FULL || d-&gt;green_eq == DT_IOP_GREEN_EQ_BOTH) piece-&gt;process_tiling_ready = 0;</a>
<a name="ln4905"> </a>
<a name="ln4906">  if (self-&gt;dev-&gt;image_storage.flags &amp; DT_IMAGE_4BAYER)</a>
<a name="ln4907">  {</a>
<a name="ln4908">    // 4Bayer images not implemented in OpenCL yet</a>
<a name="ln4909">    piece-&gt;process_cl_ready = 0;</a>
<a name="ln4910"> </a>
<a name="ln4911">    // Get and store the matrix to go from camera to RGB for 4Bayer images</a>
<a name="ln4912">    char *camera = self-&gt;dev-&gt;image_storage.camera_makermodel;</a>
<a name="ln4913">    if (!dt_colorspaces_conversion_matrices_rgb(camera, NULL, d-&gt;CAM_to_RGB, NULL))</a>
<a name="ln4914">    {</a>
<a name="ln4915">      fprintf(stderr, &quot;[colorspaces] `%s' color matrix not found for 4bayer image!\n&quot;, camera);</a>
<a name="ln4916">      dt_control_log(_(&quot;`%s' color matrix not found for 4bayer image!&quot;), camera);</a>
<a name="ln4917">    }</a>
<a name="ln4918">  }</a>
<a name="ln4919">}</a>
<a name="ln4920"> </a>
<a name="ln4921">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4922">{</a>
<a name="ln4923">  piece-&gt;data = malloc(sizeof(dt_iop_demosaic_data_t));</a>
<a name="ln4924">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln4925">}</a>
<a name="ln4926"> </a>
<a name="ln4927">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4928">{</a>
<a name="ln4929">  free(piece-&gt;data);</a>
<a name="ln4930">  piece-&gt;data = NULL;</a>
<a name="ln4931">}</a>
<a name="ln4932"> </a>
<a name="ln4933">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln4934">{</a>
<a name="ln4935">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4936">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln4937"> </a>
<a name="ln4938">  if(self-&gt;dev-&gt;image_storage.buf_dsc.filters != 9u)</a>
<a name="ln4939">  {</a>
<a name="ln4940">    gtk_widget_show(g-&gt;demosaic_method_bayer);</a>
<a name="ln4941">    gtk_widget_hide(g-&gt;demosaic_method_xtrans);</a>
<a name="ln4942">    gtk_widget_show(g-&gt;median_thrs);</a>
<a name="ln4943">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln4944">    dt_bauhaus_combobox_set(g-&gt;demosaic_method_bayer, p-&gt;demosaicing_method);</a>
<a name="ln4945">  }</a>
<a name="ln4946">  else</a>
<a name="ln4947">  {</a>
<a name="ln4948">    gtk_widget_show(g-&gt;demosaic_method_xtrans);</a>
<a name="ln4949">    gtk_widget_hide(g-&gt;demosaic_method_bayer);</a>
<a name="ln4950">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4951">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln4952">    dt_bauhaus_combobox_set(g-&gt;demosaic_method_xtrans, p-&gt;demosaicing_method &amp; ~DEMOSAIC_XTRANS);</a>
<a name="ln4953">  }</a>
<a name="ln4954"> </a>
<a name="ln4955">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln4956">  {</a>
<a name="ln4957">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4958">    gtk_widget_hide(g-&gt;color_smoothing);</a>
<a name="ln4959">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln4960">  }</a>
<a name="ln4961"> </a>
<a name="ln4962">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE || p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_VNG4)</a>
<a name="ln4963">  {</a>
<a name="ln4964">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln4965">  }</a>
<a name="ln4966"> </a>
<a name="ln4967">  dt_bauhaus_slider_set(g-&gt;median_thrs, p-&gt;median_thrs);</a>
<a name="ln4968">  dt_bauhaus_combobox_set(g-&gt;color_smoothing, p-&gt;color_smoothing);</a>
<a name="ln4969">  dt_bauhaus_combobox_set(g-&gt;greeneq, p-&gt;green_eq);</a>
<a name="ln4970"> </a>
<a name="ln4971">  if(self-&gt;default_enabled)</a>
<a name="ln4972">  {</a>
<a name="ln4973">    gtk_widget_show(g-&gt;box_raw);</a>
<a name="ln4974">    gtk_widget_hide(g-&gt;label_non_raw);</a>
<a name="ln4975">  }</a>
<a name="ln4976">  else</a>
<a name="ln4977">  {</a>
<a name="ln4978">    gtk_widget_hide(g-&gt;box_raw);</a>
<a name="ln4979">    gtk_widget_show(g-&gt;label_non_raw);</a>
<a name="ln4980">  }</a>
<a name="ln4981">}</a>
<a name="ln4982"> </a>
<a name="ln4983">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln4984">{</a>
<a name="ln4985">  dt_iop_demosaic_params_t tmp</a>
<a name="ln4986">      = (dt_iop_demosaic_params_t){ .green_eq = DT_IOP_GREEN_EQ_NO,</a>
<a name="ln4987">                                    .median_thrs = 0.0f,</a>
<a name="ln4988">                                    .color_smoothing = 0,</a>
<a name="ln4989">                                    .demosaicing_method = DT_IOP_DEMOSAIC_PPG,</a>
<a name="ln4990">                                    .yet_unused_data_specific_to_demosaicing_method = 0 };</a>
<a name="ln4991"> </a>
<a name="ln4992">  // we might be called from presets update infrastructure =&gt; there is no image</a>
<a name="ln4993">  if(!module-&gt;dev) goto end;</a>
<a name="ln4994"> </a>
<a name="ln4995">  if(dt_image_is_monochrome(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln4996">    tmp.demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln4997"> </a>
<a name="ln4998">  // only on for raw images:</a>
<a name="ln4999">  if(dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage))</a>
<a name="ln5000">    module-&gt;default_enabled = 1;</a>
<a name="ln5001">  else</a>
<a name="ln5002">    module-&gt;default_enabled = 0;</a>
<a name="ln5003"> </a>
<a name="ln5004">  if(module-&gt;dev-&gt;image_storage.buf_dsc.filters == 9u) tmp.demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln5005"> </a>
<a name="ln5006">end:</a>
<a name="ln5007">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln5008">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_demosaic_params_t));</a>
<a name="ln5009">}</a>
<a name="ln5010"> </a>
<a name="ln5011">static void median_thrs_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln5012">{</a>
<a name="ln5013">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln5014">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln5015">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5016">  p-&gt;median_thrs = dt_bauhaus_slider_get(slider);</a>
<a name="ln5017">  if(p-&gt;median_thrs &lt; 0.001f) p-&gt;median_thrs = 0.0f;</a>
<a name="ln5018">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5019">}</a>
<a name="ln5020"> </a>
<a name="ln5021">static void color_smoothing_callback(GtkWidget *button, gpointer user_data)</a>
<a name="ln5022">{</a>
<a name="ln5023">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln5024">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln5025">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5026">  p-&gt;color_smoothing = dt_bauhaus_combobox_get(button);</a>
<a name="ln5027">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5028">}</a>
<a name="ln5029"> </a>
<a name="ln5030">static void greeneq_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln5031">{</a>
<a name="ln5032">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5033">  int active = dt_bauhaus_combobox_get(combo);</a>
<a name="ln5034">  switch(active)</a>
<a name="ln5035">  {</a>
<a name="ln5036">    case DT_IOP_GREEN_EQ_FULL:</a>
<a name="ln5037">      p-&gt;green_eq = DT_IOP_GREEN_EQ_FULL;</a>
<a name="ln5038">      break;</a>
<a name="ln5039">    case DT_IOP_GREEN_EQ_LOCAL:</a>
<a name="ln5040">      p-&gt;green_eq = DT_IOP_GREEN_EQ_LOCAL;</a>
<a name="ln5041">      break;</a>
<a name="ln5042">    case DT_IOP_GREEN_EQ_BOTH:</a>
<a name="ln5043">      p-&gt;green_eq = DT_IOP_GREEN_EQ_BOTH;</a>
<a name="ln5044">      break;</a>
<a name="ln5045">    default:</a>
<a name="ln5046">    case DT_IOP_GREEN_EQ_NO:</a>
<a name="ln5047">      p-&gt;green_eq = DT_IOP_GREEN_EQ_NO;</a>
<a name="ln5048">      break;</a>
<a name="ln5049">  }</a>
<a name="ln5050">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5051">}</a>
<a name="ln5052"> </a>
<a name="ln5053">static void demosaic_method_bayer_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln5054">{</a>
<a name="ln5055">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln5056">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5057">  int active = dt_bauhaus_combobox_get(combo);</a>
<a name="ln5058"> </a>
<a name="ln5059">  switch(active)</a>
<a name="ln5060">  {</a>
<a name="ln5061">    case DT_IOP_DEMOSAIC_AMAZE:</a>
<a name="ln5062">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_AMAZE;</a>
<a name="ln5063">      break;</a>
<a name="ln5064">    case DT_IOP_DEMOSAIC_VNG4:</a>
<a name="ln5065">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_VNG4;</a>
<a name="ln5066">      break;</a>
<a name="ln5067">    case DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME:</a>
<a name="ln5068">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME;</a>
<a name="ln5069">      break;</a>
<a name="ln5070">    default:</a>
<a name="ln5071">    case DT_IOP_DEMOSAIC_PPG:</a>
<a name="ln5072">      p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_PPG;</a>
<a name="ln5073">      break;</a>
<a name="ln5074">  }</a>
<a name="ln5075"> </a>
<a name="ln5076">  if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_PASSTHROUGH_MONOCHROME)</a>
<a name="ln5077">  {</a>
<a name="ln5078">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln5079">    gtk_widget_hide(g-&gt;color_smoothing);</a>
<a name="ln5080">    gtk_widget_hide(g-&gt;greeneq);</a>
<a name="ln5081">  }</a>
<a name="ln5082">  else if(p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_AMAZE || p-&gt;demosaicing_method == DT_IOP_DEMOSAIC_VNG4)</a>
<a name="ln5083">  {</a>
<a name="ln5084">    gtk_widget_hide(g-&gt;median_thrs);</a>
<a name="ln5085">    gtk_widget_show(g-&gt;color_smoothing);</a>
<a name="ln5086">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln5087">  }</a>
<a name="ln5088">  else</a>
<a name="ln5089">  {</a>
<a name="ln5090">    gtk_widget_show(g-&gt;median_thrs);</a>
<a name="ln5091">    gtk_widget_show(g-&gt;color_smoothing);</a>
<a name="ln5092">    gtk_widget_show(g-&gt;greeneq);</a>
<a name="ln5093">  }</a>
<a name="ln5094"> </a>
<a name="ln5095">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5096">}</a>
<a name="ln5097"> </a>
<a name="ln5098">static void demosaic_method_xtrans_callback(GtkWidget *combo, dt_iop_module_t *self)</a>
<a name="ln5099">{</a>
<a name="ln5100">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5101">  p-&gt;demosaicing_method = dt_bauhaus_combobox_get(combo) | DEMOSAIC_XTRANS;</a>
<a name="ln5102">  if((p-&gt;demosaicing_method &gt; (DT_IOP_DEMOSAIC_FDC | DEMOSAIC_XTRANS))</a>
<a name="ln5103">     || (p-&gt;demosaicing_method &lt; (DT_IOP_DEMOSAIC_VNG | DEMOSAIC_XTRANS)))</a>
<a name="ln5104">    p-&gt;demosaicing_method = DT_IOP_DEMOSAIC_MARKESTEIJN;</a>
<a name="ln5105">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln5106">}</a>
<a name="ln5107"> </a>
<a name="ln5108">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln5109">{</a>
<a name="ln5110">  self-&gt;gui_data = malloc(sizeof(dt_iop_demosaic_gui_data_t));</a>
<a name="ln5111">  dt_iop_demosaic_gui_data_t *g = (dt_iop_demosaic_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln5112">  dt_iop_demosaic_params_t *p = (dt_iop_demosaic_params_t *)self-&gt;params;</a>
<a name="ln5113"> </a>
<a name="ln5114">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln5115">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln5116"> </a>
<a name="ln5117">  g-&gt;box_raw = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln5118"> </a>
<a name="ln5119">  g-&gt;demosaic_method_bayer = dt_bauhaus_combobox_new(self);</a>
<a name="ln5120">  dt_bauhaus_widget_set_label(g-&gt;demosaic_method_bayer, NULL, _(&quot;method&quot;));</a>
<a name="ln5121">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;demosaic_method_bayer, TRUE, TRUE, 0);</a>
<a name="ln5122">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;PPG (fast)&quot;));</a>
<a name="ln5123">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;AMaZE (slow)&quot;));</a>
<a name="ln5124">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;VNG4&quot;));</a>
<a name="ln5125">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_bayer, _(&quot;passthrough (monochrome) (experimental)&quot;));</a>
<a name="ln5126">  gtk_widget_set_tooltip_text(g-&gt;demosaic_method_bayer, _(&quot;demosaicing raw data method&quot;));</a>
<a name="ln5127"> </a>
<a name="ln5128">  g-&gt;demosaic_method_xtrans = dt_bauhaus_combobox_new(self);</a>
<a name="ln5129">  dt_bauhaus_widget_set_label(g-&gt;demosaic_method_xtrans, NULL, _(&quot;method&quot;));</a>
<a name="ln5130">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;demosaic_method_xtrans, TRUE, TRUE, 0);</a>
<a name="ln5131">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;VNG&quot;));</a>
<a name="ln5132">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;Markesteijn 1-pass&quot;));</a>
<a name="ln5133">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;Markesteijn 3-pass (slow)&quot;));</a>
<a name="ln5134">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;passthrough (monochrome) (experimental)&quot;));</a>
<a name="ln5135">  dt_bauhaus_combobox_add(g-&gt;demosaic_method_xtrans, _(&quot;frequency domain chroma (slow)&quot;));</a>
<a name="ln5136">  gtk_widget_set_tooltip_text(g-&gt;demosaic_method_xtrans, _(&quot;demosaicing raw data method&quot;));</a>
<a name="ln5137"> </a>
<a name="ln5138">  g-&gt;median_thrs = dt_bauhaus_slider_new_with_range(self, 0.0, 1.0, 0.001, p-&gt;median_thrs, 3);</a>
<a name="ln5139">  gtk_widget_set_tooltip_text(g-&gt;median_thrs, _(&quot;threshold for edge-aware median.\nset to 0.0 to switch off.\n&quot;</a>
<a name="ln5140">                                                &quot;set to 1.0 to ignore edges.&quot;));</a>
<a name="ln5141">  dt_bauhaus_widget_set_label(g-&gt;median_thrs, NULL, _(&quot;edge threshold&quot;));</a>
<a name="ln5142">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;median_thrs, TRUE, TRUE, 0);</a>
<a name="ln5143"> </a>
<a name="ln5144">  g-&gt;color_smoothing = dt_bauhaus_combobox_new(self);</a>
<a name="ln5145">  dt_bauhaus_widget_set_label(g-&gt;color_smoothing, NULL, _(&quot;color smoothing&quot;));</a>
<a name="ln5146">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;color_smoothing, TRUE, TRUE, 0);</a>
<a name="ln5147">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;off&quot;));</a>
<a name="ln5148">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;one time&quot;));</a>
<a name="ln5149">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;two times&quot;));</a>
<a name="ln5150">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;three times&quot;));</a>
<a name="ln5151">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;four times&quot;));</a>
<a name="ln5152">  dt_bauhaus_combobox_add(g-&gt;color_smoothing, _(&quot;five times&quot;));</a>
<a name="ln5153">  gtk_widget_set_tooltip_text(g-&gt;color_smoothing, _(&quot;how many color smoothing median steps after demosaicing&quot;));</a>
<a name="ln5154"> </a>
<a name="ln5155">  g-&gt;greeneq = dt_bauhaus_combobox_new(self);</a>
<a name="ln5156">  gtk_box_pack_start(GTK_BOX(g-&gt;box_raw), g-&gt;greeneq, TRUE, TRUE, 0);</a>
<a name="ln5157">  dt_bauhaus_widget_set_label(g-&gt;greeneq, NULL, _(&quot;match greens&quot;));</a>
<a name="ln5158">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;disabled&quot;));</a>
<a name="ln5159">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;local average&quot;));</a>
<a name="ln5160">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;full average&quot;));</a>
<a name="ln5161">  dt_bauhaus_combobox_add(g-&gt;greeneq, _(&quot;full and local average&quot;));</a>
<a name="ln5162">  gtk_widget_set_tooltip_text(g-&gt;greeneq, _(&quot;green channels matching method&quot;));</a>
<a name="ln5163"> </a>
<a name="ln5164">  g_signal_connect(G_OBJECT(g-&gt;median_thrs), &quot;value-changed&quot;, G_CALLBACK(median_thrs_callback), self);</a>
<a name="ln5165">  g_signal_connect(G_OBJECT(g-&gt;color_smoothing), &quot;value-changed&quot;, G_CALLBACK(color_smoothing_callback), self);</a>
<a name="ln5166">  g_signal_connect(G_OBJECT(g-&gt;greeneq), &quot;value-changed&quot;, G_CALLBACK(greeneq_callback), self);</a>
<a name="ln5167">  g_signal_connect(G_OBJECT(g-&gt;demosaic_method_bayer), &quot;value-changed&quot;,</a>
<a name="ln5168">                   G_CALLBACK(demosaic_method_bayer_callback), self);</a>
<a name="ln5169">  g_signal_connect(G_OBJECT(g-&gt;demosaic_method_xtrans), &quot;value-changed&quot;,</a>
<a name="ln5170">                   G_CALLBACK(demosaic_method_xtrans_callback), self);</a>
<a name="ln5171"> </a>
<a name="ln5172">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;box_raw, FALSE, FALSE, 0);</a>
<a name="ln5173"> </a>
<a name="ln5174">  g-&gt;label_non_raw = gtk_label_new(_(&quot;demosaicing\nonly needed for raw images.&quot;));</a>
<a name="ln5175">  gtk_widget_set_halign(g-&gt;label_non_raw, GTK_ALIGN_START);</a>
<a name="ln5176">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;label_non_raw, FALSE, FALSE, 0);</a>
<a name="ln5177">}</a>
<a name="ln5178"> </a>
<a name="ln5179">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln5180">{</a>
<a name="ln5181">  free(self-&gt;gui_data);</a>
<a name="ln5182">  self-&gt;gui_data = NULL;</a>
<a name="ln5183">}</a>
<a name="ln5184"> </a>
<a name="ln5185">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln5186">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln5187">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v743/" target="_blank">V743</a> The memory areas must not overlap. Use 'memmove' function.</p></div>
<div class="balloon" rel="899"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'hex[d] + hex[d + 1]' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="903"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="903"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1886"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'hex[d] + hex[d + 1]' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="1891"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1891"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1892"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'd' index could reach 3.</p></div>
<div class="balloon" rel="1892"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1892"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1900"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1900"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1901"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'd' index could reach 3.</p></div>
<div class="balloon" rel="1901"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1901"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'c' index could reach 3.</p></div>
<div class="balloon" rel="1951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="1952"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1952"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="1953"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'f' index could reach 123.</p></div>
<div class="balloon" rel="1953"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The value of '-f' index could reach -123.</p></div>
<div class="balloon" rel="2076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'd < ndir - 4' of loop is always false.</p></div>
<div class="balloon" rel="2076"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v621/" target="_blank">V621</a> Consider inspecting the 'for' operator. It's possible that the loop will be executed incorrectly or won't be executed at all.</p></div>
<div class="balloon" rel="2208"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lookup'. Check lines: 2208, 2202.</p></div>
<div class="balloon" rel="2543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2544"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2545"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2546"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2547"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2548"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2549"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2623"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2624"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="2625"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '_MM_HINT_NTA' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="3526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lookup'. Check lines: 3526, 3521.</p></div>
<div class="balloon" rel="3536"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('y' = [-1..1]).</p></div>
<div class="balloon" rel="3581"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v769/" target="_blank">V769</a> The 'ip' pointer in the 'ip - ips' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 3581, 3573.</p></div>
<div class="balloon" rel="3871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v586/" target="_blank">V586</a> The 'free' function is called twice for deallocation of the same memory space.</p></div>
<div class="balloon" rel="4753"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 4753, 4751.</p></div>
<div class="balloon" rel="5102"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="5117"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 5117, 5110.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
