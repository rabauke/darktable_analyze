
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010--2014 henrik andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;gui/camera_import_dialog.h&quot;</a>
<a name="ln20">#include &quot;common/camera_control.h&quot;</a>
<a name="ln21">#include &quot;common/darktable.h&quot;</a>
<a name="ln22">#include &quot;common/exif.h&quot;</a>
<a name="ln23">#include &quot;common/utility.h&quot;</a>
<a name="ln24">#include &quot;common/variables.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;control/jobs.h&quot;</a>
<a name="ln28">#include &quot;develop/develop.h&quot;</a>
<a name="ln29">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln30">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln31">#include &quot;osx/osx.h&quot;</a>
<a name="ln32">#endif</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;time.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#ifdef _WIN32</a>
<a name="ln37">//MSVCRT does not have strptime implemented</a>
<a name="ln38">#include &quot;win/strptime.h&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40">/*</a>
<a name="ln41"> </a>
<a name="ln42">  g_object_ref(model); // Make sure the model stays with us after the tree view unrefs it</a>
<a name="ln43"> </a>
<a name="ln44">  gtk_tree_view_set_model(GTK_TREE_VIEW(view), NULL); // Detach model from view</a>
<a name="ln45"> </a>
<a name="ln46">  ... insert a couple of thousand rows ...</a>
<a name="ln47"> </a>
<a name="ln48">  gtk_tree_view_set_model(GTK_TREE_VIEW(view), model); // Re-attach model to view</a>
<a name="ln49"> </a>
<a name="ln50">  g_object_unref(model);</a>
<a name="ln51"> </a>
<a name="ln52">*/</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">typedef struct _camera_gconf_widget_t</a>
<a name="ln56">{</a>
<a name="ln57">  GtkWidget *widget;</a>
<a name="ln58">  GtkWidget *entry;</a>
<a name="ln59">  gchar *value;</a>
<a name="ln60">  struct _camera_import_dialog_t *dialog;</a>
<a name="ln61">} _camera_gconf_widget_t;</a>
<a name="ln62"> </a>
<a name="ln63">typedef struct _camera_import_dialog_t</a>
<a name="ln64">{</a>
<a name="ln65">  GtkWidget *dialog;</a>
<a name="ln66"> </a>
<a name="ln67">  GtkWidget *notebook;</a>
<a name="ln68"> </a>
<a name="ln69">  struct</a>
<a name="ln70">  {</a>
<a name="ln71">    GtkWidget *page;</a>
<a name="ln72">    _camera_gconf_widget_t *jobname;</a>
<a name="ln73">    GtkWidget *treeview;</a>
<a name="ln74">    GtkWidget *info;</a>
<a name="ln75">  } import;</a>
<a name="ln76"> </a>
<a name="ln77">  struct</a>
<a name="ln78">  {</a>
<a name="ln79">    GtkWidget *page;</a>
<a name="ln80"> </a>
<a name="ln81">    /** Group of general import settings */</a>
<a name="ln82">    struct</a>
<a name="ln83">    {</a>
<a name="ln84">      GtkWidget *ignore_jpeg;</a>
<a name="ln85">      GtkWidget *date_override;</a>
<a name="ln86">      GtkWidget *date_entry;</a>
<a name="ln87">    } general;</a>
<a name="ln88"> </a>
<a name="ln89">  } settings;</a>
<a name="ln90"> </a>
<a name="ln91">  GtkListStore *store;</a>
<a name="ln92">  dt_job_t *preview_job;</a>
<a name="ln93">  dt_camera_import_dialog_param_t *params;</a>
<a name="ln94">} _camera_import_dialog_t;</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">static void _check_button_callback(GtkWidget *cb, gpointer user_data)</a>
<a name="ln98">{</a>
<a name="ln99"> </a>
<a name="ln100">  _camera_import_dialog_t *cid = (_camera_import_dialog_t *)user_data;</a>
<a name="ln101"> </a>
<a name="ln102">  if(cb == cid-&gt;settings.general.ignore_jpeg)</a>
<a name="ln103">  {</a>
<a name="ln104">    dt_conf_set_bool(&quot;ui_last/import_ignore_jpegs&quot;,</a>
<a name="ln105">                     gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(cid-&gt;settings.general.ignore_jpeg)));</a>
<a name="ln106">  }</a>
<a name="ln107">  else if(cb == cid-&gt;settings.general.date_override)</a>
<a name="ln108">  {</a>
<a name="ln109">    // Enable/disable the date entry widget</a>
<a name="ln110">    gtk_widget_set_sensitive(cid-&gt;settings.general.date_entry, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(</a>
<a name="ln111">                                                                   cid-&gt;settings.general.date_override)));</a>
<a name="ln112">  }</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">static void _gcw_store_callback(GtkDarktableButton *button, gpointer user_data)</a>
<a name="ln116">{</a>
<a name="ln117">  _camera_gconf_widget_t *gcw = (_camera_gconf_widget_t *)user_data;</a>
<a name="ln118">  gchar *configstring = g_object_get_data(G_OBJECT(gcw-&gt;widget), &quot;gconf:string&quot;);</a>
<a name="ln119">  const gchar *newvalue = gtk_entry_get_text(GTK_ENTRY(gcw-&gt;entry));</a>
<a name="ln120">  if(newvalue &amp;&amp; *newvalue)</a>
<a name="ln121">  {</a>
<a name="ln122">    dt_conf_set_string(configstring, newvalue);</a>
<a name="ln123">    g_free(gcw-&gt;value);</a>
<a name="ln124">    gcw-&gt;value = g_strdup(newvalue);</a>
<a name="ln125">  }</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">static void _gcw_reset_callback(GtkDarktableButton *button, gpointer user_data)</a>
<a name="ln129">{</a>
<a name="ln130">  _camera_gconf_widget_t *gcw = (_camera_gconf_widget_t *)user_data;</a>
<a name="ln131">  gchar *configstring = g_object_get_data(G_OBJECT(gcw-&gt;widget), &quot;gconf:string&quot;);</a>
<a name="ln132">  gchar *value = dt_conf_get_string(configstring);</a>
<a name="ln133">  if(value)</a>
<a name="ln134">  {</a>
<a name="ln135">    gtk_entry_set_text(GTK_ENTRY(gcw-&gt;entry), value);</a>
<a name="ln136">    g_free(gcw-&gt;value);</a>
<a name="ln137">    gcw-&gt;value = value;</a>
<a name="ln138">  }</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">static void _entry_text_changed(_camera_gconf_widget_t *gcw, GtkEntryBuffer *entrybuffer)</a>
<a name="ln143">{</a>
<a name="ln144">  const gchar *value = gtk_entry_buffer_get_text(entrybuffer);</a>
<a name="ln145">  g_free(gcw-&gt;value);</a>
<a name="ln146">  gcw-&gt;value = g_strdup(value);</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">static void entry_dt_callback(GtkEntryBuffer *entrybuffer, guint a1, guint a2, gpointer user_data)</a>
<a name="ln150">{</a>
<a name="ln151">  _entry_text_changed((_camera_gconf_widget_t *)user_data, entrybuffer);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static void entry_it_callback(GtkEntryBuffer *entrybuffer, guint a1, gchar *a2, guint a3, gpointer user_data)</a>
<a name="ln155">{</a>
<a name="ln156">  _entry_text_changed((_camera_gconf_widget_t *)user_data, entrybuffer);</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">/** Creates a gconf widget. */</a>
<a name="ln160">static _camera_gconf_widget_t *_camera_import_gconf_widget(_camera_import_dialog_t *dlg, gchar *label,</a>
<a name="ln161">                                                           gchar *confstring)</a>
<a name="ln162">{</a>
<a name="ln163">  _camera_gconf_widget_t *gcw = calloc(1, sizeof(_camera_gconf_widget_t));</a>
<a name="ln164">  GtkWidget *vbox, *hbox;</a>
<a name="ln165">  gcw-&gt;widget = vbox = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_VERTICAL, 0));</a>
<a name="ln166">  hbox = GTK_WIDGET(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0));</a>
<a name="ln167">  g_object_set_data(G_OBJECT(vbox), &quot;gconf:string&quot;, confstring);</a>
<a name="ln168">  gcw-&gt;dialog = dlg;</a>
<a name="ln169"> </a>
<a name="ln170">  gcw-&gt;entry = gtk_entry_new();</a>
<a name="ln171">  char *value = dt_conf_get_string(confstring);</a>
<a name="ln172">  if(value)</a>
<a name="ln173">  {</a>
<a name="ln174">    gtk_entry_set_text(GTK_ENTRY(gcw-&gt;entry), value);</a>
<a name="ln175">    g_free(gcw-&gt;value);</a>
<a name="ln176">    gcw-&gt;value = value;</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gcw-&gt;entry), TRUE, TRUE, 0);</a>
<a name="ln180"> </a>
<a name="ln181">  GtkWidget *button = dtgtk_button_new(dtgtk_cairo_paint_store, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln182">  gtk_widget_set_tooltip_text(button, _(&quot;store value as default&quot;));</a>
<a name="ln183">  gtk_widget_set_size_request(button, DT_PIXEL_APPLY_DPI(13), DT_PIXEL_APPLY_DPI(13));</a>
<a name="ln184">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);</a>
<a name="ln185">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_gcw_store_callback), gcw);</a>
<a name="ln186"> </a>
<a name="ln187">  button = dtgtk_button_new(dtgtk_cairo_paint_reset, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln188">  gtk_widget_set_tooltip_text(button, _(&quot;reset value to default&quot;));</a>
<a name="ln189">  gtk_widget_set_size_request(button, DT_PIXEL_APPLY_DPI(13), DT_PIXEL_APPLY_DPI(13));</a>
<a name="ln190">  gtk_box_pack_start(GTK_BOX(hbox), button, FALSE, FALSE, 0);</a>
<a name="ln191">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(_gcw_reset_callback), gcw);</a>
<a name="ln192"> </a>
<a name="ln193">  GtkWidget *l = gtk_label_new(label);</a>
<a name="ln194">  gtk_widget_set_halign(l, GTK_ALIGN_START);</a>
<a name="ln195">  gtk_box_pack_start(GTK_BOX(vbox), l, FALSE, FALSE, 0);</a>
<a name="ln196"> </a>
<a name="ln197">  gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(hbox), FALSE, FALSE, 0);</a>
<a name="ln198"> </a>
<a name="ln199">  g_signal_connect(G_OBJECT(gtk_entry_get_buffer(GTK_ENTRY(gcw-&gt;entry))), &quot;inserted-text&quot;,</a>
<a name="ln200">                   G_CALLBACK(entry_it_callback), gcw);</a>
<a name="ln201">  g_signal_connect(G_OBJECT(gtk_entry_get_buffer(GTK_ENTRY(gcw-&gt;entry))), &quot;deleted-text&quot;,</a>
<a name="ln202">                   G_CALLBACK(entry_dt_callback), gcw);</a>
<a name="ln203"> </a>
<a name="ln204">  return gcw;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">static void _camera_import_dialog_new(_camera_import_dialog_t *data)</a>
<a name="ln210">{</a>
<a name="ln211">  data-&gt;dialog = gtk_dialog_new_with_buttons(_(&quot;import images from camera&quot;), NULL, GTK_DIALOG_MODAL,</a>
<a name="ln212">                                             _(&quot;cancel&quot;), GTK_RESPONSE_NONE, C_(&quot;camera import&quot;, &quot;import&quot;),</a>
<a name="ln213">                                             GTK_RESPONSE_ACCEPT, NULL);</a>
<a name="ln214">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln215">  dt_osx_disallow_fullscreen(data-&gt;dialog);</a>
<a name="ln216">#endif</a>
<a name="ln217">  gtk_window_set_default_size(GTK_WINDOW(data-&gt;dialog), 100, 600);</a>
<a name="ln218">  gtk_window_set_transient_for(GTK_WINDOW(data-&gt;dialog), GTK_WINDOW(dt_ui_main_window(darktable.gui-&gt;ui)));</a>
<a name="ln219">  GtkWidget *content = gtk_dialog_get_content_area(GTK_DIALOG(data-&gt;dialog));</a>
<a name="ln220"> </a>
<a name="ln221">  // List - setup store</a>
<a name="ln222">  data-&gt;store = gtk_list_store_new(2, GDK_TYPE_PIXBUF, G_TYPE_STRING);</a>
<a name="ln223"> </a>
<a name="ln224">  // IMPORT PAGE</a>
<a name="ln225">  data-&gt;import.page = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln226">  gtk_container_set_border_width(GTK_CONTAINER(data-&gt;import.page), 5);</a>
<a name="ln227"> </a>
<a name="ln228">  // Top info</a>
<a name="ln229">  data-&gt;import.info = gtk_label_new(_(&quot;please wait while prefetching thumbnails of images from camera...&quot;));</a>
<a name="ln230">  gtk_label_set_single_line_mode(GTK_LABEL(data-&gt;import.info), FALSE);</a>
<a name="ln231">  gtk_widget_set_halign(data-&gt;import.info, GTK_ALIGN_START);</a>
<a name="ln232">  gtk_box_pack_start(GTK_BOX(data-&gt;import.page), data-&gt;import.info, FALSE, FALSE, 0);</a>
<a name="ln233"> </a>
<a name="ln234">  // jobcode</a>
<a name="ln235">  data-&gt;import.jobname</a>
<a name="ln236">      = _camera_import_gconf_widget(data, _(&quot;jobcode&quot;), &quot;plugins/capture/camera/import/jobcode&quot;);</a>
<a name="ln237">  gtk_box_pack_start(GTK_BOX(data-&gt;import.page), GTK_WIDGET(data-&gt;import.jobname-&gt;widget), FALSE, FALSE, 0);</a>
<a name="ln238"> </a>
<a name="ln239"> </a>
<a name="ln240">  // Create the treview with list model data store</a>
<a name="ln241">  data-&gt;import.treeview = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln242">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(data-&gt;import.treeview), GTK_POLICY_NEVER,</a>
<a name="ln243">                                 GTK_POLICY_ALWAYS);</a>
<a name="ln244"> </a>
<a name="ln245">  gtk_container_add(GTK_CONTAINER(data-&gt;import.treeview), gtk_tree_view_new());</a>
<a name="ln246">  GtkTreeView *treeview = GTK_TREE_VIEW(gtk_bin_get_child(GTK_BIN(data-&gt;import.treeview)));</a>
<a name="ln247"> </a>
<a name="ln248">  GtkCellRenderer *renderer = gtk_cell_renderer_pixbuf_new();</a>
<a name="ln249">  GtkTreeViewColumn *column</a>
<a name="ln250">      = gtk_tree_view_column_new_with_attributes(_(&quot;thumbnail&quot;), renderer, &quot;pixbuf&quot;, 0, (char *)NULL);</a>
<a name="ln251">  gtk_tree_view_append_column(treeview, column);</a>
<a name="ln252"> </a>
<a name="ln253">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln254">  column = gtk_tree_view_column_new_with_attributes(_(&quot;storage file&quot;), renderer, &quot;text&quot;, 1, (char *)NULL);</a>
<a name="ln255">  gtk_tree_view_append_column(treeview, column);</a>
<a name="ln256">  gtk_tree_view_column_set_expand(column, TRUE);</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">  GtkTreeSelection *selection = gtk_tree_view_get_selection(treeview);</a>
<a name="ln260">  gtk_tree_selection_set_mode(selection, GTK_SELECTION_MULTIPLE);</a>
<a name="ln261"> </a>
<a name="ln262">  gtk_tree_view_set_model(treeview, GTK_TREE_MODEL(data-&gt;store));</a>
<a name="ln263">  gtk_tree_view_set_headers_visible(treeview, FALSE);</a>
<a name="ln264"> </a>
<a name="ln265">  gtk_box_pack_start(GTK_BOX(data-&gt;import.page), data-&gt;import.treeview, TRUE, TRUE, 0);</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">  // SETTINGS PAGE</a>
<a name="ln269">  data-&gt;settings.page = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln270">  gtk_container_set_border_width(GTK_CONTAINER(data-&gt;settings.page), 5);</a>
<a name="ln271"> </a>
<a name="ln272">  // general settings</a>
<a name="ln273">  gtk_box_pack_start(GTK_BOX(data-&gt;settings.page), gtk_label_new(_(&quot;general&quot;)), FALSE, FALSE, 0);</a>
<a name="ln274"> </a>
<a name="ln275">  // ignoring of jpegs. hack while we don't handle raw+jpeg in the same directories.</a>
<a name="ln276">  data-&gt;settings.general.ignore_jpeg = gtk_check_button_new_with_label(_(&quot;ignore JPEG files&quot;));</a>
<a name="ln277">  gtk_widget_set_tooltip_text(data-&gt;settings.general.ignore_jpeg,</a>
<a name="ln278">               _(&quot;do not load files with an extension of .jpg or .jpeg. this can be useful when there are &quot;</a>
<a name="ln279">                 &quot;raw+JPEG in a directory.&quot;));</a>
<a name="ln280">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(data-&gt;settings.general.ignore_jpeg),</a>
<a name="ln281">                               dt_conf_get_bool(&quot;ui_last/import_ignore_jpegs&quot;));</a>
<a name="ln282">  gtk_box_pack_start(GTK_BOX(data-&gt;settings.page), data-&gt;settings.general.ignore_jpeg, FALSE, FALSE, 0);</a>
<a name="ln283">  g_signal_connect(G_OBJECT(data-&gt;settings.general.ignore_jpeg), &quot;clicked&quot;,</a>
<a name="ln284">                   G_CALLBACK(_check_button_callback), data);</a>
<a name="ln285"> </a>
<a name="ln286">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln287">  data-&gt;settings.general.date_override = gtk_check_button_new_with_label(_(&quot;override today's date&quot;));</a>
<a name="ln288">  gtk_box_pack_start(GTK_BOX(hbox), data-&gt;settings.general.date_override, FALSE, FALSE, 0);</a>
<a name="ln289">  gtk_widget_set_tooltip_text(data-&gt;settings.general.date_override,</a>
<a name="ln290">               _(&quot;check this, if you want to override the timestamp used when expanding variables:\n$(YEAR), &quot;</a>
<a name="ln291">                 &quot;$(MONTH), $(DAY),\n$(HOUR), $(MINUTE), $(SECONDS)&quot;));</a>
<a name="ln292"> </a>
<a name="ln293">  data-&gt;settings.general.date_entry = gtk_entry_new();</a>
<a name="ln294">  gtk_widget_set_sensitive(data-&gt;settings.general.date_entry, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(</a>
<a name="ln295">                                                                  data-&gt;settings.general.date_override)));</a>
<a name="ln296">  gtk_box_pack_start(GTK_BOX(hbox), data-&gt;settings.general.date_entry, TRUE, TRUE, 0);</a>
<a name="ln297"> </a>
<a name="ln298">  g_signal_connect(G_OBJECT(data-&gt;settings.general.date_override), &quot;clicked&quot;,</a>
<a name="ln299">                   G_CALLBACK(_check_button_callback), data);</a>
<a name="ln300"> </a>
<a name="ln301">  gtk_box_pack_start(GTK_BOX(data-&gt;settings.page), hbox, FALSE, FALSE, 0);</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">  // THE NOTEBOOK</a>
<a name="ln305">  data-&gt;notebook = gtk_notebook_new();</a>
<a name="ln306">  gtk_notebook_append_page(GTK_NOTEBOOK(data-&gt;notebook), data-&gt;import.page, gtk_label_new(_(&quot;images&quot;)));</a>
<a name="ln307">  gtk_notebook_append_page(GTK_NOTEBOOK(data-&gt;notebook), data-&gt;settings.page, gtk_label_new(_(&quot;settings&quot;)));</a>
<a name="ln308"> </a>
<a name="ln309">  // end</a>
<a name="ln310">  gtk_box_pack_start(GTK_BOX(content), data-&gt;notebook, TRUE, TRUE, 0);</a>
<a name="ln311">  // gtk_widget_set_size_request(content, DT_PIXEL_APPLY_DPI(400), DT_PIXEL_APPLY_DPI(400));</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">typedef struct _image_filename_t</a>
<a name="ln315">{</a>
<a name="ln316">  char *file_info;</a>
<a name="ln317">  GdkPixbuf *thumb;</a>
<a name="ln318">  GtkListStore *store;</a>
<a name="ln319">} _image_filename_t;</a>
<a name="ln320"> </a>
<a name="ln321">static gboolean _camera_storage_image_filename_gui_thread(gpointer user_data)</a>
<a name="ln322">{</a>
<a name="ln323">  _image_filename_t *params = (_image_filename_t *)user_data;</a>
<a name="ln324"> </a>
<a name="ln325">  GtkTreeIter iter;</a>
<a name="ln326"> </a>
<a name="ln327">  gtk_list_store_append(params-&gt;store, &amp;iter);</a>
<a name="ln328">  gtk_list_store_set(params-&gt;store, &amp;iter, 0, params-&gt;thumb, 1, params-&gt;file_info, -1);</a>
<a name="ln329"> </a>
<a name="ln330">  if(params-&gt;thumb) g_object_ref(params-&gt;thumb);</a>
<a name="ln331">  free(params-&gt;file_info);</a>
<a name="ln332">  free(params);</a>
<a name="ln333">  return FALSE;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">static int _camera_storage_image_filename(const dt_camera_t *camera, const char *filename,</a>
<a name="ln337">                                          CameraFile *preview, CameraFile *exif, void *user_data)</a>
<a name="ln338">{</a>
<a name="ln339">  _camera_import_dialog_t *data = (_camera_import_dialog_t *)user_data;</a>
<a name="ln340">  const char *img;</a>
<a name="ln341">  unsigned long size;</a>
<a name="ln342">  GdkPixbuf *pixbuf = NULL;</a>
<a name="ln343">  GdkPixbuf *thumb = NULL;</a>
<a name="ln344"> </a>
<a name="ln345">  /* stop fetching previews if job is cancelled */</a>
<a name="ln346">  if(data-&gt;preview_job &amp;&amp; dt_control_job_get_state(data-&gt;preview_job) == DT_JOB_STATE_CANCELLED) return 0;</a>
<a name="ln347"> </a>
<a name="ln348">  char exif_info[1024] = { 0 };</a>
<a name="ln349"> </a>
<a name="ln350">  if(preview)</a>
<a name="ln351">  {</a>
<a name="ln352">    gp_file_get_data_and_size(preview, &amp;img, &amp;size);</a>
<a name="ln353">    if(size &gt; 0)</a>
<a name="ln354">    {</a>
<a name="ln355">      // we got preview image data lets create a pixbuf from image blob</a>
<a name="ln356">      GError *err = NULL;</a>
<a name="ln357">      GInputStream *stream;</a>
<a name="ln358">      if((stream = g_memory_input_stream_new_from_data(img, size, NULL)) != NULL)</a>
<a name="ln359">        pixbuf = gdk_pixbuf_new_from_stream(stream, NULL, &amp;err);</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    if(pixbuf)</a>
<a name="ln363">    {</a>
<a name="ln364">      // Scale pixbuf to a thumbnail</a>
<a name="ln365">      double sw = gdk_pixbuf_get_width(pixbuf);</a>
<a name="ln366">      double scale = 75.0 / gdk_pixbuf_get_height(pixbuf);</a>
<a name="ln367">      thumb = gdk_pixbuf_scale_simple(pixbuf, sw * scale, 75, GDK_INTERP_BILINEAR);</a>
<a name="ln368">    }</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">#if 0</a>
<a name="ln372">  // libgphoto only supports fetching exif in jpegs, not raw</a>
<a name="ln373">  char buffer[1024]= {0};</a>
<a name="ln374">  if ( exif )</a>
<a name="ln375">  {</a>
<a name="ln376">    const char *exif_data;</a>
<a name="ln377">    char *value=NULL;</a>
<a name="ln378">    gp_file_get_data_and_size(exif, &amp;exif_data, &amp;size);</a>
<a name="ln379">    if( size &gt; 0 )</a>
<a name="ln380">    {</a>
<a name="ln381">      void *exif=dt_exif_data_new((uint8_t *)exif_data,size);</a>
<a name="ln382">      if( (value=g_strdup( dt_exif_data_get_value(exif,&quot;Exif.Photo.ExposureTime&quot;,buffer,1024) ) ) != NULL);</a>
<a name="ln383">      snprintf(exif_info, sizeof(exif_info), &quot;exposure: %s\n&quot;, value);</a>
<a name="ln384">    }</a>
<a name="ln385">    else fprintf(stderr,&quot;No exifdata read\n&quot;);</a>
<a name="ln386">  }</a>
<a name="ln387">#endif</a>
<a name="ln388"> </a>
<a name="ln389">  _image_filename_t *params = (_image_filename_t *)malloc(sizeof(_image_filename_t));</a>
<a name="ln390">  if(!params)</a>
<a name="ln391">  {</a>
<a name="ln392">    if(pixbuf) g_object_unref(pixbuf);</a>
<a name="ln393">    if(thumb) g_object_unref(thumb);</a>
<a name="ln394">    return 0;</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  // filename\n 1/60 f/2.8 24mm iso 160</a>
<a name="ln398">  params-&gt;file_info = g_strdup_printf(&quot;%s%c%s&quot;, filename, *exif_info ? '\n' : '\0',</a>
<a name="ln399">                                      *exif_info ? exif_info : &quot;&quot;);</a>
<a name="ln400">  params-&gt;thumb = thumb;</a>
<a name="ln401">  params-&gt;store = data-&gt;store;</a>
<a name="ln402">  g_main_context_invoke(NULL, _camera_storage_image_filename_gui_thread, params);</a>
<a name="ln403"> </a>
<a name="ln404">  if(pixbuf) g_object_unref(pixbuf);</a>
<a name="ln405"> </a>
<a name="ln406">  return 1;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">static void _camera_import_dialog_free(_camera_import_dialog_t *data)</a>
<a name="ln410">{</a>
<a name="ln411">  gtk_list_store_clear(data-&gt;store);</a>
<a name="ln412">  g_object_unref(data-&gt;store);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">static void _control_status(dt_camctl_status_t status, void *user_data)</a>
<a name="ln416">{</a>
<a name="ln417">  _camera_import_dialog_t *data = (_camera_import_dialog_t *)user_data;</a>
<a name="ln418">  switch(status)</a>
<a name="ln419">  {</a>
<a name="ln420">    case CAMERA_CONTROL_BUSY:</a>
<a name="ln421">    {</a>
<a name="ln422">      gtk_dialog_set_response_sensitive(GTK_DIALOG(data-&gt;dialog), GTK_RESPONSE_ACCEPT, FALSE);</a>
<a name="ln423">      gtk_dialog_set_response_sensitive(GTK_DIALOG(data-&gt;dialog), GTK_RESPONSE_NONE, FALSE);</a>
<a name="ln424">    }</a>
<a name="ln425">    break;</a>
<a name="ln426">    case CAMERA_CONTROL_AVAILABLE:</a>
<a name="ln427">    {</a>
<a name="ln428">      gtk_dialog_set_response_sensitive(GTK_DIALOG(data-&gt;dialog), GTK_RESPONSE_ACCEPT, TRUE);</a>
<a name="ln429">      gtk_dialog_set_response_sensitive(GTK_DIALOG(data-&gt;dialog), GTK_RESPONSE_NONE, TRUE);</a>
<a name="ln430">    }</a>
<a name="ln431">    break;</a>
<a name="ln432">  }</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">static void _preview_job_state_changed(dt_job_t *job, dt_job_state_t state)</a>
<a name="ln436">{</a>
<a name="ln437">  _camera_import_dialog_t *data = dt_camera_previews_job_get_data(job);</a>
<a name="ln438">  /* store job reference if needed for cancellation */</a>
<a name="ln439">  if(state == DT_JOB_STATE_RUNNING)</a>
<a name="ln440">    data-&gt;preview_job = job;</a>
<a name="ln441">  else if(state == DT_JOB_STATE_FINISHED)</a>
<a name="ln442">    data-&gt;preview_job = NULL;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">static gboolean _dialog_close(GtkWidget *window, GdkEvent *event, gpointer user_data)</a>
<a name="ln446">{</a>
<a name="ln447">  _camera_import_dialog_t *data = (_camera_import_dialog_t *)user_data;</a>
<a name="ln448"> </a>
<a name="ln449">  if(data-&gt;preview_job)</a>
<a name="ln450">  {</a>
<a name="ln451">    /* cancel preview fetching job */</a>
<a name="ln452">    dt_control_job_cancel(data-&gt;preview_job);</a>
<a name="ln453"> </a>
<a name="ln454">    /* wait for job execution to signal finished */</a>
<a name="ln455">    dt_control_job_wait(data-&gt;preview_job);</a>
<a name="ln456">  }</a>
<a name="ln457">  return FALSE;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">static time_t parse_date_time(const char *date_time_text)</a>
<a name="ln461">{</a>
<a name="ln462">  struct tm t;</a>
<a name="ln463">  memset(&amp;t, 0, sizeof(t));</a>
<a name="ln464"> </a>
<a name="ln465">  const char *end = NULL;</a>
<a name="ln466">  if((end = strptime(date_time_text, &quot;%Y-%m-%dT%T&quot;, &amp;t)) &amp;&amp; *end == 0) return mktime(&amp;t);</a>
<a name="ln467">  if((end = strptime(date_time_text, &quot;%Y-%m-%d&quot;, &amp;t)) &amp;&amp; *end == 0) return mktime(&amp;t);</a>
<a name="ln468"> </a>
<a name="ln469">  return 0;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">static void _camera_import_dialog_run(_camera_import_dialog_t *data)</a>
<a name="ln473">{</a>
<a name="ln474">  gtk_widget_show_all(data-&gt;dialog);</a>
<a name="ln475"> </a>
<a name="ln476">  // Populate store</a>
<a name="ln477"> </a>
<a name="ln478">  // Setup a listener for previews of all files on camera</a>
<a name="ln479">  // then initiate fetch of all previews from camera</a>
<a name="ln480">  if(data-&gt;params-&gt;camera != NULL)</a>
<a name="ln481">  {</a>
<a name="ln482">    /* setup a camctl listener */</a>
<a name="ln483">    dt_camctl_listener_t listener = { 0 };</a>
<a name="ln484">    listener.data = data;</a>
<a name="ln485">    listener.control_status = _control_status;</a>
<a name="ln486">    listener.camera_storage_image_filename = _camera_storage_image_filename;</a>
<a name="ln487"> </a>
<a name="ln488">    dt_job_t *job</a>
<a name="ln489">        = dt_camera_get_previews_job_create(data-&gt;params-&gt;camera, &amp;listener, CAMCTL_IMAGE_PREVIEW_DATA, data);</a>
<a name="ln490">    if(job)</a>
<a name="ln491">    {</a>
<a name="ln492">      dt_control_job_set_state_callback(job, _preview_job_state_changed);</a>
<a name="ln493">      dt_control_add_job(darktable.control, DT_JOB_QUEUE_SYSTEM_FG, job);</a>
<a name="ln494">    }</a>
<a name="ln495">  }</a>
<a name="ln496">  else</a>
<a name="ln497">    return;</a>
<a name="ln498"> </a>
<a name="ln499">  // Lets run dialog</a>
<a name="ln500">  gtk_label_set_text(GTK_LABEL(data-&gt;import.info),</a>
<a name="ln501">                     _(&quot;select the images from the list below that you want to import into a new filmroll&quot;));</a>
<a name="ln502">  gboolean all_good = FALSE;</a>
<a name="ln503">  g_signal_connect(G_OBJECT(data-&gt;dialog), &quot;delete-event&quot;, G_CALLBACK(_dialog_close), data);</a>
<a name="ln504">  while(!all_good)</a>
<a name="ln505">  {</a>
<a name="ln506">    gint result = gtk_dialog_run(GTK_DIALOG(data-&gt;dialog));</a>
<a name="ln507">    if(result == GTK_RESPONSE_ACCEPT)</a>
<a name="ln508">    {</a>
<a name="ln509">      GtkTreeIter iter;</a>
<a name="ln510">      all_good = TRUE;</a>
<a name="ln511">      GtkTreeSelection *selection</a>
<a name="ln512">          = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtk_bin_get_child(GTK_BIN(data-&gt;import.treeview))));</a>
<a name="ln513">      // Now build up result from store into GList **result</a>
<a name="ln514">      g_list_free(data-&gt;params-&gt;result);</a>
<a name="ln515">      data-&gt;params-&gt;result = NULL;</a>
<a name="ln516">      GtkTreeModel *model = GTK_TREE_MODEL(data-&gt;store);</a>
<a name="ln517">      GList *sp = gtk_tree_selection_get_selected_rows(selection, &amp;model);</a>
<a name="ln518">      if(sp)</a>
<a name="ln519">      {</a>
<a name="ln520">        do</a>
<a name="ln521">        {</a>
<a name="ln522">          GValue value = {</a>
<a name="ln523">            0,</a>
<a name="ln524">          };</a>
<a name="ln525">          gtk_tree_model_get_iter(GTK_TREE_MODEL(data-&gt;store), &amp;iter, (GtkTreePath *)sp-&gt;data);</a>
<a name="ln526">          gtk_tree_model_get_value(GTK_TREE_MODEL(data-&gt;store), &amp;iter, 1, &amp;value);</a>
<a name="ln527">          if(G_VALUE_HOLDS_STRING(&amp;value))</a>
<a name="ln528">            data-&gt;params-&gt;result = g_list_append(data-&gt;params-&gt;result, g_strdup(g_value_get_string(&amp;value)));</a>
<a name="ln529">          g_value_unset(&amp;value);</a>
<a name="ln530">        } while((sp = g_list_next(sp)));</a>
<a name="ln531">      }</a>
<a name="ln532"> </a>
<a name="ln533">      /* get jobcode from import dialog */</a>
<a name="ln534">      data-&gt;params-&gt;jobcode = data-&gt;import.jobname-&gt;value;</a>
<a name="ln535"> </a>
<a name="ln536">      /* get time override if used */</a>
<a name="ln537">      data-&gt;params-&gt;time_override = 0;</a>
<a name="ln538">      if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data-&gt;settings.general.date_override)))</a>
<a name="ln539">        data-&gt;params-&gt;time_override</a>
<a name="ln540">            = parse_date_time(gtk_entry_get_text(GTK_ENTRY(data-&gt;settings.general.date_entry)));</a>
<a name="ln541"> </a>
<a name="ln542">      if(data-&gt;params-&gt;jobcode == NULL || data-&gt;params-&gt;jobcode[0] == '\0')</a>
<a name="ln543">      {</a>
<a name="ln544">        g_free(data-&gt;params-&gt;jobcode); // might just be a string of length 0</a>
<a name="ln545">        data-&gt;params-&gt;jobcode = dt_conf_get_string(&quot;plugins/capture/camera/import/jobcode&quot;);</a>
<a name="ln546">      }</a>
<a name="ln547">      else if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(data-&gt;settings.general.date_override))</a>
<a name="ln548">              &amp;&amp; data-&gt;params-&gt;time_override == 0)</a>
<a name="ln549">      {</a>
<a name="ln550">        GtkWidget *dialog</a>
<a name="ln551">            = gtk_message_dialog_new(NULL, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_ERROR, GTK_BUTTONS_OK,</a>
<a name="ln552">                                     _(&quot;please use YYYY-MM-DD format for date override&quot;));</a>
<a name="ln553">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln554">        dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln555">#endif</a>
<a name="ln556">        g_signal_connect_swapped(dialog, &quot;response&quot;, G_CALLBACK(gtk_widget_destroy), dialog);</a>
<a name="ln557">        gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln558">        all_good = FALSE;</a>
<a name="ln559">      }</a>
<a name="ln560">    }</a>
<a name="ln561">    else</a>
<a name="ln562">    {</a>
<a name="ln563">      data-&gt;params-&gt;result = NULL;</a>
<a name="ln564">      all_good = TRUE;</a>
<a name="ln565">    }</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  // Destroy and quit</a>
<a name="ln569">  gtk_widget_destroy(data-&gt;dialog);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">void dt_camera_import_dialog_new(dt_camera_import_dialog_param_t *params)</a>
<a name="ln573">{</a>
<a name="ln574">  _camera_import_dialog_t data;</a>
<a name="ln575">  memset(&amp;data, 0, sizeof(_camera_import_dialog_t)); // needed to initialize pointers to null</a>
<a name="ln576">  data.params = params;</a>
<a name="ln577">  _camera_import_dialog_new(&amp;data);</a>
<a name="ln578">  _camera_import_dialog_run(&amp;data);</a>
<a name="ln579">  _camera_import_dialog_free(&amp;data);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln583">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln584">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gcw'. Check lines: 165, 163.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
