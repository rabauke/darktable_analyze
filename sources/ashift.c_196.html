
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  This file is part of darktable,</a>
<a name="ln3">  copyright (c) 2016 Ulrich Pegelow.</a>
<a name="ln4"> </a>
<a name="ln5">  darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">  GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18"> </a>
<a name="ln19">#ifdef HAVE_CONFIG_H</a>
<a name="ln20">#include &quot;config.h&quot;</a>
<a name="ln21">#endif</a>
<a name="ln22">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln23">#include &quot;common/bilateral.h&quot;</a>
<a name="ln24">#include &quot;common/colorspaces_inline_conversions.h&quot;</a>
<a name="ln25">#include &quot;common/debug.h&quot;</a>
<a name="ln26">#include &quot;common/interpolation.h&quot;</a>
<a name="ln27">#include &quot;common/opencl.h&quot;</a>
<a name="ln28">#include &quot;control/control.h&quot;</a>
<a name="ln29">#include &quot;develop/develop.h&quot;</a>
<a name="ln30">#include &quot;develop/imageop.h&quot;</a>
<a name="ln31">#include &quot;develop/tiling.h&quot;</a>
<a name="ln32">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln33">#include &quot;dtgtk/resetlabel.h&quot;</a>
<a name="ln34">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln35">#include &quot;gui/draw.h&quot;</a>
<a name="ln36">#include &quot;gui/gtk.h&quot;</a>
<a name="ln37">#include &quot;gui/guides.h&quot;</a>
<a name="ln38">#include &quot;gui/presets.h&quot;</a>
<a name="ln39">#include &quot;iop/iop_api.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;assert.h&gt;</a>
<a name="ln42">#include &lt;gtk/gtk.h&gt;</a>
<a name="ln43">#include &lt;inttypes.h&gt;</a>
<a name="ln44">#include &lt;math.h&gt;</a>
<a name="ln45">#include &lt;stdlib.h&gt;</a>
<a name="ln46">#include &lt;string.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">// Inspiration to this module comes from the program ShiftN (http://www.shiftn.de) by</a>
<a name="ln49">// Marcus Hebel.</a>
<a name="ln50"> </a>
<a name="ln51">// Thanks to Marcus for his support when implementing part of the ShiftN functionality</a>
<a name="ln52">// to darktable.</a>
<a name="ln53"> </a>
<a name="ln54">#define ROTATION_RANGE 10                   // allowed min/max default range for rotation parameter</a>
<a name="ln55">#define ROTATION_RANGE_SOFT 20              // allowed min/max range for rotation parameter with manual adjustment</a>
<a name="ln56">#define LENSSHIFT_RANGE 0.5                 // allowed min/max default range for lensshift parameters</a>
<a name="ln57">#define LENSSHIFT_RANGE_SOFT 1              // allowed min/max range for lensshift parameters with manual adjustment</a>
<a name="ln58">#define SHEAR_RANGE 0.2                     // allowed min/max range for shear parameter</a>
<a name="ln59">#define SHEAR_RANGE_SOFT 0.5                // allowed min/max range for shear parameter with manual adjustment</a>
<a name="ln60">#define MIN_LINE_LENGTH 5                   // the minimum length of a line in pixels to be regarded as relevant</a>
<a name="ln61">#define MAX_TANGENTIAL_DEVIATION 30         // by how many degrees a line may deviate from the +/-180 and +/-90 to be regarded as relevant</a>
<a name="ln62">#define LSD_SCALE 0.99                      // LSD: scaling factor for line detection</a>
<a name="ln63">#define LSD_SIGMA_SCALE 0.6                 // LSD: sigma for Gaussian filter is computed as sigma = sigma_scale/scale</a>
<a name="ln64">#define LSD_QUANT 2.0                       // LSD: bound to the quantization error on the gradient norm</a>
<a name="ln65">#define LSD_ANG_TH 22.5                     // LSD: gradient angle tolerance in degrees</a>
<a name="ln66">#define LSD_LOG_EPS 0.0                     // LSD: detection threshold: -log10(NFA) &gt; log_eps</a>
<a name="ln67">#define LSD_DENSITY_TH 0.7                  // LSD: minimal density of region points in rectangle</a>
<a name="ln68">#define LSD_N_BINS 1024                     // LSD: number of bins in pseudo-ordering of gradient modulus</a>
<a name="ln69">#define LSD_GAMMA 0.45                      // gamma correction to apply on raw images prior to line detection</a>
<a name="ln70">#define RANSAC_RUNS 400                     // how many iterations to run in ransac</a>
<a name="ln71">#define RANSAC_EPSILON 2                    // starting value for ransac epsilon (in -log10 units)</a>
<a name="ln72">#define RANSAC_EPSILON_STEP 1               // step size of epsilon optimization (log10 units)</a>
<a name="ln73">#define RANSAC_ELIMINATION_RATIO 60         // percentage of lines we try to eliminate as outliers</a>
<a name="ln74">#define RANSAC_OPTIMIZATION_STEPS 5         // home many steps to optimize epsilon</a>
<a name="ln75">#define RANSAC_OPTIMIZATION_DRY_RUNS 50     // how man runs per optimization steps</a>
<a name="ln76">#define RANSAC_HURDLE 5                     // hurdle rate: the number of lines below which we do a complete permutation instead of random sampling</a>
<a name="ln77">#define MINIMUM_FITLINES 4                  // minimum number of lines needed for automatic parameter fit</a>
<a name="ln78">#define NMS_EPSILON 1e-3                    // break criterion for Nelder-Mead simplex</a>
<a name="ln79">#define NMS_SCALE 1.0                       // scaling factor for Nelder-Mead simplex</a>
<a name="ln80">#define NMS_ITERATIONS 400                  // number of iterations for Nelder-Mead simplex</a>
<a name="ln81">#define NMS_CROP_EPSILON 100.0              // break criterion for Nelder-Mead simplex on crop fitting</a>
<a name="ln82">#define NMS_CROP_SCALE 0.5                  // scaling factor for Nelder-Mead simplex on crop fitting</a>
<a name="ln83">#define NMS_CROP_ITERATIONS 100             // number of iterations for Nelder-Mead simplex on crop fitting</a>
<a name="ln84">#define NMS_ALPHA 1.0                       // reflection coefficient for Nelder-Mead simplex</a>
<a name="ln85">#define NMS_BETA 0.5                        // contraction coefficient for Nelder-Mead simplex</a>
<a name="ln86">#define NMS_GAMMA 2.0                       // expansion coefficient for Nelder-Mead simplex</a>
<a name="ln87">#define DEFAULT_F_LENGTH 28.0               // focal length we assume if no exif data are available</a>
<a name="ln88"> </a>
<a name="ln89">// define to get debugging output</a>
<a name="ln90">#undef ASHIFT_DEBUG</a>
<a name="ln91"> </a>
<a name="ln92">#define SQR(a) ((a) * (a))</a>
<a name="ln93"> </a>
<a name="ln94">// For line detection we use the LSD algorithm as published by Rafael Grompone:</a>
<a name="ln95">//</a>
<a name="ln96">//  &quot;LSD: a Line Segment Detector&quot; by Rafael Grompone von Gioi,</a>
<a name="ln97">//  Jeremie Jakubowicz, Jean-Michel Morel, and Gregory Randall,</a>
<a name="ln98">//  Image Processing On Line, 2012. DOI:10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln99">//  http://dx.doi.org/10.5201/ipol.2012.gjmr-lsd</a>
<a name="ln100">#include &quot;ashift_lsd.c&quot;</a>
<a name="ln101"> </a>
<a name="ln102">// For parameter optimization we are using the Nelder-Mead simplex method</a>
<a name="ln103">// implemented by Michael F. Hutt.</a>
<a name="ln104">#include &quot;ashift_nmsimplex.c&quot;</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">DT_MODULE_INTROSPECTION(4, dt_iop_ashift_params_t)</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">const char *name()</a>
<a name="ln111">{</a>
<a name="ln112">  return _(&quot;perspective correction&quot;);</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">int flags()</a>
<a name="ln116">{</a>
<a name="ln117">  return IOP_FLAGS_ALLOW_TILING | IOP_FLAGS_TILING_FULL_ROI | IOP_FLAGS_ONE_INSTANCE;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int default_group()</a>
<a name="ln121">{</a>
<a name="ln122">  return IOP_GROUP_CORRECT;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">int operation_tags()</a>
<a name="ln126">{</a>
<a name="ln127">  return IOP_TAG_DISTORT;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">int operation_tags_filter()</a>
<a name="ln131">{</a>
<a name="ln132">  // switch off clipping and decoration, we want to see the full image.</a>
<a name="ln133">  return IOP_TAG_DECORATION | IOP_TAG_CLIPPING;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">int default_colorspace(dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln137">{</a>
<a name="ln138">  return iop_cs_rgb;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">typedef enum dt_iop_ashift_homodir_t</a>
<a name="ln142">{</a>
<a name="ln143">  ASHIFT_HOMOGRAPH_FORWARD,</a>
<a name="ln144">  ASHIFT_HOMOGRAPH_INVERTED</a>
<a name="ln145">} dt_iop_ashift_homodir_t;</a>
<a name="ln146"> </a>
<a name="ln147">typedef enum dt_iop_ashift_linetype_t</a>
<a name="ln148">{</a>
<a name="ln149">  ASHIFT_LINE_IRRELEVANT   = 0,       // the line is found to be not interesting</a>
<a name="ln150">                                      // eg. too short, or not horizontal or vertical</a>
<a name="ln151">  ASHIFT_LINE_RELEVANT     = 1 &lt;&lt; 0,  // the line is relevant for us</a>
<a name="ln152">  ASHIFT_LINE_DIRVERT      = 1 &lt;&lt; 1,  // the line is (mostly) vertical, else (mostly) horizontal</a>
<a name="ln153">  ASHIFT_LINE_SELECTED     = 1 &lt;&lt; 2,  // the line is selected for fitting</a>
<a name="ln154">  ASHIFT_LINE_VERTICAL_NOT_SELECTED   = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT,</a>
<a name="ln155">  ASHIFT_LINE_HORIZONTAL_NOT_SELECTED = ASHIFT_LINE_RELEVANT,</a>
<a name="ln156">  ASHIFT_LINE_VERTICAL_SELECTED = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT | ASHIFT_LINE_SELECTED,</a>
<a name="ln157">  ASHIFT_LINE_HORIZONTAL_SELECTED = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED,</a>
<a name="ln158">  ASHIFT_LINE_MASK = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_DIRVERT | ASHIFT_LINE_SELECTED</a>
<a name="ln159">} dt_iop_ashift_linetype_t;</a>
<a name="ln160"> </a>
<a name="ln161">typedef enum dt_iop_ashift_linecolor_t</a>
<a name="ln162">{</a>
<a name="ln163">  ASHIFT_LINECOLOR_GREY    = 0,</a>
<a name="ln164">  ASHIFT_LINECOLOR_GREEN   = 1,</a>
<a name="ln165">  ASHIFT_LINECOLOR_RED     = 2,</a>
<a name="ln166">  ASHIFT_LINECOLOR_BLUE    = 3,</a>
<a name="ln167">  ASHIFT_LINECOLOR_YELLOW  = 4</a>
<a name="ln168">} dt_iop_ashift_linecolor_t;</a>
<a name="ln169"> </a>
<a name="ln170">typedef enum dt_iop_ashift_fitaxis_t</a>
<a name="ln171">{</a>
<a name="ln172">  ASHIFT_FIT_NONE          = 0,       // none</a>
<a name="ln173">  ASHIFT_FIT_ROTATION      = 1 &lt;&lt; 0,  // flag indicates to fit rotation angle</a>
<a name="ln174">  ASHIFT_FIT_LENS_VERT     = 1 &lt;&lt; 1,  // flag indicates to fit vertical lens shift</a>
<a name="ln175">  ASHIFT_FIT_LENS_HOR      = 1 &lt;&lt; 2,  // flag indicates to fit horizontal lens shift</a>
<a name="ln176">  ASHIFT_FIT_SHEAR         = 1 &lt;&lt; 3,  // flag indicates to fit shear parameter</a>
<a name="ln177">  ASHIFT_FIT_LINES_VERT    = 1 &lt;&lt; 4,  // use vertical lines for fitting</a>
<a name="ln178">  ASHIFT_FIT_LINES_HOR     = 1 &lt;&lt; 5,  // use horizontal lines for fitting</a>
<a name="ln179">  ASHIFT_FIT_LENS_BOTH = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR,</a>
<a name="ln180">  ASHIFT_FIT_LINES_BOTH = ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln181">  ASHIFT_FIT_VERTICALLY = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln182">  ASHIFT_FIT_HORIZONTALLY = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln183">  ASHIFT_FIT_BOTH = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln184">                    ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln185">  ASHIFT_FIT_VERTICALLY_NO_ROTATION = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln186">  ASHIFT_FIT_HORIZONTALLY_NO_ROTATION = ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln187">  ASHIFT_FIT_BOTH_NO_ROTATION = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln188">                                ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln189">  ASHIFT_FIT_BOTH_SHEAR = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR |</a>
<a name="ln190">                    ASHIFT_FIT_SHEAR | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln191">  ASHIFT_FIT_ROTATION_VERTICAL_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_VERT,</a>
<a name="ln192">  ASHIFT_FIT_ROTATION_HORIZONTAL_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln193">  ASHIFT_FIT_ROTATION_BOTH_LINES = ASHIFT_FIT_ROTATION | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR,</a>
<a name="ln194">  ASHIFT_FIT_FLIP = ASHIFT_FIT_LENS_VERT | ASHIFT_FIT_LENS_HOR | ASHIFT_FIT_LINES_VERT | ASHIFT_FIT_LINES_HOR</a>
<a name="ln195">} dt_iop_ashift_fitaxis_t;</a>
<a name="ln196"> </a>
<a name="ln197">typedef enum dt_iop_ashift_nmsresult_t</a>
<a name="ln198">{</a>
<a name="ln199">  NMS_SUCCESS = 0,</a>
<a name="ln200">  NMS_NOT_ENOUGH_LINES = 1,</a>
<a name="ln201">  NMS_DID_NOT_CONVERGE = 2,</a>
<a name="ln202">  NMS_INSANE = 3</a>
<a name="ln203">} dt_iop_ashift_nmsresult_t;</a>
<a name="ln204"> </a>
<a name="ln205">typedef enum dt_iop_ashift_enhance_t</a>
<a name="ln206">{</a>
<a name="ln207">  ASHIFT_ENHANCE_NONE       = 0,</a>
<a name="ln208">  ASHIFT_ENHANCE_EDGES      = 1 &lt;&lt; 0,</a>
<a name="ln209">  ASHIFT_ENHANCE_DETAIL     = 1 &lt;&lt; 1,</a>
<a name="ln210">  ASHIFT_ENHANCE_HORIZONTAL = 0x100,</a>
<a name="ln211">  ASHIFT_ENHANCE_VERTICAL   = 0x200</a>
<a name="ln212">} dt_iop_ashift_enhance_t;</a>
<a name="ln213"> </a>
<a name="ln214">typedef enum dt_iop_ashift_mode_t</a>
<a name="ln215">{</a>
<a name="ln216">  ASHIFT_MODE_GENERIC = 0,</a>
<a name="ln217">  ASHIFT_MODE_SPECIFIC = 1</a>
<a name="ln218">} dt_iop_ashift_mode_t;</a>
<a name="ln219"> </a>
<a name="ln220">typedef enum dt_iop_ashift_crop_t</a>
<a name="ln221">{</a>
<a name="ln222">  ASHIFT_CROP_OFF = 0,</a>
<a name="ln223">  ASHIFT_CROP_LARGEST = 1,</a>
<a name="ln224">  ASHIFT_CROP_ASPECT = 2</a>
<a name="ln225">} dt_iop_ashift_crop_t;</a>
<a name="ln226"> </a>
<a name="ln227">typedef enum dt_iop_ashift_bounding_t</a>
<a name="ln228">{</a>
<a name="ln229">  ASHIFT_BOUNDING_OFF = 0,</a>
<a name="ln230">  ASHIFT_BOUNDING_SELECT = 1,</a>
<a name="ln231">  ASHIFT_BOUNDING_DESELECT = 2</a>
<a name="ln232">} dt_iop_ashift_bounding_t;</a>
<a name="ln233"> </a>
<a name="ln234">typedef enum dt_iop_ashift_jobcode_t</a>
<a name="ln235">{</a>
<a name="ln236">  ASHIFT_JOBCODE_NONE = 0,</a>
<a name="ln237">  ASHIFT_JOBCODE_GET_STRUCTURE = 1,</a>
<a name="ln238">  ASHIFT_JOBCODE_FIT = 2</a>
<a name="ln239">} dt_iop_ashift_jobcode_t;</a>
<a name="ln240"> </a>
<a name="ln241">typedef struct dt_iop_ashift_params1_t</a>
<a name="ln242">{</a>
<a name="ln243">  float rotation;</a>
<a name="ln244">  float lensshift_v;</a>
<a name="ln245">  float lensshift_h;</a>
<a name="ln246">  int toggle;</a>
<a name="ln247">} dt_iop_ashift_params1_t;</a>
<a name="ln248"> </a>
<a name="ln249">typedef struct dt_iop_ashift_params2_t</a>
<a name="ln250">{</a>
<a name="ln251">  float rotation;</a>
<a name="ln252">  float lensshift_v;</a>
<a name="ln253">  float lensshift_h;</a>
<a name="ln254">  float f_length;</a>
<a name="ln255">  float crop_factor;</a>
<a name="ln256">  float orthocorr;</a>
<a name="ln257">  float aspect;</a>
<a name="ln258">  dt_iop_ashift_mode_t mode;</a>
<a name="ln259">  int toggle;</a>
<a name="ln260">} dt_iop_ashift_params2_t;</a>
<a name="ln261"> </a>
<a name="ln262">typedef struct dt_iop_ashift_params3_t</a>
<a name="ln263">{</a>
<a name="ln264">  float rotation;</a>
<a name="ln265">  float lensshift_v;</a>
<a name="ln266">  float lensshift_h;</a>
<a name="ln267">  float f_length;</a>
<a name="ln268">  float crop_factor;</a>
<a name="ln269">  float orthocorr;</a>
<a name="ln270">  float aspect;</a>
<a name="ln271">  dt_iop_ashift_mode_t mode;</a>
<a name="ln272">  int toggle;</a>
<a name="ln273">  dt_iop_ashift_crop_t cropmode;</a>
<a name="ln274">  float cl;</a>
<a name="ln275">  float cr;</a>
<a name="ln276">  float ct;</a>
<a name="ln277">  float cb;</a>
<a name="ln278">} dt_iop_ashift_params3_t;</a>
<a name="ln279"> </a>
<a name="ln280">typedef struct dt_iop_ashift_params_t</a>
<a name="ln281">{</a>
<a name="ln282">  float rotation;</a>
<a name="ln283">  float lensshift_v;</a>
<a name="ln284">  float lensshift_h;</a>
<a name="ln285">  float shear;</a>
<a name="ln286">  float f_length;</a>
<a name="ln287">  float crop_factor;</a>
<a name="ln288">  float orthocorr;</a>
<a name="ln289">  float aspect;</a>
<a name="ln290">  dt_iop_ashift_mode_t mode;</a>
<a name="ln291">  int toggle;</a>
<a name="ln292">  dt_iop_ashift_crop_t cropmode;</a>
<a name="ln293">  float cl;</a>
<a name="ln294">  float cr;</a>
<a name="ln295">  float ct;</a>
<a name="ln296">  float cb;</a>
<a name="ln297">} dt_iop_ashift_params_t;</a>
<a name="ln298"> </a>
<a name="ln299">typedef struct dt_iop_ashift_line_t</a>
<a name="ln300">{</a>
<a name="ln301">  float p1[3];</a>
<a name="ln302">  float p2[3];</a>
<a name="ln303">  float length;</a>
<a name="ln304">  float width;</a>
<a name="ln305">  float weight;</a>
<a name="ln306">  dt_iop_ashift_linetype_t type;</a>
<a name="ln307">  // homogeneous coordinates:</a>
<a name="ln308">  float L[3];</a>
<a name="ln309">} dt_iop_ashift_line_t;</a>
<a name="ln310"> </a>
<a name="ln311">typedef struct dt_iop_ashift_points_idx_t</a>
<a name="ln312">{</a>
<a name="ln313">  size_t offset;</a>
<a name="ln314">  int length;</a>
<a name="ln315">  int near;</a>
<a name="ln316">  int bounded;</a>
<a name="ln317">  dt_iop_ashift_linetype_t type;</a>
<a name="ln318">  dt_iop_ashift_linecolor_t color;</a>
<a name="ln319">  // bounding box:</a>
<a name="ln320">  float bbx, bby, bbX, bbY;</a>
<a name="ln321">} dt_iop_ashift_points_idx_t;</a>
<a name="ln322"> </a>
<a name="ln323">typedef struct dt_iop_ashift_fit_params_t</a>
<a name="ln324">{</a>
<a name="ln325">  int params_count;</a>
<a name="ln326">  dt_iop_ashift_linetype_t linetype;</a>
<a name="ln327">  dt_iop_ashift_linetype_t linemask;</a>
<a name="ln328">  dt_iop_ashift_line_t *lines;</a>
<a name="ln329">  int lines_count;</a>
<a name="ln330">  int width;</a>
<a name="ln331">  int height;</a>
<a name="ln332">  float weight;</a>
<a name="ln333">  float f_length_kb;</a>
<a name="ln334">  float orthocorr;</a>
<a name="ln335">  float aspect;</a>
<a name="ln336">  float rotation;</a>
<a name="ln337">  float lensshift_v;</a>
<a name="ln338">  float lensshift_h;</a>
<a name="ln339">  float shear;</a>
<a name="ln340">  float rotation_range;</a>
<a name="ln341">  float lensshift_v_range;</a>
<a name="ln342">  float lensshift_h_range;</a>
<a name="ln343">  float shear_range;</a>
<a name="ln344">} dt_iop_ashift_fit_params_t;</a>
<a name="ln345"> </a>
<a name="ln346">typedef struct dt_iop_ashift_cropfit_params_t</a>
<a name="ln347">{</a>
<a name="ln348">  int width;</a>
<a name="ln349">  int height;</a>
<a name="ln350">  float x;</a>
<a name="ln351">  float y;</a>
<a name="ln352">  float alpha;</a>
<a name="ln353">  float homograph[3][3];</a>
<a name="ln354">  float edges[4][3];</a>
<a name="ln355">} dt_iop_ashift_cropfit_params_t;</a>
<a name="ln356"> </a>
<a name="ln357">typedef struct dt_iop_ashift_gui_data_t</a>
<a name="ln358">{</a>
<a name="ln359">  GtkWidget *rotation;</a>
<a name="ln360">  GtkWidget *lensshift_v;</a>
<a name="ln361">  GtkWidget *lensshift_h;</a>
<a name="ln362">  GtkWidget *shear;</a>
<a name="ln363">  GtkWidget *guide_lines;</a>
<a name="ln364">  GtkWidget *cropmode;</a>
<a name="ln365">  GtkWidget *mode;</a>
<a name="ln366">  GtkWidget *f_length;</a>
<a name="ln367">  GtkWidget *crop_factor;</a>
<a name="ln368">  GtkWidget *orthocorr;</a>
<a name="ln369">  GtkWidget *aspect;</a>
<a name="ln370">  GtkWidget *fit_v;</a>
<a name="ln371">  GtkWidget *fit_h;</a>
<a name="ln372">  GtkWidget *fit_both;</a>
<a name="ln373">  GtkWidget *structure;</a>
<a name="ln374">  GtkWidget *clean;</a>
<a name="ln375">  GtkWidget *eye;</a>
<a name="ln376">  int lines_suppressed;</a>
<a name="ln377">  int fitting;</a>
<a name="ln378">  int isflipped;</a>
<a name="ln379">  int show_guides;</a>
<a name="ln380">  int isselecting;</a>
<a name="ln381">  int isdeselecting;</a>
<a name="ln382">  dt_iop_ashift_bounding_t isbounding;</a>
<a name="ln383">  float near_delta;</a>
<a name="ln384">  int selecting_lines_version;</a>
<a name="ln385">  float rotation_range;</a>
<a name="ln386">  float lensshift_v_range;</a>
<a name="ln387">  float lensshift_h_range;</a>
<a name="ln388">  float shear_range;</a>
<a name="ln389">  dt_iop_ashift_line_t *lines;</a>
<a name="ln390">  int lines_in_width;</a>
<a name="ln391">  int lines_in_height;</a>
<a name="ln392">  int lines_x_off;</a>
<a name="ln393">  int lines_y_off;</a>
<a name="ln394">  int lines_count;</a>
<a name="ln395">  int vertical_count;</a>
<a name="ln396">  int horizontal_count;</a>
<a name="ln397">  int lines_version;</a>
<a name="ln398">  float vertical_weight;</a>
<a name="ln399">  float horizontal_weight;</a>
<a name="ln400">  float *points;</a>
<a name="ln401">  dt_iop_ashift_points_idx_t *points_idx;</a>
<a name="ln402">  int points_lines_count;</a>
<a name="ln403">  int points_version;</a>
<a name="ln404">  float *buf;</a>
<a name="ln405">  int buf_width;</a>
<a name="ln406">  int buf_height;</a>
<a name="ln407">  int buf_x_off;</a>
<a name="ln408">  int buf_y_off;</a>
<a name="ln409">  float buf_scale;</a>
<a name="ln410">  uint64_t lines_hash;</a>
<a name="ln411">  uint64_t grid_hash;</a>
<a name="ln412">  uint64_t buf_hash;</a>
<a name="ln413">  dt_iop_ashift_fitaxis_t lastfit;</a>
<a name="ln414">  float lastx;</a>
<a name="ln415">  float lasty;</a>
<a name="ln416">  float crop_cx;</a>
<a name="ln417">  float crop_cy;</a>
<a name="ln418">  dt_iop_ashift_jobcode_t jobcode;</a>
<a name="ln419">  int jobparams;</a>
<a name="ln420">  dt_pthread_mutex_t lock;</a>
<a name="ln421">  gboolean adjust_crop;</a>
<a name="ln422">} dt_iop_ashift_gui_data_t;</a>
<a name="ln423"> </a>
<a name="ln424">typedef struct dt_iop_ashift_data_t</a>
<a name="ln425">{</a>
<a name="ln426">  float rotation;</a>
<a name="ln427">  float lensshift_v;</a>
<a name="ln428">  float lensshift_h;</a>
<a name="ln429">  float shear;</a>
<a name="ln430">  float f_length_kb;</a>
<a name="ln431">  float orthocorr;</a>
<a name="ln432">  float aspect;</a>
<a name="ln433">  float cl;</a>
<a name="ln434">  float cr;</a>
<a name="ln435">  float ct;</a>
<a name="ln436">  float cb;</a>
<a name="ln437">} dt_iop_ashift_data_t;</a>
<a name="ln438"> </a>
<a name="ln439">typedef struct dt_iop_ashift_global_data_t</a>
<a name="ln440">{</a>
<a name="ln441">  int kernel_ashift_bilinear;</a>
<a name="ln442">  int kernel_ashift_bicubic;</a>
<a name="ln443">  int kernel_ashift_lanczos2;</a>
<a name="ln444">  int kernel_ashift_lanczos3;</a>
<a name="ln445">} dt_iop_ashift_global_data_t;</a>
<a name="ln446"> </a>
<a name="ln447">int legacy_params(dt_iop_module_t *self, const void *const old_params, const int old_version,</a>
<a name="ln448">                  void *new_params, const int new_version)</a>
<a name="ln449">{</a>
<a name="ln450">  if(old_version == 1 &amp;&amp; new_version == 4)</a>
<a name="ln451">  {</a>
<a name="ln452">    const dt_iop_ashift_params1_t *old = old_params;</a>
<a name="ln453">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln454">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln455">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln456">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln457">    new-&gt;shear = 0.0f;</a>
<a name="ln458">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln459">    new-&gt;f_length = DEFAULT_F_LENGTH;</a>
<a name="ln460">    new-&gt;crop_factor = 1.0f;</a>
<a name="ln461">    new-&gt;orthocorr = 100.0f;</a>
<a name="ln462">    new-&gt;aspect = 1.0f;</a>
<a name="ln463">    new-&gt;mode = ASHIFT_MODE_GENERIC;</a>
<a name="ln464">    new-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln465">    new-&gt;cl = 0.0f;</a>
<a name="ln466">    new-&gt;cr = 1.0f;</a>
<a name="ln467">    new-&gt;ct = 0.0f;</a>
<a name="ln468">    new-&gt;cb = 1.0f;</a>
<a name="ln469">    return 0;</a>
<a name="ln470">  }</a>
<a name="ln471">  if(old_version == 2 &amp;&amp; new_version == 4)</a>
<a name="ln472">  {</a>
<a name="ln473">    const dt_iop_ashift_params2_t *old = old_params;</a>
<a name="ln474">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln475">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln476">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln477">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln478">    new-&gt;shear = 0.0f;</a>
<a name="ln479">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln480">    new-&gt;f_length = old-&gt;f_length;</a>
<a name="ln481">    new-&gt;crop_factor = old-&gt;crop_factor;</a>
<a name="ln482">    new-&gt;orthocorr = old-&gt;orthocorr;</a>
<a name="ln483">    new-&gt;aspect = old-&gt;aspect;</a>
<a name="ln484">    new-&gt;mode = old-&gt;mode;</a>
<a name="ln485">    new-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln486">    new-&gt;cl = 0.0f;</a>
<a name="ln487">    new-&gt;cr = 1.0f;</a>
<a name="ln488">    new-&gt;ct = 0.0f;</a>
<a name="ln489">    new-&gt;cb = 1.0f;</a>
<a name="ln490">    return 0;</a>
<a name="ln491">  }</a>
<a name="ln492">  if(old_version == 3 &amp;&amp; new_version == 4)</a>
<a name="ln493">  {</a>
<a name="ln494">    const dt_iop_ashift_params3_t *old = old_params;</a>
<a name="ln495">    dt_iop_ashift_params_t *new = new_params;</a>
<a name="ln496">    new-&gt;rotation = old-&gt;rotation;</a>
<a name="ln497">    new-&gt;lensshift_v = old-&gt;lensshift_v;</a>
<a name="ln498">    new-&gt;lensshift_h = old-&gt;lensshift_h;</a>
<a name="ln499">    new-&gt;shear = 0.0f;</a>
<a name="ln500">    new-&gt;toggle = old-&gt;toggle;</a>
<a name="ln501">    new-&gt;f_length = old-&gt;f_length;</a>
<a name="ln502">    new-&gt;crop_factor = old-&gt;crop_factor;</a>
<a name="ln503">    new-&gt;orthocorr = old-&gt;orthocorr;</a>
<a name="ln504">    new-&gt;aspect = old-&gt;aspect;</a>
<a name="ln505">    new-&gt;mode = old-&gt;mode;</a>
<a name="ln506">    new-&gt;cropmode = old-&gt;cropmode;</a>
<a name="ln507">    new-&gt;cl = old-&gt;cl;</a>
<a name="ln508">    new-&gt;cr = old-&gt;cr;</a>
<a name="ln509">    new-&gt;ct = old-&gt;ct;</a>
<a name="ln510">    new-&gt;cb = old-&gt;cb;</a>
<a name="ln511">    return 0;</a>
<a name="ln512">  }</a>
<a name="ln513"> </a>
<a name="ln514">  return 1;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">void init_key_accels(dt_iop_module_so_t *self)</a>
<a name="ln518">{</a>
<a name="ln519">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;rotation&quot;));</a>
<a name="ln520">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;lens shift (v)&quot;));</a>
<a name="ln521">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;lens shift (h)&quot;));</a>
<a name="ln522">  dt_accel_register_slider_iop(self, FALSE, NC_(&quot;accel&quot;, &quot;shear&quot;));</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">void connect_key_accels(dt_iop_module_t *self)</a>
<a name="ln526">{</a>
<a name="ln527">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln528"> </a>
<a name="ln529">  dt_accel_connect_slider_iop(self, &quot;rotation&quot;, GTK_WIDGET(g-&gt;rotation));</a>
<a name="ln530">  dt_accel_connect_slider_iop(self, &quot;lens shift (v)&quot;, GTK_WIDGET(g-&gt;lensshift_v));</a>
<a name="ln531">  dt_accel_connect_slider_iop(self, &quot;lens shift (h)&quot;, GTK_WIDGET(g-&gt;lensshift_h));</a>
<a name="ln532">  dt_accel_connect_slider_iop(self, &quot;shear&quot;, GTK_WIDGET(g-&gt;shear));</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">// multiply 3x3 matrix with 3x1 vector</a>
<a name="ln536">// dst needs to be different from v</a>
<a name="ln537">static inline void mat3mulv(float *dst, const float *const mat, const float *const v)</a>
<a name="ln538">{</a>
<a name="ln539">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln540">  {</a>
<a name="ln541">    float x = 0.0f;</a>
<a name="ln542">    for(int i = 0; i &lt; 3; i++) x += mat[3 * k + i] * v[i];</a>
<a name="ln543">    dst[k] = x;</a>
<a name="ln544">  }</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">// multiply two 3x3 matrices</a>
<a name="ln548">// dst needs to be different from m1 and m2</a>
<a name="ln549">static inline void mat3mul(float *dst, const float *const m1, const float *const m2)</a>
<a name="ln550">{</a>
<a name="ln551">  for(int k = 0; k &lt; 3; k++)</a>
<a name="ln552">  {</a>
<a name="ln553">    for(int i = 0; i &lt; 3; i++)</a>
<a name="ln554">    {</a>
<a name="ln555">      float x = 0.0f;</a>
<a name="ln556">      for(int j = 0; j &lt; 3; j++) x += m1[3 * k + j] * m2[3 * j + i];</a>
<a name="ln557">      dst[3 * k + i] = x;</a>
<a name="ln558">    }</a>
<a name="ln559">  }</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">// normalized product of two 3x1 vectors</a>
<a name="ln563">// dst needs to be different from v1 and v2</a>
<a name="ln564">static inline void vec3prodn(float *dst, const float *const v1, const float *const v2)</a>
<a name="ln565">{</a>
<a name="ln566">  const float l1 = v1[1] * v2[2] - v1[2] * v2[1];</a>
<a name="ln567">  const float l2 = v1[2] * v2[0] - v1[0] * v2[2];</a>
<a name="ln568">  const float l3 = v1[0] * v2[1] - v1[1] * v2[0];</a>
<a name="ln569"> </a>
<a name="ln570">  // normalize so that l1^2 + l2^2 + l3^3 = 1</a>
<a name="ln571">  const float sq = sqrt(l1 * l1 + l2 * l2 + l3 * l3);</a>
<a name="ln572"> </a>
<a name="ln573">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln574"> </a>
<a name="ln575">  dst[0] = l1 * f;</a>
<a name="ln576">  dst[1] = l2 * f;</a>
<a name="ln577">  dst[2] = l3 * f;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">// normalize a 3x1 vector so that x^2 + y^2 + z^2 = 1</a>
<a name="ln581">// dst and v may be the same</a>
<a name="ln582">static inline void vec3norm(float *dst, const float *const v)</a>
<a name="ln583">{</a>
<a name="ln584">  const float sq = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);</a>
<a name="ln585"> </a>
<a name="ln586">  // special handling for an all-zero vector</a>
<a name="ln587">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln588"> </a>
<a name="ln589">  dst[0] = v[0] * f;</a>
<a name="ln590">  dst[1] = v[1] * f;</a>
<a name="ln591">  dst[2] = v[2] * f;</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">// normalize a 3x1 vector so that x^2 + y^2 = 1; a useful normalization for</a>
<a name="ln595">// lines in homogeneous coordinates</a>
<a name="ln596">// dst and v may be the same</a>
<a name="ln597">static inline void vec3lnorm(float *dst, const float *const v)</a>
<a name="ln598">{</a>
<a name="ln599">  const float sq = sqrt(v[0] * v[0] + v[1] * v[1]);</a>
<a name="ln600"> </a>
<a name="ln601">  // special handling for a point vector of the image center</a>
<a name="ln602">  const float f = sq &gt; 0.0f ? 1.0f / sq : 1.0f;</a>
<a name="ln603"> </a>
<a name="ln604">  dst[0] = v[0] * f;</a>
<a name="ln605">  dst[1] = v[1] * f;</a>
<a name="ln606">  dst[2] = v[2] * f;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">// scalar product of two 3x1 vectors</a>
<a name="ln611">static inline float vec3scalar(const float *const v1, const float *const v2)</a>
<a name="ln612">{</a>
<a name="ln613">  return (v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">// check if 3x1 vector is (very close to) null</a>
<a name="ln617">static inline int vec3isnull(const float *const v)</a>
<a name="ln618">{</a>
<a name="ln619">  const float eps = 1e-10f;</a>
<a name="ln620">  return (fabs(v[0]) &lt; eps &amp;&amp; fabs(v[1]) &lt; eps &amp;&amp; fabs(v[2]) &lt; eps);</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">#ifdef ASHIFT_DEBUG</a>
<a name="ln624">static void print_roi(const dt_iop_roi_t *roi, const char *label)</a>
<a name="ln625">{</a>
<a name="ln626">  printf(&quot;{ %5d  %5d  %5d  %5d  %.6f } %s\n&quot;, roi-&gt;x, roi-&gt;y, roi-&gt;width, roi-&gt;height, roi-&gt;scale, label);</a>
<a name="ln627">}</a>
<a name="ln628">#endif</a>
<a name="ln629"> </a>
<a name="ln630">#define MAT3SWAP(a, b) { float (*tmp)[3] = (a); (a) = (b); (b) = tmp; }</a>
<a name="ln631"> </a>
<a name="ln632">static void homography(float *homograph, const float angle, const float shift_v, const float shift_h,</a>
<a name="ln633">                       const float shear, const float f_length_kb, const float orthocorr, const float aspect,</a>
<a name="ln634">                       const int width, const int height, dt_iop_ashift_homodir_t dir)</a>
<a name="ln635">{</a>
<a name="ln636">  // calculate homograph that combines all translations, rotations</a>
<a name="ln637">  // and warping into one single matrix operation.</a>
<a name="ln638">  // this is heavily leaning on ShiftN where the homographic matrix expects</a>
<a name="ln639">  // input in (y : x : 1) format. in the darktable world we want to keep the</a>
<a name="ln640">  // (x : y : 1) convention. therefore we need to flip coordinates first and</a>
<a name="ln641">  // make sure that output is in correct format after corrections are applied.</a>
<a name="ln642"> </a>
<a name="ln643">  const float u = width;</a>
<a name="ln644">  const float v = height;</a>
<a name="ln645"> </a>
<a name="ln646">  const float phi = M_PI * angle / 180.0f;</a>
<a name="ln647">  const float cosi = cos(phi);</a>
<a name="ln648">  const float sini = sin(phi);</a>
<a name="ln649">  const float ascale = sqrt(aspect);</a>
<a name="ln650"> </a>
<a name="ln651">  // most of this comes from ShiftN</a>
<a name="ln652">  const float f_global = f_length_kb;</a>
<a name="ln653">  const float horifac = 1.0f - orthocorr / 100.0f;</a>
<a name="ln654">  const float exppa_v = exp(shift_v);</a>
<a name="ln655">  const float fdb_v = f_global / (14.4f + (v / u - 1) * 7.2f);</a>
<a name="ln656">  const float rad_v = fdb_v * (exppa_v - 1.0f) / (exppa_v + 1.0f);</a>
<a name="ln657">  const float alpha_v = CLAMP(atan(rad_v), -1.5f, 1.5f);</a>
<a name="ln658">  const float rt_v = sin(0.5f * alpha_v);</a>
<a name="ln659">  const float r_v = fmax(0.1f, 2.0f * (horifac - 1.0f) * rt_v * rt_v + 1.0f);</a>
<a name="ln660"> </a>
<a name="ln661">  const float vertifac = 1.0f - orthocorr / 100.0f;</a>
<a name="ln662">  const float exppa_h = exp(shift_h);</a>
<a name="ln663">  const float fdb_h = f_global / (14.4f + (u / v - 1) * 7.2f);</a>
<a name="ln664">  const float rad_h = fdb_h * (exppa_h - 1.0f) / (exppa_h + 1.0f);</a>
<a name="ln665">  const float alpha_h = CLAMP(atan(rad_h), -1.5f, 1.5f);</a>
<a name="ln666">  const float rt_h = sin(0.5f * alpha_h);</a>
<a name="ln667">  const float r_h = fmax(0.1f, 2.0f * (vertifac - 1.0f) * rt_h * rt_h + 1.0f);</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">  // three intermediate buffers for matrix calculation ...</a>
<a name="ln671">  float m1[3][3], m2[3][3], m3[3][3];</a>
<a name="ln672"> </a>
<a name="ln673">  // ... and some pointers to handle them more intuitively</a>
<a name="ln674">  float (*mwork)[3] = m1;</a>
<a name="ln675">  float (*minput)[3] = m2;</a>
<a name="ln676">  float (*moutput)[3] = m3;</a>
<a name="ln677"> </a>
<a name="ln678">  // Step 1: flip x and y coordinates (see above)</a>
<a name="ln679">  memset(minput, 0, 9 * sizeof(float));</a>
<a name="ln680">  minput[0][1] = 1.0f;</a>
<a name="ln681">  minput[1][0] = 1.0f;</a>
<a name="ln682">  minput[2][2] = 1.0f;</a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685">  // Step 2: rotation of image around its center</a>
<a name="ln686">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln687">  mwork[0][0] = cosi;</a>
<a name="ln688">  mwork[0][1] = -sini;</a>
<a name="ln689">  mwork[1][0] = sini;</a>
<a name="ln690">  mwork[1][1] = cosi;</a>
<a name="ln691">  mwork[0][2] = -0.5f * v * cosi + 0.5f * u * sini + 0.5f * v;</a>
<a name="ln692">  mwork[1][2] = -0.5f * v * sini - 0.5f * u * cosi + 0.5f * u;</a>
<a name="ln693">  mwork[2][2] = 1.0f;</a>
<a name="ln694"> </a>
<a name="ln695">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln696">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln697"> </a>
<a name="ln698"> </a>
<a name="ln699">  // Step 3: apply shearing</a>
<a name="ln700">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln701">  mwork[0][0] = 1.0f;</a>
<a name="ln702">  mwork[0][1] = shear;</a>
<a name="ln703">  mwork[1][1] = 1.0f;</a>
<a name="ln704">  mwork[1][0] = shear;</a>
<a name="ln705">  mwork[2][2] = 1.0f;</a>
<a name="ln706"> </a>
<a name="ln707">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln708">  MAT3SWAP(minput, moutput);</a>
<a name="ln709">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln710">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">  // Step 4: apply vertical lens shift effect</a>
<a name="ln714">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln715">  mwork[0][0] = exppa_v;</a>
<a name="ln716">  mwork[1][0] = 0.5f * ((exppa_v - 1.0f) * u) / v;</a>
<a name="ln717">  mwork[1][1] = 2.0f * exppa_v / (exppa_v + 1.0f);</a>
<a name="ln718">  mwork[1][2] = -0.5f * ((exppa_v - 1.0f) * u) / (exppa_v + 1.0f);</a>
<a name="ln719">  mwork[2][0] = (exppa_v - 1.0f) / v;</a>
<a name="ln720">  mwork[2][2] = 1.0f;</a>
<a name="ln721"> </a>
<a name="ln722">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln723">  MAT3SWAP(minput, moutput);</a>
<a name="ln724">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln725">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728">  // Step 5: horizontal compression</a>
<a name="ln729">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln730">  mwork[0][0] = 1.0f;</a>
<a name="ln731">  mwork[1][1] = r_v;</a>
<a name="ln732">  mwork[1][2] = 0.5f * u * (1.0f - r_v);</a>
<a name="ln733">  mwork[2][2] = 1.0f;</a>
<a name="ln734"> </a>
<a name="ln735">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln736">  MAT3SWAP(minput, moutput);</a>
<a name="ln737">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln738">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">  // Step 6: flip x and y back again</a>
<a name="ln742">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln743">  mwork[0][1] = 1.0f;</a>
<a name="ln744">  mwork[1][0] = 1.0f;</a>
<a name="ln745">  mwork[2][2] = 1.0f;</a>
<a name="ln746"> </a>
<a name="ln747">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln748">  MAT3SWAP(minput, moutput);</a>
<a name="ln749">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln750">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln751"> </a>
<a name="ln752"> </a>
<a name="ln753">  // from here output vectors would be in (x : y : 1) format</a>
<a name="ln754"> </a>
<a name="ln755">  // Step 7: now we can apply horizontal lens shift with the same matrix format as above</a>
<a name="ln756">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln757">  mwork[0][0] = exppa_h;</a>
<a name="ln758">  mwork[1][0] = 0.5f * ((exppa_h - 1.0f) * v) / u;</a>
<a name="ln759">  mwork[1][1] = 2.0f * exppa_h / (exppa_h + 1.0f);</a>
<a name="ln760">  mwork[1][2] = -0.5f * ((exppa_h - 1.0f) * v) / (exppa_h + 1.0f);</a>
<a name="ln761">  mwork[2][0] = (exppa_h - 1.0f) / u;</a>
<a name="ln762">  mwork[2][2] = 1.0f;</a>
<a name="ln763"> </a>
<a name="ln764">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln765">  MAT3SWAP(minput, moutput);</a>
<a name="ln766">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln767">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">  // Step 8: vertical compression</a>
<a name="ln771">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln772">  mwork[0][0] = 1.0f;</a>
<a name="ln773">  mwork[1][1] = r_h;</a>
<a name="ln774">  mwork[1][2] = 0.5f * v * (1.0f - r_h);</a>
<a name="ln775">  mwork[2][2] = 1.0f;</a>
<a name="ln776"> </a>
<a name="ln777">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln778">  MAT3SWAP(minput, moutput);</a>
<a name="ln779">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln780">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">  // Step 9: apply aspect ratio scaling</a>
<a name="ln784">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln785">  mwork[0][0] = 1.0f * ascale;</a>
<a name="ln786">  mwork[1][1] = 1.0f / ascale;</a>
<a name="ln787">  mwork[2][2] = 1.0f;</a>
<a name="ln788"> </a>
<a name="ln789">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln790">  MAT3SWAP(minput, moutput);</a>
<a name="ln791">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln792">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">  // Step 10: find x/y offsets and apply according correction so that</a>
<a name="ln796">  // no negative coordinates occur in output vector</a>
<a name="ln797">  float umin = FLT_MAX, vmin = FLT_MAX;</a>
<a name="ln798">  // visit all four corners</a>
<a name="ln799">  for(int y = 0; y &lt; height; y += height - 1)</a>
<a name="ln800">    for(int x = 0; x &lt; width; x += width - 1)</a>
<a name="ln801">    {</a>
<a name="ln802">      float pi[3], po[3];</a>
<a name="ln803">      pi[0] = x;</a>
<a name="ln804">      pi[1] = y;</a>
<a name="ln805">      pi[2] = 1.0f;</a>
<a name="ln806">      // moutput expects input in (x:y:1) format and gives output as (x:y:1)</a>
<a name="ln807">      mat3mulv(po, (float *)moutput, pi);</a>
<a name="ln808">      umin = fmin(umin, po[0] / po[2]);</a>
<a name="ln809">      vmin = fmin(vmin, po[1] / po[2]);</a>
<a name="ln810">    }</a>
<a name="ln811"> </a>
<a name="ln812">  memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln813">  mwork[0][0] = 1.0f;</a>
<a name="ln814">  mwork[1][1] = 1.0f;</a>
<a name="ln815">  mwork[2][2] = 1.0f;</a>
<a name="ln816">  mwork[0][2] = -umin;</a>
<a name="ln817">  mwork[1][2] = -vmin;</a>
<a name="ln818"> </a>
<a name="ln819">  // moutput (of last calculation) -&gt; minput</a>
<a name="ln820">  MAT3SWAP(minput, moutput);</a>
<a name="ln821">  // multiply mwork * minput -&gt; moutput</a>
<a name="ln822">  mat3mul((float *)moutput, (float *)mwork, (float *)minput);</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">  // on request we either keep the final matrix for forward conversions</a>
<a name="ln826">  // or produce an inverted matrix for backward conversions</a>
<a name="ln827">  if(dir == ASHIFT_HOMOGRAPH_FORWARD)</a>
<a name="ln828">  {</a>
<a name="ln829">    // we have what we need -&gt; copy it to the right place</a>
<a name="ln830">    memcpy(homograph, moutput, 9 * sizeof(float));</a>
<a name="ln831">  }</a>
<a name="ln832">  else</a>
<a name="ln833">  {</a>
<a name="ln834">    // generate inverted homograph (mat3inv function defined in colorspaces.c)</a>
<a name="ln835">    if(mat3inv((float *)homograph, (float *)moutput))</a>
<a name="ln836">    {</a>
<a name="ln837">      // in case of error we set to unity matrix</a>
<a name="ln838">      memset(mwork, 0, 9 * sizeof(float));</a>
<a name="ln839">      mwork[0][0] = 1.0f;</a>
<a name="ln840">      mwork[1][1] = 1.0f;</a>
<a name="ln841">      mwork[2][2] = 1.0f;</a>
<a name="ln842">      memcpy(homograph, mwork, 9 * sizeof(float));</a>
<a name="ln843">    }</a>
<a name="ln844">  }</a>
<a name="ln845">}</a>
<a name="ln846">#undef MAT3SWAP</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">// check if module parameters are set to all neutral values in which case the module's</a>
<a name="ln850">// output is identical to its input</a>
<a name="ln851">static inline int isneutral(dt_iop_ashift_data_t *data)</a>
<a name="ln852">{</a>
<a name="ln853">  // values lower than this have no visible effect</a>
<a name="ln854">  const float eps = 1.0e-4f;</a>
<a name="ln855"> </a>
<a name="ln856">  return(fabs(data-&gt;rotation) &lt; eps &amp;&amp;</a>
<a name="ln857">         fabs(data-&gt;lensshift_v) &lt; eps &amp;&amp;</a>
<a name="ln858">         fabs(data-&gt;lensshift_h) &lt; eps &amp;&amp;</a>
<a name="ln859">         fabs(data-&gt;shear) &lt; eps &amp;&amp;</a>
<a name="ln860">         fabs(data-&gt;aspect - 1.0f) &lt; eps &amp;&amp;</a>
<a name="ln861">         data-&gt;cl &lt; eps &amp;&amp;</a>
<a name="ln862">         1.0f - data-&gt;cr &lt; eps &amp;&amp;</a>
<a name="ln863">         data-&gt;ct &lt; eps &amp;&amp;</a>
<a name="ln864">         1.0f - data-&gt;cb &lt; eps);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867"> </a>
<a name="ln868">int distort_transform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points, size_t points_count)</a>
<a name="ln869">{</a>
<a name="ln870">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln871"> </a>
<a name="ln872">  // nothing to be done if parameters are set to neutral values</a>
<a name="ln873">  if(isneutral(data)) return 1;</a>
<a name="ln874"> </a>
<a name="ln875">  float homograph[3][3];</a>
<a name="ln876">  homography((float *)homograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln877">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln878"> </a>
<a name="ln879">  // clipping offset</a>
<a name="ln880">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln881">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln882">  const float cx = fullwidth * data-&gt;cl;</a>
<a name="ln883">  const float cy = fullheight * data-&gt;ct;</a>
<a name="ln884"> </a>
<a name="ln885">#ifdef _OPENMP</a>
<a name="ln886">#pragma omp parallel for schedule(static) default(none) shared(points, points_count, homograph)</a>
<a name="ln887">#endif</a>
<a name="ln888">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln889">  {</a>
<a name="ln890">    float pi[3] = { points[i], points[i + 1], 1.0f };</a>
<a name="ln891">    float po[3];</a>
<a name="ln892">    mat3mulv(po, (float *)homograph, pi);</a>
<a name="ln893">    points[i] = po[0] / po[2] - cx;</a>
<a name="ln894">    points[i + 1] = po[1] / po[2] - cy;</a>
<a name="ln895">  }</a>
<a name="ln896"> </a>
<a name="ln897">  return 1;</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900"> </a>
<a name="ln901">int distort_backtransform(dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, float *points,</a>
<a name="ln902">                          size_t points_count)</a>
<a name="ln903">{</a>
<a name="ln904">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln905"> </a>
<a name="ln906">  // nothing to be done if parameters are set to neutral values</a>
<a name="ln907">  if(isneutral(data)) return 1;</a>
<a name="ln908"> </a>
<a name="ln909">  float ihomograph[3][3];</a>
<a name="ln910">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln911">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln912"> </a>
<a name="ln913">  // clipping offset</a>
<a name="ln914">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln915">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln916">  const float cx = fullwidth * data-&gt;cl;</a>
<a name="ln917">  const float cy = fullheight * data-&gt;ct;</a>
<a name="ln918"> </a>
<a name="ln919">#ifdef _OPENMP</a>
<a name="ln920">#pragma omp parallel for schedule(static) default(none) shared(points, points_count, ihomograph)</a>
<a name="ln921">#endif</a>
<a name="ln922">  for(size_t i = 0; i &lt; points_count * 2; i += 2)</a>
<a name="ln923">  {</a>
<a name="ln924">    float pi[3] = { points[i] + cx, points[i + 1] + cy, 1.0f };</a>
<a name="ln925">    float po[3];</a>
<a name="ln926">    mat3mulv(po, (float *)ihomograph, pi);</a>
<a name="ln927">    points[i] = po[0] / po[2];</a>
<a name="ln928">    points[i + 1] = po[1] / po[2];</a>
<a name="ln929">  }</a>
<a name="ln930"> </a>
<a name="ln931">  return 1;</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">void distort_mask(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, const float *const in,</a>
<a name="ln935">                  float *const out, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln936">{</a>
<a name="ln937">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln938"> </a>
<a name="ln939">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln940">  if(isneutral(data))</a>
<a name="ln941">  {</a>
<a name="ln942">    memcpy(out, in, (size_t)roi_out-&gt;width * roi_out-&gt;height * sizeof(float));</a>
<a name="ln943">    return;</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln947"> </a>
<a name="ln948">  float ihomograph[3][3];</a>
<a name="ln949">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln950">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln951"> </a>
<a name="ln952">  // clipping offset</a>
<a name="ln953">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln954">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln955">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln956">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">#ifdef _OPENMP</a>
<a name="ln960">#pragma omp parallel for schedule(static) default(none) shared(ihomograph, interpolation)</a>
<a name="ln961">#endif</a>
<a name="ln962">  // go over all pixels of output image</a>
<a name="ln963">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln964">  {</a>
<a name="ln965">    float *_out = out + (size_t)j * roi_out-&gt;width;</a>
<a name="ln966">    for(int i = 0; i &lt; roi_out-&gt;width; i++, _out++)</a>
<a name="ln967">    {</a>
<a name="ln968">      float pin[3], pout[3];</a>
<a name="ln969"> </a>
<a name="ln970">      // convert output pixel coordinates to original image coordinates</a>
<a name="ln971">      pout[0] = roi_out-&gt;x + i + cx;</a>
<a name="ln972">      pout[1] = roi_out-&gt;y + j + cy;</a>
<a name="ln973">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln974">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln975">      pout[2] = 1.0f;</a>
<a name="ln976"> </a>
<a name="ln977">      // apply homograph</a>
<a name="ln978">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln979"> </a>
<a name="ln980">      // convert to input pixel coordinates</a>
<a name="ln981">      pin[0] /= pin[2];</a>
<a name="ln982">      pin[1] /= pin[2];</a>
<a name="ln983">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln984">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln985">      pin[0] -= roi_in-&gt;x;</a>
<a name="ln986">      pin[1] -= roi_in-&gt;y;</a>
<a name="ln987"> </a>
<a name="ln988">      // get output values by interpolation from input image</a>
<a name="ln989">      dt_interpolation_compute_pixel1c(interpolation, in, _out, pin[0], pin[1], roi_in-&gt;width,</a>
<a name="ln990">                                       roi_in-&gt;height, roi_in-&gt;width);</a>
<a name="ln991">    }</a>
<a name="ln992">  }</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">void modify_roi_out(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece, dt_iop_roi_t *roi_out,</a>
<a name="ln996">                    const dt_iop_roi_t *roi_in)</a>
<a name="ln997">{</a>
<a name="ln998">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln999">  *roi_out = *roi_in;</a>
<a name="ln1000"> </a>
<a name="ln1001">  // nothing more to be done if parameters are set to neutral values</a>
<a name="ln1002">  if(isneutral(data)) return;</a>
<a name="ln1003"> </a>
<a name="ln1004">  float homograph[3][3];</a>
<a name="ln1005">  homography((float *)homograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln1006">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln1007"> </a>
<a name="ln1008">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln1009"> </a>
<a name="ln1010">  // go through all four vertices of input roi and convert coordinates to output</a>
<a name="ln1011">  for(int y = 0; y &lt; roi_in-&gt;height; y += roi_in-&gt;height - 1)</a>
<a name="ln1012">  {</a>
<a name="ln1013">    for(int x = 0; x &lt; roi_in-&gt;width; x += roi_in-&gt;width - 1)</a>
<a name="ln1014">    {</a>
<a name="ln1015">      float pin[3], pout[3];</a>
<a name="ln1016"> </a>
<a name="ln1017">      // convert from input coordinates to original image coordinates</a>
<a name="ln1018">      pin[0] = roi_in-&gt;x + x;</a>
<a name="ln1019">      pin[1] = roi_in-&gt;y + y;</a>
<a name="ln1020">      pin[0] /= roi_in-&gt;scale;</a>
<a name="ln1021">      pin[1] /= roi_in-&gt;scale;</a>
<a name="ln1022">      pin[2] = 1.0f;</a>
<a name="ln1023"> </a>
<a name="ln1024">      // apply homograph</a>
<a name="ln1025">      mat3mulv(pout, (float *)homograph, pin);</a>
<a name="ln1026"> </a>
<a name="ln1027">      // convert to output image coordinates</a>
<a name="ln1028">      pout[0] /= pout[2];</a>
<a name="ln1029">      pout[1] /= pout[2];</a>
<a name="ln1030">      pout[0] *= roi_out-&gt;scale;</a>
<a name="ln1031">      pout[1] *= roi_out-&gt;scale;</a>
<a name="ln1032">      xm = MIN(xm, pout[0]);</a>
<a name="ln1033">      xM = MAX(xM, pout[0]);</a>
<a name="ln1034">      ym = MIN(ym, pout[1]);</a>
<a name="ln1035">      yM = MAX(yM, pout[1]);</a>
<a name="ln1036">    }</a>
<a name="ln1037">  }</a>
<a name="ln1038">  float width = xM - xm + 1;</a>
<a name="ln1039">  float height = yM - ym + 1;</a>
<a name="ln1040"> </a>
<a name="ln1041">  // clipping adjustments</a>
<a name="ln1042">  width *= data-&gt;cr - data-&gt;cl;</a>
<a name="ln1043">  height *= data-&gt;cb - data-&gt;ct;</a>
<a name="ln1044"> </a>
<a name="ln1045">  roi_out-&gt;width = floorf(width);</a>
<a name="ln1046">  roi_out-&gt;height = floorf(height);</a>
<a name="ln1047"> </a>
<a name="ln1048">#ifdef ASHIFT_DEBUG</a>
<a name="ln1049">  print_roi(roi_in, &quot;roi_in (going into modify_roi_out)&quot;);</a>
<a name="ln1050">  print_roi(roi_out, &quot;roi_out (after modify_roi_out)&quot;);</a>
<a name="ln1051">#endif</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">void modify_roi_in(struct dt_iop_module_t *self, struct dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1055">                   const dt_iop_roi_t *const roi_out, dt_iop_roi_t *roi_in)</a>
<a name="ln1056">{</a>
<a name="ln1057">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln1058">  *roi_in = *roi_out;</a>
<a name="ln1059"> </a>
<a name="ln1060">  // nothing more to be done if parameters are set to neutral values</a>
<a name="ln1061">  if(isneutral(data)) return;</a>
<a name="ln1062"> </a>
<a name="ln1063">  float ihomograph[3][3];</a>
<a name="ln1064">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln1065">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln1066"> </a>
<a name="ln1067">  const float orig_w = roi_in-&gt;scale * piece-&gt;buf_in.width;</a>
<a name="ln1068">  const float orig_h = roi_in-&gt;scale * piece-&gt;buf_in.height;</a>
<a name="ln1069"> </a>
<a name="ln1070">  // clipping offset</a>
<a name="ln1071">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln1072">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln1073">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln1074">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln1075"> </a>
<a name="ln1076">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln1077"> </a>
<a name="ln1078">  // go through all four vertices of output roi and convert coordinates to input</a>
<a name="ln1079">  for(int y = 0; y &lt; roi_out-&gt;height; y += roi_out-&gt;height - 1)</a>
<a name="ln1080">  {</a>
<a name="ln1081">    for(int x = 0; x &lt; roi_out-&gt;width; x += roi_out-&gt;width - 1)</a>
<a name="ln1082">    {</a>
<a name="ln1083">      float pin[3], pout[3];</a>
<a name="ln1084"> </a>
<a name="ln1085">      // convert from output image coordinates to original image coordinates</a>
<a name="ln1086">      pout[0] = roi_out-&gt;x + x + cx;</a>
<a name="ln1087">      pout[1] = roi_out-&gt;y + y + cy;</a>
<a name="ln1088">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln1089">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln1090">      pout[2] = 1.0f;</a>
<a name="ln1091"> </a>
<a name="ln1092">      // apply homograph</a>
<a name="ln1093">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln1094"> </a>
<a name="ln1095">      // convert to input image coordinates</a>
<a name="ln1096">      pin[0] /= pin[2];</a>
<a name="ln1097">      pin[1] /= pin[2];</a>
<a name="ln1098">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln1099">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln1100">      xm = MIN(xm, pin[0]);</a>
<a name="ln1101">      xM = MAX(xM, pin[0]);</a>
<a name="ln1102">      ym = MIN(ym, pin[1]);</a>
<a name="ln1103">      yM = MAX(yM, pin[1]);</a>
<a name="ln1104">    }</a>
<a name="ln1105">  }</a>
<a name="ln1106"> </a>
<a name="ln1107">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln1108">  roi_in-&gt;x = fmaxf(0.0f, xm - interpolation-&gt;width);</a>
<a name="ln1109">  roi_in-&gt;y = fmaxf(0.0f, ym - interpolation-&gt;width);</a>
<a name="ln1110">  roi_in-&gt;width = fminf(ceilf(orig_w) - roi_in-&gt;x, xM - roi_in-&gt;x + 1 + interpolation-&gt;width);</a>
<a name="ln1111">  roi_in-&gt;height = fminf(ceilf(orig_h) - roi_in-&gt;y, yM - roi_in-&gt;y + 1 + interpolation-&gt;width);</a>
<a name="ln1112"> </a>
<a name="ln1113">  // sanity check.</a>
<a name="ln1114">  roi_in-&gt;x = CLAMP(roi_in-&gt;x, 0, (int)floorf(orig_w));</a>
<a name="ln1115">  roi_in-&gt;y = CLAMP(roi_in-&gt;y, 0, (int)floorf(orig_h));</a>
<a name="ln1116">  roi_in-&gt;width = CLAMP(roi_in-&gt;width, 1, (int)floorf(orig_w) - roi_in-&gt;x);</a>
<a name="ln1117">  roi_in-&gt;height = CLAMP(roi_in-&gt;height, 1, (int)floorf(orig_h) - roi_in-&gt;y);</a>
<a name="ln1118">#ifdef ASHIFT_DEBUG</a>
<a name="ln1119">  print_roi(roi_out, &quot;roi_out (going into modify_roi_in)&quot;);</a>
<a name="ln1120">  print_roi(roi_in, &quot;roi_in (after modify_roi_in)&quot;);</a>
<a name="ln1121">#endif</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">// simple conversion of rgb image into greyscale variant suitable for line segment detection</a>
<a name="ln1125">// the lsd routines expect input as *double, roughly in the range [0.0; 256.0]</a>
<a name="ln1126">static void rgb2grey256(const float *in, double *out, const int width, const int height)</a>
<a name="ln1127">{</a>
<a name="ln1128">  const int ch = 4;</a>
<a name="ln1129"> </a>
<a name="ln1130">#ifdef _OPENMP</a>
<a name="ln1131">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln1132">#endif</a>
<a name="ln1133">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1134">  {</a>
<a name="ln1135">    const float *inp = in + (size_t)ch * j * width;</a>
<a name="ln1136">    double *outp = out + (size_t)j * width;</a>
<a name="ln1137">    for(int i = 0; i &lt; width; i++, inp += ch, outp++)</a>
<a name="ln1138">    {</a>
<a name="ln1139">      *outp = (0.3f * inp[0] + 0.59f * inp[1] + 0.11f * inp[2]) * 256.0;</a>
<a name="ln1140">    }</a>
<a name="ln1141">  }</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">// sobel edge enhancement in one direction</a>
<a name="ln1145">static void edge_enhance_1d(const double *in, double *out, const int width, const int height,</a>
<a name="ln1146">                            dt_iop_ashift_enhance_t dir)</a>
<a name="ln1147">{</a>
<a name="ln1148">  // Sobel kernels for both directions</a>
<a name="ln1149">  const double hkernel[3][3] = { { 1.0, 0.0, -1.0 }, { 2.0, 0.0, -2.0 }, { 1.0, 0.0, -1.0 } };</a>
<a name="ln1150">  const double vkernel[3][3] = { { 1.0, 2.0, 1.0 }, { 0.0, 0.0, 0.0 }, { -1.0, -2.0, -1.0 } };</a>
<a name="ln1151">  const int kwidth = 3;</a>
<a name="ln1152">  const int khwidth = kwidth / 2;</a>
<a name="ln1153"> </a>
<a name="ln1154">  // select kernel</a>
<a name="ln1155">  const double *kernel = (dir == ASHIFT_ENHANCE_HORIZONTAL) ? (const double *)hkernel : (const double *)vkernel;</a>
<a name="ln1156"> </a>
<a name="ln1157">#ifdef _OPENMP</a>
<a name="ln1158">#pragma omp parallel for schedule(static) default(none) shared(in, out, kernel)</a>
<a name="ln1159">#endif</a>
<a name="ln1160">  // loop over image pixels and perform sobel convolution</a>
<a name="ln1161">  for(int j = khwidth; j &lt; height - khwidth; j++)</a>
<a name="ln1162">  {</a>
<a name="ln1163">    const double *inp = in + (size_t)j * width + khwidth;</a>
<a name="ln1164">    double *outp = out + (size_t)j * width + khwidth;</a>
<a name="ln1165">    for(int i = khwidth; i &lt; width - khwidth; i++, inp++, outp++)</a>
<a name="ln1166">    {</a>
<a name="ln1167">      double sum = 0.0f;</a>
<a name="ln1168">      for(int jj = 0; jj &lt; kwidth; jj++)</a>
<a name="ln1169">      {</a>
<a name="ln1170">        const int k = jj * kwidth;</a>
<a name="ln1171">        const int l = (jj - khwidth) * width;</a>
<a name="ln1172">        for(int ii = 0; ii &lt; kwidth; ii++)</a>
<a name="ln1173">        {</a>
<a name="ln1174">          sum += inp[l + ii - khwidth] * kernel[k + ii];</a>
<a name="ln1175">        }</a>
<a name="ln1176">      }</a>
<a name="ln1177">      *outp = sum;</a>
<a name="ln1178">    }</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">#ifdef _OPENMP</a>
<a name="ln1182">#pragma omp parallel for schedule(static) default(none) shared(out)</a>
<a name="ln1183">#endif</a>
<a name="ln1184">  // border fill in output buffer, so we don't get pseudo lines at image frame</a>
<a name="ln1185">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1186">    for(int i = 0; i &lt; width; i++)</a>
<a name="ln1187">    {</a>
<a name="ln1188">      double val = out[j * width + i];</a>
<a name="ln1189"> </a>
<a name="ln1190">      if(j &lt; khwidth)</a>
<a name="ln1191">        val = out[(khwidth - j) * width + i];</a>
<a name="ln1192">      else if(j &gt;= height - khwidth)</a>
<a name="ln1193">        val = out[(j - khwidth) * width + i];</a>
<a name="ln1194">      else if(i &lt; khwidth)</a>
<a name="ln1195">        val = out[j * width + (khwidth - i)];</a>
<a name="ln1196">      else if(i &gt;= width - khwidth)</a>
<a name="ln1197">        val = out[j * width + (i - khwidth)];</a>
<a name="ln1198"> </a>
<a name="ln1199">      out[j * width + i] = val;</a>
<a name="ln1200"> </a>
<a name="ln1201">      // jump over center of image</a>
<a name="ln1202">      if(i == khwidth &amp;&amp; j &gt;= khwidth &amp;&amp; j &lt; height - khwidth) i = width - khwidth;</a>
<a name="ln1203">    }</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">// edge enhancement in both directions</a>
<a name="ln1207">static int edge_enhance(const double *in, double *out, const int width, const int height)</a>
<a name="ln1208">{</a>
<a name="ln1209">  double *Gx = NULL;</a>
<a name="ln1210">  double *Gy = NULL;</a>
<a name="ln1211"> </a>
<a name="ln1212">  Gx = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1213">  if(Gx == NULL) goto error;</a>
<a name="ln1214"> </a>
<a name="ln1215">  Gy = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1216">  if(Gy == NULL) goto error;</a>
<a name="ln1217"> </a>
<a name="ln1218">  // perform edge enhancement in both directions</a>
<a name="ln1219">  edge_enhance_1d(in, Gx, width, height, ASHIFT_ENHANCE_HORIZONTAL);</a>
<a name="ln1220">  edge_enhance_1d(in, Gy, width, height, ASHIFT_ENHANCE_VERTICAL);</a>
<a name="ln1221"> </a>
<a name="ln1222">// calculate absolute values</a>
<a name="ln1223">#ifdef _OPENMP</a>
<a name="ln1224">#pragma omp parallel for schedule(static) default(none) shared(Gx, Gy, out)</a>
<a name="ln1225">#endif</a>
<a name="ln1226">  for(size_t k = 0; k &lt; (size_t)width * height; k++)</a>
<a name="ln1227">  {</a>
<a name="ln1228">    out[k] = sqrt(Gx[k] * Gx[k] + Gy[k] * Gy[k]);</a>
<a name="ln1229">  }</a>
<a name="ln1230"> </a>
<a name="ln1231">  free(Gx);</a>
<a name="ln1232">  free(Gy);</a>
<a name="ln1233">  return TRUE;</a>
<a name="ln1234"> </a>
<a name="ln1235">error:</a>
<a name="ln1236">  if(Gx) free(Gx);</a>
<a name="ln1237">  if(Gy) free(Gy);</a>
<a name="ln1238">  return FALSE;</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">// XYZ -&gt; sRGB matrix</a>
<a name="ln1242">static void XYZ_to_sRGB(const float *XYZ, float *sRGB)</a>
<a name="ln1243">{</a>
<a name="ln1244">  sRGB[0] =  3.1338561f * XYZ[0] - 1.6168667f * XYZ[1] - 0.4906146f * XYZ[2];</a>
<a name="ln1245">  sRGB[1] = -0.9787684f * XYZ[0] + 1.9161415f * XYZ[1] + 0.0334540f * XYZ[2];</a>
<a name="ln1246">  sRGB[2] =  0.0719453f * XYZ[0] - 0.2289914f * XYZ[1] + 1.4052427f * XYZ[2];</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">// sRGB -&gt; XYZ matrix</a>
<a name="ln1250">static void sRGB_to_XYZ(const float *sRGB, float *XYZ)</a>
<a name="ln1251">{</a>
<a name="ln1252">  XYZ[0] = 0.4360747f * sRGB[0] + 0.3850649f * sRGB[1] + 0.1430804f * sRGB[2];</a>
<a name="ln1253">  XYZ[1] = 0.2225045f * sRGB[0] + 0.7168786f * sRGB[1] + 0.0606169f * sRGB[2];</a>
<a name="ln1254">  XYZ[2] = 0.0139322f * sRGB[0] + 0.0971045f * sRGB[1] + 0.7141733f * sRGB[2];</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">// detail enhancement via bilateral grid (function arguments in and out may represent identical buffers)</a>
<a name="ln1258">static int detail_enhance(const float *in, float *out, const int width, const int height)</a>
<a name="ln1259">{</a>
<a name="ln1260">  const float sigma_r = 5.0f;</a>
<a name="ln1261">  const float sigma_s = fminf(width, height) * 0.02f;</a>
<a name="ln1262">  const float detail = 10.0f;</a>
<a name="ln1263"> </a>
<a name="ln1264">  int success = TRUE;</a>
<a name="ln1265"> </a>
<a name="ln1266">  // we need to convert from RGB to Lab first;</a>
<a name="ln1267">  // as colors don't matter we are safe to assume data to be sRGB</a>
<a name="ln1268"> </a>
<a name="ln1269">  // convert RGB input to Lab, use output buffer for intermediate storage</a>
<a name="ln1270">#ifdef _OPENMP</a>
<a name="ln1271">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln1272">#endif</a>
<a name="ln1273">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1274">  {</a>
<a name="ln1275">    const float *inp = in + (size_t)4 * j * width;</a>
<a name="ln1276">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1277">    for(int i = 0; i &lt; width; i++, inp += 4, outp += 4)</a>
<a name="ln1278">    {</a>
<a name="ln1279">      float XYZ[3];</a>
<a name="ln1280">      sRGB_to_XYZ(inp, XYZ);</a>
<a name="ln1281">      dt_XYZ_to_Lab(XYZ, outp);</a>
<a name="ln1282">    }</a>
<a name="ln1283">  }</a>
<a name="ln1284"> </a>
<a name="ln1285">  // bilateral grid detail enhancement</a>
<a name="ln1286">  dt_bilateral_t *b = dt_bilateral_init(width, height, sigma_s, sigma_r);</a>
<a name="ln1287"> </a>
<a name="ln1288">  if(b != NULL)</a>
<a name="ln1289">  {</a>
<a name="ln1290">    dt_bilateral_splat(b, out);</a>
<a name="ln1291">    dt_bilateral_blur(b);</a>
<a name="ln1292">    dt_bilateral_slice_to_output(b, out, out, detail);</a>
<a name="ln1293">    dt_bilateral_free(b);</a>
<a name="ln1294">  }</a>
<a name="ln1295">  else</a>
<a name="ln1296">    success = FALSE;</a>
<a name="ln1297"> </a>
<a name="ln1298">  // convert resulting Lab to RGB output</a>
<a name="ln1299">#ifdef _OPENMP</a>
<a name="ln1300">#pragma omp parallel for schedule(static) default(none) shared(out)</a>
<a name="ln1301">#endif</a>
<a name="ln1302">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1303">  {</a>
<a name="ln1304">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1305">    for(int i = 0; i &lt; width; i++, outp += 4)</a>
<a name="ln1306">    {</a>
<a name="ln1307">      float XYZ[3];</a>
<a name="ln1308">      dt_Lab_to_XYZ(outp, XYZ);</a>
<a name="ln1309">      XYZ_to_sRGB(XYZ, outp);</a>
<a name="ln1310">    }</a>
<a name="ln1311">  }</a>
<a name="ln1312"> </a>
<a name="ln1313">  return success;</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">// apply gamma correction to RGB buffer (function arguments in and out may represent identical buffers)</a>
<a name="ln1317">static void gamma_correct(const float *in, float *out, const int width, const int height)</a>
<a name="ln1318">{</a>
<a name="ln1319">#ifdef _OPENMP</a>
<a name="ln1320">#pragma omp parallel for schedule(static) default(none) shared(in, out)</a>
<a name="ln1321">#endif</a>
<a name="ln1322">  for(int j = 0; j &lt; height; j++)</a>
<a name="ln1323">  {</a>
<a name="ln1324">    const float *inp = in + (size_t)4 * j * width;</a>
<a name="ln1325">    float *outp = out + (size_t)4 * j * width;</a>
<a name="ln1326">    for(int i = 0; i &lt; width; i++, inp += 4, outp += 4)</a>
<a name="ln1327">    {</a>
<a name="ln1328">      for(int c = 0; c &lt; 3; c++)</a>
<a name="ln1329">        outp[c] = powf(inp[c], LSD_GAMMA);</a>
<a name="ln1330">    }</a>
<a name="ln1331">  }</a>
<a name="ln1332">}</a>
<a name="ln1333"> </a>
<a name="ln1334">// do actual line_detection based on LSD algorithm and return results according</a>
<a name="ln1335">// to this module's conventions</a>
<a name="ln1336">static int line_detect(float *in, const int width, const int height, const int x_off, const int y_off,</a>
<a name="ln1337">                       const float scale, dt_iop_ashift_line_t **alines, int *lcount, int *vcount, int *hcount,</a>
<a name="ln1338">                       float *vweight, float *hweight, dt_iop_ashift_enhance_t enhance, const int is_raw)</a>
<a name="ln1339">{</a>
<a name="ln1340">  double *greyscale = NULL;</a>
<a name="ln1341">  double *lsd_lines = NULL;</a>
<a name="ln1342">  dt_iop_ashift_line_t *ashift_lines = NULL;</a>
<a name="ln1343"> </a>
<a name="ln1344">  int vertical_count = 0;</a>
<a name="ln1345">  int horizontal_count = 0;</a>
<a name="ln1346">  float vertical_weight = 0.0f;</a>
<a name="ln1347">  float horizontal_weight = 0.0f;</a>
<a name="ln1348"> </a>
<a name="ln1349">  // apply gamma correction if image is raw</a>
<a name="ln1350">  if(is_raw)</a>
<a name="ln1351">  {</a>
<a name="ln1352">    gamma_correct(in, in, width, height);</a>
<a name="ln1353">  }</a>
<a name="ln1354"> </a>
<a name="ln1355">  // if requested perform an additional detail enhancement step</a>
<a name="ln1356">  if(enhance &amp; ASHIFT_ENHANCE_DETAIL)</a>
<a name="ln1357">  {</a>
<a name="ln1358">    (void)detail_enhance(in, in, width, height);</a>
<a name="ln1359">  }</a>
<a name="ln1360"> </a>
<a name="ln1361">  // allocate intermediate buffers</a>
<a name="ln1362">  greyscale = malloc((size_t)width * height * sizeof(double));</a>
<a name="ln1363">  if(greyscale == NULL) goto error;</a>
<a name="ln1364"> </a>
<a name="ln1365">  // convert to greyscale image</a>
<a name="ln1366">  rgb2grey256(in, greyscale, width, height);</a>
<a name="ln1367"> </a>
<a name="ln1368">  // if requested perform an additional edge enhancement step</a>
<a name="ln1369">  if(enhance &amp; ASHIFT_ENHANCE_EDGES)</a>
<a name="ln1370">  {</a>
<a name="ln1371">    (void)edge_enhance(greyscale, greyscale, width, height);</a>
<a name="ln1372">  }</a>
<a name="ln1373"> </a>
<a name="ln1374">  // call the line segment detector LSD;</a>
<a name="ln1375">  // LSD stores the number of found lines in lines_count.</a>
<a name="ln1376">  // it returns structural details as vector 'double lines[7 * lines_count]'</a>
<a name="ln1377">  int lines_count;</a>
<a name="ln1378">  lsd_lines = LineSegmentDetection(&amp;lines_count, greyscale, width, height,</a>
<a name="ln1379">                                   LSD_SCALE, LSD_SIGMA_SCALE, LSD_QUANT,</a>
<a name="ln1380">                                   LSD_ANG_TH, LSD_LOG_EPS, LSD_DENSITY_TH,</a>
<a name="ln1381">                                   LSD_N_BINS, NULL, NULL, NULL);</a>
<a name="ln1382"> </a>
<a name="ln1383">  // we count the lines that we really want to use</a>
<a name="ln1384">  int lct = 0;</a>
<a name="ln1385"> </a>
<a name="ln1386">  if(lines_count &gt; 0)</a>
<a name="ln1387">  {</a>
<a name="ln1388">    // aggregate lines data into our own structures</a>
<a name="ln1389">    ashift_lines = (dt_iop_ashift_line_t *)malloc((size_t)lines_count * sizeof(dt_iop_ashift_line_t));</a>
<a name="ln1390">    if(ashift_lines == NULL) goto error;</a>
<a name="ln1391"> </a>
<a name="ln1392">    for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln1393">    {</a>
<a name="ln1394">      float x1 = lsd_lines[n * 7 + 0];</a>
<a name="ln1395">      float y1 = lsd_lines[n * 7 + 1];</a>
<a name="ln1396">      float x2 = lsd_lines[n * 7 + 2];</a>
<a name="ln1397">      float y2 = lsd_lines[n * 7 + 3];</a>
<a name="ln1398"> </a>
<a name="ln1399">      // check for lines running along image borders and skip them.</a>
<a name="ln1400">      // these would likely be false-positives which could result</a>
<a name="ln1401">      // from any kind of processing artifacts</a>
<a name="ln1402">      if((fabs(x1 - x2) &lt; 1 &amp;&amp; fmax(x1, x2) &lt; 2) ||</a>
<a name="ln1403">         (fabs(x1 - x2) &lt; 1 &amp;&amp; fmin(x1, x2) &gt; width - 3) ||</a>
<a name="ln1404">         (fabs(y1 - y2) &lt; 1 &amp;&amp; fmax(y1, y2) &lt; 2) ||</a>
<a name="ln1405">         (fabs(y1 - y2) &lt; 1 &amp;&amp; fmin(y1, y2) &gt; height - 3))</a>
<a name="ln1406">        continue;</a>
<a name="ln1407"> </a>
<a name="ln1408">      // line position in absolute coordinates</a>
<a name="ln1409">      float px1 = x_off + x1;</a>
<a name="ln1410">      float py1 = y_off + y1;</a>
<a name="ln1411">      float px2 = x_off + x2;</a>
<a name="ln1412">      float py2 = y_off + y2;</a>
<a name="ln1413"> </a>
<a name="ln1414">      // scale back to input buffer</a>
<a name="ln1415">      px1 /= scale;</a>
<a name="ln1416">      py1 /= scale;</a>
<a name="ln1417">      px2 /= scale;</a>
<a name="ln1418">      py2 /= scale;</a>
<a name="ln1419"> </a>
<a name="ln1420">      // store as homogeneous coordinates</a>
<a name="ln1421">      ashift_lines[lct].p1[0] = px1;</a>
<a name="ln1422">      ashift_lines[lct].p1[1] = py1;</a>
<a name="ln1423">      ashift_lines[lct].p1[2] = 1.0f;</a>
<a name="ln1424">      ashift_lines[lct].p2[0] = px2;</a>
<a name="ln1425">      ashift_lines[lct].p2[1] = py2;</a>
<a name="ln1426">      ashift_lines[lct].p2[2] = 1.0f;</a>
<a name="ln1427"> </a>
<a name="ln1428">      // calculate homogeneous coordinates of connecting line (defined by the two points)</a>
<a name="ln1429">      vec3prodn(ashift_lines[lct].L, ashift_lines[lct].p1, ashift_lines[lct].p2);</a>
<a name="ln1430"> </a>
<a name="ln1431">      // normalaze line coordinates so that x^2 + y^2 = 1</a>
<a name="ln1432">      // (this will always succeed as L is a real line connecting two real points)</a>
<a name="ln1433">      vec3lnorm(ashift_lines[lct].L, ashift_lines[lct].L);</a>
<a name="ln1434"> </a>
<a name="ln1435">      // length and width of rectangle (see LSD)</a>
<a name="ln1436">      ashift_lines[lct].length = sqrt((px2 - px1) * (px2 - px1) + (py2 - py1) * (py2 - py1));</a>
<a name="ln1437">      ashift_lines[lct].width = lsd_lines[n * 7 + 4] / scale;</a>
<a name="ln1438"> </a>
<a name="ln1439">      // ...  and weight (= length * width * angle precision)</a>
<a name="ln1440">      const float weight = ashift_lines[lct].length * ashift_lines[lct].width * lsd_lines[n * 7 + 5];</a>
<a name="ln1441">      ashift_lines[lct].weight = weight;</a>
<a name="ln1442"> </a>
<a name="ln1443"> </a>
<a name="ln1444">      const float angle = atan2(py2 - py1, px2 - px1) / M_PI * 180.0f;</a>
<a name="ln1445">      const int vertical = fabs(fabs(angle) - 90.0f) &lt; MAX_TANGENTIAL_DEVIATION ? 1 : 0;</a>
<a name="ln1446">      const int horizontal = fabs(fabs(fabs(angle) - 90.0f) - 90.0f) &lt; MAX_TANGENTIAL_DEVIATION ? 1 : 0;</a>
<a name="ln1447"> </a>
<a name="ln1448">      const int relevant = ashift_lines[lct].length &gt; MIN_LINE_LENGTH ? 1 : 0;</a>
<a name="ln1449"> </a>
<a name="ln1450">      // register type of line</a>
<a name="ln1451">      dt_iop_ashift_linetype_t type = ASHIFT_LINE_IRRELEVANT;</a>
<a name="ln1452">      if(vertical &amp;&amp; relevant)</a>
<a name="ln1453">      {</a>
<a name="ln1454">        type = ASHIFT_LINE_VERTICAL_SELECTED;</a>
<a name="ln1455">        vertical_count++;</a>
<a name="ln1456">        vertical_weight += weight;</a>
<a name="ln1457">      }</a>
<a name="ln1458">      else if(horizontal &amp;&amp; relevant)</a>
<a name="ln1459">      {</a>
<a name="ln1460">        type = ASHIFT_LINE_HORIZONTAL_SELECTED;</a>
<a name="ln1461">        horizontal_count++;</a>
<a name="ln1462">        horizontal_weight += weight;</a>
<a name="ln1463">      }</a>
<a name="ln1464">      ashift_lines[lct].type = type;</a>
<a name="ln1465"> </a>
<a name="ln1466">      // the next valid line</a>
<a name="ln1467">      lct++;</a>
<a name="ln1468">    }</a>
<a name="ln1469">  }</a>
<a name="ln1470">#ifdef ASHIFT_DEBUG</a>
<a name="ln1471">    printf(&quot;%d lines (vertical %d, horizontal %d, not relevant %d)\n&quot;, lines_count, vertical_count,</a>
<a name="ln1472">           horizontal_count, lct - vertical_count - horizontal_count);</a>
<a name="ln1473">    float xmin = FLT_MAX, xmax = FLT_MIN, ymin = FLT_MAX, ymax = FLT_MIN;</a>
<a name="ln1474">    for(int n = 0; n &lt; lct; n++)</a>
<a name="ln1475">    {</a>
<a name="ln1476">      xmin = fmin(xmin, fmin(ashift_lines[n].p1[0], ashift_lines[n].p2[0]));</a>
<a name="ln1477">      xmax = fmax(xmax, fmax(ashift_lines[n].p1[0], ashift_lines[n].p2[0]));</a>
<a name="ln1478">      ymin = fmin(ymin, fmin(ashift_lines[n].p1[1], ashift_lines[n].p2[1]));</a>
<a name="ln1479">      ymax = fmax(ymax, fmax(ashift_lines[n].p1[1], ashift_lines[n].p2[1]));</a>
<a name="ln1480">      printf(&quot;x1 %.0f, y1 %.0f, x2 %.0f, y2 %.0f, length %.0f, width %f, X %f, Y %f, Z %f, type %d, scalars %f %f\n&quot;,</a>
<a name="ln1481">             ashift_lines[n].p1[0], ashift_lines[n].p1[1], ashift_lines[n].p2[0], ashift_lines[n].p2[1],</a>
<a name="ln1482">             ashift_lines[n].length, ashift_lines[n].width,</a>
<a name="ln1483">             ashift_lines[n].L[0], ashift_lines[n].L[1], ashift_lines[n].L[2], ashift_lines[n].type,</a>
<a name="ln1484">             vec3scalar(ashift_lines[n].p1, ashift_lines[n].L),</a>
<a name="ln1485">             vec3scalar(ashift_lines[n].p2, ashift_lines[n].L));</a>
<a name="ln1486">    }</a>
<a name="ln1487">    printf(&quot;xmin %.0f, xmax %.0f, ymin %.0f, ymax %.0f\n&quot;, xmin, xmax, ymin, ymax);</a>
<a name="ln1488">#endif</a>
<a name="ln1489"> </a>
<a name="ln1490">  // store results in provided locations</a>
<a name="ln1491">  *lcount = lct;</a>
<a name="ln1492">  *vcount = vertical_count;</a>
<a name="ln1493">  *vweight = vertical_weight;</a>
<a name="ln1494">  *hcount = horizontal_count;</a>
<a name="ln1495">  *hweight = horizontal_weight;</a>
<a name="ln1496">  *alines = ashift_lines;</a>
<a name="ln1497"> </a>
<a name="ln1498">  // free intermediate buffers</a>
<a name="ln1499">  free(lsd_lines);</a>
<a name="ln1500">  free(greyscale);</a>
<a name="ln1501">  return lct &gt; 0 ? TRUE : FALSE;</a>
<a name="ln1502"> </a>
<a name="ln1503">error:</a>
<a name="ln1504">  free(lsd_lines);</a>
<a name="ln1505">  free(greyscale);</a>
<a name="ln1506">  return FALSE;</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">// get image from buffer, analyze for structure and save results</a>
<a name="ln1510">static int get_structure(dt_iop_module_t *module, dt_iop_ashift_enhance_t enhance)</a>
<a name="ln1511">{</a>
<a name="ln1512">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1513"> </a>
<a name="ln1514">  float *buffer = NULL;</a>
<a name="ln1515">  int width = 0;</a>
<a name="ln1516">  int height = 0;</a>
<a name="ln1517">  int x_off = 0;</a>
<a name="ln1518">  int y_off = 0;</a>
<a name="ln1519">  float scale = 0.0f;</a>
<a name="ln1520"> </a>
<a name="ln1521">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln1522">  // read buffer data if they are available</a>
<a name="ln1523">  if(g-&gt;buf != NULL)</a>
<a name="ln1524">  {</a>
<a name="ln1525">    width = g-&gt;buf_width;</a>
<a name="ln1526">    height = g-&gt;buf_height;</a>
<a name="ln1527">    x_off = g-&gt;buf_x_off;</a>
<a name="ln1528">    y_off = g-&gt;buf_y_off;</a>
<a name="ln1529">    scale = g-&gt;buf_scale;</a>
<a name="ln1530"> </a>
<a name="ln1531">    // create a temporary buffer to hold image data</a>
<a name="ln1532">    buffer = malloc((size_t)width * height * 4 * sizeof(float));</a>
<a name="ln1533">    if(buffer != NULL)</a>
<a name="ln1534">      memcpy(buffer, g-&gt;buf, (size_t)width * height * 4 * sizeof(float));</a>
<a name="ln1535">  }</a>
<a name="ln1536">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln1537"> </a>
<a name="ln1538">  if(buffer == NULL) goto error;</a>
<a name="ln1539"> </a>
<a name="ln1540">  // get rid of old structural data</a>
<a name="ln1541">  g-&gt;lines_count = 0;</a>
<a name="ln1542">  g-&gt;vertical_count = 0;</a>
<a name="ln1543">  g-&gt;horizontal_count = 0;</a>
<a name="ln1544">  free(g-&gt;lines);</a>
<a name="ln1545">  g-&gt;lines = NULL;</a>
<a name="ln1546"> </a>
<a name="ln1547">  dt_iop_ashift_line_t *lines;</a>
<a name="ln1548">  int lines_count;</a>
<a name="ln1549">  int vertical_count;</a>
<a name="ln1550">  int horizontal_count;</a>
<a name="ln1551">  float vertical_weight;</a>
<a name="ln1552">  float horizontal_weight;</a>
<a name="ln1553"> </a>
<a name="ln1554">  // get new structural data</a>
<a name="ln1555">  if(!line_detect(buffer, width, height, x_off, y_off, scale, &amp;lines, &amp;lines_count,</a>
<a name="ln1556">                  &amp;vertical_count, &amp;horizontal_count, &amp;vertical_weight, &amp;horizontal_weight,</a>
<a name="ln1557">                  enhance, dt_image_is_raw(&amp;module-&gt;dev-&gt;image_storage)))</a>
<a name="ln1558">    goto error;</a>
<a name="ln1559"> </a>
<a name="ln1560">  // save new structural data</a>
<a name="ln1561">  g-&gt;lines_in_width = width;</a>
<a name="ln1562">  g-&gt;lines_in_height = height;</a>
<a name="ln1563">  g-&gt;lines_x_off = x_off;</a>
<a name="ln1564">  g-&gt;lines_y_off = y_off;</a>
<a name="ln1565">  g-&gt;lines_count = lines_count;</a>
<a name="ln1566">  g-&gt;vertical_count = vertical_count;</a>
<a name="ln1567">  g-&gt;horizontal_count = horizontal_count;</a>
<a name="ln1568">  g-&gt;vertical_weight = vertical_weight;</a>
<a name="ln1569">  g-&gt;horizontal_weight = horizontal_weight;</a>
<a name="ln1570">  g-&gt;lines_version++;</a>
<a name="ln1571">  g-&gt;lines_suppressed = 0;</a>
<a name="ln1572">  g-&gt;lines = lines;</a>
<a name="ln1573"> </a>
<a name="ln1574">  free(buffer);</a>
<a name="ln1575">  return TRUE;</a>
<a name="ln1576"> </a>
<a name="ln1577">error:</a>
<a name="ln1578">  free(buffer);</a>
<a name="ln1579">  return FALSE;</a>
<a name="ln1580">}</a>
<a name="ln1581"> </a>
<a name="ln1582"> </a>
<a name="ln1583">// swap two integer values</a>
<a name="ln1584">static inline void swap(int *a, int *b)</a>
<a name="ln1585">{</a>
<a name="ln1586">  int tmp = *a;</a>
<a name="ln1587">  *a = *b;</a>
<a name="ln1588">  *b = tmp;</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591">// do complete permutations</a>
<a name="ln1592">static int quickperm(int *a, int *p, const int N, int *i)</a>
<a name="ln1593">{</a>
<a name="ln1594">  if(*i &gt;= N) return FALSE;</a>
<a name="ln1595"> </a>
<a name="ln1596">  p[*i]--;</a>
<a name="ln1597">  int j = (*i % 2 == 1) ? p[*i] : 0;</a>
<a name="ln1598">  swap(&amp;a[j], &amp;a[*i]);</a>
<a name="ln1599">  *i = 1;</a>
<a name="ln1600">  while(p[*i] == 0)</a>
<a name="ln1601">  {</a>
<a name="ln1602">    p[*i] = *i;</a>
<a name="ln1603">    (*i)++;</a>
<a name="ln1604">  }</a>
<a name="ln1605">  return TRUE;</a>
<a name="ln1606">}</a>
<a name="ln1607"> </a>
<a name="ln1608">// Fisher-Yates shuffle</a>
<a name="ln1609">static void shuffle(int *a, const int N)</a>
<a name="ln1610">{</a>
<a name="ln1611">  for(int i = 0; i &lt; N; i++)</a>
<a name="ln1612">  {</a>
<a name="ln1613">    int j = i + rand() % (N - i);</a>
<a name="ln1614">    swap(&amp;a[j], &amp;a[i]);</a>
<a name="ln1615">  }</a>
<a name="ln1616">}</a>
<a name="ln1617"> </a>
<a name="ln1618">// factorial function</a>
<a name="ln1619">static int fact(const int n)</a>
<a name="ln1620">{</a>
<a name="ln1621">  return (n == 1 ? 1 : n * fact(n - 1));</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">// We use a pseudo-RANSAC algorithm to elminiate ouliers from our set of lines. The</a>
<a name="ln1625">// original RANSAC works on linear optimization problems. Our model is nonlinear. We</a>
<a name="ln1626">// take advantage of the fact that lines interesting for our model are vantage lines</a>
<a name="ln1627">// that meet in one vantage point for each subset of lines (vertical/horizontal).</a>
<a name="ln1628">// Stragegy: we construct a model by (random) sampling within the subset of lines and</a>
<a name="ln1629">// calculate the vantage point. Then we check the &quot;distance&quot; of all other lines to the</a>
<a name="ln1630">// vantage point. The model that gives highest number of lines combined with the highest</a>
<a name="ln1631">// total weight and lowest overall &quot;distance&quot; wins.</a>
<a name="ln1632">// Disadvantage: compared to the original RANSAC we don't get any model parameters that</a>
<a name="ln1633">// we could use for the following NMS fit.</a>
<a name="ln1634">// Self-tuning: we optimize &quot;epsilon&quot;, the hurdle rate to reject a line as an outlier,</a>
<a name="ln1635">// by a number of dry runs first. The target average percentage value of lines to eliminate as</a>
<a name="ln1636">// outliers (without judging on the quality of the model) is given by RANSAC_ELIMINATION_RATIO,</a>
<a name="ln1637">// note: the actual percentage of outliers removed in the final run will be lower because we</a>
<a name="ln1638">// will finally look for the best quality model with the optimized epsilon and that quality value also</a>
<a name="ln1639">// encloses the number of good lines</a>
<a name="ln1640">static void ransac(const dt_iop_ashift_line_t *lines, int *index_set, int *inout_set,</a>
<a name="ln1641">                  const int set_count, const float total_weight, const int xmin, const int xmax,</a>
<a name="ln1642">                  const int ymin, const int ymax)</a>
<a name="ln1643">{</a>
<a name="ln1644">  if(set_count &lt; 3) return;</a>
<a name="ln1645"> </a>
<a name="ln1646">  const size_t set_size = set_count * sizeof(int);</a>
<a name="ln1647">  int *best_set = malloc(set_size);</a>
<a name="ln1648">  memcpy(best_set, index_set, set_size);</a>
<a name="ln1649">  int *best_inout = calloc(1, set_size);</a>
<a name="ln1650"> </a>
<a name="ln1651">  float best_quality = 0.0f;</a>
<a name="ln1652"> </a>
<a name="ln1653">  // hurdle value epsilon for rejecting a line as an outlier will be self-tuning</a>
<a name="ln1654">  // in a number of dry runs</a>
<a name="ln1655">  float epsilon = pow(10.0f, -RANSAC_EPSILON);</a>
<a name="ln1656">  float epsilon_step = RANSAC_EPSILON_STEP;</a>
<a name="ln1657">  // some accounting variables for self-tuning</a>
<a name="ln1658">  int lines_eliminated = 0;</a>
<a name="ln1659">  int valid_runs = 0;</a>
<a name="ln1660"> </a>
<a name="ln1661">  // number of runs to optimize epsilon</a>
<a name="ln1662">  const int optiruns = RANSAC_OPTIMIZATION_STEPS * RANSAC_OPTIMIZATION_DRY_RUNS;</a>
<a name="ln1663">  // go for complete permutations on small set sizes, else for random sample consensus</a>
<a name="ln1664">  const int riter = (set_count &gt; RANSAC_HURDLE) ? RANSAC_RUNS : fact(set_count);</a>
<a name="ln1665"> </a>
<a name="ln1666">  // some data needed for quickperm</a>
<a name="ln1667">  int *perm = malloc((set_count + 1) * sizeof(int));</a>
<a name="ln1668">  for(int n = 0; n &lt; set_count + 1; n++) perm[n] = n;</a>
<a name="ln1669">  int piter = 1;</a>
<a name="ln1670"> </a>
<a name="ln1671">  // inout holds good/bad qualification for each line</a>
<a name="ln1672">  int *inout = malloc(set_size);</a>
<a name="ln1673"> </a>
<a name="ln1674">  for(int r = 0; r &lt; optiruns + riter; r++)</a>
<a name="ln1675">  {</a>
<a name="ln1676">    // get random or systematic variation of index set</a>
<a name="ln1677">    if(set_count &gt; RANSAC_HURDLE || r &lt; optiruns)</a>
<a name="ln1678">      shuffle(index_set, set_count);</a>
<a name="ln1679">    else</a>
<a name="ln1680">      (void)quickperm(index_set, perm, set_count, &amp;piter);</a>
<a name="ln1681"> </a>
<a name="ln1682">    // summed quality evaluation of this run</a>
<a name="ln1683">    float quality = 0.0f;</a>
<a name="ln1684"> </a>
<a name="ln1685">    // we build a model ouf of the first two lines</a>
<a name="ln1686">    const float *L1 = lines[index_set[0]].L;</a>
<a name="ln1687">    const float *L2 = lines[index_set[1]].L;</a>
<a name="ln1688"> </a>
<a name="ln1689">    // get intersection point (ideally a vantage point)</a>
<a name="ln1690">    float V[3];</a>
<a name="ln1691">    vec3prodn(V, L1, L2);</a>
<a name="ln1692"> </a>
<a name="ln1693">    // catch special cases:</a>
<a name="ln1694">    // a) L1 and L2 are identical -&gt; V is NULL -&gt; no valid vantage point</a>
<a name="ln1695">    // b) vantage point lies inside image frame (no chance to correct for this case)</a>
<a name="ln1696">    if(vec3isnull(V) ||</a>
<a name="ln1697">       (fabs(V[2]) &gt; 0.0f &amp;&amp;</a>
<a name="ln1698">        V[0]/V[2] &gt;= xmin &amp;&amp;</a>
<a name="ln1699">        V[1]/V[2] &gt;= ymin &amp;&amp;</a>
<a name="ln1700">        V[0]/V[2] &lt;= xmax &amp;&amp;</a>
<a name="ln1701">        V[1]/V[2] &lt;= ymax))</a>
<a name="ln1702">    {</a>
<a name="ln1703">      // no valid model</a>
<a name="ln1704">      quality = 0.0f;</a>
<a name="ln1705">    }</a>
<a name="ln1706">    else</a>
<a name="ln1707">    {</a>
<a name="ln1708">      // valid model</a>
<a name="ln1709"> </a>
<a name="ln1710">      // normalize V so that x^2 + y^2 + z^2 = 1</a>
<a name="ln1711">      vec3norm(V, V);</a>
<a name="ln1712"> </a>
<a name="ln1713">      // the two lines constituting the model are part of the set</a>
<a name="ln1714">      inout[0] = 1;</a>
<a name="ln1715">      inout[1] = 1;</a>
<a name="ln1716"> </a>
<a name="ln1717">      // go through all remaining lines, check if they are within the model, and</a>
<a name="ln1718">      // mark that fact in inout[].</a>
<a name="ln1719">      // summarize a quality parameter for all lines within the model</a>
<a name="ln1720">      for(int n = 2; n &lt; set_count; n++)</a>
<a name="ln1721">      {</a>
<a name="ln1722">        // L is normalized so that x^2 + y^2 = 1</a>
<a name="ln1723">        const float *L3 = lines[index_set[n]].L;</a>
<a name="ln1724"> </a>
<a name="ln1725">        // we take the absolute value of the dot product of V and L as a measure</a>
<a name="ln1726">        // of the &quot;distance&quot; between point and line. Note that this is not the real euclidian</a>
<a name="ln1727">        // distance but - with the given normalization - just a pragmatically selected number</a>
<a name="ln1728">        // that goes to zero if V lies on L and increases the more V and L are apart</a>
<a name="ln1729">        const float d = fabs(vec3scalar(V, L3));</a>
<a name="ln1730"> </a>
<a name="ln1731">        // depending on d we either include or exclude the point from the set</a>
<a name="ln1732">        inout[n] = (d &lt; epsilon) ? 1 : 0;</a>
<a name="ln1733"> </a>
<a name="ln1734">        float q;</a>
<a name="ln1735"> </a>
<a name="ln1736">        if(inout[n] == 1)</a>
<a name="ln1737">        {</a>
<a name="ln1738">          // a quality parameter that depends 1/3 on the number of lines within the model,</a>
<a name="ln1739">          // 1/3 on their weight, and 1/3 on their weighted distance d to the vantage point</a>
<a name="ln1740">          q = 0.33f / (float)set_count</a>
<a name="ln1741">              + 0.33f * lines[index_set[n]].weight / total_weight</a>
<a name="ln1742">              + 0.33f * (1.0f - d / epsilon) * (float)set_count * lines[index_set[n]].weight / total_weight;</a>
<a name="ln1743">        }</a>
<a name="ln1744">        else</a>
<a name="ln1745">        {</a>
<a name="ln1746">          q = 0.0f;</a>
<a name="ln1747">          lines_eliminated++;</a>
<a name="ln1748">        }</a>
<a name="ln1749"> </a>
<a name="ln1750">        quality += q;</a>
<a name="ln1751">      }</a>
<a name="ln1752">      valid_runs++;</a>
<a name="ln1753">    }</a>
<a name="ln1754"> </a>
<a name="ln1755">    if(r &lt; optiruns)</a>
<a name="ln1756">    {</a>
<a name="ln1757">      // on last run of each self-tuning step</a>
<a name="ln1758">      if((r % RANSAC_OPTIMIZATION_DRY_RUNS) == (RANSAC_OPTIMIZATION_DRY_RUNS - 1) &amp;&amp; (valid_runs &gt; 0))</a>
<a name="ln1759">      {</a>
<a name="ln1760">#ifdef ASHIFT_DEBUG</a>
<a name="ln1761">        printf(&quot;ransac self-tuning (run %d): epsilon %f&quot;, r, epsilon);</a>
<a name="ln1762">#endif</a>
<a name="ln1763">        // average ratio of lines that we eliminated with the given epsilon</a>
<a name="ln1764">        float ratio = 100.0f * (float)lines_eliminated / ((float)set_count * valid_runs);</a>
<a name="ln1765">        // adjust epsilon accordingly</a>
<a name="ln1766">        if(ratio &lt; RANSAC_ELIMINATION_RATIO)</a>
<a name="ln1767">          epsilon = pow(10.0f, log10(epsilon) - epsilon_step);</a>
<a name="ln1768">        else if(ratio &gt; RANSAC_ELIMINATION_RATIO)</a>
<a name="ln1769">          epsilon = pow(10.0f, log10(epsilon) + epsilon_step);</a>
<a name="ln1770">#ifdef ASHIFT_DEBUG</a>
<a name="ln1771">        printf(&quot; (elimination ratio %f) -&gt; %f\n&quot;, ratio, epsilon);</a>
<a name="ln1772">#endif</a>
<a name="ln1773">        // reduce step-size for next optimization round</a>
<a name="ln1774">        epsilon_step /= 2.0f;</a>
<a name="ln1775">        lines_eliminated = 0;</a>
<a name="ln1776">        valid_runs = 0;</a>
<a name="ln1777">      }</a>
<a name="ln1778">    }</a>
<a name="ln1779">    else</a>
<a name="ln1780">    {</a>
<a name="ln1781">      // in the &quot;real&quot; runs check against the best model found so far</a>
<a name="ln1782">      if(quality &gt; best_quality)</a>
<a name="ln1783">      {</a>
<a name="ln1784">        memcpy(best_set, index_set, set_size);</a>
<a name="ln1785">        memcpy(best_inout, inout, set_size);</a>
<a name="ln1786">        best_quality = quality;</a>
<a name="ln1787">      }</a>
<a name="ln1788">    }</a>
<a name="ln1789"> </a>
<a name="ln1790">#ifdef ASHIFT_DEBUG</a>
<a name="ln1791">    // report some statistics</a>
<a name="ln1792">    int count = 0, lastcount = 0;</a>
<a name="ln1793">    for(int n = 0; n &lt; set_count; n++) count += best_inout[n];</a>
<a name="ln1794">    for(int n = 0; n &lt; set_count; n++) lastcount += inout[n];</a>
<a name="ln1795">    printf(&quot;ransac run %d: best qual %.6f, eps %.6f, line count %d of %d (this run: qual %.5f, count %d (%2f%%))\n&quot;, r,</a>
<a name="ln1796">           best_quality, epsilon, count, set_count, quality, lastcount, 100.0f * lastcount / (float)set_count);</a>
<a name="ln1797">#endif</a>
<a name="ln1798">  }</a>
<a name="ln1799"> </a>
<a name="ln1800">  // store back best set</a>
<a name="ln1801">  memcpy(index_set, best_set, set_size);</a>
<a name="ln1802">  memcpy(inout_set, best_inout, set_size);</a>
<a name="ln1803"> </a>
<a name="ln1804">  free(inout);</a>
<a name="ln1805">  free(perm);</a>
<a name="ln1806">  free(best_inout);</a>
<a name="ln1807">  free(best_set);</a>
<a name="ln1808">}</a>
<a name="ln1809"> </a>
<a name="ln1810"> </a>
<a name="ln1811">// try to clean up structural data by eliminating outliers and thereby increasing</a>
<a name="ln1812">// the chance of a convergent fitting</a>
<a name="ln1813">static int remove_outliers(dt_iop_module_t *module)</a>
<a name="ln1814">{</a>
<a name="ln1815">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln1816"> </a>
<a name="ln1817">  const int width = g-&gt;lines_in_width;</a>
<a name="ln1818">  const int height = g-&gt;lines_in_height;</a>
<a name="ln1819">  const int xmin = g-&gt;lines_x_off;</a>
<a name="ln1820">  const int ymin = g-&gt;lines_y_off;</a>
<a name="ln1821">  const int xmax = xmin + width;</a>
<a name="ln1822">  const int ymax = ymin + height;</a>
<a name="ln1823"> </a>
<a name="ln1824">  // holds the index set of lines we want to work on</a>
<a name="ln1825">  int *lines_set = malloc(g-&gt;lines_count * sizeof(int));</a>
<a name="ln1826">  // holds the result of ransac</a>
<a name="ln1827">  int *inout_set = malloc(g-&gt;lines_count * sizeof(int));</a>
<a name="ln1828"> </a>
<a name="ln1829">  // some accounting variables</a>
<a name="ln1830">  int vnb = 0, vcount = 0;</a>
<a name="ln1831">  int hnb = 0, hcount = 0;</a>
<a name="ln1832"> </a>
<a name="ln1833">  // just to be on the safe side</a>
<a name="ln1834">  if(g-&gt;lines == NULL) goto error;</a>
<a name="ln1835"> </a>
<a name="ln1836">  // generate index list for the vertical lines</a>
<a name="ln1837">  for(int n = 0; n &lt; g-&gt;lines_count; n++)</a>
<a name="ln1838">  {</a>
<a name="ln1839">    // is this a selected vertical line?</a>
<a name="ln1840">    if((g-&gt;lines[n].type &amp; ASHIFT_LINE_MASK) != ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln1841">      continue;</a>
<a name="ln1842"> </a>
<a name="ln1843">    lines_set[vnb] = n;</a>
<a name="ln1844">    inout_set[vnb] = 0;</a>
<a name="ln1845">    vnb++;</a>
<a name="ln1846">  }</a>
<a name="ln1847"> </a>
<a name="ln1848">  // it only makes sense to call ransac if we have more than two lines</a>
<a name="ln1849">  if(vnb &gt; 2)</a>
<a name="ln1850">    ransac(g-&gt;lines, lines_set, inout_set, vnb, g-&gt;vertical_weight,</a>
<a name="ln1851">           xmin, xmax, ymin, ymax);</a>
<a name="ln1852"> </a>
<a name="ln1853">  // adjust line selected flag according to the ransac results</a>
<a name="ln1854">  for(int n = 0; n &lt; vnb; n++)</a>
<a name="ln1855">  {</a>
<a name="ln1856">    const int m = lines_set[n];</a>
<a name="ln1857">    if(inout_set[n] == 1)</a>
<a name="ln1858">    {</a>
<a name="ln1859">      g-&gt;lines[m].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln1860">      vcount++;</a>
<a name="ln1861">    }</a>
<a name="ln1862">    else</a>
<a name="ln1863">      g-&gt;lines[m].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln1864">  }</a>
<a name="ln1865">  // update number of vertical lines</a>
<a name="ln1866">  g-&gt;vertical_count = vcount;</a>
<a name="ln1867">  g-&gt;lines_version++;</a>
<a name="ln1868"> </a>
<a name="ln1869">  // now generate index list for the horizontal lines</a>
<a name="ln1870">  for(int n = 0; n &lt; g-&gt;lines_count; n++)</a>
<a name="ln1871">  {</a>
<a name="ln1872">    // is this a selected horizontal line?</a>
<a name="ln1873">    if((g-&gt;lines[n].type &amp; ASHIFT_LINE_MASK) != ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln1874">      continue;</a>
<a name="ln1875"> </a>
<a name="ln1876">    lines_set[hnb] = n;</a>
<a name="ln1877">    inout_set[hnb] = 0;</a>
<a name="ln1878">    hnb++;</a>
<a name="ln1879">  }</a>
<a name="ln1880"> </a>
<a name="ln1881">  // it only makes sense to call ransac if we have more than two lines</a>
<a name="ln1882">  if(hnb &gt; 2)</a>
<a name="ln1883">    ransac(g-&gt;lines, lines_set, inout_set, hnb, g-&gt;horizontal_weight,</a>
<a name="ln1884">           xmin, xmax, ymin, ymax);</a>
<a name="ln1885"> </a>
<a name="ln1886">  // adjust line selected flag according to the ransac results</a>
<a name="ln1887">  for(int n = 0; n &lt; hnb; n++)</a>
<a name="ln1888">  {</a>
<a name="ln1889">    const int m = lines_set[n];</a>
<a name="ln1890">    if(inout_set[n] == 1)</a>
<a name="ln1891">    {</a>
<a name="ln1892">      g-&gt;lines[m].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln1893">      hcount++;</a>
<a name="ln1894">    }</a>
<a name="ln1895">    else</a>
<a name="ln1896">      g-&gt;lines[m].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln1897">  }</a>
<a name="ln1898">  // update number of horizontal lines</a>
<a name="ln1899">  g-&gt;horizontal_count = hcount;</a>
<a name="ln1900">  g-&gt;lines_version++;</a>
<a name="ln1901"> </a>
<a name="ln1902">  free(inout_set);</a>
<a name="ln1903">  free(lines_set);</a>
<a name="ln1904"> </a>
<a name="ln1905">  return TRUE;</a>
<a name="ln1906"> </a>
<a name="ln1907">error:</a>
<a name="ln1908">  free(inout_set);</a>
<a name="ln1909">  free(lines_set);</a>
<a name="ln1910">  return FALSE;</a>
<a name="ln1911">}</a>
<a name="ln1912"> </a>
<a name="ln1913">// utility function to map a variable in [min; max] to [-INF; + INF]</a>
<a name="ln1914">static inline double logit(double x, double min, double max)</a>
<a name="ln1915">{</a>
<a name="ln1916">  const double eps = 1.0e-6;</a>
<a name="ln1917">  // make sure p does not touch the borders of its definition area,</a>
<a name="ln1918">  // not critical for data accuracy as logit() is only used on initial fit parameters</a>
<a name="ln1919">  double p = CLAMP((x - min) / (max - min), eps, 1.0 - eps);</a>
<a name="ln1920"> </a>
<a name="ln1921">  return (2.0 * atanh(2.0 * p - 1.0));</a>
<a name="ln1922">}</a>
<a name="ln1923"> </a>
<a name="ln1924">// inverted function to logit()</a>
<a name="ln1925">static inline double ilogit(double L, double min, double max)</a>
<a name="ln1926">{</a>
<a name="ln1927">  double p = 0.5 * (1.0 + tanh(0.5 * L));</a>
<a name="ln1928"> </a>
<a name="ln1929">  return (p * (max - min) + min);</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">// helper function for simplex() return quality parameter for the given model</a>
<a name="ln1933">// strategy:</a>
<a name="ln1934">//    * generate homography matrix out of fixed parameters and fitting parameters</a>
<a name="ln1935">//    * apply homography to all end points of affected lines</a>
<a name="ln1936">//    * generate new line out of transformed end points</a>
<a name="ln1937">//    * calculate scalar product s of line with perpendicular axis</a>
<a name="ln1938">//    * sum over weighted s^2 values</a>
<a name="ln1939">static double model_fitness(double *params, void *data)</a>
<a name="ln1940">{</a>
<a name="ln1941">  dt_iop_ashift_fit_params_t *fit = (dt_iop_ashift_fit_params_t *)data;</a>
<a name="ln1942"> </a>
<a name="ln1943">  // just for convenience: get shorter names</a>
<a name="ln1944">  dt_iop_ashift_line_t *lines = fit-&gt;lines;</a>
<a name="ln1945">  const int lines_count = fit-&gt;lines_count;</a>
<a name="ln1946">  const int width = fit-&gt;width;</a>
<a name="ln1947">  const int height = fit-&gt;height;</a>
<a name="ln1948">  const float f_length_kb = fit-&gt;f_length_kb;</a>
<a name="ln1949">  const float orthocorr = fit-&gt;orthocorr;</a>
<a name="ln1950">  const float aspect = fit-&gt;aspect;</a>
<a name="ln1951"> </a>
<a name="ln1952">  float rotation = fit-&gt;rotation;</a>
<a name="ln1953">  float lensshift_v = fit-&gt;lensshift_v;</a>
<a name="ln1954">  float lensshift_h = fit-&gt;lensshift_h;</a>
<a name="ln1955">  float shear = fit-&gt;shear;</a>
<a name="ln1956">  float rotation_range = fit-&gt;rotation_range;</a>
<a name="ln1957">  float lensshift_v_range = fit-&gt;lensshift_v_range;</a>
<a name="ln1958">  float lensshift_h_range = fit-&gt;lensshift_h_range;</a>
<a name="ln1959">  float shear_range = fit-&gt;shear_range;</a>
<a name="ln1960"> </a>
<a name="ln1961">  int pcount = 0;</a>
<a name="ln1962"> </a>
<a name="ln1963">  // fill in fit parameters from params[]. Attention: order matters!!!</a>
<a name="ln1964">  if(isnan(rotation))</a>
<a name="ln1965">  {</a>
<a name="ln1966">    rotation = ilogit(params[pcount], -rotation_range, rotation_range);</a>
<a name="ln1967">    pcount++;</a>
<a name="ln1968">  }</a>
<a name="ln1969"> </a>
<a name="ln1970">  if(isnan(lensshift_v))</a>
<a name="ln1971">  {</a>
<a name="ln1972">    lensshift_v = ilogit(params[pcount], -lensshift_v_range, lensshift_v_range);</a>
<a name="ln1973">    pcount++;</a>
<a name="ln1974">  }</a>
<a name="ln1975"> </a>
<a name="ln1976">  if(isnan(lensshift_h))</a>
<a name="ln1977">  {</a>
<a name="ln1978">    lensshift_h = ilogit(params[pcount], -lensshift_h_range, lensshift_h_range);</a>
<a name="ln1979">    pcount++;</a>
<a name="ln1980">  }</a>
<a name="ln1981"> </a>
<a name="ln1982">  if(isnan(shear))</a>
<a name="ln1983">  {</a>
<a name="ln1984">    shear = ilogit(params[pcount], -shear_range, shear_range);</a>
<a name="ln1985">    pcount++;</a>
<a name="ln1986">  }</a>
<a name="ln1987"> </a>
<a name="ln1988">  assert(pcount == fit-&gt;params_count);</a>
<a name="ln1989"> </a>
<a name="ln1990">  // the possible reference axes</a>
<a name="ln1991">  const float Av[3] = { 1.0f, 0.0f, 0.0f };</a>
<a name="ln1992">  const float Ah[3] = { 0.0f, 1.0f, 0.0f };</a>
<a name="ln1993"> </a>
<a name="ln1994">  // generate homograph out of the parameters</a>
<a name="ln1995">  float homograph[3][3];</a>
<a name="ln1996">  homography((float *)homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln1997">             orthocorr, aspect, width, height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln1998"> </a>
<a name="ln1999">  // accounting variables</a>
<a name="ln2000">  double sumsq_v = 0.0;</a>
<a name="ln2001">  double sumsq_h = 0.0;</a>
<a name="ln2002">  double weight_v = 0.0;</a>
<a name="ln2003">  double weight_h = 0.0;</a>
<a name="ln2004">  int count_v = 0;</a>
<a name="ln2005">  int count_h = 0;</a>
<a name="ln2006">  int count = 0;</a>
<a name="ln2007"> </a>
<a name="ln2008">  // iterate over all lines</a>
<a name="ln2009">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln2010">  {</a>
<a name="ln2011">    // check if this is a line which we must skip</a>
<a name="ln2012">    if((lines[n].type &amp; fit-&gt;linemask) != fit-&gt;linetype)</a>
<a name="ln2013">      continue;</a>
<a name="ln2014"> </a>
<a name="ln2015">    // the direction of this line (vertical?)</a>
<a name="ln2016">    const int isvertical = lines[n].type &amp; ASHIFT_LINE_DIRVERT;</a>
<a name="ln2017"> </a>
<a name="ln2018">    // select the perpendicular reference axis</a>
<a name="ln2019">    const float *A = isvertical ? Ah : Av;</a>
<a name="ln2020"> </a>
<a name="ln2021">    // apply homographic transformation to the end points</a>
<a name="ln2022">    float P1[3], P2[3];</a>
<a name="ln2023">    mat3mulv(P1, (float *)homograph, lines[n].p1);</a>
<a name="ln2024">    mat3mulv(P2, (float *)homograph, lines[n].p2);</a>
<a name="ln2025"> </a>
<a name="ln2026">    // get line connecting the two points</a>
<a name="ln2027">    float L[3];</a>
<a name="ln2028">    vec3prodn(L, P1, P2);</a>
<a name="ln2029"> </a>
<a name="ln2030">    // normalize L so that x^2 + y^2 = 1; makes sure that</a>
<a name="ln2031">    // y^2 = 1 / (1 + m^2) and x^2 = m^2 / (1 + m^2) with m defining the slope of the line</a>
<a name="ln2032">    vec3lnorm(L, L);</a>
<a name="ln2033"> </a>
<a name="ln2034">    // get scalar product of line L with orthogonal axis A -&gt; gives 0 if line is perpendicular</a>
<a name="ln2035">    float s = vec3scalar(L, A);</a>
<a name="ln2036"> </a>
<a name="ln2037">    // sum up weighted s^2 for both directions individually</a>
<a name="ln2038">    sumsq_v += isvertical ? s * s * lines[n].weight : 0.0;</a>
<a name="ln2039">    weight_v  += isvertical ? lines[n].weight : 0.0;</a>
<a name="ln2040">    count_v += isvertical ? 1 : 0;</a>
<a name="ln2041">    sumsq_h += !isvertical ? s * s * lines[n].weight : 0.0;</a>
<a name="ln2042">    weight_h  += !isvertical ? lines[n].weight : 0.0;</a>
<a name="ln2043">    count_h += !isvertical ? 1 : 0;</a>
<a name="ln2044">    count++;</a>
<a name="ln2045">  }</a>
<a name="ln2046"> </a>
<a name="ln2047">  const double v = weight_v &gt; 0.0f &amp;&amp; count &gt; 0 ? sumsq_v / weight_v * (float)count_v / count : 0.0;</a>
<a name="ln2048">  const double h = weight_h &gt; 0.0f &amp;&amp; count &gt; 0 ? sumsq_h / weight_h * (float)count_h / count : 0.0;</a>
<a name="ln2049"> </a>
<a name="ln2050">  double sum = sqrt(1.0 - (1.0 - v) * (1.0 - h)) * 1.0e6;</a>
<a name="ln2051">  //double sum = sqrt(v + h) * 1.0e6;</a>
<a name="ln2052"> </a>
<a name="ln2053">#ifdef ASHIFT_DEBUG</a>
<a name="ln2054">  printf(&quot;fitness with rotation %f, lensshift_v %f, lensshift_h %f, shear %f -&gt; lines %d, quality %10f\n&quot;,</a>
<a name="ln2055">         rotation, lensshift_v, lensshift_h, shear, count, sum);</a>
<a name="ln2056">#endif</a>
<a name="ln2057"> </a>
<a name="ln2058">  return sum;</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061">// setup all data structures for fitting and call NM simplex</a>
<a name="ln2062">static dt_iop_ashift_nmsresult_t nmsfit(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2063">{</a>
<a name="ln2064">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2065"> </a>
<a name="ln2066">  if(!g-&gt;lines) return NMS_NOT_ENOUGH_LINES;</a>
<a name="ln2067">  if(dir == ASHIFT_FIT_NONE) return NMS_SUCCESS;</a>
<a name="ln2068"> </a>
<a name="ln2069">  double params[4];</a>
<a name="ln2070">  int pcount = 0;</a>
<a name="ln2071">  int enough_lines = TRUE;</a>
<a name="ln2072"> </a>
<a name="ln2073">  // initialize fit parameters</a>
<a name="ln2074">  dt_iop_ashift_fit_params_t fit;</a>
<a name="ln2075">  fit.lines = g-&gt;lines;</a>
<a name="ln2076">  fit.lines_count = g-&gt;lines_count;</a>
<a name="ln2077">  fit.width = g-&gt;lines_in_width;</a>
<a name="ln2078">  fit.height = g-&gt;lines_in_height;</a>
<a name="ln2079">  fit.f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2080">  fit.orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2081">  fit.aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2082">  fit.rotation = p-&gt;rotation;</a>
<a name="ln2083">  fit.lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2084">  fit.lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2085">  fit.shear = p-&gt;shear;</a>
<a name="ln2086">  fit.rotation_range = g-&gt;rotation_range;</a>
<a name="ln2087">  fit.lensshift_v_range = g-&gt;lensshift_v_range;</a>
<a name="ln2088">  fit.lensshift_h_range = g-&gt;lensshift_h_range;</a>
<a name="ln2089">  fit.shear_range = g-&gt;shear_range;</a>
<a name="ln2090">  fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2091">  fit.linemask = ASHIFT_LINE_MASK;</a>
<a name="ln2092">  fit.params_count = 0;</a>
<a name="ln2093">  fit.weight = 0.0f;</a>
<a name="ln2094"> </a>
<a name="ln2095">  // if the image is flipped and if we do not want to fit both lens shift</a>
<a name="ln2096">  // directions or none at all, then we need to change direction</a>
<a name="ln2097">  dt_iop_ashift_fitaxis_t mdir = dir;</a>
<a name="ln2098">  if((mdir &amp; ASHIFT_FIT_LENS_BOTH) != ASHIFT_FIT_LENS_BOTH &amp;&amp;</a>
<a name="ln2099">     (mdir &amp; ASHIFT_FIT_LENS_BOTH) != 0)</a>
<a name="ln2100">  {</a>
<a name="ln2101">    // flip all directions</a>
<a name="ln2102">    mdir ^= g-&gt;isflipped ? ASHIFT_FIT_FLIP : 0;</a>
<a name="ln2103">    // special case that needs to be corrected</a>
<a name="ln2104">    mdir |= (mdir &amp; ASHIFT_FIT_LINES_BOTH) == 0 ? ASHIFT_FIT_LINES_BOTH : 0;</a>
<a name="ln2105">  }</a>
<a name="ln2106"> </a>
<a name="ln2107"> </a>
<a name="ln2108">  // prepare fit structure and starting parameters for simplex fit.</a>
<a name="ln2109">  // note: the sequence of parameters in params[] needs to match the</a>
<a name="ln2110">  // respective order in dt_iop_ashift_fit_params_t. Parameters which are</a>
<a name="ln2111">  // to be fittet are marked with NAN in the fit structure. Non-NAN</a>
<a name="ln2112">  // parameters are assumed to be constant.</a>
<a name="ln2113">  if(mdir &amp; ASHIFT_FIT_ROTATION)</a>
<a name="ln2114">  {</a>
<a name="ln2115">    // we fit rotation</a>
<a name="ln2116">    fit.params_count++;</a>
<a name="ln2117">    params[pcount] = logit(fit.rotation, -fit.rotation_range, fit.rotation_range);</a>
<a name="ln2118">    pcount++;</a>
<a name="ln2119">    fit.rotation = NAN;</a>
<a name="ln2120">  }</a>
<a name="ln2121"> </a>
<a name="ln2122">  if(mdir &amp; ASHIFT_FIT_LENS_VERT)</a>
<a name="ln2123">  {</a>
<a name="ln2124">    // we fit vertical lens shift</a>
<a name="ln2125">    fit.params_count++;</a>
<a name="ln2126">    params[pcount] = logit(fit.lensshift_v, -fit.lensshift_v_range, fit.lensshift_v_range);</a>
<a name="ln2127">    pcount++;</a>
<a name="ln2128">    fit.lensshift_v = NAN;</a>
<a name="ln2129">  }</a>
<a name="ln2130"> </a>
<a name="ln2131">  if(mdir &amp; ASHIFT_FIT_LENS_HOR)</a>
<a name="ln2132">  {</a>
<a name="ln2133">    // we fit horizontal lens shift</a>
<a name="ln2134">    fit.params_count++;</a>
<a name="ln2135">    params[pcount] = logit(fit.lensshift_h, -fit.lensshift_h_range, fit.lensshift_h_range);</a>
<a name="ln2136">    pcount++;</a>
<a name="ln2137">    fit.lensshift_h = NAN;</a>
<a name="ln2138">  }</a>
<a name="ln2139"> </a>
<a name="ln2140">  if(mdir &amp; ASHIFT_FIT_SHEAR)</a>
<a name="ln2141">  {</a>
<a name="ln2142">    // we fit the shear parameter</a>
<a name="ln2143">    fit.params_count++;</a>
<a name="ln2144">    params[pcount] = logit(fit.shear, -fit.shear_range, fit.shear_range);</a>
<a name="ln2145">    pcount++;</a>
<a name="ln2146">    fit.shear = NAN;</a>
<a name="ln2147">  }</a>
<a name="ln2148"> </a>
<a name="ln2149">  if(mdir &amp; ASHIFT_FIT_LINES_VERT)</a>
<a name="ln2150">  {</a>
<a name="ln2151">    // we use vertical lines for fitting</a>
<a name="ln2152">    fit.linetype |= ASHIFT_LINE_DIRVERT;</a>
<a name="ln2153">    fit.weight += g-&gt;vertical_weight;</a>
<a name="ln2154">    enough_lines = enough_lines &amp;&amp; (g-&gt;vertical_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2155">  }</a>
<a name="ln2156"> </a>
<a name="ln2157">  if(mdir &amp; ASHIFT_FIT_LINES_HOR)</a>
<a name="ln2158">  {</a>
<a name="ln2159">    // we use horizontal lines for fitting</a>
<a name="ln2160">    fit.linetype |= 0;</a>
<a name="ln2161">    fit.weight += g-&gt;horizontal_weight;</a>
<a name="ln2162">    enough_lines = enough_lines &amp;&amp; (g-&gt;horizontal_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2163">  }</a>
<a name="ln2164"> </a>
<a name="ln2165">  // this needs to come after ASHIFT_FIT_LINES_VERT and ASHIFT_FIT_LINES_HOR</a>
<a name="ln2166">  if((mdir &amp; ASHIFT_FIT_LINES_BOTH) == ASHIFT_FIT_LINES_BOTH)</a>
<a name="ln2167">  {</a>
<a name="ln2168">    // if we use fitting in both directions we need to</a>
<a name="ln2169">    // adjust fit.linetype and fit.linemask to match all selected lines</a>
<a name="ln2170">    fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2171">    fit.linemask = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2172">  }</a>
<a name="ln2173"> </a>
<a name="ln2174">  // error case: we do not run simplex if there are not enough lines</a>
<a name="ln2175">  if(!enough_lines)</a>
<a name="ln2176">  {</a>
<a name="ln2177">#ifdef ASHIFT_DEBUG</a>
<a name="ln2178">    printf(&quot;optimization not possible: insufficient number of lines\n&quot;);</a>
<a name="ln2179">#endif</a>
<a name="ln2180">    return NMS_NOT_ENOUGH_LINES;</a>
<a name="ln2181">  }</a>
<a name="ln2182"> </a>
<a name="ln2183">  // start the simplex fit</a>
<a name="ln2184">  int iter = simplex(model_fitness, params, fit.params_count, NMS_EPSILON, NMS_SCALE, NMS_ITERATIONS, NULL, (void*)&amp;fit);</a>
<a name="ln2185"> </a>
<a name="ln2186">  // error case: the fit did not converge</a>
<a name="ln2187">  if(iter &gt;= NMS_ITERATIONS)</a>
<a name="ln2188">  {</a>
<a name="ln2189">#ifdef ASHIFT_DEBUG</a>
<a name="ln2190">    printf(&quot;optimization not successful: maximum number of iterations reached (%d)\n&quot;, iter);</a>
<a name="ln2191">#endif</a>
<a name="ln2192">    return NMS_DID_NOT_CONVERGE;</a>
<a name="ln2193">  }</a>
<a name="ln2194"> </a>
<a name="ln2195">  // fit was successful: now consolidate the results (order matters!!!)</a>
<a name="ln2196">  pcount = 0;</a>
<a name="ln2197">  fit.rotation = isnan(fit.rotation) ? ilogit(params[pcount++], -fit.rotation_range, fit.rotation_range) : fit.rotation;</a>
<a name="ln2198">  fit.lensshift_v = isnan(fit.lensshift_v) ? ilogit(params[pcount++], -fit.lensshift_v_range, fit.lensshift_v_range) : fit.lensshift_v;</a>
<a name="ln2199">  fit.lensshift_h = isnan(fit.lensshift_h) ? ilogit(params[pcount++], -fit.lensshift_h_range, fit.lensshift_h_range) : fit.lensshift_h;</a>
<a name="ln2200">  fit.shear = isnan(fit.shear) ? ilogit(params[pcount++], -fit.shear_range, fit.shear_range) : fit.shear;</a>
<a name="ln2201">#ifdef ASHIFT_DEBUG</a>
<a name="ln2202">  printf(&quot;params after optimization (%d iterations): rotation %f, lensshift_v %f, lensshift_h %f, shear %f\n&quot;,</a>
<a name="ln2203">         iter, fit.rotation, fit.lensshift_v, fit.lensshift_h, fit.shear);</a>
<a name="ln2204">#endif</a>
<a name="ln2205"> </a>
<a name="ln2206">  // sanity check: in case of extreme values the image gets distorted so strongly that it spans an insanely huge area. we check that</a>
<a name="ln2207">  // case and assume values that increase the image area by more than a factor of 4 as being insane.</a>
<a name="ln2208">  float homograph[3][3];</a>
<a name="ln2209">  homography((float *)homograph, fit.rotation, fit.lensshift_v, fit.lensshift_h, fit.shear, fit.f_length_kb,</a>
<a name="ln2210">             fit.orthocorr, fit.aspect, fit.width, fit.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2211"> </a>
<a name="ln2212">  // visit all four corners and find maximum span</a>
<a name="ln2213">  float xm = FLT_MAX, xM = -FLT_MAX, ym = FLT_MAX, yM = -FLT_MAX;</a>
<a name="ln2214">  for(int y = 0; y &lt; fit.height; y += fit.height - 1)</a>
<a name="ln2215">    for(int x = 0; x &lt; fit.width; x += fit.width - 1)</a>
<a name="ln2216">    {</a>
<a name="ln2217">      float pi[3], po[3];</a>
<a name="ln2218">      pi[0] = x;</a>
<a name="ln2219">      pi[1] = y;</a>
<a name="ln2220">      pi[2] = 1.0f;</a>
<a name="ln2221">      mat3mulv(po, (float *)homograph, pi);</a>
<a name="ln2222">      po[0] /= po[2];</a>
<a name="ln2223">      po[1] /= po[2];</a>
<a name="ln2224">      xm = fmin(xm, po[0]);</a>
<a name="ln2225">      ym = fmin(ym, po[1]);</a>
<a name="ln2226">      xM = fmax(xM, po[0]);</a>
<a name="ln2227">      yM = fmax(yM, po[1]);</a>
<a name="ln2228">    }</a>
<a name="ln2229"> </a>
<a name="ln2230">  if((xM - xm) * (yM - ym) &gt; 4.0f * fit.width * fit.height)</a>
<a name="ln2231">  {</a>
<a name="ln2232">#ifdef ASHIFT_DEBUG</a>
<a name="ln2233">    printf(&quot;optimization not successful: degenerate case with area growth factor (%f) exceeding limits\n&quot;,</a>
<a name="ln2234">           (xM - xm) * (yM - ym) / (fit.width * fit.height));</a>
<a name="ln2235">#endif</a>
<a name="ln2236">    return NMS_INSANE;</a>
<a name="ln2237">  }</a>
<a name="ln2238"> </a>
<a name="ln2239">  // now write the results into structure p</a>
<a name="ln2240">  p-&gt;rotation = fit.rotation;</a>
<a name="ln2241">  p-&gt;lensshift_v = fit.lensshift_v;</a>
<a name="ln2242">  p-&gt;lensshift_h = fit.lensshift_h;</a>
<a name="ln2243">  p-&gt;shear = fit.shear;</a>
<a name="ln2244">  return NMS_SUCCESS;</a>
<a name="ln2245">}</a>
<a name="ln2246"> </a>
<a name="ln2247">#ifdef ASHIFT_DEBUG</a>
<a name="ln2248">// only used in development phase. call model_fitness() with current parameters and</a>
<a name="ln2249">// print some useful information</a>
<a name="ln2250">static void model_probe(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2251">{</a>
<a name="ln2252">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2253"> </a>
<a name="ln2254">  if(!g-&gt;lines) return;</a>
<a name="ln2255">  if(dir == ASHIFT_FIT_NONE) return;</a>
<a name="ln2256"> </a>
<a name="ln2257">  double params[4];</a>
<a name="ln2258">  int enough_lines = TRUE;</a>
<a name="ln2259"> </a>
<a name="ln2260">  // initialize fit parameters</a>
<a name="ln2261">  dt_iop_ashift_fit_params_t fit;</a>
<a name="ln2262">  fit.lines = g-&gt;lines;</a>
<a name="ln2263">  fit.lines_count = g-&gt;lines_count;</a>
<a name="ln2264">  fit.width = g-&gt;lines_in_width;</a>
<a name="ln2265">  fit.height = g-&gt;lines_in_height;</a>
<a name="ln2266">  fit.f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2267">  fit.orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2268">  fit.aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2269">  fit.rotation = p-&gt;rotation;</a>
<a name="ln2270">  fit.lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2271">  fit.lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2272">  fit.shear = p-&gt;shear;</a>
<a name="ln2273">  fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2274">  fit.linemask = ASHIFT_LINE_MASK;</a>
<a name="ln2275">  fit.params_count = 0;</a>
<a name="ln2276">  fit.weight = 0.0f;</a>
<a name="ln2277"> </a>
<a name="ln2278">  // if the image is flipped and if we do not want to fit both lens shift</a>
<a name="ln2279">  // directions or none at all, then we need to change direction</a>
<a name="ln2280">  dt_iop_ashift_fitaxis_t mdir = dir;</a>
<a name="ln2281">  if((mdir &amp; ASHIFT_FIT_LENS_BOTH) != ASHIFT_FIT_LENS_BOTH &amp;&amp;</a>
<a name="ln2282">     (mdir &amp; ASHIFT_FIT_LENS_BOTH) != 0)</a>
<a name="ln2283">  {</a>
<a name="ln2284">    // flip all directions</a>
<a name="ln2285">    mdir ^= g-&gt;isflipped ? ASHIFT_FIT_FLIP : 0;</a>
<a name="ln2286">    // special case that needs to be corrected</a>
<a name="ln2287">    mdir |= (mdir &amp; ASHIFT_FIT_LINES_BOTH) == 0 ? ASHIFT_FIT_LINES_BOTH : 0;</a>
<a name="ln2288">  }</a>
<a name="ln2289"> </a>
<a name="ln2290">  if(mdir &amp; ASHIFT_FIT_LINES_VERT)</a>
<a name="ln2291">  {</a>
<a name="ln2292">    // we use vertical lines for fitting</a>
<a name="ln2293">    fit.linetype |= ASHIFT_LINE_DIRVERT;</a>
<a name="ln2294">    fit.weight += g-&gt;vertical_weight;</a>
<a name="ln2295">    enough_lines = enough_lines &amp;&amp; (g-&gt;vertical_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2296">  }</a>
<a name="ln2297"> </a>
<a name="ln2298">  if(mdir &amp; ASHIFT_FIT_LINES_HOR)</a>
<a name="ln2299">  {</a>
<a name="ln2300">    // we use horizontal lines for fitting</a>
<a name="ln2301">    fit.linetype |= 0;</a>
<a name="ln2302">    fit.weight += g-&gt;horizontal_weight;</a>
<a name="ln2303">    enough_lines = enough_lines &amp;&amp; (g-&gt;horizontal_count &gt;= MINIMUM_FITLINES);</a>
<a name="ln2304">  }</a>
<a name="ln2305"> </a>
<a name="ln2306">  // this needs to come after ASHIFT_FIT_LINES_VERT and ASHIFT_FIT_LINES_HOR</a>
<a name="ln2307">  if((mdir &amp; ASHIFT_FIT_LINES_BOTH) == ASHIFT_FIT_LINES_BOTH)</a>
<a name="ln2308">  {</a>
<a name="ln2309">    // if we use fitting in both directions we need to</a>
<a name="ln2310">    // adjust fit.linetype and fit.linemask to match all selected lines</a>
<a name="ln2311">    fit.linetype = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2312">    fit.linemask = ASHIFT_LINE_RELEVANT | ASHIFT_LINE_SELECTED;</a>
<a name="ln2313">  }</a>
<a name="ln2314"> </a>
<a name="ln2315">  double quality = model_fitness(params, (void *)&amp;fit);</a>
<a name="ln2316"> </a>
<a name="ln2317">  printf(&quot;model fitness: %.8f (rotation %f, lensshift_v %f, lensshift_h %f, shear %f)\n&quot;,</a>
<a name="ln2318">         quality, p-&gt;rotation, p-&gt;lensshift_v, p-&gt;lensshift_h, p-&gt;shear);</a>
<a name="ln2319">}</a>
<a name="ln2320">#endif</a>
<a name="ln2321"> </a>
<a name="ln2322">// function to keep crop fitting parameters within constraints</a>
<a name="ln2323">static void crop_constraint(double *params, int pcount)</a>
<a name="ln2324">{</a>
<a name="ln2325">  if(pcount &gt; 0) params[0] = fabs(params[0]);</a>
<a name="ln2326">  if(pcount &gt; 1) params[1] = fabs(params[1]);</a>
<a name="ln2327">  if(pcount &gt; 2) params[2] = fabs(params[2]);</a>
<a name="ln2328"> </a>
<a name="ln2329">  if(pcount &gt; 0 &amp;&amp; params[0] &gt; 1.0) params[0] = 1.0 - params[0];</a>
<a name="ln2330">  if(pcount &gt; 1 &amp;&amp; params[1] &gt; 1.0) params[1] = 1.0 - params[1];</a>
<a name="ln2331">  if(pcount &gt; 2 &amp;&amp; params[2] &gt; 0.5*M_PI) params[2] = 0.5*M_PI - params[2];</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334">// helper function for getting the best fitting crop area;</a>
<a name="ln2335">// returns the negative area of the largest rectangle that fits within the</a>
<a name="ln2336">// defined image with a given rectangle's center and its aspect angle;</a>
<a name="ln2337">// the trick: the rectangle center coordinates are given in the input</a>
<a name="ln2338">// image coordinates so we know for sure that it also lies within the image after</a>
<a name="ln2339">// conversion to the output coordinates</a>
<a name="ln2340">static double crop_fitness(double *params, void *data)</a>
<a name="ln2341">{</a>
<a name="ln2342">  dt_iop_ashift_cropfit_params_t *cropfit = (dt_iop_ashift_cropfit_params_t *)data;</a>
<a name="ln2343"> </a>
<a name="ln2344">  const float wd = cropfit-&gt;width;</a>
<a name="ln2345">  const float ht = cropfit-&gt;height;</a>
<a name="ln2346"> </a>
<a name="ln2347">  // get variable and constant parameters, respectively</a>
<a name="ln2348">  const float x = isnan(cropfit-&gt;x) ? params[0] : cropfit-&gt;x;</a>
<a name="ln2349">  const float y = isnan(cropfit-&gt;y) ? params[1] : cropfit-&gt;y;</a>
<a name="ln2350">  const float alpha = isnan(cropfit-&gt;alpha) ? params[2] : cropfit-&gt;alpha;</a>
<a name="ln2351"> </a>
<a name="ln2352">  // the center of the rectangle in input image coordinates</a>
<a name="ln2353">  const float Pc[3] = { x * wd, y * ht, 1.0f };</a>
<a name="ln2354"> </a>
<a name="ln2355">  // convert to the output image coordinates and normalize</a>
<a name="ln2356">  float P[3];</a>
<a name="ln2357">  mat3mulv(P, (float *)cropfit-&gt;homograph, Pc);</a>
<a name="ln2358">  P[0] /= P[2];</a>
<a name="ln2359">  P[1] /= P[2];</a>
<a name="ln2360">  P[2] = 1.0f;</a>
<a name="ln2361"> </a>
<a name="ln2362">  // two auxiliary points (some arbitrary distance away from P) to construct the diagonals</a>
<a name="ln2363">  const float Pa[2][3] = { { P[0] + 10.0f * cos(alpha), P[1] + 10.0f * sin(alpha), 1.0f },</a>
<a name="ln2364">                           { P[0] + 10.0f * cos(alpha), P[1] - 10.0f * sin(alpha), 1.0f } };</a>
<a name="ln2365"> </a>
<a name="ln2366">  // the two diagonals: D = P x Pa</a>
<a name="ln2367">  float D[2][3];</a>
<a name="ln2368">  vec3prodn(D[0], P, Pa[0]);</a>
<a name="ln2369">  vec3prodn(D[1], P, Pa[1]);</a>
<a name="ln2370"> </a>
<a name="ln2371">  // find all intersection points of all four edges with both diagonals (I = E x D);</a>
<a name="ln2372">  // the shortest distance d2min of the intersection point I to the crop area center P determines</a>
<a name="ln2373">  // the size of the crop area that still fits into the image (for the given center and aspect angle)</a>
<a name="ln2374">  float d2min = FLT_MAX;</a>
<a name="ln2375">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln2376">    for(int l = 0; l &lt; 2; l++)</a>
<a name="ln2377">    {</a>
<a name="ln2378">      // the intersection point</a>
<a name="ln2379">      float I[3];</a>
<a name="ln2380">      vec3prodn(I, cropfit-&gt;edges[k], D[l]);</a>
<a name="ln2381"> </a>
<a name="ln2382">      // special case: I is all null -&gt; E and D are identical -&gt; P lies on E -&gt; d2min = 0</a>
<a name="ln2383">      if(vec3isnull(I))</a>
<a name="ln2384">      {</a>
<a name="ln2385">        d2min = 0.0f;</a>
<a name="ln2386">        break;</a>
<a name="ln2387">      }</a>
<a name="ln2388"> </a>
<a name="ln2389">      // special case: I[2] is 0.0f -&gt; E and D are parallel and intersect at infinity -&gt; no relevant point</a>
<a name="ln2390">      if(I[2] == 0.0f)</a>
<a name="ln2391">        continue;</a>
<a name="ln2392"> </a>
<a name="ln2393">      // the default case -&gt; normalize I</a>
<a name="ln2394">      I[0] /= I[2];</a>
<a name="ln2395">      I[1] /= I[2];</a>
<a name="ln2396"> </a>
<a name="ln2397">      // calculate distance from I to P</a>
<a name="ln2398">      const float d2 = SQR(P[0] - I[0]) + SQR(P[1] - I[1]);</a>
<a name="ln2399"> </a>
<a name="ln2400">      // the minimum distance over all intersection points</a>
<a name="ln2401">      d2min = MIN(d2min, d2);</a>
<a name="ln2402">    }</a>
<a name="ln2403"> </a>
<a name="ln2404">  // calculate the area of the rectangle</a>
<a name="ln2405">  const float A = 2.0f * d2min * sin(2.0f * alpha);</a>
<a name="ln2406"> </a>
<a name="ln2407">#ifdef ASHIFT_DEBUG</a>
<a name="ln2408">  printf(&quot;crop fitness with x %f, y %f, angle %f -&gt; distance %f, area %f\n&quot;,</a>
<a name="ln2409">         x, y, alpha, d2min, A);</a>
<a name="ln2410">#endif</a>
<a name="ln2411">  // and return -A to allow Nelder-Mead simplex to search for the minimum</a>
<a name="ln2412">  return -A;</a>
<a name="ln2413">}</a>
<a name="ln2414"> </a>
<a name="ln2415">// strategy: for a given center of the crop area and a specific aspect angle</a>
<a name="ln2416">// we calculate the largest crop area that still lies within the output image;</a>
<a name="ln2417">// now we allow a Nelder-Mead simplex to search for the center coordinates</a>
<a name="ln2418">// (and optionally the aspect angle) that delivers the largest overall crop area.</a>
<a name="ln2419">static void do_crop(dt_iop_module_t *module, dt_iop_ashift_params_t *p)</a>
<a name="ln2420">{</a>
<a name="ln2421">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2422"> </a>
<a name="ln2423">  // skip if fitting is still running</a>
<a name="ln2424">  if(g-&gt;fitting) return;</a>
<a name="ln2425"> </a>
<a name="ln2426">  // reset fit margins if auto-cropping is off</a>
<a name="ln2427">  if(p-&gt;cropmode == ASHIFT_CROP_OFF)</a>
<a name="ln2428">  {</a>
<a name="ln2429">    p-&gt;cl = 0.0f;</a>
<a name="ln2430">    p-&gt;cr = 1.0f;</a>
<a name="ln2431">    p-&gt;ct = 0.0f;</a>
<a name="ln2432">    p-&gt;cb = 1.0f;</a>
<a name="ln2433">    return;</a>
<a name="ln2434">  }</a>
<a name="ln2435"> </a>
<a name="ln2436">  g-&gt;fitting = 1;</a>
<a name="ln2437"> </a>
<a name="ln2438">  double params[3];</a>
<a name="ln2439">  int pcount;</a>
<a name="ln2440"> </a>
<a name="ln2441">  // get parameters for the homograph</a>
<a name="ln2442">  const float f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2443">  const float orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2444">  const float aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2445">  const float rotation = p-&gt;rotation;</a>
<a name="ln2446">  const float lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2447">  const float lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2448">  const float shear = p-&gt;shear;</a>
<a name="ln2449"> </a>
<a name="ln2450">  // prepare structure of constant parameters</a>
<a name="ln2451">  dt_iop_ashift_cropfit_params_t cropfit;</a>
<a name="ln2452">  cropfit.width = g-&gt;buf_width;</a>
<a name="ln2453">  cropfit.height = g-&gt;buf_height;</a>
<a name="ln2454">  homography((float *)cropfit.homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2455">             orthocorr, aspect, cropfit.width, cropfit.height, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2456"> </a>
<a name="ln2457">  const float wd = cropfit.width;</a>
<a name="ln2458">  const float ht = cropfit.height;</a>
<a name="ln2459"> </a>
<a name="ln2460">  // the four vertices of the image in input image coordinates</a>
<a name="ln2461">  const float Vc[4][3] = { { 0.0f, 0.0f, 1.0f },</a>
<a name="ln2462">                           { 0.0f,   ht, 1.0f },</a>
<a name="ln2463">                           {   wd,   ht, 1.0f },</a>
<a name="ln2464">                           {   wd, 0.0f, 1.0f } };</a>
<a name="ln2465"> </a>
<a name="ln2466">  // convert the vertices to output image coordinates</a>
<a name="ln2467">  float V[4][3];</a>
<a name="ln2468">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2469">    mat3mulv(V[n], (float *)cropfit.homograph, Vc[n]);</a>
<a name="ln2470"> </a>
<a name="ln2471">  // get width and height of output image for later use</a>
<a name="ln2472">  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln2473">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2474">  {</a>
<a name="ln2475">    // normalize V</a>
<a name="ln2476">    V[n][0] /= V[n][2];</a>
<a name="ln2477">    V[n][1] /= V[n][2];</a>
<a name="ln2478">    V[n][2] = 1.0f;</a>
<a name="ln2479">    xmin = MIN(xmin, V[n][0]);</a>
<a name="ln2480">    xmax = MAX(xmax, V[n][0]);</a>
<a name="ln2481">    ymin = MIN(ymin, V[n][1]);</a>
<a name="ln2482">    ymax = MAX(ymax, V[n][1]);</a>
<a name="ln2483">  }</a>
<a name="ln2484">  const float owd = xmax - xmin;</a>
<a name="ln2485">  const float oht = ymax - ymin;</a>
<a name="ln2486"> </a>
<a name="ln2487">  // calculate the lines defining the four edges of the image area: E = V[n] x V[n+1]</a>
<a name="ln2488">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2489">    vec3prodn(cropfit.edges[n], V[n], V[(n + 1) % 4]);</a>
<a name="ln2490"> </a>
<a name="ln2491">  // initial fit parameters: crop area is centered and aspect angle is that of the original image</a>
<a name="ln2492">  // number of parameters: fit only crop center coordinates with a fixed aspect ratio, or fit all three variables</a>
<a name="ln2493">  if(p-&gt;cropmode == ASHIFT_CROP_LARGEST)</a>
<a name="ln2494">  {</a>
<a name="ln2495">    params[0] = 0.5;</a>
<a name="ln2496">    params[1] = 0.5;</a>
<a name="ln2497">    params[2] = atan2((float)cropfit.height, (float)cropfit.width);</a>
<a name="ln2498">    cropfit.x = NAN;</a>
<a name="ln2499">    cropfit.y = NAN;</a>
<a name="ln2500">    cropfit.alpha = NAN;</a>
<a name="ln2501">    pcount = 3;</a>
<a name="ln2502">  }</a>
<a name="ln2503">  else //(p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln2504">  {</a>
<a name="ln2505">    params[0] = 0.5;</a>
<a name="ln2506">    params[1] = 0.5;</a>
<a name="ln2507">    cropfit.x = NAN;</a>
<a name="ln2508">    cropfit.y = NAN;</a>
<a name="ln2509">    cropfit.alpha = atan2((float)cropfit.height, (float)cropfit.width);</a>
<a name="ln2510">    pcount = 2;</a>
<a name="ln2511">  }</a>
<a name="ln2512"> </a>
<a name="ln2513">  // start the simplex fit</a>
<a name="ln2514">  const int iter = simplex(crop_fitness, params, pcount, NMS_CROP_EPSILON, NMS_CROP_SCALE, NMS_CROP_ITERATIONS,</a>
<a name="ln2515">                           crop_constraint, (void*)&amp;cropfit);</a>
<a name="ln2516"> </a>
<a name="ln2517">  // in case the fit did not converge -&gt; failed</a>
<a name="ln2518">  if(iter &gt;= NMS_CROP_ITERATIONS) goto failed;</a>
<a name="ln2519"> </a>
<a name="ln2520">  // the fit did converge -&gt; get clipping margins out of params:</a>
<a name="ln2521">  cropfit.x = isnan(cropfit.x) ? params[0] : cropfit.x;</a>
<a name="ln2522">  cropfit.y = isnan(cropfit.y) ? params[1] : cropfit.y;</a>
<a name="ln2523">  cropfit.alpha = isnan(cropfit.alpha) ? params[2] : cropfit.alpha;</a>
<a name="ln2524"> </a>
<a name="ln2525">  // the area of the best fitting rectangle</a>
<a name="ln2526">  const float A = fabs(crop_fitness(params, (void*)&amp;cropfit));</a>
<a name="ln2527"> </a>
<a name="ln2528">  // unlikely to happen but we need to catch this case</a>
<a name="ln2529">  if(A == 0.0f) goto failed;</a>
<a name="ln2530"> </a>
<a name="ln2531">  // we need the half diagonal of that rectangle (this is in output image dimensions);</a>
<a name="ln2532">  // no need to check for division by zero here as this case implies A == 0.0f, caught above</a>
<a name="ln2533">  const float d = sqrt(A / (2.0f * sin(2.0f * cropfit.alpha)));</a>
<a name="ln2534"> </a>
<a name="ln2535">  // the rectangle's center in input image (homogeneous) coordinates</a>
<a name="ln2536">  const float Pc[3] = { cropfit.x * wd, cropfit.y * ht, 1.0f };</a>
<a name="ln2537"> </a>
<a name="ln2538">  // convert rectangle center to output image coordinates and normalize</a>
<a name="ln2539">  float P[3];</a>
<a name="ln2540">  mat3mulv(P, (float *)cropfit.homograph, Pc);</a>
<a name="ln2541">  P[0] /= P[2];</a>
<a name="ln2542">  P[1] /= P[2];</a>
<a name="ln2543"> </a>
<a name="ln2544">  // calculate clipping margins relative to output image dimensions</a>
<a name="ln2545">  p-&gt;cl = CLAMP((P[0] - d * cos(cropfit.alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2546">  p-&gt;cr = CLAMP((P[0] + d * cos(cropfit.alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2547">  p-&gt;ct = CLAMP((P[1] - d * sin(cropfit.alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2548">  p-&gt;cb = CLAMP((P[1] + d * sin(cropfit.alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2549"> </a>
<a name="ln2550">  // final sanity check</a>
<a name="ln2551">  if(p-&gt;cr - p-&gt;cl &lt;= 0.0f || p-&gt;cb - p-&gt;ct &lt;= 0.0f) goto failed;</a>
<a name="ln2552"> </a>
<a name="ln2553">  g-&gt;fitting = 0;</a>
<a name="ln2554"> </a>
<a name="ln2555">#ifdef ASHIFT_DEBUG</a>
<a name="ln2556">  printf(&quot;margins after crop fitting: iter %d, x %f, y %f, angle %f, crop area (%f %f %f %f), width %f, height %f\n&quot;,</a>
<a name="ln2557">         iter, cropfit.x, cropfit.y, cropfit.alpha, p-&gt;cl, p-&gt;cr, p-&gt;ct, p-&gt;cb, wd, ht);</a>
<a name="ln2558">#endif</a>
<a name="ln2559">  dt_control_queue_redraw_center();</a>
<a name="ln2560">  return;</a>
<a name="ln2561"> </a>
<a name="ln2562">failed:</a>
<a name="ln2563">  // in case of failure: reset clipping margins, set &quot;automatic cropping&quot; parameter</a>
<a name="ln2564">  // to &quot;off&quot; state, and display warning message</a>
<a name="ln2565">  p-&gt;cl = 0.0f;</a>
<a name="ln2566">  p-&gt;cr = 1.0f;</a>
<a name="ln2567">  p-&gt;ct = 0.0f;</a>
<a name="ln2568">  p-&gt;cb = 1.0f;</a>
<a name="ln2569">  p-&gt;cropmode = ASHIFT_CROP_OFF;</a>
<a name="ln2570">  dt_bauhaus_combobox_set(g-&gt;cropmode, p-&gt;cropmode);</a>
<a name="ln2571">  g-&gt;fitting = 0;</a>
<a name="ln2572">  dt_control_log(_(&quot;automatic cropping failed&quot;));</a>
<a name="ln2573">  return;</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">// manually adjust crop area by shifting its center</a>
<a name="ln2577">static void crop_adjust(dt_iop_module_t *module, dt_iop_ashift_params_t *p, const float newx, const float newy)</a>
<a name="ln2578">{</a>
<a name="ln2579">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2580"> </a>
<a name="ln2581">  // skip if fitting is still running</a>
<a name="ln2582">  if(g-&gt;fitting) return;</a>
<a name="ln2583"> </a>
<a name="ln2584">  // get parameters for the homograph</a>
<a name="ln2585">  const float f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln2586">  const float orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln2587">  const float aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln2588">  const float rotation = p-&gt;rotation;</a>
<a name="ln2589">  const float lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln2590">  const float lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln2591">  const float shear = p-&gt;shear;</a>
<a name="ln2592"> </a>
<a name="ln2593">  const float wd = g-&gt;buf_width;</a>
<a name="ln2594">  const float ht = g-&gt;buf_height;</a>
<a name="ln2595"> </a>
<a name="ln2596">  const float alpha = atan2(ht, wd);</a>
<a name="ln2597"> </a>
<a name="ln2598">  float homograph[3][3];</a>
<a name="ln2599">  homography((float *)homograph, rotation, lensshift_v, lensshift_h, shear, f_length_kb,</a>
<a name="ln2600">             orthocorr, aspect, wd, ht, ASHIFT_HOMOGRAPH_FORWARD);</a>
<a name="ln2601"> </a>
<a name="ln2602">  // the four vertices of the image in input image coordinates</a>
<a name="ln2603">  const float Vc[4][3] = { { 0.0f, 0.0f, 1.0f },</a>
<a name="ln2604">                           { 0.0f,   ht, 1.0f },</a>
<a name="ln2605">                           {   wd,   ht, 1.0f },</a>
<a name="ln2606">                           {   wd, 0.0f, 1.0f } };</a>
<a name="ln2607"> </a>
<a name="ln2608">  // convert the vertices to output image coordinates</a>
<a name="ln2609">  float V[4][3];</a>
<a name="ln2610">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2611">    mat3mulv(V[n], (float *)homograph, Vc[n]);</a>
<a name="ln2612"> </a>
<a name="ln2613">  // get width and height of output image</a>
<a name="ln2614">  float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln2615">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2616">  {</a>
<a name="ln2617">    // normalize V</a>
<a name="ln2618">    V[n][0] /= V[n][2];</a>
<a name="ln2619">    V[n][1] /= V[n][2];</a>
<a name="ln2620">    V[n][2] = 1.0f;</a>
<a name="ln2621">    xmin = MIN(xmin, V[n][0]);</a>
<a name="ln2622">    xmax = MAX(xmax, V[n][0]);</a>
<a name="ln2623">    ymin = MIN(ymin, V[n][1]);</a>
<a name="ln2624">    ymax = MAX(ymax, V[n][1]);</a>
<a name="ln2625">  }</a>
<a name="ln2626">  const float owd = xmax - xmin;</a>
<a name="ln2627">  const float oht = ymax - ymin;</a>
<a name="ln2628"> </a>
<a name="ln2629">  // calculate the lines defining the four edges of the image area: E = V[n] x V[n+1]</a>
<a name="ln2630">  float E[4][3];</a>
<a name="ln2631">  for(int n = 0; n &lt; 4; n++)</a>
<a name="ln2632">    vec3prodn(E[n], V[n], V[(n + 1) % 4]);</a>
<a name="ln2633"> </a>
<a name="ln2634">  // the center of the rectangle in output image coordinates</a>
<a name="ln2635">  const float P[3] = { newx * owd, newy * oht, 1.0f };</a>
<a name="ln2636"> </a>
<a name="ln2637">  // two auxiliary points (some arbitrary distance away from P) to construct the diagonals</a>
<a name="ln2638">  const float Pa[2][3] = { { P[0] + 10.0f * cos(alpha), P[1] + 10.0f * sin(alpha), 1.0f },</a>
<a name="ln2639">                           { P[0] + 10.0f * cos(alpha), P[1] - 10.0f * sin(alpha), 1.0f } };</a>
<a name="ln2640"> </a>
<a name="ln2641">  // the two diagonals: D = P x Pa</a>
<a name="ln2642">  float D[2][3];</a>
<a name="ln2643">  vec3prodn(D[0], P, Pa[0]);</a>
<a name="ln2644">  vec3prodn(D[1], P, Pa[1]);</a>
<a name="ln2645"> </a>
<a name="ln2646">  // find all intersection points of all four edges with both diagonals (I = E x D);</a>
<a name="ln2647">  // the shortest distance d2min of the intersection point I to the crop area center P determines</a>
<a name="ln2648">  // the size of the crop area that still fits into the image (for the given center and aspect angle)</a>
<a name="ln2649">  float d2min = FLT_MAX;</a>
<a name="ln2650">  for(int k = 0; k &lt; 4; k++)</a>
<a name="ln2651">    for(int l = 0; l &lt; 2; l++)</a>
<a name="ln2652">    {</a>
<a name="ln2653">      // the intersection point</a>
<a name="ln2654">      float I[3];</a>
<a name="ln2655">      vec3prodn(I, E[k], D[l]);</a>
<a name="ln2656"> </a>
<a name="ln2657">      // special case: I is all null -&gt; E and D are identical -&gt; P lies on E -&gt; d2min = 0</a>
<a name="ln2658">      if(vec3isnull(I))</a>
<a name="ln2659">      {</a>
<a name="ln2660">        d2min = 0.0f;</a>
<a name="ln2661">        break;</a>
<a name="ln2662">      }</a>
<a name="ln2663"> </a>
<a name="ln2664">      // special case: I[2] is 0.0f -&gt; E and D are parallel and intersect at infinity -&gt; no relevant point</a>
<a name="ln2665">      if(I[2] == 0.0f)</a>
<a name="ln2666">        continue;</a>
<a name="ln2667"> </a>
<a name="ln2668">      // the default case -&gt; normalize I</a>
<a name="ln2669">      I[0] /= I[2];</a>
<a name="ln2670">      I[1] /= I[2];</a>
<a name="ln2671"> </a>
<a name="ln2672">      // calculate distance from I to P</a>
<a name="ln2673">      const float d2 = SQR(P[0] - I[0]) + SQR(P[1] - I[1]);</a>
<a name="ln2674"> </a>
<a name="ln2675">      // the minimum distance over all intersection points</a>
<a name="ln2676">      d2min = MIN(d2min, d2);</a>
<a name="ln2677">    }</a>
<a name="ln2678"> </a>
<a name="ln2679">  const float d = sqrt(d2min);</a>
<a name="ln2680"> </a>
<a name="ln2681">  // do not allow crop area to drop below 1% of input image area</a>
<a name="ln2682">  const float A = 2.0f * d * d * sin(2.0f * alpha);</a>
<a name="ln2683">  if(A &lt; 0.01f * wd * ht) return;</a>
<a name="ln2684"> </a>
<a name="ln2685">  // calculate clipping margins relative to output image dimensions</a>
<a name="ln2686">  p-&gt;cl = CLAMP((P[0] - d * cos(alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2687">  p-&gt;cr = CLAMP((P[0] + d * cos(alpha)) / owd, 0.0f, 1.0f);</a>
<a name="ln2688">  p-&gt;ct = CLAMP((P[1] - d * sin(alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2689">  p-&gt;cb = CLAMP((P[1] + d * sin(alpha)) / oht, 0.0f, 1.0f);</a>
<a name="ln2690"> </a>
<a name="ln2691">#ifdef ASHIFT_DEBUG</a>
<a name="ln2692">  printf(&quot;margins after crop adjustment: x %f, y %f, angle %f, crop area (%f %f %f %f), width %f, height %f\n&quot;,</a>
<a name="ln2693">         0.5f * (p-&gt;cl + p-&gt;cr), 0.5f * (p-&gt;ct + p-&gt;cb), alpha, p-&gt;cl, p-&gt;cr, p-&gt;ct, p-&gt;cb, wd, ht);</a>
<a name="ln2694">#endif</a>
<a name="ln2695">  dt_control_queue_redraw_center();</a>
<a name="ln2696">  return;</a>
<a name="ln2697">}</a>
<a name="ln2698"> </a>
<a name="ln2699"> </a>
<a name="ln2700">// helper function to start analysis for structural data and report about errors</a>
<a name="ln2701">static int do_get_structure(dt_iop_module_t *module, dt_iop_ashift_params_t *p,</a>
<a name="ln2702">                            dt_iop_ashift_enhance_t enhance)</a>
<a name="ln2703">{</a>
<a name="ln2704">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2705"> </a>
<a name="ln2706">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2707"> </a>
<a name="ln2708">  g-&gt;fitting = 1;</a>
<a name="ln2709"> </a>
<a name="ln2710">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2711">  float *b = g-&gt;buf;</a>
<a name="ln2712">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2713"> </a>
<a name="ln2714">  if(b == NULL)</a>
<a name="ln2715">  {</a>
<a name="ln2716">    dt_control_log(_(&quot;data pending - please repeat&quot;));</a>
<a name="ln2717">    goto error;</a>
<a name="ln2718">  }</a>
<a name="ln2719"> </a>
<a name="ln2720">  if(!get_structure(module, enhance))</a>
<a name="ln2721">  {</a>
<a name="ln2722">    dt_control_log(_(&quot;could not detect structural data in image&quot;));</a>
<a name="ln2723">#ifdef ASHIFT_DEBUG</a>
<a name="ln2724">    // find out more</a>
<a name="ln2725">    printf(&quot;do_get_structure: buf %p, buf_hash %lu, buf_width %d, buf_height %d, lines %p, lines_count %d\n&quot;,</a>
<a name="ln2726">           g-&gt;buf, g-&gt;buf_hash, g-&gt;buf_width, g-&gt;buf_height, g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln2727">#endif</a>
<a name="ln2728">    goto error;</a>
<a name="ln2729">  }</a>
<a name="ln2730"> </a>
<a name="ln2731">  if(!remove_outliers(module))</a>
<a name="ln2732">  {</a>
<a name="ln2733">    dt_control_log(_(&quot;could not run outlier removal&quot;));</a>
<a name="ln2734">#ifdef ASHIFT_DEBUG</a>
<a name="ln2735">    // find out more</a>
<a name="ln2736">    printf(&quot;remove_outliers: buf %p, buf_hash %lu, buf_width %d, buf_height %d, lines %p, lines_count %d\n&quot;,</a>
<a name="ln2737">           g-&gt;buf, g-&gt;buf_hash, g-&gt;buf_width, g-&gt;buf_height, g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln2738">#endif</a>
<a name="ln2739">    goto error;</a>
<a name="ln2740">  }</a>
<a name="ln2741"> </a>
<a name="ln2742">  g-&gt;fitting = 0;</a>
<a name="ln2743">  return TRUE;</a>
<a name="ln2744"> </a>
<a name="ln2745">error:</a>
<a name="ln2746">  g-&gt;fitting = 0;</a>
<a name="ln2747">  return FALSE;</a>
<a name="ln2748">}</a>
<a name="ln2749"> </a>
<a name="ln2750">// helper function to clean structural data</a>
<a name="ln2751">static int do_clean_structure(dt_iop_module_t *module, dt_iop_ashift_params_t *p)</a>
<a name="ln2752">{</a>
<a name="ln2753">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2754"> </a>
<a name="ln2755">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2756"> </a>
<a name="ln2757">  g-&gt;fitting = 1;</a>
<a name="ln2758">  g-&gt;lines_count = 0;</a>
<a name="ln2759">  g-&gt;vertical_count = 0;</a>
<a name="ln2760">  g-&gt;horizontal_count = 0;</a>
<a name="ln2761">  free(g-&gt;lines);</a>
<a name="ln2762">  g-&gt;lines = NULL;</a>
<a name="ln2763">  g-&gt;lines_version++;</a>
<a name="ln2764">  g-&gt;lines_suppressed = 0;</a>
<a name="ln2765">  g-&gt;fitting = 0;</a>
<a name="ln2766">  return TRUE;</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">// helper function to start parameter fit and report about errors</a>
<a name="ln2770">static int do_fit(dt_iop_module_t *module, dt_iop_ashift_params_t *p, dt_iop_ashift_fitaxis_t dir)</a>
<a name="ln2771">{</a>
<a name="ln2772">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln2773"> </a>
<a name="ln2774">  if(g-&gt;fitting) return FALSE;</a>
<a name="ln2775"> </a>
<a name="ln2776">  // if no structure available get it</a>
<a name="ln2777">  if(g-&gt;lines == NULL)</a>
<a name="ln2778">    if(!do_get_structure(module, p, ASHIFT_ENHANCE_NONE)) goto error;</a>
<a name="ln2779"> </a>
<a name="ln2780">  g-&gt;fitting = 1;</a>
<a name="ln2781"> </a>
<a name="ln2782">  dt_iop_ashift_nmsresult_t res = nmsfit(module, p, dir);</a>
<a name="ln2783"> </a>
<a name="ln2784">  switch(res)</a>
<a name="ln2785">  {</a>
<a name="ln2786">    case NMS_NOT_ENOUGH_LINES:</a>
<a name="ln2787">      dt_control_log(_(&quot;not enough structure for automatic correction&quot;));</a>
<a name="ln2788">      goto error;</a>
<a name="ln2789">      break;</a>
<a name="ln2790">    case NMS_DID_NOT_CONVERGE:</a>
<a name="ln2791">    case NMS_INSANE:</a>
<a name="ln2792">      dt_control_log(_(&quot;automatic correction failed, please correct manually&quot;));</a>
<a name="ln2793">      goto error;</a>
<a name="ln2794">      break;</a>
<a name="ln2795">    case NMS_SUCCESS:</a>
<a name="ln2796">    default:</a>
<a name="ln2797">      break;</a>
<a name="ln2798">  }</a>
<a name="ln2799"> </a>
<a name="ln2800">  g-&gt;fitting = 0;</a>
<a name="ln2801"> </a>
<a name="ln2802">  // finally apply cropping</a>
<a name="ln2803">  do_crop(module, p);</a>
<a name="ln2804"> </a>
<a name="ln2805">  return TRUE;</a>
<a name="ln2806"> </a>
<a name="ln2807">error:</a>
<a name="ln2808">  g-&gt;fitting = 0;</a>
<a name="ln2809">  return FALSE;</a>
<a name="ln2810">}</a>
<a name="ln2811"> </a>
<a name="ln2812"> </a>
<a name="ln2813">void process(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, const void *const ivoid,</a>
<a name="ln2814">             void *const ovoid, const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2815">{</a>
<a name="ln2816">  dt_iop_ashift_data_t *data = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln2817">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2818"> </a>
<a name="ln2819">  const int ch = piece-&gt;colors;</a>
<a name="ln2820">  const int ch_width = ch * roi_in-&gt;width;</a>
<a name="ln2821"> </a>
<a name="ln2822">  // only for preview pipe: collect input buffer data and do some other evaluations</a>
<a name="ln2823">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2824">  {</a>
<a name="ln2825">    // we want to find out if the final output image is flipped in relation to this iop</a>
<a name="ln2826">    // so we can adjust the gui labels accordingly</a>
<a name="ln2827"> </a>
<a name="ln2828">    const int width = roi_in-&gt;width;</a>
<a name="ln2829">    const int height = roi_in-&gt;height;</a>
<a name="ln2830">    const int x_off = roi_in-&gt;x;</a>
<a name="ln2831">    const int y_off = roi_in-&gt;y;</a>
<a name="ln2832">    const float scale = roi_in-&gt;scale;</a>
<a name="ln2833"> </a>
<a name="ln2834">    // origin of image and opposite corner as reference points</a>
<a name="ln2835">    float points[4] = { 0.0f, 0.0f, (float)piece-&gt;buf_in.width, (float)piece-&gt;buf_in.height };</a>
<a name="ln2836">    float ivec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2837">    float ivecl = sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1]);</a>
<a name="ln2838"> </a>
<a name="ln2839">    // where do they go?</a>
<a name="ln2840">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points,</a>
<a name="ln2841">                                      2);</a>
<a name="ln2842"> </a>
<a name="ln2843">    float ovec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2844">    float ovecl = sqrt(ovec[0] * ovec[0] + ovec[1] * ovec[1]);</a>
<a name="ln2845"> </a>
<a name="ln2846">    // angle between input vector and output vector</a>
<a name="ln2847">    float alpha = acos(CLAMP((ivec[0] * ovec[0] + ivec[1] * ovec[1]) / (ivecl * ovecl), -1.0f, 1.0f));</a>
<a name="ln2848"> </a>
<a name="ln2849">    // we are interested if |alpha| is in the range of 90 +/- 45 -&gt; we assume the image is flipped</a>
<a name="ln2850">    int isflipped = fabs(fmod(alpha + M_PI, M_PI) - M_PI / 2.0f) &lt; M_PI / 4.0f ? 1 : 0;</a>
<a name="ln2851"> </a>
<a name="ln2852">    // did modules prior to this one in pixelpipe have changed? -&gt; check via hash value</a>
<a name="ln2853">    uint64_t hash = dt_dev_hash_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_EXCL);</a>
<a name="ln2854"> </a>
<a name="ln2855">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2856">    g-&gt;isflipped = isflipped;</a>
<a name="ln2857"> </a>
<a name="ln2858">    // save a copy of preview input buffer for parameter fitting</a>
<a name="ln2859">    if(g-&gt;buf == NULL || (size_t)g-&gt;buf_width * g-&gt;buf_height &lt; (size_t)width * height)</a>
<a name="ln2860">    {</a>
<a name="ln2861">      // if needed allocate buffer</a>
<a name="ln2862">      free(g-&gt;buf); // a no-op if g-&gt;buf is NULL</a>
<a name="ln2863">      // only get new buffer if no old buffer available or old buffer does not fit in terms of size</a>
<a name="ln2864">      g-&gt;buf = malloc((size_t)width * height * 4 * sizeof(float));</a>
<a name="ln2865">    }</a>
<a name="ln2866"> </a>
<a name="ln2867">    if(g-&gt;buf /* &amp;&amp; hash != g-&gt;buf_hash */)</a>
<a name="ln2868">    {</a>
<a name="ln2869">      // copy data</a>
<a name="ln2870">      memcpy(g-&gt;buf, ivoid, (size_t)width * height * ch * sizeof(float));</a>
<a name="ln2871"> </a>
<a name="ln2872">      g-&gt;buf_width = width;</a>
<a name="ln2873">      g-&gt;buf_height = height;</a>
<a name="ln2874">      g-&gt;buf_x_off = x_off;</a>
<a name="ln2875">      g-&gt;buf_y_off = y_off;</a>
<a name="ln2876">      g-&gt;buf_scale = scale;</a>
<a name="ln2877">      g-&gt;buf_hash = hash;</a>
<a name="ln2878">    }</a>
<a name="ln2879"> </a>
<a name="ln2880">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln2881">  }</a>
<a name="ln2882"> </a>
<a name="ln2883">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln2884">  if(isneutral(data))</a>
<a name="ln2885">  {</a>
<a name="ln2886">    memcpy(ovoid, ivoid, (size_t)roi_out-&gt;width * roi_out-&gt;height * ch * sizeof(float));</a>
<a name="ln2887">    return;</a>
<a name="ln2888">  }</a>
<a name="ln2889"> </a>
<a name="ln2890">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln2891"> </a>
<a name="ln2892">  float ihomograph[3][3];</a>
<a name="ln2893">  homography((float *)ihomograph, data-&gt;rotation, data-&gt;lensshift_v, data-&gt;lensshift_h, data-&gt;shear, data-&gt;f_length_kb,</a>
<a name="ln2894">             data-&gt;orthocorr, data-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln2895"> </a>
<a name="ln2896">  // clipping offset</a>
<a name="ln2897">  const float fullwidth = (float)piece-&gt;buf_out.width / (data-&gt;cr - data-&gt;cl);</a>
<a name="ln2898">  const float fullheight = (float)piece-&gt;buf_out.height / (data-&gt;cb - data-&gt;ct);</a>
<a name="ln2899">  const float cx = roi_out-&gt;scale * fullwidth * data-&gt;cl;</a>
<a name="ln2900">  const float cy = roi_out-&gt;scale * fullheight * data-&gt;ct;</a>
<a name="ln2901"> </a>
<a name="ln2902"> </a>
<a name="ln2903">#ifdef _OPENMP</a>
<a name="ln2904">#pragma omp parallel for schedule(static) default(none) shared(ihomograph, interpolation)</a>
<a name="ln2905">#endif</a>
<a name="ln2906">  // go over all pixels of output image</a>
<a name="ln2907">  for(int j = 0; j &lt; roi_out-&gt;height; j++)</a>
<a name="ln2908">  {</a>
<a name="ln2909">    float *out = ((float *)ovoid) + (size_t)ch * j * roi_out-&gt;width;</a>
<a name="ln2910">    for(int i = 0; i &lt; roi_out-&gt;width; i++, out += ch)</a>
<a name="ln2911">    {</a>
<a name="ln2912">      float pin[3], pout[3];</a>
<a name="ln2913"> </a>
<a name="ln2914">      // convert output pixel coordinates to original image coordinates</a>
<a name="ln2915">      pout[0] = roi_out-&gt;x + i + cx;</a>
<a name="ln2916">      pout[1] = roi_out-&gt;y + j + cy;</a>
<a name="ln2917">      pout[0] /= roi_out-&gt;scale;</a>
<a name="ln2918">      pout[1] /= roi_out-&gt;scale;</a>
<a name="ln2919">      pout[2] = 1.0f;</a>
<a name="ln2920"> </a>
<a name="ln2921">      // apply homograph</a>
<a name="ln2922">      mat3mulv(pin, (float *)ihomograph, pout);</a>
<a name="ln2923"> </a>
<a name="ln2924">      // convert to input pixel coordinates</a>
<a name="ln2925">      pin[0] /= pin[2];</a>
<a name="ln2926">      pin[1] /= pin[2];</a>
<a name="ln2927">      pin[0] *= roi_in-&gt;scale;</a>
<a name="ln2928">      pin[1] *= roi_in-&gt;scale;</a>
<a name="ln2929">      pin[0] -= roi_in-&gt;x;</a>
<a name="ln2930">      pin[1] -= roi_in-&gt;y;</a>
<a name="ln2931"> </a>
<a name="ln2932">      // get output values by interpolation from input image</a>
<a name="ln2933">      dt_interpolation_compute_pixel4c(interpolation, (float *)ivoid, out, pin[0], pin[1], roi_in-&gt;width,</a>
<a name="ln2934">                                       roi_in-&gt;height, ch_width);</a>
<a name="ln2935">    }</a>
<a name="ln2936">  }</a>
<a name="ln2937">}</a>
<a name="ln2938"> </a>
<a name="ln2939">#ifdef HAVE_OPENCL</a>
<a name="ln2940">int process_cl(struct dt_iop_module_t *self, dt_dev_pixelpipe_iop_t *piece, cl_mem dev_in, cl_mem dev_out,</a>
<a name="ln2941">               const dt_iop_roi_t *const roi_in, const dt_iop_roi_t *const roi_out)</a>
<a name="ln2942">{</a>
<a name="ln2943">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln2944">  dt_iop_ashift_global_data_t *gd = (dt_iop_ashift_global_data_t *)self-&gt;data;</a>
<a name="ln2945">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln2946"> </a>
<a name="ln2947">  const int devid = piece-&gt;pipe-&gt;devid;</a>
<a name="ln2948">  const int iwidth = roi_in-&gt;width;</a>
<a name="ln2949">  const int iheight = roi_in-&gt;height;</a>
<a name="ln2950">  const int width = roi_out-&gt;width;</a>
<a name="ln2951">  const int height = roi_out-&gt;height;</a>
<a name="ln2952"> </a>
<a name="ln2953">  cl_int err = -999;</a>
<a name="ln2954">  cl_mem dev_homo = NULL;</a>
<a name="ln2955"> </a>
<a name="ln2956">  // only for preview pipe: collect input buffer data and do some other evaluations</a>
<a name="ln2957">  if(self-&gt;dev-&gt;gui_attached &amp;&amp; g &amp;&amp; piece-&gt;pipe-&gt;type == DT_DEV_PIXELPIPE_PREVIEW)</a>
<a name="ln2958">  {</a>
<a name="ln2959">    // we want to find out if the final output image is flipped in relation to this iop</a>
<a name="ln2960">    // so we can adjust the gui labels accordingly</a>
<a name="ln2961"> </a>
<a name="ln2962">    const int x_off = roi_in-&gt;x;</a>
<a name="ln2963">    const int y_off = roi_in-&gt;y;</a>
<a name="ln2964">    const float scale = roi_in-&gt;scale;</a>
<a name="ln2965"> </a>
<a name="ln2966">    // origin of image and opposite corner as reference points</a>
<a name="ln2967">    float points[4] = { 0.0f, 0.0f, (float)piece-&gt;buf_in.width, (float)piece-&gt;buf_in.height };</a>
<a name="ln2968">    float ivec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2969">    float ivecl = sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1]);</a>
<a name="ln2970"> </a>
<a name="ln2971">    // where do they go?</a>
<a name="ln2972">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL, points,</a>
<a name="ln2973">                                      2);</a>
<a name="ln2974"> </a>
<a name="ln2975">    float ovec[2] = { points[2] - points[0], points[3] - points[1] };</a>
<a name="ln2976">    float ovecl = sqrt(ovec[0] * ovec[0] + ovec[1] * ovec[1]);</a>
<a name="ln2977"> </a>
<a name="ln2978">    // angle between input vector and output vector</a>
<a name="ln2979">    float alpha = acos(CLAMP((ivec[0] * ovec[0] + ivec[1] * ovec[1]) / (ivecl * ovecl), -1.0f, 1.0f));</a>
<a name="ln2980"> </a>
<a name="ln2981">    // we are interested if |alpha| is in the range of 90 +/- 45 -&gt; we assume the image is flipped</a>
<a name="ln2982">    int isflipped = fabs(fmod(alpha + M_PI, M_PI) - M_PI / 2.0f) &lt; M_PI / 4.0f ? 1 : 0;</a>
<a name="ln2983"> </a>
<a name="ln2984">    // do modules coming before this one in pixelpipe have changed? -&gt; check via hash value</a>
<a name="ln2985">    uint64_t hash = dt_dev_hash_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_EXCL);</a>
<a name="ln2986"> </a>
<a name="ln2987">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln2988">    g-&gt;isflipped = isflipped;</a>
<a name="ln2989"> </a>
<a name="ln2990">    // save a copy of preview input buffer for parameter fitting</a>
<a name="ln2991">    if(g-&gt;buf == NULL || (size_t)g-&gt;buf_width * g-&gt;buf_height &lt; (size_t)iwidth * iheight)</a>
<a name="ln2992">    {</a>
<a name="ln2993">      // if needed allocate buffer</a>
<a name="ln2994">      free(g-&gt;buf); // a no-op if g-&gt;buf is NULL</a>
<a name="ln2995">      // only get new buffer if no old buffer or old buffer does not fit in terms of size</a>
<a name="ln2996">      g-&gt;buf = malloc((size_t)iwidth * iheight * 4 * sizeof(float));</a>
<a name="ln2997">    }</a>
<a name="ln2998"> </a>
<a name="ln2999">    if(g-&gt;buf /* &amp;&amp; hash != g-&gt;buf_hash */)</a>
<a name="ln3000">    {</a>
<a name="ln3001">      // copy data</a>
<a name="ln3002">      err = dt_opencl_copy_device_to_host(devid, g-&gt;buf, dev_in, iwidth, iheight, 4 * sizeof(float));</a>
<a name="ln3003"> </a>
<a name="ln3004">      g-&gt;buf_width = iwidth;</a>
<a name="ln3005">      g-&gt;buf_height = iheight;</a>
<a name="ln3006">      g-&gt;buf_x_off = x_off;</a>
<a name="ln3007">      g-&gt;buf_y_off = y_off;</a>
<a name="ln3008">      g-&gt;buf_scale = scale;</a>
<a name="ln3009">      g-&gt;buf_hash = hash;</a>
<a name="ln3010">    }</a>
<a name="ln3011">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln3012">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3013">  }</a>
<a name="ln3014"> </a>
<a name="ln3015">  // if module is set to neutral parameters we just copy input-&gt;output and are done</a>
<a name="ln3016">  if(isneutral(d))</a>
<a name="ln3017">  {</a>
<a name="ln3018">    size_t origin[] = { 0, 0, 0 };</a>
<a name="ln3019">    size_t region[] = { width, height, 1 };</a>
<a name="ln3020">    err = dt_opencl_enqueue_copy_image(devid, dev_in, dev_out, origin, origin, region);</a>
<a name="ln3021">    if(err != CL_SUCCESS) goto error;</a>
<a name="ln3022">    return TRUE;</a>
<a name="ln3023">  }</a>
<a name="ln3024"> </a>
<a name="ln3025">  float ihomograph[3][3];</a>
<a name="ln3026">  homography((float *)ihomograph, d-&gt;rotation, d-&gt;lensshift_v, d-&gt;lensshift_h, d-&gt;shear, d-&gt;f_length_kb,</a>
<a name="ln3027">             d-&gt;orthocorr, d-&gt;aspect, piece-&gt;buf_in.width, piece-&gt;buf_in.height, ASHIFT_HOMOGRAPH_INVERTED);</a>
<a name="ln3028"> </a>
<a name="ln3029">  // clipping offset</a>
<a name="ln3030">  const float fullwidth = (float)piece-&gt;buf_out.width / (d-&gt;cr - d-&gt;cl);</a>
<a name="ln3031">  const float fullheight = (float)piece-&gt;buf_out.height / (d-&gt;cb - d-&gt;ct);</a>
<a name="ln3032">  const float cx = roi_out-&gt;scale * fullwidth * d-&gt;cl;</a>
<a name="ln3033">  const float cy = roi_out-&gt;scale * fullheight * d-&gt;ct;</a>
<a name="ln3034"> </a>
<a name="ln3035">  dev_homo = dt_opencl_copy_host_to_device_constant(devid, sizeof(float) * 9, ihomograph);</a>
<a name="ln3036">  if(dev_homo == NULL) goto error;</a>
<a name="ln3037"> </a>
<a name="ln3038">  const int iroi[2] = { roi_in-&gt;x, roi_in-&gt;y };</a>
<a name="ln3039">  const int oroi[2] = { roi_out-&gt;x, roi_out-&gt;y };</a>
<a name="ln3040">  const float in_scale = roi_in-&gt;scale;</a>
<a name="ln3041">  const float out_scale = roi_out-&gt;scale;</a>
<a name="ln3042">  const float clip[2] = { cx, cy };</a>
<a name="ln3043"> </a>
<a name="ln3044">  size_t sizes[] = { ROUNDUPWD(width), ROUNDUPHT(height), 1 };</a>
<a name="ln3045"> </a>
<a name="ln3046">  const struct dt_interpolation *interpolation = dt_interpolation_new(DT_INTERPOLATION_USERPREF);</a>
<a name="ln3047"> </a>
<a name="ln3048">  int ldkernel = -1;</a>
<a name="ln3049"> </a>
<a name="ln3050">  switch(interpolation-&gt;id)</a>
<a name="ln3051">  {</a>
<a name="ln3052">    case DT_INTERPOLATION_BILINEAR:</a>
<a name="ln3053">      ldkernel = gd-&gt;kernel_ashift_bilinear;</a>
<a name="ln3054">      break;</a>
<a name="ln3055">    case DT_INTERPOLATION_BICUBIC:</a>
<a name="ln3056">      ldkernel = gd-&gt;kernel_ashift_bicubic;</a>
<a name="ln3057">      break;</a>
<a name="ln3058">    case DT_INTERPOLATION_LANCZOS2:</a>
<a name="ln3059">      ldkernel = gd-&gt;kernel_ashift_lanczos2;</a>
<a name="ln3060">      break;</a>
<a name="ln3061">    case DT_INTERPOLATION_LANCZOS3:</a>
<a name="ln3062">      ldkernel = gd-&gt;kernel_ashift_lanczos3;</a>
<a name="ln3063">      break;</a>
<a name="ln3064">    default:</a>
<a name="ln3065">      goto error;</a>
<a name="ln3066">  }</a>
<a name="ln3067"> </a>
<a name="ln3068">  dt_opencl_set_kernel_arg(devid, ldkernel, 0, sizeof(cl_mem), (void *)&amp;dev_in);</a>
<a name="ln3069">  dt_opencl_set_kernel_arg(devid, ldkernel, 1, sizeof(cl_mem), (void *)&amp;dev_out);</a>
<a name="ln3070">  dt_opencl_set_kernel_arg(devid, ldkernel, 2, sizeof(int), (void *)&amp;width);</a>
<a name="ln3071">  dt_opencl_set_kernel_arg(devid, ldkernel, 3, sizeof(int), (void *)&amp;height);</a>
<a name="ln3072">  dt_opencl_set_kernel_arg(devid, ldkernel, 4, sizeof(int), (void *)&amp;iwidth);</a>
<a name="ln3073">  dt_opencl_set_kernel_arg(devid, ldkernel, 5, sizeof(int), (void *)&amp;iheight);</a>
<a name="ln3074">  dt_opencl_set_kernel_arg(devid, ldkernel, 6, 2 * sizeof(int), (void *)iroi);</a>
<a name="ln3075">  dt_opencl_set_kernel_arg(devid, ldkernel, 7, 2 * sizeof(int), (void *)oroi);</a>
<a name="ln3076">  dt_opencl_set_kernel_arg(devid, ldkernel, 8, sizeof(float), (void *)&amp;in_scale);</a>
<a name="ln3077">  dt_opencl_set_kernel_arg(devid, ldkernel, 9, sizeof(float), (void *)&amp;out_scale);</a>
<a name="ln3078">  dt_opencl_set_kernel_arg(devid, ldkernel, 10, 2 * sizeof(float), (void *)clip);</a>
<a name="ln3079">  dt_opencl_set_kernel_arg(devid, ldkernel, 11, sizeof(cl_mem), (void *)&amp;dev_homo);</a>
<a name="ln3080">  err = dt_opencl_enqueue_kernel_2d(devid, ldkernel, sizes);</a>
<a name="ln3081">  if(err != CL_SUCCESS) goto error;</a>
<a name="ln3082"> </a>
<a name="ln3083">  dt_opencl_release_mem_object(dev_homo);</a>
<a name="ln3084">  return TRUE;</a>
<a name="ln3085"> </a>
<a name="ln3086">error:</a>
<a name="ln3087">  dt_opencl_release_mem_object(dev_homo);</a>
<a name="ln3088">  dt_print(DT_DEBUG_OPENCL, &quot;[opencl_ashift] couldn't enqueue kernel! %d\n&quot;, err);</a>
<a name="ln3089">  return FALSE;</a>
<a name="ln3090">}</a>
<a name="ln3091">#endif</a>
<a name="ln3092"> </a>
<a name="ln3093">// gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3094">static void get_near(const float *points, dt_iop_ashift_points_idx_t *points_idx, const int lines_count,</a>
<a name="ln3095">                     float pzx, float pzy, float delta)</a>
<a name="ln3096">{</a>
<a name="ln3097">  const float delta2 = delta * delta;</a>
<a name="ln3098"> </a>
<a name="ln3099">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3100">  {</a>
<a name="ln3101">    points_idx[n].near = 0;</a>
<a name="ln3102"> </a>
<a name="ln3103">    // skip irrelevant lines</a>
<a name="ln3104">    if(points_idx[n].type == ASHIFT_LINE_IRRELEVANT)</a>
<a name="ln3105">      continue;</a>
<a name="ln3106"> </a>
<a name="ln3107">    // first check if the mouse pointer is outside the bounding box of the line -&gt; skip this line</a>
<a name="ln3108">    if(pzx &lt; points_idx[n].bbx - delta &amp;&amp;</a>
<a name="ln3109">       pzx &gt; points_idx[n].bbX + delta &amp;&amp;</a>
<a name="ln3110">       pzy &lt; points_idx[n].bby - delta &amp;&amp;</a>
<a name="ln3111">       pzy &gt; points_idx[n].bbY + delta)</a>
<a name="ln3112">      continue;</a>
<a name="ln3113"> </a>
<a name="ln3114">    // pointer is inside bounding box</a>
<a name="ln3115">    size_t offset = points_idx[n].offset;</a>
<a name="ln3116">    const int length = points_idx[n].length;</a>
<a name="ln3117"> </a>
<a name="ln3118">    // sanity check (this should not happen)</a>
<a name="ln3119">    if(length &lt; 2) continue;</a>
<a name="ln3120"> </a>
<a name="ln3121">    // check line point by point</a>
<a name="ln3122">    for(int l = 0; l &lt; length; l++, offset++)</a>
<a name="ln3123">    {</a>
<a name="ln3124">      float dx = pzx - points[offset * 2];</a>
<a name="ln3125">      float dy = pzy - points[offset * 2 + 1];</a>
<a name="ln3126"> </a>
<a name="ln3127">      if(dx * dx + dy * dy &lt; delta2)</a>
<a name="ln3128">      {</a>
<a name="ln3129">        points_idx[n].near = 1;</a>
<a name="ln3130">        break;</a>
<a name="ln3131">      }</a>
<a name="ln3132">    }</a>
<a name="ln3133">  }</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136">// mark lines which are inside a rectangular area in isbounding mode</a>
<a name="ln3137">static void get_bounded_inside(const float *points, dt_iop_ashift_points_idx_t *points_idx,</a>
<a name="ln3138">                               const int points_lines_count, float pzx, float pzy, float pzx2, float pzy2,</a>
<a name="ln3139">                               dt_iop_ashift_bounding_t mode)</a>
<a name="ln3140">{</a>
<a name="ln3141">  // get bounding box coordinates</a>
<a name="ln3142">  float ax = pzx;</a>
<a name="ln3143">  float ay = pzy;</a>
<a name="ln3144">  float bx = pzx2;</a>
<a name="ln3145">  float by = pzy2;</a>
<a name="ln3146">  if(pzx &gt; pzx2)</a>
<a name="ln3147">  {</a>
<a name="ln3148">    ax = pzx2;</a>
<a name="ln3149">    bx = pzx;</a>
<a name="ln3150">  }</a>
<a name="ln3151">  if(pzy &gt; pzy2)</a>
<a name="ln3152">  {</a>
<a name="ln3153">    ay = pzy2;</a>
<a name="ln3154">    by = pzy;</a>
<a name="ln3155">  }</a>
<a name="ln3156"> </a>
<a name="ln3157">  // we either look for the selected or the deselected lines</a>
<a name="ln3158">  dt_iop_ashift_linetype_t mask = ASHIFT_LINE_SELECTED;</a>
<a name="ln3159">  dt_iop_ashift_linetype_t state = (mode == ASHIFT_BOUNDING_DESELECT) ? ASHIFT_LINE_SELECTED : 0;</a>
<a name="ln3160"> </a>
<a name="ln3161">  for(int n = 0; n &lt; points_lines_count; n++)</a>
<a name="ln3162">  {</a>
<a name="ln3163">    // mark line as &quot;not near&quot; and &quot;not bounded&quot;</a>
<a name="ln3164">    points_idx[n].near = 0;</a>
<a name="ln3165">    points_idx[n].bounded = 0;</a>
<a name="ln3166"> </a>
<a name="ln3167">    // skip irrelevant lines</a>
<a name="ln3168">    if(points_idx[n].type == ASHIFT_LINE_IRRELEVANT)</a>
<a name="ln3169">      continue;</a>
<a name="ln3170"> </a>
<a name="ln3171">    // is the line inside the box ?</a>
<a name="ln3172">    if(points_idx[n].bbx &gt;= ax &amp;&amp; points_idx[n].bbx &lt;= bx &amp;&amp; points_idx[n].bbX &gt;= ax</a>
<a name="ln3173">       &amp;&amp; points_idx[n].bbX &lt;= bx &amp;&amp; points_idx[n].bby &gt;= ay &amp;&amp; points_idx[n].bby &lt;= by</a>
<a name="ln3174">       &amp;&amp; points_idx[n].bbY &gt;= ay &amp;&amp; points_idx[n].bbY &lt;= by)</a>
<a name="ln3175">    {</a>
<a name="ln3176">      points_idx[n].bounded = 1;</a>
<a name="ln3177">      // only mark &quot;near&quot;-ness of those lines we are interested in</a>
<a name="ln3178">      points_idx[n].near = ((points_idx[n].type &amp; mask) != state) ? 0 : 1;</a>
<a name="ln3179">    }</a>
<a name="ln3180">  }</a>
<a name="ln3181">}</a>
<a name="ln3182"> </a>
<a name="ln3183">// generate hash value for lines taking into account only the end point coordinates</a>
<a name="ln3184">static uint64_t get_lines_hash(const dt_iop_ashift_line_t *lines, const int lines_count)</a>
<a name="ln3185">{</a>
<a name="ln3186">  uint64_t hash = 5381;</a>
<a name="ln3187">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3188">  {</a>
<a name="ln3189">    float v[4] = { lines[n].p1[0], lines[n].p1[1], lines[n].p2[0], lines[n].p2[1] };</a>
<a name="ln3190">    union {</a>
<a name="ln3191">        float f;</a>
<a name="ln3192">        uint32_t u;</a>
<a name="ln3193">    } x;</a>
<a name="ln3194"> </a>
<a name="ln3195">    for(size_t i = 0; i &lt; 4; i++) {</a>
<a name="ln3196">      x.f = v[i];</a>
<a name="ln3197">      hash = ((hash &lt;&lt; 5) + hash) ^ x.u;</a>
<a name="ln3198">    }</a>
<a name="ln3199">  }</a>
<a name="ln3200">  return hash;</a>
<a name="ln3201">}</a>
<a name="ln3202"> </a>
<a name="ln3203">// update color information in points_idx if lines have changed in terms of type (but not in terms</a>
<a name="ln3204">// of number or position)</a>
<a name="ln3205">static int update_colors(struct dt_iop_module_t *self, dt_iop_ashift_points_idx_t *points_idx,</a>
<a name="ln3206">                         int points_lines_count)</a>
<a name="ln3207">{</a>
<a name="ln3208">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3209"> </a>
<a name="ln3210">  // is the display flipped relative to the original image?</a>
<a name="ln3211">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln3212"> </a>
<a name="ln3213">  // go through all lines</a>
<a name="ln3214">  for(int n = 0; n &lt; points_lines_count; n++)</a>
<a name="ln3215">  {</a>
<a name="ln3216">    const dt_iop_ashift_linetype_t type = points_idx[n].type;</a>
<a name="ln3217"> </a>
<a name="ln3218">    // set line color according to line type/orientation</a>
<a name="ln3219">    // note: if the screen display is flipped versus the original image we need</a>
<a name="ln3220">    // to respect that fact in the color selection</a>
<a name="ln3221">    if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3222">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_BLUE : ASHIFT_LINECOLOR_GREEN;</a>
<a name="ln3223">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_NOT_SELECTED)</a>
<a name="ln3224">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_YELLOW : ASHIFT_LINECOLOR_RED;</a>
<a name="ln3225">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3226">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_GREEN : ASHIFT_LINECOLOR_BLUE;</a>
<a name="ln3227">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_NOT_SELECTED)</a>
<a name="ln3228">      points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_RED : ASHIFT_LINECOLOR_YELLOW;</a>
<a name="ln3229">    else</a>
<a name="ln3230">      points_idx[n].color = ASHIFT_LINECOLOR_GREY;</a>
<a name="ln3231">  }</a>
<a name="ln3232"> </a>
<a name="ln3233">  return TRUE;</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">// get all the points to display lines in the gui</a>
<a name="ln3237">static int get_points(struct dt_iop_module_t *self, const dt_iop_ashift_line_t *lines, const int lines_count,</a>
<a name="ln3238">                      const int lines_version, float **points, dt_iop_ashift_points_idx_t **points_idx,</a>
<a name="ln3239">                      int *points_lines_count)</a>
<a name="ln3240">{</a>
<a name="ln3241">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln3242">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3243"> </a>
<a name="ln3244">  dt_iop_ashift_points_idx_t *my_points_idx = NULL;</a>
<a name="ln3245">  float *my_points = NULL;</a>
<a name="ln3246"> </a>
<a name="ln3247">  // is the display flipped relative to the original image?</a>
<a name="ln3248">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln3249"> </a>
<a name="ln3250">  // allocate new index array</a>
<a name="ln3251">  my_points_idx = (dt_iop_ashift_points_idx_t *)malloc(lines_count * sizeof(dt_iop_ashift_points_idx_t));</a>
<a name="ln3252">  if(my_points_idx == NULL) goto error;</a>
<a name="ln3253"> </a>
<a name="ln3254">  // account for total number of points</a>
<a name="ln3255">  size_t total_points = 0;</a>
<a name="ln3256"> </a>
<a name="ln3257">  // first step: basic initialization of my_points_idx and counting of total_points</a>
<a name="ln3258">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3259">  {</a>
<a name="ln3260">    const int length = lines[n].length;</a>
<a name="ln3261"> </a>
<a name="ln3262">    total_points += length;</a>
<a name="ln3263"> </a>
<a name="ln3264">    my_points_idx[n].length = length;</a>
<a name="ln3265">    my_points_idx[n].near = 0;</a>
<a name="ln3266">    my_points_idx[n].bounded = 0;</a>
<a name="ln3267"> </a>
<a name="ln3268">    const dt_iop_ashift_linetype_t type = lines[n].type;</a>
<a name="ln3269">    my_points_idx[n].type = type;</a>
<a name="ln3270"> </a>
<a name="ln3271">    // set line color according to line type/orientation</a>
<a name="ln3272">    // note: if the screen display is flipped versus the original image we need</a>
<a name="ln3273">    // to respect that fact in the color selection</a>
<a name="ln3274">    if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3275">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_BLUE : ASHIFT_LINECOLOR_GREEN;</a>
<a name="ln3276">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_NOT_SELECTED)</a>
<a name="ln3277">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_YELLOW : ASHIFT_LINECOLOR_RED;</a>
<a name="ln3278">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3279">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_GREEN : ASHIFT_LINECOLOR_BLUE;</a>
<a name="ln3280">    else if((type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_NOT_SELECTED)</a>
<a name="ln3281">      my_points_idx[n].color = isflipped ? ASHIFT_LINECOLOR_RED : ASHIFT_LINECOLOR_YELLOW;</a>
<a name="ln3282">    else</a>
<a name="ln3283">      my_points_idx[n].color = ASHIFT_LINECOLOR_GREY;</a>
<a name="ln3284">  }</a>
<a name="ln3285"> </a>
<a name="ln3286">  // now allocate new points buffer</a>
<a name="ln3287">  my_points = (float *)malloc((size_t)2 * total_points * sizeof(float));</a>
<a name="ln3288">  if(my_points == NULL) goto error;</a>
<a name="ln3289"> </a>
<a name="ln3290">  // second step: generate points for each line</a>
<a name="ln3291">  for(int n = 0, offset = 0; n &lt; lines_count; n++)</a>
<a name="ln3292">  {</a>
<a name="ln3293">    my_points_idx[n].offset = offset;</a>
<a name="ln3294"> </a>
<a name="ln3295">    float x = lines[n].p1[0];</a>
<a name="ln3296">    float y = lines[n].p1[1];</a>
<a name="ln3297">    const int length = lines[n].length;</a>
<a name="ln3298"> </a>
<a name="ln3299">    const float dx = (lines[n].p2[0] - x) / (float)(length - 1);</a>
<a name="ln3300">    const float dy = (lines[n].p2[1] - y) / (float)(length - 1);</a>
<a name="ln3301"> </a>
<a name="ln3302">    for(int l = 0; l &lt; length &amp;&amp; offset &lt; total_points; l++, offset++)</a>
<a name="ln3303">    {</a>
<a name="ln3304">      my_points[2 * offset] = x;</a>
<a name="ln3305">      my_points[2 * offset + 1] = y;</a>
<a name="ln3306"> </a>
<a name="ln3307">      x += dx;</a>
<a name="ln3308">      y += dy;</a>
<a name="ln3309">    }</a>
<a name="ln3310">  }</a>
<a name="ln3311"> </a>
<a name="ln3312">  // third step: transform all points</a>
<a name="ln3313">  if(!dt_dev_distort_transform_plus(dev, dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_INCL, my_points, total_points))</a>
<a name="ln3314">    goto error;</a>
<a name="ln3315"> </a>
<a name="ln3316">  // fourth step: get bounding box in final coordinates (used later for checking &quot;near&quot;-ness to mouse pointer)</a>
<a name="ln3317">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3318">  {</a>
<a name="ln3319">    float xmin = FLT_MAX, xmax = FLT_MIN, ymin = FLT_MAX, ymax = FLT_MIN;</a>
<a name="ln3320"> </a>
<a name="ln3321">    size_t offset = my_points_idx[n].offset;</a>
<a name="ln3322">    int length = my_points_idx[n].length;</a>
<a name="ln3323"> </a>
<a name="ln3324">    for(int l = 0; l &lt; length; l++)</a>
<a name="ln3325">    {</a>
<a name="ln3326">      xmin = fmin(xmin, my_points[2 * offset]);</a>
<a name="ln3327">      xmax = fmax(xmax, my_points[2 * offset]);</a>
<a name="ln3328">      ymin = fmin(ymin, my_points[2 * offset + 1]);</a>
<a name="ln3329">      ymax = fmax(ymax, my_points[2 * offset + 1]);</a>
<a name="ln3330">    }</a>
<a name="ln3331"> </a>
<a name="ln3332">    my_points_idx[n].bbx = xmin;</a>
<a name="ln3333">    my_points_idx[n].bbX = xmax;</a>
<a name="ln3334">    my_points_idx[n].bby = ymin;</a>
<a name="ln3335">    my_points_idx[n].bbY = ymax;</a>
<a name="ln3336">  }</a>
<a name="ln3337"> </a>
<a name="ln3338">  // check if lines_version has changed in-between -&gt; too bad: we can forget about all we did :(</a>
<a name="ln3339">  if(g-&gt;lines_version &gt; lines_version)</a>
<a name="ln3340">    goto error;</a>
<a name="ln3341"> </a>
<a name="ln3342">  *points = my_points;</a>
<a name="ln3343">  *points_idx = my_points_idx;</a>
<a name="ln3344">  *points_lines_count = lines_count;</a>
<a name="ln3345"> </a>
<a name="ln3346">  return TRUE;</a>
<a name="ln3347"> </a>
<a name="ln3348">error:</a>
<a name="ln3349">  if(my_points_idx != NULL) free(my_points_idx);</a>
<a name="ln3350">  if(my_points != NULL) free(my_points);</a>
<a name="ln3351">  return FALSE;</a>
<a name="ln3352">}</a>
<a name="ln3353"> </a>
<a name="ln3354">// does this gui have focus?</a>
<a name="ln3355">static int gui_has_focus(struct dt_iop_module_t *self)</a>
<a name="ln3356">{</a>
<a name="ln3357">  return self-&gt;dev-&gt;gui_module == self;</a>
<a name="ln3358">}</a>
<a name="ln3359"> </a>
<a name="ln3360">/* this function replaces this sentence, it calls distort_transform() for this module on the pipe</a>
<a name="ln3361">if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;priority, self-&gt;priority + 1,</a>
<a name="ln3362">      (float *)V, 4))</a>
<a name="ln3363">*/</a>
<a name="ln3364">static int call_distort_transform(dt_develop_t *dev, dt_dev_pixelpipe_t *pipe, struct dt_iop_module_t *self,</a>
<a name="ln3365">                                  float *points, size_t points_count)</a>
<a name="ln3366">{</a>
<a name="ln3367">  int ret = 0;</a>
<a name="ln3368">  dt_dev_pixelpipe_iop_t *piece = dt_dev_distort_get_iop_pipe(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self);</a>
<a name="ln3369">  if(!piece) return ret;</a>
<a name="ln3370">  if(piece-&gt;module == self &amp;&amp; piece-&gt;enabled &amp;&amp;</a>
<a name="ln3371">     !(dev-&gt;gui_module &amp;&amp; dev-&gt;gui_module-&gt;operation_tags_filter() &amp; piece-&gt;module-&gt;operation_tags()))</a>
<a name="ln3372">  {</a>
<a name="ln3373">    ret = piece-&gt;module-&gt;distort_transform(piece-&gt;module, piece, points, points_count);</a>
<a name="ln3374">  }</a>
<a name="ln3375">  return ret;</a>
<a name="ln3376">}</a>
<a name="ln3377"> </a>
<a name="ln3378">void gui_post_expose(struct dt_iop_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln3379">                     int32_t pointerx, int32_t pointery)</a>
<a name="ln3380">{</a>
<a name="ln3381">  dt_develop_t *dev = self-&gt;dev;</a>
<a name="ln3382">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3383">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3384"> </a>
<a name="ln3385">  // the usual rescaling stuff</a>
<a name="ln3386">  const float wd = dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3387">  const float ht = dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3388">  if(wd &lt; 1.0 || ht &lt; 1.0) return;</a>
<a name="ln3389">  const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln3390">  const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln3391">  const dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3392">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3393">  const float zoom_scale = dt_dev_get_zoom_scale(dev, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln3394"> </a>
<a name="ln3395">  // we draw the cropping area; we need x_off/y_off/width/height which is only available</a>
<a name="ln3396">  // after g-&gt;buf has been processed</a>
<a name="ln3397">  if(g-&gt;buf &amp;&amp; (p-&gt;cropmode != ASHIFT_CROP_OFF) &amp;&amp; self-&gt;enabled)</a>
<a name="ln3398">  {</a>
<a name="ln3399">    // roi data of the preview pipe input buffer</a>
<a name="ln3400">    const float iwd = g-&gt;buf_width;</a>
<a name="ln3401">    const float iht = g-&gt;buf_height;</a>
<a name="ln3402">    const float ixo = g-&gt;buf_x_off;</a>
<a name="ln3403">    const float iyo = g-&gt;buf_y_off;</a>
<a name="ln3404"> </a>
<a name="ln3405">    // the four corners of the input buffer of this module</a>
<a name="ln3406">    const float V[4][2] = { { ixo,        iyo       },</a>
<a name="ln3407">                          {   ixo,        iyo + iht },</a>
<a name="ln3408">                          {   ixo + iwd,  iyo + iht },</a>
<a name="ln3409">                          {   ixo + iwd,  iyo       } };</a>
<a name="ln3410"> </a>
<a name="ln3411">    // convert coordinates of corners to coordinates of this module's output</a>
<a name="ln3412">    if(!call_distort_transform(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self, (float *)V, 4))</a>
<a name="ln3413">      return;</a>
<a name="ln3414"> </a>
<a name="ln3415">    // get x/y-offset as well as width and height of output buffer</a>
<a name="ln3416">    float xmin = FLT_MAX, ymin = FLT_MAX, xmax = FLT_MIN, ymax = FLT_MIN;</a>
<a name="ln3417">    for(int n = 0; n &lt; 4; n++)</a>
<a name="ln3418">    {</a>
<a name="ln3419">      xmin = MIN(xmin, V[n][0]);</a>
<a name="ln3420">      xmax = MAX(xmax, V[n][0]);</a>
<a name="ln3421">      ymin = MIN(ymin, V[n][1]);</a>
<a name="ln3422">      ymax = MAX(ymax, V[n][1]);</a>
<a name="ln3423">    }</a>
<a name="ln3424">    const float owd = xmax - xmin;</a>
<a name="ln3425">    const float oht = ymax - ymin;</a>
<a name="ln3426"> </a>
<a name="ln3427">    // the four clipping corners</a>
<a name="ln3428">    const float C[4][2] = { { xmin + p-&gt;cl * owd, ymin + p-&gt;ct * oht },</a>
<a name="ln3429">                            { xmin + p-&gt;cl * owd, ymin + p-&gt;cb * oht },</a>
<a name="ln3430">                            { xmin + p-&gt;cr * owd, ymin + p-&gt;cb * oht },</a>
<a name="ln3431">                            { xmin + p-&gt;cr * owd, ymin + p-&gt;ct * oht } };</a>
<a name="ln3432"> </a>
<a name="ln3433">    // convert clipping corners to final output image</a>
<a name="ln3434">    if(!dt_dev_distort_transform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order, DT_DEV_TRANSFORM_DIR_FORW_EXCL,</a>
<a name="ln3435">      (float *)C, 4))</a>
<a name="ln3436">      return;</a>
<a name="ln3437"> </a>
<a name="ln3438">    cairo_save(cr);</a>
<a name="ln3439"> </a>
<a name="ln3440">    double dashes = DT_PIXEL_APPLY_DPI(5.0) / zoom_scale;</a>
<a name="ln3441">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln3442"> </a>
<a name="ln3443">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3444">    cairo_clip(cr);</a>
<a name="ln3445"> </a>
<a name="ln3446">    // mask parts of image outside of clipping area in dark grey</a>
<a name="ln3447">    cairo_set_source_rgba(cr, .2, .2, .2, .8);</a>
<a name="ln3448">    cairo_set_fill_rule(cr, CAIRO_FILL_RULE_EVEN_ODD);</a>
<a name="ln3449">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3450">    cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln3451">    cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3452">    cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3453">    cairo_move_to(cr, C[0][0], C[0][1]);</a>
<a name="ln3454">    cairo_line_to(cr, C[1][0], C[1][1]);</a>
<a name="ln3455">    cairo_line_to(cr, C[2][0], C[2][1]);</a>
<a name="ln3456">    cairo_line_to(cr, C[3][0], C[3][1]);</a>
<a name="ln3457">    cairo_close_path(cr);</a>
<a name="ln3458">    cairo_fill(cr);</a>
<a name="ln3459"> </a>
<a name="ln3460">    // draw white outline around clipping area</a>
<a name="ln3461">    cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3462">    cairo_move_to(cr, C[0][0], C[0][1]);</a>
<a name="ln3463">    cairo_line_to(cr, C[1][0], C[1][1]);</a>
<a name="ln3464">    cairo_line_to(cr, C[2][0], C[2][1]);</a>
<a name="ln3465">    cairo_line_to(cr, C[3][0], C[3][1]);</a>
<a name="ln3466">    cairo_close_path(cr);</a>
<a name="ln3467">    cairo_stroke(cr);</a>
<a name="ln3468"> </a>
<a name="ln3469">    // if adjusting crop, draw indicator</a>
<a name="ln3470">    if (g-&gt;adjust_crop &amp;&amp; p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln3471">    {</a>
<a name="ln3472">      const double x1 = C[0][0];</a>
<a name="ln3473">      const double x2 = fabs(x1 - C[1][0]) &lt; 0.001f ? C[2][0] : C[1][0];</a>
<a name="ln3474">      const double y1 = C[0][1];</a>
<a name="ln3475">      const double y2 = fabs(y1 - C[1][1]) &lt; 0.001f ? C[2][1] : C[1][1];</a>
<a name="ln3476"> </a>
<a name="ln3477">      const double xpos = (x1 + x2) / 2.0f;</a>
<a name="ln3478">      const double ypos = (y1 + y2) / 2.0f;</a>
<a name="ln3479">      const double base_size = fabs(x1 - x2);</a>
<a name="ln3480">      const double size_circle = base_size / 30.0f;</a>
<a name="ln3481">      const double size_line = base_size / 5.0f;</a>
<a name="ln3482">      const double size_arrow = base_size / 25.0f;</a>
<a name="ln3483"> </a>
<a name="ln3484">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln3485">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3486">      cairo_arc (cr, xpos, ypos, size_circle, 0, 2.0 * M_PI);</a>
<a name="ln3487">      cairo_stroke(cr);</a>
<a name="ln3488">      cairo_fill(cr);</a>
<a name="ln3489"> </a>
<a name="ln3490">      cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln3491">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln3492"> </a>
<a name="ln3493">      // horizontal line</a>
<a name="ln3494">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3495">      cairo_line_to(cr, xpos + size_line, ypos);</a>
<a name="ln3496"> </a>
<a name="ln3497">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3498">      cairo_rel_line_to(cr, size_arrow, size_arrow);</a>
<a name="ln3499">      cairo_move_to(cr, xpos - size_line, ypos);</a>
<a name="ln3500">      cairo_rel_line_to(cr, size_arrow, -size_arrow);</a>
<a name="ln3501"> </a>
<a name="ln3502">      cairo_move_to(cr, xpos + size_line, ypos);</a>
<a name="ln3503">      cairo_rel_line_to(cr, -size_arrow, size_arrow);</a>
<a name="ln3504">      cairo_move_to(cr, xpos + size_line, ypos);</a>
<a name="ln3505">      cairo_rel_line_to(cr, -size_arrow, -size_arrow);</a>
<a name="ln3506"> </a>
<a name="ln3507">      // vertical line</a>
<a name="ln3508">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3509">      cairo_line_to(cr, xpos, ypos + size_line);</a>
<a name="ln3510"> </a>
<a name="ln3511">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3512">      cairo_rel_line_to(cr, -size_arrow, size_arrow);</a>
<a name="ln3513">      cairo_move_to(cr, xpos, ypos - size_line);</a>
<a name="ln3514">      cairo_rel_line_to(cr, size_arrow, size_arrow);</a>
<a name="ln3515"> </a>
<a name="ln3516">      cairo_move_to(cr, xpos, ypos + size_line);</a>
<a name="ln3517">      cairo_rel_line_to(cr, -size_arrow, -size_arrow);</a>
<a name="ln3518">      cairo_move_to(cr, xpos, ypos + size_line);</a>
<a name="ln3519">      cairo_rel_line_to(cr, size_arrow, -size_arrow);</a>
<a name="ln3520"> </a>
<a name="ln3521">      cairo_stroke(cr);</a>
<a name="ln3522">    }</a>
<a name="ln3523"> </a>
<a name="ln3524">    cairo_restore(cr);</a>
<a name="ln3525">  }</a>
<a name="ln3526"> </a>
<a name="ln3527">  // show guide lines on request</a>
<a name="ln3528">  if(g-&gt;show_guides)</a>
<a name="ln3529">  {</a>
<a name="ln3530">    dt_guides_t *guide = (dt_guides_t *)g_list_nth_data(darktable.guides, 0);</a>
<a name="ln3531">    double dashes = DT_PIXEL_APPLY_DPI(5.0);</a>
<a name="ln3532">    cairo_save(cr);</a>
<a name="ln3533">    cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3534">    cairo_clip(cr);</a>
<a name="ln3535">    cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.0));</a>
<a name="ln3536">    cairo_set_source_rgb(cr, .8, .8, .8);</a>
<a name="ln3537">    cairo_set_dash(cr, &amp;dashes, 1, 0);</a>
<a name="ln3538">    guide-&gt;draw(cr, 0, 0, width, height, 1.0, guide-&gt;user_data);</a>
<a name="ln3539">    cairo_stroke_preserve(cr);</a>
<a name="ln3540">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln3541">    cairo_set_source_rgba(cr, 0.3, .3, .3, .8);</a>
<a name="ln3542">    cairo_stroke(cr);</a>
<a name="ln3543">    cairo_restore(cr);</a>
<a name="ln3544">  }</a>
<a name="ln3545"> </a>
<a name="ln3546">  // structural data are currently being collected or fit procedure is running? -&gt; skip</a>
<a name="ln3547">  if(g-&gt;fitting) return;</a>
<a name="ln3548"> </a>
<a name="ln3549">  // no structural data or visibility switched off? -&gt; stop here</a>
<a name="ln3550">  if(g-&gt;lines == NULL || g-&gt;lines_suppressed || !gui_has_focus(self)) return;</a>
<a name="ln3551"> </a>
<a name="ln3552">  // get hash value that changes if distortions from here to the end of the pixelpipe changed</a>
<a name="ln3553">  uint64_t hash = dt_dev_hash_distort(dev);</a>
<a name="ln3554">  // get hash value that changes if coordinates of lines have changed</a>
<a name="ln3555">  uint64_t lines_hash = get_lines_hash(g-&gt;lines, g-&gt;lines_count);</a>
<a name="ln3556"> </a>
<a name="ln3557">  // points data are missing or outdated, or distortion has changed?</a>
<a name="ln3558">  if(g-&gt;points == NULL || g-&gt;points_idx == NULL || hash != g-&gt;grid_hash ||</a>
<a name="ln3559">    (g-&gt;lines_version &gt; g-&gt;points_version &amp;&amp; g-&gt;lines_hash != lines_hash))</a>
<a name="ln3560">  {</a>
<a name="ln3561">    // we need to reprocess points</a>
<a name="ln3562">    free(g-&gt;points);</a>
<a name="ln3563">    g-&gt;points = NULL;</a>
<a name="ln3564">    free(g-&gt;points_idx);</a>
<a name="ln3565">    g-&gt;points_idx = NULL;</a>
<a name="ln3566">    g-&gt;points_lines_count = 0;</a>
<a name="ln3567"> </a>
<a name="ln3568">    if(!get_points(self, g-&gt;lines, g-&gt;lines_count, g-&gt;lines_version, &amp;g-&gt;points, &amp;g-&gt;points_idx,</a>
<a name="ln3569">                   &amp;g-&gt;points_lines_count))</a>
<a name="ln3570">      return;</a>
<a name="ln3571"> </a>
<a name="ln3572">    g-&gt;points_version = g-&gt;lines_version;</a>
<a name="ln3573">    g-&gt;grid_hash = hash;</a>
<a name="ln3574">    g-&gt;lines_hash = lines_hash;</a>
<a name="ln3575">  }</a>
<a name="ln3576">  else if(g-&gt;lines_hash == lines_hash)</a>
<a name="ln3577">  {</a>
<a name="ln3578">    // update line type information in points_idx</a>
<a name="ln3579">    for(int n = 0; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3580">      g-&gt;points_idx[n].type = g-&gt;lines[n].type;</a>
<a name="ln3581"> </a>
<a name="ln3582">    // coordinates of lines are unchanged -&gt; we only need to update colors</a>
<a name="ln3583">    if(!update_colors(self, g-&gt;points_idx, g-&gt;points_lines_count))</a>
<a name="ln3584">      return;</a>
<a name="ln3585"> </a>
<a name="ln3586">    g-&gt;points_version = g-&gt;lines_version;</a>
<a name="ln3587">  }</a>
<a name="ln3588"> </a>
<a name="ln3589">  // a final check</a>
<a name="ln3590">  if(g-&gt;points == NULL || g-&gt;points_idx == NULL) return;</a>
<a name="ln3591"> </a>
<a name="ln3592">  cairo_save(cr);</a>
<a name="ln3593">  cairo_rectangle(cr, 0, 0, width, height);</a>
<a name="ln3594">  cairo_clip(cr);</a>
<a name="ln3595">  cairo_translate(cr, width / 2.0, height / 2.0);</a>
<a name="ln3596">  cairo_scale(cr, zoom_scale, zoom_scale);</a>
<a name="ln3597">  cairo_translate(cr, -.5f * wd - zoom_x * wd, -.5f * ht - zoom_y * ht);</a>
<a name="ln3598"> </a>
<a name="ln3599">  // this must match the sequence of enum dt_iop_ashift_linecolor_t!</a>
<a name="ln3600">  const float line_colors[5][4] =</a>
<a name="ln3601">  { { 0.3f, 0.3f, 0.3f, 0.8f },                    // grey (misc. lines)</a>
<a name="ln3602">    { 0.0f, 1.0f, 0.0f, 0.8f },                    // green (selected vertical lines)</a>
<a name="ln3603">    { 0.8f, 0.0f, 0.0f, 0.8f },                    // red (de-selected vertical lines)</a>
<a name="ln3604">    { 0.0f, 0.0f, 1.0f, 0.8f },                    // blue (selected horizontal lines)</a>
<a name="ln3605">    { 0.8f, 0.8f, 0.0f, 0.8f } };                  // yellow (de-selected horizontal lines)</a>
<a name="ln3606"> </a>
<a name="ln3607">  cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln3608"> </a>
<a name="ln3609">  // now draw all lines</a>
<a name="ln3610">  for(int n = 0; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3611">  {</a>
<a name="ln3612">    // is the near flag set? -&gt; draw line a bit thicker</a>
<a name="ln3613">    if(g-&gt;points_idx[n].near)</a>
<a name="ln3614">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(3.0) / zoom_scale);</a>
<a name="ln3615">    else</a>
<a name="ln3616">      cairo_set_line_width(cr, DT_PIXEL_APPLY_DPI(1.5) / zoom_scale);</a>
<a name="ln3617"> </a>
<a name="ln3618">    // the color of this line</a>
<a name="ln3619">    const float *color = line_colors[g-&gt;points_idx[n].color];</a>
<a name="ln3620">    cairo_set_source_rgba(cr, color[0], color[1], color[2], color[3]);</a>
<a name="ln3621"> </a>
<a name="ln3622">    size_t offset = g-&gt;points_idx[n].offset;</a>
<a name="ln3623">    const int length = g-&gt;points_idx[n].length;</a>
<a name="ln3624"> </a>
<a name="ln3625">    // sanity check (this should not happen)</a>
<a name="ln3626">    if(length &lt; 2) continue;</a>
<a name="ln3627"> </a>
<a name="ln3628">    // set starting point of multi-segment line</a>
<a name="ln3629">    cairo_move_to(cr, g-&gt;points[offset * 2], g-&gt;points[offset * 2 + 1]);</a>
<a name="ln3630"> </a>
<a name="ln3631">    offset++;</a>
<a name="ln3632">    // draw individual line segments</a>
<a name="ln3633">    for(int l = 1; l &lt; length; l++, offset++)</a>
<a name="ln3634">    {</a>
<a name="ln3635">      cairo_line_to(cr, g-&gt;points[offset * 2], g-&gt;points[offset * 2 + 1]);</a>
<a name="ln3636">    }</a>
<a name="ln3637"> </a>
<a name="ln3638">    // finally stroke the line</a>
<a name="ln3639">    cairo_stroke(cr);</a>
<a name="ln3640">  }</a>
<a name="ln3641"> </a>
<a name="ln3642">  // and we draw the selection box if any</a>
<a name="ln3643">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF)</a>
<a name="ln3644">  {</a>
<a name="ln3645">    float pzx, pzy;</a>
<a name="ln3646">    dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln3647">    pzx += 0.5f;</a>
<a name="ln3648">    pzy += 0.5f;</a>
<a name="ln3649"> </a>
<a name="ln3650">    double dashed[] = { 4.0, 4.0 };</a>
<a name="ln3651">    dashed[0] /= zoom_scale;</a>
<a name="ln3652">    dashed[1] /= zoom_scale;</a>
<a name="ln3653">    int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln3654"> </a>
<a name="ln3655">    cairo_rectangle(cr, g-&gt;lastx * wd, g-&gt;lasty * ht, (pzx - g-&gt;lastx) * wd, (pzy - g-&gt;lasty) * ht);</a>
<a name="ln3656"> </a>
<a name="ln3657">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln3658">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln3659">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln3660">    cairo_stroke_preserve(cr);</a>
<a name="ln3661">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln3662">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln3663">    cairo_stroke(cr);</a>
<a name="ln3664">  }</a>
<a name="ln3665"> </a>
<a name="ln3666">  // indicate which area is used for &quot;near&quot;-ness detection when selecting/deselecting lines</a>
<a name="ln3667">  if(g-&gt;near_delta &gt; 0)</a>
<a name="ln3668">  {</a>
<a name="ln3669">    float pzx, pzy;</a>
<a name="ln3670">    dt_dev_get_pointer_zoom_pos(dev, pointerx, pointery, &amp;pzx, &amp;pzy);</a>
<a name="ln3671">    pzx += 0.5f;</a>
<a name="ln3672">    pzy += 0.5f;</a>
<a name="ln3673"> </a>
<a name="ln3674">    double dashed[] = { 4.0, 4.0 };</a>
<a name="ln3675">    dashed[0] /= zoom_scale;</a>
<a name="ln3676">    dashed[1] /= zoom_scale;</a>
<a name="ln3677">    int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln3678"> </a>
<a name="ln3679">    cairo_arc(cr, pzx * wd, pzy * ht, g-&gt;near_delta, 0, 2.0 * M_PI);</a>
<a name="ln3680"> </a>
<a name="ln3681">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln3682">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln3683">    cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln3684">    cairo_stroke_preserve(cr);</a>
<a name="ln3685">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln3686">    cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln3687">    cairo_stroke(cr);</a>
<a name="ln3688">  }</a>
<a name="ln3689"> </a>
<a name="ln3690">  cairo_restore(cr);</a>
<a name="ln3691">}</a>
<a name="ln3692"> </a>
<a name="ln3693">// update the number of selected vertical and horizontal lines</a>
<a name="ln3694">static void update_lines_count(const dt_iop_ashift_line_t *lines, const int lines_count,</a>
<a name="ln3695">                               int *vertical_count, int *horizontal_count)</a>
<a name="ln3696">{</a>
<a name="ln3697">  int vlines = 0;</a>
<a name="ln3698">  int hlines = 0;</a>
<a name="ln3699"> </a>
<a name="ln3700">  for(int n = 0; n &lt; lines_count; n++)</a>
<a name="ln3701">  {</a>
<a name="ln3702">    if((lines[n].type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_VERTICAL_SELECTED)</a>
<a name="ln3703">      vlines++;</a>
<a name="ln3704">    else if((lines[n].type &amp; ASHIFT_LINE_MASK) == ASHIFT_LINE_HORIZONTAL_SELECTED)</a>
<a name="ln3705">      hlines++;</a>
<a name="ln3706">  }</a>
<a name="ln3707"> </a>
<a name="ln3708">  *vertical_count = vlines;</a>
<a name="ln3709">  *horizontal_count = hlines;</a>
<a name="ln3710">}</a>
<a name="ln3711"> </a>
<a name="ln3712">int mouse_moved(struct dt_iop_module_t *self, double x, double y, double pressure, int which)</a>
<a name="ln3713">{</a>
<a name="ln3714">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3715">  int handled = 0;</a>
<a name="ln3716"> </a>
<a name="ln3717">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3718">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3719">  if(wd &lt; 1.0 || ht &lt; 1.0) return 1;</a>
<a name="ln3720"> </a>
<a name="ln3721">  float pzx, pzy;</a>
<a name="ln3722">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3723">  pzx += 0.5f;</a>
<a name="ln3724">  pzy += 0.5f;</a>
<a name="ln3725"> </a>
<a name="ln3726">  if (g-&gt;adjust_crop)</a>
<a name="ln3727">  {</a>
<a name="ln3728">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3729"> </a>
<a name="ln3730">    float pts[4] = { pzx, pzy, 1.0f, 1.0f };</a>
<a name="ln3731">    dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order,</a>
<a name="ln3732">                                      DT_DEV_TRANSFORM_DIR_FORW_INCL, pts, 2);</a>
<a name="ln3733"> </a>
<a name="ln3734">    const float newx = g-&gt;crop_cx + (pts[0] - pts[2]) - g-&gt;lastx;</a>
<a name="ln3735">    const float newy = g-&gt;crop_cy + (pts[1] - pts[3]) - g-&gt;lasty;</a>
<a name="ln3736"> </a>
<a name="ln3737">    crop_adjust(self, p, newx, newy);</a>
<a name="ln3738">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln3739">    return TRUE;</a>
<a name="ln3740">  }</a>
<a name="ln3741"> </a>
<a name="ln3742">  // if in rectangle selecting mode adjust &quot;near&quot;-ness of lines according to</a>
<a name="ln3743">  // the rectangular selection</a>
<a name="ln3744">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF)</a>
<a name="ln3745">  {</a>
<a name="ln3746">    if(wd &gt;= 1.0 &amp;&amp; ht &gt;= 1.0)</a>
<a name="ln3747">    {</a>
<a name="ln3748">      // mark lines inside the rectangle</a>
<a name="ln3749">      get_bounded_inside(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;lastx * wd,</a>
<a name="ln3750">                         g-&gt;lasty * ht, g-&gt;isbounding);</a>
<a name="ln3751">    }</a>
<a name="ln3752"> </a>
<a name="ln3753">    dt_control_queue_redraw_center();</a>
<a name="ln3754">    return FALSE;</a>
<a name="ln3755">  }</a>
<a name="ln3756"> </a>
<a name="ln3757">  // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3758">  get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3759"> </a>
<a name="ln3760">  // if we are in sweeping mode iterate over lines as we move the pointer and change &quot;selected&quot; state.</a>
<a name="ln3761">  if(g-&gt;isdeselecting || g-&gt;isselecting)</a>
<a name="ln3762">  {</a>
<a name="ln3763">    for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3764">    {</a>
<a name="ln3765">      if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3766">        continue;</a>
<a name="ln3767"> </a>
<a name="ln3768">      if(g-&gt;isdeselecting)</a>
<a name="ln3769">        g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3770">      else if(g-&gt;isselecting)</a>
<a name="ln3771">        g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3772"> </a>
<a name="ln3773">      handled = 1;</a>
<a name="ln3774">    }</a>
<a name="ln3775">  }</a>
<a name="ln3776"> </a>
<a name="ln3777">  if(handled)</a>
<a name="ln3778">  {</a>
<a name="ln3779">    update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3780">    g-&gt;lines_version++;</a>
<a name="ln3781">    g-&gt;selecting_lines_version++;</a>
<a name="ln3782">  }</a>
<a name="ln3783"> </a>
<a name="ln3784">  dt_control_queue_redraw_center();</a>
<a name="ln3785"> </a>
<a name="ln3786">  // if not in sweeping mode we need to pass the event</a>
<a name="ln3787">  return (g-&gt;isdeselecting || g-&gt;isselecting);</a>
<a name="ln3788">}</a>
<a name="ln3789"> </a>
<a name="ln3790">int button_pressed(struct dt_iop_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln3791">                   uint32_t state)</a>
<a name="ln3792">{</a>
<a name="ln3793">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3794">  int handled = 0;</a>
<a name="ln3795"> </a>
<a name="ln3796">  float pzx, pzy;</a>
<a name="ln3797">  dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3798">  pzx += 0.5f;</a>
<a name="ln3799">  pzy += 0.5f;</a>
<a name="ln3800"> </a>
<a name="ln3801">  const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3802">  const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3803">  if(wd &lt; 1.0 || ht &lt; 1.0) return 1;</a>
<a name="ln3804"> </a>
<a name="ln3805"> </a>
<a name="ln3806">  // if visibility of lines is switched off or no lines available -&gt; potentially adjust crop area</a>
<a name="ln3807">  if(g-&gt;lines_suppressed || g-&gt;lines == NULL)</a>
<a name="ln3808">  {</a>
<a name="ln3809">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln3810">    if (p-&gt;cropmode == ASHIFT_CROP_ASPECT)</a>
<a name="ln3811">    {</a>
<a name="ln3812">      dt_control_change_cursor(GDK_HAND1);</a>
<a name="ln3813">      g-&gt;adjust_crop = TRUE;</a>
<a name="ln3814"> </a>
<a name="ln3815">      float pts[4] = { pzx, pzy, 1.0f, 1.0f };</a>
<a name="ln3816">      dt_dev_distort_backtransform_plus(self-&gt;dev, self-&gt;dev-&gt;preview_pipe, self-&gt;iop_order,</a>
<a name="ln3817">                                        DT_DEV_TRANSFORM_DIR_FORW_INCL, pts, 2);</a>
<a name="ln3818"> </a>
<a name="ln3819">      g-&gt;lastx = pts[0] - pts[2];</a>
<a name="ln3820">      g-&gt;lasty = pts[1] - pts[3];</a>
<a name="ln3821">      g-&gt;crop_cx = 0.5f * (p-&gt;cl + p-&gt;cr);</a>
<a name="ln3822">      g-&gt;crop_cy = 0.5f * (p-&gt;ct + p-&gt;cb);</a>
<a name="ln3823">      return TRUE;</a>
<a name="ln3824">    }</a>
<a name="ln3825">    else</a>
<a name="ln3826">      return FALSE;</a>
<a name="ln3827">  }</a>
<a name="ln3828"> </a>
<a name="ln3829">  // remember lines version at this stage so we can continuously monitor if the</a>
<a name="ln3830">  // lines have changed in-between</a>
<a name="ln3831">  g-&gt;selecting_lines_version = g-&gt;lines_version;</a>
<a name="ln3832"> </a>
<a name="ln3833">  // if shift button is pressed go into bounding mode (selecting or deselecting</a>
<a name="ln3834">  // in a rectangle area)</a>
<a name="ln3835">  if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln3836">  {</a>
<a name="ln3837">    g-&gt;lastx = pzx;</a>
<a name="ln3838">    g-&gt;lasty = pzy;</a>
<a name="ln3839"> </a>
<a name="ln3840">    g-&gt;isbounding = (which == 3) ? ASHIFT_BOUNDING_DESELECT : ASHIFT_BOUNDING_SELECT;</a>
<a name="ln3841">    dt_control_change_cursor(GDK_CROSS);</a>
<a name="ln3842"> </a>
<a name="ln3843">    return TRUE;</a>
<a name="ln3844">  }</a>
<a name="ln3845"> </a>
<a name="ln3846">  dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln3847">  const int closeup = dt_control_get_dev_closeup();</a>
<a name="ln3848">  const float min_scale = dt_dev_get_zoom_scale(self-&gt;dev, DT_ZOOM_FIT, 1&lt;&lt;closeup, 0);</a>
<a name="ln3849">  const float cur_scale = dt_dev_get_zoom_scale(self-&gt;dev, zoom, 1&lt;&lt;closeup, 0);</a>
<a name="ln3850"> </a>
<a name="ln3851">  // if we are zoomed out (no panning possible) and we have lines to display we take control</a>
<a name="ln3852">  const int take_control = (cur_scale == min_scale) &amp;&amp; (g-&gt;points_lines_count &gt; 0);</a>
<a name="ln3853"> </a>
<a name="ln3854">  g-&gt;near_delta = dt_conf_get_float(&quot;plugins/darkroom/ashift/near_delta&quot;);</a>
<a name="ln3855"> </a>
<a name="ln3856">  // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3857">  get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3858"> </a>
<a name="ln3859">  // iterate over all lines close to the pointer and change &quot;selected&quot; state.</a>
<a name="ln3860">  // left-click selects and right-click deselects the line</a>
<a name="ln3861">  for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3862">  {</a>
<a name="ln3863">    if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3864">      continue;</a>
<a name="ln3865"> </a>
<a name="ln3866">    if(which == 3)</a>
<a name="ln3867">      g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3868">    else</a>
<a name="ln3869">      g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3870"> </a>
<a name="ln3871">    handled = 1;</a>
<a name="ln3872">  }</a>
<a name="ln3873"> </a>
<a name="ln3874">  // we switch into sweeping mode either if we anyhow take control</a>
<a name="ln3875">  // or if cursor was close to a line when button was pressed. in other</a>
<a name="ln3876">  // cases we hand over the event (for image panning)</a>
<a name="ln3877">  if((take_control || handled) &amp;&amp; which == 3)</a>
<a name="ln3878">  {</a>
<a name="ln3879">    dt_control_change_cursor(GDK_PIRATE);</a>
<a name="ln3880">    g-&gt;isdeselecting = 1;</a>
<a name="ln3881">  }</a>
<a name="ln3882">  else if(take_control || handled)</a>
<a name="ln3883">  {</a>
<a name="ln3884">    dt_control_change_cursor(GDK_PLUS);</a>
<a name="ln3885">    g-&gt;isselecting = 1;</a>
<a name="ln3886">  }</a>
<a name="ln3887"> </a>
<a name="ln3888">  if(handled)</a>
<a name="ln3889">  {</a>
<a name="ln3890">    update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3891">    g-&gt;lines_version++;</a>
<a name="ln3892">    g-&gt;selecting_lines_version++;</a>
<a name="ln3893">  }</a>
<a name="ln3894"> </a>
<a name="ln3895">  return (take_control || handled);</a>
<a name="ln3896">}</a>
<a name="ln3897"> </a>
<a name="ln3898">int button_released(struct dt_iop_module_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln3899">{</a>
<a name="ln3900">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3901"> </a>
<a name="ln3902">  // stop adjust crop</a>
<a name="ln3903">  g-&gt;adjust_crop = FALSE;</a>
<a name="ln3904">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3905"> </a>
<a name="ln3906">  // finalize the isbounding mode</a>
<a name="ln3907">  // if user has released the shift button in-between -&gt; do nothing</a>
<a name="ln3908">  if(g-&gt;isbounding != ASHIFT_BOUNDING_OFF &amp;&amp; (state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln3909">  {</a>
<a name="ln3910">    int handled = 0;</a>
<a name="ln3911"> </a>
<a name="ln3912">    // we compute the rectangle selection</a>
<a name="ln3913">    float pzx, pzy;</a>
<a name="ln3914">    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3915"> </a>
<a name="ln3916">    pzx += 0.5f;</a>
<a name="ln3917">    pzy += 0.5f;</a>
<a name="ln3918"> </a>
<a name="ln3919">    const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3920">    const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3921"> </a>
<a name="ln3922">    if(wd &gt;= 1.0 &amp;&amp; ht &gt;= 1.0)</a>
<a name="ln3923">    {</a>
<a name="ln3924">      // mark lines inside the rectangle</a>
<a name="ln3925">      get_bounded_inside(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;lastx * wd,</a>
<a name="ln3926">                         g-&gt;lasty * ht, g-&gt;isbounding);</a>
<a name="ln3927"> </a>
<a name="ln3928">      // select or deselect lines within the rectangle according to isbounding state</a>
<a name="ln3929">      for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3930">      {</a>
<a name="ln3931">        if(g-&gt;points_idx[n].bounded == 0) continue;</a>
<a name="ln3932"> </a>
<a name="ln3933">        if(g-&gt;isbounding == ASHIFT_BOUNDING_DESELECT)</a>
<a name="ln3934">          g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln3935">        else</a>
<a name="ln3936">          g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln3937"> </a>
<a name="ln3938">        handled = 1;</a>
<a name="ln3939">      }</a>
<a name="ln3940"> </a>
<a name="ln3941">      if(handled)</a>
<a name="ln3942">      {</a>
<a name="ln3943">        update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln3944">        g-&gt;lines_version++;</a>
<a name="ln3945">        g-&gt;selecting_lines_version++;</a>
<a name="ln3946">      }</a>
<a name="ln3947"> </a>
<a name="ln3948">    dt_control_queue_redraw_center();</a>
<a name="ln3949">    }</a>
<a name="ln3950">  }</a>
<a name="ln3951"> </a>
<a name="ln3952">  // end of sweeping/isbounding mode</a>
<a name="ln3953">  dt_control_change_cursor(GDK_LEFT_PTR);</a>
<a name="ln3954">  g-&gt;isselecting = g-&gt;isdeselecting = 0;</a>
<a name="ln3955">  g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln3956">  g-&gt;near_delta = 0;</a>
<a name="ln3957">  g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln3958">  g-&gt;crop_cx = g-&gt;crop_cy = -1.0f;</a>
<a name="ln3959"> </a>
<a name="ln3960">  return 0;</a>
<a name="ln3961">}</a>
<a name="ln3962"> </a>
<a name="ln3963">int scrolled(struct dt_iop_module_t *self, double x, double y, int up, uint32_t state)</a>
<a name="ln3964">{</a>
<a name="ln3965">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln3966"> </a>
<a name="ln3967">  // do nothing if visibility of lines is switched off or no lines available</a>
<a name="ln3968">  if(g-&gt;lines_suppressed || g-&gt;lines == NULL)</a>
<a name="ln3969">    return FALSE;</a>
<a name="ln3970"> </a>
<a name="ln3971">  if(g-&gt;near_delta &gt; 0 &amp;&amp; (g-&gt;isdeselecting || g-&gt;isselecting))</a>
<a name="ln3972">  {</a>
<a name="ln3973">    int handled = 0;</a>
<a name="ln3974"> </a>
<a name="ln3975">    float pzx, pzy;</a>
<a name="ln3976">    dt_dev_get_pointer_zoom_pos(self-&gt;dev, x, y, &amp;pzx, &amp;pzy);</a>
<a name="ln3977">    pzx += 0.5f;</a>
<a name="ln3978">    pzy += 0.5f;</a>
<a name="ln3979"> </a>
<a name="ln3980">    const float wd = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln3981">    const float ht = self-&gt;dev-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln3982"> </a>
<a name="ln3983">    float near_delta = dt_conf_get_float(&quot;plugins/darkroom/ashift/near_delta&quot;);</a>
<a name="ln3984">    const float amount = up ? 0.8f : 1.25f;</a>
<a name="ln3985">    near_delta = MAX(4.0f, MIN(near_delta * amount, 100.0f));</a>
<a name="ln3986">    dt_conf_set_float(&quot;plugins/darkroom/ashift/near_delta&quot;, near_delta);</a>
<a name="ln3987">    g-&gt;near_delta = near_delta;</a>
<a name="ln3988"> </a>
<a name="ln3989">    // gather information about &quot;near&quot;-ness in g-&gt;points_idx</a>
<a name="ln3990">    get_near(g-&gt;points, g-&gt;points_idx, g-&gt;points_lines_count, pzx * wd, pzy * ht, g-&gt;near_delta);</a>
<a name="ln3991"> </a>
<a name="ln3992">    // iterate over all lines close to the pointer and change &quot;selected&quot; state.</a>
<a name="ln3993">    for(int n = 0; g-&gt;selecting_lines_version == g-&gt;lines_version &amp;&amp; n &lt; g-&gt;points_lines_count; n++)</a>
<a name="ln3994">    {</a>
<a name="ln3995">      if(g-&gt;points_idx[n].near == 0)</a>
<a name="ln3996">        continue;</a>
<a name="ln3997"> </a>
<a name="ln3998">      if(g-&gt;isdeselecting)</a>
<a name="ln3999">        g-&gt;lines[n].type &amp;= ~ASHIFT_LINE_SELECTED;</a>
<a name="ln4000">      else if(g-&gt;isselecting)</a>
<a name="ln4001">        g-&gt;lines[n].type |= ASHIFT_LINE_SELECTED;</a>
<a name="ln4002"> </a>
<a name="ln4003">      handled = 1;</a>
<a name="ln4004">    }</a>
<a name="ln4005"> </a>
<a name="ln4006">    if(handled)</a>
<a name="ln4007">    {</a>
<a name="ln4008">      update_lines_count(g-&gt;lines, g-&gt;lines_count, &amp;g-&gt;vertical_count, &amp;g-&gt;horizontal_count);</a>
<a name="ln4009">      g-&gt;lines_version++;</a>
<a name="ln4010">      g-&gt;selecting_lines_version++;</a>
<a name="ln4011">    }</a>
<a name="ln4012"> </a>
<a name="ln4013">    dt_control_queue_redraw_center();</a>
<a name="ln4014">    return TRUE;</a>
<a name="ln4015">  }</a>
<a name="ln4016"> </a>
<a name="ln4017">  return FALSE;</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020">static void rotation_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4021">{</a>
<a name="ln4022">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4023">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4024">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4025">  p-&gt;rotation = dt_bauhaus_slider_get(slider);</a>
<a name="ln4026">#ifdef ASHIFT_DEBUG</a>
<a name="ln4027">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4028">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4029">#endif</a>
<a name="ln4030">  do_crop(self, p);</a>
<a name="ln4031">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4032">}</a>
<a name="ln4033"> </a>
<a name="ln4034">static void lensshift_v_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4035">{</a>
<a name="ln4036">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4037">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4038">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4039">  p-&gt;lensshift_v = dt_bauhaus_slider_get(slider);</a>
<a name="ln4040">#ifdef ASHIFT_DEBUG</a>
<a name="ln4041">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4042">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4043">#endif</a>
<a name="ln4044">  do_crop(self, p);</a>
<a name="ln4045">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4046">}</a>
<a name="ln4047"> </a>
<a name="ln4048">static void lensshift_h_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4049">{</a>
<a name="ln4050">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4051">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4052">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4053">  p-&gt;lensshift_h = dt_bauhaus_slider_get(slider);</a>
<a name="ln4054">#ifdef ASHIFT_DEBUG</a>
<a name="ln4055">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4056">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4057">#endif</a>
<a name="ln4058">  do_crop(self, p);</a>
<a name="ln4059">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4060">}</a>
<a name="ln4061"> </a>
<a name="ln4062">static void shear_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4063">{</a>
<a name="ln4064">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4065">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4066">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4067">  p-&gt;shear = dt_bauhaus_slider_get(slider);</a>
<a name="ln4068">#ifdef ASHIFT_DEBUG</a>
<a name="ln4069">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4070">  model_probe(self, p, g-&gt;lastfit);</a>
<a name="ln4071">#endif</a>
<a name="ln4072">  do_crop(self, p);</a>
<a name="ln4073">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4074">}</a>
<a name="ln4075"> </a>
<a name="ln4076">static void guide_lines_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4077">{</a>
<a name="ln4078">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4079">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4080">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4081">  g-&gt;show_guides = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4082">  dt_iop_request_focus(self);</a>
<a name="ln4083">  dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4084">}</a>
<a name="ln4085"> </a>
<a name="ln4086">static void cropmode_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4087">{</a>
<a name="ln4088">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4089">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4090">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4091">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4092">  p-&gt;cropmode = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4093">  if(g-&gt;lines != NULL &amp;&amp; !g-&gt;lines_suppressed)</a>
<a name="ln4094">  {</a>
<a name="ln4095">    g-&gt;lines_suppressed = 1;</a>
<a name="ln4096">    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), g-&gt;lines_suppressed);</a>
<a name="ln4097">  }</a>
<a name="ln4098">  do_crop(self, p);</a>
<a name="ln4099">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4100">}</a>
<a name="ln4101"> </a>
<a name="ln4102">static void mode_callback(GtkWidget *widget, gpointer user_data)</a>
<a name="ln4103">{</a>
<a name="ln4104">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4105">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4106">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4107">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4108">  p-&gt;mode = dt_bauhaus_combobox_get(widget);</a>
<a name="ln4109"> </a>
<a name="ln4110">  switch(p-&gt;mode)</a>
<a name="ln4111">  {</a>
<a name="ln4112">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4113">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4114">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4115">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4116">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4117">      break;</a>
<a name="ln4118">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4119">    default:</a>
<a name="ln4120">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4121">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4122">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4123">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4124">      break;</a>
<a name="ln4125">  }</a>
<a name="ln4126"> </a>
<a name="ln4127">  do_crop(self, p);</a>
<a name="ln4128">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4129">}</a>
<a name="ln4130"> </a>
<a name="ln4131">static void f_length_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4132">{</a>
<a name="ln4133">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4134">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4135">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4136">  p-&gt;f_length = dt_bauhaus_slider_get(slider);</a>
<a name="ln4137">  do_crop(self, p);</a>
<a name="ln4138">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4139">}</a>
<a name="ln4140"> </a>
<a name="ln4141">static void crop_factor_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4142">{</a>
<a name="ln4143">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4144">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4145">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4146">  p-&gt;crop_factor = dt_bauhaus_slider_get(slider);</a>
<a name="ln4147">  do_crop(self, p);</a>
<a name="ln4148">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4149">}</a>
<a name="ln4150"> </a>
<a name="ln4151">static void orthocorr_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4152">{</a>
<a name="ln4153">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4154">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4155">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4156">  p-&gt;orthocorr = dt_bauhaus_slider_get(slider);</a>
<a name="ln4157">  do_crop(self, p);</a>
<a name="ln4158">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4159">}</a>
<a name="ln4160"> </a>
<a name="ln4161">static void aspect_callback(GtkWidget *slider, gpointer user_data)</a>
<a name="ln4162">{</a>
<a name="ln4163">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4164">  if(self-&gt;dt-&gt;gui-&gt;reset) return;</a>
<a name="ln4165">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4166">  p-&gt;aspect = dt_bauhaus_slider_get(slider);</a>
<a name="ln4167">  do_crop(self, p);</a>
<a name="ln4168">  dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4169">}</a>
<a name="ln4170"> </a>
<a name="ln4171">static int fit_v_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4172">{</a>
<a name="ln4173">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4174">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4175"> </a>
<a name="ln4176">  if(event-&gt;button == 1)</a>
<a name="ln4177">  {</a>
<a name="ln4178">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4179">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4180"> </a>
<a name="ln4181">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4182">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4183"> </a>
<a name="ln4184">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4185"> </a>
<a name="ln4186">    if(control)</a>
<a name="ln4187">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_ROTATION_VERTICAL_LINES;</a>
<a name="ln4188">    else if(shift)</a>
<a name="ln4189">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_VERTICALLY_NO_ROTATION;</a>
<a name="ln4190">    else</a>
<a name="ln4191">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_VERTICALLY;</a>
<a name="ln4192"> </a>
<a name="ln4193">    dt_iop_request_focus(self);</a>
<a name="ln4194">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4195"> </a>
<a name="ln4196">    if(self-&gt;enabled)</a>
<a name="ln4197">    {</a>
<a name="ln4198">      // module is enable -&gt; we process directly</a>
<a name="ln4199">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4200">      {</a>
<a name="ln4201">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4202">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4203">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4204">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4205">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4206">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4207">      }</a>
<a name="ln4208">    }</a>
<a name="ln4209">    else</a>
<a name="ln4210">    {</a>
<a name="ln4211">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4212">      // the preview image is ready</a>
<a name="ln4213">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4214">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4215">      p-&gt;toggle ^= 1;</a>
<a name="ln4216">    }</a>
<a name="ln4217"> </a>
<a name="ln4218">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4219">    return TRUE;</a>
<a name="ln4220">  }</a>
<a name="ln4221">  return FALSE;</a>
<a name="ln4222">}</a>
<a name="ln4223"> </a>
<a name="ln4224">static int fit_h_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4225">{</a>
<a name="ln4226">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4227">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4228"> </a>
<a name="ln4229">  if(event-&gt;button == 1)</a>
<a name="ln4230">  {</a>
<a name="ln4231">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4232">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4233"> </a>
<a name="ln4234">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4235">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4236"> </a>
<a name="ln4237">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4238"> </a>
<a name="ln4239">    if(control)</a>
<a name="ln4240">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_ROTATION_HORIZONTAL_LINES;</a>
<a name="ln4241">    else if(shift)</a>
<a name="ln4242">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_HORIZONTALLY_NO_ROTATION;</a>
<a name="ln4243">    else</a>
<a name="ln4244">      g-&gt;lastfit = fitaxis = ASHIFT_FIT_HORIZONTALLY;</a>
<a name="ln4245"> </a>
<a name="ln4246">    dt_iop_request_focus(self);</a>
<a name="ln4247">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4248"> </a>
<a name="ln4249">    if(self-&gt;enabled)</a>
<a name="ln4250">    {</a>
<a name="ln4251">      // module is enable -&gt; we process directly</a>
<a name="ln4252">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4253">      {</a>
<a name="ln4254">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4255">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4256">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4257">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4258">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4259">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4260">      }</a>
<a name="ln4261">    }</a>
<a name="ln4262">    else</a>
<a name="ln4263">    {</a>
<a name="ln4264">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4265">      // the preview image is ready</a>
<a name="ln4266">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4267">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4268">      p-&gt;toggle ^= 1;</a>
<a name="ln4269">    }</a>
<a name="ln4270"> </a>
<a name="ln4271">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4272">    return TRUE;</a>
<a name="ln4273">  }</a>
<a name="ln4274">  return FALSE;</a>
<a name="ln4275">}</a>
<a name="ln4276"> </a>
<a name="ln4277">static int fit_both_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4278">{</a>
<a name="ln4279">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4280">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4281"> </a>
<a name="ln4282">  if(event-&gt;button == 1)</a>
<a name="ln4283">  {</a>
<a name="ln4284">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4285">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4286"> </a>
<a name="ln4287">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4288">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4289"> </a>
<a name="ln4290">    dt_iop_ashift_fitaxis_t fitaxis = ASHIFT_FIT_NONE;</a>
<a name="ln4291"> </a>
<a name="ln4292">    if(control &amp;&amp; shift)</a>
<a name="ln4293">      fitaxis = ASHIFT_FIT_BOTH;</a>
<a name="ln4294">    else if(control)</a>
<a name="ln4295">      fitaxis = ASHIFT_FIT_ROTATION_BOTH_LINES;</a>
<a name="ln4296">    else if(shift)</a>
<a name="ln4297">      fitaxis = ASHIFT_FIT_BOTH_NO_ROTATION;</a>
<a name="ln4298">    else</a>
<a name="ln4299">      fitaxis = ASHIFT_FIT_BOTH_SHEAR;</a>
<a name="ln4300"> </a>
<a name="ln4301">    dt_iop_request_focus(self);</a>
<a name="ln4302">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4303"> </a>
<a name="ln4304">    if(self-&gt;enabled)</a>
<a name="ln4305">    {</a>
<a name="ln4306">      // module is enable -&gt; we process directly</a>
<a name="ln4307">      if(do_fit(self, p, fitaxis))</a>
<a name="ln4308">      {</a>
<a name="ln4309">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4310">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4311">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4312">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4313">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4314">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4315">      }</a>
<a name="ln4316">    }</a>
<a name="ln4317">    else</a>
<a name="ln4318">    {</a>
<a name="ln4319">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4320">      // the preview image is ready</a>
<a name="ln4321">      g-&gt;jobcode = ASHIFT_JOBCODE_FIT;</a>
<a name="ln4322">      g-&gt;jobparams = g-&gt;lastfit = fitaxis;</a>
<a name="ln4323">      p-&gt;toggle ^= 1;</a>
<a name="ln4324">    }</a>
<a name="ln4325"> </a>
<a name="ln4326">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4327">    return TRUE;</a>
<a name="ln4328">  }</a>
<a name="ln4329">  return FALSE;</a>
<a name="ln4330">}</a>
<a name="ln4331"> </a>
<a name="ln4332">static int structure_button_clicked(GtkWidget *widget, GdkEventButton *event, gpointer user_data)</a>
<a name="ln4333">{</a>
<a name="ln4334">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4335">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4336"> </a>
<a name="ln4337">  if(event-&gt;button == 1)</a>
<a name="ln4338">  {</a>
<a name="ln4339">    dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4340">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4341"> </a>
<a name="ln4342">    const int control = (event-&gt;state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK;</a>
<a name="ln4343">    const int shift = (event-&gt;state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK;</a>
<a name="ln4344"> </a>
<a name="ln4345">    dt_iop_ashift_enhance_t enhance;</a>
<a name="ln4346"> </a>
<a name="ln4347">    if(control &amp;&amp; shift)</a>
<a name="ln4348">      enhance = ASHIFT_ENHANCE_EDGES | ASHIFT_ENHANCE_DETAIL;</a>
<a name="ln4349">    else if(shift)</a>
<a name="ln4350">      enhance = ASHIFT_ENHANCE_DETAIL;</a>
<a name="ln4351">    else if(control)</a>
<a name="ln4352">      enhance = ASHIFT_ENHANCE_EDGES;</a>
<a name="ln4353">    else</a>
<a name="ln4354">      enhance = ASHIFT_ENHANCE_NONE;</a>
<a name="ln4355"> </a>
<a name="ln4356">    dt_iop_request_focus(self);</a>
<a name="ln4357">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4358"> </a>
<a name="ln4359">    if(self-&gt;enabled)</a>
<a name="ln4360">    {</a>
<a name="ln4361">      // module is enabled -&gt; process directly</a>
<a name="ln4362">      (void)do_get_structure(self, p, enhance);</a>
<a name="ln4363">    }</a>
<a name="ln4364">    else</a>
<a name="ln4365">    {</a>
<a name="ln4366">      // module is not enabled -&gt; invoke it and queue the job to be processed once</a>
<a name="ln4367">      // the preview image is ready</a>
<a name="ln4368">      g-&gt;jobcode = ASHIFT_JOBCODE_GET_STRUCTURE;</a>
<a name="ln4369">      g-&gt;jobparams = enhance;</a>
<a name="ln4370">      p-&gt;toggle ^= 1;</a>
<a name="ln4371">    }</a>
<a name="ln4372"> </a>
<a name="ln4373">    dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4374">    return TRUE;</a>
<a name="ln4375">  }</a>
<a name="ln4376">  return FALSE;</a>
<a name="ln4377">}</a>
<a name="ln4378"> </a>
<a name="ln4379">static void clean_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln4380">{</a>
<a name="ln4381">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4382">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4383">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4384">  (void)do_clean_structure(self, p);</a>
<a name="ln4385">  dt_iop_request_focus(self);</a>
<a name="ln4386">  dt_control_queue_redraw_center();</a>
<a name="ln4387">}</a>
<a name="ln4388"> </a>
<a name="ln4389">static void eye_button_toggled(GtkToggleButton *togglebutton, gpointer user_data)</a>
<a name="ln4390">{</a>
<a name="ln4391">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4392">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4393">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4394">  if(g-&gt;lines == NULL)</a>
<a name="ln4395">  {</a>
<a name="ln4396">    g-&gt;lines_suppressed = 0;</a>
<a name="ln4397">    gtk_toggle_button_set_active(togglebutton, 0);</a>
<a name="ln4398">  }</a>
<a name="ln4399">  else</a>
<a name="ln4400">  {</a>
<a name="ln4401">    g-&gt;lines_suppressed = gtk_toggle_button_get_active(togglebutton);</a>
<a name="ln4402">  }</a>
<a name="ln4403">  dt_iop_request_focus(self);</a>
<a name="ln4404">  dt_control_queue_redraw_center();</a>
<a name="ln4405">}</a>
<a name="ln4406"> </a>
<a name="ln4407">// routine that is called after preview image has been processed. we use it</a>
<a name="ln4408">// to perform structure collection or fitting in case those have been triggered while</a>
<a name="ln4409">// the module had not yet been enabled</a>
<a name="ln4410">static void process_after_preview_callback(gpointer instance, gpointer user_data)</a>
<a name="ln4411">{</a>
<a name="ln4412">  dt_iop_module_t *self = (dt_iop_module_t *)user_data;</a>
<a name="ln4413">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4414">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4415"> </a>
<a name="ln4416">  dt_iop_ashift_jobcode_t jobcode = g-&gt;jobcode;</a>
<a name="ln4417">  int jobparams = g-&gt;jobparams;</a>
<a name="ln4418"> </a>
<a name="ln4419">  // purge</a>
<a name="ln4420">  g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4421">  g-&gt;jobparams = 0;</a>
<a name="ln4422"> </a>
<a name="ln4423">  if(darktable.gui-&gt;reset) return;</a>
<a name="ln4424"> </a>
<a name="ln4425">  switch(jobcode)</a>
<a name="ln4426">  {</a>
<a name="ln4427">    case ASHIFT_JOBCODE_GET_STRUCTURE:</a>
<a name="ln4428">      (void)do_get_structure(self, p, (dt_iop_ashift_enhance_t)jobparams);</a>
<a name="ln4429">      break;</a>
<a name="ln4430"> </a>
<a name="ln4431">    case ASHIFT_JOBCODE_FIT:</a>
<a name="ln4432">      if(do_fit(self, p, (dt_iop_ashift_fitaxis_t)jobparams))</a>
<a name="ln4433">      {</a>
<a name="ln4434">        darktable.gui-&gt;reset = 1;</a>
<a name="ln4435">        dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4436">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4437">        dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4438">        dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4439">        darktable.gui-&gt;reset = 0;</a>
<a name="ln4440">      }</a>
<a name="ln4441">      dt_dev_add_history_item(darktable.develop, self, TRUE);</a>
<a name="ln4442">      break;</a>
<a name="ln4443"> </a>
<a name="ln4444">    case ASHIFT_JOBCODE_NONE:</a>
<a name="ln4445">    default:</a>
<a name="ln4446">      break;</a>
<a name="ln4447">  }</a>
<a name="ln4448"> </a>
<a name="ln4449">  dt_control_queue_redraw_center();</a>
<a name="ln4450">}</a>
<a name="ln4451"> </a>
<a name="ln4452">void commit_params(struct dt_iop_module_t *self, dt_iop_params_t *p1, dt_dev_pixelpipe_t *pipe,</a>
<a name="ln4453">                   dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4454">{</a>
<a name="ln4455">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)p1;</a>
<a name="ln4456">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)piece-&gt;data;</a>
<a name="ln4457"> </a>
<a name="ln4458">  d-&gt;rotation = p-&gt;rotation;</a>
<a name="ln4459">  d-&gt;lensshift_v = p-&gt;lensshift_v;</a>
<a name="ln4460">  d-&gt;lensshift_h = p-&gt;lensshift_h;</a>
<a name="ln4461">  d-&gt;shear = p-&gt;shear;</a>
<a name="ln4462">  d-&gt;f_length_kb = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? DEFAULT_F_LENGTH : p-&gt;f_length * p-&gt;crop_factor;</a>
<a name="ln4463">  d-&gt;orthocorr = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 0.0f : p-&gt;orthocorr;</a>
<a name="ln4464">  d-&gt;aspect = (p-&gt;mode == ASHIFT_MODE_GENERIC) ? 1.0f : p-&gt;aspect;</a>
<a name="ln4465"> </a>
<a name="ln4466">  if(gui_has_focus(self))</a>
<a name="ln4467">  {</a>
<a name="ln4468">    // if gui has focus we want to see the full uncropped image</a>
<a name="ln4469">    d-&gt;cl = 0.0f;</a>
<a name="ln4470">    d-&gt;cr = 1.0f;</a>
<a name="ln4471">    d-&gt;ct = 0.0f;</a>
<a name="ln4472">    d-&gt;cb = 1.0f;</a>
<a name="ln4473">  }</a>
<a name="ln4474">  else</a>
<a name="ln4475">  {</a>
<a name="ln4476">    d-&gt;cl = p-&gt;cl;</a>
<a name="ln4477">    d-&gt;cr = p-&gt;cr;</a>
<a name="ln4478">    d-&gt;ct = p-&gt;ct;</a>
<a name="ln4479">    d-&gt;cb = p-&gt;cb;</a>
<a name="ln4480">  }</a>
<a name="ln4481">}</a>
<a name="ln4482"> </a>
<a name="ln4483">void init_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4484">{</a>
<a name="ln4485">  dt_iop_ashift_data_t *d = (dt_iop_ashift_data_t *)calloc(1, sizeof(dt_iop_ashift_data_t));</a>
<a name="ln4486">  piece-&gt;data = (void *)d;</a>
<a name="ln4487">  self-&gt;commit_params(self, self-&gt;default_params, pipe, piece);</a>
<a name="ln4488">}</a>
<a name="ln4489"> </a>
<a name="ln4490">void cleanup_pipe(struct dt_iop_module_t *self, dt_dev_pixelpipe_t *pipe, dt_dev_pixelpipe_iop_t *piece)</a>
<a name="ln4491">{</a>
<a name="ln4492">  free(piece-&gt;data);</a>
<a name="ln4493">  piece-&gt;data = NULL;</a>
<a name="ln4494">}</a>
<a name="ln4495"> </a>
<a name="ln4496">void gui_update(struct dt_iop_module_t *self)</a>
<a name="ln4497">{</a>
<a name="ln4498">  dt_iop_module_t *module = (dt_iop_module_t *)self;</a>
<a name="ln4499">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4500">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)module-&gt;params;</a>
<a name="ln4501">  dt_bauhaus_slider_set_soft(g-&gt;rotation, p-&gt;rotation);</a>
<a name="ln4502">  dt_bauhaus_slider_set_soft(g-&gt;lensshift_v, p-&gt;lensshift_v);</a>
<a name="ln4503">  dt_bauhaus_slider_set_soft(g-&gt;lensshift_h, p-&gt;lensshift_h);</a>
<a name="ln4504">  dt_bauhaus_slider_set_soft(g-&gt;shear, p-&gt;shear);</a>
<a name="ln4505">  dt_bauhaus_slider_set_soft(g-&gt;f_length, p-&gt;f_length);</a>
<a name="ln4506">  dt_bauhaus_slider_set_soft(g-&gt;crop_factor, p-&gt;crop_factor);</a>
<a name="ln4507">  dt_bauhaus_slider_set(g-&gt;orthocorr, p-&gt;orthocorr);</a>
<a name="ln4508">  dt_bauhaus_slider_set(g-&gt;aspect, p-&gt;aspect);</a>
<a name="ln4509">  dt_bauhaus_combobox_set(g-&gt;mode, p-&gt;mode);</a>
<a name="ln4510">  dt_bauhaus_combobox_set(g-&gt;guide_lines, g-&gt;show_guides);</a>
<a name="ln4511">  dt_bauhaus_combobox_set(g-&gt;cropmode, p-&gt;cropmode);</a>
<a name="ln4512">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), 0);</a>
<a name="ln4513"> </a>
<a name="ln4514">  switch(p-&gt;mode)</a>
<a name="ln4515">  {</a>
<a name="ln4516">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4517">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4518">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4519">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4520">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4521">      break;</a>
<a name="ln4522">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4523">    default:</a>
<a name="ln4524">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4525">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4526">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4527">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4528">      break;</a>
<a name="ln4529">  }</a>
<a name="ln4530">}</a>
<a name="ln4531"> </a>
<a name="ln4532">void init(dt_iop_module_t *module)</a>
<a name="ln4533">{</a>
<a name="ln4534">  module-&gt;params = calloc(1, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4535">  module-&gt;default_params = calloc(1, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4536">  module-&gt;default_enabled = 0;</a>
<a name="ln4537">  module-&gt;params_size = sizeof(dt_iop_ashift_params_t);</a>
<a name="ln4538">  module-&gt;gui_data = NULL;</a>
<a name="ln4539">  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){ 0.0f, 0.0f, 0.0f, 0.0f, DEFAULT_F_LENGTH, 1.0f, 100.0f, 1.0f, ASHIFT_MODE_GENERIC, 0,</a>
<a name="ln4540">                                                         ASHIFT_CROP_OFF, 0.0f, 1.0f, 0.0f, 1.0f };</a>
<a name="ln4541">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4542">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4543">}</a>
<a name="ln4544"> </a>
<a name="ln4545">void reload_defaults(dt_iop_module_t *module)</a>
<a name="ln4546">{</a>
<a name="ln4547">  // our module is disabled by default</a>
<a name="ln4548">  module-&gt;default_enabled = 0;</a>
<a name="ln4549"> </a>
<a name="ln4550">  int isflipped = 0;</a>
<a name="ln4551">  float f_length = DEFAULT_F_LENGTH;</a>
<a name="ln4552">  float crop_factor = 1.0f;</a>
<a name="ln4553"> </a>
<a name="ln4554">  // try to get information on orientation, focal length and crop factor from image data</a>
<a name="ln4555">  if(module-&gt;dev)</a>
<a name="ln4556">  {</a>
<a name="ln4557">    const dt_image_t *img = &amp;module-&gt;dev-&gt;image_storage;</a>
<a name="ln4558">    // orientation only needed as a-priori information to correctly label some sliders</a>
<a name="ln4559">    // before pixelpipe has been set up. later we will get a definite result by</a>
<a name="ln4560">    // assessing the pixelpipe</a>
<a name="ln4561">    isflipped = (img-&gt;orientation == ORIENTATION_ROTATE_CCW_90_DEG</a>
<a name="ln4562">                 || img-&gt;orientation == ORIENTATION_ROTATE_CW_90_DEG)</a>
<a name="ln4563">                    ? 1</a>
<a name="ln4564">                    : 0;</a>
<a name="ln4565"> </a>
<a name="ln4566">    // focal length should be available in exif data if lens is electronically coupled to the camera</a>
<a name="ln4567">    f_length = isfinite(img-&gt;exif_focal_length) &amp;&amp; img-&gt;exif_focal_length &gt; 0.0f ? img-&gt;exif_focal_length : f_length;</a>
<a name="ln4568">    // crop factor of the camera is often not available and user will need to set it manually in the gui</a>
<a name="ln4569">    crop_factor = isfinite(img-&gt;exif_crop) &amp;&amp; img-&gt;exif_crop &gt; 0.0f ? img-&gt;exif_crop : crop_factor;</a>
<a name="ln4570">  }</a>
<a name="ln4571"> </a>
<a name="ln4572">  // init defaults:</a>
<a name="ln4573">  dt_iop_ashift_params_t tmp = (dt_iop_ashift_params_t){ 0.0f, 0.0f, 0.0f, 0.0f, f_length, crop_factor, 100.0f, 1.0f, ASHIFT_MODE_GENERIC, 0,</a>
<a name="ln4574">                                                         ASHIFT_CROP_OFF, 0.0f, 1.0f, 0.0f, 1.0f };</a>
<a name="ln4575">  memcpy(module-&gt;params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4576">  memcpy(module-&gt;default_params, &amp;tmp, sizeof(dt_iop_ashift_params_t));</a>
<a name="ln4577"> </a>
<a name="ln4578">  // reset gui elements</a>
<a name="ln4579">  if(module-&gt;gui_data)</a>
<a name="ln4580">  {</a>
<a name="ln4581">    dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)module-&gt;gui_data;</a>
<a name="ln4582"> </a>
<a name="ln4583">    char string_v[256];</a>
<a name="ln4584">    char string_h[256];</a>
<a name="ln4585"> </a>
<a name="ln4586">    snprintf(string_v, sizeof(string_v), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;horizontal&quot;) : _(&quot;vertical&quot;));</a>
<a name="ln4587">    snprintf(string_h, sizeof(string_h), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;vertical&quot;) : _(&quot;horizontal&quot;));</a>
<a name="ln4588"> </a>
<a name="ln4589">    dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, string_v);</a>
<a name="ln4590">    dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, string_h);</a>
<a name="ln4591"> </a>
<a name="ln4592">    dt_bauhaus_slider_set_default(g-&gt;f_length, tmp.f_length);</a>
<a name="ln4593">    dt_bauhaus_slider_set_default(g-&gt;crop_factor, tmp.crop_factor);</a>
<a name="ln4594"> </a>
<a name="ln4595">    dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4596">    free(g-&gt;buf);</a>
<a name="ln4597">    g-&gt;buf = NULL;</a>
<a name="ln4598">    g-&gt;buf_width = 0;</a>
<a name="ln4599">    g-&gt;buf_height = 0;</a>
<a name="ln4600">    g-&gt;buf_x_off = 0;</a>
<a name="ln4601">    g-&gt;buf_y_off = 0;</a>
<a name="ln4602">    g-&gt;buf_scale = 1.0f;</a>
<a name="ln4603">    g-&gt;buf_hash = 0;</a>
<a name="ln4604">    g-&gt;isflipped = -1;</a>
<a name="ln4605">    g-&gt;lastfit = ASHIFT_FIT_NONE;</a>
<a name="ln4606">    dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4607"> </a>
<a name="ln4608">    g-&gt;fitting = 0;</a>
<a name="ln4609">    free(g-&gt;lines);</a>
<a name="ln4610">    g-&gt;lines = NULL;</a>
<a name="ln4611">    g-&gt;lines_count =0;</a>
<a name="ln4612">    g-&gt;horizontal_count = 0;</a>
<a name="ln4613">    g-&gt;vertical_count = 0;</a>
<a name="ln4614">    g-&gt;grid_hash = 0;</a>
<a name="ln4615">    g-&gt;lines_hash = 0;</a>
<a name="ln4616">    g-&gt;rotation_range = ROTATION_RANGE_SOFT;</a>
<a name="ln4617">    g-&gt;lensshift_v_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4618">    g-&gt;lensshift_h_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4619">    g-&gt;shear_range = SHEAR_RANGE_SOFT;</a>
<a name="ln4620">    g-&gt;lines_suppressed = 0;</a>
<a name="ln4621">    g-&gt;lines_version = 0;</a>
<a name="ln4622">    g-&gt;show_guides = 0;</a>
<a name="ln4623">    g-&gt;isselecting = 0;</a>
<a name="ln4624">    g-&gt;isdeselecting = 0;</a>
<a name="ln4625">    g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln4626">    g-&gt;near_delta = 0;</a>
<a name="ln4627">    g-&gt;selecting_lines_version = 0;</a>
<a name="ln4628"> </a>
<a name="ln4629">    free(g-&gt;points);</a>
<a name="ln4630">    g-&gt;points = NULL;</a>
<a name="ln4631">    free(g-&gt;points_idx);</a>
<a name="ln4632">    g-&gt;points_idx = NULL;</a>
<a name="ln4633">    g-&gt;points_lines_count = 0;</a>
<a name="ln4634">    g-&gt;points_version = 0;</a>
<a name="ln4635"> </a>
<a name="ln4636">    g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4637">    g-&gt;jobparams = 0;</a>
<a name="ln4638">    g-&gt;adjust_crop = FALSE;</a>
<a name="ln4639">    g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln4640">    g-&gt;crop_cx = g-&gt;crop_cy = 1.0f;</a>
<a name="ln4641">  }</a>
<a name="ln4642">}</a>
<a name="ln4643"> </a>
<a name="ln4644"> </a>
<a name="ln4645">void init_global(dt_iop_module_so_t *module)</a>
<a name="ln4646">{</a>
<a name="ln4647">  dt_iop_ashift_global_data_t *gd</a>
<a name="ln4648">      = (dt_iop_ashift_global_data_t *)malloc(sizeof(dt_iop_ashift_global_data_t));</a>
<a name="ln4649">  module-&gt;data = gd;</a>
<a name="ln4650"> </a>
<a name="ln4651">  const int program = 2; // basic.cl, from programs.conf</a>
<a name="ln4652">  gd-&gt;kernel_ashift_bilinear = dt_opencl_create_kernel(program, &quot;ashift_bilinear&quot;);</a>
<a name="ln4653">  gd-&gt;kernel_ashift_bicubic = dt_opencl_create_kernel(program, &quot;ashift_bicubic&quot;);</a>
<a name="ln4654">  gd-&gt;kernel_ashift_lanczos2 = dt_opencl_create_kernel(program, &quot;ashift_lanczos2&quot;);</a>
<a name="ln4655">  gd-&gt;kernel_ashift_lanczos3 = dt_opencl_create_kernel(program, &quot;ashift_lanczos3&quot;);</a>
<a name="ln4656">}</a>
<a name="ln4657"> </a>
<a name="ln4658">void cleanup(dt_iop_module_t *module)</a>
<a name="ln4659">{</a>
<a name="ln4660">  free(module-&gt;params);</a>
<a name="ln4661">  module-&gt;params = NULL;</a>
<a name="ln4662">}</a>
<a name="ln4663"> </a>
<a name="ln4664">void cleanup_global(dt_iop_module_so_t *module)</a>
<a name="ln4665">{</a>
<a name="ln4666">  dt_iop_ashift_global_data_t *gd = (dt_iop_ashift_global_data_t *)module-&gt;data;</a>
<a name="ln4667">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_bilinear);</a>
<a name="ln4668">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_bicubic);</a>
<a name="ln4669">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_lanczos2);</a>
<a name="ln4670">  dt_opencl_free_kernel(gd-&gt;kernel_ashift_lanczos3);</a>
<a name="ln4671">  free(module-&gt;data);</a>
<a name="ln4672">  module-&gt;data = NULL;</a>
<a name="ln4673">}</a>
<a name="ln4674"> </a>
<a name="ln4675">// adjust labels of lens shift parameters according to flip status of image</a>
<a name="ln4676">static gboolean draw(GtkWidget *widget, cairo_t *cr, dt_iop_module_t *self)</a>
<a name="ln4677">{</a>
<a name="ln4678">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4679">  if(darktable.gui-&gt;reset) return FALSE;</a>
<a name="ln4680"> </a>
<a name="ln4681">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4682">  const int isflipped = g-&gt;isflipped;</a>
<a name="ln4683">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4684"> </a>
<a name="ln4685">  if(isflipped == -1) return FALSE;</a>
<a name="ln4686"> </a>
<a name="ln4687">  char string_v[256];</a>
<a name="ln4688">  char string_h[256];</a>
<a name="ln4689"> </a>
<a name="ln4690">  snprintf(string_v, sizeof(string_v), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;horizontal&quot;) : _(&quot;vertical&quot;));</a>
<a name="ln4691">  snprintf(string_h, sizeof(string_h), _(&quot;lens shift (%s)&quot;), isflipped ? _(&quot;vertical&quot;) : _(&quot;horizontal&quot;));</a>
<a name="ln4692"> </a>
<a name="ln4693">  darktable.gui-&gt;reset = 1;</a>
<a name="ln4694">  dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, string_v);</a>
<a name="ln4695">  dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, string_h);</a>
<a name="ln4696">  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g-&gt;eye), g-&gt;lines_suppressed);</a>
<a name="ln4697">  darktable.gui-&gt;reset = 0;</a>
<a name="ln4698"> </a>
<a name="ln4699">  return FALSE;</a>
<a name="ln4700">}</a>
<a name="ln4701"> </a>
<a name="ln4702">void gui_focus(struct dt_iop_module_t *self, gboolean in)</a>
<a name="ln4703">{</a>
<a name="ln4704">  if(self-&gt;enabled)</a>
<a name="ln4705">    dt_dev_reprocess_all(self-&gt;dev);</a>
<a name="ln4706">}</a>
<a name="ln4707"> </a>
<a name="ln4708">static float log10_callback(GtkWidget *self, float inval, dt_bauhaus_callback_t dir)</a>
<a name="ln4709">{</a>
<a name="ln4710">  float outval;</a>
<a name="ln4711">  switch(dir)</a>
<a name="ln4712">  {</a>
<a name="ln4713">    case DT_BAUHAUS_SET:</a>
<a name="ln4714">      outval = log10(fmax(inval, 1e-15f));</a>
<a name="ln4715">      break;</a>
<a name="ln4716">    case DT_BAUHAUS_GET:</a>
<a name="ln4717">      outval = exp(M_LN10 * inval);</a>
<a name="ln4718">      break;</a>
<a name="ln4719">    default:</a>
<a name="ln4720">      outval = inval;</a>
<a name="ln4721">  }</a>
<a name="ln4722">  return outval;</a>
<a name="ln4723">}</a>
<a name="ln4724"> </a>
<a name="ln4725">static float log2_callback(GtkWidget *self, float inval, dt_bauhaus_callback_t dir)</a>
<a name="ln4726">{</a>
<a name="ln4727">  float outval;</a>
<a name="ln4728">  switch(dir)</a>
<a name="ln4729">  {</a>
<a name="ln4730">    case DT_BAUHAUS_SET:</a>
<a name="ln4731">      outval = log(fmax(inval, 1e-15f)) / M_LN2;</a>
<a name="ln4732">      break;</a>
<a name="ln4733">    case DT_BAUHAUS_GET:</a>
<a name="ln4734">      outval = exp(M_LN2 * inval);</a>
<a name="ln4735">      break;</a>
<a name="ln4736">    default:</a>
<a name="ln4737">      outval = inval;</a>
<a name="ln4738">  }</a>
<a name="ln4739">  return outval;</a>
<a name="ln4740">}</a>
<a name="ln4741"> </a>
<a name="ln4742">void gui_init(struct dt_iop_module_t *self)</a>
<a name="ln4743">{</a>
<a name="ln4744">  self-&gt;gui_data = malloc(sizeof(dt_iop_ashift_gui_data_t));</a>
<a name="ln4745">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4746">  dt_iop_ashift_params_t *p = (dt_iop_ashift_params_t *)self-&gt;params;</a>
<a name="ln4747"> </a>
<a name="ln4748">  dt_pthread_mutex_init(&amp;g-&gt;lock, NULL);</a>
<a name="ln4749">  dt_pthread_mutex_lock(&amp;g-&gt;lock);</a>
<a name="ln4750">  g-&gt;buf = NULL;</a>
<a name="ln4751">  g-&gt;buf_width = 0;</a>
<a name="ln4752">  g-&gt;buf_height = 0;</a>
<a name="ln4753">  g-&gt;buf_x_off = 0;</a>
<a name="ln4754">  g-&gt;buf_y_off = 0;</a>
<a name="ln4755">  g-&gt;buf_scale = 1.0f;</a>
<a name="ln4756">  g-&gt;buf_hash = 0;</a>
<a name="ln4757">  g-&gt;isflipped = -1;</a>
<a name="ln4758">  g-&gt;lastfit = ASHIFT_FIT_NONE;</a>
<a name="ln4759">  dt_pthread_mutex_unlock(&amp;g-&gt;lock);</a>
<a name="ln4760"> </a>
<a name="ln4761">  g-&gt;fitting = 0;</a>
<a name="ln4762">  g-&gt;lines = NULL;</a>
<a name="ln4763">  g-&gt;lines_count = 0;</a>
<a name="ln4764">  g-&gt;vertical_count = 0;</a>
<a name="ln4765">  g-&gt;horizontal_count = 0;</a>
<a name="ln4766">  g-&gt;lines_version = 0;</a>
<a name="ln4767">  g-&gt;lines_suppressed = 0;</a>
<a name="ln4768">  g-&gt;points = NULL;</a>
<a name="ln4769">  g-&gt;points_idx = NULL;</a>
<a name="ln4770">  g-&gt;points_lines_count = 0;</a>
<a name="ln4771">  g-&gt;points_version = 0;</a>
<a name="ln4772">  g-&gt;grid_hash = 0;</a>
<a name="ln4773">  g-&gt;lines_hash = 0;</a>
<a name="ln4774">  g-&gt;rotation_range = ROTATION_RANGE_SOFT;</a>
<a name="ln4775">  g-&gt;lensshift_v_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4776">  g-&gt;lensshift_h_range = LENSSHIFT_RANGE_SOFT;</a>
<a name="ln4777">  g-&gt;shear_range = SHEAR_RANGE_SOFT;</a>
<a name="ln4778">  g-&gt;show_guides = 0;</a>
<a name="ln4779">  g-&gt;isselecting = 0;</a>
<a name="ln4780">  g-&gt;isdeselecting = 0;</a>
<a name="ln4781">  g-&gt;isbounding = ASHIFT_BOUNDING_OFF;</a>
<a name="ln4782">  g-&gt;near_delta = 0;</a>
<a name="ln4783">  g-&gt;selecting_lines_version = 0;</a>
<a name="ln4784"> </a>
<a name="ln4785">  g-&gt;jobcode = ASHIFT_JOBCODE_NONE;</a>
<a name="ln4786">  g-&gt;jobparams = 0;</a>
<a name="ln4787">  g-&gt;adjust_crop = FALSE;</a>
<a name="ln4788">  g-&gt;lastx = g-&gt;lasty = -1.0f;</a>
<a name="ln4789">  g-&gt;crop_cx = g-&gt;crop_cy = 1.0f;</a>
<a name="ln4790"> </a>
<a name="ln4791">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, DT_BAUHAUS_SPACE);</a>
<a name="ln4792">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;op));</a>
<a name="ln4793"> </a>
<a name="ln4794">  g-&gt;rotation = dt_bauhaus_slider_new_with_range(self, -ROTATION_RANGE, ROTATION_RANGE, 0.01*ROTATION_RANGE, p-&gt;rotation, 2);</a>
<a name="ln4795">  dt_bauhaus_widget_set_label(g-&gt;rotation, NULL, _(&quot;rotation&quot;));</a>
<a name="ln4796">  dt_bauhaus_slider_set_format(g-&gt;rotation, &quot;%.2f&quot;);</a>
<a name="ln4797">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;rotation, -ROTATION_RANGE_SOFT, ROTATION_RANGE_SOFT);</a>
<a name="ln4798">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;rotation, TRUE, TRUE, 0);</a>
<a name="ln4799"> </a>
<a name="ln4800">  g-&gt;lensshift_v = dt_bauhaus_slider_new_with_range(self, -LENSSHIFT_RANGE, LENSSHIFT_RANGE, 0.01*LENSSHIFT_RANGE, p-&gt;lensshift_v, 3);</a>
<a name="ln4801">  dt_bauhaus_widget_set_label(g-&gt;lensshift_v, NULL, _(&quot;lens shift (vertical)&quot;));</a>
<a name="ln4802">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;lensshift_v, -LENSSHIFT_RANGE_SOFT, LENSSHIFT_RANGE_SOFT);</a>
<a name="ln4803">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;lensshift_v, TRUE, TRUE, 0);</a>
<a name="ln4804"> </a>
<a name="ln4805">  g-&gt;lensshift_h = dt_bauhaus_slider_new_with_range(self, -LENSSHIFT_RANGE, LENSSHIFT_RANGE, 0.01*LENSSHIFT_RANGE, p-&gt;lensshift_h, 3);</a>
<a name="ln4806">  dt_bauhaus_widget_set_label(g-&gt;lensshift_h, NULL, _(&quot;lens shift (horizontal)&quot;));</a>
<a name="ln4807">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;lensshift_h, -LENSSHIFT_RANGE_SOFT, LENSSHIFT_RANGE_SOFT);</a>
<a name="ln4808">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;lensshift_h, TRUE, TRUE, 0);</a>
<a name="ln4809"> </a>
<a name="ln4810">  g-&gt;shear = dt_bauhaus_slider_new_with_range(self, -SHEAR_RANGE, SHEAR_RANGE, 0.01*SHEAR_RANGE, p-&gt;shear, 3);</a>
<a name="ln4811">  dt_bauhaus_widget_set_label(g-&gt;shear, NULL, _(&quot;shear&quot;));</a>
<a name="ln4812">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;shear, -SHEAR_RANGE_SOFT, SHEAR_RANGE_SOFT);</a>
<a name="ln4813">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;shear, TRUE, TRUE, 0);</a>
<a name="ln4814"> </a>
<a name="ln4815">  g-&gt;guide_lines = dt_bauhaus_combobox_new(self);</a>
<a name="ln4816">  dt_bauhaus_widget_set_label(g-&gt;guide_lines, NULL, _(&quot;guides&quot;));</a>
<a name="ln4817">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;off&quot;));</a>
<a name="ln4818">  dt_bauhaus_combobox_add(g-&gt;guide_lines, _(&quot;on&quot;));</a>
<a name="ln4819">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;guide_lines, TRUE, TRUE, 0);</a>
<a name="ln4820"> </a>
<a name="ln4821">  g-&gt;cropmode = dt_bauhaus_combobox_new(self);</a>
<a name="ln4822">  dt_bauhaus_widget_set_label(g-&gt;cropmode, NULL, _(&quot;automatic cropping&quot;));</a>
<a name="ln4823">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;off&quot;));</a>
<a name="ln4824">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;largest area&quot;));</a>
<a name="ln4825">  dt_bauhaus_combobox_add(g-&gt;cropmode, _(&quot;original format&quot;));</a>
<a name="ln4826">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;cropmode, TRUE, TRUE, 0);</a>
<a name="ln4827"> </a>
<a name="ln4828">  g-&gt;mode = dt_bauhaus_combobox_new(self);</a>
<a name="ln4829">  dt_bauhaus_widget_set_label(g-&gt;mode, NULL, _(&quot;lens model&quot;));</a>
<a name="ln4830">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;generic&quot;));</a>
<a name="ln4831">  dt_bauhaus_combobox_add(g-&gt;mode, _(&quot;specific&quot;));</a>
<a name="ln4832">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;mode, TRUE, TRUE, 0);</a>
<a name="ln4833"> </a>
<a name="ln4834">  g-&gt;f_length = dt_bauhaus_slider_new_with_range(self, 1.0f, 3.0f, 0.01f, 1.0f, 2);</a>
<a name="ln4835">  dt_bauhaus_widget_set_label(g-&gt;f_length, NULL, _(&quot;focal length&quot;));</a>
<a name="ln4836">  dt_bauhaus_slider_set_callback(g-&gt;f_length, log10_callback);</a>
<a name="ln4837">  dt_bauhaus_slider_set_format(g-&gt;f_length, &quot;%.0fmm&quot;);</a>
<a name="ln4838">  dt_bauhaus_slider_set_default(g-&gt;f_length, DEFAULT_F_LENGTH);</a>
<a name="ln4839">  dt_bauhaus_slider_set(g-&gt;f_length, DEFAULT_F_LENGTH);</a>
<a name="ln4840">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;f_length, 1.0f, 2000.0f);</a>
<a name="ln4841">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;f_length, TRUE, TRUE, 0);</a>
<a name="ln4842"> </a>
<a name="ln4843">  g-&gt;crop_factor = dt_bauhaus_slider_new_with_range(self, 1.0f, 2.0f, 0.01f, p-&gt;crop_factor, 2);</a>
<a name="ln4844">  dt_bauhaus_widget_set_label(g-&gt;crop_factor, NULL, _(&quot;crop factor&quot;));</a>
<a name="ln4845">  dt_bauhaus_slider_enable_soft_boundaries(g-&gt;crop_factor, 0.5f, 10.0f);</a>
<a name="ln4846">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;crop_factor, TRUE, TRUE, 0);</a>
<a name="ln4847"> </a>
<a name="ln4848">  g-&gt;orthocorr = dt_bauhaus_slider_new_with_range(self, 0.0f, 100.0f, 1.0f, p-&gt;orthocorr, 2);</a>
<a name="ln4849">  dt_bauhaus_widget_set_label(g-&gt;orthocorr, NULL, _(&quot;lens dependence&quot;));</a>
<a name="ln4850">  dt_bauhaus_slider_set_format(g-&gt;orthocorr, &quot;%.0f%%&quot;);</a>
<a name="ln4851">#if 0</a>
<a name="ln4852">  // this parameter could serve to finetune between generic model (0%) and specific model (100%).</a>
<a name="ln4853">  // however, users can more easily get the same effect with the aspect adjust parameter so we keep</a>
<a name="ln4854">  // this one hidden.</a>
<a name="ln4855">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;orthocorr, TRUE, TRUE, 0);</a>
<a name="ln4856">#endif</a>
<a name="ln4857"> </a>
<a name="ln4858">  g-&gt;aspect = dt_bauhaus_slider_new_with_range(self, -1.0f, 1.0f, 0.01f, 0.0f, 2);</a>
<a name="ln4859">  dt_bauhaus_widget_set_label(g-&gt;aspect, NULL, _(&quot;aspect adjust&quot;));</a>
<a name="ln4860">  dt_bauhaus_slider_set_callback(g-&gt;aspect, log2_callback);</a>
<a name="ln4861">  dt_bauhaus_slider_set_default(g-&gt;aspect, 1.0f);</a>
<a name="ln4862">  dt_bauhaus_slider_set(g-&gt;aspect, 1.0f);</a>
<a name="ln4863">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), g-&gt;aspect, TRUE, TRUE, 0);</a>
<a name="ln4864"> </a>
<a name="ln4865">  GtkWidget *grid = gtk_grid_new();</a>
<a name="ln4866">  gtk_grid_set_row_spacing(GTK_GRID(grid), 2 * DT_BAUHAUS_SPACE);</a>
<a name="ln4867">  gtk_grid_set_column_spacing(GTK_GRID(grid), DT_PIXEL_APPLY_DPI(10));</a>
<a name="ln4868"> </a>
<a name="ln4869">  GtkWidget *label1 = gtk_label_new(_(&quot;automatic fit&quot;));</a>
<a name="ln4870">  gtk_widget_set_halign(label1, GTK_ALIGN_START);</a>
<a name="ln4871">  gtk_grid_attach(GTK_GRID(grid), label1, 0, 0, 1, 1);</a>
<a name="ln4872"> </a>
<a name="ln4873">  g-&gt;fit_v = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 1, NULL);</a>
<a name="ln4874">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_v), TRUE);</a>
<a name="ln4875">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_v, label1, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4876"> </a>
<a name="ln4877">  g-&gt;fit_h = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 2, NULL);</a>
<a name="ln4878">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_h), TRUE);</a>
<a name="ln4879">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_h, g-&gt;fit_v, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4880"> </a>
<a name="ln4881">  g-&gt;fit_both = dtgtk_button_new(dtgtk_cairo_paint_perspective, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | 3, NULL);</a>
<a name="ln4882">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;fit_both), TRUE);</a>
<a name="ln4883">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;fit_both, g-&gt;fit_h, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4884"> </a>
<a name="ln4885">  GtkWidget *label2 = gtk_label_new(_(&quot;get structure&quot;));</a>
<a name="ln4886">  gtk_widget_set_halign(label2, GTK_ALIGN_START);</a>
<a name="ln4887">  gtk_grid_attach(GTK_GRID(grid), label2, 0, 1, 1, 1);</a>
<a name="ln4888"> </a>
<a name="ln4889">  g-&gt;structure = dtgtk_button_new(dtgtk_cairo_paint_structure, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4890">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;structure), TRUE);</a>
<a name="ln4891">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;structure, label2, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4892"> </a>
<a name="ln4893">  g-&gt;clean = dtgtk_button_new(dtgtk_cairo_paint_cancel, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4894">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;clean), TRUE);</a>
<a name="ln4895">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;clean, g-&gt;structure, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4896"> </a>
<a name="ln4897">  g-&gt;eye = dtgtk_togglebutton_new(dtgtk_cairo_paint_eye_toggle, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln4898">  gtk_widget_set_hexpand(GTK_WIDGET(g-&gt;eye), TRUE);</a>
<a name="ln4899">  gtk_grid_attach_next_to(GTK_GRID(grid), g-&gt;eye, g-&gt;clean, GTK_POS_RIGHT, 1, 1);</a>
<a name="ln4900"> </a>
<a name="ln4901">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), grid, TRUE, TRUE, 0);</a>
<a name="ln4902"> </a>
<a name="ln4903">  gtk_widget_show_all(g-&gt;f_length);</a>
<a name="ln4904">  gtk_widget_set_no_show_all(g-&gt;f_length, TRUE);</a>
<a name="ln4905">  gtk_widget_show_all(g-&gt;crop_factor);</a>
<a name="ln4906">  gtk_widget_set_no_show_all(g-&gt;crop_factor, TRUE);</a>
<a name="ln4907">  gtk_widget_show_all(g-&gt;orthocorr);</a>
<a name="ln4908">  gtk_widget_set_no_show_all(g-&gt;orthocorr, TRUE);</a>
<a name="ln4909">  gtk_widget_show_all(g-&gt;aspect);</a>
<a name="ln4910">  gtk_widget_set_no_show_all(g-&gt;aspect, TRUE);</a>
<a name="ln4911"> </a>
<a name="ln4912"> </a>
<a name="ln4913">  switch(p-&gt;mode)</a>
<a name="ln4914">  {</a>
<a name="ln4915">    case ASHIFT_MODE_GENERIC:</a>
<a name="ln4916">      gtk_widget_hide(g-&gt;f_length);</a>
<a name="ln4917">      gtk_widget_hide(g-&gt;crop_factor);</a>
<a name="ln4918">      gtk_widget_hide(g-&gt;orthocorr);</a>
<a name="ln4919">      gtk_widget_hide(g-&gt;aspect);</a>
<a name="ln4920">      break;</a>
<a name="ln4921">    case ASHIFT_MODE_SPECIFIC:</a>
<a name="ln4922">    default:</a>
<a name="ln4923">      gtk_widget_show(g-&gt;f_length);</a>
<a name="ln4924">      gtk_widget_show(g-&gt;crop_factor);</a>
<a name="ln4925">      gtk_widget_show(g-&gt;orthocorr);</a>
<a name="ln4926">      gtk_widget_show(g-&gt;aspect);</a>
<a name="ln4927">      break;</a>
<a name="ln4928">  }</a>
<a name="ln4929"> </a>
<a name="ln4930">  gtk_widget_set_tooltip_text(g-&gt;rotation, _(&quot;rotate image&quot;));</a>
<a name="ln4931">  gtk_widget_set_tooltip_text(g-&gt;lensshift_v, _(&quot;apply lens shift correction in one direction&quot;));</a>
<a name="ln4932">  gtk_widget_set_tooltip_text(g-&gt;lensshift_h, _(&quot;apply lens shift correction in one direction&quot;));</a>
<a name="ln4933">  gtk_widget_set_tooltip_text(g-&gt;shear, _(&quot;shear the image along one diagonal&quot;));</a>
<a name="ln4934">  gtk_widget_set_tooltip_text(g-&gt;guide_lines, _(&quot;display guide lines overlay&quot;));</a>
<a name="ln4935">  gtk_widget_set_tooltip_text(g-&gt;cropmode, _(&quot;automatically crop to avoid black edges&quot;));</a>
<a name="ln4936">  gtk_widget_set_tooltip_text(g-&gt;mode, _(&quot;lens model of the perspective correction: &quot;</a>
<a name="ln4937">                                         &quot;generic or according to the focal length&quot;));</a>
<a name="ln4938">  gtk_widget_set_tooltip_text(g-&gt;f_length, _(&quot;focal length of the lens, &quot;</a>
<a name="ln4939">                                             &quot;default value set from exif data if available&quot;));</a>
<a name="ln4940">  gtk_widget_set_tooltip_text(g-&gt;crop_factor, _(&quot;crop factor of the camera sensor, &quot;</a>
<a name="ln4941">                                                &quot;default value set from exif data if available, &quot;</a>
<a name="ln4942">                                                &quot;manual setting is often required&quot;));</a>
<a name="ln4943">  gtk_widget_set_tooltip_text(g-&gt;orthocorr, _(&quot;the level of lens dependent correction, set to maximum for full lens dependency, &quot;</a>
<a name="ln4944">                                              &quot;set to zero for the generic case&quot;));</a>
<a name="ln4945">  gtk_widget_set_tooltip_text(g-&gt;aspect, _(&quot;adjust aspect ratio of image by horizontal and vertical scaling&quot;));</a>
<a name="ln4946">  gtk_widget_set_tooltip_text(g-&gt;fit_v, _(&quot;automatically correct for vertical perspective distortion\n&quot;</a>
<a name="ln4947">                                          &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4948">                                          &quot;shift-click to only fit lens shift&quot;));</a>
<a name="ln4949">  gtk_widget_set_tooltip_text(g-&gt;fit_h, _(&quot;automatically correct for horizontal perspective distortion\n&quot;</a>
<a name="ln4950">                                          &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4951">                                          &quot;shift-click to only fit lens shift&quot;));</a>
<a name="ln4952">  gtk_widget_set_tooltip_text(g-&gt;fit_both, _(&quot;automatically correct for vertical and &quot;</a>
<a name="ln4953">                                             &quot;horizontal perspective distortions; fitting rotation,&quot;</a>
<a name="ln4954">                                             &quot;lens shift in both directions, and shear\n&quot;</a>
<a name="ln4955">                                             &quot;ctrl-click to only fit rotation\n&quot;</a>
<a name="ln4956">                                             &quot;shift-click to only fit lens shift\n&quot;</a>
<a name="ln4957">                                             &quot;ctrl-shift-click to only fit rotation and lens shift&quot;));</a>
<a name="ln4958">  gtk_widget_set_tooltip_text(g-&gt;structure, _(&quot;analyse line structure in image\n&quot;</a>
<a name="ln4959">                                              &quot;ctrl-click for an additional edge enhancement\n&quot;</a>
<a name="ln4960">                                              &quot;shift-click for an additional detail enhancement\n&quot;</a>
<a name="ln4961">                                              &quot;ctrl-shift-click for a combination of both methods&quot;));</a>
<a name="ln4962">  gtk_widget_set_tooltip_text(g-&gt;clean, _(&quot;remove line structure information&quot;));</a>
<a name="ln4963">  gtk_widget_set_tooltip_text(g-&gt;eye, _(&quot;toggle visibility of structure lines&quot;));</a>
<a name="ln4964"> </a>
<a name="ln4965">  g_signal_connect(G_OBJECT(g-&gt;rotation), &quot;value-changed&quot;, G_CALLBACK(rotation_callback), self);</a>
<a name="ln4966">  g_signal_connect(G_OBJECT(g-&gt;lensshift_v), &quot;value-changed&quot;, G_CALLBACK(lensshift_v_callback), self);</a>
<a name="ln4967">  g_signal_connect(G_OBJECT(g-&gt;lensshift_h), &quot;value-changed&quot;, G_CALLBACK(lensshift_h_callback), self);</a>
<a name="ln4968">  g_signal_connect(G_OBJECT(g-&gt;shear), &quot;value-changed&quot;, G_CALLBACK(shear_callback), self);</a>
<a name="ln4969">  g_signal_connect(G_OBJECT(g-&gt;guide_lines), &quot;value-changed&quot;, G_CALLBACK(guide_lines_callback), self);</a>
<a name="ln4970">  g_signal_connect(G_OBJECT(g-&gt;cropmode), &quot;value-changed&quot;, G_CALLBACK(cropmode_callback), self);</a>
<a name="ln4971">  g_signal_connect(G_OBJECT(g-&gt;mode), &quot;value-changed&quot;, G_CALLBACK(mode_callback), self);</a>
<a name="ln4972">  g_signal_connect(G_OBJECT(g-&gt;f_length), &quot;value-changed&quot;, G_CALLBACK(f_length_callback), self);</a>
<a name="ln4973">  g_signal_connect(G_OBJECT(g-&gt;crop_factor), &quot;value-changed&quot;, G_CALLBACK(crop_factor_callback), self);</a>
<a name="ln4974">  g_signal_connect(G_OBJECT(g-&gt;orthocorr), &quot;value-changed&quot;, G_CALLBACK(orthocorr_callback), self);</a>
<a name="ln4975">  g_signal_connect(G_OBJECT(g-&gt;aspect), &quot;value-changed&quot;, G_CALLBACK(aspect_callback), self);</a>
<a name="ln4976">  g_signal_connect(G_OBJECT(g-&gt;fit_v), &quot;button-press-event&quot;, G_CALLBACK(fit_v_button_clicked), (gpointer)self);</a>
<a name="ln4977">  g_signal_connect(G_OBJECT(g-&gt;fit_h), &quot;button-press-event&quot;, G_CALLBACK(fit_h_button_clicked), (gpointer)self);</a>
<a name="ln4978">  g_signal_connect(G_OBJECT(g-&gt;fit_both), &quot;button-press-event&quot;, G_CALLBACK(fit_both_button_clicked), (gpointer)self);</a>
<a name="ln4979">  g_signal_connect(G_OBJECT(g-&gt;structure), &quot;button-press-event&quot;, G_CALLBACK(structure_button_clicked), (gpointer)self);</a>
<a name="ln4980">  g_signal_connect(G_OBJECT(g-&gt;clean), &quot;clicked&quot;, G_CALLBACK(clean_button_clicked), (gpointer)self);</a>
<a name="ln4981">  g_signal_connect(G_OBJECT(g-&gt;eye), &quot;toggled&quot;, G_CALLBACK(eye_button_toggled), (gpointer)self);</a>
<a name="ln4982">  g_signal_connect(G_OBJECT(self-&gt;widget), &quot;draw&quot;, G_CALLBACK(draw), self);</a>
<a name="ln4983"> </a>
<a name="ln4984">  /* add signal handler for preview pipe finish to redraw the overlay */</a>
<a name="ln4985">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_DEVELOP_PREVIEW_PIPE_FINISHED,</a>
<a name="ln4986">                            G_CALLBACK(process_after_preview_callback), self);</a>
<a name="ln4987"> </a>
<a name="ln4988">}</a>
<a name="ln4989"> </a>
<a name="ln4990">void gui_cleanup(struct dt_iop_module_t *self)</a>
<a name="ln4991">{</a>
<a name="ln4992">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(process_after_preview_callback), self);</a>
<a name="ln4993"> </a>
<a name="ln4994">  dt_iop_ashift_gui_data_t *g = (dt_iop_ashift_gui_data_t *)self-&gt;gui_data;</a>
<a name="ln4995">  dt_pthread_mutex_destroy(&amp;g-&gt;lock);</a>
<a name="ln4996">  free(g-&gt;lines);</a>
<a name="ln4997">  free(g-&gt;buf);</a>
<a name="ln4998">  free(g-&gt;points);</a>
<a name="ln4999">  free(g-&gt;points_idx);</a>
<a name="ln5000">  free(self-&gt;gui_data);</a>
<a name="ln5001">  self-&gt;gui_data = NULL;</a>
<a name="ln5002">}</a>
<a name="ln5003"> </a>
<a name="ln5004">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln5005">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln5006">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="1237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'Gy' is always false.</p></div>
<div class="balloon" rel="1648"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1648, 1647.</p></div>
<div class="balloon" rel="1668"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'perm'. Check lines: 1668, 1667.</p></div>
<div class="balloon" rel="1714"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'inout'. Check lines: 1714, 1672.</p></div>
<div class="balloon" rel="1785"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1785, 1649.</p></div>
<div class="balloon" rel="1843"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lines_set'. Check lines: 1843, 1825.</p></div>
<div class="balloon" rel="1844"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'inout_set'. Check lines: 1844, 1827.</p></div>
<div class="balloon" rel="2765"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'g->fitting' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2757, 2765.</p></div>
<div class="balloon" rel="3861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true.</p></div>
<div class="balloon" rel="4541"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 4541, 4534.</p></div>
<div class="balloon" rel="4542"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 4542, 4535.</p></div>
<div class="balloon" rel="4652"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'gd'. Check lines: 4652, 4648.</p></div>
<div class="balloon" rel="4748"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'g'. Check lines: 4748, 4744.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
