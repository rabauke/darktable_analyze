
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2010 johannes hanika.</a>
<a name="ln4">    copyright (c) 2011 henrik andersson.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;common/collection.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;common/debug.h&quot;</a>
<a name="ln22">#include &quot;common/tags.h&quot;</a>
<a name="ln23">#include &quot;control/conf.h&quot;</a>
<a name="ln24">#include &quot;control/control.h&quot;</a>
<a name="ln25">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln26">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln27">#include &quot;gui/gtk.h&quot;</a>
<a name="ln28">#include &quot;libs/lib.h&quot;</a>
<a name="ln29">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln30">#include &quot;views/view.h&quot;</a>
<a name="ln31">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln32">#include &quot;osx/osx.h&quot;</a>
<a name="ln33">#endif</a>
<a name="ln34">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln35">#include &lt;math.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#define FLOATING_ENTRY_WIDTH DT_PIXEL_APPLY_DPI(150)</a>
<a name="ln38"> </a>
<a name="ln39">DT_MODULE(1)</a>
<a name="ln40"> </a>
<a name="ln41">static gboolean _lib_tagging_tag_show(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln42">                                      GdkModifierType modifier, dt_lib_module_t *self);</a>
<a name="ln43"> </a>
<a name="ln44">typedef struct dt_lib_tagging_t</a>
<a name="ln45">{</a>
<a name="ln46">  char keyword[1024];</a>
<a name="ln47">  GtkEntry *entry;</a>
<a name="ln48">  GtkTreeView *current, *related;</a>
<a name="ln49">  int imgsel;</a>
<a name="ln50"> </a>
<a name="ln51">  GtkWidget *attach_button, *detach_button, *new_button, *delete_button, *import_button, *export_button;</a>
<a name="ln52"> </a>
<a name="ln53">  GtkWidget *floating_tag_window;</a>
<a name="ln54">  int floating_tag_imgid;</a>
<a name="ln55">} dt_lib_tagging_t;</a>
<a name="ln56"> </a>
<a name="ln57">typedef enum dt_lib_tagging_cols_t</a>
<a name="ln58">{</a>
<a name="ln59">  DT_LIB_TAGGING_COL_TAG = 0,</a>
<a name="ln60">  DT_LIB_TAGGING_COL_ID,</a>
<a name="ln61">  DT_LIB_TAGGING_NUM_COLS</a>
<a name="ln62">} dt_lib_tagging_cols_t;</a>
<a name="ln63"> </a>
<a name="ln64">const char *name(dt_lib_module_t *self)</a>
<a name="ln65">{</a>
<a name="ln66">  return _(&quot;tagging&quot;);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">const char **views(dt_lib_module_t *self)</a>
<a name="ln70">{</a>
<a name="ln71">  static const char *v1[] = {&quot;lighttable&quot;, &quot;darkroom&quot;, &quot;map&quot;, &quot;tethering&quot;, NULL};</a>
<a name="ln72">  static const char *v2[] = {&quot;lighttable&quot;, &quot;map&quot;, &quot;tethering&quot;, NULL};</a>
<a name="ln73"> </a>
<a name="ln74">  if(dt_conf_get_bool(&quot;plugins/darkroom/tagging/visible&quot;))</a>
<a name="ln75">    return v1;</a>
<a name="ln76">  else</a>
<a name="ln77">    return v2;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln81">{</a>
<a name="ln82">  const dt_view_t *cv = dt_view_manager_get_current_view(darktable.view_manager);</a>
<a name="ln83">  if(cv-&gt;view((dt_view_t *)cv) == DT_VIEW_DARKROOM)</a>
<a name="ln84">    return DT_UI_CONTAINER_PANEL_LEFT_CENTER;</a>
<a name="ln85">  else</a>
<a name="ln86">    return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln90">{</a>
<a name="ln91">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;attach&quot;), 0, 0);</a>
<a name="ln92">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;detach&quot;), 0, 0);</a>
<a name="ln93">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;new&quot;), 0, 0);</a>
<a name="ln94">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;delete&quot;), 0, 0);</a>
<a name="ln95">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;tag&quot;), GDK_KEY_t, GDK_CONTROL_MASK);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln99">{</a>
<a name="ln100">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln101"> </a>
<a name="ln102">  dt_accel_connect_button_lib(self, &quot;attach&quot;, d-&gt;attach_button);</a>
<a name="ln103">  dt_accel_connect_button_lib(self, &quot;detach&quot;, d-&gt;detach_button);</a>
<a name="ln104">  dt_accel_connect_button_lib(self, &quot;new&quot;, d-&gt;new_button);</a>
<a name="ln105">  dt_accel_connect_button_lib(self, &quot;delete&quot;, d-&gt;delete_button);</a>
<a name="ln106">  dt_accel_connect_lib(self, &quot;tag&quot;, g_cclosure_new(G_CALLBACK(_lib_tagging_tag_show), self, NULL));</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static void update(dt_lib_module_t *self, int which)</a>
<a name="ln110">{</a>
<a name="ln111">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln112">  GList *tags = NULL;</a>
<a name="ln113">  uint32_t count;</a>
<a name="ln114"> </a>
<a name="ln115">  if(which == 0) // tags of selected images</a>
<a name="ln116">  {</a>
<a name="ln117">    int imgsel = dt_control_get_mouse_over_id();</a>
<a name="ln118">    d-&gt;imgsel = imgsel;</a>
<a name="ln119">    count = dt_tag_get_attached(imgsel, &amp;tags, FALSE);</a>
<a name="ln120">  }</a>
<a name="ln121">  else // related tags of typed text</a>
<a name="ln122">    count = dt_tag_get_suggestions(d-&gt;keyword, &amp;tags);</a>
<a name="ln123"> </a>
<a name="ln124">  GtkTreeIter iter;</a>
<a name="ln125">  GtkTreeView *view;</a>
<a name="ln126">  if(which == 0)</a>
<a name="ln127">    view = d-&gt;current;</a>
<a name="ln128">  else</a>
<a name="ln129">    view = d-&gt;related;</a>
<a name="ln130">  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));</a>
<a name="ln131">  g_object_ref(model);</a>
<a name="ln132">  gtk_tree_view_set_model(GTK_TREE_VIEW(view), NULL);</a>
<a name="ln133">  gtk_list_store_clear(GTK_LIST_STORE(model));</a>
<a name="ln134"> </a>
<a name="ln135">  if(count &gt; 0 &amp;&amp; tags)</a>
<a name="ln136">  {</a>
<a name="ln137">    GList *tag = tags;</a>
<a name="ln138">    do</a>
<a name="ln139">    {</a>
<a name="ln140">      gtk_list_store_append(GTK_LIST_STORE(model), &amp;iter);</a>
<a name="ln141">      gtk_list_store_set(GTK_LIST_STORE(model), &amp;iter, DT_LIB_TAGGING_COL_TAG, ((dt_tag_t *)tag-&gt;data)-&gt;tag,</a>
<a name="ln142">                         DT_LIB_TAGGING_COL_ID, ((dt_tag_t *)tag-&gt;data)-&gt;id, -1);</a>
<a name="ln143">    } while((tag = g_list_next(tag)) != NULL);</a>
<a name="ln144">  }</a>
<a name="ln145"> </a>
<a name="ln146">  // Free result...</a>
<a name="ln147">  dt_tag_free_result(&amp;tags);</a>
<a name="ln148"> </a>
<a name="ln149">  gtk_tree_view_set_model(GTK_TREE_VIEW(view), model);</a>
<a name="ln150">  g_object_unref(model);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">static void set_keyword(dt_lib_module_t *self, dt_lib_tagging_t *d)</a>
<a name="ln154">{</a>
<a name="ln155">  const gchar *beg = g_strrstr(gtk_entry_get_text(d-&gt;entry), &quot;,&quot;);</a>
<a name="ln156">  if(!beg)</a>
<a name="ln157">    beg = gtk_entry_get_text(d-&gt;entry);</a>
<a name="ln158">  else</a>
<a name="ln159">  {</a>
<a name="ln160">    if(*beg == ',') beg++;</a>
<a name="ln161">    if(*beg == ' ') beg++;</a>
<a name="ln162">  }</a>
<a name="ln163">  snprintf(d-&gt;keyword, sizeof(d-&gt;keyword), &quot;%s&quot;, beg);</a>
<a name="ln164">  update(self, 1);</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">static void attach_selected_tag(dt_lib_module_t *self, dt_lib_tagging_t *d)</a>
<a name="ln168">{</a>
<a name="ln169">  GtkTreeIter iter;</a>
<a name="ln170">  GtkTreeModel *model = NULL;</a>
<a name="ln171">  GtkTreeView *view = d-&gt;related;</a>
<a name="ln172">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln173">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)</a>
<a name="ln174">     &amp;&amp; !gtk_tree_model_get_iter_first(model, &amp;iter))</a>
<a name="ln175">    return;</a>
<a name="ln176">  guint tagid;</a>
<a name="ln177">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln178"> </a>
<a name="ln179">  int imgsel = -1;</a>
<a name="ln180">  if(tagid &lt;= 0) return;</a>
<a name="ln181"> </a>
<a name="ln182">  imgsel = dt_view_get_image_to_act_on();</a>
<a name="ln183"> </a>
<a name="ln184">  dt_tag_attach(tagid, imgsel);</a>
<a name="ln185">  dt_image_synch_xmp(imgsel);</a>
<a name="ln186"> </a>
<a name="ln187">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static void detach_selected_tag(dt_lib_module_t *self, dt_lib_tagging_t *d)</a>
<a name="ln191">{</a>
<a name="ln192">  GtkTreeIter iter;</a>
<a name="ln193">  GtkTreeModel *model = NULL;</a>
<a name="ln194">  GtkTreeView *view = d-&gt;current;</a>
<a name="ln195">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln196">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln197">  guint tagid;</a>
<a name="ln198">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln199"> </a>
<a name="ln200">  int imgsel = -1;</a>
<a name="ln201">  if(tagid &lt;= 0) return;</a>
<a name="ln202"> </a>
<a name="ln203">  imgsel = dt_view_get_image_to_act_on();</a>
<a name="ln204">  GList *affected_images = dt_tag_get_images_from_selection(imgsel, tagid);</a>
<a name="ln205"> </a>
<a name="ln206">  dt_tag_detach(tagid, imgsel);</a>
<a name="ln207"> </a>
<a name="ln208">  // we have to check the conf option as dt_image_synch_xmp() doesn't when called for a single image</a>
<a name="ln209">  if(dt_conf_get_bool(&quot;write_sidecar_files&quot;))</a>
<a name="ln210">  {</a>
<a name="ln211">    for(GList *image_iter = affected_images; image_iter; image_iter = g_list_next(image_iter))</a>
<a name="ln212">    {</a>
<a name="ln213">      int imgid = GPOINTER_TO_INT(image_iter-&gt;data);</a>
<a name="ln214">      dt_image_synch_xmp(imgid);</a>
<a name="ln215">    }</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218">  g_list_free(affected_images);</a>
<a name="ln219"> </a>
<a name="ln220">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static void attach_activated(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, gpointer user_data)</a>
<a name="ln224">{</a>
<a name="ln225">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln226">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln227">  attach_selected_tag(self, d);</a>
<a name="ln228">  update(self, 0);</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">static void detach_activated(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *col, gpointer user_data)</a>
<a name="ln232">{</a>
<a name="ln233">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln234">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln235">  detach_selected_tag(self, d);</a>
<a name="ln236">  update(self, 0);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">static void attach_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln240">{</a>
<a name="ln241">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln242">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln243">  attach_selected_tag(self, d);</a>
<a name="ln244">  update(self, 0);</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">static void detach_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln248">{</a>
<a name="ln249">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln250">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln251">  detach_selected_tag(self, d);</a>
<a name="ln252">  update(self, 0);</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">static void new_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln256">{</a>
<a name="ln257">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln258">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln259">  const gchar *tag = gtk_entry_get_text(d-&gt;entry);</a>
<a name="ln260"> </a>
<a name="ln261">  /** attach tag to selected images  */</a>
<a name="ln262">  dt_tag_attach_string_list(tag, -1);</a>
<a name="ln263">  dt_image_synch_xmp(-1);</a>
<a name="ln264"> </a>
<a name="ln265">  update(self, 1);</a>
<a name="ln266">  update(self, 0);</a>
<a name="ln267"> </a>
<a name="ln268">  /** clear input box */</a>
<a name="ln269">  gtk_entry_set_text(d-&gt;entry, &quot;&quot;);</a>
<a name="ln270"> </a>
<a name="ln271">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static void entry_activated(GtkButton *button, gpointer user_data)</a>
<a name="ln275">{</a>
<a name="ln276">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln277">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln278">  const gchar *tag = gtk_entry_get_text(d-&gt;entry);</a>
<a name="ln279">  if(!tag || tag[0] == '\0') return;</a>
<a name="ln280"> </a>
<a name="ln281">  /** attach tag to selected images  */</a>
<a name="ln282">  dt_tag_attach_string_list(tag, -1);</a>
<a name="ln283">  dt_image_synch_xmp(-1);</a>
<a name="ln284"> </a>
<a name="ln285">  update(self, 1);</a>
<a name="ln286">  update(self, 0);</a>
<a name="ln287">  gtk_entry_set_text(d-&gt;entry, &quot;&quot;);</a>
<a name="ln288"> </a>
<a name="ln289">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">static void tag_name_changed(GtkEntry *entry, gpointer user_data)</a>
<a name="ln293">{</a>
<a name="ln294">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln295">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln296">  set_keyword(self, d);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">static void delete_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln300">{</a>
<a name="ln301">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln302">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln303"> </a>
<a name="ln304">  int res = GTK_RESPONSE_YES;</a>
<a name="ln305"> </a>
<a name="ln306">  guint tagid;</a>
<a name="ln307">  GtkTreeIter iter;</a>
<a name="ln308">  GtkTreeModel *model = NULL;</a>
<a name="ln309">  GtkTreeView *view = d-&gt;related;</a>
<a name="ln310">  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(view));</a>
<a name="ln311">  if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter)) return;</a>
<a name="ln312">  gtk_tree_model_get(model, &amp;iter, DT_LIB_TAGGING_COL_ID, &amp;tagid, -1);</a>
<a name="ln313"> </a>
<a name="ln314">  // First check how many images are affected by the remove</a>
<a name="ln315">  int count = dt_tag_remove(tagid, FALSE);</a>
<a name="ln316">  if(count &gt; 0 &amp;&amp; dt_conf_get_bool(&quot;plugins/lighttable/tagging/ask_before_delete_tag&quot;))</a>
<a name="ln317">  {</a>
<a name="ln318">    GtkWidget *dialog;</a>
<a name="ln319">    GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln320">    gchar *tagname = dt_tag_get_name(tagid);</a>
<a name="ln321">    dialog = gtk_message_dialog_new(</a>
<a name="ln322">        GTK_WINDOW(win), GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_QUESTION, GTK_BUTTONS_YES_NO,</a>
<a name="ln323">        ngettext(&quot;do you really want to delete the tag `%s'?\n%d image is assigned this tag!&quot;,</a>
<a name="ln324">                 &quot;do you really want to delete the tag `%s'?\n%d images are assigned this tag!&quot;, count),</a>
<a name="ln325">        tagname, count);</a>
<a name="ln326">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln327">    dt_osx_disallow_fullscreen(dialog);</a>
<a name="ln328">#endif</a>
<a name="ln329">    gtk_window_set_title(GTK_WINDOW(dialog), _(&quot;delete tag?&quot;));</a>
<a name="ln330">    res = gtk_dialog_run(GTK_DIALOG(dialog));</a>
<a name="ln331">    gtk_widget_destroy(dialog);</a>
<a name="ln332">    free(tagname);</a>
<a name="ln333">  }</a>
<a name="ln334">  if(res != GTK_RESPONSE_YES) return;</a>
<a name="ln335"> </a>
<a name="ln336">  GList *tagged_images = NULL;</a>
<a name="ln337">  sqlite3_stmt *stmt;</a>
<a name="ln338">  DT_DEBUG_SQLITE3_PREPARE_V2(dt_database_get(darktable.db), &quot;SELECT imgid FROM main.tagged_images WHERE tagid=?1&quot;,</a>
<a name="ln339">                              -1, &amp;stmt, NULL);</a>
<a name="ln340">  DT_DEBUG_SQLITE3_BIND_INT(stmt, 1, tagid);</a>
<a name="ln341">  while(sqlite3_step(stmt) == SQLITE_ROW)</a>
<a name="ln342">  {</a>
<a name="ln343">    tagged_images = g_list_append(tagged_images, GINT_TO_POINTER(sqlite3_column_int(stmt, 0)));</a>
<a name="ln344">  }</a>
<a name="ln345">  sqlite3_finalize(stmt);</a>
<a name="ln346"> </a>
<a name="ln347">  dt_tag_remove(tagid, TRUE);</a>
<a name="ln348"> </a>
<a name="ln349">  GList *list_iter;</a>
<a name="ln350">  if((list_iter = g_list_first(tagged_images)) != NULL)</a>
<a name="ln351">  {</a>
<a name="ln352">    do</a>
<a name="ln353">    {</a>
<a name="ln354">      dt_image_synch_xmp(GPOINTER_TO_INT(list_iter-&gt;data));</a>
<a name="ln355">    } while((list_iter = g_list_next(list_iter)) != NULL);</a>
<a name="ln356">  }</a>
<a name="ln357">  g_list_free(g_list_first(tagged_images));</a>
<a name="ln358"> </a>
<a name="ln359">  update(self, 0);</a>
<a name="ln360">  update(self, 1);</a>
<a name="ln361"> </a>
<a name="ln362">  dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">static void import_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln366">{</a>
<a name="ln367">  char *last_dirname = dt_conf_get_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;);</a>
<a name="ln368">  if(!last_dirname || !*last_dirname)</a>
<a name="ln369">  {</a>
<a name="ln370">    g_free(last_dirname);</a>
<a name="ln371">    last_dirname = g_strdup(g_get_home_dir());</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln375">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(_(&quot;Select a keyword file&quot;), GTK_WINDOW(win),</a>
<a name="ln376">                                                       GTK_FILE_CHOOSER_ACTION_OPEN,</a>
<a name="ln377">                                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln378">                                                       _(&quot;_import&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln379">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln380">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln381">#endif</a>
<a name="ln382">  gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_dirname);</a>
<a name="ln383">  gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(filechooser), FALSE);</a>
<a name="ln384"> </a>
<a name="ln385">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln386">  {</a>
<a name="ln387">    char *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln388">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln389">    dt_conf_set_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;, dirname);</a>
<a name="ln390">    ssize_t count = dt_tag_import(filename);</a>
<a name="ln391">    if(count &lt; 0)</a>
<a name="ln392">      dt_control_log(_(&quot;error importing tags&quot;));</a>
<a name="ln393">    else</a>
<a name="ln394">      dt_control_log(_(&quot;%zd tags imported&quot;), count);</a>
<a name="ln395">    g_free(filename);</a>
<a name="ln396">    g_free(dirname);</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  g_free(last_dirname);</a>
<a name="ln400">  gtk_widget_destroy(filechooser);</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403">static void export_button_clicked(GtkButton *button, gpointer user_data)</a>
<a name="ln404">{</a>
<a name="ln405">  GDateTime *now = g_date_time_new_now_local();</a>
<a name="ln406">  char *export_filename = g_date_time_format(now, &quot;darktable_tags_%F_%R.txt&quot;);</a>
<a name="ln407">  char *last_dirname = dt_conf_get_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;);</a>
<a name="ln408">  if(!last_dirname || !*last_dirname)</a>
<a name="ln409">  {</a>
<a name="ln410">    g_free(last_dirname);</a>
<a name="ln411">    last_dirname = g_strdup(g_get_home_dir());</a>
<a name="ln412">  }</a>
<a name="ln413"> </a>
<a name="ln414">  GtkWidget *win = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln415">  GtkWidget *filechooser = gtk_file_chooser_dialog_new(_(&quot;Select file to export to&quot;), GTK_WINDOW(win),</a>
<a name="ln416">                                                       GTK_FILE_CHOOSER_ACTION_SAVE,</a>
<a name="ln417">                                                       _(&quot;_cancel&quot;), GTK_RESPONSE_CANCEL,</a>
<a name="ln418">                                                       _(&quot;_export&quot;), GTK_RESPONSE_ACCEPT, (char *)NULL);</a>
<a name="ln419">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln420">  dt_osx_disallow_fullscreen(filechooser);</a>
<a name="ln421">#endif</a>
<a name="ln422">  gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(filechooser), TRUE);</a>
<a name="ln423">  gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(filechooser), last_dirname);</a>
<a name="ln424">  gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(filechooser), export_filename);</a>
<a name="ln425"> </a>
<a name="ln426">  if(gtk_dialog_run(GTK_DIALOG(filechooser)) == GTK_RESPONSE_ACCEPT)</a>
<a name="ln427">  {</a>
<a name="ln428">    char *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(filechooser));</a>
<a name="ln429">    char *dirname = g_path_get_dirname(filename);</a>
<a name="ln430">    dt_conf_set_string(&quot;plugins/lighttable/tagging/last_import_export_location&quot;, dirname);</a>
<a name="ln431">    ssize_t count = dt_tag_export(filename);</a>
<a name="ln432">    if(count &lt; 0)</a>
<a name="ln433">      dt_control_log(_(&quot;error exporting tags&quot;));</a>
<a name="ln434">    else</a>
<a name="ln435">      dt_control_log(_(&quot;%zd tags exported&quot;), count);</a>
<a name="ln436">    g_free(filename);</a>
<a name="ln437">    g_free(dirname);</a>
<a name="ln438">  }</a>
<a name="ln439"> </a>
<a name="ln440">  g_date_time_unref(now);</a>
<a name="ln441">  g_free(last_dirname);</a>
<a name="ln442">  g_free(export_filename);</a>
<a name="ln443">  gtk_widget_destroy(filechooser);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln447">{</a>
<a name="ln448">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln449">  // clear entry box and query</a>
<a name="ln450">  gtk_entry_set_text(d-&gt;entry, &quot;&quot;);</a>
<a name="ln451">  set_keyword(self, d);</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">int position()</a>
<a name="ln455">{</a>
<a name="ln456">  return 500;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">static void _lib_tagging_redraw_callback(gpointer instance, gpointer user_data)</a>
<a name="ln460">{</a>
<a name="ln461">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln462">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln463">  int imgsel = dt_control_get_mouse_over_id();</a>
<a name="ln464">  if(imgsel != d-&gt;imgsel) update(self, 0);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">static void _lib_tagging_tags_changed_callback(gpointer instance, gpointer user_data)</a>
<a name="ln468">{</a>
<a name="ln469">  dt_lib_module_t *self = (dt_lib_module_t *)user_data;</a>
<a name="ln470">  update(self, 0);</a>
<a name="ln471">  update(self, 1);</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">void gui_init(dt_lib_module_t *self)</a>
<a name="ln475">{</a>
<a name="ln476">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)malloc(sizeof(dt_lib_tagging_t));</a>
<a name="ln477">  self-&gt;data = (void *)d;</a>
<a name="ln478">  d-&gt;imgsel = -1;</a>
<a name="ln479"> </a>
<a name="ln480">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln481">  dt_gui_add_help_link(self-&gt;widget, dt_get_help_url(self-&gt;plugin_name));</a>
<a name="ln482">  //   gtk_widget_set_size_request(self-&gt;widget, DT_PIXEL_APPLY_DPI(100), -1);</a>
<a name="ln483"> </a>
<a name="ln484">  GtkBox *box, *hbox;</a>
<a name="ln485">  GtkWidget *button;</a>
<a name="ln486">  GtkWidget *w;</a>
<a name="ln487">  GtkListStore *liststore;</a>
<a name="ln488"> </a>
<a name="ln489">  // left side, current</a>
<a name="ln490">  box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 5));</a>
<a name="ln491"> </a>
<a name="ln492">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 0);</a>
<a name="ln493">  w = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln494">  gtk_widget_set_size_request(w, -1, DT_PIXEL_APPLY_DPI(100));</a>
<a name="ln495">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(w), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln496">  gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln497">  d-&gt;current = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln498">  gtk_tree_view_set_headers_visible(d-&gt;current, FALSE);</a>
<a name="ln499">  liststore = gtk_list_store_new(DT_LIB_TAGGING_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT);</a>
<a name="ln500">  GtkTreeViewColumn *col = gtk_tree_view_column_new();</a>
<a name="ln501">  gtk_tree_view_append_column(d-&gt;current, col);</a>
<a name="ln502">  GtkCellRenderer *renderer = gtk_cell_renderer_text_new();</a>
<a name="ln503">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln504">  gtk_tree_view_column_add_attribute(col, renderer, &quot;text&quot;, DT_LIB_TAGGING_COL_TAG);</a>
<a name="ln505">  gtk_tree_selection_set_mode(gtk_tree_view_get_selection(d-&gt;current), GTK_SELECTION_SINGLE);</a>
<a name="ln506">  gtk_tree_view_set_model(d-&gt;current, GTK_TREE_MODEL(liststore));</a>
<a name="ln507">  g_object_unref(liststore);</a>
<a name="ln508">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;current), _(&quot;attached tags,\ndoubleclick to detach&quot;));</a>
<a name="ln509">  dt_gui_add_help_link(GTK_WIDGET(d-&gt;current), &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln510">  g_signal_connect(G_OBJECT(d-&gt;current), &quot;row-activated&quot;, G_CALLBACK(detach_activated), (gpointer)self);</a>
<a name="ln511">  gtk_container_add(GTK_CONTAINER(w), GTK_WIDGET(d-&gt;current));</a>
<a name="ln512"> </a>
<a name="ln513">  // attach/detach buttons</a>
<a name="ln514">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln515"> </a>
<a name="ln516">  button = gtk_button_new_with_label(_(&quot;attach&quot;));</a>
<a name="ln517">  d-&gt;attach_button = button;</a>
<a name="ln518">  gtk_widget_set_tooltip_text(button, _(&quot;attach tag to all selected images&quot;));</a>
<a name="ln519">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln520">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln521">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(attach_button_clicked), (gpointer)self);</a>
<a name="ln522"> </a>
<a name="ln523">  button = gtk_button_new_with_label(_(&quot;detach&quot;));</a>
<a name="ln524">  d-&gt;detach_button = button;</a>
<a name="ln525">  gtk_widget_set_tooltip_text(button, _(&quot;detach tag from all selected images&quot;));</a>
<a name="ln526">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln527">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(detach_button_clicked), (gpointer)self);</a>
<a name="ln528">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln529"> </a>
<a name="ln530">  gtk_box_pack_start(box, GTK_WIDGET(hbox), FALSE, TRUE, 0);</a>
<a name="ln531"> </a>
<a name="ln532">  // right side, related</a>
<a name="ln533">  box = GTK_BOX(gtk_box_new(GTK_ORIENTATION_VERTICAL, 5));</a>
<a name="ln534">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), GTK_WIDGET(box), TRUE, TRUE, 5);</a>
<a name="ln535"> </a>
<a name="ln536">  // text entry and new button</a>
<a name="ln537">  w = gtk_entry_new();</a>
<a name="ln538">  gtk_widget_set_tooltip_text(w, _(&quot;enter tag name&quot;));</a>
<a name="ln539">  dt_gui_add_help_link(w, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln540">  gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln541">  gtk_widget_add_events(GTK_WIDGET(w), GDK_KEY_RELEASE_MASK);</a>
<a name="ln542">  // g_signal_connect(G_OBJECT(w), &quot;key-release-event&quot;,</a>
<a name="ln543">  g_signal_connect(G_OBJECT(w), &quot;changed&quot;, G_CALLBACK(tag_name_changed), (gpointer)self);</a>
<a name="ln544">  g_signal_connect(G_OBJECT(w), &quot;activate&quot;, G_CALLBACK(entry_activated), (gpointer)self);</a>
<a name="ln545">  d-&gt;entry = GTK_ENTRY(w);</a>
<a name="ln546">  dt_gui_key_accel_block_on_focus_connect(GTK_WIDGET(d-&gt;entry));</a>
<a name="ln547"> </a>
<a name="ln548">  // related tree view</a>
<a name="ln549">  w = gtk_scrolled_window_new(NULL, NULL);</a>
<a name="ln550">  gtk_widget_set_size_request(w, -1, DT_PIXEL_APPLY_DPI(100));</a>
<a name="ln551">  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(w), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);</a>
<a name="ln552">  gtk_box_pack_start(box, w, TRUE, TRUE, 0);</a>
<a name="ln553">  d-&gt;related = GTK_TREE_VIEW(gtk_tree_view_new());</a>
<a name="ln554">  gtk_tree_view_set_headers_visible(d-&gt;related, FALSE);</a>
<a name="ln555">  liststore = gtk_list_store_new(DT_LIB_TAGGING_NUM_COLS, G_TYPE_STRING, G_TYPE_UINT);</a>
<a name="ln556">  col = gtk_tree_view_column_new();</a>
<a name="ln557">  gtk_tree_view_append_column(d-&gt;related, col);</a>
<a name="ln558">  renderer = gtk_cell_renderer_text_new();</a>
<a name="ln559">  gtk_tree_view_column_pack_start(col, renderer, TRUE);</a>
<a name="ln560">  gtk_tree_view_column_add_attribute(col, renderer, &quot;text&quot;, DT_LIB_TAGGING_COL_TAG);</a>
<a name="ln561">  gtk_tree_selection_set_mode(gtk_tree_view_get_selection(d-&gt;related), GTK_SELECTION_SINGLE);</a>
<a name="ln562">  gtk_tree_view_set_model(d-&gt;related, GTK_TREE_MODEL(liststore));</a>
<a name="ln563">  g_object_unref(liststore);</a>
<a name="ln564">  gtk_widget_set_tooltip_text(GTK_WIDGET(d-&gt;related), _(&quot;related tags,\ndoubleclick to attach&quot;));</a>
<a name="ln565">  dt_gui_add_help_link(GTK_WIDGET(d-&gt;related), &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln566">  g_signal_connect(G_OBJECT(d-&gt;related), &quot;row-activated&quot;, G_CALLBACK(attach_activated), (gpointer)self);</a>
<a name="ln567">  gtk_container_add(GTK_CONTAINER(w), GTK_WIDGET(d-&gt;related));</a>
<a name="ln568"> </a>
<a name="ln569">  // attach and delete buttons</a>
<a name="ln570">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5));</a>
<a name="ln571"> </a>
<a name="ln572">  button = gtk_button_new_with_label(_(&quot;new&quot;));</a>
<a name="ln573">  d-&gt;new_button = button;</a>
<a name="ln574">  gtk_widget_set_tooltip_text(button, _(&quot;create a new tag with the\nname you entered&quot;));</a>
<a name="ln575">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln576">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln577">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(new_button_clicked), (gpointer)self);</a>
<a name="ln578"> </a>
<a name="ln579">  button = gtk_button_new_with_label(_(&quot;delete&quot;));</a>
<a name="ln580">  d-&gt;delete_button = button;</a>
<a name="ln581">  gtk_widget_set_tooltip_text(button, _(&quot;delete selected tag&quot;));</a>
<a name="ln582">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln583">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln584">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(delete_button_clicked), (gpointer)self);</a>
<a name="ln585"> </a>
<a name="ln586">  button = gtk_button_new_with_label(C_(&quot;verb&quot;, &quot;import&quot;));</a>
<a name="ln587">  d-&gt;import_button = button;</a>
<a name="ln588">  gtk_widget_set_tooltip_text(button, _(&quot;import tags from a Lightroom keyword file&quot;));</a>
<a name="ln589">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln590">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln591">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(import_button_clicked), (gpointer)self);</a>
<a name="ln592"> </a>
<a name="ln593">  button = gtk_button_new_with_label(C_(&quot;verb&quot;, &quot;export&quot;));</a>
<a name="ln594">  d-&gt;export_button = button;</a>
<a name="ln595">  gtk_widget_set_tooltip_text(button, _(&quot;export all tags to a Lightroom keyword file&quot;));</a>
<a name="ln596">  dt_gui_add_help_link(button, &quot;tagging.html#tagging_usage&quot;);</a>
<a name="ln597">  gtk_box_pack_start(hbox, button, FALSE, TRUE, 0);</a>
<a name="ln598">  g_signal_connect(G_OBJECT(button), &quot;clicked&quot;, G_CALLBACK(export_button_clicked), (gpointer)self);</a>
<a name="ln599"> </a>
<a name="ln600">  gtk_box_pack_start(box, GTK_WIDGET(hbox), FALSE, TRUE, 0);</a>
<a name="ln601"> </a>
<a name="ln602">  // add entry completion</a>
<a name="ln603">  GtkEntryCompletion *completion = gtk_entry_completion_new();</a>
<a name="ln604">  gtk_entry_completion_set_model(completion, gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;related)));</a>
<a name="ln605">  gtk_entry_completion_set_text_column(completion, 0);</a>
<a name="ln606">  gtk_entry_completion_set_inline_completion(completion, TRUE);</a>
<a name="ln607">  gtk_entry_set_completion(d-&gt;entry, completion);</a>
<a name="ln608"> </a>
<a name="ln609">  /* connect to mouse over id */</a>
<a name="ln610">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_MOUSE_OVER_IMAGE_CHANGE,</a>
<a name="ln611">                            G_CALLBACK(_lib_tagging_redraw_callback), self);</a>
<a name="ln612">  dt_control_signal_connect(darktable.signals, DT_SIGNAL_TAG_CHANGED,</a>
<a name="ln613">                            G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln614"> </a>
<a name="ln615">  update(self, 0);</a>
<a name="ln616">  set_keyword(self, d);</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln620">{</a>
<a name="ln621">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln622">  dt_gui_key_accel_block_on_focus_disconnect(GTK_WIDGET(d-&gt;entry));</a>
<a name="ln623">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_tagging_redraw_callback), self);</a>
<a name="ln624">  dt_control_signal_disconnect(darktable.signals, G_CALLBACK(_lib_tagging_tags_changed_callback), self);</a>
<a name="ln625">  free(self-&gt;data);</a>
<a name="ln626">  self-&gt;data = NULL;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">// http://stackoverflow.com/questions/4631388/transparent-floating-gtkentry</a>
<a name="ln630">static gboolean _lib_tagging_tag_key_press(GtkWidget *entry, GdkEventKey *event, dt_lib_module_t *self)</a>
<a name="ln631">{</a>
<a name="ln632">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln633">  switch(event-&gt;keyval)</a>
<a name="ln634">  {</a>
<a name="ln635">    case GDK_KEY_Escape:</a>
<a name="ln636">      gtk_widget_destroy(d-&gt;floating_tag_window);</a>
<a name="ln637">      return TRUE;</a>
<a name="ln638">    case GDK_KEY_Tab:</a>
<a name="ln639">      return TRUE;</a>
<a name="ln640">    case GDK_KEY_Return:</a>
<a name="ln641">    case GDK_KEY_KP_Enter:</a>
<a name="ln642">    {</a>
<a name="ln643">      const gchar *tag = gtk_entry_get_text(GTK_ENTRY(entry));</a>
<a name="ln644">      // both these functions can deal with -1 for all selected images. no need for extra code in here!</a>
<a name="ln645">      dt_tag_attach_string_list(tag, d-&gt;floating_tag_imgid);</a>
<a name="ln646">      dt_image_synch_xmp(d-&gt;floating_tag_imgid);</a>
<a name="ln647">      update(self, 1);</a>
<a name="ln648">      update(self, 0);</a>
<a name="ln649">      gtk_widget_destroy(d-&gt;floating_tag_window);</a>
<a name="ln650">      dt_control_signal_raise(darktable.signals, DT_SIGNAL_TAG_CHANGED);</a>
<a name="ln651">      return TRUE;</a>
<a name="ln652">    }</a>
<a name="ln653">  }</a>
<a name="ln654">  return FALSE; /* event not handled */</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">static gboolean _lib_tagging_tag_destroy(GtkWidget *widget, GdkEvent *event, gpointer user_data)</a>
<a name="ln658">{</a>
<a name="ln659">  gtk_widget_destroy(GTK_WIDGET(user_data));</a>
<a name="ln660">  return FALSE;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">static gboolean _match_selected_func(GtkEntryCompletion *completion, GtkTreeModel *model, GtkTreeIter *iter, gpointer user_data)</a>
<a name="ln664">{</a>
<a name="ln665">  char *tag = NULL;</a>
<a name="ln666">  int column = gtk_entry_completion_get_text_column(completion);</a>
<a name="ln667"> </a>
<a name="ln668">  if(gtk_tree_model_get_column_type(model, column) != G_TYPE_STRING) return TRUE;</a>
<a name="ln669"> </a>
<a name="ln670">  GtkEditable *e = (GtkEditable *)gtk_entry_completion_get_entry(completion);</a>
<a name="ln671">  if(!GTK_IS_EDITABLE(e))</a>
<a name="ln672">  {</a>
<a name="ln673">    return FALSE;</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  gtk_tree_model_get(model, iter, column, &amp;tag, -1);</a>
<a name="ln677"> </a>
<a name="ln678">  gint cut_off, cur_pos = gtk_editable_get_position(e);</a>
<a name="ln679"> </a>
<a name="ln680">  gchar *currentText = gtk_editable_get_chars(e, 0, -1);</a>
<a name="ln681">  const gchar *lastTag = g_strrstr(currentText, &quot;,&quot;);</a>
<a name="ln682">  if(lastTag == NULL)</a>
<a name="ln683">  {</a>
<a name="ln684">    cut_off = 0;</a>
<a name="ln685">  }</a>
<a name="ln686">  else</a>
<a name="ln687">  {</a>
<a name="ln688">    cut_off = (int)(g_utf8_strlen(currentText, -1) - g_utf8_strlen(lastTag, -1))+1;</a>
<a name="ln689">  }</a>
<a name="ln690">  free(currentText);</a>
<a name="ln691"> </a>
<a name="ln692">  gtk_editable_delete_text(e, cut_off, cur_pos);</a>
<a name="ln693">  cur_pos = cut_off;</a>
<a name="ln694">  gtk_editable_insert_text(e, tag, -1, &amp;cur_pos);</a>
<a name="ln695">  gtk_editable_set_position(e, cur_pos);</a>
<a name="ln696">  return TRUE;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">static gboolean _completion_match_func(GtkEntryCompletion *completion, const gchar *key, GtkTreeIter *iter,</a>
<a name="ln700">                                       gpointer user_data)</a>
<a name="ln701">{</a>
<a name="ln702">  gboolean res = FALSE;</a>
<a name="ln703"> </a>
<a name="ln704">  GtkEditable *e = (GtkEditable *)gtk_entry_completion_get_entry(completion);</a>
<a name="ln705"> </a>
<a name="ln706">  if(!GTK_IS_EDITABLE(e))</a>
<a name="ln707">  {</a>
<a name="ln708">    return FALSE;</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  gint cur_pos = gtk_editable_get_position(e);</a>
<a name="ln712">  gboolean onLastTag = (g_strstr_len(&amp;key[cur_pos], -1, &quot;,&quot;) == NULL);</a>
<a name="ln713">  if(!onLastTag)</a>
<a name="ln714">  {</a>
<a name="ln715">    return FALSE;</a>
<a name="ln716">  }</a>
<a name="ln717"> </a>
<a name="ln718"> </a>
<a name="ln719">  char *tag = NULL;</a>
<a name="ln720">  GtkTreeModel *model = gtk_entry_completion_get_model(completion);</a>
<a name="ln721">  int column = gtk_entry_completion_get_text_column(completion);</a>
<a name="ln722"> </a>
<a name="ln723">  if(gtk_tree_model_get_column_type(model, column) != G_TYPE_STRING) return FALSE;</a>
<a name="ln724"> </a>
<a name="ln725">  gtk_tree_model_get(model, iter, column, &amp;tag, -1);</a>
<a name="ln726"> </a>
<a name="ln727">  const gchar *lastTag = g_strrstr(key, &quot;,&quot;);</a>
<a name="ln728">  if(lastTag != NULL)</a>
<a name="ln729">  {</a>
<a name="ln730">    lastTag++;</a>
<a name="ln731">  }</a>
<a name="ln732">  else</a>
<a name="ln733">  {</a>
<a name="ln734">    lastTag = key;</a>
<a name="ln735">  }</a>
<a name="ln736">  if(lastTag[0] == '\0' &amp;&amp; key[0] != '\0')</a>
<a name="ln737">  {</a>
<a name="ln738">    return FALSE;</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  if(tag)</a>
<a name="ln742">  {</a>
<a name="ln743">    char *normalized = g_utf8_normalize(tag, -1, G_NORMALIZE_ALL);</a>
<a name="ln744">    if(normalized)</a>
<a name="ln745">    {</a>
<a name="ln746">      char *casefold = g_utf8_casefold(normalized, -1);</a>
<a name="ln747">      if(casefold)</a>
<a name="ln748">      {</a>
<a name="ln749">        res = g_strstr_len(casefold, -1, lastTag) != NULL;</a>
<a name="ln750">      }</a>
<a name="ln751">      g_free(casefold);</a>
<a name="ln752">    }</a>
<a name="ln753">    g_free(normalized);</a>
<a name="ln754">    g_free(tag);</a>
<a name="ln755">  }</a>
<a name="ln756"> </a>
<a name="ln757">  return res;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">static gboolean _lib_tagging_tag_show(GtkAccelGroup *accel_group, GObject *acceleratable, guint keyval,</a>
<a name="ln761">                                      GdkModifierType modifier, dt_lib_module_t *self)</a>
<a name="ln762">{</a>
<a name="ln763">  int mouse_over_id = -1;</a>
<a name="ln764">  int zoom = dt_conf_get_int(&quot;plugins/lighttable/images_in_row&quot;);</a>
<a name="ln765"> </a>
<a name="ln766">  // the order is:</a>
<a name="ln767">  // if(zoom == 1) =&gt; currently shown image</a>
<a name="ln768">  // else if(selection not empty) =&gt; selected images</a>
<a name="ln769">  // else if(cursor over image) =&gt; hovered image</a>
<a name="ln770">  // else =&gt; return</a>
<a name="ln771">  if(zoom == 1 || dt_collection_get_selected_count(darktable.collection) == 0)</a>
<a name="ln772">  {</a>
<a name="ln773">    mouse_over_id = dt_control_get_mouse_over_id();</a>
<a name="ln774">    if(mouse_over_id &lt; 0) return TRUE;</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777">  dt_lib_tagging_t *d = (dt_lib_tagging_t *)self-&gt;data;</a>
<a name="ln778">  d-&gt;floating_tag_imgid = mouse_over_id;</a>
<a name="ln779"> </a>
<a name="ln780">  gint x, y;</a>
<a name="ln781">  gint px, py, w, h;</a>
<a name="ln782">  GtkWidget *window = dt_ui_main_window(darktable.gui-&gt;ui);</a>
<a name="ln783">  GtkWidget *center = dt_ui_center(darktable.gui-&gt;ui);</a>
<a name="ln784">  gdk_window_get_origin(gtk_widget_get_window(center), &amp;px, &amp;py);</a>
<a name="ln785"> </a>
<a name="ln786">  w = gdk_window_get_width(gtk_widget_get_window(center));</a>
<a name="ln787">  h = gdk_window_get_height(gtk_widget_get_window(center));</a>
<a name="ln788"> </a>
<a name="ln789">  x = px + 0.5 * (w - FLOATING_ENTRY_WIDTH);</a>
<a name="ln790">  y = py + h - 50;</a>
<a name="ln791"> </a>
<a name="ln792">  /* put the floating box at the mouse pointer */</a>
<a name="ln793">  //   gint pointerx, pointery;</a>
<a name="ln794">  //   GdkDevice *device =</a>
<a name="ln795">  //   gdk_device_manager_get_client_pointer(gdk_display_get_device_manager(gtk_widget_get_display(widget)));</a>
<a name="ln796">  //   gdk_window_get_device_position (gtk_widget_get_window (widget), device, &amp;pointerx, &amp;pointery, NULL);</a>
<a name="ln797">  //   x = px + pointerx + 1;</a>
<a name="ln798">  //   y = py + pointery + 1;</a>
<a name="ln799"> </a>
<a name="ln800">  d-&gt;floating_tag_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);</a>
<a name="ln801">#ifdef GDK_WINDOWING_QUARTZ</a>
<a name="ln802">  dt_osx_disallow_fullscreen(d-&gt;floating_tag_window);</a>
<a name="ln803">#endif</a>
<a name="ln804">  /* stackoverflow.com/questions/1925568/how-to-give-keyboard-focus-to-a-pop-up-gtk-window */</a>
<a name="ln805">  gtk_widget_set_can_focus(d-&gt;floating_tag_window, TRUE);</a>
<a name="ln806">  gtk_window_set_decorated(GTK_WINDOW(d-&gt;floating_tag_window), FALSE);</a>
<a name="ln807">  gtk_window_set_type_hint(GTK_WINDOW(d-&gt;floating_tag_window), GDK_WINDOW_TYPE_HINT_POPUP_MENU);</a>
<a name="ln808">  gtk_window_set_transient_for(GTK_WINDOW(d-&gt;floating_tag_window), GTK_WINDOW(window));</a>
<a name="ln809">  gtk_widget_set_opacity(d-&gt;floating_tag_window, 0.8);</a>
<a name="ln810">  gtk_window_move(GTK_WINDOW(d-&gt;floating_tag_window), x, y);</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">  GtkWidget *entry = gtk_entry_new();</a>
<a name="ln814">  gtk_widget_set_size_request(entry, FLOATING_ENTRY_WIDTH, -1);</a>
<a name="ln815">  gtk_widget_add_events(entry, GDK_FOCUS_CHANGE_MASK);</a>
<a name="ln816"> </a>
<a name="ln817">  GtkEntryCompletion *completion = gtk_entry_completion_new();</a>
<a name="ln818">  gtk_entry_completion_set_model(completion, gtk_tree_view_get_model(GTK_TREE_VIEW(d-&gt;related)));</a>
<a name="ln819">  gtk_entry_completion_set_text_column(completion, 0);</a>
<a name="ln820">  gtk_entry_completion_set_inline_completion(completion, TRUE);</a>
<a name="ln821">  gtk_entry_completion_set_popup_set_width(completion, FALSE);</a>
<a name="ln822">  g_signal_connect(G_OBJECT(completion), &quot;match-selected&quot;, G_CALLBACK(_match_selected_func), self);</a>
<a name="ln823">  gtk_entry_completion_set_match_func(completion, _completion_match_func, NULL, NULL);</a>
<a name="ln824">  gtk_entry_set_completion(GTK_ENTRY(entry), completion);</a>
<a name="ln825"> </a>
<a name="ln826">  gtk_editable_select_region(GTK_EDITABLE(entry), 0, -1);</a>
<a name="ln827">  gtk_container_add(GTK_CONTAINER(d-&gt;floating_tag_window), entry);</a>
<a name="ln828">  g_signal_connect(entry, &quot;focus-out-event&quot;, G_CALLBACK(_lib_tagging_tag_destroy), d-&gt;floating_tag_window);</a>
<a name="ln829">  g_signal_connect(entry, &quot;key-press-event&quot;, G_CALLBACK(_lib_tagging_tag_key_press), self);</a>
<a name="ln830"> </a>
<a name="ln831">  gtk_widget_show_all(d-&gt;floating_tag_window);</a>
<a name="ln832">  gtk_widget_grab_focus(entry);</a>
<a name="ln833">  gtk_window_present(GTK_WINDOW(d-&gt;floating_tag_window));</a>
<a name="ln834"> </a>
<a name="ln835">  return TRUE;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln839">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln840">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'd'. Check lines: 478, 476.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
