
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2009--2011 johannes hanika.</a>
<a name="ln4">    copyright (c) 2012 tobias ellinghaus.</a>
<a name="ln5">    copyright (c) 2014 henrik andersson.</a>
<a name="ln6"> </a>
<a name="ln7">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln8">    it under the terms of the GNU General Public License as published by</a>
<a name="ln9">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln10">    (at your option) any later version.</a>
<a name="ln11"> </a>
<a name="ln12">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln13">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln15">    GNU General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">    You should have received a copy of the GNU General Public License</a>
<a name="ln18">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln19">*/</a>
<a name="ln20">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln21">#include &quot;common/camera_control.h&quot;</a>
<a name="ln22">#include &quot;common/darktable.h&quot;</a>
<a name="ln23">#include &quot;common/image_cache.h&quot;</a>
<a name="ln24">#include &quot;common/mipmap_cache.h&quot;</a>
<a name="ln25">#include &quot;control/conf.h&quot;</a>
<a name="ln26">#include &quot;control/control.h&quot;</a>
<a name="ln27">#include &quot;control/jobs.h&quot;</a>
<a name="ln28">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln29">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln30">#include &quot;gui/gtk.h&quot;</a>
<a name="ln31">#include &quot;gui/guides.h&quot;</a>
<a name="ln32">#include &quot;libs/lib.h&quot;</a>
<a name="ln33">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln34">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">typedef enum dt_lib_live_view_flip_t</a>
<a name="ln37">{</a>
<a name="ln38">  FLAG_FLIP_NONE = 0,</a>
<a name="ln39">  FLAG_FLIP_HORIZONTAL = 1&lt;&lt;0,</a>
<a name="ln40">  FLAG_FLIP_VERTICAL = 1&lt;&lt;1,</a>
<a name="ln41">  FLAG_FLIP_BOTH = FLAG_FLIP_HORIZONTAL|FLAG_FLIP_VERTICAL</a>
<a name="ln42">} dt_lib_live_view_flip_t;</a>
<a name="ln43"> </a>
<a name="ln44">typedef enum dt_lib_live_view_overlay_t</a>
<a name="ln45">{</a>
<a name="ln46">  OVERLAY_NONE = 0,</a>
<a name="ln47">  OVERLAY_SELECTED,</a>
<a name="ln48">  OVERLAY_ID</a>
<a name="ln49">} dt_lib_live_view_overlay_t;</a>
<a name="ln50"> </a>
<a name="ln51">#define HANDLE_SIZE 0.02</a>
<a name="ln52"> </a>
<a name="ln53">static const cairo_operator_t _overlay_modes[] = {</a>
<a name="ln54">  CAIRO_OPERATOR_OVER, CAIRO_OPERATOR_XOR, CAIRO_OPERATOR_ADD, CAIRO_OPERATOR_SATURATE</a>
<a name="ln55">#if(CAIRO_VERSION &gt;= CAIRO_VERSION_ENCODE(1, 10, 0))</a>
<a name="ln56">  ,</a>
<a name="ln57">  CAIRO_OPERATOR_MULTIPLY, CAIRO_OPERATOR_SCREEN, CAIRO_OPERATOR_OVERLAY, CAIRO_OPERATOR_DARKEN,</a>
<a name="ln58">  CAIRO_OPERATOR_LIGHTEN, CAIRO_OPERATOR_COLOR_DODGE, CAIRO_OPERATOR_COLOR_BURN, CAIRO_OPERATOR_HARD_LIGHT,</a>
<a name="ln59">  CAIRO_OPERATOR_SOFT_LIGHT, CAIRO_OPERATOR_DIFFERENCE, CAIRO_OPERATOR_EXCLUSION, CAIRO_OPERATOR_HSL_HUE,</a>
<a name="ln60">  CAIRO_OPERATOR_HSL_SATURATION, CAIRO_OPERATOR_HSL_COLOR, CAIRO_OPERATOR_HSL_LUMINOSITY</a>
<a name="ln61">#endif</a>
<a name="ln62">};</a>
<a name="ln63"> </a>
<a name="ln64">DT_MODULE(1)</a>
<a name="ln65"> </a>
<a name="ln66">typedef struct dt_lib_live_view_t</a>
<a name="ln67">{</a>
<a name="ln68">  int imgid;</a>
<a name="ln69">  int splitline_rotation;</a>
<a name="ln70">  double overlay_x0, overlay_x1, overlay_y0, overlay_y1;</a>
<a name="ln71">  double splitline_x, splitline_y; // 0..1</a>
<a name="ln72">  gboolean splitline_dragging;</a>
<a name="ln73"> </a>
<a name="ln74">  GtkWidget *live_view, *live_view_zoom, *rotate_ccw, *rotate_cw, *flip;</a>
<a name="ln75">  GtkWidget *focus_out_small, *focus_out_big, *focus_in_small, *focus_in_big;</a>
<a name="ln76">  GtkWidget *guide_selector, *flip_guides, *guides_widgets;</a>
<a name="ln77">  GList *guides_widgets_list;</a>
<a name="ln78">  GtkWidget *overlay, *overlay_id_box, *overlay_id, *overlay_mode, *overlay_splitline;</a>
<a name="ln79">} dt_lib_live_view_t;</a>
<a name="ln80"> </a>
<a name="ln81">static void guides_presets_set_visibility(dt_lib_live_view_t *lib, int which)</a>
<a name="ln82">{</a>
<a name="ln83">  if(which == 0)</a>
<a name="ln84">  {</a>
<a name="ln85">    gtk_widget_set_no_show_all(lib-&gt;guides_widgets, TRUE);</a>
<a name="ln86">    gtk_widget_hide(lib-&gt;guides_widgets);</a>
<a name="ln87">    gtk_widget_set_no_show_all(lib-&gt;flip_guides, TRUE);</a>
<a name="ln88">    gtk_widget_hide(lib-&gt;flip_guides);</a>
<a name="ln89">  }</a>
<a name="ln90">  else</a>
<a name="ln91">  {</a>
<a name="ln92">    GtkWidget *widget = g_list_nth_data(lib-&gt;guides_widgets_list, which - 1);</a>
<a name="ln93">    if(widget)</a>
<a name="ln94">    {</a>
<a name="ln95">      gtk_widget_set_no_show_all(lib-&gt;guides_widgets, FALSE);</a>
<a name="ln96">      gtk_widget_show_all(lib-&gt;guides_widgets);</a>
<a name="ln97">      gtk_stack_set_visible_child(GTK_STACK(lib-&gt;guides_widgets), widget);</a>
<a name="ln98">    }</a>
<a name="ln99">    else</a>
<a name="ln100">    {</a>
<a name="ln101">      gtk_widget_set_no_show_all(lib-&gt;guides_widgets, TRUE);</a>
<a name="ln102">      gtk_widget_hide(lib-&gt;guides_widgets);</a>
<a name="ln103">    }</a>
<a name="ln104">    gtk_widget_set_no_show_all(lib-&gt;flip_guides, FALSE);</a>
<a name="ln105">    gtk_widget_show_all(lib-&gt;flip_guides);</a>
<a name="ln106">  }</a>
<a name="ln107"> </a>
<a name="ln108">  // TODO: add a support_flip flag to guides to hide the flip gui?</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">static void guides_presets_changed(GtkWidget *combo, dt_lib_live_view_t *lib)</a>
<a name="ln112">{</a>
<a name="ln113">  int which = dt_bauhaus_combobox_get(combo);</a>
<a name="ln114">  guides_presets_set_visibility(lib, which);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static void overlay_changed(GtkWidget *combo, dt_lib_live_view_t *lib)</a>
<a name="ln118">{</a>
<a name="ln119">  int which = dt_bauhaus_combobox_get(combo);</a>
<a name="ln120">  if(which == OVERLAY_NONE)</a>
<a name="ln121">  {</a>
<a name="ln122">    gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_mode), FALSE);</a>
<a name="ln123">    gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_splitline), FALSE);</a>
<a name="ln124">  }</a>
<a name="ln125">  else</a>
<a name="ln126">  {</a>
<a name="ln127">    gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_mode), TRUE);</a>
<a name="ln128">    gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_splitline), TRUE);</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  if(which == OVERLAY_ID)</a>
<a name="ln132">    gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_id_box), TRUE);</a>
<a name="ln133">  else</a>
<a name="ln134">    gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_id_box), FALSE);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138">const char *name(dt_lib_module_t *self)</a>
<a name="ln139">{</a>
<a name="ln140">  return _(&quot;live view&quot;);</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">const char **views(dt_lib_module_t *self)</a>
<a name="ln144">{</a>
<a name="ln145">  static const char *v[] = {&quot;tethering&quot;, NULL};</a>
<a name="ln146">  return v;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln150">{</a>
<a name="ln151">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln156">{</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">int position()</a>
<a name="ln160">{</a>
<a name="ln161">  return 998;</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln165">{</a>
<a name="ln166">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;toggle live view&quot;), GDK_KEY_v, 0);</a>
<a name="ln167">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;zoom live view&quot;), GDK_KEY_z, 0);</a>
<a name="ln168">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rotate 90 degrees CCW&quot;), 0, 0);</a>
<a name="ln169">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;rotate 90 degrees CW&quot;), 0, 0);</a>
<a name="ln170">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;flip horizontally&quot;), 0, 0);</a>
<a name="ln171">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;move focus point in (big steps)&quot;), 0, 0);</a>
<a name="ln172">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;move focus point in (small steps)&quot;), 0, 0);</a>
<a name="ln173">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;move focus point out (small steps)&quot;), 0, 0);</a>
<a name="ln174">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;move focus point out (big steps)&quot;), 0, 0);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln178">{</a>
<a name="ln179">  dt_lib_live_view_t *lib = (dt_lib_live_view_t *)self-&gt;data;</a>
<a name="ln180"> </a>
<a name="ln181">  dt_accel_connect_button_lib(self, &quot;toggle live view&quot;, GTK_WIDGET(lib-&gt;live_view));</a>
<a name="ln182">  dt_accel_connect_button_lib(self, &quot;zoom live view&quot;, GTK_WIDGET(lib-&gt;live_view_zoom));</a>
<a name="ln183">  dt_accel_connect_button_lib(self, &quot;rotate 90 degrees CCW&quot;, GTK_WIDGET(lib-&gt;rotate_ccw));</a>
<a name="ln184">  dt_accel_connect_button_lib(self, &quot;rotate 90 degrees CW&quot;, GTK_WIDGET(lib-&gt;rotate_cw));</a>
<a name="ln185">  dt_accel_connect_button_lib(self, &quot;flip horizontally&quot;, GTK_WIDGET(lib-&gt;flip));</a>
<a name="ln186">  dt_accel_connect_button_lib(self, &quot;move focus point in (big steps)&quot;, GTK_WIDGET(lib-&gt;focus_in_big));</a>
<a name="ln187">  dt_accel_connect_button_lib(self, &quot;move focus point in (small steps)&quot;, GTK_WIDGET(lib-&gt;focus_in_small));</a>
<a name="ln188">  dt_accel_connect_button_lib(self, &quot;move focus point out (small steps)&quot;, GTK_WIDGET(lib-&gt;focus_out_small));</a>
<a name="ln189">  dt_accel_connect_button_lib(self, &quot;move focus point out (big steps)&quot;, GTK_WIDGET(lib-&gt;focus_out_big));</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">static void _rotate_ccw(GtkWidget *widget, gpointer user_data)</a>
<a name="ln193">{</a>
<a name="ln194">  dt_camera_t *cam = (dt_camera_t *)darktable.camctl-&gt;active_camera;</a>
<a name="ln195">  cam-&gt;live_view_rotation = (cam-&gt;live_view_rotation + 1) % 4; // 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; ...</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">static void _rotate_cw(GtkWidget *widget, gpointer user_data)</a>
<a name="ln199">{</a>
<a name="ln200">  dt_camera_t *cam = (dt_camera_t *)darktable.camctl-&gt;active_camera;</a>
<a name="ln201">  cam-&gt;live_view_rotation = (cam-&gt;live_view_rotation + 3) % 4; // 0 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 0 -&gt; ...</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">// Congratulations to Simon for being the first one recognizing live view in a screen shot ^^</a>
<a name="ln205">static void _toggle_live_view_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln206">{</a>
<a name="ln207">  if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)) == TRUE)</a>
<a name="ln208">  {</a>
<a name="ln209">    if(dt_camctl_camera_start_live_view(darktable.camctl) == FALSE)</a>
<a name="ln210">      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(widget), FALSE);</a>
<a name="ln211">  }</a>
<a name="ln212">  else</a>
<a name="ln213">  {</a>
<a name="ln214">    dt_camctl_camera_stop_live_view(darktable.camctl);</a>
<a name="ln215">  }</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">// TODO: using a toggle button would be better, but this setting can also be changed by right clicking on the</a>
<a name="ln219">// canvas (src/views/capture.c).</a>
<a name="ln220">//       maybe using a signal would work? i have no idea.</a>
<a name="ln221">static void _zoom_live_view_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln222">{</a>
<a name="ln223">  dt_camera_t *cam = (dt_camera_t *)darktable.camctl-&gt;active_camera;</a>
<a name="ln224">  if(cam-&gt;is_live_viewing)</a>
<a name="ln225">  {</a>
<a name="ln226">    cam-&gt;live_view_zoom = !cam-&gt;live_view_zoom;</a>
<a name="ln227">    if(cam-&gt;live_view_zoom == TRUE)</a>
<a name="ln228">      dt_camctl_camera_set_property_string(darktable.camctl, NULL, &quot;eoszoom&quot;, &quot;5&quot;);</a>
<a name="ln229">    else</a>
<a name="ln230">      dt_camctl_camera_set_property_string(darktable.camctl, NULL, &quot;eoszoom&quot;, &quot;1&quot;);</a>
<a name="ln231">  }</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">static void _focus_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln235">{</a>
<a name="ln236">  int focus = GPOINTER_TO_INT(user_data);</a>
<a name="ln237">  dt_camctl_camera_set_property_choice(darktable.camctl, NULL, &quot;manualfocusdrive&quot;, focus);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">static void _toggle_flip_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln241">{</a>
<a name="ln242">  dt_camera_t *cam = (dt_camera_t *)darktable.camctl-&gt;active_camera;</a>
<a name="ln243">  cam-&gt;live_view_flip = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">static void _overlay_id_changed(GtkWidget *widget, gpointer user_data)</a>
<a name="ln247">{</a>
<a name="ln248">  dt_lib_live_view_t *lib = (dt_lib_live_view_t *)user_data;</a>
<a name="ln249">  lib-&gt;imgid = gtk_spin_button_get_value(GTK_SPIN_BUTTON(widget));</a>
<a name="ln250">  dt_conf_set_int(&quot;plugins/lighttable/live_view/overlay_imgid&quot;, lib-&gt;imgid);</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">static void _overlay_mode_changed(GtkWidget *combo, gpointer user_data)</a>
<a name="ln254">{</a>
<a name="ln255">  dt_conf_set_int(&quot;plugins/lighttable/live_view/overlay_mode&quot;, dt_bauhaus_combobox_get(combo));</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">static void _overlay_splitline_changed(GtkWidget *combo, gpointer user_data)</a>
<a name="ln259">{</a>
<a name="ln260">  dt_conf_set_int(&quot;plugins/lighttable/live_view/splitline&quot;, dt_bauhaus_combobox_get(combo));</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">void gui_init(dt_lib_module_t *self)</a>
<a name="ln264">{</a>
<a name="ln265">  self-&gt;data = calloc(1, sizeof(dt_lib_live_view_t));</a>
<a name="ln266"> </a>
<a name="ln267">  // Setup lib data</a>
<a name="ln268">  dt_lib_live_view_t *lib = self-&gt;data;</a>
<a name="ln269">  lib-&gt;splitline_x = lib-&gt;splitline_y = 0.5;</a>
<a name="ln270"> </a>
<a name="ln271">  // Setup gui</a>
<a name="ln272">  self-&gt;widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);</a>
<a name="ln273">  dt_gui_add_help_link(self-&gt;widget, &quot;live_view.html#live_view&quot;);</a>
<a name="ln274">  GtkWidget *box;</a>
<a name="ln275"> </a>
<a name="ln276">  box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln277">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), box, TRUE, TRUE, 0);</a>
<a name="ln278">  lib-&gt;live_view = dtgtk_togglebutton_new(dtgtk_cairo_paint_eye, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln279">  lib-&gt;live_view_zoom = dtgtk_button_new(</a>
<a name="ln280">      dtgtk_cairo_paint_zoom, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL); // TODO: see _zoom_live_view_clicked</a>
<a name="ln281">  lib-&gt;rotate_ccw = dtgtk_button_new(dtgtk_cairo_paint_refresh, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL);</a>
<a name="ln282">  lib-&gt;rotate_cw = dtgtk_button_new(dtgtk_cairo_paint_refresh,</a>
<a name="ln283">                                    CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | CPF_DIRECTION_UP, NULL);</a>
<a name="ln284">  lib-&gt;flip = dtgtk_togglebutton_new(dtgtk_cairo_paint_flip,</a>
<a name="ln285">                                     CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | CPF_DIRECTION_UP, NULL);</a>
<a name="ln286"> </a>
<a name="ln287">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;live_view, TRUE, TRUE, 0);</a>
<a name="ln288">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;live_view_zoom, TRUE, TRUE, 0);</a>
<a name="ln289">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;rotate_ccw, TRUE, TRUE, 0);</a>
<a name="ln290">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;rotate_cw, TRUE, TRUE, 0);</a>
<a name="ln291">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;flip, TRUE, TRUE, 0);</a>
<a name="ln292"> </a>
<a name="ln293">  gtk_widget_set_tooltip_text(lib-&gt;live_view, _(&quot;toggle live view&quot;));</a>
<a name="ln294">  gtk_widget_set_tooltip_text(lib-&gt;live_view_zoom, _(&quot;zoom live view&quot;));</a>
<a name="ln295">  gtk_widget_set_tooltip_text(lib-&gt;rotate_ccw, _(&quot;rotate 90 degrees ccw&quot;));</a>
<a name="ln296">  gtk_widget_set_tooltip_text(lib-&gt;rotate_cw, _(&quot;rotate 90 degrees cw&quot;));</a>
<a name="ln297">  gtk_widget_set_tooltip_text(lib-&gt;flip, _(&quot;flip live view horizontally&quot;));</a>
<a name="ln298"> </a>
<a name="ln299">  g_signal_connect(G_OBJECT(lib-&gt;live_view), &quot;clicked&quot;, G_CALLBACK(_toggle_live_view_clicked), lib);</a>
<a name="ln300">  g_signal_connect(G_OBJECT(lib-&gt;live_view_zoom), &quot;clicked&quot;, G_CALLBACK(_zoom_live_view_clicked), lib);</a>
<a name="ln301">  g_signal_connect(G_OBJECT(lib-&gt;rotate_ccw), &quot;clicked&quot;, G_CALLBACK(_rotate_ccw), lib);</a>
<a name="ln302">  g_signal_connect(G_OBJECT(lib-&gt;rotate_cw), &quot;clicked&quot;, G_CALLBACK(_rotate_cw), lib);</a>
<a name="ln303">  g_signal_connect(G_OBJECT(lib-&gt;flip), &quot;clicked&quot;, G_CALLBACK(_toggle_flip_clicked), lib);</a>
<a name="ln304"> </a>
<a name="ln305">  // focus buttons</a>
<a name="ln306">  box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln307">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), box, TRUE, TRUE, 0);</a>
<a name="ln308">  lib-&gt;focus_in_big = dtgtk_button_new(dtgtk_cairo_paint_solid_triangle,</a>
<a name="ln309">                                       CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | CPF_DIRECTION_LEFT, NULL);</a>
<a name="ln310">  lib-&gt;focus_in_small</a>
<a name="ln311">      = dtgtk_button_new(dtgtk_cairo_paint_arrow, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER</a>
<a name="ln312">                                                  | CPF_DIRECTION_LEFT, NULL); // TODO icon not centered</a>
<a name="ln313">  lib-&gt;focus_out_small = dtgtk_button_new(dtgtk_cairo_paint_arrow, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER</a>
<a name="ln314">                                                                   | CPF_DIRECTION_RIGHT, NULL); // TODO same here</a>
<a name="ln315">  lib-&gt;focus_out_big = dtgtk_button_new(dtgtk_cairo_paint_solid_triangle,</a>
<a name="ln316">                                        CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER | CPF_DIRECTION_RIGHT, NULL);</a>
<a name="ln317"> </a>
<a name="ln318">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;focus_in_big, TRUE, TRUE, 0);</a>
<a name="ln319">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;focus_in_small, TRUE, TRUE, 0);</a>
<a name="ln320">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;focus_out_small, TRUE, TRUE, 0);</a>
<a name="ln321">  gtk_box_pack_start(GTK_BOX(box), lib-&gt;focus_out_big, TRUE, TRUE, 0);</a>
<a name="ln322"> </a>
<a name="ln323">  gtk_widget_set_tooltip_text(lib-&gt;focus_in_big, _(&quot;move focus point in (big steps)&quot;));</a>
<a name="ln324">  gtk_widget_set_tooltip_text(lib-&gt;focus_in_small, _(&quot;move focus point in (small steps)&quot;));</a>
<a name="ln325">  gtk_widget_set_tooltip_text(lib-&gt;focus_out_small, _(&quot;move focus point out (small steps)&quot;));</a>
<a name="ln326">  gtk_widget_set_tooltip_text(lib-&gt;focus_out_big, _(&quot;move focus point out (big steps)&quot;));</a>
<a name="ln327"> </a>
<a name="ln328">  // Near 3</a>
<a name="ln329">  g_signal_connect(G_OBJECT(lib-&gt;focus_in_big), &quot;clicked&quot;, G_CALLBACK(_focus_button_clicked),</a>
<a name="ln330">                   GINT_TO_POINTER(2));</a>
<a name="ln331">  // Near 1</a>
<a name="ln332">  g_signal_connect(G_OBJECT(lib-&gt;focus_in_small), &quot;clicked&quot;, G_CALLBACK(_focus_button_clicked),</a>
<a name="ln333">                   GINT_TO_POINTER(0));</a>
<a name="ln334">  // Far 1</a>
<a name="ln335">  g_signal_connect(G_OBJECT(lib-&gt;focus_out_small), &quot;clicked&quot;, G_CALLBACK(_focus_button_clicked),</a>
<a name="ln336">                   GINT_TO_POINTER(4));</a>
<a name="ln337">  // Far 3</a>
<a name="ln338">  g_signal_connect(G_OBJECT(lib-&gt;focus_out_big), &quot;clicked&quot;, G_CALLBACK(_focus_button_clicked),</a>
<a name="ln339">                   GINT_TO_POINTER(6));</a>
<a name="ln340"> </a>
<a name="ln341">  // Guides</a>
<a name="ln342">  lib-&gt;guide_selector = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln343">  dt_bauhaus_widget_set_label(lib-&gt;guide_selector, NULL, _(&quot;guides&quot;));</a>
<a name="ln344">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;guide_selector, TRUE, TRUE, 0);</a>
<a name="ln345"> </a>
<a name="ln346">  lib-&gt;guides_widgets = gtk_stack_new();</a>
<a name="ln347">  gtk_stack_set_homogeneous(GTK_STACK(lib-&gt;guides_widgets), FALSE);</a>
<a name="ln348">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;guides_widgets, TRUE, TRUE, 0);</a>
<a name="ln349"> </a>
<a name="ln350">  dt_bauhaus_combobox_add(lib-&gt;guide_selector, _(&quot;none&quot;));</a>
<a name="ln351">  int i = 0;</a>
<a name="ln352">  for(GList *iter = darktable.guides; iter; iter = g_list_next(iter), i++)</a>
<a name="ln353">  {</a>
<a name="ln354">    GtkWidget *widget = NULL;</a>
<a name="ln355">    dt_guides_t *guide = (dt_guides_t *)iter-&gt;data;</a>
<a name="ln356">    dt_bauhaus_combobox_add(lib-&gt;guide_selector, _(guide-&gt;name));</a>
<a name="ln357">    if(guide-&gt;widget)</a>
<a name="ln358">    {</a>
<a name="ln359">      // generate some unique name so that we can have the same name several times</a>
<a name="ln360">      char name[5];</a>
<a name="ln361">      snprintf(name, sizeof(name), &quot;%d&quot;, i);</a>
<a name="ln362">      widget = guide-&gt;widget(NULL, guide-&gt;user_data);</a>
<a name="ln363">      gtk_widget_show_all(widget);</a>
<a name="ln364">      gtk_stack_add_named(GTK_STACK(lib-&gt;guides_widgets), widget, name);</a>
<a name="ln365">    }</a>
<a name="ln366">    lib-&gt;guides_widgets_list = g_list_append(lib-&gt;guides_widgets_list, widget);</a>
<a name="ln367">  }</a>
<a name="ln368">  gtk_widget_set_no_show_all(lib-&gt;guides_widgets, TRUE);</a>
<a name="ln369"> </a>
<a name="ln370">  gtk_widget_set_tooltip_text(lib-&gt;guide_selector, _(&quot;display guide lines to help compose your photograph&quot;));</a>
<a name="ln371">  g_signal_connect(G_OBJECT(lib-&gt;guide_selector), &quot;value-changed&quot;, G_CALLBACK(guides_presets_changed), lib);</a>
<a name="ln372"> </a>
<a name="ln373">  lib-&gt;flip_guides = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln374">  dt_bauhaus_widget_set_label(lib-&gt;flip_guides, NULL, _(&quot;flip&quot;));</a>
<a name="ln375">  dt_bauhaus_combobox_add(lib-&gt;flip_guides, _(&quot;none&quot;));</a>
<a name="ln376">  dt_bauhaus_combobox_add(lib-&gt;flip_guides, _(&quot;horizontally&quot;));</a>
<a name="ln377">  dt_bauhaus_combobox_add(lib-&gt;flip_guides, _(&quot;vertically&quot;));</a>
<a name="ln378">  dt_bauhaus_combobox_add(lib-&gt;flip_guides, _(&quot;both&quot;));</a>
<a name="ln379">  gtk_widget_set_tooltip_text(lib-&gt;flip_guides, _(&quot;flip guides&quot;));</a>
<a name="ln380">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;flip_guides, TRUE, TRUE, 0);</a>
<a name="ln381"> </a>
<a name="ln382">  lib-&gt;overlay = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln383">  dt_bauhaus_widget_set_label(lib-&gt;overlay, NULL, _(&quot;overlay&quot;));</a>
<a name="ln384">  dt_bauhaus_combobox_add(lib-&gt;overlay, _(&quot;none&quot;));</a>
<a name="ln385">  dt_bauhaus_combobox_add(lib-&gt;overlay, _(&quot;selected image&quot;));</a>
<a name="ln386">  dt_bauhaus_combobox_add(lib-&gt;overlay, _(&quot;id&quot;));</a>
<a name="ln387">  gtk_widget_set_tooltip_text(lib-&gt;overlay, _(&quot;overlay another image over the live view&quot;));</a>
<a name="ln388">  g_signal_connect(G_OBJECT(lib-&gt;overlay), &quot;value-changed&quot;, G_CALLBACK(overlay_changed), lib);</a>
<a name="ln389">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;overlay, TRUE, TRUE, 0);</a>
<a name="ln390"> </a>
<a name="ln391">  lib-&gt;overlay_id_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);</a>
<a name="ln392">  GtkWidget *label = gtk_label_new(_(&quot;image id&quot;));</a>
<a name="ln393">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln394">  lib-&gt;overlay_id = gtk_spin_button_new_with_range(0, 1000000000, 1);</a>
<a name="ln395">  gtk_spin_button_set_digits(GTK_SPIN_BUTTON(lib-&gt;overlay_id), 0);</a>
<a name="ln396">  gtk_widget_set_tooltip_text(lib-&gt;overlay_id, _(&quot;enter image id of the overlay manually&quot;));</a>
<a name="ln397">  g_signal_connect(G_OBJECT(lib-&gt;overlay_id), &quot;value-changed&quot;, G_CALLBACK(_overlay_id_changed), lib);</a>
<a name="ln398">  gtk_spin_button_set_value(GTK_SPIN_BUTTON(lib-&gt;overlay_id),</a>
<a name="ln399">                            dt_conf_get_int(&quot;plugins/lighttable/live_view/overlay_imgid&quot;));</a>
<a name="ln400">  gtk_box_pack_start(GTK_BOX(lib-&gt;overlay_id_box), label, TRUE, TRUE, 0);</a>
<a name="ln401">  gtk_box_pack_start(GTK_BOX(lib-&gt;overlay_id_box), lib-&gt;overlay_id, TRUE, TRUE, 0);</a>
<a name="ln402">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;overlay_id_box, TRUE, TRUE, 0);</a>
<a name="ln403">  gtk_widget_show(lib-&gt;overlay_id);</a>
<a name="ln404">  gtk_widget_show(label);</a>
<a name="ln405"> </a>
<a name="ln406">  lib-&gt;overlay_mode = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln407">  dt_bauhaus_widget_set_label(lib-&gt;overlay_mode, NULL, _(&quot;overlay mode&quot;));</a>
<a name="ln408">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;normal&quot;));</a>
<a name="ln409">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;xor&quot;));</a>
<a name="ln410">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;add&quot;));</a>
<a name="ln411">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;saturate&quot;));</a>
<a name="ln412">#if(CAIRO_VERSION &gt;= CAIRO_VERSION_ENCODE(1, 10, 0))</a>
<a name="ln413">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;multiply&quot;));</a>
<a name="ln414">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;screen&quot;));</a>
<a name="ln415">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;overlay&quot;));</a>
<a name="ln416">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;darken&quot;));</a>
<a name="ln417">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;lighten&quot;));</a>
<a name="ln418">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;color dodge&quot;));</a>
<a name="ln419">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;color burn&quot;));</a>
<a name="ln420">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;hard light&quot;));</a>
<a name="ln421">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;soft light&quot;));</a>
<a name="ln422">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;difference&quot;));</a>
<a name="ln423">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;exclusion&quot;));</a>
<a name="ln424">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;HSL hue&quot;));</a>
<a name="ln425">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;HSL saturation&quot;));</a>
<a name="ln426">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;HSL color&quot;));</a>
<a name="ln427">  dt_bauhaus_combobox_add(lib-&gt;overlay_mode, C_(&quot;blendmode&quot;, &quot;HSL luminosity&quot;));</a>
<a name="ln428">#endif</a>
<a name="ln429">  gtk_widget_set_tooltip_text(lib-&gt;overlay_mode, _(&quot;mode of the overlay&quot;));</a>
<a name="ln430">  dt_bauhaus_combobox_set(lib-&gt;overlay_mode, dt_conf_get_int(&quot;plugins/lighttable/live_view/overlay_mode&quot;));</a>
<a name="ln431">  g_signal_connect(G_OBJECT(lib-&gt;overlay_mode), &quot;value-changed&quot;, G_CALLBACK(_overlay_mode_changed), lib);</a>
<a name="ln432">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;overlay_mode, TRUE, TRUE, 0);</a>
<a name="ln433"> </a>
<a name="ln434">  lib-&gt;overlay_splitline = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln435">  dt_bauhaus_widget_set_label(lib-&gt;overlay_splitline, NULL, _(&quot;split line&quot;));</a>
<a name="ln436">  dt_bauhaus_combobox_add(lib-&gt;overlay_splitline, _(&quot;off&quot;));</a>
<a name="ln437">  dt_bauhaus_combobox_add(lib-&gt;overlay_splitline, _(&quot;on&quot;));</a>
<a name="ln438">  gtk_widget_set_tooltip_text(lib-&gt;overlay_splitline, _(&quot;only draw part of the overlay&quot;));</a>
<a name="ln439">  dt_bauhaus_combobox_set(lib-&gt;overlay_splitline, dt_conf_get_int(&quot;plugins/lighttable/live_view/splitline&quot;));</a>
<a name="ln440">  g_signal_connect(G_OBJECT(lib-&gt;overlay_splitline), &quot;value-changed&quot;, G_CALLBACK(_overlay_splitline_changed),</a>
<a name="ln441">                   lib);</a>
<a name="ln442">  gtk_box_pack_start(GTK_BOX(self-&gt;widget), lib-&gt;overlay_splitline, TRUE, TRUE, 0);</a>
<a name="ln443"> </a>
<a name="ln444">  gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_mode), FALSE);</a>
<a name="ln445">  gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_id_box), FALSE);</a>
<a name="ln446">  gtk_widget_set_visible(GTK_WIDGET(lib-&gt;overlay_splitline), FALSE);</a>
<a name="ln447"> </a>
<a name="ln448">  gtk_widget_set_no_show_all(GTK_WIDGET(lib-&gt;overlay_mode), TRUE);</a>
<a name="ln449">  gtk_widget_set_no_show_all(GTK_WIDGET(lib-&gt;overlay_id_box), TRUE);</a>
<a name="ln450">  gtk_widget_set_no_show_all(GTK_WIDGET(lib-&gt;overlay_splitline), TRUE);</a>
<a name="ln451"> </a>
<a name="ln452">  guides_presets_set_visibility(lib, 0);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln456">{</a>
<a name="ln457">  // dt_lib_live_view_t *lib = self-&gt;data;</a>
<a name="ln458"> </a>
<a name="ln459">  // g_list_free(lib-&gt;guides_widgets_list);</a>
<a name="ln460">  // INTENTIONAL. it's supposed to be leaky until lua is fixed.</a>
<a name="ln461"> </a>
<a name="ln462">  free(self-&gt;data);</a>
<a name="ln463">  self-&gt;data = NULL;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">void view_enter(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln467">{</a>
<a name="ln468">  // disable buttons that won't work with this camera</a>
<a name="ln469">  // TODO: initialize tethering mode outside of libs/camera.s so we can use darktable.camctl-&gt;active_camera</a>
<a name="ln470">  // here</a>
<a name="ln471">  dt_lib_live_view_t *lib = self-&gt;data;</a>
<a name="ln472">  const dt_camera_t *cam = darktable.camctl-&gt;active_camera;</a>
<a name="ln473">  if(cam == NULL) cam = darktable.camctl-&gt;wanted_camera;</a>
<a name="ln474"> </a>
<a name="ln475">  gboolean sensitive = cam &amp;&amp; cam-&gt;can_live_view_advanced;</a>
<a name="ln476"> </a>
<a name="ln477">  gtk_widget_set_sensitive(lib-&gt;live_view_zoom, sensitive);</a>
<a name="ln478">  gtk_widget_set_sensitive(lib-&gt;focus_in_big, sensitive);</a>
<a name="ln479">  gtk_widget_set_sensitive(lib-&gt;focus_in_small, sensitive);</a>
<a name="ln480">  gtk_widget_set_sensitive(lib-&gt;focus_out_big, sensitive);</a>
<a name="ln481">  gtk_widget_set_sensitive(lib-&gt;focus_out_small, sensitive);</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">// TODO: find out where the zoom window is and draw overlay + grid accordingly</a>
<a name="ln485">#define MARGIN 20</a>
<a name="ln486">#define BAR_HEIGHT 18 /* see libs/camera.c */</a>
<a name="ln487">void gui_post_expose(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height, int32_t pointerx,</a>
<a name="ln488">                     int32_t pointery)</a>
<a name="ln489">{</a>
<a name="ln490">  dt_camera_t *cam = (dt_camera_t *)darktable.camctl-&gt;active_camera;</a>
<a name="ln491">  dt_lib_live_view_t *lib = self-&gt;data;</a>
<a name="ln492"> </a>
<a name="ln493">  if(cam-&gt;is_live_viewing == FALSE || cam-&gt;live_view_zoom == TRUE) return;</a>
<a name="ln494"> </a>
<a name="ln495">  dt_pthread_mutex_lock(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln496">  if(GDK_IS_PIXBUF(cam-&gt;live_view_pixbuf) == FALSE)</a>
<a name="ln497">  {</a>
<a name="ln498">    dt_pthread_mutex_unlock(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln499">    return;</a>
<a name="ln500">  }</a>
<a name="ln501">  double w = width - (MARGIN * 2.0f);</a>
<a name="ln502">  double h = height - (MARGIN * 2.0f) - BAR_HEIGHT;</a>
<a name="ln503">  gint pw = gdk_pixbuf_get_width(cam-&gt;live_view_pixbuf);</a>
<a name="ln504">  gint ph = gdk_pixbuf_get_height(cam-&gt;live_view_pixbuf);</a>
<a name="ln505">  lib-&gt;overlay_x0 = lib-&gt;overlay_x1 = lib-&gt;overlay_y0 = lib-&gt;overlay_y1 = 0.0;</a>
<a name="ln506"> </a>
<a name="ln507">  gboolean use_splitline = (dt_bauhaus_combobox_get(lib-&gt;overlay_splitline) == 1);</a>
<a name="ln508"> </a>
<a name="ln509">  // OVERLAY</a>
<a name="ln510">  int imgid = 0;</a>
<a name="ln511">  switch(dt_bauhaus_combobox_get(lib-&gt;overlay))</a>
<a name="ln512">  {</a>
<a name="ln513">    case OVERLAY_SELECTED:</a>
<a name="ln514">      imgid = dt_view_tethering_get_selected_imgid(darktable.view_manager);</a>
<a name="ln515">      break;</a>
<a name="ln516">    case OVERLAY_ID:</a>
<a name="ln517">      imgid = lib-&gt;imgid;</a>
<a name="ln518">      break;</a>
<a name="ln519">  }</a>
<a name="ln520">  if(imgid &gt; 0)</a>
<a name="ln521">  {</a>
<a name="ln522">    cairo_save(cr);</a>
<a name="ln523">    const dt_image_t *img = dt_image_cache_testget(darktable.image_cache, imgid, 'r');</a>
<a name="ln524">    // if the user points at this image, we really want it:</a>
<a name="ln525">    if(!img) img = dt_image_cache_get(darktable.image_cache, imgid, 'r');</a>
<a name="ln526"> </a>
<a name="ln527">    const float imgwd = 0.97f;</a>
<a name="ln528">    dt_mipmap_buffer_t buf;</a>
<a name="ln529">    dt_mipmap_size_t mip = dt_mipmap_cache_get_matching_size(darktable.mipmap_cache, imgwd * w, imgwd * h);</a>
<a name="ln530">    dt_mipmap_cache_get(darktable.mipmap_cache, &amp;buf, imgid, mip, 0, 'r');</a>
<a name="ln531"> </a>
<a name="ln532">    float scale = 1.0;</a>
<a name="ln533">    cairo_surface_t *surface = NULL;</a>
<a name="ln534">    if(buf.buf)</a>
<a name="ln535">    {</a>
<a name="ln536">      const int32_t stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, buf.width);</a>
<a name="ln537">      surface = cairo_image_surface_create_for_data(buf.buf, CAIRO_FORMAT_RGB24, buf.width,</a>
<a name="ln538">                                                    buf.height, stride);</a>
<a name="ln539">      scale = fminf(fminf(w, pw) / (float)buf.width, fminf(h, ph) / (float)buf.height);</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">    // draw centered and fitted:</a>
<a name="ln543">    cairo_translate(cr, width / 2.0, (height + BAR_HEIGHT) / 2.0f);</a>
<a name="ln544">    cairo_scale(cr, scale, scale);</a>
<a name="ln545"> </a>
<a name="ln546">    if(buf.buf)</a>
<a name="ln547">    {</a>
<a name="ln548">      cairo_translate(cr, -.5f * buf.width, -.5f * buf.height);</a>
<a name="ln549"> </a>
<a name="ln550">      if(use_splitline)</a>
<a name="ln551">      {</a>
<a name="ln552">        double x0, y0, x1, y1;</a>
<a name="ln553">        switch(lib-&gt;splitline_rotation)</a>
<a name="ln554">        {</a>
<a name="ln555">          case 0:</a>
<a name="ln556">            x0 = 0.0;</a>
<a name="ln557">            y0 = 0.0;</a>
<a name="ln558">            x1 = buf.width * lib-&gt;splitline_x;</a>
<a name="ln559">            y1 = buf.height;</a>
<a name="ln560">            break;</a>
<a name="ln561">          case 1:</a>
<a name="ln562">            x0 = 0.0;</a>
<a name="ln563">            y0 = 0.0;</a>
<a name="ln564">            x1 = buf.width;</a>
<a name="ln565">            y1 = buf.height * lib-&gt;splitline_y;</a>
<a name="ln566">            break;</a>
<a name="ln567">          case 2:</a>
<a name="ln568">            x0 = buf.width * lib-&gt;splitline_x;</a>
<a name="ln569">            y0 = 0.0;</a>
<a name="ln570">            x1 = buf.width;</a>
<a name="ln571">            y1 = buf.height;</a>
<a name="ln572">            break;</a>
<a name="ln573">          case 3:</a>
<a name="ln574">            x0 = 0.0;</a>
<a name="ln575">            y0 = buf.height * lib-&gt;splitline_y;</a>
<a name="ln576">            x1 = buf.width;</a>
<a name="ln577">            y1 = buf.height;</a>
<a name="ln578">            break;</a>
<a name="ln579">          default:</a>
<a name="ln580">            fprintf(stderr, &quot;OMFG, the world will collapse, this shouldn't be reachable!\n&quot;);</a>
<a name="ln581">            dt_pthread_mutex_unlock(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln582">            return;</a>
<a name="ln583">        }</a>
<a name="ln584"> </a>
<a name="ln585">        cairo_rectangle(cr, x0, y0, x1, y1);</a>
<a name="ln586">        cairo_clip(cr);</a>
<a name="ln587">      }</a>
<a name="ln588"> </a>
<a name="ln589">      cairo_set_source_surface(cr, surface, 0, 0);</a>
<a name="ln590">      // set filter no nearest:</a>
<a name="ln591">      // in skull mode, we want to see big pixels.</a>
<a name="ln592">      // in 1 iir mode for the right mip, we want to see exactly what the pipe gave us, 1:1 pixel for pixel.</a>
<a name="ln593">      // in between, filtering just makes stuff go unsharp.</a>
<a name="ln594">      if((buf.width &lt;= 8 &amp;&amp; buf.height &lt;= 8) || fabsf(scale - 1.0f) &lt; 0.01f)</a>
<a name="ln595">        cairo_pattern_set_filter(cairo_get_source(cr), CAIRO_FILTER_NEAREST);</a>
<a name="ln596">      cairo_rectangle(cr, 0, 0, buf.width, buf.height);</a>
<a name="ln597">      int overlay_modes_index = dt_bauhaus_combobox_get(lib-&gt;overlay_mode);</a>
<a name="ln598">      if(overlay_modes_index &gt;= 0)</a>
<a name="ln599">      {</a>
<a name="ln600">        cairo_operator_t mode = _overlay_modes[overlay_modes_index];</a>
<a name="ln601">        cairo_set_operator(cr, mode);</a>
<a name="ln602">      }</a>
<a name="ln603">      cairo_fill(cr);</a>
<a name="ln604">      cairo_set_operator(cr, CAIRO_OPERATOR_OVER);</a>
<a name="ln605">      cairo_surface_destroy(surface);</a>
<a name="ln606">    }</a>
<a name="ln607">    cairo_restore(cr);</a>
<a name="ln608">    if(buf.buf) dt_mipmap_cache_release(darktable.mipmap_cache, &amp;buf);</a>
<a name="ln609">    if(img) dt_image_cache_read_release(darktable.image_cache, img);</a>
<a name="ln610"> </a>
<a name="ln611">    // ON CANVAS CONTROLS</a>
<a name="ln612">    if(use_splitline)</a>
<a name="ln613">    {</a>
<a name="ln614">      scale = fminf(1.0, fminf(w / pw, h / ph));</a>
<a name="ln615"> </a>
<a name="ln616">      // image coordinates</a>
<a name="ln617">      lib-&gt;overlay_x0 = 0.5 * (width - pw * scale);</a>
<a name="ln618">      lib-&gt;overlay_y0 = 0.5 * (height - ph * scale + BAR_HEIGHT);</a>
<a name="ln619">      lib-&gt;overlay_x1 = lib-&gt;overlay_x0 + pw * scale;</a>
<a name="ln620">      lib-&gt;overlay_y1 = lib-&gt;overlay_y0 + ph * scale;</a>
<a name="ln621"> </a>
<a name="ln622">      // splitline position to absolute coords:</a>
<a name="ln623">      double sl_x = lib-&gt;overlay_x0 + lib-&gt;splitline_x * pw * scale;</a>
<a name="ln624">      double sl_y = lib-&gt;overlay_y0 + lib-&gt;splitline_y * ph * scale;</a>
<a name="ln625"> </a>
<a name="ln626">      int x0 = sl_x, y0 = 0.0, x1 = x0, y1 = height;</a>
<a name="ln627">      if(lib-&gt;splitline_rotation % 2 != 0)</a>
<a name="ln628">      {</a>
<a name="ln629">        x0 = 0.0;</a>
<a name="ln630">        y0 = sl_y;</a>
<a name="ln631">        x1 = width;</a>
<a name="ln632">        y1 = y0;</a>
<a name="ln633">      }</a>
<a name="ln634">      gboolean mouse_over_control = (lib-&gt;splitline_rotation % 2 == 0) ? (fabs(sl_x - pointerx) &lt; 5)</a>
<a name="ln635">                                                                       : (fabs(sl_y - pointery) &lt; 5);</a>
<a name="ln636">      cairo_save(cr);</a>
<a name="ln637">      cairo_set_source_rgb(cr, .7, .7, .7);</a>
<a name="ln638">      cairo_set_line_width(cr, (mouse_over_control ? 2.0 : 0.5));</a>
<a name="ln639"> </a>
<a name="ln640">      cairo_move_to(cr, x0, y0);</a>
<a name="ln641">      cairo_line_to(cr, x1, y1);</a>
<a name="ln642">      cairo_stroke(cr);</a>
<a name="ln643"> </a>
<a name="ln644">      /* if mouse over control lets draw center rotate control, hide if split is dragged */</a>
<a name="ln645">      if(!lib-&gt;splitline_dragging &amp;&amp; mouse_over_control)</a>
<a name="ln646">      {</a>
<a name="ln647">        cairo_set_line_width(cr, 0.5);</a>
<a name="ln648">        double s = width * HANDLE_SIZE;</a>
<a name="ln649">        dtgtk_cairo_paint_refresh(cr, sl_x - (s * 0.5), sl_y - (s * 0.5), s, s, 1, NULL);</a>
<a name="ln650">      }</a>
<a name="ln651"> </a>
<a name="ln652">      cairo_restore(cr);</a>
<a name="ln653">    }</a>
<a name="ln654">  }</a>
<a name="ln655"> </a>
<a name="ln656">  // GUIDES</a>
<a name="ln657">  if(cam-&gt;live_view_rotation % 2 == 1)</a>
<a name="ln658">  {</a>
<a name="ln659">    gint tmp = pw;</a>
<a name="ln660">    pw = ph;</a>
<a name="ln661">    ph = tmp;</a>
<a name="ln662">  }</a>
<a name="ln663">  float scale = 1.0;</a>
<a name="ln664">  //   if(cam-&gt;live_view_zoom == FALSE)</a>
<a name="ln665">  //   {</a>
<a name="ln666">  if(pw &gt; w) scale = w / pw;</a>
<a name="ln667">  if(ph &gt; h) scale = fminf(scale, h / ph);</a>
<a name="ln668">  //   }</a>
<a name="ln669">  double sw = scale * pw;</a>
<a name="ln670">  double sh = scale * ph;</a>
<a name="ln671"> </a>
<a name="ln672">  // draw guides</a>
<a name="ln673">  int guide_flip = dt_bauhaus_combobox_get(lib-&gt;flip_guides);</a>
<a name="ln674">  double left = (width - sw) * 0.5;</a>
<a name="ln675">  double top = (height + BAR_HEIGHT - sh) * 0.5;</a>
<a name="ln676"> </a>
<a name="ln677">  double dashes = 5.0;</a>
<a name="ln678"> </a>
<a name="ln679">  cairo_save(cr);</a>
<a name="ln680">  cairo_rectangle(cr, left, top, sw, sh);</a>
<a name="ln681">  cairo_clip(cr);</a>
<a name="ln682">  cairo_set_dash(cr, &amp;dashes, 1, 0);</a>
<a name="ln683"> </a>
<a name="ln684">  // Move coordinates to local center selection.</a>
<a name="ln685">  cairo_translate(cr, (sw / 2 + left), (sh / 2 + top));</a>
<a name="ln686"> </a>
<a name="ln687">  // Flip horizontal.</a>
<a name="ln688">  if(guide_flip &amp; FLAG_FLIP_HORIZONTAL) cairo_scale(cr, -1, 1);</a>
<a name="ln689">  // Flip vertical.</a>
<a name="ln690">  if(guide_flip &amp; FLAG_FLIP_VERTICAL) cairo_scale(cr, 1, -1);</a>
<a name="ln691"> </a>
<a name="ln692">  int which = dt_bauhaus_combobox_get(lib-&gt;guide_selector);</a>
<a name="ln693">  dt_guides_t *guide = (dt_guides_t *)g_list_nth_data(darktable.guides, which - 1);</a>
<a name="ln694">  if(guide)</a>
<a name="ln695">  {</a>
<a name="ln696">    guide-&gt;draw(cr, -sw / 2, -sh / 2, sw, sh, 1.0, guide-&gt;user_data);</a>
<a name="ln697">    cairo_stroke_preserve(cr);</a>
<a name="ln698">    cairo_set_dash(cr, &amp;dashes, 0, 0);</a>
<a name="ln699">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln700">    cairo_stroke(cr);</a>
<a name="ln701">  }</a>
<a name="ln702">  cairo_restore(cr);</a>
<a name="ln703">  dt_pthread_mutex_unlock(&amp;cam-&gt;live_view_pixbuf_mutex);</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">int button_released(struct dt_lib_module_t *self, double x, double y, int which, uint32_t state)</a>
<a name="ln707">{</a>
<a name="ln708">  dt_lib_live_view_t *d = (dt_lib_live_view_t *)self-&gt;data;</a>
<a name="ln709">  if(d-&gt;splitline_dragging == TRUE)</a>
<a name="ln710">  {</a>
<a name="ln711">    d-&gt;splitline_dragging = FALSE;</a>
<a name="ln712">    return 1;</a>
<a name="ln713">  }</a>
<a name="ln714">  return 0;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">int button_pressed(struct dt_lib_module_t *self, double x, double y, double pressure, int which, int type,</a>
<a name="ln718">                   uint32_t state)</a>
<a name="ln719">{</a>
<a name="ln720">  dt_lib_live_view_t *lib = (dt_lib_live_view_t *)self-&gt;data;</a>
<a name="ln721">  int result = 0;</a>
<a name="ln722"> </a>
<a name="ln723">  int imgid = 0;</a>
<a name="ln724">  switch(dt_bauhaus_combobox_get(lib-&gt;overlay))</a>
<a name="ln725">  {</a>
<a name="ln726">    case OVERLAY_SELECTED:</a>
<a name="ln727">      imgid = dt_view_tethering_get_selected_imgid(darktable.view_manager);</a>
<a name="ln728">      break;</a>
<a name="ln729">    case OVERLAY_ID:</a>
<a name="ln730">      imgid = lib-&gt;imgid;</a>
<a name="ln731">      break;</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  if(imgid &gt; 0 &amp;&amp; dt_bauhaus_combobox_get(lib-&gt;overlay_splitline))</a>
<a name="ln735">  {</a>
<a name="ln736">    const double width = lib-&gt;overlay_x1 - lib-&gt;overlay_x0;</a>
<a name="ln737">    const double height = lib-&gt;overlay_y1 - lib-&gt;overlay_y0;</a>
<a name="ln738"> </a>
<a name="ln739">    // splitline position to absolute coords:</a>
<a name="ln740">    double sl_x = lib-&gt;overlay_x0 + lib-&gt;splitline_x * width;</a>
<a name="ln741">    double sl_y = lib-&gt;overlay_y0 + lib-&gt;splitline_y * height;</a>
<a name="ln742"> </a>
<a name="ln743">    gboolean mouse_over_control = (lib-&gt;splitline_rotation % 2 == 0) ? (fabs(sl_x - x) &lt; 5)</a>
<a name="ln744">                                                                     : (fabs(sl_y - y) &lt; 5);</a>
<a name="ln745"> </a>
<a name="ln746">    /* do the split rotating */</a>
<a name="ln747">    if(which == 1 &amp;&amp; fabs(sl_x - x) &lt; 7 &amp;&amp; fabs(sl_y - y) &lt; 7)</a>
<a name="ln748">    {</a>
<a name="ln749">      /* let's rotate */</a>
<a name="ln750">      lib-&gt;splitline_rotation = (lib-&gt;splitline_rotation + 1) % 4;</a>
<a name="ln751"> </a>
<a name="ln752">      dt_control_queue_redraw_center();</a>
<a name="ln753">      result = 1;</a>
<a name="ln754">    }</a>
<a name="ln755">    /* do the dragging !? */</a>
<a name="ln756">    else if(which == 1 &amp;&amp; mouse_over_control)</a>
<a name="ln757">    {</a>
<a name="ln758">      lib-&gt;splitline_dragging = TRUE;</a>
<a name="ln759">      dt_control_queue_redraw_center();</a>
<a name="ln760">      result = 1;</a>
<a name="ln761">    }</a>
<a name="ln762">  }</a>
<a name="ln763">  return result;</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">int mouse_moved(dt_lib_module_t *self, double x, double y, double pressure, int which)</a>
<a name="ln767">{</a>
<a name="ln768">  dt_lib_live_view_t *lib = (dt_lib_live_view_t *)self-&gt;data;</a>
<a name="ln769">  int result = 0;</a>
<a name="ln770"> </a>
<a name="ln771">  if(lib-&gt;splitline_dragging)</a>
<a name="ln772">  {</a>
<a name="ln773">    const double width = lib-&gt;overlay_x1 - lib-&gt;overlay_x0;</a>
<a name="ln774">    const double height = lib-&gt;overlay_y1 - lib-&gt;overlay_y0;</a>
<a name="ln775"> </a>
<a name="ln776">    // absolute coords to splitline position:</a>
<a name="ln777">    lib-&gt;splitline_x = CLAMPS((x - lib-&gt;overlay_x0) / width, 0.0, 1.0);</a>
<a name="ln778">    lib-&gt;splitline_y = CLAMPS((y - lib-&gt;overlay_y0) / height, 0.0, 1.0);</a>
<a name="ln779"> </a>
<a name="ln780">    result = 1;</a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  return result;</a>
<a name="ln784">}</a>
<a name="ln785">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln786">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln787">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="269"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lib'. Check lines: 269, 265.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
