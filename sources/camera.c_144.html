
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2010 - 2014 henrik andersson.</a>
<a name="ln4"> </a>
<a name="ln5">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln6">    it under the terms of the GNU General Public License as published by</a>
<a name="ln7">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln8">    (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln11">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">    GNU General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">    You should have received a copy of the GNU General Public License</a>
<a name="ln16">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln17">*/</a>
<a name="ln18">#include &quot;bauhaus/bauhaus.h&quot;</a>
<a name="ln19">#include &quot;common/camera_control.h&quot;</a>
<a name="ln20">#include &quot;common/darktable.h&quot;</a>
<a name="ln21">#include &quot;control/conf.h&quot;</a>
<a name="ln22">#include &quot;control/control.h&quot;</a>
<a name="ln23">#include &quot;control/jobs.h&quot;</a>
<a name="ln24">#include &quot;dtgtk/button.h&quot;</a>
<a name="ln25">#include &quot;gui/accelerators.h&quot;</a>
<a name="ln26">#include &quot;gui/gtk.h&quot;</a>
<a name="ln27">#include &quot;libs/lib.h&quot;</a>
<a name="ln28">#include &quot;libs/lib_api.h&quot;</a>
<a name="ln29">#include &lt;gdk/gdkkeysyms.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">DT_MODULE(1)</a>
<a name="ln32"> </a>
<a name="ln33">typedef struct dt_lib_camera_property_t</a>
<a name="ln34">{</a>
<a name="ln35">  /** the visual property name */</a>
<a name="ln36">  gchar *name;</a>
<a name="ln37">  /** the property name */</a>
<a name="ln38">  gchar *property_name;</a>
<a name="ln39">  /**Combobox of values available for the property*/</a>
<a name="ln40">  GtkWidget *values;</a>
<a name="ln41">  /** Show property OSD */</a>
<a name="ln42">  GtkDarktableToggleButton *osd;</a>
<a name="ln43">} dt_lib_camera_property_t;</a>
<a name="ln44"> </a>
<a name="ln45">typedef struct dt_lib_camera_t</a>
<a name="ln46">{</a>
<a name="ln47">  /** Gui part of the module */</a>
<a name="ln48">  struct</a>
<a name="ln49">  {</a>
<a name="ln50">    GtkGrid *main_grid;</a>
<a name="ln51">    GtkDarktableToggleButton *toggle_timer, *toggle_sequence, *toggle_bracket;</a>
<a name="ln52">    GtkWidget *timer, *count, *brackets, *steps;</a>
<a name="ln53">    GtkWidget *button1;</a>
<a name="ln54"> </a>
<a name="ln55">    int rows; // the number of row in the grid</a>
<a name="ln56">    int prop_start; // the row of the grid above the first property</a>
<a name="ln57">    int prop_end; // the row of the grid where to insert new properties</a>
<a name="ln58"> </a>
<a name="ln59">    GtkWidget *plabel, *pname; // propertylabel,widget</a>
<a name="ln60">    GList *properties;         // a list of dt_lib_camera_property_t</a>
<a name="ln61"> </a>
<a name="ln62">    GtkMenu *properties_menu; // available properties</a>
<a name="ln63"> </a>
<a name="ln64">  } gui;</a>
<a name="ln65"> </a>
<a name="ln66">  /** Data part of the module */</a>
<a name="ln67">  struct</a>
<a name="ln68">  {</a>
<a name="ln69">    const gchar *camera_model;</a>
<a name="ln70">    dt_camctl_listener_t *listener;</a>
<a name="ln71">  } data;</a>
<a name="ln72">} dt_lib_camera_t;</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">const char *name(dt_lib_module_t *self)</a>
<a name="ln77">{</a>
<a name="ln78">  return _(&quot;camera settings&quot;);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">const char **views(dt_lib_module_t *self)</a>
<a name="ln82">{</a>
<a name="ln83">  static const char *v[] = {&quot;tethering&quot;, NULL};</a>
<a name="ln84">  return v;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">uint32_t container(dt_lib_module_t *self)</a>
<a name="ln88">{</a>
<a name="ln89">  return DT_UI_CONTAINER_PANEL_RIGHT_CENTER;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">void gui_reset(dt_lib_module_t *self)</a>
<a name="ln94">{</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">int position()</a>
<a name="ln98">{</a>
<a name="ln99">  return 997;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">void init_key_accels(dt_lib_module_t *self)</a>
<a name="ln103">{</a>
<a name="ln104">  dt_accel_register_lib(self, NC_(&quot;accel&quot;, &quot;capture image(s)&quot;), 0, 0);</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">void connect_key_accels(dt_lib_module_t *self)</a>
<a name="ln108">{</a>
<a name="ln109">  dt_lib_camera_t *lib = (dt_lib_camera_t *)self-&gt;data;</a>
<a name="ln110"> </a>
<a name="ln111">  dt_accel_connect_button_lib(self, &quot;capture image(s)&quot;, GTK_WIDGET(lib-&gt;gui.button1));</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">/** Property changed*/</a>
<a name="ln115">static void property_changed_callback(GtkComboBox *cb, gpointer data)</a>
<a name="ln116">{</a>
<a name="ln117">  dt_lib_camera_property_t *prop = (dt_lib_camera_property_t *)data;</a>
<a name="ln118">  dt_camctl_camera_set_property_string(darktable.camctl, NULL, prop-&gt;property_name,</a>
<a name="ln119">                                       dt_bauhaus_combobox_get_text(prop-&gt;values));</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">/** Add  a new property of camera to the gui */</a>
<a name="ln123">static dt_lib_camera_property_t *_lib_property_add_new(dt_lib_camera_t *lib, const gchar *label,</a>
<a name="ln124">                                                       const gchar *propertyname)</a>
<a name="ln125">{</a>
<a name="ln126">  if(dt_camctl_camera_property_exists(darktable.camctl, NULL, propertyname))</a>
<a name="ln127">  {</a>
<a name="ln128">    const char *value;</a>
<a name="ln129">    if((value = dt_camctl_camera_property_get_first_choice(darktable.camctl, NULL, propertyname)) != NULL)</a>
<a name="ln130">    {</a>
<a name="ln131">      // We got a value for property lets construct the gui for the property and add values</a>
<a name="ln132">      int i = 0;</a>
<a name="ln133">      const char *current_value = dt_camctl_camera_get_property(darktable.camctl, NULL, propertyname);</a>
<a name="ln134">      dt_lib_camera_property_t *prop = calloc(1, sizeof(dt_lib_camera_property_t));</a>
<a name="ln135">      prop-&gt;name = strdup(label);</a>
<a name="ln136">      prop-&gt;property_name = strdup(propertyname);</a>
<a name="ln137">      prop-&gt;values = dt_bauhaus_combobox_new(NULL);</a>
<a name="ln138">      dt_bauhaus_widget_set_label(prop-&gt;values, NULL, label);</a>
<a name="ln139">      g_object_ref_sink(prop-&gt;values);</a>
<a name="ln140"> </a>
<a name="ln141">      prop-&gt;osd = DTGTK_TOGGLEBUTTON(dtgtk_togglebutton_new(dtgtk_cairo_paint_eye, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln142">      g_object_ref_sink(prop-&gt;osd);</a>
<a name="ln143">      gtk_widget_set_size_request(GTK_WIDGET(prop-&gt;osd), DT_PIXEL_APPLY_DPI(14), -1);</a>
<a name="ln144">      gtk_widget_set_tooltip_text(GTK_WIDGET(prop-&gt;osd), _(&quot;toggle view property in center view&quot;));</a>
<a name="ln145">      do</a>
<a name="ln146">      {</a>
<a name="ln147">        dt_bauhaus_combobox_add(prop-&gt;values, g_dgettext(&quot;libgphoto2-2&quot;, value));</a>
<a name="ln148">        if(!strcmp(current_value, g_dgettext(&quot;libgphoto2-2&quot;, value)))</a>
<a name="ln149">          dt_bauhaus_combobox_set(prop-&gt;values, i);</a>
<a name="ln150">        i++;</a>
<a name="ln151">      } while((value = dt_camctl_camera_property_get_next_choice(darktable.camctl, NULL, propertyname))</a>
<a name="ln152">              != NULL);</a>
<a name="ln153">      lib-&gt;gui.properties = g_list_append(lib-&gt;gui.properties, prop);</a>
<a name="ln154">      // Does dead lock!!!</a>
<a name="ln155">      g_signal_connect(G_OBJECT(prop-&gt;values), &quot;value-changed&quot;, G_CALLBACK(property_changed_callback),</a>
<a name="ln156">                       (gpointer)prop);</a>
<a name="ln157">      return prop;</a>
<a name="ln158">    }</a>
<a name="ln159">  }</a>
<a name="ln160">  return NULL;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">static void _lib_property_free(gpointer data)</a>
<a name="ln164">{</a>
<a name="ln165">  dt_lib_camera_property_t * prop = (dt_lib_camera_property_t *)data;</a>
<a name="ln166">  g_object_unref(prop-&gt;osd);</a>
<a name="ln167">  g_object_unref(prop-&gt;values);</a>
<a name="ln168">  free(prop-&gt;name);</a>
<a name="ln169">  free(prop-&gt;property_name);</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">static gint _compare_property_by_name(gconstpointer a, gconstpointer b)</a>
<a name="ln173">{</a>
<a name="ln174">  dt_lib_camera_property_t *ca = (dt_lib_camera_property_t *)a;</a>
<a name="ln175">  return strcmp(ca-&gt;property_name, (char *)b);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">/** Invoked when a value of a property is changed. */</a>
<a name="ln179">static void _camera_property_value_changed(const dt_camera_t *camera, const char *name, const char *value,</a>
<a name="ln180">                                           void *data)</a>
<a name="ln181">{</a>
<a name="ln182">  dt_lib_camera_t *lib = (dt_lib_camera_t *)data;</a>
<a name="ln183">  // Find the property in lib-&gt;data.properties, update value</a>
<a name="ln184">  GList *citem;</a>
<a name="ln185">  if((citem = g_list_find_custom(lib-&gt;gui.properties, name, _compare_property_by_name)) != NULL)</a>
<a name="ln186">  {</a>
<a name="ln187">    dt_lib_camera_property_t *prop = (dt_lib_camera_property_t *)citem-&gt;data;</a>
<a name="ln188">    int i = 0;</a>
<a name="ln189">    for(const GList *iter = dt_bauhaus_combobox_get_labels(prop-&gt;values); iter; iter = g_list_next(iter), i++)</a>
<a name="ln190">    {</a>
<a name="ln191">      if(!g_strcmp0((gchar*)iter-&gt;data, value))</a>
<a name="ln192">      {</a>
<a name="ln193">        dt_bauhaus_combobox_set(prop-&gt;values, i);</a>
<a name="ln194">        return;</a>
<a name="ln195">      }</a>
<a name="ln196">    }</a>
<a name="ln197">  }</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">/** Invoked when accesibility of a property is changed. */</a>
<a name="ln201">static void _camera_property_accessibility_changed(const dt_camera_t *camera, const char *name,</a>
<a name="ln202">                                                   gboolean read_only, void *data)</a>
<a name="ln203">{</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">static gboolean _bailout_of_tethering(gpointer user_data)</a>
<a name="ln207">{</a>
<a name="ln208">  /* consider all error types as failure and bailout of tethering mode */</a>
<a name="ln209">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln210">  dt_camctl_tether_mode(darktable.camctl, NULL, FALSE);</a>
<a name="ln211">  dt_camctl_unregister_listener(darktable.camctl, lib-&gt;data.listener);</a>
<a name="ln212"> </a>
<a name="ln213">  /* switch back to library mode */</a>
<a name="ln214">  dt_ctl_switch_mode_to(&quot;lighttable&quot;);</a>
<a name="ln215"> </a>
<a name="ln216">  return FALSE;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">/** Invoked when camera error appear */</a>
<a name="ln220">static void _camera_error_callback(const dt_camera_t *camera, dt_camera_error_t error, void *user_data)</a>
<a name="ln221">{</a>
<a name="ln222">  dt_control_log(_(&quot;connection with camera lost, exiting tethering mode&quot;));</a>
<a name="ln223">  g_idle_add(_bailout_of_tethering, user_data);</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">static void _capture_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln227">{</a>
<a name="ln228">  const char *jobcode = NULL;</a>
<a name="ln229">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln230">  uint32_t delay = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_timer)) == TRUE</a>
<a name="ln231">                       ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.timer))</a>
<a name="ln232">                       : 0;</a>
<a name="ln233">  uint32_t count = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_sequence)) == TRUE</a>
<a name="ln234">                       ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.count))</a>
<a name="ln235">                       : 1;</a>
<a name="ln236">  uint32_t brackets = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_bracket)) == TRUE</a>
<a name="ln237">                          ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.brackets))</a>
<a name="ln238">                          : 0;</a>
<a name="ln239">  uint32_t steps = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(lib-&gt;gui.toggle_bracket)) == TRUE</a>
<a name="ln240">                       ? (uint32_t)gtk_spin_button_get_value(GTK_SPIN_BUTTON(lib-&gt;gui.steps))</a>
<a name="ln241">                       : 0;</a>
<a name="ln242"> </a>
<a name="ln243">  /* create a capture background job */</a>
<a name="ln244">  jobcode = dt_view_tethering_get_job_code(darktable.view_manager);</a>
<a name="ln245">  dt_control_add_job(darktable.control, DT_JOB_QUEUE_USER_FG,</a>
<a name="ln246">                     dt_camera_capture_job_create(jobcode, delay, count, brackets, steps));</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249"> </a>
<a name="ln250">static void _osd_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln251">{</a>
<a name="ln252">  dt_control_queue_redraw_center();</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">static void _property_choice_callback(GtkMenuItem *item, gpointer user_data)</a>
<a name="ln256">{</a>
<a name="ln257">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln258">  gtk_entry_set_text(GTK_ENTRY(lib-&gt;gui.pname), gtk_menu_item_get_label(item));</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">static void _show_property_popupmenu_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln263">{</a>
<a name="ln264">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln265"> </a>
<a name="ln266">#if GTK_CHECK_VERSION(3, 22, 0)</a>
<a name="ln267">  gtk_menu_popup_at_pointer(lib-&gt;gui.properties_menu, NULL);</a>
<a name="ln268">#else</a>
<a name="ln269">  gtk_menu_popup(lib-&gt;gui.properties_menu, NULL, NULL, NULL, NULL, 1, gtk_get_current_event_time());</a>
<a name="ln270">#endif</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">static void _lib_property_add_to_gui(dt_lib_camera_property_t *prop, dt_lib_camera_t *lib)</a>
<a name="ln274">{</a>
<a name="ln275">  GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln276">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(prop-&gt;values), TRUE, TRUE, 0);</a>
<a name="ln277">  gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(prop-&gt;osd), FALSE, FALSE, 0);</a>
<a name="ln278">  gtk_grid_insert_row(lib-&gt;gui.main_grid, lib-&gt;gui.prop_end); // make space for the new row</a>
<a name="ln279">  gtk_grid_attach(lib-&gt;gui.main_grid, GTK_WIDGET(hbox), 0, lib-&gt;gui.prop_end, 2, 1);</a>
<a name="ln280">  g_signal_connect(G_OBJECT(prop-&gt;osd), &quot;clicked&quot;, G_CALLBACK(_osd_button_clicked), prop);</a>
<a name="ln281">  gtk_widget_show_all(GTK_WIDGET(hbox));</a>
<a name="ln282">  lib-&gt;gui.rows++;</a>
<a name="ln283">  lib-&gt;gui.prop_end++;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">static void _add_property_button_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln287">{</a>
<a name="ln288">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln289">  const gchar *label = gtk_entry_get_text(GTK_ENTRY(lib-&gt;gui.plabel));</a>
<a name="ln290">  const gchar *property = gtk_entry_get_text(GTK_ENTRY(lib-&gt;gui.pname));</a>
<a name="ln291"> </a>
<a name="ln292">  /* let's try to add property */</a>
<a name="ln293">  if(label &amp;&amp; property)</a>
<a name="ln294">  {</a>
<a name="ln295">    dt_lib_camera_property_t *prop = NULL;</a>
<a name="ln296"> </a>
<a name="ln297">    if((prop = _lib_property_add_new(lib, label, property)) != NULL)</a>
<a name="ln298">    {</a>
<a name="ln299">      _lib_property_add_to_gui(prop, lib);</a>
<a name="ln300"> </a>
<a name="ln301">      gchar key[256] = { &quot;plugins/capture/tethering/properties/&quot; };</a>
<a name="ln302">      g_strlcat(key, label, sizeof(key));</a>
<a name="ln303">      gchar *p = key;</a>
<a name="ln304">      const char *end = key + strlen(key);</a>
<a name="ln305">      while(p++ &lt; end)</a>
<a name="ln306">        if(*p == ' ') *p = '_';</a>
<a name="ln307">      dt_conf_set_string(key, property);</a>
<a name="ln308"> </a>
<a name="ln309">      /* clean entries */</a>
<a name="ln310">      gtk_entry_set_text(GTK_ENTRY(lib-&gt;gui.plabel), &quot;&quot;);</a>
<a name="ln311">      gtk_entry_set_text(GTK_ENTRY(lib-&gt;gui.pname), &quot;&quot;);</a>
<a name="ln312">    }</a>
<a name="ln313">  }</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316"> </a>
<a name="ln317">static void _toggle_capture_mode_clicked(GtkWidget *widget, gpointer user_data)</a>
<a name="ln318">{</a>
<a name="ln319">  dt_lib_camera_t *lib = (dt_lib_camera_t *)user_data;</a>
<a name="ln320">  GtkWidget *w = NULL;</a>
<a name="ln321">  if(widget == GTK_WIDGET(lib-&gt;gui.toggle_timer))</a>
<a name="ln322">    w = lib-&gt;gui.timer;</a>
<a name="ln323">  else if(widget == GTK_WIDGET(lib-&gt;gui.toggle_sequence))</a>
<a name="ln324">    w = lib-&gt;gui.count;</a>
<a name="ln325">  else if(widget == GTK_WIDGET(lib-&gt;gui.toggle_bracket))</a>
<a name="ln326">  {</a>
<a name="ln327">    gtk_widget_set_sensitive(lib-&gt;gui.brackets, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln328">    gtk_widget_set_sensitive(lib-&gt;gui.steps, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln329">  }</a>
<a name="ln330"> </a>
<a name="ln331">  if(w) gtk_widget_set_sensitive(w, gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget)));</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">#define BAR_HEIGHT DT_PIXEL_APPLY_DPI(18) /* also change in views/tethering.c */</a>
<a name="ln336">static void _expose_info_bar(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln337">                             int32_t pointerx, int32_t pointery)</a>
<a name="ln338">{</a>
<a name="ln339">  dt_lib_camera_t *lib = (dt_lib_camera_t *)self-&gt;data;</a>
<a name="ln340"> </a>
<a name="ln341">  // Draw infobar background at top</a>
<a name="ln342">  cairo_set_source_rgb(cr, .0, .0, .0);</a>
<a name="ln343">  cairo_rectangle(cr, 0, 0, width, BAR_HEIGHT);</a>
<a name="ln344">  cairo_fill(cr);</a>
<a name="ln345"> </a>
<a name="ln346">  cairo_set_source_rgb(cr, .8, .8, .8);</a>
<a name="ln347"> </a>
<a name="ln348">  // Draw left aligned value camera model value</a>
<a name="ln349">  PangoLayout *layout;</a>
<a name="ln350">  PangoRectangle ink;</a>
<a name="ln351">  PangoFontDescription *desc = pango_font_description_copy_static(darktable.bauhaus-&gt;pango_font_desc);</a>
<a name="ln352">  pango_font_description_set_weight(desc, PANGO_WEIGHT_BOLD);</a>
<a name="ln353">  layout = pango_cairo_create_layout(cr);</a>
<a name="ln354">  const int fontsize = DT_PIXEL_APPLY_DPI(11.5);</a>
<a name="ln355">  pango_font_description_set_absolute_size(desc, fontsize * PANGO_SCALE);</a>
<a name="ln356">  pango_layout_set_font_description(layout, desc);</a>
<a name="ln357">  char model[4096] = { 0 };</a>
<a name="ln358">  sprintf(model + strlen(model), &quot;%s&quot;, lib-&gt;data.camera_model);</a>
<a name="ln359">  pango_layout_set_text(layout, model, -1);</a>
<a name="ln360">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln361">  cairo_move_to(cr, DT_PIXEL_APPLY_DPI(5), DT_PIXEL_APPLY_DPI(1) + BAR_HEIGHT - ink.height / 2 - fontsize);</a>
<a name="ln362">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln363"> </a>
<a name="ln364">  // Draw right aligned battery value</a>
<a name="ln365">  const char *battery_value = dt_camctl_camera_get_property(darktable.camctl, NULL, &quot;batterylevel&quot;);</a>
<a name="ln366">  char battery[4096] = { 0 };</a>
<a name="ln367">  snprintf(battery, sizeof(battery), &quot;%s: %s&quot;, _(&quot;battery&quot;), battery_value ? battery_value : _(&quot;n/a&quot;));</a>
<a name="ln368">  pango_layout_set_text(layout, battery, -1);</a>
<a name="ln369">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln370">  cairo_move_to(cr, width - ink.width - DT_PIXEL_APPLY_DPI(5), DT_PIXEL_APPLY_DPI(1) + BAR_HEIGHT - ink.height / 2 - fontsize);</a>
<a name="ln371">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln372"> </a>
<a name="ln373">  // Let's cook up the middle part of infobar</a>
<a name="ln374">  gchar center[1024] = { 0 };</a>
<a name="ln375">  for(guint i = 0; i &lt; g_list_length(lib-&gt;gui.properties); i++)</a>
<a name="ln376">  {</a>
<a name="ln377">    dt_lib_camera_property_t *prop = (dt_lib_camera_property_t *)g_list_nth_data(lib-&gt;gui.properties, i);</a>
<a name="ln378">    if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(prop-&gt;osd)) == TRUE)</a>
<a name="ln379">    {</a>
<a name="ln380">      g_strlcat(center, &quot;      &quot;, sizeof(center));</a>
<a name="ln381">      g_strlcat(center, prop-&gt;name, sizeof(center));</a>
<a name="ln382">      g_strlcat(center, &quot;: &quot;, sizeof(center));</a>
<a name="ln383">      g_strlcat(center, dt_bauhaus_combobox_get_text(prop-&gt;values), sizeof(center));</a>
<a name="ln384">    }</a>
<a name="ln385">  }</a>
<a name="ln386">  g_strlcat(center, &quot;      &quot;, sizeof(center));</a>
<a name="ln387"> </a>
<a name="ln388">  // Now lets put it in center view...</a>
<a name="ln389">  pango_layout_set_text(layout, center, -1);</a>
<a name="ln390">  pango_layout_get_pixel_extents(layout, &amp;ink, NULL);</a>
<a name="ln391">  cairo_move_to(cr, (width / 2) - (ink.width / 2), DT_PIXEL_APPLY_DPI(1) + BAR_HEIGHT - ink.height / 2 - fontsize);</a>
<a name="ln392">  pango_cairo_show_layout(cr, layout);</a>
<a name="ln393">  pango_font_description_free(desc);</a>
<a name="ln394">  g_object_unref(layout);</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">static void _expose_settings_bar(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height,</a>
<a name="ln398">                                 int32_t pointerx, int32_t pointery)</a>
<a name="ln399">{</a>
<a name="ln400">  /*// Draw control bar at bottom</a>
<a name="ln401">  cairo_set_source_rgb (cr, .0,.0,.0);</a>
<a name="ln402">  cairo_rectangle(cr, 0, height-BAR_HEIGHT, width, BAR_HEIGHT);</a>
<a name="ln403">  cairo_fill (cr);*/</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">void gui_post_expose(dt_lib_module_t *self, cairo_t *cr, int32_t width, int32_t height, int32_t pointerx,</a>
<a name="ln407">                     int32_t pointery)</a>
<a name="ln408">{</a>
<a name="ln409">  // Setup cairo font..</a>
<a name="ln410">  cairo_set_font_size(cr, 11.5);</a>
<a name="ln411">  cairo_select_font_face(cr, &quot;Sans&quot;, CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);</a>
<a name="ln412"> </a>
<a name="ln413">  _expose_info_bar(self, cr, width, height, pointerx, pointery);</a>
<a name="ln414">  _expose_settings_bar(self, cr, width, height, pointerx, pointery);</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">void gui_init(dt_lib_module_t *self)</a>
<a name="ln418">{</a>
<a name="ln419">  self-&gt;data = calloc(1, sizeof(dt_lib_camera_t));</a>
<a name="ln420"> </a>
<a name="ln421">  // Setup lib data</a>
<a name="ln422">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln423">  lib-&gt;data.listener = calloc(1, sizeof(dt_camctl_listener_t));</a>
<a name="ln424">  lib-&gt;data.listener-&gt;data = lib;</a>
<a name="ln425">  lib-&gt;data.listener-&gt;camera_error = _camera_error_callback;</a>
<a name="ln426">  lib-&gt;data.listener-&gt;camera_property_value_changed = _camera_property_value_changed;</a>
<a name="ln427">  lib-&gt;data.listener-&gt;camera_property_accessibility_changed = _camera_property_accessibility_changed;</a>
<a name="ln428"> </a>
<a name="ln429">  // Setup gui</a>
<a name="ln430">  lib-&gt;gui.rows = 0;</a>
<a name="ln431">  lib-&gt;gui.prop_end = 0;</a>
<a name="ln432">  self-&gt;widget = gtk_grid_new();</a>
<a name="ln433">  gtk_grid_set_column_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln434">  lib-&gt;gui.main_grid = GTK_GRID(self-&gt;widget);</a>
<a name="ln435">  gtk_grid_set_row_spacing(GTK_GRID(self-&gt;widget), DT_PIXEL_APPLY_DPI(5));</a>
<a name="ln436"> </a>
<a name="ln437">  GtkBox *hbox;</a>
<a name="ln438"> </a>
<a name="ln439">  // Camera control</a>
<a name="ln440">  GtkWidget *label = dt_ui_section_label_new(_(&quot;camera control&quot;));</a>
<a name="ln441">  gtk_grid_attach(GTK_GRID(self-&gt;widget), label, lib-&gt;gui.rows++, 0, 2, 1);</a>
<a name="ln442">  dt_gui_add_help_link(self-&gt;widget, &quot;camera_settings.html#camera_settings&quot;);</a>
<a name="ln443"> </a>
<a name="ln444">  GtkWidget *modes_label = gtk_label_new(_(&quot;modes&quot;));</a>
<a name="ln445">  GtkWidget *timer_label = gtk_label_new(_(&quot;timer (s)&quot;));</a>
<a name="ln446">  GtkWidget *count_label = gtk_label_new(_(&quot;count&quot;));</a>
<a name="ln447">  GtkWidget *brackets_label = gtk_label_new(_(&quot;brackets&quot;));</a>
<a name="ln448">  GtkWidget *steps_label = gtk_label_new(_(&quot;bkt. steps&quot;));</a>
<a name="ln449">  gtk_widget_set_halign(GTK_WIDGET(modes_label), GTK_ALIGN_START);</a>
<a name="ln450">  gtk_widget_set_halign(GTK_WIDGET(timer_label), GTK_ALIGN_START);</a>
<a name="ln451">  gtk_widget_set_halign(GTK_WIDGET(count_label), GTK_ALIGN_START);</a>
<a name="ln452">  gtk_widget_set_halign(GTK_WIDGET(brackets_label), GTK_ALIGN_START);</a>
<a name="ln453">  gtk_widget_set_halign(GTK_WIDGET(steps_label), GTK_ALIGN_START);</a>
<a name="ln454"> </a>
<a name="ln455">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(modes_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln456">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(timer_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln457">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(count_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln458">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(brackets_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln459">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(steps_label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln460"> </a>
<a name="ln461">  // capture modes buttons</a>
<a name="ln462">  lib-&gt;gui.toggle_timer = DTGTK_TOGGLEBUTTON(</a>
<a name="ln463">      dtgtk_togglebutton_new(dtgtk_cairo_paint_timer, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln464">  lib-&gt;gui.toggle_sequence = DTGTK_TOGGLEBUTTON(</a>
<a name="ln465">      dtgtk_togglebutton_new(dtgtk_cairo_paint_filmstrip, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln466">  lib-&gt;gui.toggle_bracket = DTGTK_TOGGLEBUTTON(</a>
<a name="ln467">      dtgtk_togglebutton_new(dtgtk_cairo_paint_bracket, CPF_STYLE_FLAT | CPF_DO_NOT_USE_BORDER, NULL));</a>
<a name="ln468"> </a>
<a name="ln469">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(5)));</a>
<a name="ln470">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.toggle_timer), TRUE, TRUE, 0);</a>
<a name="ln471">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.toggle_sequence), TRUE, TRUE, 0);</a>
<a name="ln472">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.toggle_bracket), TRUE, TRUE, 0);</a>
<a name="ln473">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(hbox), GTK_WIDGET(modes_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln474"> </a>
<a name="ln475">  lib-&gt;gui.timer = gtk_spin_button_new_with_range(1, 60, 1);</a>
<a name="ln476">  lib-&gt;gui.count = gtk_spin_button_new_with_range(1, 500, 1);</a>
<a name="ln477">  lib-&gt;gui.brackets = gtk_spin_button_new_with_range(1, 5, 1);</a>
<a name="ln478">  lib-&gt;gui.steps = gtk_spin_button_new_with_range(1, 9, 1);</a>
<a name="ln479">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.timer), GTK_WIDGET(timer_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln480">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.count), GTK_WIDGET(count_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln481">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.brackets), GTK_WIDGET(brackets_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln482">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.steps), GTK_WIDGET(steps_label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln483"> </a>
<a name="ln484">  lib-&gt;gui.button1 = gtk_button_new_with_label(_(&quot;capture image(s)&quot;));</a>
<a name="ln485">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.button1), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln486"> </a>
<a name="ln487">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.toggle_timer), _(&quot;toggle delayed capture mode&quot;));</a>
<a name="ln488">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.toggle_sequence), _(&quot;toggle sequenced capture mode&quot;));</a>
<a name="ln489">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.toggle_bracket), _(&quot;toggle bracketed capture mode&quot;));</a>
<a name="ln490">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.timer), _(&quot;the count of seconds before actually doing a capture&quot;));</a>
<a name="ln491">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.count),</a>
<a name="ln492">               _(&quot;the amount of images to capture in a sequence,\nyou can use this in conjunction with &quot;</a>
<a name="ln493">                 &quot;delayed mode to create stop-motion sequences.&quot;));</a>
<a name="ln494">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.brackets),</a>
<a name="ln495">               _(&quot;the amount of brackets on each side of centered shoot, amount of images = (brackets*2)+1.&quot;));</a>
<a name="ln496">  gtk_widget_set_tooltip_text(GTK_WIDGET(lib-&gt;gui.steps),</a>
<a name="ln497">               _(&quot;the amount of steps per bracket, steps is camera configurable and usually 3 steps per &quot;</a>
<a name="ln498">                 &quot;stop\nwith other words, 3 steps is 1EV exposure step between brackets.&quot;));</a>
<a name="ln499"> </a>
<a name="ln500">  g_signal_connect(G_OBJECT(lib-&gt;gui.toggle_timer), &quot;clicked&quot;, G_CALLBACK(_toggle_capture_mode_clicked), lib);</a>
<a name="ln501">  g_signal_connect(G_OBJECT(lib-&gt;gui.toggle_sequence), &quot;clicked&quot;, G_CALLBACK(_toggle_capture_mode_clicked), lib);</a>
<a name="ln502">  g_signal_connect(G_OBJECT(lib-&gt;gui.toggle_bracket), &quot;clicked&quot;, G_CALLBACK(_toggle_capture_mode_clicked), lib);</a>
<a name="ln503">  g_signal_connect(G_OBJECT(lib-&gt;gui.button1), &quot;clicked&quot;, G_CALLBACK(_capture_button_clicked), lib);</a>
<a name="ln504"> </a>
<a name="ln505">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.timer), FALSE);</a>
<a name="ln506">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.count), FALSE);</a>
<a name="ln507">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.brackets), FALSE);</a>
<a name="ln508">  gtk_widget_set_sensitive(GTK_WIDGET(lib-&gt;gui.steps), FALSE);</a>
<a name="ln509"> </a>
<a name="ln510">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.timer);</a>
<a name="ln511">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.count);</a>
<a name="ln512">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.brackets);</a>
<a name="ln513">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.steps);</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">  // Camera settings</a>
<a name="ln517">  label = dt_ui_section_label_new(_(&quot;properties&quot;));</a>
<a name="ln518">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln519">  dt_gui_add_help_link(self-&gt;widget, &quot;camera_settings.html#camera_settings&quot;);</a>
<a name="ln520"> </a>
<a name="ln521">  lib-&gt;gui.prop_start = lib-&gt;gui.rows -1;</a>
<a name="ln522">  lib-&gt;gui.prop_end = lib-&gt;gui.rows;</a>
<a name="ln523"> </a>
<a name="ln524"> </a>
<a name="ln525">  // user specified properties</a>
<a name="ln526">  label = dt_ui_section_label_new(_(&quot;additional properties&quot;));</a>
<a name="ln527">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln528">  dt_gui_add_help_link(self-&gt;widget, &quot;camera_settings.html#camera_settings&quot;);</a>
<a name="ln529"> </a>
<a name="ln530">  label = gtk_label_new(_(&quot;label&quot;));</a>
<a name="ln531">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln532">  lib-&gt;gui.plabel = gtk_entry_new();</a>
<a name="ln533">  gtk_entry_set_width_chars(GTK_ENTRY(lib-&gt;gui.plabel), 0);</a>
<a name="ln534">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.plabel);</a>
<a name="ln535">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln536">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(lib-&gt;gui.plabel), GTK_WIDGET(label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln537"> </a>
<a name="ln538">  hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, DT_PIXEL_APPLY_DPI(5)));</a>
<a name="ln539">  label = gtk_label_new(_(&quot;property&quot;));</a>
<a name="ln540">  gtk_widget_set_halign(label, GTK_ALIGN_START);</a>
<a name="ln541">  GtkWidget *widget = gtk_button_new_with_label(&quot;O&quot;);</a>
<a name="ln542">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_show_property_popupmenu_clicked), lib);</a>
<a name="ln543">  lib-&gt;gui.pname = gtk_entry_new();</a>
<a name="ln544">  gtk_entry_set_width_chars(GTK_ENTRY(lib-&gt;gui.pname), 0);</a>
<a name="ln545">  dt_gui_key_accel_block_on_focus_connect(lib-&gt;gui.pname);</a>
<a name="ln546">  gtk_box_pack_start(hbox, GTK_WIDGET(lib-&gt;gui.pname), TRUE, TRUE, 0);</a>
<a name="ln547">  gtk_box_pack_start(hbox, GTK_WIDGET(widget), FALSE, FALSE, 0);</a>
<a name="ln548">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(label), 0, lib-&gt;gui.rows++, 1, 1);</a>
<a name="ln549">  gtk_grid_attach_next_to(GTK_GRID(self-&gt;widget), GTK_WIDGET(hbox), GTK_WIDGET(label), GTK_POS_RIGHT, 1, 1);</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">  widget = gtk_button_new_with_label(_(&quot;add user property&quot;));</a>
<a name="ln553">  g_signal_connect(G_OBJECT(widget), &quot;clicked&quot;, G_CALLBACK(_add_property_button_clicked), lib);</a>
<a name="ln554">  gtk_widget_show(widget);</a>
<a name="ln555">  gtk_grid_attach(GTK_GRID(self-&gt;widget), GTK_WIDGET(widget), 0, lib-&gt;gui.rows++, 2, 1);</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">void gui_cleanup(dt_lib_module_t *self)</a>
<a name="ln561">{</a>
<a name="ln562">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln563">  dt_gui_key_accel_block_on_focus_disconnect(lib-&gt;gui.plabel);</a>
<a name="ln564">  dt_gui_key_accel_block_on_focus_disconnect(lib-&gt;gui.pname);</a>
<a name="ln565">  free(lib-&gt;data.listener);</a>
<a name="ln566">  lib-&gt;data.listener = NULL;</a>
<a name="ln567">  free(self-&gt;data);</a>
<a name="ln568">  self-&gt;data = NULL;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">void view_enter(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln572">{</a>
<a name="ln573">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln574">  /* add all camera properties to the widget */</a>
<a name="ln575">  dt_lib_camera_property_t *prop;</a>
<a name="ln576">  if((prop = _lib_property_add_new(lib, _(&quot;program&quot;), &quot;expprogram&quot;)) != NULL)</a>
<a name="ln577">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln578"> </a>
<a name="ln579">  if((prop = _lib_property_add_new(lib, _(&quot;focus mode&quot;), &quot;focusmode&quot;)) != NULL)</a>
<a name="ln580">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln581">  else if((prop = _lib_property_add_new(lib, _(&quot;focus mode&quot;), &quot;drivemode&quot;)) != NULL)</a>
<a name="ln582">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln583"> </a>
<a name="ln584">  if((prop = _lib_property_add_new(lib, _(&quot;aperture&quot;), &quot;f-number&quot;)) != NULL)</a>
<a name="ln585">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln586">  else if((prop = _lib_property_add_new(lib, _(&quot;aperture&quot;), &quot;aperture&quot;)) != NULL) // for Canon cameras</a>
<a name="ln587">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln588"> </a>
<a name="ln589">  if((prop = _lib_property_add_new(lib, _(&quot;focal length&quot;), &quot;focallength&quot;)) != NULL)</a>
<a name="ln590">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln591"> </a>
<a name="ln592">  if((prop = _lib_property_add_new(lib, _(&quot;shutterspeed2&quot;), &quot;shutterspeed2&quot;)) != NULL)</a>
<a name="ln593">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln594">  else if((prop = _lib_property_add_new(lib, _(&quot;shutterspeed&quot;), &quot;shutterspeed&quot;)) != NULL) // Canon, again</a>
<a name="ln595">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln596"> </a>
<a name="ln597">  if((prop = _lib_property_add_new(lib, _(&quot;ISO&quot;), &quot;iso&quot;)) != NULL)</a>
<a name="ln598">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln599"> </a>
<a name="ln600">  if((prop = _lib_property_add_new(lib, _(&quot;WB&quot;), &quot;whitebalance&quot;)) != NULL)</a>
<a name="ln601">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln602"> </a>
<a name="ln603">  if((prop = _lib_property_add_new(lib, _(&quot;quality&quot;), &quot;imagequality&quot;)) != NULL)</a>
<a name="ln604">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln605"> </a>
<a name="ln606">  if((prop = _lib_property_add_new(lib, _(&quot;size&quot;), &quot;imagesize&quot;)) != NULL)</a>
<a name="ln607">    _lib_property_add_to_gui(prop, lib);</a>
<a name="ln608"> </a>
<a name="ln609">  /* add user widgets */</a>
<a name="ln610">  GSList *options = dt_conf_all_string_entries(&quot;plugins/capture/tethering/properties&quot;);</a>
<a name="ln611">  if(options)</a>
<a name="ln612">  {</a>
<a name="ln613">    GSList *item = options;</a>
<a name="ln614">    do</a>
<a name="ln615">    {</a>
<a name="ln616">      dt_conf_string_entry_t *entry = (dt_conf_string_entry_t *)item-&gt;data;</a>
<a name="ln617"> </a>
<a name="ln618">      /* get the label from key */</a>
<a name="ln619">      char *p = entry-&gt;key;</a>
<a name="ln620">      const char *end = entry-&gt;key + strlen(entry-&gt;key);</a>
<a name="ln621">      while(p++ &lt; end)</a>
<a name="ln622">        if(*p == '_') *p = ' ';</a>
<a name="ln623"> </a>
<a name="ln624">      if((prop = _lib_property_add_new(lib, entry-&gt;key, entry-&gt;value)) != NULL)</a>
<a name="ln625">        _lib_property_add_to_gui(prop, lib);</a>
<a name="ln626">    } while((item = g_slist_next(item)) != NULL);</a>
<a name="ln627">    g_slist_free_full(options, dt_conf_string_entry_free);</a>
<a name="ln628">  }</a>
<a name="ln629">  /* build the propertymenu  we do it now because it needs an actual camera */</a>
<a name="ln630">  dt_camctl_camera_build_property_menu(darktable.camctl, NULL, &amp;lib-&gt;gui.properties_menu,</a>
<a name="ln631">                                       G_CALLBACK(_property_choice_callback), lib);</a>
<a name="ln632"> </a>
<a name="ln633">  // Register listener</a>
<a name="ln634">  dt_camctl_register_listener(darktable.camctl, lib-&gt;data.listener);</a>
<a name="ln635">  dt_camctl_tether_mode(darktable.camctl, NULL, TRUE);</a>
<a name="ln636">  // Get camera model name</a>
<a name="ln637">  lib-&gt;data.camera_model = dt_camctl_camera_get_model(darktable.camctl, NULL);</a>
<a name="ln638">}</a>
<a name="ln639">void view_leave(struct dt_lib_module_t *self,struct dt_view_t *old_view,struct dt_view_t *new_view)</a>
<a name="ln640">{</a>
<a name="ln641">  dt_lib_camera_t *lib = self-&gt;data;</a>
<a name="ln642">  // remove listener from camera control..</a>
<a name="ln643">  dt_camctl_tether_mode(darktable.camctl, NULL, FALSE);</a>
<a name="ln644">  dt_camctl_unregister_listener(darktable.camctl, lib-&gt;data.listener);</a>
<a name="ln645">  gtk_widget_destroy(GTK_WIDGET(lib-&gt;gui.properties_menu));</a>
<a name="ln646">  lib-&gt;gui.properties_menu = NULL;</a>
<a name="ln647">  // remove all properties</a>
<a name="ln648">  while(lib-&gt;gui.prop_end &gt; lib-&gt;gui.prop_start +1) {</a>
<a name="ln649">    gtk_grid_remove_row(lib-&gt;gui.main_grid,lib-&gt;gui.prop_start +1);</a>
<a name="ln650">    lib-&gt;gui.rows--;</a>
<a name="ln651">    lib-&gt;gui.prop_end--;</a>
<a name="ln652">  }</a>
<a name="ln653">  // no need to free widgets, they are freed when the line of the grid is destroyed</a>
<a name="ln654">  g_list_free_full(lib-&gt;gui.properties,_lib_property_free);</a>
<a name="ln655">  lib-&gt;gui.properties = NULL;</a>
<a name="ln656">}</a>
<a name="ln657">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln658">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln659">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="135"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'prop'. Check lines: 135, 134.</p></div>
<div class="balloon" rel="358"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'sprintf' function will lead to overflow of the buffer 'model + strlen(model)'.</p></div>
<div class="balloon" rel="336"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v751/" target="_blank">V751</a> Parameter 'height' is not used inside function body.</p></div>
<div class="balloon" rel="423"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'lib'. Check lines: 423, 419.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
