
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    This file is part of darktable,</a>
<a name="ln3">    copyright (c) 2012--2013 aldric renaudin.</a>
<a name="ln4">    copyright (c) 2013--2016 Ulrich Pegelow.</a>
<a name="ln5"> </a>
<a name="ln6">    darktable is free software: you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation, either version 3 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    darktable is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with darktable.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</a>
<a name="ln18">*/</a>
<a name="ln19">#include &quot;common/debug.h&quot;</a>
<a name="ln20">#include &quot;control/conf.h&quot;</a>
<a name="ln21">#include &quot;control/control.h&quot;</a>
<a name="ln22">#include &quot;develop/blend.h&quot;</a>
<a name="ln23">#include &quot;develop/imageop.h&quot;</a>
<a name="ln24">#include &quot;develop/masks.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">static inline void _ellipse_point_transform(const float xref, const float yref, const float x, const float y,</a>
<a name="ln27">                                            const float sinr, const float cosr, const float scalea,</a>
<a name="ln28">                                            const float scaleb, const float sinv, const float cosv,</a>
<a name="ln29">                                            float *xnew, float *ynew)</a>
<a name="ln30">{</a>
<a name="ln31">  float xtmp = (scaleb * sinr * sinr + scalea * cosr * cosr) * (x - xref)</a>
<a name="ln32">               + (scalea * cosr * sinr - scaleb * cosr * sinr) * (y - yref);</a>
<a name="ln33">  float ytmp = (scalea * cosr * sinr - scaleb * cosr * sinr) * (x - xref)</a>
<a name="ln34">               + (scalea * sinr * sinr + scaleb * cosr * cosr) * (y - yref);</a>
<a name="ln35"> </a>
<a name="ln36">  *xnew = xref + cosv * xtmp - sinv * ytmp;</a>
<a name="ln37">  *ynew = yref + sinv * xtmp + cosv * ytmp;</a>
<a name="ln38">}</a>
<a name="ln39"> </a>
<a name="ln40">// Jordan's point in polygon test</a>
<a name="ln41">static int dt_ellipse_cross_test(float x, float y, float *point_1, float *point_2)</a>
<a name="ln42">{</a>
<a name="ln43">  float x_a = x;</a>
<a name="ln44">  float y_a = y;</a>
<a name="ln45">  float x_b = point_1[0];</a>
<a name="ln46">  float y_b = point_1[1];</a>
<a name="ln47">  float x_c = point_2[0];</a>
<a name="ln48">  float y_c = point_2[1];</a>
<a name="ln49"> </a>
<a name="ln50">  if(y_a == y_b &amp;&amp; y_b == y_c)</a>
<a name="ln51">  {</a>
<a name="ln52">    if((x_b &lt;= x_a &amp;&amp; x_a &lt;= x_c) || (x_c &lt;= x_a &amp;&amp; x_a &lt;= x_b))</a>
<a name="ln53">      return 0;</a>
<a name="ln54">    else</a>
<a name="ln55">      return 1;</a>
<a name="ln56">  }</a>
<a name="ln57"> </a>
<a name="ln58">  if(y_b &gt; y_c)</a>
<a name="ln59">  {</a>
<a name="ln60">    float tmp;</a>
<a name="ln61">    tmp = x_b, x_b = x_c, x_c = tmp;</a>
<a name="ln62">    tmp = y_b, y_b = y_c, y_c = tmp;</a>
<a name="ln63">  }</a>
<a name="ln64"> </a>
<a name="ln65">  if(y_a == y_b &amp;&amp; x_a == x_b) return 0;</a>
<a name="ln66"> </a>
<a name="ln67">  if(y_a &lt;= y_b || y_a &gt; y_c) return 1;</a>
<a name="ln68"> </a>
<a name="ln69">  float delta = (x_b - x_a) * (y_c - y_a) - (y_b - y_a) * (x_c - x_a);</a>
<a name="ln70"> </a>
<a name="ln71">  if(delta &gt; 0)</a>
<a name="ln72">    return -1;</a>
<a name="ln73">  else if(delta &lt; 0)</a>
<a name="ln74">    return 1;</a>
<a name="ln75">  else</a>
<a name="ln76">    return 0;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">static int dt_ellipse_point_in_polygon(float x, float y, float *points, int points_count)</a>
<a name="ln80">{</a>
<a name="ln81">  int t = -1;</a>
<a name="ln82"> </a>
<a name="ln83">  t *= dt_ellipse_cross_test(x, y, points + 2 * (points_count - 1), points);</a>
<a name="ln84"> </a>
<a name="ln85">  for(int i = 0; i &lt; points_count - 2; i++)</a>
<a name="ln86">    t *= dt_ellipse_cross_test(x, y, points + 2 * i, points + 2 * (i + 1));</a>
<a name="ln87"> </a>
<a name="ln88">  return t;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">// check if point is close to path - segment by segment</a>
<a name="ln92">static int dt_ellipse_point_close_to_path(float x, float y, float as, float *points, int points_count)</a>
<a name="ln93">{</a>
<a name="ln94">  float as2 = as * as;</a>
<a name="ln95"> </a>
<a name="ln96">  float lastx = points[2 * (points_count - 1)];</a>
<a name="ln97">  float lasty = points[2 * (points_count - 1) + 1];</a>
<a name="ln98"> </a>
<a name="ln99">  for(int i = 0; i &lt; points_count; i++)</a>
<a name="ln100">  {</a>
<a name="ln101">    float px = points[2 * i];</a>
<a name="ln102">    float py = points[2 * i + 1];</a>
<a name="ln103"> </a>
<a name="ln104">    float r1 = x - lastx;</a>
<a name="ln105">    float r2 = y - lasty;</a>
<a name="ln106">    float r3 = px - lastx;</a>
<a name="ln107">    float r4 = py - lasty;</a>
<a name="ln108"> </a>
<a name="ln109">    float d = r1 * r3 + r2 * r4;</a>
<a name="ln110">    float l = r3 * r3 + r4 * r4;</a>
<a name="ln111">    float p = d / l;</a>
<a name="ln112"> </a>
<a name="ln113">    float xx, yy;</a>
<a name="ln114"> </a>
<a name="ln115">    if(p &lt; 0 || (px == lastx &amp;&amp; py == lasty))</a>
<a name="ln116">    {</a>
<a name="ln117">      xx = lastx;</a>
<a name="ln118">      yy = lasty;</a>
<a name="ln119">    }</a>
<a name="ln120">    else if(p &gt; 1)</a>
<a name="ln121">    {</a>
<a name="ln122">      xx = px;</a>
<a name="ln123">      yy = py;</a>
<a name="ln124">    }</a>
<a name="ln125">    else</a>
<a name="ln126">    {</a>
<a name="ln127">      xx = lastx + p * r3;</a>
<a name="ln128">      yy = lasty + p * r4;</a>
<a name="ln129">    }</a>
<a name="ln130"> </a>
<a name="ln131">    float dx = x - xx;</a>
<a name="ln132">    float dy = y - yy;</a>
<a name="ln133"> </a>
<a name="ln134">    if(dx * dx + dy * dy &lt; as2) return 1;</a>
<a name="ln135">  }</a>
<a name="ln136">  return 0;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">static void dt_ellipse_get_distance(float x, int y, float as, dt_masks_form_gui_t *gui, int index,</a>
<a name="ln140">                                    int *inside, int *inside_border, int *near, int *inside_source)</a>
<a name="ln141">{</a>
<a name="ln142">  if(!gui) return;</a>
<a name="ln143"> </a>
<a name="ln144">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln145">  if(!gpt) return;</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">  // we first check if we are inside the source form</a>
<a name="ln149">  if(gpt-&gt;source_count &gt; 10)</a>
<a name="ln150">  {</a>
<a name="ln151">    if(dt_ellipse_point_in_polygon(x, y, gpt-&gt;source + 10, gpt-&gt;source_count - 5) &gt;= 0)</a>
<a name="ln152">    {</a>
<a name="ln153">      *inside_source = 1;</a>
<a name="ln154">      *inside = 1;</a>
<a name="ln155">      *inside_border = 0;</a>
<a name="ln156">      *near = -1;</a>
<a name="ln157">      return;</a>
<a name="ln158">    }</a>
<a name="ln159">  }</a>
<a name="ln160"> </a>
<a name="ln161">  *inside_source = 0;</a>
<a name="ln162"> </a>
<a name="ln163">  // we check if it's inside borders</a>
<a name="ln164">  if(dt_ellipse_point_in_polygon(x, y, gpt-&gt;border + 10, gpt-&gt;border_count - 5) &lt; 0)</a>
<a name="ln165">  {</a>
<a name="ln166">    *inside = 0;</a>
<a name="ln167">    *inside_border = 0;</a>
<a name="ln168">    *near = -1;</a>
<a name="ln169">    return;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  *inside = 1;</a>
<a name="ln173">  *near = 0;</a>
<a name="ln174">  *inside_border = 1;</a>
<a name="ln175"> </a>
<a name="ln176">  if(dt_ellipse_point_in_polygon(x, y, gpt-&gt;points + 10, gpt-&gt;points_count - 5) &gt;= 0) *inside_border = 0;</a>
<a name="ln177">  if(dt_ellipse_point_close_to_path(x, y, as, gpt-&gt;points + 10, gpt-&gt;points_count - 5)) *near = 1;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static void dt_ellipse_draw_shape(cairo_t *cr, double *dashed, const int selected, const float zoom_scale,</a>
<a name="ln181">                                  const float dx, const float dy, const float xref, const float yref,</a>
<a name="ln182">                                  const float sinv, const float cosv, const float scalea, const float scaleb,</a>
<a name="ln183">                                  float *points, const int points_count)</a>
<a name="ln184">{</a>
<a name="ln185">  if(points_count &lt;= 10) return;</a>
<a name="ln186"> </a>
<a name="ln187">  const float r = atan2(points[3] - points[1], points[2] - points[0]);</a>
<a name="ln188">  const float sinr = sin(r);</a>
<a name="ln189">  const float cosr = cos(r);</a>
<a name="ln190"> </a>
<a name="ln191">  float x = 0.f;</a>
<a name="ln192">  float y = 0.f;</a>
<a name="ln193"> </a>
<a name="ln194">  cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln195">  if(selected)</a>
<a name="ln196">    cairo_set_line_width(cr, 5.0 / zoom_scale);</a>
<a name="ln197">  else</a>
<a name="ln198">    cairo_set_line_width(cr, 3.0 / zoom_scale);</a>
<a name="ln199">  cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln200"> </a>
<a name="ln201">  _ellipse_point_transform(xref, yref, points[10] + dx, points[11] + dy, sinr, cosr, scalea, scaleb, sinv, cosv,</a>
<a name="ln202">                           &amp;x, &amp;y);</a>
<a name="ln203">  cairo_move_to(cr, x, y);</a>
<a name="ln204">  for(int i = 6; i &lt; points_count; i++)</a>
<a name="ln205">  {</a>
<a name="ln206">    _ellipse_point_transform(xref, yref, points[i * 2] + dx, points[i * 2 + 1] + dy, sinr, cosr, scalea, scaleb,</a>
<a name="ln207">                             sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln208">    cairo_line_to(cr, x, y);</a>
<a name="ln209">  }</a>
<a name="ln210">  _ellipse_point_transform(xref, yref, points[10] + dx, points[11] + dy, sinr, cosr, scalea, scaleb, sinv, cosv,</a>
<a name="ln211">                           &amp;x, &amp;y);</a>
<a name="ln212">  cairo_line_to(cr, x, y);</a>
<a name="ln213">  cairo_stroke_preserve(cr);</a>
<a name="ln214">  if(selected)</a>
<a name="ln215">    cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln216">  else</a>
<a name="ln217">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln218">  cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln219">  cairo_stroke(cr);</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">static void dt_ellipse_draw_border(cairo_t *cr, double *dashed, const float len, const int selected,</a>
<a name="ln223">                                   const float zoom_scale, const float dx, const float dy, const float xref,</a>
<a name="ln224">                                   const float yref, const float sinv, const float cosv, const float scaleab,</a>
<a name="ln225">                                   const float scalebb, float *border, const int border_count)</a>
<a name="ln226">{</a>
<a name="ln227">  if(border_count &lt;= 10) return;</a>
<a name="ln228"> </a>
<a name="ln229">  const float r = atan2(border[3] - border[1], border[2] - border[0]);</a>
<a name="ln230">  const float sinr = sin(r);</a>
<a name="ln231">  const float cosr = cos(r);</a>
<a name="ln232"> </a>
<a name="ln233">  float x = 0.f;</a>
<a name="ln234">  float y = 0.f;</a>
<a name="ln235"> </a>
<a name="ln236">  cairo_set_dash(cr, dashed, len, 0);</a>
<a name="ln237">  if(selected)</a>
<a name="ln238">    cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln239">  else</a>
<a name="ln240">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln241">  cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln242"> </a>
<a name="ln243">  _ellipse_point_transform(xref, yref, border[10] + dx, border[11] + dy, sinr, cosr, scaleab, scalebb, sinv, cosv,</a>
<a name="ln244">                           &amp;x, &amp;y);</a>
<a name="ln245">  cairo_move_to(cr, x, y);</a>
<a name="ln246">  for(int i = 6; i &lt; border_count; i++)</a>
<a name="ln247">  {</a>
<a name="ln248">    _ellipse_point_transform(xref, yref, border[i * 2] + dx, border[i * 2 + 1] + dy, sinr, cosr, scaleab, scalebb,</a>
<a name="ln249">                             sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln250">    cairo_line_to(cr, x, y);</a>
<a name="ln251">  }</a>
<a name="ln252">  _ellipse_point_transform(xref, yref, border[10] + dx, border[11] + dy, sinr, cosr, scaleab, scalebb, sinv, cosv,</a>
<a name="ln253">                           &amp;x, &amp;y);</a>
<a name="ln254">  cairo_line_to(cr, x, y);</a>
<a name="ln255"> </a>
<a name="ln256">  cairo_stroke_preserve(cr);</a>
<a name="ln257">  if(selected)</a>
<a name="ln258">    cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln259">  else</a>
<a name="ln260">    cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln261">  cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln262">  cairo_set_dash(cr, dashed, len, 4);</a>
<a name="ln263">  cairo_stroke(cr);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">static int dt_ellipse_get_points(dt_develop_t *dev, float xx, float yy, float radius_a, float radius_b,</a>
<a name="ln267">                                 float rotation, float **points, int *points_count)</a>
<a name="ln268">{</a>
<a name="ln269">  const float wd = dev-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln270">  const float ht = dev-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln271">  const float v1 = (rotation / 180.0f) * M_PI;</a>
<a name="ln272">  const float v2 = (rotation - 90.0f) / 180.0f * M_PI;</a>
<a name="ln273">  float a, b, v;</a>
<a name="ln274"> </a>
<a name="ln275">  if(radius_a &gt;= radius_b)</a>
<a name="ln276">  {</a>
<a name="ln277">    a = radius_a * MIN(wd, ht);</a>
<a name="ln278">    b = radius_b * MIN(wd, ht);</a>
<a name="ln279">    v = v1;</a>
<a name="ln280">  }</a>
<a name="ln281">  else</a>
<a name="ln282">  {</a>
<a name="ln283">    a = radius_b * MIN(wd, ht);</a>
<a name="ln284">    b = radius_a * MIN(wd, ht);</a>
<a name="ln285">    v = v2;</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  const float sinv = sinf(v);</a>
<a name="ln289">  const float cosv = cosf(v);</a>
<a name="ln290"> </a>
<a name="ln291"> </a>
<a name="ln292">  // how many points do we need? we only take every nth point and rely on interpolation (only affecting GUI</a>
<a name="ln293">  // anyhow)</a>
<a name="ln294">  const int n = 10;</a>
<a name="ln295">  const float lambda = (a - b) / (a + b);</a>
<a name="ln296">  const int l = MAX(</a>
<a name="ln297">      100, (int)((M_PI * (a + b)</a>
<a name="ln298">                  * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda)))) / n));</a>
<a name="ln299"> </a>
<a name="ln300">  // buffer allocations</a>
<a name="ln301">  *points = calloc(2 * (l + 5), sizeof(float));</a>
<a name="ln302">  *points_count = l + 5;</a>
<a name="ln303"> </a>
<a name="ln304">  // now we set the points</a>
<a name="ln305">  const float x = (*points)[0] = xx * wd;</a>
<a name="ln306">  const float y = (*points)[1] = yy * ht;</a>
<a name="ln307"> </a>
<a name="ln308">  (*points)[2] = x + a * cos(v);</a>
<a name="ln309">  (*points)[3] = y + a * sin(v);</a>
<a name="ln310">  (*points)[4] = x - a * cos(v);</a>
<a name="ln311">  (*points)[5] = y - a * sin(v);</a>
<a name="ln312"> </a>
<a name="ln313">  (*points)[6] = x + b * cos(v - M_PI / 2.0f);</a>
<a name="ln314">  (*points)[7] = y + b * sin(v - M_PI / 2.0f);</a>
<a name="ln315">  (*points)[8] = x - b * cos(v - M_PI / 2.0f);</a>
<a name="ln316">  (*points)[9] = y - b * sin(v - M_PI / 2.0f);</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">  for(int i = 5; i &lt; l + 5; i++)</a>
<a name="ln320">  {</a>
<a name="ln321">    float alpha = (i - 5) * 2.0 * M_PI / (float)l;</a>
<a name="ln322">    (*points)[i * 2] = x + a * cosf(alpha) * cosv - b * sinf(alpha) * sinv;</a>
<a name="ln323">    (*points)[i * 2 + 1] = y + a * cosf(alpha) * sinv + b * sinf(alpha) * cosv;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  // and we transform them with all distorted modules</a>
<a name="ln327">  if(dt_dev_distort_transform(dev, *points, l + 5)) return 1;</a>
<a name="ln328"> </a>
<a name="ln329">  // if we failed, then free all and return</a>
<a name="ln330">  free(*points);</a>
<a name="ln331">  *points = NULL;</a>
<a name="ln332">  *points_count = 0;</a>
<a name="ln333">  return 0;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">static int dt_ellipse_events_mouse_scrolled(struct dt_iop_module_t *module, float pzx, float pzy, int up,</a>
<a name="ln337">                                            uint32_t state, dt_masks_form_t *form, int parentid,</a>
<a name="ln338">                                            dt_masks_form_gui_t *gui, int index)</a>
<a name="ln339">{</a>
<a name="ln340">  // add a preview when creating an ellipse</a>
<a name="ln341">  if(gui-&gt;creation)</a>
<a name="ln342">  {</a>
<a name="ln343">    if((state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) == (GDK_SHIFT_MASK | GDK_CONTROL_MASK))</a>
<a name="ln344">    {</a>
<a name="ln345">      float rotation;</a>
<a name="ln346"> </a>
<a name="ln347">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln348">        rotation = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;);</a>
<a name="ln349">      else</a>
<a name="ln350">        rotation = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;);</a>
<a name="ln351"> </a>
<a name="ln352">      if(up)</a>
<a name="ln353">        rotation -= 10.f;</a>
<a name="ln354">      else</a>
<a name="ln355">        rotation += 10.f;</a>
<a name="ln356">      rotation = fmodf(rotation, 360.0f);</a>
<a name="ln357"> </a>
<a name="ln358">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln359">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;, rotation);</a>
<a name="ln360">      else</a>
<a name="ln361">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;, rotation);</a>
<a name="ln362">    }</a>
<a name="ln363">    else if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln364">    {</a>
<a name="ln365">      float masks_border;</a>
<a name="ln366">      int flags;</a>
<a name="ln367">      float radius_a;</a>
<a name="ln368">      float radius_b;</a>
<a name="ln369"> </a>
<a name="ln370">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln371">      {</a>
<a name="ln372">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_border&quot;);</a>
<a name="ln373">        flags = dt_conf_get_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;);</a>
<a name="ln374">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln375">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln376">      }</a>
<a name="ln377">      else</a>
<a name="ln378">      {</a>
<a name="ln379">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/border&quot;);</a>
<a name="ln380">        flags = dt_conf_get_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;);</a>
<a name="ln381">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln382">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln383">      }</a>
<a name="ln384"> </a>
<a name="ln385">      const float reference = (flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f / fmin(radius_a, radius_b) : 1.0f);</a>
<a name="ln386">      if(up &amp;&amp; masks_border &gt; 0.001f * reference)</a>
<a name="ln387">        masks_border *= 0.97f;</a>
<a name="ln388">      else if(!up &amp;&amp; masks_border &lt; 1.0f * reference)</a>
<a name="ln389">        masks_border *= 1.0f / 0.97f;</a>
<a name="ln390">      else</a>
<a name="ln391">        return 1;</a>
<a name="ln392">      masks_border = CLAMP(masks_border, 0.001f * reference, reference);</a>
<a name="ln393"> </a>
<a name="ln394">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln395">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_border&quot;, masks_border);</a>
<a name="ln396">      else</a>
<a name="ln397">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/border&quot;, masks_border);</a>
<a name="ln398">    }</a>
<a name="ln399">    else if(state == 0)</a>
<a name="ln400">    {</a>
<a name="ln401">      float radius_a;</a>
<a name="ln402">      float radius_b;</a>
<a name="ln403"> </a>
<a name="ln404">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln405">      {</a>
<a name="ln406">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln407">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln408">      }</a>
<a name="ln409">      else</a>
<a name="ln410">      {</a>
<a name="ln411">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln412">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln413">      }</a>
<a name="ln414"> </a>
<a name="ln415">      const float oldradius = radius_a;</a>
<a name="ln416"> </a>
<a name="ln417">      if(up &amp;&amp; radius_a &gt; 0.001f)</a>
<a name="ln418">        radius_a *= 0.97f;</a>
<a name="ln419">      else if(!up &amp;&amp; radius_a &lt; 1.0f)</a>
<a name="ln420">        radius_a *= 1.0f / 0.97f;</a>
<a name="ln421">      else</a>
<a name="ln422">        return 1;</a>
<a name="ln423"> </a>
<a name="ln424">      radius_a = CLAMP(radius_a, 0.001f, 1.0f);</a>
<a name="ln425"> </a>
<a name="ln426">      const float factor = radius_a / oldradius;</a>
<a name="ln427">      radius_b *= factor;</a>
<a name="ln428"> </a>
<a name="ln429">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln430">      {</a>
<a name="ln431">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;, radius_a);</a>
<a name="ln432">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;, radius_b);</a>
<a name="ln433">      }</a>
<a name="ln434">      else</a>
<a name="ln435">      {</a>
<a name="ln436">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;, radius_a);</a>
<a name="ln437">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;, radius_b);</a>
<a name="ln438">      }</a>
<a name="ln439">    }</a>
<a name="ln440">    return 1;</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  if(gui-&gt;form_selected)</a>
<a name="ln444">  {</a>
<a name="ln445">    // we register the current position</a>
<a name="ln446">    if(gui-&gt;scrollx == 0.0f &amp;&amp; gui-&gt;scrolly == 0.0f)</a>
<a name="ln447">    {</a>
<a name="ln448">      gui-&gt;scrollx = pzx;</a>
<a name="ln449">      gui-&gt;scrolly = pzy;</a>
<a name="ln450">    }</a>
<a name="ln451">    if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK &amp;&amp; !((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK))</a>
<a name="ln452">    {</a>
<a name="ln453">      // we try to change the opacity</a>
<a name="ln454">      dt_masks_form_change_opacity(form, parentid, up);</a>
<a name="ln455">    }</a>
<a name="ln456">    else</a>
<a name="ln457">    {</a>
<a name="ln458">      dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln459">      if((state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK)) == (GDK_SHIFT_MASK | GDK_CONTROL_MASK)</a>
<a name="ln460">         &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln461">      {</a>
<a name="ln462">        // we try to change the rotation</a>
<a name="ln463">        if(up)</a>
<a name="ln464">          ellipse-&gt;rotation -= 10.f;</a>
<a name="ln465">        else</a>
<a name="ln466">          ellipse-&gt;rotation += 10.f;</a>
<a name="ln467">        ellipse-&gt;rotation = fmodf(ellipse-&gt;rotation, 360.0f);</a>
<a name="ln468"> </a>
<a name="ln469">        dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln470">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln471">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln472">        if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln473">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln474">        else</a>
<a name="ln475">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln476">      }</a>
<a name="ln477">      // resize don't care where the mouse is inside a shape</a>
<a name="ln478">      if((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)</a>
<a name="ln479">      {</a>
<a name="ln480">        const float reference = (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f/fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]) : 1.0f);</a>
<a name="ln481">        if(up &amp;&amp; ellipse-&gt;border &gt; 0.001f * reference)</a>
<a name="ln482">          ellipse-&gt;border *= 0.97f;</a>
<a name="ln483">        else if(!up &amp;&amp; ellipse-&gt;border &lt; 1.0f * reference)</a>
<a name="ln484">          ellipse-&gt;border *= 1.0f/0.97f;</a>
<a name="ln485">        else return 1;</a>
<a name="ln486">        ellipse-&gt;border = CLAMP(ellipse-&gt;border, 0.001f * reference, reference);</a>
<a name="ln487">        dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln488">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln489">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln490">        if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln491">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_border&quot;, ellipse-&gt;border);</a>
<a name="ln492">        else</a>
<a name="ln493">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/border&quot;, ellipse-&gt;border);</a>
<a name="ln494">      }</a>
<a name="ln495">      else if(gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln496">      {</a>
<a name="ln497">        const float oldradius = ellipse-&gt;radius[0];</a>
<a name="ln498"> </a>
<a name="ln499">        if(up &amp;&amp; ellipse-&gt;radius[0] &gt; 0.001f)</a>
<a name="ln500">          ellipse-&gt;radius[0] *= 0.97f;</a>
<a name="ln501">        else if(!up &amp;&amp; ellipse-&gt;radius[0] &lt; 1.0f)</a>
<a name="ln502">          ellipse-&gt;radius[0] *= 1.0f / 0.97f;</a>
<a name="ln503">        else return 1;</a>
<a name="ln504"> </a>
<a name="ln505">        ellipse-&gt;radius[0] = CLAMP(ellipse-&gt;radius[0], 0.001f, 1.0f);</a>
<a name="ln506"> </a>
<a name="ln507">        const float factor = ellipse-&gt;radius[0] / oldradius;</a>
<a name="ln508">        ellipse-&gt;radius[1] *= factor;</a>
<a name="ln509"> </a>
<a name="ln510">        dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln511">        dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln512">        dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln513">        if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln514">        {</a>
<a name="ln515">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln516">          dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln517">        }</a>
<a name="ln518">        else</a>
<a name="ln519">        {</a>
<a name="ln520">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln521">          dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln522">        }</a>
<a name="ln523">      }</a>
<a name="ln524">      else</a>
<a name="ln525">      {</a>
<a name="ln526">        return 0;</a>
<a name="ln527">      }</a>
<a name="ln528">      dt_masks_update_image(darktable.develop);</a>
<a name="ln529">    }</a>
<a name="ln530">    return 1;</a>
<a name="ln531">  }</a>
<a name="ln532">  return 0;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">static int dt_ellipse_events_button_pressed(struct dt_iop_module_t *module, float pzx, float pzy,</a>
<a name="ln536">                                            double pressure, int which, int type, uint32_t state,</a>
<a name="ln537">                                            dt_masks_form_t *form, int parentid, dt_masks_form_gui_t *gui,</a>
<a name="ln538">                                            int index)</a>
<a name="ln539">{</a>
<a name="ln540">  if(!gui) return 0;</a>
<a name="ln541">  if(gui-&gt;source_selected &amp;&amp; !gui-&gt;creation &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln542">  {</a>
<a name="ln543">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln544">    if(!gpt) return 0;</a>
<a name="ln545">    // we start the source dragging</a>
<a name="ln546">    gui-&gt;source_dragging = TRUE;</a>
<a name="ln547">    gui-&gt;dx = gpt-&gt;source[0] - gui-&gt;posx;</a>
<a name="ln548">    gui-&gt;dy = gpt-&gt;source[1] - gui-&gt;posy;</a>
<a name="ln549">    return 1;</a>
<a name="ln550">  }</a>
<a name="ln551">  else if(gui-&gt;point_selected &gt;= 1 &amp;&amp; !gui-&gt;creation &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL</a>
<a name="ln552">          &amp;&amp; !((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK))</a>
<a name="ln553">  {</a>
<a name="ln554">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln555">    if(!gpt) return 0;</a>
<a name="ln556">    gui-&gt;point_dragging = gui-&gt;point_selected;</a>
<a name="ln557">    gui-&gt;dx = gpt-&gt;points[0] - gui-&gt;posx;</a>
<a name="ln558">    gui-&gt;dy = gpt-&gt;points[1] - gui-&gt;posy;</a>
<a name="ln559">    return 1;</a>
<a name="ln560">  }</a>
<a name="ln561">  else if(gui-&gt;form_selected &amp;&amp; !gui-&gt;creation &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL</a>
<a name="ln562">          &amp;&amp; !((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK))</a>
<a name="ln563">  {</a>
<a name="ln564">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln565">    if(!gpt) return 0;</a>
<a name="ln566">    // we start the form dragging or rotating</a>
<a name="ln567">    if((state &amp; GDK_CONTROL_MASK) == GDK_CONTROL_MASK)</a>
<a name="ln568">      gui-&gt;form_rotating = TRUE;</a>
<a name="ln569">    else</a>
<a name="ln570">      gui-&gt;form_dragging = TRUE;</a>
<a name="ln571">    gui-&gt;dx = gpt-&gt;points[0] - gui-&gt;posx;</a>
<a name="ln572">    gui-&gt;dy = gpt-&gt;points[1] - gui-&gt;posy;</a>
<a name="ln573">    return 1;</a>
<a name="ln574">  }</a>
<a name="ln575">  else if(gui-&gt;form_selected &amp;&amp; !gui-&gt;creation &amp;&amp; ((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK))</a>
<a name="ln576">  {</a>
<a name="ln577">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln578">    if(!gpt) return 0;</a>
<a name="ln579"> </a>
<a name="ln580">    gui-&gt;border_toggling = TRUE;</a>
<a name="ln581"> </a>
<a name="ln582">    return 1;</a>
<a name="ln583">  }</a>
<a name="ln584">  else if(gui-&gt;creation &amp;&amp; (which == 3))</a>
<a name="ln585">  {</a>
<a name="ln586">    gui-&gt;creation_continuous = FALSE;</a>
<a name="ln587">    gui-&gt;creation_continuous_module = NULL;</a>
<a name="ln588">    dt_masks_set_edit_mode(module, DT_MASKS_EDIT_FULL);</a>
<a name="ln589">    dt_masks_iop_update(module);</a>
<a name="ln590">    dt_control_queue_redraw_center();</a>
<a name="ln591">    return 1;</a>
<a name="ln592">  }</a>
<a name="ln593">  else if(gui-&gt;creation &amp;&amp; which == 1</a>
<a name="ln594">          &amp;&amp; (((state &amp; (GDK_CONTROL_MASK | GDK_SHIFT_MASK)) == (GDK_CONTROL_MASK | GDK_SHIFT_MASK))</a>
<a name="ln595">              || ((state &amp; GDK_SHIFT_MASK) == GDK_SHIFT_MASK)))</a>
<a name="ln596">  {</a>
<a name="ln597">    // set some absolute or relative position for the source of the clone mask</a>
<a name="ln598">    if(form-&gt;type &amp; DT_MASKS_CLONE) dt_masks_set_source_pos_initial_state(gui, state, pzx, pzy);</a>
<a name="ln599"> </a>
<a name="ln600">    return 1;</a>
<a name="ln601">  }</a>
<a name="ln602">  else if(gui-&gt;creation)</a>
<a name="ln603">  {</a>
<a name="ln604">    dt_iop_module_t *crea_module = gui-&gt;creation_module;</a>
<a name="ln605">    // we create the ellipse</a>
<a name="ln606">    dt_masks_point_ellipse_t *ellipse</a>
<a name="ln607">        = (dt_masks_point_ellipse_t *)(malloc(sizeof(dt_masks_point_ellipse_t)));</a>
<a name="ln608"> </a>
<a name="ln609">    // we change the center value</a>
<a name="ln610">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln611">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln612">    float pts[2] = { pzx * wd, pzy * ht };</a>
<a name="ln613">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln614">    ellipse-&gt;center[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln615">    ellipse-&gt;center[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln616"> </a>
<a name="ln617">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln618">    {</a>
<a name="ln619">      const float a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln620">      const float b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln621">      const float ellipse_border = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_border&quot;);</a>
<a name="ln622">      const float rotation = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;);</a>
<a name="ln623">      const int flags = dt_conf_get_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;);</a>
<a name="ln624">      ellipse-&gt;radius[0] = MAX(0.001f, MIN(0.5f, a));</a>
<a name="ln625">      ellipse-&gt;radius[1] = MAX(0.001f, MIN(0.5f, b));</a>
<a name="ln626">      ellipse-&gt;flags = flags;</a>
<a name="ln627">      ellipse-&gt;rotation = rotation;</a>
<a name="ln628">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln629">      const float reference = (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f/min_radius : 1.0f);</a>
<a name="ln630">      ellipse-&gt;border = MAX(0.005f * reference, MIN(0.5f * reference, ellipse_border));</a>
<a name="ln631">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln632">      {</a>
<a name="ln633">        dt_masks_set_source_pos_initial_value(gui, DT_MASKS_ELLIPSE, form, pzx, pzy);</a>
<a name="ln634">      }</a>
<a name="ln635">      else</a>
<a name="ln636">      {</a>
<a name="ln637">        // not used for regular masks</a>
<a name="ln638">        form-&gt;source[0] = form-&gt;source[1] = 0.0f;</a>
<a name="ln639">      }</a>
<a name="ln640">    }</a>
<a name="ln641">    else</a>
<a name="ln642">    {</a>
<a name="ln643">      const float a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln644">      const float b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln645">      const float ellipse_border = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/border&quot;);</a>
<a name="ln646">      const float rotation = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;);</a>
<a name="ln647">      const int flags = dt_conf_get_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;);</a>
<a name="ln648">      ellipse-&gt;radius[0] = MAX(0.001f, MIN(0.5f, a));</a>
<a name="ln649">      ellipse-&gt;radius[1] = MAX(0.001f, MIN(0.5f, b));</a>
<a name="ln650">      ellipse-&gt;flags = flags;</a>
<a name="ln651">      ellipse-&gt;rotation = rotation;</a>
<a name="ln652">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln653">      const float reference = (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? 1.0f/min_radius : 1.0f);</a>
<a name="ln654">      ellipse-&gt;border = MAX(0.005f * reference, MIN(0.5f * reference, ellipse_border));</a>
<a name="ln655">      // not used for masks</a>
<a name="ln656">      form-&gt;source[0] = form-&gt;source[1] = 0.0f;</a>
<a name="ln657">    }</a>
<a name="ln658">    form-&gt;points = g_list_append(form-&gt;points, ellipse);</a>
<a name="ln659">    dt_masks_gui_form_save_creation(darktable.develop, crea_module, form, gui);</a>
<a name="ln660"> </a>
<a name="ln661">    if(crea_module)</a>
<a name="ln662">    {</a>
<a name="ln663">      // we save the move</a>
<a name="ln664">      dt_dev_add_history_item(darktable.develop, crea_module, TRUE);</a>
<a name="ln665">      // and we switch in edit mode to show all the forms</a>
<a name="ln666">      if(gui-&gt;creation_continuous)</a>
<a name="ln667">        dt_masks_set_edit_mode_single_form(crea_module, form-&gt;formid, DT_MASKS_EDIT_FULL);</a>
<a name="ln668">      else</a>
<a name="ln669">        dt_masks_set_edit_mode(crea_module, DT_MASKS_EDIT_FULL);</a>
<a name="ln670">      dt_masks_iop_update(crea_module);</a>
<a name="ln671">      gui-&gt;creation_module = NULL;</a>
<a name="ln672">    }</a>
<a name="ln673">    else</a>
<a name="ln674">    {</a>
<a name="ln675">      // we select the new form</a>
<a name="ln676">      dt_dev_masks_selection_change(darktable.develop, form-&gt;formid, TRUE);</a>
<a name="ln677">    }</a>
<a name="ln678"> </a>
<a name="ln679">    // if we draw a clone ellipse, we start now the source dragging</a>
<a name="ln680">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln681">    {</a>
<a name="ln682">      dt_masks_form_t *grp = darktable.develop-&gt;form_visible;</a>
<a name="ln683">      if(!grp || !(grp-&gt;type &amp; DT_MASKS_GROUP)) return 1;</a>
<a name="ln684">      int pos3 = 0, pos2 = -1;</a>
<a name="ln685">      GList *fs = g_list_first(grp-&gt;points);</a>
<a name="ln686">      while(fs)</a>
<a name="ln687">      {</a>
<a name="ln688">        dt_masks_point_group_t *pt = (dt_masks_point_group_t *)fs-&gt;data;</a>
<a name="ln689">        if(pt-&gt;formid == form-&gt;formid)</a>
<a name="ln690">        {</a>
<a name="ln691">          pos2 = pos3;</a>
<a name="ln692">          break;</a>
<a name="ln693">        }</a>
<a name="ln694">        pos3++;</a>
<a name="ln695">        fs = g_list_next(fs);</a>
<a name="ln696">      }</a>
<a name="ln697">      if(pos2 &lt; 0) return 1;</a>
<a name="ln698">      dt_masks_form_gui_t *gui2 = darktable.develop-&gt;form_gui;</a>
<a name="ln699">      if(!gui2) return 1;</a>
<a name="ln700">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln701">        gui2-&gt;source_dragging = TRUE;</a>
<a name="ln702">      else</a>
<a name="ln703">        gui2-&gt;form_dragging = TRUE;</a>
<a name="ln704">      gui2-&gt;group_edited = gui2-&gt;group_selected = pos2;</a>
<a name="ln705">      gui2-&gt;posx = pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln706">      gui2-&gt;posy = pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln707">      gui2-&gt;dx = 0.0;</a>
<a name="ln708">      gui2-&gt;dy = 0.0;</a>
<a name="ln709">      gui2-&gt;scrollx = pzx;</a>
<a name="ln710">      gui2-&gt;scrolly = pzy;</a>
<a name="ln711">      gui2-&gt;form_selected = TRUE; // we also want to be selected after button released</a>
<a name="ln712"> </a>
<a name="ln713">      dt_masks_select_form(module, dt_masks_get_from_id(darktable.develop, form-&gt;formid));</a>
<a name="ln714">    }</a>
<a name="ln715">    return 1;</a>
<a name="ln716">  }</a>
<a name="ln717">  return 0;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">static int dt_ellipse_events_button_released(struct dt_iop_module_t *module, float pzx, float pzy, int which,</a>
<a name="ln721">                                             uint32_t state, dt_masks_form_t *form, int parentid,</a>
<a name="ln722">                                             dt_masks_form_gui_t *gui, int index)</a>
<a name="ln723">{</a>
<a name="ln724">  if(which == 3 &amp;&amp; parentid &gt; 0 &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln725">  {</a>
<a name="ln726">    // we hide the form</a>
<a name="ln727">    if(!(darktable.develop-&gt;form_visible-&gt;type &amp; DT_MASKS_GROUP))</a>
<a name="ln728">      dt_masks_change_form_gui(NULL);</a>
<a name="ln729">    else if(g_list_length(darktable.develop-&gt;form_visible-&gt;points) &lt; 2)</a>
<a name="ln730">      dt_masks_change_form_gui(NULL);</a>
<a name="ln731">    else</a>
<a name="ln732">    {</a>
<a name="ln733">      dt_masks_clear_form_gui(darktable.develop);</a>
<a name="ln734">      GList *forms = g_list_first(darktable.develop-&gt;form_visible-&gt;points);</a>
<a name="ln735">      while(forms)</a>
<a name="ln736">      {</a>
<a name="ln737">        dt_masks_point_group_t *gpt = (dt_masks_point_group_t *)forms-&gt;data;</a>
<a name="ln738">        if(gpt-&gt;formid == form-&gt;formid)</a>
<a name="ln739">        {</a>
<a name="ln740">          darktable.develop-&gt;form_visible-&gt;points</a>
<a name="ln741">              = g_list_remove(darktable.develop-&gt;form_visible-&gt;points, gpt);</a>
<a name="ln742">          free(gpt);</a>
<a name="ln743">          break;</a>
<a name="ln744">        }</a>
<a name="ln745">        forms = g_list_next(forms);</a>
<a name="ln746">      }</a>
<a name="ln747">      gui-&gt;edit_mode = DT_MASKS_EDIT_FULL;</a>
<a name="ln748">    }</a>
<a name="ln749"> </a>
<a name="ln750">    // we remove the shape</a>
<a name="ln751">    dt_masks_form_remove(module, dt_masks_get_from_id(darktable.develop, parentid), form);</a>
<a name="ln752">    return 1;</a>
<a name="ln753">  }</a>
<a name="ln754">  if(gui-&gt;form_dragging)</a>
<a name="ln755">  {</a>
<a name="ln756">    // we get the ellipse</a>
<a name="ln757">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln758"> </a>
<a name="ln759">    // we end the form dragging</a>
<a name="ln760">    gui-&gt;form_dragging = FALSE;</a>
<a name="ln761"> </a>
<a name="ln762">    // we change the center value</a>
<a name="ln763">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln764">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln765">    float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln766">    dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln767">    ellipse-&gt;center[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln768">    ellipse-&gt;center[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln769">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln770"> </a>
<a name="ln771">    // we recreate the form points</a>
<a name="ln772">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln773">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln774"> </a>
<a name="ln775">    // we save the move</a>
<a name="ln776">    dt_masks_update_image(darktable.develop);</a>
<a name="ln777"> </a>
<a name="ln778">    if(gui-&gt;creation_continuous)</a>
<a name="ln779">    {</a>
<a name="ln780">      dt_masks_form_t *form_new = dt_masks_create(form-&gt;type);</a>
<a name="ln781">      dt_masks_change_form_gui(form_new);</a>
<a name="ln782"> </a>
<a name="ln783">      darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln784">      darktable.develop-&gt;form_gui-&gt;creation_module = gui-&gt;creation_continuous_module;</a>
<a name="ln785">    }</a>
<a name="ln786">    return 1;</a>
<a name="ln787">  }</a>
<a name="ln788">  else if(gui-&gt;border_toggling)</a>
<a name="ln789">  {</a>
<a name="ln790">    // we get the ellipse</a>
<a name="ln791">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln792"> </a>
<a name="ln793">    // we end the border toggling</a>
<a name="ln794">    gui-&gt;border_toggling = FALSE;</a>
<a name="ln795"> </a>
<a name="ln796">    // toggle feathering type of border and adjust border radius accordingly</a>
<a name="ln797">    if(ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL)</a>
<a name="ln798">    {</a>
<a name="ln799">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln800">      ellipse-&gt;border = ellipse-&gt;border * min_radius;</a>
<a name="ln801">      ellipse-&gt;border = CLAMP(ellipse-&gt;border, 0.001f, 1.0f);</a>
<a name="ln802"> </a>
<a name="ln803">      ellipse-&gt;flags &amp;= ~DT_MASKS_ELLIPSE_PROPORTIONAL;</a>
<a name="ln804">    }</a>
<a name="ln805">    else</a>
<a name="ln806">    {</a>
<a name="ln807">      const float min_radius = fmin(ellipse-&gt;radius[0], ellipse-&gt;radius[1]);</a>
<a name="ln808">      ellipse-&gt;border = ellipse-&gt;border/min_radius;</a>
<a name="ln809">      ellipse-&gt;border = CLAMP(ellipse-&gt;border, 0.001f/min_radius, 1.0f/min_radius);</a>
<a name="ln810"> </a>
<a name="ln811">      ellipse-&gt;flags |= DT_MASKS_ELLIPSE_PROPORTIONAL;</a>
<a name="ln812">    }</a>
<a name="ln813"> </a>
<a name="ln814">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln815">    {</a>
<a name="ln816">      dt_conf_set_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;, ellipse-&gt;flags);</a>
<a name="ln817">      dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_border&quot;, ellipse-&gt;border);</a>
<a name="ln818">    }</a>
<a name="ln819">    else</a>
<a name="ln820">    {</a>
<a name="ln821">      dt_conf_set_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;, ellipse-&gt;flags);</a>
<a name="ln822">      dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/border&quot;, ellipse-&gt;border);</a>
<a name="ln823">    }</a>
<a name="ln824"> </a>
<a name="ln825">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln826"> </a>
<a name="ln827">    // we recreate the form points</a>
<a name="ln828">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln829">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln830"> </a>
<a name="ln831">    // we save the new parameters</a>
<a name="ln832">    dt_masks_update_image(darktable.develop);</a>
<a name="ln833"> </a>
<a name="ln834">    return 1;</a>
<a name="ln835">  }</a>
<a name="ln836">  else if(gui-&gt;form_rotating &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln837">  {</a>
<a name="ln838">    // we get the ellipse</a>
<a name="ln839">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln840"> </a>
<a name="ln841">    // we end the form rotating</a>
<a name="ln842">    gui-&gt;form_rotating = FALSE;</a>
<a name="ln843"> </a>
<a name="ln844">    float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln845">    float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln846">    float x = pzx * wd;</a>
<a name="ln847">    float y = pzy * ht;</a>
<a name="ln848"> </a>
<a name="ln849">    // we need the reference point</a>
<a name="ln850">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln851">    if(!gpt) return 0;</a>
<a name="ln852">    float xref = gpt-&gt;points[0];</a>
<a name="ln853">    float yref = gpt-&gt;points[1];</a>
<a name="ln854"> </a>
<a name="ln855">    float dv = atan2(y - yref, x - xref) - atan2(-gui-&gt;dy, -gui-&gt;dx);</a>
<a name="ln856"> </a>
<a name="ln857">    ellipse-&gt;rotation += dv / M_PI * 180.0f;</a>
<a name="ln858">    ellipse-&gt;rotation = fmodf(ellipse-&gt;rotation, 360.0f);</a>
<a name="ln859"> </a>
<a name="ln860">    if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln861">      dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln862">    else</a>
<a name="ln863">      dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;, ellipse-&gt;rotation);</a>
<a name="ln864"> </a>
<a name="ln865">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln866"> </a>
<a name="ln867">    // we recreate the form points</a>
<a name="ln868">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln869">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln870"> </a>
<a name="ln871">    // we save the rotation</a>
<a name="ln872">    dt_masks_update_image(darktable.develop);</a>
<a name="ln873"> </a>
<a name="ln874">    return 1;</a>
<a name="ln875">  }</a>
<a name="ln876">  else if(gui-&gt;point_dragging &gt;= 1 &amp;&amp; gui-&gt;edit_mode == DT_MASKS_EDIT_FULL)</a>
<a name="ln877">  {</a>
<a name="ln878">    // we get the ellipse</a>
<a name="ln879">    dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln880"> </a>
<a name="ln881">    const int k = gui-&gt;point_dragging;</a>
<a name="ln882"> </a>
<a name="ln883">    // we end the point dragging</a>
<a name="ln884">    gui-&gt;point_dragging = -1;</a>
<a name="ln885"> </a>
<a name="ln886">    // we need the reference points</a>
<a name="ln887">    dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln888">    if(!gpt) return 0;</a>
<a name="ln889"> </a>
<a name="ln890">    const float xref = gpt-&gt;points[0];</a>
<a name="ln891">    const float yref = gpt-&gt;points[1];</a>
<a name="ln892">    const float rx = gpt-&gt;points[k * 2] - xref;</a>
<a name="ln893">    const float ry = gpt-&gt;points[k * 2 + 1] - yref;</a>
<a name="ln894">    const float deltax = gui-&gt;posx + gui-&gt;dx - xref;</a>
<a name="ln895">    const float deltay = gui-&gt;posy + gui-&gt;dy - yref;</a>
<a name="ln896"> </a>
<a name="ln897">    const float r = sqrtf(rx * rx + ry * ry);</a>
<a name="ln898">    const float d = (rx * deltax + ry * deltay) / r;</a>
<a name="ln899">    const float s = fmaxf(r &gt; 0.0f ? (r + d) / r : 0.0f, 0.0f);</a>
<a name="ln900"> </a>
<a name="ln901">    // make sure we adjust the right radius: anchor points and 1 and 2 correspond to the ellipse's longer axis</a>
<a name="ln902">    if(((k == 1 || k == 2) &amp;&amp; ellipse-&gt;radius[0] &gt; ellipse-&gt;radius[1])</a>
<a name="ln903">       || ((k == 3 || k == 4) &amp;&amp; ellipse-&gt;radius[0] &lt;= ellipse-&gt;radius[1]))</a>
<a name="ln904">    {</a>
<a name="ln905">      ellipse-&gt;radius[0] = MAX(0.002f, ellipse-&gt;radius[0] * s);</a>
<a name="ln906">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln907">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln908">      else</a>
<a name="ln909">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;, ellipse-&gt;radius[0]);</a>
<a name="ln910">    }</a>
<a name="ln911">    else</a>
<a name="ln912">    {</a>
<a name="ln913">      ellipse-&gt;radius[1] = MAX(0.002f, ellipse-&gt;radius[1] * s);</a>
<a name="ln914">      if(form-&gt;type &amp; (DT_MASKS_CLONE|DT_MASKS_NON_CLONE))</a>
<a name="ln915">        dt_conf_set_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln916">      else</a>
<a name="ln917">        dt_conf_set_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;, ellipse-&gt;radius[1]);</a>
<a name="ln918">    }</a>
<a name="ln919"> </a>
<a name="ln920">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln921">    // we recreate the form points</a>
<a name="ln922">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln923">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln924"> </a>
<a name="ln925">    // we save the rotation</a>
<a name="ln926">    dt_masks_update_image(darktable.develop);</a>
<a name="ln927"> </a>
<a name="ln928">    return 1;</a>
<a name="ln929">  }</a>
<a name="ln930">  else if(gui-&gt;source_dragging)</a>
<a name="ln931">  {</a>
<a name="ln932">    // we end the form dragging</a>
<a name="ln933">    gui-&gt;source_dragging = FALSE;</a>
<a name="ln934">    if(gui-&gt;scrollx != 0.0 || gui-&gt;scrolly != 0.0)</a>
<a name="ln935">    {</a>
<a name="ln936">      // if there's no dragging the source is calculated in dt_ellipse_events_button_pressed()</a>
<a name="ln937">    }</a>
<a name="ln938">    else</a>
<a name="ln939">    {</a>
<a name="ln940">      // we change the center value</a>
<a name="ln941">      float wd = darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln942">      float ht = darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln943">      float pts[2] = { pzx * wd + gui-&gt;dx, pzy * ht + gui-&gt;dy };</a>
<a name="ln944"> </a>
<a name="ln945">      dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln946"> </a>
<a name="ln947">      form-&gt;source[0] = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln948">      form-&gt;source[1] = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln949">    }</a>
<a name="ln950">    dt_dev_add_masks_history_item(darktable.develop, module, TRUE);</a>
<a name="ln951"> </a>
<a name="ln952">    // we recreate the form points</a>
<a name="ln953">    dt_masks_gui_form_remove(form, gui, index);</a>
<a name="ln954">    dt_masks_gui_form_create(form, gui, index);</a>
<a name="ln955"> </a>
<a name="ln956">    // we save the move</a>
<a name="ln957">    dt_masks_update_image(darktable.develop);</a>
<a name="ln958"> </a>
<a name="ln959">    if(gui-&gt;creation_continuous)</a>
<a name="ln960">    {</a>
<a name="ln961">      dt_masks_form_t *form_new = dt_masks_create(form-&gt;type);</a>
<a name="ln962">      dt_masks_change_form_gui(form_new);</a>
<a name="ln963"> </a>
<a name="ln964">      darktable.develop-&gt;form_gui-&gt;creation = TRUE;</a>
<a name="ln965">      darktable.develop-&gt;form_gui-&gt;creation_module = gui-&gt;creation_continuous_module;</a>
<a name="ln966">    }</a>
<a name="ln967">    return 1;</a>
<a name="ln968">  }</a>
<a name="ln969">  return 0;</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972">static int dt_ellipse_events_mouse_moved(struct dt_iop_module_t *module, float pzx, float pzy,</a>
<a name="ln973">                                         double pressure, int which, dt_masks_form_t *form, int parentid,</a>
<a name="ln974">                                         dt_masks_form_gui_t *gui, int index)</a>
<a name="ln975">{</a>
<a name="ln976">  if(gui-&gt;form_dragging || gui-&gt;form_rotating || gui-&gt;source_dragging || gui-&gt;point_dragging &gt;= 1)</a>
<a name="ln977">  {</a>
<a name="ln978">    dt_control_queue_redraw_center();</a>
<a name="ln979">    return 1;</a>
<a name="ln980">  }</a>
<a name="ln981">  else if(!gui-&gt;creation)</a>
<a name="ln982">  {</a>
<a name="ln983">    dt_dev_zoom_t zoom = dt_control_get_dev_zoom();</a>
<a name="ln984">    int closeup = dt_control_get_dev_closeup();</a>
<a name="ln985">    float zoom_scale = dt_dev_get_zoom_scale(darktable.develop, zoom, 1&lt;&lt;closeup, 1);</a>
<a name="ln986">    float as = 0.005f / zoom_scale * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln987">    float x = pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln988">    float y = pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln989">    int in = 0, inb = 0, near = 0, ins = 0; // FIXME gcc7 false-positive</a>
<a name="ln990">    dt_ellipse_get_distance(pzx * darktable.develop-&gt;preview_pipe-&gt;backbuf_width,</a>
<a name="ln991">                            pzy * darktable.develop-&gt;preview_pipe-&gt;backbuf_height, as, gui, index, &amp;in, &amp;inb,</a>
<a name="ln992">                            &amp;near, &amp;ins);</a>
<a name="ln993">    if(ins)</a>
<a name="ln994">    {</a>
<a name="ln995">      gui-&gt;form_selected = TRUE;</a>
<a name="ln996">      gui-&gt;source_selected = TRUE;</a>
<a name="ln997">      gui-&gt;border_selected = FALSE;</a>
<a name="ln998">    }</a>
<a name="ln999">    else if(inb)</a>
<a name="ln1000">    {</a>
<a name="ln1001">      gui-&gt;form_selected = TRUE;</a>
<a name="ln1002">      gui-&gt;border_selected = TRUE;</a>
<a name="ln1003">      gui-&gt;source_selected = FALSE;</a>
<a name="ln1004">    }</a>
<a name="ln1005">    else if(in)</a>
<a name="ln1006">    {</a>
<a name="ln1007">      gui-&gt;form_selected = TRUE;</a>
<a name="ln1008">      gui-&gt;border_selected = FALSE;</a>
<a name="ln1009">      gui-&gt;source_selected = FALSE;</a>
<a name="ln1010">    }</a>
<a name="ln1011">    else</a>
<a name="ln1012">    {</a>
<a name="ln1013">      gui-&gt;form_selected = FALSE;</a>
<a name="ln1014">      gui-&gt;border_selected = FALSE;</a>
<a name="ln1015">      gui-&gt;source_selected = FALSE;</a>
<a name="ln1016">    }</a>
<a name="ln1017"> </a>
<a name="ln1018">    // see if we are close to one of the anchor points</a>
<a name="ln1019">    gui-&gt;point_selected = -1;</a>
<a name="ln1020">    if(gui-&gt;form_selected)</a>
<a name="ln1021">    {</a>
<a name="ln1022">      dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1023">      for(int i = 1; i &lt; 5; i++)</a>
<a name="ln1024">      {</a>
<a name="ln1025">        if(x - gpt-&gt;points[i * 2] &gt; -as &amp;&amp; x - gpt-&gt;points[i * 2] &lt; as &amp;&amp; y - gpt-&gt;points[i * 2 + 1] &gt; -as</a>
<a name="ln1026">           &amp;&amp; y - gpt-&gt;points[i * 2 + 1] &lt; as)</a>
<a name="ln1027">        {</a>
<a name="ln1028">          gui-&gt;point_selected = i;</a>
<a name="ln1029">          break;</a>
<a name="ln1030">        }</a>
<a name="ln1031">      }</a>
<a name="ln1032">    }</a>
<a name="ln1033"> </a>
<a name="ln1034">    dt_control_queue_redraw_center();</a>
<a name="ln1035">    if(!gui-&gt;form_selected &amp;&amp; !gui-&gt;border_selected) return 0;</a>
<a name="ln1036">    if(gui-&gt;edit_mode != DT_MASKS_EDIT_FULL) return 0;</a>
<a name="ln1037">    return 1;</a>
<a name="ln1038">  }</a>
<a name="ln1039">  // add a preview when creating an ellipse</a>
<a name="ln1040">  else if(gui-&gt;creation)</a>
<a name="ln1041">  {</a>
<a name="ln1042">    dt_control_queue_redraw_center();</a>
<a name="ln1043">    return 1;</a>
<a name="ln1044">  }</a>
<a name="ln1045"> </a>
<a name="ln1046">  return 0;</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">static void dt_ellipse_events_post_expose(cairo_t *cr, float zoom_scale, dt_masks_form_gui_t *gui, int index)</a>
<a name="ln1050">{</a>
<a name="ln1051">  double dashed[] = { 4.0, 4.0 };</a>
<a name="ln1052">  dashed[0] /= zoom_scale;</a>
<a name="ln1053">  dashed[1] /= zoom_scale;</a>
<a name="ln1054">  int len = sizeof(dashed) / sizeof(dashed[0]);</a>
<a name="ln1055">  dt_masks_form_gui_points_t *gpt = (dt_masks_form_gui_points_t *)g_list_nth_data(gui-&gt;points, index);</a>
<a name="ln1056"> </a>
<a name="ln1057">  float dx = 0.0f, dy = 0.0f, xref = 0.0f, yref = 0.0f;</a>
<a name="ln1058">  float dxs = 0.0f, dys = 0.0f, xrefs = 0.0f, yrefs = 0.0f;</a>
<a name="ln1059">  float sinv = 0.0f, cosv = 1.0f;</a>
<a name="ln1060">  float scalea = 1.0f, scaleb = 1.0f, scaleab = 1.0f, scalebb = 1.0f;</a>
<a name="ln1061"> </a>
<a name="ln1062">  // add a preview when creating an ellipse</a>
<a name="ln1063">  // in creation mode</a>
<a name="ln1064">  if(gui-&gt;creation)</a>
<a name="ln1065">  {</a>
<a name="ln1066">    if(gui-&gt;guipoints_count == 0)</a>
<a name="ln1067">    {</a>
<a name="ln1068">      dt_masks_form_t *form = darktable.develop-&gt;form_visible;</a>
<a name="ln1069">      if(!form) return;</a>
<a name="ln1070"> </a>
<a name="ln1071">      float x, y;</a>
<a name="ln1072">      float masks_border;</a>
<a name="ln1073">      int flags;</a>
<a name="ln1074">      float radius_a;</a>
<a name="ln1075">      float radius_b;</a>
<a name="ln1076">      float rotation;</a>
<a name="ln1077"> </a>
<a name="ln1078">      if(form-&gt;type &amp; (DT_MASKS_CLONE | DT_MASKS_NON_CLONE))</a>
<a name="ln1079">      {</a>
<a name="ln1080">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_border&quot;);</a>
<a name="ln1081">        flags = dt_conf_get_int(&quot;plugins/darkroom/spots/ellipse_flags&quot;);</a>
<a name="ln1082">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_a&quot;);</a>
<a name="ln1083">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_radius_b&quot;);</a>
<a name="ln1084">        rotation = dt_conf_get_float(&quot;plugins/darkroom/spots/ellipse_rotation&quot;);</a>
<a name="ln1085">      }</a>
<a name="ln1086">      else</a>
<a name="ln1087">      {</a>
<a name="ln1088">        masks_border = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/border&quot;);</a>
<a name="ln1089">        flags = dt_conf_get_int(&quot;plugins/darkroom/masks/ellipse/flags&quot;);</a>
<a name="ln1090">        radius_a = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_a&quot;);</a>
<a name="ln1091">        radius_b = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/radius_b&quot;);</a>
<a name="ln1092">        rotation = dt_conf_get_float(&quot;plugins/darkroom/masks/ellipse/rotation&quot;);</a>
<a name="ln1093">      }</a>
<a name="ln1094"> </a>
<a name="ln1095">      float pzx = gui-&gt;posx;</a>
<a name="ln1096">      float pzy = gui-&gt;posy;</a>
<a name="ln1097"> </a>
<a name="ln1098">      if((pzx == -1.f &amp;&amp; pzy == -1.f) || gui-&gt;mouse_leaved_center)</a>
<a name="ln1099">      {</a>
<a name="ln1100">        const float zoom_x = dt_control_get_dev_zoom_x();</a>
<a name="ln1101">        const float zoom_y = dt_control_get_dev_zoom_y();</a>
<a name="ln1102">        pzx = (.5f + zoom_x) * darktable.develop-&gt;preview_pipe-&gt;backbuf_width;</a>
<a name="ln1103">        pzy = (.5f + zoom_y) * darktable.develop-&gt;preview_pipe-&gt;backbuf_height;</a>
<a name="ln1104">      }</a>
<a name="ln1105"> </a>
<a name="ln1106">      float pts[2] = { pzx, pzy };</a>
<a name="ln1107">      dt_dev_distort_backtransform(darktable.develop, pts, 1);</a>
<a name="ln1108">      x = pts[0] / darktable.develop-&gt;preview_pipe-&gt;iwidth;</a>
<a name="ln1109">      y = pts[1] / darktable.develop-&gt;preview_pipe-&gt;iheight;</a>
<a name="ln1110"> </a>
<a name="ln1111">      float *points = NULL;</a>
<a name="ln1112">      int points_count = 0;</a>
<a name="ln1113">      float *border = NULL;</a>
<a name="ln1114">      int border_count = 0;</a>
<a name="ln1115"> </a>
<a name="ln1116">      int draw = 0;</a>
<a name="ln1117"> </a>
<a name="ln1118">      draw = dt_ellipse_get_points(darktable.develop, x, y, radius_a, radius_b, rotation, &amp;points, &amp;points_count);</a>
<a name="ln1119">      if(draw &amp;&amp; masks_border &gt; 0.f)</a>
<a name="ln1120">      {</a>
<a name="ln1121">        draw = dt_ellipse_get_points(</a>
<a name="ln1122">            darktable.develop, x, y,</a>
<a name="ln1123">            (flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? radius_a * (1.0f + masks_border) : radius_a + masks_border),</a>
<a name="ln1124">            (flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? radius_b * (1.0f + masks_border) : radius_b + masks_border),</a>
<a name="ln1125">            rotation, &amp;border, &amp;border_count);</a>
<a name="ln1126">      }</a>
<a name="ln1127"> </a>
<a name="ln1128">      if(draw &amp;&amp; points_count &gt;= 2)</a>
<a name="ln1129">      {</a>
<a name="ln1130">        xref = points[0];</a>
<a name="ln1131">        yref = points[1];</a>
<a name="ln1132"> </a>
<a name="ln1133">        dt_ellipse_draw_shape(cr, dashed, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scalea, scaleb, points,</a>
<a name="ln1134">                              points_count);</a>
<a name="ln1135">      }</a>
<a name="ln1136">      if(draw &amp;&amp; border_count &gt;= 2)</a>
<a name="ln1137">      {</a>
<a name="ln1138">        xref = border[0];</a>
<a name="ln1139">        yref = border[1];</a>
<a name="ln1140"> </a>
<a name="ln1141">        dt_ellipse_draw_border(cr, dashed, len, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scaleab, scalebb,</a>
<a name="ln1142">                               border, border_count);</a>
<a name="ln1143">      }</a>
<a name="ln1144"> </a>
<a name="ln1145">      // draw a cross where the source will be created</a>
<a name="ln1146">      if(form-&gt;type &amp; DT_MASKS_CLONE)</a>
<a name="ln1147">      {</a>
<a name="ln1148">        float x = 0.f, y = 0.f;</a>
<a name="ln1149">        dt_masks_calculate_source_pos_value(gui, DT_MASKS_ELLIPSE, pzx, pzy, pzx, pzy, &amp;x, &amp;y, FALSE);</a>
<a name="ln1150">        dt_masks_draw_clone_source_pos(cr, zoom_scale, x, y);</a>
<a name="ln1151">      }</a>
<a name="ln1152"> </a>
<a name="ln1153">      if(points) free(points);</a>
<a name="ln1154">      if(border) free(border);</a>
<a name="ln1155">    }</a>
<a name="ln1156">    return;</a>
<a name="ln1157">  }</a>
<a name="ln1158"> </a>
<a name="ln1159">  if(!gpt) return;</a>
<a name="ln1160"> </a>
<a name="ln1161">  const float r = atan2(gpt-&gt;points[3] - gpt-&gt;points[1], gpt-&gt;points[2] - gpt-&gt;points[0]);</a>
<a name="ln1162">  const float sinr = sin(r);</a>
<a name="ln1163">  const float cosr = cos(r);</a>
<a name="ln1164"> </a>
<a name="ln1165">  xref = gpt-&gt;points[0];</a>
<a name="ln1166">  yref = gpt-&gt;points[1];</a>
<a name="ln1167"> </a>
<a name="ln1168">  if(gpt-&gt;source_count &gt; 10)</a>
<a name="ln1169">  {</a>
<a name="ln1170">    xrefs = gpt-&gt;source[0];</a>
<a name="ln1171">    yrefs = gpt-&gt;source[1];</a>
<a name="ln1172">  }</a>
<a name="ln1173">  if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;form_dragging)</a>
<a name="ln1174">  {</a>
<a name="ln1175">    dx = gui-&gt;posx + gui-&gt;dx - xref;</a>
<a name="ln1176">    dy = gui-&gt;posy + gui-&gt;dy - yref;</a>
<a name="ln1177">  }</a>
<a name="ln1178">  else if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;source_dragging)</a>
<a name="ln1179">  {</a>
<a name="ln1180">    xrefs = gpt-&gt;source[0], yrefs = gpt-&gt;source[1];</a>
<a name="ln1181">    dxs = gui-&gt;posx + gui-&gt;dx - xrefs;</a>
<a name="ln1182">    dys = gui-&gt;posy + gui-&gt;dy - yrefs;</a>
<a name="ln1183">  }</a>
<a name="ln1184">  else if((gui-&gt;group_selected == index) &amp;&amp; gui-&gt;form_rotating)</a>
<a name="ln1185">  {</a>
<a name="ln1186">    const float v = atan2(gui-&gt;posy - yref, gui-&gt;posx - xref) - atan2(-gui-&gt;dy, -gui-&gt;dx);</a>
<a name="ln1187">    sinv = sin(v);</a>
<a name="ln1188">    cosv = cos(v);</a>
<a name="ln1189">  }</a>
<a name="ln1190">  else if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;point_dragging &gt;= 1))</a>
<a name="ln1191">  {</a>
<a name="ln1192">    const int k = gui-&gt;point_dragging;</a>
<a name="ln1193">    const float rx = gpt-&gt;points[k * 2] - xref;</a>
<a name="ln1194">    const float ry = gpt-&gt;points[k * 2 + 1] - yref;</a>
<a name="ln1195">    const float bx = gpt-&gt;border[k * 2] - xref;</a>
<a name="ln1196">    const float by = gpt-&gt;border[k * 2 + 1] - yref;</a>
<a name="ln1197">    const float deltax = gui-&gt;posx + gui-&gt;dx - xref;</a>
<a name="ln1198">    const float deltay = gui-&gt;posy + gui-&gt;dy - yref;</a>
<a name="ln1199"> </a>
<a name="ln1200">    const float r = sqrtf(rx * rx + ry * ry);</a>
<a name="ln1201">    const float b = sqrtf(bx * bx + by * by);</a>
<a name="ln1202">    float d = (rx * deltax + ry * deltay) / r;</a>
<a name="ln1203">    if(r + d &lt; 0) d = -r;</a>
<a name="ln1204"> </a>
<a name="ln1205">    if(k == 1 || k == 2)</a>
<a name="ln1206">    {</a>
<a name="ln1207">      scalea = r &gt; 0 ? (r + d) / r : 0;</a>
<a name="ln1208">      scaleab = b &gt; 0 ? (b + d) / b : 0;</a>
<a name="ln1209">    }</a>
<a name="ln1210">    else</a>
<a name="ln1211">    {</a>
<a name="ln1212">      scaleb = r &gt; 0 ? (r + d) / r : 0;</a>
<a name="ln1213">      scalebb = b &gt; 0 ? (b + d) / b : 0;</a>
<a name="ln1214">    }</a>
<a name="ln1215">  }</a>
<a name="ln1216"> </a>
<a name="ln1217">  float x, y;</a>
<a name="ln1218"> </a>
<a name="ln1219">  // draw shape</a>
<a name="ln1220">  dt_ellipse_draw_shape(cr, dashed, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scalea, scaleb, gpt-&gt;points,</a>
<a name="ln1221">                        gpt-&gt;points_count);</a>
<a name="ln1222"> </a>
<a name="ln1223">  // draw anchor points</a>
<a name="ln1224">  if(TRUE)</a>
<a name="ln1225">  {</a>
<a name="ln1226">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln1227">    float anchor_size; // = (gui-&gt;form_dragging || gui-&gt;form_selected) ? 7.0f / zoom_scale : 5.0f /</a>
<a name="ln1228">                       // zoom_scale;</a>
<a name="ln1229"> </a>
<a name="ln1230">    for(int i = 1; i &lt; 5; i++)</a>
<a name="ln1231">    {</a>
<a name="ln1232">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln1233"> </a>
<a name="ln1234">      if(i == gui-&gt;point_dragging || i == gui-&gt;point_selected)</a>
<a name="ln1235">        anchor_size = 7.0f / zoom_scale;</a>
<a name="ln1236">      else</a>
<a name="ln1237">        anchor_size = 5.0f / zoom_scale;</a>
<a name="ln1238"> </a>
<a name="ln1239">      _ellipse_point_transform(xref, yref, gpt-&gt;points[i * 2] + dx, gpt-&gt;points[i * 2 + 1] + dy, sinr, cosr,</a>
<a name="ln1240">                               scalea, scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1241">      cairo_rectangle(cr, x - (anchor_size * 0.5), y - (anchor_size * 0.5), anchor_size, anchor_size);</a>
<a name="ln1242">      cairo_fill_preserve(cr);</a>
<a name="ln1243">      if((gui-&gt;group_selected == index) &amp;&amp; (i == gui-&gt;point_dragging || i == gui-&gt;point_selected))</a>
<a name="ln1244">        cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln1245">      if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_dragging || gui-&gt;form_selected))</a>
<a name="ln1246">        cairo_set_line_width(cr, 2.0 / zoom_scale);</a>
<a name="ln1247">      else</a>
<a name="ln1248">        cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln1249">      cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln1250">      cairo_stroke(cr);</a>
<a name="ln1251">    }</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  // draw border</a>
<a name="ln1255">  if(gui-&gt;group_selected == index)</a>
<a name="ln1256">  {</a>
<a name="ln1257">    dt_ellipse_draw_border(cr, dashed, len, 0, zoom_scale, dx, dy, xref, yref, sinv, cosv, scaleab, scalebb,</a>
<a name="ln1258">                           gpt-&gt;border, gpt-&gt;border_count);</a>
<a name="ln1259">  }</a>
<a name="ln1260"> </a>
<a name="ln1261">  // draw the source if any</a>
<a name="ln1262">  if(gpt-&gt;source_count &gt; 10)</a>
<a name="ln1263">  {</a>
<a name="ln1264">    // compute the dest inner ellipse intersection with the line from source center to dest center.</a>
<a name="ln1265">    float cdx = gpt-&gt;source[0] + dxs - gpt-&gt;points[0] - dx;</a>
<a name="ln1266">    float cdy = gpt-&gt;source[1] + dys - gpt-&gt;points[1] - dy;</a>
<a name="ln1267"> </a>
<a name="ln1268">    // we don't draw the line if source==point</a>
<a name="ln1269">    if(cdx != 0.0 &amp;&amp; cdy != 0.0)</a>
<a name="ln1270">    {</a>
<a name="ln1271">      cairo_set_line_cap(cr, CAIRO_LINE_CAP_ROUND);</a>
<a name="ln1272">      float cangle = atan(cdx / cdy);</a>
<a name="ln1273"> </a>
<a name="ln1274">      if(cdy &gt; 0)</a>
<a name="ln1275">        cangle = (M_PI / 2) - cangle;</a>
<a name="ln1276">      else</a>
<a name="ln1277">        cangle = -(M_PI / 2) - cangle;</a>
<a name="ln1278"> </a>
<a name="ln1279">      float arrowx = gpt-&gt;points[0] + dx;</a>
<a name="ln1280">      float arrowy = gpt-&gt;points[1] + dy;</a>
<a name="ln1281"> </a>
<a name="ln1282">      cairo_move_to(cr, gpt-&gt;source[0] + dxs, gpt-&gt;source[1] + dys); // source center</a>
<a name="ln1283">      cairo_line_to(cr, arrowx, arrowy);                             // dest border</a>
<a name="ln1284">      // then draw to line for the arrow itself</a>
<a name="ln1285">      const float arrow_scale = 8.0;</a>
<a name="ln1286">      cairo_move_to(cr, arrowx + arrow_scale * cos(cangle + (0.4)),</a>
<a name="ln1287">                    arrowy + arrow_scale * sin(cangle + (0.4)));</a>
<a name="ln1288">      cairo_line_to(cr, arrowx, arrowy);</a>
<a name="ln1289">      cairo_line_to(cr, arrowx + arrow_scale * cos(cangle - (0.4)),</a>
<a name="ln1290">                    arrowy + arrow_scale * sin(cangle - (0.4)));</a>
<a name="ln1291"> </a>
<a name="ln1292">      cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln1293">      if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1294">        cairo_set_line_width(cr, 2.5 / zoom_scale);</a>
<a name="ln1295">      else</a>
<a name="ln1296">        cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln1297">      cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln1298">      cairo_stroke_preserve(cr);</a>
<a name="ln1299">      if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1300">        cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln1301">      else</a>
<a name="ln1302">        cairo_set_line_width(cr, 0.5 / zoom_scale);</a>
<a name="ln1303">      cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln1304">      cairo_stroke(cr);</a>
<a name="ln1305">    }</a>
<a name="ln1306"> </a>
<a name="ln1307">    // we draw the source</a>
<a name="ln1308">    cairo_set_dash(cr, dashed, 0, 0);</a>
<a name="ln1309">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1310">      cairo_set_line_width(cr, 2.5 / zoom_scale);</a>
<a name="ln1311">    else</a>
<a name="ln1312">      cairo_set_line_width(cr, 1.5 / zoom_scale);</a>
<a name="ln1313">    cairo_set_source_rgba(cr, .3, .3, .3, .8);</a>
<a name="ln1314">    _ellipse_point_transform(xrefs, yrefs, gpt-&gt;source[10] + dxs, gpt-&gt;source[11] + dys, sinr, cosr, scalea,</a>
<a name="ln1315">                             scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1316">    cairo_move_to(cr, x, y);</a>
<a name="ln1317">    for(int i = 6; i &lt; gpt-&gt;source_count; i++)</a>
<a name="ln1318">    {</a>
<a name="ln1319">      _ellipse_point_transform(xrefs, yrefs, gpt-&gt;source[i * 2] + dxs, gpt-&gt;source[i * 2 + 1] + dys, sinr,</a>
<a name="ln1320">                               cosr, scalea, scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1321">      cairo_line_to(cr, x, y);</a>
<a name="ln1322">    }</a>
<a name="ln1323">    _ellipse_point_transform(xrefs, yrefs, gpt-&gt;source[10] + dxs, gpt-&gt;source[11] + dys, sinr, cosr, scalea,</a>
<a name="ln1324">                             scaleb, sinv, cosv, &amp;x, &amp;y);</a>
<a name="ln1325">    cairo_line_to(cr, x, y);</a>
<a name="ln1326">    cairo_stroke_preserve(cr);</a>
<a name="ln1327">    if((gui-&gt;group_selected == index) &amp;&amp; (gui-&gt;form_selected || gui-&gt;form_dragging))</a>
<a name="ln1328">      cairo_set_line_width(cr, 1.0 / zoom_scale);</a>
<a name="ln1329">    else</a>
<a name="ln1330">      cairo_set_line_width(cr, 0.5 / zoom_scale);</a>
<a name="ln1331">    cairo_set_source_rgba(cr, .8, .8, .8, .8);</a>
<a name="ln1332">    cairo_stroke(cr);</a>
<a name="ln1333">  }</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">static int dt_ellipse_get_source_area(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1337">                                      dt_masks_form_t *form, int *width, int *height, int *posx, int *posy)</a>
<a name="ln1338">{</a>
<a name="ln1339">  // we get the ellipse values</a>
<a name="ln1340">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1341">  const float wd = piece-&gt;pipe-&gt;iwidth, ht = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1342"> </a>
<a name="ln1343">  const float total[2] = { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wd, ht),</a>
<a name="ln1344">                           (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wd, ht) };</a>
<a name="ln1345">  const float v1 = ((ellipse-&gt;rotation) / 180.0f) * M_PI;</a>
<a name="ln1346">  const float v2 = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1347">  float a, b, v;</a>
<a name="ln1348"> </a>
<a name="ln1349">  if(total[0] &gt;= total[1])</a>
<a name="ln1350">  {</a>
<a name="ln1351">    a = total[0];</a>
<a name="ln1352">    b = total[1];</a>
<a name="ln1353">    v = v1;</a>
<a name="ln1354">  }</a>
<a name="ln1355">  else</a>
<a name="ln1356">  {</a>
<a name="ln1357">    a = total[1];</a>
<a name="ln1358">    b = total[0];</a>
<a name="ln1359">    v = v2;</a>
<a name="ln1360">  }</a>
<a name="ln1361"> </a>
<a name="ln1362">  const float sinv = sinf(v);</a>
<a name="ln1363">  const float cosv = cosf(v);</a>
<a name="ln1364"> </a>
<a name="ln1365">  // how many points do we need ?</a>
<a name="ln1366">  const float lambda = (a - b) / (a + b);</a>
<a name="ln1367">  const int l = (int)(M_PI * (a + b)</a>
<a name="ln1368">                      * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda))));</a>
<a name="ln1369"> </a>
<a name="ln1370">  // buffer allocations</a>
<a name="ln1371">  float *points = calloc(2 * (l + 5), sizeof(float));</a>
<a name="ln1372"> </a>
<a name="ln1373">  // now we set the points</a>
<a name="ln1374">  const float x = points[0] = ellipse-&gt;center[0] * wd;</a>
<a name="ln1375">  const float y = points[1] = ellipse-&gt;center[1] * ht;</a>
<a name="ln1376"> </a>
<a name="ln1377">  points[2] = x + a * cos(v);</a>
<a name="ln1378">  points[3] = y + a * sin(v);</a>
<a name="ln1379">  points[4] = x - a * cos(v);</a>
<a name="ln1380">  points[5] = y - a * sin(v);</a>
<a name="ln1381"> </a>
<a name="ln1382">  points[6] = x + b * cos(v - M_PI / 2.0f);</a>
<a name="ln1383">  points[7] = y + b * sin(v - M_PI / 2.0f);</a>
<a name="ln1384">  points[8] = x - b * cos(v - M_PI / 2.0f);</a>
<a name="ln1385">  points[9] = y - b * sin(v - M_PI / 2.0f);</a>
<a name="ln1386"> </a>
<a name="ln1387">  for(int i = 1; i &lt; l + 5; i++)</a>
<a name="ln1388">  {</a>
<a name="ln1389">    float alpha = (i - 5) * 2.0 * M_PI / (float)l;</a>
<a name="ln1390">    points[i * 2] = points[0] + a * cosf(alpha) * cosv - b * sinf(alpha) * sinv;</a>
<a name="ln1391">    points[i * 2 + 1] = points[1] + a * cosf(alpha) * sinv + b * sinf(alpha) * cosv;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  // and we transform them with all distorted modules</a>
<a name="ln1395">  if(!dt_dev_distort_transform_plus(darktable.develop, piece-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, l + 5))</a>
<a name="ln1396">  {</a>
<a name="ln1397">    free(points);</a>
<a name="ln1398">    return 0;</a>
<a name="ln1399">  }</a>
<a name="ln1400"> </a>
<a name="ln1401">  // now we search min and max</a>
<a name="ln1402">  float xmin, xmax, ymin, ymax;</a>
<a name="ln1403">  xmin = ymin = FLT_MAX;</a>
<a name="ln1404">  xmax = ymax = FLT_MIN;</a>
<a name="ln1405">  for(int i = 1; i &lt; l + 5; i++)</a>
<a name="ln1406">  {</a>
<a name="ln1407">    xmin = fminf(points[i * 2], xmin);</a>
<a name="ln1408">    xmax = fmaxf(points[i * 2], xmax);</a>
<a name="ln1409">    ymin = fminf(points[i * 2 + 1], ymin);</a>
<a name="ln1410">    ymax = fmaxf(points[i * 2 + 1], ymax);</a>
<a name="ln1411">  }</a>
<a name="ln1412">  free(points);</a>
<a name="ln1413">  // and we set values</a>
<a name="ln1414">  *posx = xmin;</a>
<a name="ln1415">  *posy = ymin;</a>
<a name="ln1416">  *width = (xmax - xmin);</a>
<a name="ln1417">  *height = (ymax - ymin);</a>
<a name="ln1418">  return 1;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">static int dt_ellipse_get_area(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln1422">                               int *width, int *height, int *posx, int *posy)</a>
<a name="ln1423">{</a>
<a name="ln1424">  // we get the ellipse values</a>
<a name="ln1425">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1426"> </a>
<a name="ln1427">  const float wd = piece-&gt;pipe-&gt;iwidth, ht = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1428"> </a>
<a name="ln1429">  const float total[2] = { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wd, ht),</a>
<a name="ln1430">                           (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wd, ht) };</a>
<a name="ln1431">  const float v1 = ((ellipse-&gt;rotation) / 180.0f) * M_PI;</a>
<a name="ln1432">  const float v2 = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1433">  float a, b, v;</a>
<a name="ln1434"> </a>
<a name="ln1435">  if(total[0] &gt;= total[1])</a>
<a name="ln1436">  {</a>
<a name="ln1437">    a = total[0];</a>
<a name="ln1438">    b = total[1];</a>
<a name="ln1439">    v = v1;</a>
<a name="ln1440">  }</a>
<a name="ln1441">  else</a>
<a name="ln1442">  {</a>
<a name="ln1443">    a = total[1];</a>
<a name="ln1444">    b = total[0];</a>
<a name="ln1445">    v = v2;</a>
<a name="ln1446">  }</a>
<a name="ln1447"> </a>
<a name="ln1448">  const float sinv = sinf(v);</a>
<a name="ln1449">  const float cosv = cosf(v);</a>
<a name="ln1450"> </a>
<a name="ln1451">  // how many points do we need ?</a>
<a name="ln1452">  const float lambda = (a - b) / (a + b);</a>
<a name="ln1453">  const int l = (int)(M_PI * (a + b)</a>
<a name="ln1454">                      * (1.0f + (3.0f * lambda * lambda) / (10.0f + sqrtf(4.0f - 3.0f * lambda * lambda))));</a>
<a name="ln1455"> </a>
<a name="ln1456">  // buffer allocations</a>
<a name="ln1457">  float *points = calloc(2 * (l + 5), sizeof(float));</a>
<a name="ln1458"> </a>
<a name="ln1459">  // now we set the points</a>
<a name="ln1460">  const float x = points[0] = ellipse-&gt;center[0] * wd;</a>
<a name="ln1461">  const float y = points[1] = ellipse-&gt;center[1] * ht;</a>
<a name="ln1462"> </a>
<a name="ln1463">  points[2] = x + a * cos(v);</a>
<a name="ln1464">  points[3] = y + a * sin(v);</a>
<a name="ln1465">  points[4] = x - a * cos(v);</a>
<a name="ln1466">  points[5] = y - a * sin(v);</a>
<a name="ln1467"> </a>
<a name="ln1468">  points[6] = x + b * cos(v - M_PI / 2.0f);</a>
<a name="ln1469">  points[7] = y + b * sin(v - M_PI / 2.0f);</a>
<a name="ln1470">  points[8] = x - b * cos(v - M_PI / 2.0f);</a>
<a name="ln1471">  points[9] = y - b * sin(v - M_PI / 2.0f);</a>
<a name="ln1472"> </a>
<a name="ln1473">  for(int i = 5; i &lt; l + 5; i++)</a>
<a name="ln1474">  {</a>
<a name="ln1475">    float alpha = (i - 5) * 2.0 * M_PI / (float)l;</a>
<a name="ln1476">    points[i * 2] = x + a * cosf(alpha) * cosv - b * sinf(alpha) * sinv;</a>
<a name="ln1477">    points[i * 2 + 1] = y + a * cosf(alpha) * sinv + b * sinf(alpha) * cosv;</a>
<a name="ln1478">  }</a>
<a name="ln1479"> </a>
<a name="ln1480">  // and we transform them with all distorted modules</a>
<a name="ln1481">  if(!dt_dev_distort_transform_plus(module-&gt;dev, piece-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, l + 5))</a>
<a name="ln1482">  {</a>
<a name="ln1483">    free(points);</a>
<a name="ln1484">    return 0;</a>
<a name="ln1485">  }</a>
<a name="ln1486"> </a>
<a name="ln1487">  // now we search min and max</a>
<a name="ln1488">  float xmin, xmax, ymin, ymax;</a>
<a name="ln1489">  xmin = ymin = FLT_MAX;</a>
<a name="ln1490">  xmax = ymax = FLT_MIN;</a>
<a name="ln1491">  for(int i = 5; i &lt; l + 5; i++)</a>
<a name="ln1492">  {</a>
<a name="ln1493">    xmin = fminf(points[i * 2], xmin);</a>
<a name="ln1494">    xmax = fmaxf(points[i * 2], xmax);</a>
<a name="ln1495">    ymin = fminf(points[i * 2 + 1], ymin);</a>
<a name="ln1496">    ymax = fmaxf(points[i * 2 + 1], ymax);</a>
<a name="ln1497">  }</a>
<a name="ln1498">  free(points);</a>
<a name="ln1499"> </a>
<a name="ln1500">  // and we set values</a>
<a name="ln1501">  *posx = xmin;</a>
<a name="ln1502">  *posy = ymin;</a>
<a name="ln1503">  *width = (xmax - xmin);</a>
<a name="ln1504">  *height = (ymax - ymin);</a>
<a name="ln1505">  return 1;</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">static int dt_ellipse_get_mask(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece, dt_masks_form_t *form,</a>
<a name="ln1509">                               float **buffer, int *width, int *height, int *posx, int *posy)</a>
<a name="ln1510">{</a>
<a name="ln1511">  double start2 = dt_get_wtime();</a>
<a name="ln1512"> </a>
<a name="ln1513">  // we get the area</a>
<a name="ln1514">  if(!dt_ellipse_get_area(module, piece, form, width, height, posx, posy)) return 0;</a>
<a name="ln1515"> </a>
<a name="ln1516">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1517">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse area took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1518">  start2 = dt_get_wtime();</a>
<a name="ln1519"> </a>
<a name="ln1520">  // we get the ellipse values</a>
<a name="ln1521">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1522"> </a>
<a name="ln1523">  // we create a buffer of points with all points in the area</a>
<a name="ln1524">  int w = *width, h = *height;</a>
<a name="ln1525">  float *points = malloc(w * h * 2 * sizeof(float));</a>
<a name="ln1526">  for(int i = 0; i &lt; h; i++)</a>
<a name="ln1527">    for(int j = 0; j &lt; w; j++)</a>
<a name="ln1528">    {</a>
<a name="ln1529">      points[(i * w + j) * 2] = (j + (*posx));</a>
<a name="ln1530">      points[(i * w + j) * 2 + 1] = (i + (*posy));</a>
<a name="ln1531">    }</a>
<a name="ln1532"> </a>
<a name="ln1533">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1534">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse draw took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1535">  start2 = dt_get_wtime();</a>
<a name="ln1536"> </a>
<a name="ln1537">  // we back transform all this points</a>
<a name="ln1538">  if(!dt_dev_distort_backtransform_plus(module-&gt;dev, piece-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points, w * h))</a>
<a name="ln1539">  {</a>
<a name="ln1540">    free(points);</a>
<a name="ln1541">    return 0;</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1545">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse transform took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln1546">             dt_get_wtime() - start2);</a>
<a name="ln1547">  start2 = dt_get_wtime();</a>
<a name="ln1548"> </a>
<a name="ln1549">  // we allocate the buffer</a>
<a name="ln1550">  *buffer = calloc(w * h, sizeof(float));</a>
<a name="ln1551"> </a>
<a name="ln1552">  // we populate the buffer</a>
<a name="ln1553">  const int wi = piece-&gt;pipe-&gt;iwidth, hi = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1554">  const float center[2] = { ellipse-&gt;center[0] * wi, ellipse-&gt;center[1] * hi };</a>
<a name="ln1555">  const float radius[2] = { ellipse-&gt;radius[0] * MIN(wi, hi), ellipse-&gt;radius[1] * MIN(wi, hi) };</a>
<a name="ln1556">  const float total[2] =  { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wi, hi),</a>
<a name="ln1557">                            (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wi, hi) };</a>
<a name="ln1558"> </a>
<a name="ln1559">  float a, b, ta, tb, alpha;</a>
<a name="ln1560"> </a>
<a name="ln1561">  if(radius[0] &gt;= radius[1])</a>
<a name="ln1562">  {</a>
<a name="ln1563">    a = radius[0];</a>
<a name="ln1564">    b = radius[1];</a>
<a name="ln1565">    ta = total[0];</a>
<a name="ln1566">    tb = total[1];</a>
<a name="ln1567">    alpha = (ellipse-&gt;rotation / 180.0f) * M_PI;</a>
<a name="ln1568">  }</a>
<a name="ln1569">  else</a>
<a name="ln1570">  {</a>
<a name="ln1571">    a = radius[1];</a>
<a name="ln1572">    b = radius[0];</a>
<a name="ln1573">    ta = total[1];</a>
<a name="ln1574">    tb = total[0];</a>
<a name="ln1575">    alpha = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1576">  }</a>
<a name="ln1577"> </a>
<a name="ln1578">  for(int i = 0; i &lt; h; i++)</a>
<a name="ln1579">    for(int j = 0; j &lt; w; j++)</a>
<a name="ln1580">    {</a>
<a name="ln1581">      float x = points[(i * w + j) * 2] - center[0];</a>
<a name="ln1582">      float y = points[(i * w + j) * 2 + 1] - center[1];</a>
<a name="ln1583">      float v = atan2(y, x) - alpha;</a>
<a name="ln1584">      float cosv = cos(v);</a>
<a name="ln1585">      float sinv = sin(v);</a>
<a name="ln1586">      float radius2 = a * a * b * b / (a * a * sinv * sinv + b * b * cosv * cosv);</a>
<a name="ln1587">      float total2 = ta * ta * tb * tb / (ta * ta * sinv * sinv + tb * tb * cosv * cosv);</a>
<a name="ln1588">      float l2 = x * x + y * y;</a>
<a name="ln1589"> </a>
<a name="ln1590">      if(l2 &lt; radius2)</a>
<a name="ln1591">        (*buffer)[i * w + j] = 1.0f;</a>
<a name="ln1592">      else if(l2 &lt; total2)</a>
<a name="ln1593">      {</a>
<a name="ln1594">        float f = (total2 - l2) / (total2 - radius2);</a>
<a name="ln1595">        (*buffer)[i * w + j] = f * f;</a>
<a name="ln1596">      }</a>
<a name="ln1597">      else</a>
<a name="ln1598">        (*buffer)[i * w + j] = 0.0f;</a>
<a name="ln1599">    }</a>
<a name="ln1600">  free(points);</a>
<a name="ln1601"> </a>
<a name="ln1602">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1603">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse fill took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1604">//   start2 = dt_get_wtime();</a>
<a name="ln1605"> </a>
<a name="ln1606">  return 1;</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609"> </a>
<a name="ln1610">static int dt_ellipse_get_mask_roi(dt_iop_module_t *module, dt_dev_pixelpipe_iop_t *piece,</a>
<a name="ln1611">                                   dt_masks_form_t *form, const dt_iop_roi_t *roi, float *buffer)</a>
<a name="ln1612">{</a>
<a name="ln1613">  double start2 = dt_get_wtime();</a>
<a name="ln1614"> </a>
<a name="ln1615">  // we get the ellipse values</a>
<a name="ln1616">  dt_masks_point_ellipse_t *ellipse = (dt_masks_point_ellipse_t *)(g_list_first(form-&gt;points)-&gt;data);</a>
<a name="ln1617"> </a>
<a name="ln1618">  // we create a buffer of mesh points for later interpolation. mainly in order to reduce memory footprint</a>
<a name="ln1619">  const int w = roi-&gt;width;</a>
<a name="ln1620">  const int h = roi-&gt;height;</a>
<a name="ln1621">  const int px = roi-&gt;x;</a>
<a name="ln1622">  const int py = roi-&gt;y;</a>
<a name="ln1623">  const float iscale = 1.0f / roi-&gt;scale;</a>
<a name="ln1624">  const int mesh = 4;</a>
<a name="ln1625">  const int mw = (w + mesh - 1) / mesh + 1;</a>
<a name="ln1626">  const int mh = (h + mesh - 1) / mesh + 1;</a>
<a name="ln1627"> </a>
<a name="ln1628">  float *points = malloc((size_t)mw * mh * 2 * sizeof(float));</a>
<a name="ln1629">  if(points == NULL) return 0;</a>
<a name="ln1630"> </a>
<a name="ln1631">#ifdef _OPENMP</a>
<a name="ln1632">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln1633">#pragma omp parallel for default(none) \</a>
<a name="ln1634">  dt_omp_firstprivate(iscale, mh, mw, py, px, mesh) \</a>
<a name="ln1635">  shared(points)</a>
<a name="ln1636">#else</a>
<a name="ln1637">#pragma omp parallel for shared(points)</a>
<a name="ln1638">#endif</a>
<a name="ln1639">#endif</a>
<a name="ln1640">  for(int j = 0; j &lt; mh; j++)</a>
<a name="ln1641">    for(int i = 0; i &lt; mw; i++)</a>
<a name="ln1642">    {</a>
<a name="ln1643">      size_t index = (size_t)j * mw + i;</a>
<a name="ln1644">      points[index * 2] = (mesh * i + px) * iscale;</a>
<a name="ln1645">      points[index * 2 + 1] = (mesh * j + py) * iscale;</a>
<a name="ln1646">    }</a>
<a name="ln1647"> </a>
<a name="ln1648">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1649">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse draw took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1650">  start2 = dt_get_wtime();</a>
<a name="ln1651"> </a>
<a name="ln1652">  // we back transform all these points</a>
<a name="ln1653">  if(!dt_dev_distort_backtransform_plus(module-&gt;dev, piece-&gt;pipe, module-&gt;iop_order, DT_DEV_TRANSFORM_DIR_BACK_INCL, points,</a>
<a name="ln1654">                                        (size_t)mw * mh))</a>
<a name="ln1655">  {</a>
<a name="ln1656">    free(points);</a>
<a name="ln1657">    return 0;</a>
<a name="ln1658">  }</a>
<a name="ln1659"> </a>
<a name="ln1660">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1661">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse transform took %0.04f sec\n&quot;, form-&gt;name,</a>
<a name="ln1662">             dt_get_wtime() - start2);</a>
<a name="ln1663">  start2 = dt_get_wtime();</a>
<a name="ln1664"> </a>
<a name="ln1665">  // we populate the buffer</a>
<a name="ln1666">  const int wi = piece-&gt;pipe-&gt;iwidth, hi = piece-&gt;pipe-&gt;iheight;</a>
<a name="ln1667">  const float center[2] = { ellipse-&gt;center[0] * wi, ellipse-&gt;center[1] * hi };</a>
<a name="ln1668">  const float radius[2] = { ellipse-&gt;radius[0] * MIN(wi, hi), ellipse-&gt;radius[1] * MIN(wi, hi) };</a>
<a name="ln1669">  const float total[2] = { (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[0] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[0] + ellipse-&gt;border) * MIN(wi, hi),</a>
<a name="ln1670">                           (ellipse-&gt;flags &amp; DT_MASKS_ELLIPSE_PROPORTIONAL ? ellipse-&gt;radius[1] * (1.0f + ellipse-&gt;border) : ellipse-&gt;radius[1] + ellipse-&gt;border) * MIN(wi, hi) };</a>
<a name="ln1671"> </a>
<a name="ln1672">  float a, b, ta, tb, alpha;</a>
<a name="ln1673"> </a>
<a name="ln1674">  if(radius[0] &gt;= radius[1])</a>
<a name="ln1675">  {</a>
<a name="ln1676">    a = radius[0];</a>
<a name="ln1677">    b = radius[1];</a>
<a name="ln1678">    ta = total[0];</a>
<a name="ln1679">    tb = total[1];</a>
<a name="ln1680">    alpha = (ellipse-&gt;rotation / 180.0f) * M_PI;</a>
<a name="ln1681">  }</a>
<a name="ln1682">  else</a>
<a name="ln1683">  {</a>
<a name="ln1684">    a = radius[1];</a>
<a name="ln1685">    b = radius[0];</a>
<a name="ln1686">    ta = total[1];</a>
<a name="ln1687">    tb = total[0];</a>
<a name="ln1688">    alpha = ((ellipse-&gt;rotation - 90.0f) / 180.0f) * M_PI;</a>
<a name="ln1689">  }</a>
<a name="ln1690"> </a>
<a name="ln1691">#ifdef _OPENMP</a>
<a name="ln1692">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln1693">#pragma omp parallel for default(none) \</a>
<a name="ln1694">  dt_omp_firstprivate(center, mh, mw) \</a>
<a name="ln1695">  shared(points, a, b, ta, tb, alpha)</a>
<a name="ln1696">#else</a>
<a name="ln1697">#pragma omp parallel for shared(points, a, b, ta, tb, alpha)</a>
<a name="ln1698">#endif</a>
<a name="ln1699">#endif</a>
<a name="ln1700">  for(int i = 0; i &lt; mh; i++)</a>
<a name="ln1701">    for(int j = 0; j &lt; mw; j++)</a>
<a name="ln1702">    {</a>
<a name="ln1703">      size_t index = (size_t)i * mw + j;</a>
<a name="ln1704">      float x = points[index * 2] - center[0];</a>
<a name="ln1705">      float y = points[index * 2 + 1] - center[1];</a>
<a name="ln1706">      float v = atan2(y, x) - alpha;</a>
<a name="ln1707">      float cosv = cos(v);</a>
<a name="ln1708">      float sinv = sin(v);</a>
<a name="ln1709">      float radius2 = a * a * b * b / (a * a * sinv * sinv + b * b * cosv * cosv);</a>
<a name="ln1710">      float total2 = ta * ta * tb * tb / (ta * ta * sinv * sinv + tb * tb * cosv * cosv);</a>
<a name="ln1711">      float l2 = x * x + y * y;</a>
<a name="ln1712"> </a>
<a name="ln1713">      if(l2 &lt; radius2)</a>
<a name="ln1714">        points[index * 2] = 1.0f;</a>
<a name="ln1715">      else if(l2 &lt; total2)</a>
<a name="ln1716">      {</a>
<a name="ln1717">        float f = (total2 - l2) / (total2 - radius2);</a>
<a name="ln1718">        points[index * 2] = f * f;</a>
<a name="ln1719">      }</a>
<a name="ln1720">      else</a>
<a name="ln1721">        points[index * 2] = 0.0f;</a>
<a name="ln1722">    }</a>
<a name="ln1723"> </a>
<a name="ln1724">// we fill the output buffer by interpolation</a>
<a name="ln1725">#ifdef _OPENMP</a>
<a name="ln1726">#if !defined(__SUNOS__) &amp;&amp; !defined(__NetBSD__)</a>
<a name="ln1727">#pragma omp parallel for default(none) \</a>
<a name="ln1728">  dt_omp_firstprivate(h, mw, w, mesh) \</a>
<a name="ln1729">  shared(points, buffer)</a>
<a name="ln1730">#else</a>
<a name="ln1731">#pragma omp parallel for shared(points, buffer)</a>
<a name="ln1732">#endif</a>
<a name="ln1733">#endif</a>
<a name="ln1734">  for(int j = 0; j &lt; h; j++)</a>
<a name="ln1735">  {</a>
<a name="ln1736">    int jj = j % mesh;</a>
<a name="ln1737">    int mj = j / mesh;</a>
<a name="ln1738">    for(int i = 0; i &lt; w; i++)</a>
<a name="ln1739">    {</a>
<a name="ln1740">      int ii = i % mesh;</a>
<a name="ln1741">      int mi = i / mesh;</a>
<a name="ln1742">      size_t mindex = (size_t)mj * mw + mi;</a>
<a name="ln1743">      buffer[(size_t)j * w + i]</a>
<a name="ln1744">          = (points[mindex * 2] * (mesh - ii) * (mesh - jj) + points[(mindex + 1) * 2] * ii * (mesh - jj)</a>
<a name="ln1745">             + points[(mindex + mw) * 2] * (mesh - ii) * jj + points[(mindex + mw + 1) * 2] * ii * jj)</a>
<a name="ln1746">            / (mesh * mesh);</a>
<a name="ln1747">    }</a>
<a name="ln1748">  }</a>
<a name="ln1749"> </a>
<a name="ln1750">  free(points);</a>
<a name="ln1751"> </a>
<a name="ln1752"> </a>
<a name="ln1753">  if(darktable.unmuted &amp; DT_DEBUG_PERF)</a>
<a name="ln1754">    dt_print(DT_DEBUG_MASKS, &quot;[masks %s] ellipse fill took %0.04f sec\n&quot;, form-&gt;name, dt_get_wtime() - start2);</a>
<a name="ln1755">//   start2 = dt_get_wtime();</a>
<a name="ln1756"> </a>
<a name="ln1757">  return 1;</a>
<a name="ln1758">}</a>
<a name="ln1759"> </a>
<a name="ln1760"> </a>
<a name="ln1761"> </a>
<a name="ln1762">// modelines: These editor modelines have been set for all relevant files by tools/update_modelines.sh</a>
<a name="ln1763">// vim: shiftwidth=2 expandtab tabstop=2 cindent</a>
<a name="ln1764">// kate: tab-indents: off; indent-width 2; replace-tabs on; indent-mode cstyle; remove-trailing-spaces modified;</a>

</code></pre>
<div class="balloon" rel="614"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'ellipse'. Check lines: 614, 607.</p></div>
<div class="balloon" rel="1131"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'points' pointer was utilized before it was verified against nullptr. Check lines: 1131, 1153.</p></div>
<div class="balloon" rel="1139"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'border' pointer was utilized before it was verified against nullptr. Check lines: 1139, 1154.</p></div>
<div class="balloon" rel="1374"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'points'. Check lines: 1374, 1371.</p></div>
<div class="balloon" rel="1460"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'points'. Check lines: 1460, 1457.</p></div>
<div class="balloon" rel="1529"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'points'. Check lines: 1529, 1525.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
